[{"title":"riscv kvm guest os reboot 后挂死问题","url":"/2024/02/12/hxd_new/虚拟化/debug/riscv kvm guest os reboot 后挂死问题/","content":"\n问题:\n在 guest shell 中发起 reboot, guest os 完成关机后挂死.\nguest os 无 log 输出, kvm 无异常 log.\n\n```shell\nThe system is going down NOW!\nSent SIGTERM to all processes\nlogout\nSent SIGKILL to all processes\nRequesting system reboot\n\n\n\n\n```\n\n从现象上看, 首先需要查 vcpu 在 kvm 中的调度是否正常.\n需要的关键信息即 vcpu 的信息.\n\n# Guest 运行情况\n\n通过 vcpu->arch. Guest_csr 和 vcpu->arch. Guest_context 可以得到 guest 陷入到 kvm 前的 csr 和通用寄存器状态.\n\n```shell\n    guest_csr = {\n      vsstatus = 0x200000020,\n      vsie = 0x222,\n      vstvec = 0xffffffff800031f4,\n      vsscratch = 0x0,\n      vsepc = 0xffffffff805b107a,\n      vscause = 0x8000000000000005,\n      vstval = 0x0,\n      hvip = 0x0,\n      vsatp = 0xa000100000082924,\n      scounteren = 0x7\n    },\n```\n\n如果 host kernel 和 guest kernel 使用的同一份 Image, 其虚拟地址映射的符号应该是一致的, 因为 kernel va 的映射起始地址是一样的.\n如果 host kernel 和 guest kernel 使用的 Image 不同, 可以查看 qemu 映射的 memory-layout\n\nQemu 命令行  ctrl+a+c, 切换到 qemu 命令行\n```c\n# info mtree\n0000000080000000-0000000087ffffff (prio 0, ram): riscv_virt_board.ram \"GPA 地址\"\n```\n\nKernel 的 log\n```shell\n[    0.000000] Virtual kernel memory layout:\n[    0.000000]       fixmap : 0xff1bfffffea00000 - 0xff1bffffff000000   (6144 kB)\n[    0.000000]       pci io : 0xff1bffffff000000 - 0xff1c000000000000   (  16 MB)\n[    0.000000]      vmemmap : 0xff1c000000000000 - 0xff20000000000000   (1024 TB)\n[    0.000000]      vmalloc : 0xff20000000000000 - 0xff60000000000000   (16384 TB)\n[    0.000000]      modules : 0xffffffff019c7000 - 0xffffffff80000000   (2022 MB)\n[    0.000000]       lowmem : 0xff60000000000000 - 0xff60000008000000   ( 128 MB)\n[    0.000000]       kernel : 0xffffffff80000000 - 0xffffffffffffffff   (2047 MB)\n```\n\n对照 kernel 编译的 System. Map 即可找到 gva 对应的函数符号\n\n> qemu-kvm 框架下并不支持 kernel 的调试, 可以先通过 dump 手段将 guest kernel 的运行的 coredump 导出.\n\n## Qemu 生成 coredump\n\n通过 qemu 命令行生成 guest kernel 的 coredump.\n\nCtrl+a+c 打开 qemu 命令行\n```shell\n# 生成coredump文件为 core.file\ndump-guest-memory core.file\n```\nGdb 调试 coredump\n```shell\nriscv64-unknown-linux-gnu-gdb -ex \"core guest.core\" -ex \"file virt_build/vmlinux\"\n```\n\n从 coredump 后发现, pc 还停在 `0x80000000` 处, 怀疑是 reboot 后还没有 poweron. \n另外 guest_csr 的 vsepc 与该处的 pc 值不同也说明了这一点.\n\n需要分析代码流程及 vcpu task 挂死后 vcpu 数据的分析\n为了方便后面分析, 需要先梳理下怎么在 kernel 的运行信息中找到 vcpu 的数据, 包括在线场景和离线场景.\n\n# 找到 vcpu 数据\n\n从 qemu 的 info cpus 找到其 vcpu 绑定的线程 id\n```shell\n(qemu) info cpus\n* CPU #0: thread_id=142\n```\n\n\n## 从 Per-cpu 变量 kvm_running_vcpu 找到 vcpu\n\n在 kvm 中, 当前 cpu 的运行的 vcpu 数据被写到了 Per-cpu 变量 kvm_running_vcpu 中.\nhost 中找到 kvm_running_vcpu 的地址 (全局变量, 其他 cpu 上都是一样的)\n```shell\np/x &kvm_running_vcpu\n$1 = 0xffffffff80c19390\n```\n\nhost 中找到 `__per_cpu_offset`\n```shell\np/x __per_cpu_offset\n$2 = {[0x0] = 0xff6000013e397000, [0x1] = 0xff6000013e3aa000, [0x2] = 0x0 <repeats 62 times>}\n```\n\n找到 cpu 0 上的kvm_running_vcpu 的 vcpu 数据\n\n```shell\nc 0xffffffff80c19390+0xff6000013e397000 = 0xff600000befb0390\nx/a 0xff600000befb0390\n>>> x/a 0xff600000befb0390\n0xff600000befb0390:     0x0\n```\n\n同理找到 cpu 1 上的 kvm_running_vcpu 的 vcpu\n\n```shell\nc 0xffffffff80c19390+0xff6000013e3aa000 = 0xff600000befc3390\n>>> x/a 0xff600000befc3390\n0xff600000befc3390:     0xff60000080120000\n```\n\n可知 vcpu 运行在 cpu 1 上.\n查看 vcpu 的数据\n```c\n>>> p (*(struct kvm_vcpu*)0xff60000080120000)->stats_id\n$7 = \"kvm-142/vcpu-0\", '\\000' <repeats 33 times> \"stats_id 与 info cpus 查看的信息一致\"\n\n>>> p (*(struct kvm_vcpu*)0xff60000080120000)->arch  \"查看arch riscv 数据\"\npower_off = true,\npause = false,\n\n>>> p *((*(struct kvm_vcpu*)0xff60000080120000)->wait->task) \"vcpu->wait->task  vcpu 所在的task\"\n__state = 0x1,                  \"TASK_INTERRUPTIBLE\"\non_cpu = 1,\nprio = 120,\npid = 142\n\n>>> p ((*(struct kvm_vcpu*)0xff60000080120000)->wait->task->pid)\npid = 142\n\n>>> p ((*(struct kvm_vcpu*)0xff60000080120000)->wait->task->thread)\n  thread = {\n    ra = 0xffffffff8084d530,\n    sp = 0xff200000008d3c90,\n\t...\n  }\n```\n\n\n## 从 file 中导出 vcpu 信息\n\n在 vcpu task 未调度时, kvm_running_vcpu 并不会保存 vcpu 的地址信息.\n在这种情况下, 还需要从其他数据结构中导出 vcpu 的地址.\n\nKernel 未保存全局的 kvm 变量, 也未保存全局的 vcpu 的信息, 但是 qemu 进程保存了打开的文件的信息.\n从之前调研 kvm guest vm 及 vcpu 的创建及开机过程, 可知 qemu 打开了两个匿名文件 `kvm-vm` 保存了 kvm 的信息, 打开了 `kvm-vcpu-x` 保存了 vcpu 的信息, 只要找到 qemu 进程的 task 信息即可顺藤摸瓜找到 vm 及 vcpu 的数据.\n\n通过 qemu 进程打开的 `kvm-vm` 匿名文件和 `kvm-vcpu:0` vcpu 的匿名文件反向追踪到 file 结构体\n`ps` 或 top 查询到 qemu 的主线程\n```shell\nls -l /proc/131/fd\nlrwx------    1 root     root            64 Jun  1 02:49 0 -> /dev/pts/0\nlrwx------    1 root     root            64 Jun  1 02:49 1 -> /dev/pts/0\nlrwx------    1 root     root            64 Jun  1 02:49 10 -> /dev/kvm\nlrwx------    1 root     root            64 Jun  1 02:49 11 -> anon_inode:kvm-vm\nlrwx------    1 root     root            64 Jun  1 02:49 12 -> anon_inode:kvm-vcpu:0\nlrwx------    1 root     root            64 Jun  1 02:49 13 -> /root/rootfs.ext2\nlrwx------    1 root     root            64 Jun  1 02:49 14 -> anon_inode:[eventfd]\n```\n\n可以看到 11 号为 `kvm-vm` 的 fd. 12 号为 ` kvm-vcpu:0 ` 的 fd\n在离线场景中, 或客户提供的 log 中, 查看该信息, 找到 kvm 的 fd. 找到 vcpu 的 fd.\n找到 qemu 对应的 task 结构体\n\n## 通过 Kernel gdb-script 找到 vm\n\nMake scripts_gdb\n\nGdb 调试时加入\n`add-auto-load-safe-path </path/to/linux-build>`\n`source </path/to/linux-build>/vmlinux-gdb.py `\n\n在 `kvm_running_vcpu` per-cpu 变量为空时, 即所有 vcpu 未运行时, 可以通过 `vmlinux-gdb.py` 提供的 `lx_task_by_pid` 函数找到对应的 task 数据\n```shell\n>>> apropos lx \"help信息\"\n>>> lx-ps \"打印所有的task, 找到qemu 主进程 pid\"\n>>> p $lx_task_by_pid(140) \"打印 qemu 主线程task\"\n```\n>  `lx-ps` 是通过 `init_task.tasks.next` 链表找出的所有的 task 信息, next 为 list_head tasks 成员变量, 由 container_of 通过 list_head 类型的 tasks 变量地址找到对应的 task 结构体, list_head 成员变量在 task 结构体的偏移可以通过 init_task. Tasks 的地址减去 init_task 的地址得到.\n\n```shell\n# 可以通过如下的方法索引出所有的task\n>>> p &init_task.tasks\n$5 = (struct list_head *) 0xffffffff8140de28 <init_task+872>\n>>> p &init_task\n$6 = (struct task_struct *) 0xffffffff8140dac0 <init_task>\n>>> p (*(struct task_struct*)(0xff60000080098368-872))->tasks\n$8 = {\n  next = 0xff60000080098f28,\n  prev = 0xffffffff8140de28 <init_task+872>\n}\n>>> p (*(struct task_struct*)(0xff60000080098f28-872))->tasks\n...\n```\n\n根据 qemu 主线程 task 的 files 找到对应的打开的 \"kvm-vm\" 的 file 结构体\n```shell\n>>> p $lx_task_by_pid(140).files.fdtab.fd\n```\n\n通过 `f_op` 确定是 \"/dev/kvm\"的 file 结构体, f_op 为 `kvm_vm_fops`\n```shell\n>>> p (*(struct file*)($lx_task_by_pid(140).files.fdtab.fd[11])).f_op\n$76 = (const file_operations *) 0xffffffff80e02708 <kvm_vm_fops>\n```\n\n确定后, `file->private_data` 即为 kvm 的地址\n```c\n>>> p (*(struct file*)($lx_task_by_pid(140).files.fdtab.fd[11])).private_data\n$77 = (void *) 0xff60000080fde000\n```\n\nKernel 中通过 kvm 遍历 vcpu\n```c\n#define kvm_for_each_vcpu(idx, vcpup, kvm)\t\t   \\\n\txa_for_each_range(&kvm->vcpu_array, idx, vcpup, 0, \\\n\t\t\t  (atomic_read(&kvm->online_vcpus) - 1))\nkvm_for_each_vcpu(i, vcpu, kvm)\n```\n\n对应 gdb 中通过 kvm 遍历 vcpu 需要看下 kernel 中相关的数据结构\n通过 kvm->vcpu_array->xa_head  找出 vcpu 的数组的 xa_node, 再通过 `node->slots[offset]` 根据 vcpu 的 offset 找到对应的 vcpu. \n```c\n// 通过 kvm->vcpu_array->xa_head  找出vcpu 的数组.\n// xa_head 指针转为 xa_node, 进而找到 xa_node->slots 数组, 根据vcpu offset 找到对应的vcpu 地址.\nstatic inline struct xa_node *xa_to_node(const void *entry)\n{\n\treturn (struct xa_node *)((unsigned long)entry - 2);\n}\n\n>>> p (*(struct kvm*) 0xff60000080fde000)->vcpu_array->xa_head \"定位 kvm->vcpu_array->xa_head\"\n$80 = (void *) 0xff60000080120000\n\"找到所有的 vcpu的地址, 如果只有一个vcpu, 则该 slots 则没有有效项, 只有xa_head 是唯一的vcpu 地址\"\n>>> p (*(struct xa_node*)(0xff60000080120000-2))->slots\n$7 = {[0] = 0, [1] = 0, [2] = 0 ...}\n\"多个vcpu的情况\"\n>>> p (*(struct xa_node*)(0xff600000951d348a-2))->slots\n$7 = {[0] = 0xff60000081368000, [1] = 0xff6000008136a8e0, [2] = 0xff6000008136d1c0, [3] = 0x0 <repeats 61 times>}\n\n>>> p (*(struct kvm_vcpu*)0xff60000081858000)->vcpu_id\n>>> p (*(struct kvm_vcpu*)0xff6000008185a8e0)->stats_id \"通过stats_id 可以找到对应的vcpu 所在的线程id, 及vcpu_fd 的name\"\n$19 = \"kvm-132/vcpu-1\", '\\000' <repeats 33 times>\n```\n\n当然也可直接通过 `kvm-vcpu-x` 的匿名文件的 fd 找到 vcpu\n```shell\n>>> p (*(struct file*)($lx_task_by_pid(140).files.fdtab.fd[12])).f_op\n$76 = (const file_operations *) <addr> <kvm_vcpu_fops> \"通过 kvm_vcpu_fops 证明是vcpufd\"\n>>> p (*(struct file*)($lx_task_by_pid(140).files.fdtab.fd[12])).private_data \"private_data 即保存的vcpu的地址\"\n```\n\n# vcpu task 挂死堆栈分析\n从 vcpu->wait->task->thread 的 sp ra 经过计算后可以推出该 task 切换出去前的堆栈\n\n```c\n>>> p ((*(struct kvm_vcpu*)0xff60000080120000)->wait->task->thread)\n  thread = {\n    ra = 0xffffffff8084d530,\n    sp = 0xff200000008d3c90,\n\t...\n  }\n```\n\n```c\n>>> disassemble 0xffffffff8084d530\nDump of assembler code for function __schedule:\n   0xffffffff8084d292 <+0>:     addi    sp,sp,-128\n   0xffffffff8084d294 <+2>:     sd      s0,112(sp)\n   0xffffffff8084d296 <+4>:     sd      s3,88(sp)\n   0xffffffff8084d298 <+6>:     sd      s5,72(sp)\n   0xffffffff8084d29a <+8>:     sd      s6,64(sp)\n   0xffffffff8084d29c <+10>:    sd      ra,120(sp) \"上一个 ra 存在 sp+120的地方\"\n\n>>> x/a 0xff200000008d3c90+120 \"sp+120\"\n0xff200000008d3d08:     0xffffffff8084d9e8 <schedule+72>\n>>> disass 0xffffffff8084d9e8 \n   0xffffffff8084d9a0 <+0>:     addi    sp,sp,-32\n   0xffffffff8084d9a2 <+2>:     sd      s0,16(sp)\n   0xffffffff8084d9a4 <+4>:     sd      s1,8(sp)\n   0xffffffff8084d9a6 <+6>:     sd      ra,24(sp)\n>>> x/a 0xff200000008d3c90+128+24 \"sp+128+24\"\n0xff200000008d3d28:     0xffffffff80017468 <kvm_arch_vcpu_ioctl_run+888>\n>>> x/16i 0xffffffff80017468-16\nx/16i 0xffffffff80017468-16\n   0xffffffff80017458 <kvm_arch_vcpu_ioctl_run+872>:    ld      a5,0(a4)\n   0xffffffff8001745a <kvm_arch_vcpu_ioctl_run+874>:    srli    a5,a5,0x2\n   0xffffffff8001745c <kvm_arch_vcpu_ioctl_run+876>:    andi    a5,a5,1\n   0xffffffff8001745e <kvm_arch_vcpu_ioctl_run+878>:    bnez    a5,0xffffffff80017394 <kvm_arch_vcpu_ioctl_run+676>\n   0xffffffff80017460 <kvm_arch_vcpu_ioctl_run+880>:    auipc   ra,0x836\n   0xffffffff80017464 <kvm_arch_vcpu_ioctl_run+884>:    jalr    1344(ra)\n-> 0xffffffff80017468 <kvm_arch_vcpu_ioctl_run+888>:    auipc   a3,0x0\n   0xffffffff8001746c <kvm_arch_vcpu_ioctl_run+892>:    addi    a3,a3,-252\n   0xffffffff80017470 <kvm_arch_vcpu_ioctl_run+896>:    j       0xffffffff8001736c <kvm_arch_vcpu_ioctl_run+636>\n   0xffffffff80017472 <kvm_arch_vcpu_ioctl_run+898>:    ebreak\n   0xffffffff80017474 <kvm_arch_vcpu_ioctl_run+900>:    j       0xffffffff800171be <kvm_arch_vcpu_ioctl_run+206>\n   0xffffffff80017476 <kvm_arch_vcpu_ioctl_run+902>:    fence   w,w\n   0xffffffff8001747a <kvm_arch_vcpu_ioctl_run+906>:    li      a5,256\n   0xffffffff8001747e <kvm_arch_vcpu_ioctl_run+910>:    addi    a4,s1,56\n   0xffffffff80017482 <kvm_arch_vcpu_ioctl_run+914>:    amoor.d zero,a5,(a4)\n   0xffffffff80017486 <kvm_arch_vcpu_ioctl_run+918>:    j       0xffffffff800173b0 <kvm_arch_vcpu_ioctl_run+704>\n```\n\n为了比较容易反推堆栈的代码, 可以通过 objdump 打印比较完整的反汇编代码的所在行数.\n```shell\nriscv64-unknown-linux-gnu-objdump -DSrtlFCz vmlinux > vmlinux.full.S\n```\n\n因为 dump 出的反汇编文件非常大, 打开整个文件会很卡, 可以借助 `grep <addr> -B/-A/-C <行数>` 指定搜索的前后文信息:\n\n```c\n❯ grep \"ffffffff80017468\" vmlinux.full.S -C 12\n\tffffffff80017458:       631c                    ld      a5,0(a4)\n\tffffffff8001745a:       8389                    srli    a5,a5,0x2\n\tsignal_pending_state():\n\t/home/liguang/program/riscv-lab/linux/virt_build/../include/linux/sched/signal.h:418\n\t        if (!signal_pending(p))\n\tffffffff8001745c:       8b85                    andi    a5,a5,1\n\tffffffff8001745e:       fb9d                    bnez    a5,ffffffff80017394 <kvm_arch_vcpu_ioctl_run+0x2a4> (File Offset: 0x18394)\n\tkvm_riscv_check_vcpu_requests():\n\t/home/liguang/program/riscv-lab/linux/virt_build/../arch/riscv/kvm/vcpu.c:1043\n\t                        rcuwait_wait_event(wait,\n\tffffffff80017460:       00836097                auipc   ra,0x836\n\tffffffff80017464:       540080e7                jalr    1344(ra) # ffffffff8084d9a0 <schedule> (File Offset: 0x84e9a0)\n->\tffffffff80017468:       00000697                auipc   a3,0x0\n\tffffffff8001746c:       f0468693                addi    a3,a3,-252 # ffffffff8001736c <kvm_arch_vcpu_ioctl_run+0x27c> (File Offset: 0x1836c)\n\tffffffff80017470:       bdf5                    j       ffffffff8001736c <kvm_arch_vcpu_ioctl_run+0x27c> (File Offset: 0x1836c)\n\tsrcu_read_unlock():\n\t/home/liguang/program/riscv-lab/linux/virt_build/../include/linux/srcu.h:285\n\t        WARN_ON_ONCE(idx & ~0x1);\n\tffffffff80017472:       9002                    ebreak\n\tffffffff80017474:       b3a9                    j       ffffffff800171be <kvm_arch_vcpu_ioctl_run+0xce> (File Offset: 0x181be)\n\t__kvm_make_request():\n\t/home/liguang/program/riscv-lab/linux/virt_build/../include/linux/kvm_host.h:2041\n\t        smp_wmb();\n\tffffffff80017476:       0110000f                fence   w,w\n\tset_bit():\n```\n\n最终定位到 vcpu.c:1043 行, 由于默认是 `-Os` 编译, 优化后有些函数调用关系缺失了, 但大概能推出对应的堆栈\n\n```c\n----> schedule(); \"切到了其他进程\"\n---> rcuwait_wait_event(wait,(!vcpu->arch.power_off) && (!vcpu->arch.pause), TASK_INTERRUPTIBLE);  \"调用了 set_current_state(TASK_INTERRUPTIBLE);\"\n--> kvm_riscv_check_vcpu_requests(vcpu); \n-> kvm_arch_vcpu_ioctl_run()\n```\n\n最终落到了下面的 for 循环中. 正常情况下是监听的 condition 状态, condition 是 `vcpu->arch.power_off` 和 `vcpu->arch.pause` 同时为 false 时, 该 for 循环才会退出.\n当前 `vcpu->arch.power_off=true` 是不正常的, 也就是 guest 没有触发过 vcpu 的 poweron, 导致 vcpu 一直处在 `kvm_riscv_check_vcpu_requests` 的 rcu_wait_event 的 for 循环中.\n\n```c\n#define rcuwait_wait_event(w, condition, state)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\t\t\\\n\tprepare_to_rcuwait(w);\t\t\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tset_current_state(state);\t\t\t\t\\\n\t\tif (condition)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (signal_pending_state(state, current)) {\t\t\\\n\t\t\t__ret = -EINTR;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n=>\t\tschedule();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tfinish_rcuwait(w);\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n```\n\n查询 `vcpu->arch.power_off` 的置位情况, 只有 `kvm_riscv_vcpu_power_on` 函数将其置为了 true.\n\n代码逻辑应该是有问题的, guest 重启时发送 sbi 的 SBI_SRST_RESET_TYPE_COLD_REBOOT 陷入 kvm, kvm 处理该 sbi 消息, 将所有 vcpu->arch.power_off 置为 on.\n\n并发送了 `KVM_REQ_SLEEP` 请求, 在该状态检查时, vcpu 是 power_off 状态, 导致一直陷入到 `kvm_riscv_check_vcpu_requests` ` rcu_wait_event(!vcpu->arch.power_off) && (!vcpu->arch.pause)) ` 的 for 循环中, guest 得不到执行, 而 kvm_riscv_vcpu_power_on 这个函数又是 guest sbi ecall 才会调用的函数, 所以 ` vcpu->arch.power_off ` 状态没有机会变为 false.\n\n```shell\n>>> p &vcpu->arch.power_off\n$2 = (bool *) 0xff60000002f4bfc0\n\n>>> p vcpu->wait->task->pid\n$8 = 161\n\"reboot 后 vcpu 被复用\"\nvcpu=0xff60000002f4a8e0\np &vcpu->arch.power_off\n$3 = (bool *) 0xff60000002f4bfc0\n```\n\n## 解决方案\n\n在 qemu 中添加 vcpu power_on 的逻辑, qemu 完成 device reset 后紧接着调用 vcpu 的 power_on 使 vcpu->arch.power_off 回到 false 状态.\n\n添加上述逻辑后遇到的问题:\n- vcpu crash\n- smp crash\n\n### vcpu crash 问题分析解决\n\n先看下 vcpu crash 的问题:\n```shell\n[   53.061320] kvm [129]: fault_addr 0xffffffff80003594 memslot 0x0 stval 0xffffffff80003594\n[   53.061660] kvm [129]: VCPU exit error -95\n[   53.062231] kvm [129]: SEPC=0xffffffff80003594 SSTATUS=0x200004120 HSTATUS=0x2002001c0\n[   53.066559] kvm [129]: SCAUSE=0x14 STVAL=0xffffffff80003594 HTVAL=0x3fffffffe0000d65 HTINST=0x0\nerror: kvm run failed Operation not supported\n pc       ffffffff80003594\n mhartid  0000000000000000\n mstatus  0000000200000120\n mip      0000000000000000\n mie      0000000000000222\n mideleg  0000000000000000\n medeleg  0000000000000000\n mtvec    0000000000000000\n mepc     0000000000000000\n mcause   0000000000000000\n mtval    0000000000000000\n mscratch 0000000000000000\n x0/zero  0000000000000000 x1/ra    ffffffff8003f2a6 x2/sp    ff200000007cbcd0 x3/gp    ffffffff814fd4e8\n x4/tp    ff6000000243de00 x5/t0    ffffffff80843aa8 x6/t1    0000000000000001 x7/t2    52203a746f6f6265\n x8/s0    ff200000007cbce0 x9/s1    ff600000021bcad8 x10/a0   0000000000000000 x11/a1   0000000087000000\n x12/a2   0000000000000000 x13/a3   0000000000000000 x14/a4   0000000000000000 x15/a5   0000000000000000\n x16/a6   0000000000000000 x17/a7   0000000053525354 x18/s2   ffffffffffffffff x19/s3   0000000000000000\n x20/s4   0000000000000000 x21/s5   0000000000008000 x22/s6   0000000000000019 x23/s7   0000000000000000\n x24/s8   0000000000000000 x25/s9   0000000000000000 x26/s10  0000000000000000 x27/s11  0000000000000000\n x28/t3   ff60000001818f00 x29/t4   ff60000001818f00 x30/t5   ff60000001818000 x31/t6   ff200000007cbb58\n```\n\nvcpu 出现 guest insn exception (20 0x14), crash 的 fault_addr 为 `0xffffffff80003594`\n首先这个 fault_addr 是不正常的, 这个地址直接就是 gva, 并没有转换为 gpa, 所以在 kvm 中没有在 memslot 找到对应的 hva.\ngva 为什么没有转换为 gpa, 而 gva 的符号地址落在了 guest kernel 的 `handle_exception` 处, 原因只能是 `vstap` 被清 0 了.\n\n第一点怀疑 vstap 被 kvm 错误置位了, 找出所有 vstap 可能在 kvm 中被改写的地方\n从 vcpu 的调用中追踪 vstap 的改写逻辑发现都是正常的, 而且即使把 vsatp 的改写逻辑去掉, 依然会触发其他异常.\n排除该点怀疑.\n\n第二点怀疑 reset 后 guest_context guest_csr 状态不对, 在 vcpu reset 后第一次进入 guest 地方打点\n\n```shell\np/x (*(struct kvm_vcpu*)0xff60000002cd0000).arch.guest_context\n$25 = {\n  zero = 0x0,\n  ra = 0xffffffff8003f2a6,\n  sp = 0xff200000007cbcd0,\n  gp = 0xffffffff814fd4e8,\n  tp = 0xff60000002424680,\n  t0 = 0xffffffff80843aa8,\n  t1 = 0x1,\n  t2 = 0x52203a746f6f6265,\n  s0 = 0xff200000007cbce0,\n  s1 = 0xff600000021bcad8,\n  a0 = 0x0,\n  a1 = 0x87000000,\n  a2 = 0x0,\n  a3 = 0x0,\n  a4 = 0x0,\n  a5 = 0x0,\n  a6 = 0x0,\n  a7 = 0x53525354,\n  s2 = 0xffffffffffffffff,\n  s3 = 0x0,\n  s4 = 0x0,\n  s5 = 0x8000,\n  s6 = 0x19,\n  s7 = 0x0,\n  s8 = 0x0,\n  s9 = 0x0,\n  s10 = 0x0,\n  s11 = 0x0,\n  t3 = 0xff60000001818f00,\n  t4 = 0xff60000001818f00,\n  t5 = 0xff60000001818000,\n  t6 = 0xff200000007cbb58,\n  sepc = 0x80000000,\n  sstatus = 0x200004120,\n  hstatus = 0x200200180,\n  fp = {\n    f = {\n      f = {[0x0] = 0x0 <repeats 32 times>},\n      fcsr = 0x0\n    },\n    d = {\n      f = {[0x0] = 0x0 <repeats 32 times>},\n      fcsr = 0x0\n    },\n    q = {\n      f = {[0x0] = 0x0 <repeats 64 times>},\n      fcsr = 0x0,\n      reserved = {[0x0] = 0x0, [0x1] = 0x0, [0x2] = 0x0}\n    }\n  }\n}\n>>> p/x (*(struct kvm_vcpu*)0xff60000002cd0000).arch.guest_csr\n$26 = {\n  vsstatus = 0xa00000022,\n  vsie = 0x222,\n  vstvec = 0xffffffff80003594,\n  vsscratch = 0x0,\n  vsepc = 0xffffffff8006d566,\n  vscause = 0x8000000000000005,\n  vstval = 0x0,\n  hvip = 0x0,\n  vsatp = 0x0,\n  scounteren = 0x7\n}\n```\n\n通过上面寄存器的状态, 可以明显发现异常, 通用寄存器的状态不对, v* 开头的 csr 状态也不对, vstvec 和报错的栈正好对上, 而 guest_context.sepc 是 guest kernel reset 开始执行的代码地址.\n可以充分怀疑是 vcpu 的通用寄存器和 v* 开头的 csr 状态没有重置导致了 vcpu reset 上电后状态是错乱的, guest kernel reset 后还未建页表时触发了 guest insn exception 走到了 vstvec, 从而陷入了 kvm, htval/stval 的地址因为此时 vstap 还是 0, 所以直接报的 gva 地址.\n\n为什么 vcpu 的寄存器在 reset 后没有复位? kvm 中因为 vcpu 复用, 没走销毁的流程, 而是在 reset 中的关机阶段 power_off 了, vcpu 仅仅不进行调度, kvm 从 vcpu 的 task 切换到了其他进程.\nvcpu 的寄存器还保留了 vcpu 关机前的状态, kvm 并没有处置的理由, 应该由 qemu 告诉 kvm vcpu 何时完成重置的.\n\n梳理 qemu vm 重置的逻辑: (分先后顺序)\n- rom 的重置\n- ram 状态的重置\n- 外设状态的重置\n- cpu 的重置\nqemu 中的各实例调用 `qemu_register_reset` 注册 reset 的 callback, qemu 在 ioctl(vcpufd, KVM_RUN) 调用结束后收到 kvm 的退出原因 `KVM_SYSTEM_EVENT_RESET`, 进而触发了 `qemu_system_reset->qemu_devices_reset` 触发各实例注册的 reset callback.\n\n在 cpu 的重置中, \nriscv 的调用链:\n\nriscv_harts_cpu_reset->cpu_reset->riscv_cpu_reset->kvm_riscv_reset_vcpu\n首先 riscv_hart_realize 中通过 qemu_register_reset 注册了 riscv_harts_cpu_reset 的 reset callback\n该 callback 调用了 CPU_CLASS 的 cpu_reset\n而 `RISCVCPUClass` 在 class 初始化时注册了 parent class `CPUClass` 的 cpu_reset 的接口为 `riscv_cpu_reset`\n`device_class_set_parent_reset(dc, riscv_cpu_reset, &mcc->parent_reset);`\n\n在开启 kvm 后, 最终通过 kvm_riscv_reset_vcpu 重置了 qemu 保存的 vcpu 的寄存器状态, 但这里只重置了 sepc a0 a1 vstap. 这明显是有问题的.\n在 cpu 状态重置完后, 通过 `cpu_synchronize_all_post_reset` 最终调用 kvm_arch_put_registers 将重置后的 vcpu 的寄存器状态通过 ioctl(KVM_SET_ONE_REG) 设置回了 kvm 的 vcpu 中.\n\n这里只需要修改 qemu 的 `kvm_riscv_reset_vcpu` 函数将所有的通用寄存器和 v 开头的寄存器重置即可.\n\n### smp crash 分析解决\n\n分析 riscv 的启动过程, 只有 boot_hart 在 reset 后需要立即上电, 其他 vcpu 是走的 sbi 的接口最终调用 `kvm_riscv_vcpu_power_on` 上电的\n这里只需要修改 qemu 的流程, 在 reset 最后由 qemu 发起 vcpu 上电的流程中判断 vcpu 的 index, 只对 boot_hart 上电即可.\n\n### System_reset 导致的 crash\n\n方案修改完后, 在测试时, 需要对其他场景进行测试.\n虚拟机的重启行为不仅有 guest shell 内自己调用 reboot 进行重启, 更重要的还有虚拟机管理软件上提供的重启功能 (界面上的重启按钮等)\n对 qemu 而言, 最终都会调到其 `system_reset` command.\n\n测试发现, smp 场景下, system_reset 后, kvm 出现 crash, 而单核场景下 kvm 不会出现 crash.\n对比发现, 不是修改引入.\n\n```shell\n[   53.739556] kvm [150]: VCPU exit error -95\n[   53.739563] kvm [148]: VCPU exit error -95\n[   53.739557] kvm [149]: VCPU exit error -95\n[   53.740957] kvm [149]: SEPC=0x0 SSTATUS=0x200004120 HSTATUS=0x2002001c0\n[   53.740957] kvm [148]: SEPC=0x0 SSTATUS=0x200004120 HSTATUS=0x2002001c0\n[   53.741054] kvm [148]: SCAUSE=0x14 STVAL=0x0 HTVAL=0x0 HTINST=0x0\n[   53.741058] kvm [149]: SCAUSE=0x14 STVAL=0x0 HTVAL=0x0 HTINST=0x0\n[   53.756187] kvm [150]: SEPC=0x0 SSTATUS=0x200004120 HSTATUS=0x2002001c0\n[   53.757797] kvm [150]: SCAUSE=0x14 STVAL=0x0 HTVAL=0x0 HTINST=0x0\n```\n\n那这个该怎么解释呢? 联想之前的 smp 场景的问题, 怀疑点仍然是 kvm 内部的 vcpu->arch.power_off 状态出问题了.\n\n通过 qemu 下发 system_reset 与 guest 内部 shell 执行 reboot 有什么区别呢, 为什么上述方案不能解决 qemu system_reset 导致的重启呢?\n根据代码调用的路径, 最主要的点在 \n- guest 内部 shell 执行的 reboot 通过 sbi 陷入到 kvm 时, 将所有 vcpu->arch.power_off 全部置为 on 了即 vcpu 全部断电\n- qemu 下发 system_reset 并未处理 kvm 的 vcpu->arch.power_off, 只是把所有 vcpu 线程退出了 KVM_RUN 的循环. 结束了 ioctl(KVM_RUN)的调用, 这一点与 guest shell reboot 的行为是一样的. 这也能解释为什么非 smp 场景下, system_reset 可以正常重启. 因为 boot_hart 的 vcpu 未断电, 所以可以正常调度.\n\n根据这个区别点, 很容易想到在修复 smp crash 的方案中, 将不是 boot_hart 的 vcpu, 主动给 kvm 发送 vcpu 断电的命令, 让非 boot_hart 的 vcpu 的 vcpu->arch.power_off 回到 on 状态.\n加入这个修改后, smp 场景下测试 qemu 下发 system_reset 可以正常重启.\n\n# 小结\n\n整体回顾下 reboot 流程, 这里为什么需要把 reset 流程总结一下, 因为上面的方案中无论是 qemu 通过 ioctl 设置 vcpu->arch.power_off 还是通过 ioctl 设置 vcpu 的寄存器和 csr, 都要保证 vcpu 不能处在 KVM_RUN 的小循环下 (红色实线的循环), 必须结束 ioctl(KVM_RUN) 退到用户态后重发 ioctl(KVM_RUN). 否则是没有时机同步这些的. 即使可以同步, 也非常容易引起时序混乱.\n\n\n![](../attachments/kvm_run.png)\n\n\n> qemu 的 vcpu 线程可以通过其他线程设置 pthread_kill signal 将阻塞在 `ioctl(KVM_RUN)` 的系统调用退出 ioctl.\n> 在 vcpu 的 kvm task 因 power_off 导致处于 rcu_wait_event 循环 schedual 出不来时, signal 导致该 task 收到信号后, 在 rcu_wait_event 检测到了 signal_pending_state 退出循环, 进入下一轮循环后, kvm 调用了 kvm_handle_signal_exit 结束了本次 `ioctl(KVM_RUN)` 调用回到了 qemu 中.\n\n\n![](attachments/vcpu_schedual.png)\n\n# upstream 修复\nupstream 提交change 修复\n\nhttps://github.com/qemu/qemu/commit/8633951530cc923f1e7a6cd250f670f24c0ed817\n","tags":["kvm"],"categories":["RISCV","qemu","debug"]},{"title":"riscv kernel crash dump","url":"/2024/01/12/hxd_new/虚拟化/debug/riscv kernel crash dump/","content":"\n# 编译内核子模块\n\n# submodule\n\n```shell\nmake SUBDIRS=./kmodules/01_oops O=virt_build modules \"5.3之前的kernel版本\"\nmake M=./kmodules/01_oops O=virt_build modules \"之后的版本\"\n```\n\n编写一个简单的可以导致 load page fault 的内核模块触发内核 panic.\n\n# Kernel sysrq\n\n`Documentation/translations/zh_CN/admin-guide/sysrq.rst`\n\n启用 `CONFIG_MAGIC_SYSRQ`\n\n```shell\necho c > /proc/sysrq-trigger \"产生panic\"\n```\n\n# 配置 crashdump\n\n## kexec-tools\n\nhttps://github.com/chenjh005/kexec-tools/tree/build-test-riscv-v2\n\n编译\n```shell\n../configure --host=riscv64-linux --target=riscv64 --prefix=/home/liguang/program/riscv-lab/kexec-tools/install\n```\n\n最终生成 `/sbin/kexec`\n\n## kernel 配置\n\nkernel 需要打开\n\n`CONFIG_KEXEC=y` `CONFIG_DEBUG_INFO=y` `CONFIG_CRASH_DUMP=y` `CONFIG_PROC_VMCORE=y`\n\n## cmdline 配置\n\n需要在内核的启动参数中添加 `crashkernel=X[@Y]` 这样的参数，表明需要预留一部分内存用以保存 dump 内核的代码，以便在第一个内核崩溃的情况下，通过一系列故障处理之后，迅速切换到第二个内核，也就是所谓的 dump 内核，通过该内核收集第一个内核所产生的崩溃现场信息\n\n```\n-append \"root=/dev/vda rw earlycon=sbi console=ttyS0 crashkernel=256M\"\n```\n\n## 设置 kexec 参数\n\n需要将 vmlinux dtb 导入到 rootfs 中, 接着注册 kexec 参数\n\n```shell\n/sbin/kexec -p --dtb=dtb.file --reuse-cmdline vmlinux \n```\n上述命令需要设置到开机自启动脚本中.\n\n# 触发 crash, 启动第二个内核\n\nkernel crash 后, 会按照 kexec 设置的参数启动第二个内核, 在第二个内核中生成 `/proc/vmcore` 文件.\n\n```shell\n# echo c > /proc/sysrq-trigger\n[   31.743965] sysrq: Trigger a crash\n[   31.744405] Kernel panic - not syncing: sysrq triggered crash\n[   31.744762] CPU: 0 PID: 124 Comm: sh Kdump: loaded Not tainted 6.4.0-rc1-00026-g80e62bc8487b-dirty #11\n[   31.745125] Hardware name: riscv-virtio,qemu (DT)\n[   31.745430] Call Trace:\n[   31.745733] [<ffffffff800054ae>] dump_backtrace+0x1c/0x24\n[   31.746032] [<ffffffff8084420c>] show_stack+0x2c/0x38\n[   31.746239] [<ffffffff8084f4be>] dump_stack_lvl+0x3c/0x54\n[   31.746547] [<ffffffff8084f4ea>] dump_stack+0x14/0x1c\n[   31.746843] [<ffffffff808445b8>] panic+0x102/0x2b6\n[   31.747128] [<ffffffff804e6940>] sysrq_reset_seq_param_set+0x0/0x72\n[   31.747371] [<ffffffff804e6f16>] __handle_sysrq+0x9a/0x18c\n[   31.747648] [<ffffffff804e7400>] write_sysrq_trigger+0x70/0x9e\n[   31.748095] [<ffffffff8021955e>] proc_reg_write+0x3e/0x8c\n[   31.748849] [<ffffffff801bac2a>] vfs_write+0xac/0x2f8\n[   31.749145] [<ffffffff801bafb2>] ksys_write+0x5e/0xc8\n[   31.749411] [<ffffffff801bb02a>] sys_write+0xe/0x16\n[   31.749648] [<ffffffff8084ff00>] do_trap_ecall_u+0xe0/0xf4\n[   31.749936] [<ffffffff8000366c>] ret_from_exception+0x0/0x64\n[   31.750790] SMP: stopping secondary CPUs\n[   31.751969] Starting crashdump kernel...\n[   31.752427] Will call new kernel at f0000000 from hart id 0\n[   31.752898] FDT image at ffffd000\n[   31.753255] Bye...\n[    0.000000] Linux version 6.4.0-rc1-00026-g80e62bc8487b-dirty (liguang@LAPTOP-N3BGDMO9) (riscv64-unknown-linux-gnu-gcc (GCC) 10.2.0, GNU ld (GNU Binutils) 2.35) #11 SMP Fri Jun  2 16:22:42 CST 2023\n[    0.000000] Machine model: riscv-virtio,qemu\n[    0.000000] efi: UEFI not found.\n[    0.000000] OF: fdt: Reserving 1 KiB of memory at 0xfffff000 for elfcorehdr\n[    0.000000] Zone ranges:\n[    0.000000]   DMA32    [mem 0x00000000f0000000-0x00000000ffffffff]\n[    0.000000]   Normal   empty\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x00000000f0000000-0x00000000ffffffff]\n[    0.000000] Initmem setup node 0 [mem 0x00000000f0000000-0x00000000ffffffff]\n[    0.000000] crashkernel: ignoring reservation request\n[    0.000000] SBI specification v1.0 detected\n```\n\n生成的 `/proc/vmcore` 文件\n\n```shell\n-r--------    1 root     root     1901559808 Jun  2 09:13 /proc/vmcore\n```\n\n# vmcore 文件转储\n\n需要使用 makedumpfile 工具对 `/proc/vmcore` 进行转储, 在 debain 下, makedumpfile 是被 kdump-tools.service 调用的, 调用 `/usr/sbin/kdump-config` 脚本最终使用 `makedumpfile` 对 `/proc/vmcore` 进行转储.\n放在默认的 `/var/crash/` 下.\n\n```shell\n/etc/systemd/system/multi-user.target.wants/kdump-tools.service\n```\n\n但是 makedumpfile 工具目前还不支持 riscv\nhttps://github.com/makedumpfile/makedumpfile/issues/8\n\n而且如果不使用 debain 这种带 systemd 服务的, 需要手动编写 init.d 脚本配置 makedumpfile 自启动, 以确保第二个 kernel 启动后自启动脚本完成对 `/proc/vmcore` 的转储.\n\n也可以使用 `cp` `scp` 等 copy 命令将/proc/vmcore 拷贝出来\n\n# vmcore 分析\n\n可以使用 crash 工具对 vmcore 进行分析. gdb 应该也是支持的.\n\n`gdb -ex \"core vmcore\"`\n目前 riscv 上转储的 core 地址有问题, 没有保存 `0xff200000_00000000` 段的地址, 该段地址属于 vmalloc 段地址.\n\n0xff20000000903c58\n\n\n# 源码分析\n\n## kexec\n\nkexec 源码:  `https://github.com/horms/kexec-tools`\n\n读取 `/proc/iomem` , 判断是否加载 crashkernel\n\n![](attachments/iomem.png)\n\n其中， 除了crash kernel部分， System RAM其余部分都是需要被dump的","tags":["crash_dump"],"categories":["RISCV"]},{"title":"linux riscv mmu 地址翻译调试","url":"/2024/01/11/hxd_new/riscv调研/mmu/mmu 地址翻译调试/","content":"\nsv39\n\nsatp: 0x8000000000087fff\nva:   0x80000fac\n\n求 pa\n\nsv39\n38...30     9bit\n29...21     9bit\n20...12     9bit\n11...0      12bit\n\n64bit 中一个页表项占 64bit，一个 double word\n\n\n![](attachments/sv39_pte.png)\n\n- satp.PPN 给出了一级页表的基址, VA[38:30]给出了一级页号, 因此处理器会读取位于地址(satp.PPN × 4096 + VA[38:30] × 8)的页目录项  (此处的 8 为 8字节，即一个页表项占 64bit)\n- 该 PTE 包含二级页表的基址, VA[29:21]给出了二级页号, 因此处理器读取位于地址(PTE.PPN × 4096 + VA[29:21] × 8)的页目录项\n- 该 PTE 包含了三级页表的基址, VA[20:12] 给出了三级页号, 处理器读取位于地址(PTE.PPN × 4096 + VA[20:12] × 8)的页目录项\n- 该页表项的 PTE. PPN 就是物理地址对应的 PPN * 4096 + offset 得到物理地址\n\n\nva: 0x80000fac\n\n```shell\nbit:   1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | \nindex: 31| 30| 29| 28| 27| 26| 25| 24| 23| 22| 21| 20| 19| 18| 17| 16| \n----------------------------------------------------------------------\nbit:   0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | \nindex: 15| 14| 13| 12| 11| 10| 09| 08| 07| 06| 05| 04| 03| 02| 01| 00|\n```\nsatp.ppn = 0x87fff << 12 = 0x87fff000\n- satp.PPN × 4096 + VA[38:30] × 8 = `0x87fff000+0b10*8` = 0x87fff010         @地址存放的值为 (0x21ffe801)\n- PTE.PPN × 4096 + VA[29:21] × 8 = `0x21ffe801>>10<<12 + 0*8` = 0x87ffa000    @地址存放的值为 (0x21ffe401)\n- PTE.PPN × 4096 + VA[20:12] × 8 = `0x21ffe401>>10<<12 + 0*8` = 0x87ff9000   @地址存放的值为 (0x2000004b)\n- PPN x 4096 + offset = `0x2000004b>>10<<12 + 0xfac` = 0x80000fac\n\n最终取得 pa 为 0x80000fac\n","tags":["mmu"],"categories":["linux","mmu","debug"]},{"title":"riscv kvm qemu 虚拟化调研","url":"/2023/10/11/hxd_new/riscv调研/虚拟化/RISCV kvm qemu 虚拟化调研/","content":"\n# KVM\n\nKVM（Kernel-based Virtual Machine，基于内核的虚拟机）是一种用于 Linux 内核中的虚拟化基础设施。本质是一个嵌入到 Linux 内核中的虚拟化功能模块 kvm.ko，该模块在利用 Linux 内核所提供的部分操作系统能力（e.g. 任务调度、内存管理、硬件设备交互）的基础上，再加入了处理器和内存虚拟化的能力，使得 Linux 内核具备了成为 VMM 的条件。\n\nKVM 内核模块本身只能提供 `CPU 和内存的虚拟化`。\nKVM 需要`硬件虚拟化技术支持`(Intel VT-x, AMD svm, ARM hypervisor, RISCV H-extension)，所以 KVM 也被称之为硬件辅助的虚拟化实现。\n\n严格来说 kvm 属于硬件辅助的全虚拟化 + type2 类虚拟化技术.\n\n## KVM 的功能清单：\n\n- 支持 CPU 和 Memory 超分（Overcommit）\n- 支持半虚拟化 I/O（virtio）\n- 支持热插拔 （CPU、块设备、网络设备等）\n- 支持 SMP（Symmetric Multi-Processing，对称多处理）处理器架构\n- 支持 NUMA （Non-Uniform Memory Access，非一致存储访问）处理器架构\n- 支持实时迁移（Live Migration）\n- 支持 PCI 设备直接分配（Pass-through）和单根 I/O 虚拟化 （SR-IOV）\n- 支持合并相同内存页 （KSM ）\n\n## KVM 内核模块加载流程\n\n当启动 Linux 操作系统并加载 KVM 内核模块时：\n\n- 初始化 KVM 模块内部的数据结构\n- KVM 模块检测当前的 CPU 体系结构, 打开虚拟化模式开关\n- KVM 模块创建特殊的接口设备文件` /dev/kvm` 并等待来自用户空间（QEMU）的指令。\n\nKVM 是运行在内核态的且**本身不能进行任何io设备的模拟**。所以，KVM 还必须借助于一个运行在用户态的应用程序来模拟出虚拟机所需要的虚拟设备（e.g. 网卡、显卡、存储控制器和硬盘）同时为用户提供操作入口。目前这个应用程序的最佳选择就是 QEMU。\n\n# QEMU\n\n纯软QEMU 本身作为一套完整的 VMM 实现，包括了`处理器虚拟化`，`内存虚拟化`，以及模拟各类虚拟设备的功能。QEMU 4.0.0 版本甚至几乎可以模拟任何硬件设备，但由于这些模拟都是纯软件实现的，所以其**性能低下**。\n\n在 KVM 开发者在对 QEMU 进行稍加改造后，QEMU 可以通过 KVM 对外暴露的 /dev/kvm 接口来对其进行调用。从 QEMU 角度来看，也可以说是 `QEMU` 使用了 `KVM` 的处理器和内存虚拟化功能，为自己的虚拟机提供了硬件辅助虚拟化加速。\n\n![image-20240416112227420](attachments/image-20240416112227420.png)\n\n虚拟机的配置和创建、虚拟机运行所依赖的虚拟设备、虚拟机运行时的用户环境和用户交互，以及一些虚拟机的特定技术，比如：动态迁移，都是交由 QEMU 来实现的。\n\n## QEMU 的使用方式\n\n1. **纯软件（二进制翻译）实现的全虚拟化虚拟机**\n2. **基于硬件辅助虚拟化（KVM）的全虚拟化虚拟机**\n3. **基于硬件辅助虚拟化（KVM）的半虚拟化虚拟机** (借助软件virtio 实现io 模拟)\n4. **仿真器**：为用户空间的进程提供 CPU 仿真(指令翻译)，让在不同处理器结构体系上编译的程序得以跨平台运行。例如：让 RISCV 架构上编译的程序在 x86 架构上运行（借由 VMM 的形式) 。\n\n# QEMU-KVM\n\nKVM 官方提供的软件包下载包含了 KVM 内核模块、QEMU、qemu-kvm 以及 virtio, qemu-kvm 本质是专门针对 KVM 的 QEMU 分支代码包\n\nQEMU-KVM 相比原生 QEMU 的改动：\n\n- 原生的 QEMU 通过指令翻译实现 CPU 的完全虚拟化，但是修改后的 QEMU-KVM 会调用 ICOTL 命令来调用 KVM 模块。\n- 原生的 QEMU 是单线程实现，QEMU-KVM 是多线程实现。\n\n在 QEMU-KVM 中，KVM 运行在内核空间，提供 CPU 和内存的虚级化，以及 Guest OS 的 I/O 拦截。QEMU 运行在用户空间，提供硬件 I/O 虚拟化，并通过 ioctl 调用` /dev/kvm` 接口将 KVM 模块相关的 CPU 指令传递到内核中执行。当 Guest OS 的 I/O 被 KVM 拦截后，就会将 I/O 请求交由 QEMU 处理\n\nKVM 提供的ioctl 命令:\n\n```c\nopen(\"/dev/kvm\", O_RDWR|O_LARGEFILE)    = 3\nioctl(3, KVM_GET_API_VERSION, 0)        = 12\nioctl(3, KVM_CHECK_EXTENSION, 0x19)     = 0\nioctl(3, KVM_CREATE_VM, 0)              = 4\nioctl(3, KVM_CHECK_EXTENSION, 0x4)      = 1\nioctl(3, KVM_CHECK_EXTENSION, 0x4)      = 1\nioctl(4, KVM_SET_TSS_ADDR, 0xfffbd000)  = 0\nioctl(3, KVM_CHECK_EXTENSION, 0x25)     = 0\nioctl(3, KVM_CHECK_EXTENSION, 0xb)      = 1\nioctl(4, KVM_CREATE_PIT, 0xb)           = 0\nioctl(3, KVM_CHECK_EXTENSION, 0xf)      = 2\nioctl(3, KVM_CHECK_EXTENSION, 0x3)      = 1\nioctl(3, KVM_CHECK_EXTENSION, 0)        = 1\nioctl(4, KVM_CREATE_IRQCHIP, 0)         = 0\nioctl(3, KVM_CHECK_EXTENSION, 0x1a)     = 0\n```\n\n## QEMU-KVM 调用 KVM 内核模块启动虚拟机的流程概要\n\n- 获取 `/dev/kvm` fd（文件描述符）\n\n- 创建虚拟机，获取虚拟机的句柄\n\n  `KVM_CREATE_VM` 可以理解成 KVM 为虚拟机创建了对应的数据结构，然后，KVM 会返回一个文件句柄来代表该虚拟机。针对这个句柄执行 ioctl 调用即可完成对虚拟机执行相应的管理，比如：\n\n  - 创建用户空间虚拟地址（Virtual Address）\n  - 客户机物理地址GPA（Guest Physical Address）以及主机物理地址HPA（Host Physical Address）之间的映射关系\n\n- 为虚拟机映射内存和其他的 PCI 设备，以及信号处理的初始化。\n\n  ```c\n  ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);\n  ```\n\n- 将虚拟机镜像数据映射到内存，相当于物理机的 boot 过程，把操作系统内核映射到内存。\n\n- 创建 vCPU，并为 vCPU 分配内存空间。KVM_CREATE_VCPU 时，KVM 为每一个 vCPU 生成对应的文件句柄，对其执行相应的 ioctl 调用，就可以对 vCPU 进行管理\n\n  ```c\n  ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);\n  vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n  ```\n\n- 创建 vCPU 个数的线程并运行虚拟机。\n\n  ```c\n  ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);\n  ```\n\n- 线程进入循环，监听并捕获虚拟机退出原因，做相应的处理。这里的退出并不一定指的是虚拟机关机，虚拟机如果遇到 I/O 操作，访问硬件设备，缺页中断等都会执行退出。执行退出可以理解为将 CPU 执行上下文返回到 QEMU。\n\n  ```c\n  open(\"/dev/kvm\")\n  ioctl(KVM_CREATE_VM)\n  ioctl(KVM_CREATE_VCPU)\n  for (;;) {\n       ioctl(KVM_RUN)\n       switch (exit_reason) {  /* 分析退出原因，并执行相应操作 */\n       case KVM_EXIT_IO:  /* ... */\n       case KVM_EXIT_HLT:  /* ... */\n       }\n  }\n  ```\n\n## 虚拟化 kvm-qemu io模拟框架\n\n![image-20240416112232080](attachments/image-20240416112232080.png)\n\n# virtio\n\n传统的设备模拟中，虚拟机内部设备驱动完全不知道自己处在虚拟化环境中。对于网络和存储等，I/O操作会完整地走完虚拟机内核栈->QEMU->宿主机内核栈，产生很多的VM Exit和VM Entry，所以性能很差。virtio方案则是旨在提高性能的一种优化方案，在该方案中，虚拟机能够感知到自己处于虚拟化环境，并且会加载相应的virtio总线驱动和virtio设备驱动。\n\n半虚拟化包含两个部分:\n\n- VMM 创建出模拟的设备 (后端)\n- guest os 安装好该模拟设备的驱动 (前端)\n\n传统的模拟手段, 如模拟网卡收发包过程中, 会配置众多的寄存器和io端口, 每一次都需要陷入陷出VMM, 使得网卡性能较差. 而半虚拟化通过虚拟的设备封装设备请求, 大幅减少陷入陷出的次数.\n\nvirtio是一种前后端架构，包括前端驱动（Front-End Driver）和后端设备（Back-End Device）以及自身定义的传输协议。通过传输协议，virtio不仅可以用于QEMU/KVM方案，也可以用于其他的虚拟化方案\n\n前端驱动为虚拟机内部的virtio模拟设备对应的驱动，每一种前端设备都需要有对应的驱动才能正常运行。前端驱动的主要作用是接收用户态的请求，然后按照传输协议将这些请求进行`封装`，再写I/O端口，发送一个通知到QEMU的后端设备。\n\n后端设备则是在QEMU中，用来接收前端驱动发过来的I/O请求，然后从接收的数据中按照传输协议的格式进行`解析`，对于网卡等需要实际物理设备交互的请求，后端驱动会对`物理设备进行操作`，从而完成请求，并且会通过`中断机制`通知前端驱动\n\nvirtio能够支持各种不同的设备，如基于virtio实现的网络架构通常被称为virtio-net\n\n后端设备位于用户态QEMU进程，VCPU 需要暂停执行\n\n![image-20240416112239957](attachments/image-20240416112239957.png)\n\n## virtio设备的初始化\n\nvirtio设备首先需要创建一个PCI设备，叫作`virtio PCI代理设备`，这个代理设备挂到PCI总线上，接着virtio代理设备再创建一条virtio总线，这样virtio设备就可以挂到这条总线上了。\n\nvirtio PCI代理的父设备是一个PCI设备，类型为VirtioPCIClass，实例为VirtIOPCIProxy，注意这是一个抽象设备，所以并不能创建其实例，只能由其子类去创建。QEMU中定义了所有virtio设备的PCI代理设备，如virtio balloon PCI设备、virtio scsi PCI设备、virito crypto PCI设备\n\n![image-20240416112244530](attachments/image-20240416112244530.png)\n\n所有的virtio设备都有一个共同的父类`TYPE_VIRTIO_DEVICE`\n\n### virtio ballon 设备示例\n\n这里以virtio balloon设备为例分析virtio设备的初始化过程。创建virtio balloon时只需要创建其PCI代理设备（即TYPE_VIRTIO_BALLOON_PCI）即可，在命令行指定-device virtio-balloon-pci\n\n> 通常来说，要改变客户机占用的宿主机内存，是要先关闭客户机，修改启动时的内存配置，然后重启客户机才能实现。而内存的ballooning（气球）技术可以在客户机运行时动态地调整它所占用的宿主机内存资源，而不需要关闭客户机。\n\n```c\nstatic void virtio_balloon_pci_register(void)\n{\n    virtio_pci_types_register(&virtio_balloon_pci_info);\n}\nstatic const VirtioPCIDeviceTypeInfo virtio_balloon_pci_info = {\n    .base_name             = TYPE_VIRTIO_BALLOON_PCI,\n    .generic_name          = \"virtio-balloon-pci\",\n    .transitional_name     = \"virtio-balloon-pci-transitional\",\n    .non_transitional_name = \"virtio-balloon-pci-non-transitional\",\n    .instance_size = sizeof(VirtIOBalloonPCI),\n    .instance_init = virtio_balloon_pci_instance_init,\n    .class_init    = virtio_balloon_pci_class_init,\n};\nstatic void virtio_balloon_pci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);\n    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);\n    k->realize = virtio_balloon_pci_realize; // 具现\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n    device_class_set_props(dc, virtio_balloon_pci_properties);\n    pcidev_k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n    pcidev_k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n    pcidev_k->revision = VIRTIO_PCI_ABI_VERSION;\n    pcidev_k->class_id = PCI_CLASS_OTHERS;\n}\n```\n\nQEMU在main函数中会对所有-device的参数进行具现化，设备的具现化函数都会调用`device_set_realized`函数，在该函数中会调用设备类的realize函数\n\nvirtio设备类的继承链关系为DeviceClass->PCIDeviceClass->VirtioPCIClass\n\n![image-20240416112248800](attachments/image-20240416112248800.png)\n\n![image-20240416112252260](attachments/image-20240416112252260.png)\n\n## virtio驱动的加载\n\n由于virtioPCI代理设备的存在，PCI进行扫描的时候会扫描到这个设备，并且会调用相应驱动的probe函数，virtio_pci_driver及其probe回调函数定义如下\n\n```c\nstatic struct pci_driver virtio_pci_driver = {\n\t.name\t\t= \"virtio-pci\",\n\t.id_table\t= virtio_pci_id_table,\n\t.probe\t\t= virtio_pci_probe, // probe 实现\n\t.remove\t\t= virtio_pci_remove,\n\t.sriov_configure = virtio_pci_sriov_configure,\n};\nstatic int virtio_pci_probe(struct pci_dev *pci_dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct virtio_pci_device *vp_dev, *reg_dev = NULL;\n\tint rc;\n\tvp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);\n\tpci_set_drvdata(pci_dev, vp_dev);\n\tvp_dev->vdev.dev.parent = &pci_dev->dev;\n\tvp_dev->vdev.dev.release = virtio_pci_release_dev;\n\tvp_dev->pci_dev = pci_dev;\n\tINIT_LIST_HEAD(&vp_dev->virtqueues);\n\tspin_lock_init(&vp_dev->lock);\n\n\t/* enable the device */\n\trc = pci_enable_device(pci_dev);  // pci_enable_device使能该PCI设备\n\tif (rc)\n\t\tgoto err_enable_device;\n...\n\t\trc = virtio_pci_modern_probe(vp_dev); // 初始化该PCI设备对应的virtio设备\n\t\tif (rc == -ENODEV)\n\t\t\trc = virtio_pci_legacy_probe(vp_dev); // 初始化该PCI设备对应的virtio设备\n\t\tif (rc)\n\t\t\tgoto err_probe;\n...\n\tpci_set_master(pci_dev);\n\n\tvp_dev->is_legacy = vp_dev->ldev.ioaddr ? true : false;\n\n\trc = register_virtio_device(&vp_dev->vdev);\n\treg_dev = vp_dev;\n\tif (rc)\n\t\tgoto err_register;\n\n\treturn 0;\nerr_register:\n    ... // err \n\treturn rc;\n}\n```\n\n调用`pci_enable_device`使能该PCI设备，接下来调用`virtio_pci_legacy_probe`或者`virtio_pci_modern_probe`来初始化该PCI设备对应的virtio设备，只考虑modern设备，virtio_pci_modern_probe代码如下\n\n```c\nint virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)\n{\n\tstruct virtio_pci_modern_device *mdev = &vp_dev->mdev;\n\tstruct pci_dev *pci_dev = vp_dev->pci_dev;\n\tint err;\n\n\tmdev->pci_dev = pci_dev;\n\n\terr = vp_modern_probe(mdev); // 进入 vp_modern_probe \n\tif (err)\n\t\treturn err;\n\n\tif (mdev->device)\n\t\tvp_dev->vdev.config = &virtio_pci_config_ops;\n\telse\n\t\tvp_dev->vdev.config = &virtio_pci_config_nodev_ops;\n\n\tvp_dev->config_vector = vp_config_vector;\n\tvp_dev->setup_vq = setup_vq;\n\tvp_dev->del_vq = del_vq;\n\tvp_dev->isr = mdev->isr;\n\tvp_dev->vdev.id = mdev->id;\n\n\treturn 0;\n}\nint vp_modern_probe(struct virtio_pci_modern_device *mdev)\n{\n\tstruct pci_dev *pci_dev = mdev->pci_dev;\n\tint err, common, isr, notify, device;\n\tu32 notify_length;\n\tu32 notify_offset;\n\n\tcheck_offsets();\n     // 设置device id\n\tif (pci_dev->device < 0x1040) {\n\t\tmdev->id.device = pci_dev->subsystem_device;\n\t} else {\n\t\tmdev->id.device = pci_dev->device - 0x1040;\n\t}\n    // 设置vendor id\n\tmdev->id.vendor = pci_dev->subsystem_vendor; \n    \n     // 接下来调用多次virtio_pci_find_capability来发现virtio PCI代理设备的pci capability，这也是在virtio_pci_device_plugged写入到virtio PCI代理设备的配置空间中的\n    \n\t/* check for a common config: if not, use legacy mode (bar 0). */\n\tcommon = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,\n\t\t\t\t\t    IORESOURCE_IO | IORESOURCE_MEM,\n\t\t\t\t\t    &mdev->modern_bars);\n\t...\n\n\t/* If common is there, these should be too... */\n\tisr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,\n\t\t\t\t\t IORESOURCE_IO | IORESOURCE_MEM,\n\t\t\t\t\t &mdev->modern_bars);\n\tnotify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,\n\t\t\t\t\t    IORESOURCE_IO | IORESOURCE_MEM,\n\t\t\t\t\t    &mdev->modern_bars);\n\t...\n\terr = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(64));\n\tdevice = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,\n\t\t\t\t\t    IORESOURCE_IO | IORESOURCE_MEM,\n\t\t\t\t\t    &mdev->modern_bars);\n\n\terr = pci_request_selected_regions(pci_dev, mdev->modern_bars,\n\t\t\t\t\t   \"virtio-pci-modern\");\n\t...\n\terr = -EINVAL;\n    // 调用map_capability将对应的capability在PCI代理设备中的BAR空间映射到内核地址空间，如virtio_pci_device的common成员就映射了virtio_pci_common_cfg的数据到内核中，这样，后续就可以直接通过这个内存地址空间来访问common这个capability了，其他的capability类似。这样实际上就将virtio PCI代理设备的BAR映射到虚拟机内核地址空间了，后续直接访问这些地址即可实现对virtio PCI代理设备的配置和控制\n\tmdev->common = vp_modern_map_capability(mdev, common,\n\t\t\t\t      sizeof(struct virtio_pci_common_cfg), 4,\n\t\t\t\t      0, sizeof(struct virtio_pci_common_cfg),\n\t\t\t\t      NULL, NULL);\n\t...\n\tmdev->isr = vp_modern_map_capability(mdev, isr, sizeof(u8), 1,\n\t\t\t\t\t     0, 1,\n\t\t\t\t\t     NULL, NULL);\n\t...\n\n\t/* Read notify_off_multiplier from config space. */\n\tpci_read_config_dword(pci_dev,\n\t\t\t      notify + offsetof(struct virtio_pci_notify_cap,\n\t\t\t\t\t\tnotify_off_multiplier),\n\t\t\t      &mdev->notify_offset_multiplier);\n\t/* Read notify length and offset from config space. */\n\tpci_read_config_dword(pci_dev,\n\t\t\t      notify + offsetof(struct virtio_pci_notify_cap,\n\t\t\t\t\t\tcap.length),\n\t\t\t      &notify_length);\n\n\tpci_read_config_dword(pci_dev,\n\t\t\t      notify + offsetof(struct virtio_pci_notify_cap,\n\t\t\t\t\t\tcap.offset),\n\t\t\t      &notify_offset);\n\n\t\n\tif ((u64)notify_length + (notify_offset % PAGE_SIZE) <= PAGE_SIZE) {\n\t\tmdev->notify_base = vp_modern_map_capability(mdev, notify,\n\t\t\t\t\t\t\t     2, 2,\n\t\t\t\t\t\t\t     0, notify_length,\n\t\t\t\t\t\t\t     &mdev->notify_len,\n\t\t\t\t\t\t\t     &mdev->notify_pa);\n\t\t...\n\t} else {\n\t\tmdev->notify_map_cap = notify;\n\t}\n\n\t// virtio_pci_modern_probe函数接着设置virtio_pci_device中virtio_device的成员vdev的config成员。如果有device这个capability，则设置为virtio_pci_config_ops，设置virtio_pci_device的几个回调函数\n\tif (device) {\n\t\tmdev->device = vp_modern_map_capability(mdev, device, 0, 4,\n\t\t\t\t\t\t\t0, PAGE_SIZE,\n\t\t\t\t\t\t\t&mdev->device_len,\n\t\t\t\t\t\t\tNULL);\n\t\t...\n\t}\n\n\treturn 0;\n\nerr_map_device:\n\t// ... err\n}\nEXPORT_SYMBOL_GPL(vp_modern_probe);\n```\n\n首先设置了virtio设备的vendor ID和device ID，值得注意的是，virtio PCI代理设备的device ID就是上一节中在virtio_pci_device_plugged函数中设置的0x1040+5，所以这里virtio设备的device ID为5。virtio_pci_modern_probe函数接下来调用多次virtio_pci_find_capability来发现virtio PCI代理设备的pci capability，这也是在virtio_pci_device_plugged写入到virtio PCI代理设备的配置空间中的，virtio_pci_find_capability找到所属的PCI BAR，写入到virtio_pci_device的modern_bars成员中，从QEMU的virtio_pci_realize函数中可以知道这个modern_bars是1<<4。接着pci_request_selected_regions就将virtio PCI代理设备的BAR地址空间保留起来了\n\nvirtio_pci_modern_probe函数调用map_capability将对应的capability在PCI代理设备中的BAR空间映射到内核地址空间，如virtio_pci_device的common成员就映射了virtio_pci_common_cfg的数据到内核中，这样，后续就可以直接通过这个内存地址空间来访问common这个capability了，其他的capability类似。这样实际上就将virtio PCI代理设备的BAR映射到虚拟机内核地址空间了，后续直接访问这些地址即可实现对virtio PCI代理设备的配置和控制。virtio_pci_modern_probe函数接着设置virtio_pci_device中virtio_device的成员vdev的config成员。如果有device这个capability，则设置为virtio_pci_config_ops，设置virtio_pci_device的几个回调函数，config_vector与MSI中断有关，setup_vq用来配置virtio设备virt queue，del_vq用来删除virt queue\n\n执行完 `virtio_pci_modern_probe` 后, 注册的函数指针:\n\n![image-20240416112259350](attachments/image-20240416112259350.png)\n\nvirtio_pci_modern_probe返回之后会调用`register_virtio_device`，这个函数将一个`virtio device`注册到系统中\n\nregister_virtio_device函数设置virtio设备的Bus为`virtio_bus`，virtio_bus在系统初始化的时候会注册到系统中。设置virtio设备的名字为类似`virtio0`、`virtio1`的字符串，然后调用dev->config->reset回调函数重置设备，最后调用device_register将设备注册到到系统中。device_register函数跟设备驱动相关比较大，这里简单介绍一下其作用。该函数会调用`device_add`将设备加到系统中，并且会发送一个`uevent`消息到用户空间，这个uevent消息中包含了virtio设备的`vendor id`、`device id`，udev接收到这个消息之后会加载virtio设备的对应驱动(动态驱动的情况下, 如果是打包到kernel的驱动, 这一步则不需要, 直接跳过即可)。device_add会调用`bus_probe_device`，最终调用到Bus的`probe`函数和设备的`probe`函数，也就是virtio_dev_probe和virtballoon_probe函数\n\n一般来讲，virtio驱动初始化一个设备的过程如下:\n\n1）重置设备，这是在上述register_virtio_device函数中通过dev->config->reset调用完成的。\n\n2）设置ACKNOWLEDGE状态位，表示virtio驱动已经知道了该设备，这同样是在register_virtio_device函数中由add_status(dev，VIRTIO_CONFIG_S_ACKNOWLEDGE语句完成的。\n\n3）设置DRIVER状态位，表示virtio驱动知道怎么样驱动该设备，这是在virtio总线的probe函数virtio_dev_probe中通过add_status(dev，VIRTIO_CONFIG_S_DRIVER)完成的。\n\n4）读取virtio设备的feature位，求出驱动设置的feature，将两者计算子集，然后向设备写入这个子集特性，这是在virtio_dev_probe函数中完成的，计算driver_features和device_features，然后调用virtio_finalize_features\n\n5）设置FEATURES_OK特性位，这之后virtio驱动就不会再接收新的特性了，这一步是在函数virtio_finalize_features中通过调用add_status(dev，VIRTIO_CONFIG_S_FEATURES_OK)完成的\n\n6）重新读取设备的feature位，确保设置了FEATURES_OK，否则设备不支持virtio驱动设置的一些状态，表示设备不可用，这同样是在virtio_finalize_features函数中完成的。\n\n7）执行设备相关的初始化操作，包括发现设备的virtqueue、读写virtio设备的配置空间等，这是在virtio_dev_probe函数中通过调用驱动的probe函数完成的，即drv->probe(dev)。\n\n8）设置DRIVER_OK状态位，这通常是在具体设备驱动的probe函数中通过调用virtio_device_ready完成的，对于virtio balloon来说是virtballoon_probe，如果设备驱动没有设置DRIVER_OK位，则会由总线的probe函数virtio_dev_probe来设置\n\n### virtio 设备驱动加载过程分析\n\n1. 启动虚拟机\n\n   ![image-20240416112303889](attachments/image-20240416112303889.png)\n\n2. 在虚拟机中使用auditd对驱动访问进行监控\n\n   ![image-20240416112307138](attachments/image-20240416112307138.png)\n\n 3. 在虚拟机中调用udevadm monitor对uevent事件进行监控\n\n    ![image-20240416112309964](attachments/image-20240416112309964.png)\n\n 4. 添加virtio-rng-pci设备\n\n    ![image-20240416112313355](attachments/image-20240416112313355.png)\n\nudev可以看到有设备添加的消息\n\n![image-20240416112316272](attachments/image-20240416112316272.png)\n\n再从audit的日志看，udev确实加载了virtio-rng.ko驱动\n\n![image-20240416112319969](attachments/image-20240416112319969.png)\n\n使用`lspci-v`可以看到，所有virtio设备的驱动均为virtio_pci，并没有virtio-rng、virtio-net等驱动\n\n![image-20240416112324004](attachments/image-20240416112324004.png)\n\n因为virtio设备是由一个PCI的控制器添加的，其本质是一个virtio设备，会挂到virtio总线上，所以PCI总线上只会显示其驱动为`virtio-pci`\n\n## virtio 驱动初始化\n\n先说一下驱动加载过程中的`virtio_pci_config_ops`, 被赋值给了 virtio_device 结构体的config 成员\n\n```c\nstatic const struct virtio_config_ops virtio_pci_config_ops = {\n\t.get\t\t= vp_get,\n\t.set\t\t= vp_set,\n\t.generation\t= vp_generation,\n\t.get_status\t= vp_get_status,\n\t.set_status\t= vp_set_status,\n\t.reset\t\t= vp_reset,\n\t.find_vqs\t= vp_modern_find_vqs,\n\t.del_vqs\t= vp_del_vqs,\n\t.synchronize_cbs = vp_synchronize_vectors,\n\t.get_features\t= vp_get_features,\n\t.finalize_features = vp_finalize_features,\n\t.bus_name\t= vp_bus_name,\n\t.set_vq_affinity = vp_set_vq_affinity,\n\t.get_vq_affinity = vp_get_vq_affinity,\n\t.get_shm_region  = vp_get_shm_region,\n\t.disable_vq_and_reset = vp_modern_disable_vq_and_reset,\n\t.enable_vq_after_reset = vp_modern_enable_vq_after_reset,\n};\n```\n\nvirtio_pci_config_ops结构体中的成员函数通常是**代理virtioPCI代理设备的I/O操作**，包括读写virtio PCI代理设备的PIO和MMIO，如get_status和set_status成员对应的vp_get_status和vp_set_status函数\n\n```erlang\n+ vp_set_status(vdev, status)\n\\ -+ vp_modern_set_status(&vp_dev->mdev, status);\n   \\ - *cfg = mdev->common\n   | - vp_iowrite8(status, &cfg->device_status);\n```\n\nvp_dev->mdev->common对应的是virtio PCI代理设备第四个BAR表示的地址中的一段空间，其指向的数据表示如下\n\n```c\nstruct virtio_pci_common_cfg {\n\t/* About the whole device. */\n\t__le32 device_feature_select;\t/* read-write */\n\t__le32 device_feature;\t\t/* read-only */\n\t__le32 guest_feature_select;\t/* read-write */\n\t__le32 guest_feature;\t\t/* read-write */\n\t__le16 msix_config;\t\t/* read-write */\n\t__le16 num_queues;\t\t/* read-only */\n\t__u8 device_status;\t\t/* read-write */\n\t__u8 config_generation;\t\t/* read-only */\n\n\t/* About a specific virtqueue. */\n\t__le16 queue_select;\t\t/* read-write */\n\t__le16 queue_size;\t\t/* read-write, power of 2. */\n\t__le16 queue_msix_vector;\t/* read-write */\n\t__le16 queue_enable;\t\t/* read-write */\n\t__le16 queue_notify_off;\t/* read-only */\n\t__le32 queue_desc_lo;\t\t/* read-write */\n\t__le32 queue_desc_hi;\t\t/* read-write */\n\t__le32 queue_avail_lo;\t\t/* read-write */\n\t__le32 queue_avail_hi;\t\t/* read-write */\n\t__le32 queue_used_lo;\t\t/* read-write */\n\t__le32 queue_used_hi;\t\t/* read-write */\n};\n```\n\n上面代码中的每一个成员都表示一个virtio PCI代理设备modern MMIO地址空间中对应的值，读写这些成员都会陷入到QEMU中, 比如设置或者获取设备状态的device_status成员, 该MemoryRegion对应的回调操作结构是common_ops.\n\n```c\n--> hw/virtio/virtio-pci.c\nstatic void virtio_pci_modern_regions_init(VirtIOPCIProxy *proxy)\n{    \n\tstatic const MemoryRegionOps common_ops = {\n        .read = virtio_pci_common_read,\n        .write = virtio_pci_common_write,\n        .impl = {\n            .min_access_size = 1,\n            .max_access_size = 4,\n        },\n        .endianness = DEVICE_LITTLE_ENDIAN,\n    };\n    ...\n}\n```\n\nvirtio_pci_config_ops的各个函数封装了这些I/O操作, virtio 设备可以通过这个结构体中的各个回调函数来驱动设备.\n\n## virtio balloon 设备驱动初始化示例\n\n```erlang\n+ virtballoon_probe(virtio_device *vdev)\n\\ - virtio_balloon *vb = kzalloc(sizeof(*vb), GFP_KERNEL)\n| - INIT_WORK(&vb->update_balloon_stats_work, update_balloon_stats_func);\n| - balloon_devinfo_init(&vb->vb_dev_info);\n| -+ init_vqs(vb);\n   \\ - callbacks[VIRTIO_BALLOON_VQ_INFLATE] = balloon_ack;\n   | - callbacks[VIRTIO_BALLOON_VQ_DEFLATE] = balloon_ack;\n   | -+ virtio_find_vqs(vb->vdev, VIRTIO_BALLOON_VQ_MAX, vqs, callbacks, names, NULL)\n      \\ -+ vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc)\n         \\ -+ vp_modern_find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc)\n            \\ -+ vp_find_vqs(vdev, nvqs, vqs, callbacks, names, ctx, desc)\n               \\ -| vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, true, ctx, desc);\n               | -| vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, false, ctx, desc);\n               | -+ vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx)\n                  \\ - vp_dev->vqs = kcalloc(nvqs, sizeof(*vp_dev->vqs), GFP_KERNEL)\n                  | - request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,\n\t\t\t\t\t\tdev_name(&vdev->dev), vp_dev) \"申请中断\"\n                  | -+ qs[i] = vp_setup_vq(vdev, queue_idx++, callbacks[i], names[i],\n\t\t\t\t     ctx ? ctx[i] : false, VIRTIO_MSI_NO_VECTOR);\n                     \\ -+ vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,\n\t\t\t\t\t      msix_vec);\n                        \\ - vp_modern_get_num_queues(mdev)\n                        | - num = vp_modern_get_queue_size(mdev, index)\n                        | - !num | vp_modern_get_queue_enable(mdev, index)\n                        | - vq = vring_create_virtqueue(index, num,\n\t\t\t\t    \t\tSMP_CACHE_BYTES, &vp_dev->vdev, true, true, ctx,\n\t\t\t\t    \t\tvp_notify, callback, name);\n            | - vp_modern_set_queue_enable(&vp_dev->mdev, [for vq in vqs]->index, true);        \n   | - vb->inflate_vq = vqs[VIRTIO_BALLOON_VQ_INFLATE];\n   | - vb->deflate_vq = vqs[VIRTIO_BALLOON_VQ_DEFLATE];\n| - virtio_device_ready(vdev); \"设置driver ok 状态位\"\n```\n\nvp_find_vqs函数本质上只调用了一个函数vp_try_to_find_vqs，但是3次调用的参数不同。3次调用的区别主要是virtio设备使用中断的方式，vp_try_to_find_vqs函数的最后两个参数一个是是否使用MSIx的中断方式，另一个是如果使用MSIx中断方式，最后一种是否是每个virtqueue一个vector。virtio设备是否使用MSIx，是由QEMU中virtio PCI代理设备结构VirtIOPCIProxy中的nvectors决定的，而这个值是作为属性添加的. 如virtio PCI代理设备的属性virtio_crypto_pci_properties定义中有`DEFINE_PROP_UINT32(\"vectors\"，VirtIOPCIProxy，nvectors，2)`，这句代码表示virtio crypto有两个MSIx的vector。virtio pci balloon设备没有定义这个属性，所以还是使用传统的INTx中断方式，也就是所有的中断都使用一个中断\n\n`vp_request_intx`申请了一个中断资源，中断处理函数为vp_interrupt, 中断申请之后会对每一个virtqueue调用`vp_setup_vq`来初始化virtqueue, 这个回调函数同样是在virtio_pci_modern_probe中设置的，为setup_vq\n\n首先得到virtio_pci_device的common成员，这是virtio PCI代理设备中用来配置的一段MMIO，直接读写这些地址会导致陷入到QEMU中的virtio_pci_common_read/write函数\n\n结合setup_vq的代码，可以总结初始化一个virtqueue的步骤：\n\n1) 如果判断需要初始化的virtqueue的索引大于读取出来的队列，那就返回错误，对应到QEMU中，通过判断VirtQueue中vring成员num（也就是virtqueue）大小不为零来判断队列个数\n2) 读取队列大小，队列大小不能为0并且该队列不处于enable状态\n3) 读取queue_notify_off寄存器的值，这个值表示virtio驱动在通知virtio设备后端时应该写的地址在notify_base中的偏移，QEMU只是简单以队列的索引返回，所以进行通知时，只需要队列索引号*notify_offset_multiplier即可。\n4) 调用alloc_virtqueue_pages分配virtqueue的页面，本质上就是分配vring的descriptor table、available ring和used ring 3个部分，这个3个部分是在连续的物理地址空间中，“info->queue”保存了分配空间的虚拟地址。\n5) 调用vring_new_virtqueue创建一个vring_virtqueue结构，参数中的vp_notify表示virtio驱动用来通知virtio设备的函数，callback表示virtio设备使用了descriptor table之后virtio驱动会调用的函数。vring_virtqueue的第一个成员是virtqueue结构，vring_virtqueue包含了所有virtqueue的信息，vring_new_virtqueue即是用来分配vring_virtqueue的，值得注意的是还多分配了num个void*指针，这是用来在调用使用通知时传递的所谓token。vring_new_virtqueue中还会调用vring_init，这个函数初始化vring，设置vring中队列大小(vring->num)、descriptor table(vring->desc)、avail ring(vring->avail)和used ring(vring->used)的地址。值得注意的是，vring_new_virtqueue会把每个vring_desc的next成员设置为下一个vring_desc的索引\n6) 激活队列，这个步骤会把队列大小，队列的descriptor table、avail ring和used ring的物理地址写入到相应的寄存器中。\n7) 设置virtqueue的priv成员为notify地址。对于virtio balloon来说，notify_offset_multiplier为4个字节, 当virtio驱动调用vp_notify通知virtio设备时，会直接写vq->priv地址, QEMU这边只需要将地址除以notify_offset_multiplier即可找到对应的队列\n\nvirtio_balloon设备的init_vqs函数调用之后，相关的数据结构\n\n![image-20240416112329901](attachments/image-20240416112329901.png)\n\n## virtqueue机制\n\n- 处理批量的异步I/O请求\n- 减少上下文切换次数\n- 基于共享内存机制\n\n## Virtqueue机制具体实现—vring\n\n- 描述符表：保存一系列描述符，每一个描述符都被用来描述一块客户机内的内存区域\n- avail ring：保存后端设备可以使用的描述符\n- used ring：后端驱动已经处理过并且尚未反馈给前端驱动的描述符\n\n![image-20240416112333572](attachments/image-20240416112333572.png)\n\nvirtqueue 机制虽然一定程度上改善了性能, 但是由于io 数据发送接收过程仍然涉及到多次上下文切换, qemu 用户态的virtio的后端需要集中处理来自guest的io 请求, 最后再从host 用户态发给内核态处理这些io请求. \n\n例如 guest 发包给外部网络，首先，guest 需要切换到 host kernel，然后 host kernel 会切换到 qemu 用户态来处理 guest 的请求， Hypervisor 通过系统调用将数据包发送到外部网络后，会切换回 host kernel ， 最后再切换回 guest。这样漫长的路径无疑会带来性能上的损失。vhost 正是在这样的背景下提出的一种改善方案\n\n![image-20240416112336510](attachments/image-20240416112336510.png)\n\n## vhost\n\nvhost 是位于 `host kernel` 的一个模块，用于和 guest 直接通信，数据交换直接在 guest 和 host kernel 之间通过 virtqueue 来进行，qemu 不参与通信，但也没有完全退出舞台，它还要负责一些控制层面的事情，比如和 KVM 之间的控制指令的下发等。\n\n以vhost-net 内核模块举例, 它以一个独立的模块完成 guest 和 host kernel 的数据交换过程。\n\n初始化过程:\n\n- 通过ioctl初始化vhost-net\n\n![image-20240416112340081](attachments/image-20240416112340081.png)\n\nguest 通知 host kernel 中`vhost-net` 模块的事件要借助 host kernel的 `kvm.ko` 模块来完成\n\nvhost-net 初始化期间，会启动一个工作线程 work 来监听 `eventfd`，一旦 guest 对`vhost-net` 发出event，`kvm.ko` 触发 `ioeventfd` 通知到 `vhost-net`，`vhost-net` 通过 virtqueue 的 `avail ring` 获取数据，并设置 `used ring`。同样，从 vhost 工作线程向 guest 通信时，也采用同样的机制，只不过这种情况发的是一个回调的 call envent，kvm.ko 触发 `irqfd` 通知 guest。\n\n可以看到这种架构下, 从guest 中虚拟io设备发送数据到 host的 真实io 设备\n\n- 通信过程不需要进入到host的用户态处理\n- 异步处理, 多核cpu上不需要终止vcpu的执行, 避免了上下文开销\n- 不影响前端驱动的设计, guest os 不需要额外的修改\n\n## Vhost-user架构\n\nVhost从host 内核迁移到host用户态，一般集成在DPDK等用户态驱动中\n\n采用 UNIX 域套接字来建立QEMU进程与vhost-user之间的联系，进而初始化vhost-user\n\n事件通知机制与Vhost-net相同\n\n数据在用户态传递\n\n![image-20240416112343837](attachments/image-20240416112343837.png)\n\n# VFIO\n\n设备直通就是将物理设备直接挂到虚拟机，虚拟机通过直接与设备交互来获得较好的性能。传统的透传设备到QEMU/KVM虚拟机的方法为`PCI passthrough`，这种老的设备直通方式**需要KVM完成大量的工作**，如与IOMMU交互、注册中断处理函数等。显然这种方法会让KVM过多地与设备打交道，扮演一个设备驱动的角色，这种方案不够通用灵活，所以后来有了`VFIO`（Virtual Function I/O）\n\nVFIO是一个用户态驱动框架，它利用硬件层面的I/O虚拟化技术，如Intel的VT-d和AMD的AMD-Vi，将设备直通给虚拟机。传统上，设备驱动与设备进行交互需要访问设备的很多资源，如`PCI设备的配置空间`、`BAR地址空间`、`设备中断`等，所有这些资源都是在内核态进行分配和访问的。虚拟化环境下，把设备直通给虚拟机之后，QEMU需要接管所有虚拟机对设备资源的访问。\n\nVFIO的基本思想包括两个部分\n\n- 将物理设备的各种资源分解，并将获取这些资源的接口向上导出到用户空间\n  - QEMU等应用层软件可以利用这些接口获取硬件的所有资源，包括设备的配置空间、BAR空间和中断\n- 聚合，也就是将从硬件设备得到的各种资源聚合起来，对虚拟化展示一个完整的设备接口，这种聚合是在用户空间完成\n  - 它从硬件设备分解各种资源之后，会重新聚合成一个虚拟机设备挂到虚拟机上，QEMU还会调用KVM的接口将这些资源与虚拟机联系起来，使得虚拟机内部完全对VFIO的存在无感知，虚拟机内部的操作系统能够透明地与直通设备进行交互，也能够正常处理直通设备的中断请求\n\n![image-20240416112347325](attachments/image-20240416112347325.png)\n\n- VFIO Interface作为接口层，用来向应用层导出一系列接口，QEMU等用户程序可以通过相应的ioctl对VFIO进行交互\n- iommu driver是物理硬件IOMMU的驱动实现，如Intel和AMD的IOMMU\n- pci_bus driver是物理PCI设备的驱动程序\n- vfio_iommu是对底层iommu driver的封装，用来向上提供IOMMU的功能，如DMA Remapping以及Interrupt Remapping\n- vfio_pci是对设备驱动的封装，用来向用户进程提供访问设备驱动的功能，如配置空间和模拟BAR\n\nVFIO的重要功能之一是对各个设备进行分区，但是即使有IOMMU的存在，想要以单个设备作为隔离粒度有时也做不到。所以，VFIO设备直通中有3个重要的概念，即`container`、`group`和`device`，其关系如图所示\n\n![image-20240416112350504](attachments/image-20240416112350504.png)\n\ngroup是IOMMU能够进行DMA隔离的最小单元，一个group内可能只有一个device，也可能有多个device，这取决于物理平台上硬件的IOMMU拓扑结构。设备直通的时候一个group里面的设备必须都直通给一个虚拟机。不能让一个group里的多个device分别从属于2个不同的VM，也不允许部分device在宿主机上而另一部分被分配到虚拟机里，因为这样一个虚拟机中的device可以利用DMA攻击获取另外一个虚拟机里的数据，无法做到物理上的DMA隔离。\n\ndevice指的是要操作的硬件设备，不过这里的“设备”需要从IOMMU拓扑的角度去理解。如果该设备是一个硬件拓扑上独立的设备，那么它自己就构成一个IOMMU group。如果这里是一个multi-function设备，那么它和其他的function一起组成一个IOMMU group，因为多个function设备在物理硬件上是互联的，它们可以互相访问数据，所以必须放到一个group里隔离起来\n\ncontainer是由多个group组成的，虽然group是VFIO的最小隔离单元，但是有的时候并不是最好的分割粒度。如多个group可能会共享一组页表，通过将多个group组成一个container可以提高系统的性能，也能够方便用户。一般来讲，每个进程/虚拟机可以作为一个container。\n\n![image-20240416112353598](attachments/image-20240416112353598.png)\n\n## VFIO使用方法\n\n1. 假设需要直通的设备如下所示\n\n   ![image-20240416112358776](attachments/image-20240416112358776.png)\n\n2. 找到这个设备的VFIO group，这是由内核生成的\n\n   ![image-20240416112402860](attachments/image-20240416112402860.png)\n\n 3. 查看group里面的设备，这个group只有一个设备\n\n    ![image-20240416112405858](attachments/image-20240416112405858.png)\n\n 4. 将设备与驱动程序解绑\n\n    ![image-20240416112409452](attachments/image-20240416112409452.png)\n\n 5. 找到设备的生产商&设备ID\n\n    ![image-20240416112412904](attachments/image-20240416112412904.png)\n\n 6. 将设备绑定到vfio-pci驱动，这会导致一个新的设备节点“/dev/vfio/15”被创建，这个节点表示直通设备所属的group文件，用户态程序可以通过该节点操作直通设备的group\n\n    ![image-20240416112417061](attachments/image-20240416112417061.png)\n\n 7. 修改这个设备节点的属性\n\n    ![image-20240416112420366](attachments/image-20240416112420366.png)\n\n 8. 设置能够锁定的内存为虚拟机内存+一些IO空间\n\n    ![image-20240416112423822](attachments/image-20240416112423822.png)\n\n 9. 向QEMU传递相关参数\n\n    ![image-20240416112427019](attachments/image-20240416112427019.png)\n\n# KVM上层管理工具\n\n一个成熟的虚拟化解决方案离不开良好的管理和运维工具，部署、运维、管理的复杂度与灵活性是企业实施虚拟化时重点考虑的问题。KVM目前已经有从libvirt API、virsh命令行工具到OpenStack云管理平台等一整套管理工具，尽管与老牌虚拟化巨头VMware提供的商业化虚拟化管理工具相比在功能和易用性上有所差距，但KVM这一整套管理工具都是API化的、开源的，在使用的灵活性以及对其做二次开发的定制化方面仍有一定优势。\n\n## libvirt\n\nlibvirt是使用最广泛的对KVM虚拟化进行管理的工具和应用程序接口，已经是事实上的虚拟化接口标准，作为通用的虚拟化API，libvirt不但能管理KVM，还能管理VMware、Hyper-V、Xen、VirtualBox等其他虚拟化方案。\n\n## virsh\n\nvirsh是一个常用的管理KVM虚拟化的命令行工具，对于系统管理员在单个宿主机上进行运维操作，virsh命令行可能是最佳选择。virsh是用C语言编写的一个使用libvirt API的虚拟化管理工具，其源代码也是在libvirt这个开源项目中的。\n\n## virt-manager\n\nvirt-manager是专门针对虚拟机的图形化管理软件，底层与虚拟化交互的部分仍然是调用libvirt API来操作的。virt-manager除了提供虚拟机生命周期（包括：创建、启动、停止、打快照、动态迁移等）管理的基本功能，还提供性能和资源使用率的监控，同时内置了VNC和SPICE客户端，方便图形化连接到虚拟客户机中。virt-manager在RHEL、CentOS、Fedora等操作系统上是非常流行的虚拟化管理软件，在管理的机器数量规模较小时，virt-manager是很好的选择。因其图形化操作的易用性，成为新手入门学习虚拟化操作的首选管理软件。\n\n## OpenStack\n\nOpenStack是一个开源的基础架构即服务（IaaS）云计算管理平台，可用于构建共有云和私有云服务的基础设施。OpenStack是目前业界使用最广泛的功能最强大的云管理平台，它不仅提供了管理虚拟机的丰富功能，还有非常多其他重要管理功能，如：对象存储、块存储、网络、镜像、身份验证、编排服务、控制面板等。OpenStack仍然使用libvirt API来完成对底层虚拟化的管理。\n\n","tags":["riscv","kvm"],"categories":["虚拟化","RISCV","中断"]},{"title":"riscv kvm timer bug 问题分析","url":"/2023/09/11/hxd_new/riscv调研/虚拟化/riscv kvm timer bug 问题分析/","content":"\n# 问题背景\n\n在使用最新版本 qemu (8.0) 搭配 linux kernel (5.19.16) 模拟出的 riscv 主机上, 使用 riscv 版本的 qemu 跑 kvm-mode 的 guest kernel 无法执行.\n现象为没有 host kernel 的 log, 没有 guest kernel 的 log 输出.\n\n\n# 问题初步分析\n\n在 kvm_riscv_vcpu_enter_exit 处下断点看下 vcpu 的调度情况\n发现 vcpu 调度是正常的\n\n但在 kvm_riscv_vcpu_exit 处打 log 发现每次 guest 退出的原因都是因为\nsbi 设置 timecmp\n\n通过 qemu 的 command `dump-guest-memory` 命令导出 guest 的 coredump\nguest 停在了通过 sbi 设置 timecmp 的地方.\n\n根据这个现象, guest kernel 一直在处理 timer tick, 却不能走其他的流程, 对比正常的 log, 启动过程中从 guest 退出到 kvm 的原因是多种多样的, 所以可以首先怀疑是 guest timer tick 出了问题.\n\n对比最新版本 qemu (8.0) 搭配 linux kernel (主线 6.x) 版本, 可以正常运行 guest.\n对比 linux kernel kvm 中对 guest timer tick 的处理, 发现加入了 sstc 的 feature.\n\n# 初步验证\n\nsstc 可以作为第一个疑点, 需要首先排除下是否是这个 feature 导致的.\n\n在 host qemu (8.0) 中关掉 sstc 的 feature, 即关掉模拟 riscv 主机的 sstc 的 feature, 再次运行 guest, 发现 guest 正常运行了.\n\n调研 sstc 的 SPEC 文档, sstc 引入了 vstimecmp 寄存器, guest 可以通过直接设置 vstimecmp 来避免陷入 kvm 来处理 timer tick.\n\n但调研 SPEC 结束后, 发现不能解释为什么 old kernel (5.19.16) kvm 上不使用 vstimecmp 应该是没问题的, guest 通过 sbi 设置 timecmp 是走了通过 host kvm 来处理 guest timer tick 的逻辑.\n\nguest os 设置 compare 发 `SBI_EXT_0_1_SET_TIMER` 的请求\n导致陷入到 kvm 中, kvm 接收的请求中第一个参数 `next_cycle` 即为下一轮的 compare 数.\n\n在 guest 因设置 compare 请求导致陷入到 kvm 中, kvm 处理 `SBI_EXT_0_1_SET_TIMER`:\n- 首先清除了 IRQ_VS_TIMER 中断, 确保本轮 tick 中不再有有的 timer 中断产生\n- 计算下一轮到期的时间 delta_ns (cycle 转换为 host 的纳秒单位)\n- 启动定时器, 到期时间为当前时间+delta_ns\n- 退出 kvm, 重返到 vcpu guest\n\n定时器到期时, 触发中断重新陷入到 kvm 中, 处理函数为 kvm_riscv_vcpu_hrtimer_expired\n, 通过 hvip 注入 IRQ_VS_TIMER 中断, 让 guest 处理 timer tick, 走到对应的 tick 处理函数, 紧接着通过 sbi SBI_EXT_0_1_SET_TIMER 设置下一轮 compare.\n\n这套机制的问题只是效率慢 (一次 timer tick 的处理需要两次陷入 kvm), 但机制是没问题的.\n\n再次深入调研 sstc 的 SPEC, 注意到这个描述:\n\n> The interrupt remains posted until vstimecmp becomes\nGreater than (time + htimedelta) - typically as a result of writing vstimecmp\n\n会不会是 vstimecmp 没处理是默认的 0, 所以 compare 总是比 time 小, 导致一直触发 VSTIP 的中断, guest 一直在处理 VSTIP 中断, 不能让出 cpu 来处理其他的流程.\n\n想到这一点, 可以简单的验证下:\n\n在 `kvm_arch_vcpu_load` 中设置 vstimecmp 为最大值\n`csr_write(0x24D, -1UL);`\n\n修改后验证 qemu (8.0)+old kernel (5.19.17) 模拟的 riscv 主机上跑 guest, guest 正常运行了, 证明正是这个问题导致的.\n\n# 梳理 guest timer 的流程\n\n在找到 root cause 后, 有时间需要对 guest riscv timer tick 的流程做一下梳理.\n这里直接拿最新的 linux kernel 版本进行分析.\n\n首先整理 sstc 的 feature.\n\nguest 在满足上述 `[m/h]envcfg.STCE` 和 `[m/h]counteren.TM` 后可以直接操作 stimecmp csr 来设置 timer tick, 就不必再通过 sbi 陷入到 kvm 中设置 compare, 也不需要 kvm 维护定时器, 同时也不需要 kvm 注入 timer 虚拟中断给 vcpu, 减少了两次陷入 kvm, 大大提升了 guest 处理 tick 的效率. \nTick 到期后, 由硬件来保证 vcpu 直接收到 timer 的虚拟中断, vcpu 不用陷入到 kvm 就可以处理一轮轮的 tick.\n\n> 为什么上述问题中, guest os 却是设置 compare 发 `SBI_EXT_0_1_SET_TIMER` 的请求\n这是因为这个问题中, guest kernel 用的 old kernel (5.19.17), 并未合入 sstc feature 的相关修改.\n\n可以直接看下 guest kernel 处理 timer tick 的逻辑\n\n```erlang\nstart_kernel\n  +-> time_init\n    +-> timer_probe\n      +-> cpuhp_setup_state\n        +-> __cpuhp_setup_state\n          +-> __cpuhp_setup_state_cpuslocked\n            +-> cpuhp_issue_call\n              +-> cpuhp_invoke_callback\n                +-> riscv_timer_starting_cpu\n                  +-> clockevents_config_and_register\n                    +-> clockevents_register_device\n                      +-> tick_check_new_device\n                        +-> tick_setup_device\n                          +-> tick_setup_periodic\n\t\t\t\t\t          /* event_handler回调 */\n\t\t\t\t\t         +-> tick_handle_periodic\n\t\t\t\t\t           +-> clockevents_program_event\n\t\t\t\t\t             +-> dev->set_next_event\n\t\t\t\t\t               +-> riscv_clock_next_event\n```\n\nold kernel (5.19.17)\n```c\nstatic int riscv_clock_next_event(unsigned long delta,\n\t\tstruct clock_event_device *ce)\n{\n\tcsr_set(CSR_IE, IE_TIE);\n\tsbi_set_timer(get_cycles64() + delta);\n\treturn 0;\n}\n```\n\n而最新主线上的 kernel (6.x)\n\n```c\nstatic int riscv_clock_next_event(unsigned long delta,\n\t\tstruct clock_event_device *ce)\n{\n\tu64 next_tval = get_cycles64() + delta;\n\n\tcsr_set(CSR_IE, IE_TIE);\n\tif (static_branch_likely(&riscv_sstc_available)) {\n...\n\t\tcsr_write(CSR_STIMECMP, next_tval);\n\t} else\n\t\tsbi_set_timer(next_tval);\n\n\treturn 0;\n}\n```\n\nguest kernel 未合入 sstc feature 修改前, guest 只能通过 sbi SBI_EXT_0_1_SET_TIMER 设置 compare.\n需要陷入到 kvm 中设置 compare.\n\nguest kernel 合入了 sstc feature 后, guest kernel 可以检测主机是否支持 sstc, \n- 如支持, guest 通过 stimecmp (vstimecmp) 来设置 compare, 最大化的提高 timer tick 的处理效率.\n- 不支持, guest 仍通过 sbi SBI_EXT_0_1_SET_TIMER 设置 compare.\n\n而最新的 linux kvm 版本合入了 sstc 的 feature, 则需要考虑 guest kernel 的兼容性, 同时兼容老的 kernel (不支持 sstc) 和新的 kernel(支持 sstc)\n\n来看下对应的处理逻辑:\n- 模拟的 riscv 主机支持 sstc 时:\n\t1. 对于支持 sstc 的新的 guest kernel, 在 guest 运行后, 就不用管 guest 的 timer tick 了, 但是 guest 退出运行后, 处于 block 时, 仍然需要关注 guest 的 timer tick.\n\t2. 对于不支持 sstc 的旧的 guest kernel, 需要处理 guest 发过来的 sbi SBI_EXT_0_1_SET_TIMER 消息. 但 guest 运行时, 也不需要通过主机定时器来处理 guest 的 timer tick. 因为 host 是支持 sstc 的, 只是 guest kernel 未检测 sstc 而已. 只要 kvm 在收到 sbi SBI_EXT_0_1_SET_TIMER 后直接设置 vstimecmp 就可以了, 这样时间到了后, 硬件会设置 VSTIP, guest 就可以处理 timer tick 中断走到 tick 处理函数了.\n- 模拟的 riscv 主机不支持 sstc 时:\n\t1. 退回到通过 host kvm 设置定时器来处理 guest 的 timer tick.\n\t\n```c\nint kvm_riscv_vcpu_timer_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_timer *t = &vcpu->arch.timer;\n\n\tif (t->init_done)\n\t\treturn -EINVAL;\n\n\thrtimer_init(&t->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tt->init_done = true;\n\tt->next_set = false;\n\n\t/* Enable sstc for every vcpu if available in hardware */\n\tif (riscv_isa_extension_available(NULL, SSTC)) {\n\t\tt->sstc_enabled = true;\n\t\tt->hrt.function = kvm_riscv_vcpu_vstimer_expired;\n\t\tt->timer_next_event = kvm_riscv_vcpu_update_vstimecmp;\n\t} else {\n\t\tt->sstc_enabled = false;\n\t\tt->hrt.function = kvm_riscv_vcpu_hrtimer_expired;\n\t\tt->timer_next_event = kvm_riscv_vcpu_update_hrtimer;\n\t}\n\n\treturn 0;\n}\n```\n\n## riscv 主机支持 sstc\n\n看下 riscv 主机支持 sstc 的策略:\n`t->timer_next_event = kvm_riscv_vcpu_update_vstimecmp;`\n\n该函数是在处理 guest 发来的 `sbi SBI_EXT_0_1_SET_TIMER` 的处理函数\n\n```erlang\n-+ kvm_sbi_ext_v01_handler\n \\ -+ case SBI_EXT_0_1_SET_TIMER:\n    \\ -  next_cycle = (u64)cp->a0;\n    | -+ kvm_riscv_vcpu_timer_next_event(vcpu, next_cycle); \n       \\ -+ t->timer_next_event(vcpu, ncycles);\n          \\ -+ kvm_riscv_vcpu_update_vstimecmp()\n             \\ -  csr_write(CSR_VSTIMECMP, ncycles);\n```\n\n对应支持 sstc 模拟 riscv 主机的第二种情况.\n而第一种情况 guest 运行中 guest kernel 自己设置 vstimecmp, 不需要陷入 kvm, 所以 kvm 也不用处理.\n\n再看下 \n`t->hrt.function = kvm_riscv_vcpu_vstimer_expired;`\n\n这个是 host kvm 定时器的超期函数, 这个函数是为了处理 guest kernel 因 block 得不到执行时的定时器处理函数, 该定时器是类似于 doorbell 机制, 在 guest kernel 未能调度时, 需要 kvm 设置定时器处理 guest 的 tick. 保证 vcpu 可以有调度的机会.\n\n```erlang\n\"退出ioctl(KVM_RUN)的小循环时, 调用了 vcpu_put 释放vcpu资源\"\n-+ kvm_arch_vcpu_ioctl_run(vcpu)\n \\ -+ vcpu_put(vcpu)\n    \\ -+ kvm_arch_vcpu_put(vcpu);\n       \\ -+ kvm_riscv_vcpu_timer_save(vcpu);\n          \\ -|+ if kvm_vcpu_is_blocking(vcpu)\n              \\ -+ kvm_riscv_vcpu_timer_blocking(vcpu);\n                      \"启动定时器\"\n                 \\ -  hrtimer_start(&t->hrt, ktime_set(0, delta_ns), HRTIMER_MODE_REL);\n\"定时器到时处理函数\"\n-+ kvm_riscv_vcpu_vstimer_expired(struct hrtimer *h)\n \\ -  kvm_vcpu_kick(vcpu); \"唤醒vcpu\"\n | -  return HRTIMER_NORESTART; \"不重启定时器\"\n```\n\n## riscv 主机不支持 sstc\n\n回退 kvm 主机为 guest timer tick 设置定时器\n`t->timer_next_event = kvm_riscv_vcpu_update_hrtimer;`\n\n在 guest 因设置 compare 请求导致陷入到 kvm 中, kvm 处理 `SBI_EXT_0_1_SET_TIMER`:\n在 `kvm_riscv_vcpu_update_hrtimer` 中\n\n- 首先清除了 IRQ_VS_TIMER 中断, 确保本轮 tick 中不再有新的 timer 中断产生\n- 计算下一轮到期的时间 delta_ns (cycle 转换为 host 的纳秒单位)\n- 启动定时器, 到期时间为当前时间+delta_ns\n- 退出 kvm, 重返到 vcpu guest\n\n定时器到期时, 触发中断重新陷入到 kvm 中, 处理函数为 `kvm_riscv_vcpu_hrtimer_expired`\n, 通过 hvip 注入 IRQ_VS_TIMER 中断, 让 guest 处理 timer tick, 走到对应的 tick 处理函数, 紧接着通过 sbi SBI_EXT_0_1_SET_TIMER 设置下一轮 compare.","tags":["riscv","kvm"],"categories":["虚拟化","RISCV","qemu","bug"]},{"title":"riscv kvm 方案代码调研","url":"/2023/09/09/hxd_new/虚拟化/riscv kvm 调研/","content":"\n# 内存虚拟化\n\n![](attachments/1771657-20201107233844101-140556043.png)\n\n\n涉及到两个主题:\n1. GPA->HVA\n2. HVA->HPA\n\n略过 GVA->GPA, 这个是 guest os 中的 mmu 地址翻译过程. \n\n## GPA->HVA\n\nKVM-Qemu 方案中，GPA->HVA 的转换，是通过 `ioctl` 中的 `KVM_SET_USER_MEMORY_REGION` 命令来实现的.\n\n![](attachments/1771657-20201107233855813-554323553.png)\n\n### 数据结构\n\n![](attachments/1771657-20201107233904748-592916078.png)\n\n- 虚拟机使用`slot`来组织物理内存，每个`slot`对应一个`struct kvm_memory_slot`，一个虚拟机的所有`slot`构成了它的物理地址空间；\n- 用户态使用`struct kvm_userspace_memory_region`来设置内存`slot`，在内核中使用`struct kvm_memslots`结构来将`kvm_memory_slot`组织起来；\n- `struct kvm_userspace_memory_region`结构体中，包含了`slot`的 ID 号用于查找对应的`slot`，此外还包含了物理内存起始地址及大小，以及 HVA 地址，HVA 地址是在用户进程地址空间中分配的，也就是 Qemu 进程地址空间中的一段区域；\n\n### 流程分析\n数据结构部分已经罗列了大体的关系，那么在`KVM_SET_USER_MEMORY_REGION`时，围绕的操作就是`slots`的创建、删除，更新等操作\n\n![](attachments/1771657-20201107233915050-1368514616.png)\n\n- 当用户要设置内存区域时，最终会调用到`__kvm_set_memory_region`函数，在该函数中完成所有的逻辑处理；\n- `__kvm_set_memory_region`函数，首先会对传入的`struct kvm_userspace_memory_region`的各个字段进行合法性检测判断，主要是包括了地址的对齐，范围的检测等；\n- 如果传入的参数中`memory_size`为 0，那么会将对应`slot`进行删除操作；\n- 根据用户传入的参数，设置`slot`的处理方式：`KVM_MR_CREATE`，`KVM_MR_MOVE`，`KVM_MEM_READONLY`；\n- 根据用户传递的参数决定是否需要分配脏页的 bitmap，标识页是否可用；\n- 最终调用`kvm_set_memslot`来设置和更新`slot`信息；\n\n#### kvm_set_memslot\n\n具体的`memslot`的设置在`kvm_set_memslot`函数中完成，`slot`的操作流程如下：\n![](attachments/1771657-20201107233927534-60352225.png)\n\n- 首先分配一个新的`memslots`，并将原来的`memslots`内容复制到新的`memslots`中；\n- 如果针对`slot`的操作是删除或者移动，首先根据旧的`slot id`号从`memslots`中找到原来的`slot`，将该`slot`设置成不可用状态，再将`memslots`安装回去。这个安装的意思，就是 RCU 的 assignment 操作，不理解这个的，建议去看看之前的 RCU 系列文章。由于`slot`不可用了，需要解除 stage2 的映射；\n- `kvm_arch_prepare_memory_region`函数，用于处理新的`slot`可能跨越多个用户进程 VMA 区域的问题，如果为设备区域，还需要将该区域映射到`Guest GPA`中；\n- `update_memslots`用于更新整个`memslots`，`memslots`基于 PFN 来进行排序的，添加、删除、移动等操作都是基于这个条件。由于都是有序的，因此可以选择二分法来进行查找操作；\n- 将添加新的`slot`后的`memslots`安装回 KVM 中；\n- `kvfree`用于将原来的`memslots`释放掉；\n\n```erlang\n-+ kvm_set_memslot(struct kvm *kvm, struct kvm_memory_slot *old, struct kvm_memory_slot *new, enum kvm_mr_change change)\n \\ -+ kvm_invalidate_memslot(kvm, old, invalid_slot); \n\t \"KVM_MR_DELETE 或 KVM_MR_MOVE 情况下需要无效化该slot以告知vcpu 该slot映射已经不存在了, 如果该内存插槽在KVM虚拟机中正在使用，则此函数将导致任何对该内存区域的访问引发异常。\"\n\t\\ -+ kvm_arch_flush_shadow_memslot(kvm, old);\n\t   \\ -+ gstage_unmap_range(kvm, gpa, size, false); \"riscv 解除stage2 映射\"\n\t      \\ -+ gstage_op_pte(kvm, addr, ptep, ptep_level, GSTAGE_OP_CLEAR); \n\t         \\ -  set_pte(ptep, __pte(0)); \"G-stage pte 清除, 进而导致vcpu 触发page fault\"\n | -+ kvm_prepare_memory_region(kvm, old, new, change);\n    \\ -+ kvm_arch_prepare_memory_region(kvm, old, new, change); \"riscv 实现\"\n\t       \"change 为 KVM_MR_CREATE 或 KVM_MR_MOVE 或 KVM_MR_FLAGS_ONLY 情况时\" \n       \\ -  hva = new->userspace_addr;\n       | -  size = new->npages << PAGE_SHIFT;   \"新申请的memslot range \"\n       | -  reg_end = hva + size;\n       | -  base_gpa = new->base_gfn << PAGE_SHIFT;\n          \"新申请的memslot 内存区域可能跨多个 VMA, 所以需要遍历所有的VMA, 查看 vma 是否覆盖了 hva的地址范围\"\n       | -+ while (vma = find_vma(current->mm, hva)) \"查到的vma 包含了hva地址, current->mm 代表查找当前进程即qemu的vma\"\n          \\ -  pa = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;\n          | -  vm_start = max(hva, vma->vm_start);\n          | -  pa += vm_start - vma->vm_start; \"pa 为 HPA\"\n          | -  gpa = base_gpa + (vm_start - hva);\n          | -|+ if (vma->vm_flags & VM_PFNMAP) \"预先映射 gpa->hpa 页表的前提是触及的vma 有 VM_PFNMAP 的flag\"\n\t          \\ -+ gstage_ioremap(kvm, gpa, pa, size(vm_end - vm_start), writable);\n\t                \"维护gpa -> hpa映射关系\"\n\t             \\ -  end = (gpa + size + PAGE_SIZE - 1) & PAGE_MASK;\n\t             | -  pfn = __phys_to_pfn(hpa); \"hpa 物理页号\"\n\t             | -+ for (addr = gpa; addr < end; addr += PAGE_SIZE)\n\t                \\ -  pte = pfn_pte(pfn, PAGE_KERNEL);\n\t                | -  kvm_mmu_topup_memory_cache(&pcache, gstage_pgd_levels); \"预分配mmu 页表本身所需的内存\"\n\t                | -+ gstage_set_pte(kvm, level:0, &pcache, GPA:addr, &pte);\n\t                   \\ -  current_level = gstage_pgd_levels - 1; \"这里只看到 sv39x4, gstage_pgd_levels=3\"\n\t                   | -  pte_t *next_ptep = (pte_t *)kvm->arch.pgd; \"kvm 为虚拟机的实例, pgd 为G-stage 第一级页表基址\"\n\t                   | -  pte_t *ptep = &next_ptep[gstage_pte_index(addr, current_level)]; \"取出第一级页表项\"\n\t                   | -+ while (current_level != level(0))\n\t                      \\ -  gstage_pte_leaf(ptep)  \"检查不应为叶子节点\"\n\t                      | -|+ if(!pte_val(*ptep)) \"下一级页表项无效, 需要创建下一级页表项\"\n                                    \"从预分配内存中找出一个可用的内存地址放下一级页表项\"\n\t                          \\ -  next_ptep = kvm_mmu_memory_cache_alloc(pcache);                                    \n\t                          | -  *ptep = pfn_pte(PFN_DOWN(__pa(next_ptep)), __pgprot(_PAGE_TABLE));\n\t                                \"更新当前页表项, 保存下一级页表项 ppn 及 权限\"\n\t                        -|+ else \"下一级页表项有效\"\n\t                          \\ -  next_ptep = (pte_t *)gstage_pte_page_vaddr(*ptep); \"直接找出下一级页表项地址\"       \n\t                      | -  current_level--; \"处理下一级页表项\"\n\t                      | -  ptep = &next_ptep[gstage_pte_index(addr, current_level)]; \"ptep 更新为下一级页表项地址\"    \n\t                   | -  *ptep = *pte; \"最终更新叶子节点为 HPA的pte\"\n\t                   | -+ gstage_remote_tlb_flush(kvm, current_level, addr); \"G-stage 页表更新后, 还需要刷新tlb\"\\\n\t                      \\ -+ kvm_riscv_hfence_gvma_vmid_gpa(kvm, -1UL, 0, addr, BIT(order), order);           \n\t                         \\ ---+ kvm_riscv_hfence_process(vcpu)\n\t                              \\ -+ case KVM_RISCV_HFENCE_GVMA_VMID_GPA:\n\t                                 \\ -  kvm_riscv_local_hfence_gvma_vmid_gpa(READ_ONCE(v->vmid), d.addr, d.size, d.order); \n          | -  hva = vm_end; \"更新hva\" \n | -+ kvm_create_memslot(kvm, new); \"if KVM_MR_CREATE\"\n | -+ kvm_delete_memslot(kvm, old, invalid_slot); \"if KVM_MR_DELETE\"\n | -+ kvm_move_memslot(kvm, old, new, invalid_slot); \"if KVM_MR_MOVE\"\n | -+ kvm_update_flags_memslot(kvm, old, new); \"if KVM_MR_FLAGS_ONLY\"\n | -+ kvm_commit_memory_region(kvm, old, new, change);\n```\n\n在 riscv 中, kvm_arch_prepare_memory_region 的实现判断如果vma 有 `VM_PFNMAP` 的flag, 会调用 gstage_ioremap 进而调用 gstage_set_pte 建立 GPA->HPA的G-stage 页表\n\n最终建立页表映射关系的函数为 gstage_set_pte.\n而不是所有的vma 都有这个flag, 大部分的 GPA->HPA的 G-stage 页表映射的建立还是在触发Guest Page Fault 时处理的.\n\n#### kvm_commit_memory_region\n\n```erlang\n-+ kvm_commit_memory_region(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     const struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n \\ -  kvm->nr_memslot_pages -= old->npages; \"if KVM_MR_DELETE\"\n | -  kvm->nr_memslot_pages += new->npages; \"if KVM_MR_CREATE\"\n | -+ kvm_arch_commit_memory_region(kvm, old, new, change);\n    \\ -|+ if(change != KVM_MR_DELETE && new->flags & KVM_MEM_LOG_DIRTY_PAGES)\n        \\ -+ gstage_wp_memory_region(kvm, new->id);\n           \\ -  kvm_memslots *slots = kvm_memslots(kvm); \"找到memslots\"\n           | -  kvm_memory_slot *memslot = id_to_memslot(slots, slot); \"根据slot id 找到对应的slot\"\n           | -  start = memslot->base_gfn << PAGE_SHIFT;\n           | -  end = (memslot->base_gfn + memslot->npages) << PAGE_SHIFT;\n           | -+ gstage_wp_range(kvm, start, end);\n              \\ -+ while (addr < end)\n                 \\ -+ gstage_op_pte(kvm, addr, ptep, ptep_level, GSTAGE_OP_WP); \n                    \\ -  set_pte(ptep, __pte(pte_val(*ptep) & ~_PAGE_WRITE)); \"操作G-stage 页表pte, 去除W权限, write protector\"\n           | -  kvm_flush_remote_tlbs(kvm);\n```\n\n## GPA->HPA\n\ngstage_page_fault 根据guest page fault 时的htval/stval 记录的fault addr 为 GPA, 通过GPA 在memslots中找到对应的memslot, 进而找到 hva 和 hpa, 根据hva所在的vma 的page_size 确定是建立大页还是普通的G-stage 页表\n, 最终通过 gstage_set_pte 函数建立G-stage 页表.\n中途还处理了hpa的dirty 和 memslot 中的dirty_bitmap 以及 G-stage 页表pte的dirty位\n\n```erlang\n-+ gstage_page_fault(struct kvm_vcpu *vcpu, struct kvm_run *run,\n\t\t\t     struct kvm_cpu_trap *trap)\n \\ -  fault_addr = (trap->htval << 2) | (trap->stval & 0x3); \"guest page fault 时 通过htval 或 stval 记录 GPA\"\n | -  gfn = fault_addr >> PAGE_SHIFT; \"GPA的页号\"\n | -  memslot = gfn_to_memslot(vcpu->kvm, gfn); \"通过GPA 页号找到kvm对应的memslot\"\n | -  hva = gfn_to_hva_memslot_prot(memslot, gfn, &writeable); \"通过memslot gpa页号找到 hva\"\n\t \"找到了hva, 说明是内存, 不会陷入到 emulate_load emulate_store io模拟\"\n | -+ kvm_riscv_gstage_map(vcpu, memslot, GPA:fault_addr, hva,\n\t\tis_write:(trap->scause == EXC_STORE_GUEST_PAGE_FAULT) ? true : false);\n\t\\ -  vma = find_vma_intersection(current->mm, hva, hva + 1); \"查找vma\"\n\t| -  kvm_mmu_topup_memory_cache(pcache, gstage_pgd_levels); \"预分配页表本身所需内存\"\n\t| -+ hfn = gfn_to_pfn_prot(kvm, gfn, is_write, &writeable);\t\"gpa页号找到hpa页号\"\n\t   \\ -  addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault); \"先通过gpa 找到hva\"\n\t   | -  return hva_to_pfn(addr, atomic, async, write_fault, writable);\t\"再通过hva 找到hpa 得到hfn\"\n\t| -|+ if (writeable)\n\t    \\ -  kvm_set_pfn_dirty(hfn); \"hfn pte 置dirty\"\n\t    | -  mark_page_dirty(kvm, gfn); \"对应memslot的 dirty_bitmap 置位, 维护虚拟机状态\"\n\t    | -+ gstage_map_page(kvm, pcache, gpa, hfn << PAGE_SHIFT,\n\t\t\t\t      page_size:vma_pagesize, page_rdonly:false, page_exec:true);\n                 \"根据page_size 确定建几级页表, 比如该vma的page_size 很大, 超过了 1个page, 就可以考虑建大页\"\n\t\t   \\ -  gstage_page_size_to_level(page_size, &level); \t\t      \n\t\t   | - \tnew_pte = pfn_pte(PFN_DOWN(hpa), prot); \"更新pte 状态, prot 根据 page_rdonly page_exec 确定 RWX权限\"\n\t\t   | -  new_pte = pte_mkdirty(new_pte);\t \"pte 添加 Dirty状态\"\n\t\t   | -  gstage_set_pte(kvm, level, pcache, gpa, &new_pte); \"建立 G-stage GPA->HPA 页表\"\n\t| -|+ else\n\t    \\ -  ret = gstage_map_page(kvm, pcache, gpa, hfn << PAGE_SHIFT,\n\t\t\t\t      vma_pagesize, true, true);\t\t\t      \n```\n\n\n# cpu 虚拟化\n\n## vcpu 调用流\n\n梳理下vcpu 调度的流程, 需要结合下qemu 来看下\n\n### KVM_VCPU_RUN\n\nqemu 用户态代码, qemu 为每个vcpu 建了一个新的线程, 专门用来运行vcpu, 主要逻辑就是一个while 循环调用ioctl(KVM_RUN), 如果vcpu guest 一直运行, 则该次ioctl 不会结束,\n- 只有当guest 因请求导致异常陷入kvm 后, kvm 判断需要用户态处理该请求时, 才会结束这次ioctl的调用, 回到qemu 中\n- qemu 接着判断这次需要用户态处理的原因, 处理完后, 再进行下一轮while 循环, 继续发送ioctl(KVM_RUN)\n- qemu 将本次处理的结果在下一轮循环中告诉kvm, kvm 在处理完qemu处理的结果后, 再进到guest, 结束本次guest的请求.\n\n```c\n    while(1) {\n        ret = ioctl(vcpufd, KVM_RUN, NULL);\n        switch (run->exit_reason)\n\t        case KVM_EXIT_IO:\n\t            kvm_handle_io(run->io.port, attrs,\n                          (uint8_t *)run + run->io.data_offset,\n                          run->io.direction,\n                          run->io.size,\n                          run->io.count);\n            ...\n\t\t    case KVM_EXIT_MMIO:\n\t\t        address_space_rw(&address_space_memory,\n                             run->mmio.phys_addr, attrs,\n                             run->mmio.data,\n                             run->mmio.len,\n                             run->mmio.is_write);\n\t         ...   \n    }\n```\n\nkvm 中vcpu run的流程(精简)\n```c\n```erlang\n-+ kvm_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)\n \\ -  kvm_arch_vcpu_async_ioctl(filp, ioctl, arg); \"riscv not implement\"\n | -+ case KVM_RUN    \"ioctl 值\"\n    \\ -  oldpid = rcu_access_pointer(vcpu->pid); \"保存vcpu->pid 值, 这个值表示用户态qemu 创建的vcpu 线程id\"\n    | -|+ if oldpid != task_pid(current) \"线程id不一样\"\n        \\ -+ kvm_arch_vcpu_run_pid_change(vcpu) \"riscv not implement\"\n        | -  newpid = get_task_pid(current, PIDTYPE_PID);\n        | -  rcu_assign_pointer(vcpu->pid, newpid); \"vcpu 指向新的线程id\"\n    | -+ r = kvm_arch_vcpu_ioctl_run(vcpu);    \n       \\ -  kvm_run *run = vcpu->run;\n       | -  vcpu->arch.ran_atleast_once = true; \"标记运行过\"\n       | -+ switch (run->exit_reason)\n          \\ -|+ case KVM_EXIT_MMIO: \"处理寄存器\"\n                                    \"比如guest 此时 [ld t0, 地址], 此处为 qemu 读到的mmio 地址的值, 最后要调用这个函数将值塞到 guest_context.t0中\"\n              \\ -  kvm_riscv_vcpu_mmio_return(vcpu, vcpu->run);\n          | -|+ case KVM_EXIT_RISCV_SBI:\n              \\ -  kvm_riscv_vcpu_sbi_return(vcpu, vcpu->run); \"Process SBI value returned from user-space\"\n          | -|+ case KVM_EXIT_RISCV_CSR:\n              \\ -  kvm_riscv_vcpu_csr_return(vcpu, vcpu->run); \"Process CSR value returned from user-space\"          \n       | -+ vcpu_load(vcpu);\n          \\ -+ kvm_arch_vcpu_load(vcpu, cpu);\n             \\ -  kvm_vcpu_csr *csr = &vcpu->arch.guest_csr; \"guest_csr 在前面KVM_VCPU_CREATE 创建时已经初始化过了\"\n             | -  csr_write(CSR_VSEPC, csr->vsepc); \"读取vcpu->guest_csr 中的v开头的csr, 恢复到 cpu的对应csr中\"\n       | -+ while(ret > 0)\n          \\ -  kvm_riscv_gstage_vmid_update(vcpu); \"更新vmid\"\n          | -  kvm_riscv_check_vcpu_requests(vcpu);\n          | -  local_irq_disable(); \"关闭 hs kernel的中断\"\n          | -  kvm_riscv_vcpu_flush_interrupts(vcpu); \"根据qemu 注入的 irqs_pending sync vcpu->guest_csr 的hvip\"\n          | -  kvm_riscv_update_hvip(vcpu); \"根据vcpu->guest_csr的hvip 更新 cpu的 hvip csr\"\n          | -+ kvm_riscv_vcpu_enter_exit(vcpu); \"切换vcpu 虚拟机运行\"\n             \\ -+ __kvm_riscv_switch_to(&vcpu->arch); \"进入 guest\"\n\t\t             \"同时设置stvec 为 __kvm_switch_return, 这样因异常或中断退出guest 返回host 时, 会走到 __kvm_switch_return 中\" \n                  -----------> \"因异常或中断退出guest, 回到kvm上下文, 退出guest 切换到 host 时, 会保存guest 的上下文到 guest_context 中\" <--------\n          | ---+ __kvm_switch_return \"保存guest 上下文, 恢复host 上下文, 恢复stvec 为 hs kernel 原本的stvec\"\n          | -        \n          | -  trap.sepc = vcpu->arch.guest_context.sepc; \n          | -  trap.htval = csr_read(CSR_HTVAL);\n          | -  trap.scause = csr_read(CSR_SCAUSE);\n          | -  kvm_riscv_vcpu_sync_interrupts(vcpu);    \"guest 有可能会操作 sip.VSSIP 导致 hvip.VSSIP 变化了, 这里要跟host 中的hvip 变量同步一下\"\n          | -  local_irq_enable();  \"开启hs kernel 的中断, 如果有hs kernel 的异常/中断的pending, 会在这个地方进入到hs kernel的异常/中断处理流程中\"\n          | -+ kvm_riscv_vcpu_exit(vcpu, run, &trap);   \"判断异常的原因, 对异常进行处理\"\n             \\ -  switch (trap->scause)\n             | -|+ case EXC_INST_ILLEGAL\n             | -|+ case EXC_VIRTUAL_INST_FAULT\n             | -|+ case EXC_INST_GUEST_PAGE_FAULT | EXC_LOAD_GUEST_PAGE_FAULT | EXC_STORE_GUEST_PAGE_FAULT\n                 \\ -+ gstage_page_fault(vcpu, run, trap);\n                    \\ -  switch (trap->scause)\n                    | -|+ case EXC_LOAD_GUEST_PAGE_FAULT\n                        \\ -+ return kvm_riscv_vcpu_mmio_load(vcpu, run, fault_addr, trap->htinst);   \n                           \\ -|+ if (!kvm_io_bus_read(vcpu, KVM_MMIO_BUS, fault_addr, len, data_buf) \"如果kvm能自己处理, 则不会陷入用户态, 由kvm_io 设备处理\"\n                               \\ -  kvm_riscv_vcpu_mmio_return(vcpu, run); \"处理寄存器\"\n                                        \"比如guest 此时 [ld t0, 地址], kvm从kvm_io设备中读出该地址的值, 最后要调用这个函数将值塞到 guest_context.t0中\"\n          |    <== ret = 1     \\ -  return 1 \" 不需要陷入用户态, ret 返回1, while继续, 下一轮重新进入guest 中\"\n                           | -|+ else\n                               \\ -  vcpu->stat.mmio_exit_user++;\n                               | -  run->exit_reason = KVM_EXIT_MMIO; \"陷入用户态 qemu, qemu需要知道原因\"\n          |    <== ret = 0     | -  return 0; \"由用户态 qemu 进行处理, 这个地方return 0, 退出while 循环, 本轮 ioctl(vcpufd, KVM_RUN, NULL) 调用结束, 回到qemu用户态\"\n                    | -|+ case EXC_STORE_GUEST_PAGE_FAULT\n          |    <==      \\ -+ return kvm_riscv_vcpu_mmio_store(vcpu, run, fault_addr, trap->htinst);\n                    | -  kvm_riscv_gstage_map(vcpu, memslot, fault_addr, hva, is_write) \"如果能通过gpa 找到hva, 对应ram 的地址, 则直接建立G-stage 页表就行了\"\n          |    <==  | -  return 1;    \" 继续while 循环, 下一轮进入guest\"\n             | -|+ case EXC_SUPERVISOR_SYSCALL\n                 \\ -+ kvm_riscv_vcpu_sbi_ecall(vcpu, run);\n       | -+ vcpu_put(vcpu);  \"上面return 0 时代表需要进入qemu 中进行处理, 继续走到这里\"\n          \\ -+ kvm_arch_vcpu_put(vcpu); \"主要是读取v 开头的csr, 保存到vcpu->guest_csr 下\"                \n | -  \"结束ioctl 调用\"       \n```\n\n为了更容易理解, 只对mmio load 这一种情况做一下简要的流程介绍: \n\n![](attachments/kvm_run.png)\n\n图中两个循环, 一个是qemu 中的 (黄色线) , 一个是kvm中的 (红色线)\n当guest 因load 指令陷入到 kvm 中时, 查找GPA 没找到 关联的hva (说明是MMIO 地址, 不是RAM 地址)\n如果kvm 可以自己处理, 即通过遍历 KVM_MMIO_BUS 上注册的kvm_io_dev 设备的地址范围, 查找gpa 是否在该范围内\n- 如果在 KVM_MMIO_BUS 地址范围, 则由kvm_io_dev的对应的read 函数进行处理\n- 如果不在, 则需要退出kvm的 `KVM_RUN` 的循环, 结束ioctl(KVM_RUN), 回到qemu 用户态, 原因为 KVM_EXIT_MMIO, 由qemu 在AddressSpace 查找对应的MemoryRegion, 调用MemoryRegion的read函数进行处理, 处理完后, qemu 进行下一轮循环, 重新发起 ioctl(KVM_RUN) 进入kvm\n- 上述两种方式读到了mmio 地址 (GPA) 的值, 最终都需要调用 kvm_riscv_vcpu_mmio_return 将该地址的值填到对应的 guest 发起的load 目标寄存器中.\n- 最后通过 kvm_riscv_vcpu_enter_exit 函数重新进入guest 中.\n\n> 注意host 上下文和 guest 上下文的保存恢复过程, 上述为了简述只写了通用寄存器的保存恢复流程, 实际还有一些cpu的 csr 需要保存恢复. 如 host的 scounteren sstatus hstatus hvip hgatp 等 (一个物理cpu可以托管多个vcpu, 而每个vcpu的这几个csr可能都是不同的)\n> guest 的主要的v开头的csr 属于是vcpu 专属的, 这部分放在了vcpu->guest_csr 中, 需要在 vcpu_put 和 vcpu_load 中进行保存和恢复. 这一部分为什么没在 kvm_riscv_vcpu_enter_exit 时进行处理是因为, kvm的 KVM_RUN的循环是针对同一个vcpuid的, 离开了这个循环才有可能在本物理cpu上调度其他vcpuid的vcpu, 将v 开头的csr保存恢复放在 `KVM_RUN` 循环外避免了 无意义的保存恢复.\n\n### vCPU 调度\n\n首先需要知道 qemu-kvm 框架下vcpu 和 虚拟机实例 vm 的角色.\n\nKVM中的一个客户机(VM 实例)是作为一个用户空间进程(qemu-kvm)运行。和其他普通的用户空间进程一样,由内核调度。\n多个客户机(VM 实例)就是宿主机中的多个QEMU进程\n而一个客户机的多个vCPU就是一个QEMU进程中的多个线程。\n\n因为vCPU实际上是宿主机上的一个线程,所以vCPU的调度是依赖宿主机Linux内核中的CPU调度算法。\n即kvm 中并没有为vcpu 做专门的调度.\n\n宿主机调度时机基于宿主机的每一次的tick处理函数, 根据运行的时间片或负载调整内核task的切换.\n用户态的进程和线程落到kernel 中都是task.\n宿主机因tick 中断会从vcpu guest 中退出来陷入到 host kernel 中的tick 处理函数中.\nhost kernel 根据对应的调度策略选择切换到其他的task.\n\nLinux调度算法有三个比较著名:\n\n1.  O(1) scheduler\n2.  Comletely Fair Scheduler(CFS)\n3.  BF Scheduler(BFS)\n\n对smp的支持\n\n在多个hart 上并行执行多个vcpu的task.\nvcpu task 因为是属于qemu的线程, 所以vcpu 可以更换物理hart运行.\nlinux 的CFS算法会根据smp负载情况调度qemu的线程, 使vcpu 运行在负载较低的物理hart上.\n\n### hs timer tick 调度细节\n\n从源码上看, kvm 在进guest 之前, 将stvec 变成了kvm的 `__kvm_switch_return`\n在vcpu 正在运行时, 如果因为 hs kernel的timer tick 到了, hs kernel 会因中断打断vcpu guest  的运行, 进而会先走到 `__kvm_switch_return`中\n`__kvm_switch_return` 会保存guest上下文/恢复host的上下文, 将stvec 恢复成hs kernel 原本的stvec, 接着处理kvm循环的后半部分, \n接着会调用 `local_irq_enable` 这个函数会启用hs kernel 的中断, 开启后因为 sip & sie timer的pending, 所以会接着走timer的tick 的处理函数处理该pending, 也就进入了cpu调度的部分. cpu可以根据负载情况从 vcpu run的task 切换到别的task上.\n\n但是注意此时vcpu run的task 还是在这个物理hart上, 从源码上看不允许将该task 切换到别的物理hart上执行, kvm的 KVM_RUN的循环没有退出, vcpu的资源也没有释放, vcpu在kvm中的相关资源(timer 中断, 更复杂的场景如支持中断直通)没有切换物理hart的时机,  vcpu->cpu 并没有改变的时机, 只有KVM_RUN 结束后回到qemu的循环时, vcpu的资源才会释放, 该vcpu才能跑到其他的物理hart上.\n这个可能会导致vcpu 长期绑到了一个物理hart上.\n\n## timer 虚拟化\n从操作系统的角度来看一下 timer 的作用吧：\n![](attachments/1771657-20201205235145167-121582686.png)\n\n通过 timer 的中断，OS 实现的功能包括但不局限于上图：\n- 定时器的维护，包括用户态和内核态，当指定时间段过去后触发事件操作，比如 IO 操作注册的超时定时器等；\n- 更新系统的运行时间、wall time 等，此外还保存当前的时间和日期，以便能通过`time()`等接口返回给用户程序，内核中也可以利用其作为文件和网络包的时间戳；\n- 调度器在调度任务分配给 CPU 时，也会去对 task 的运行时间进行统计计算，比如 CFS 调度，Round-Robin 调度等；\n- 资源使用统计，比如系统负载的记录等，此外用户使用 top 命令也能进行查看；\n\n\n### riscv 中 对timer的虚拟化支持\n\n- mtime csr 时间来自于clint, 所有cpu 共享, 统一维护一个时间基准.\n- htimedelta, 每个cpu 有一个htimedelta csr, 各自记录与mtime 之间的offset.\n- time csr, 在V=1时, time = mtime + htimedelta; 在kvm中(HS-mode下), time = mtime\n\n示例如下：\n\n![](attachments/1771657-20201205235232851-53486309.png)\n\n6ms 的时间段里，每个 vCPU 运行 3ms，Hypervisor 可以使用 htimedelta 寄存器来将 vCPU 的时间调整为其实际的运行时间；\n\n### 用户层访问\n\n可以从用户态对 vtimer 进行读写操作，比如 Qemu 中，流程如下：\n\n```erlang\n---> qemu <---\n-+ ioctl(vcpu_fd, KVM_GET_ONE_REG, 0)\n---> kernel <---\n \\ -+ kvm_arch_vcpu_ioctl\n    \\ -+ case KVM_GET_ONE_REG\n       \\ -+ kvm_riscv_vcpu_get_reg(vcpu, &reg);\n          \\ -+ kvm_riscv_vcpu_get_reg_timer\n             \\ -+ case KVM_REG_RISCV_TIMER_REG(time)\n                \\ -+ reg_val = kvm_riscv_current_cycles(gt);\n                   \\ - csr_read(CSR_TIME) + gt->time_delta;\n             | -+ case KVM_REG_RISCV_TIMER_REG(compare)\n                \\ -  reg_val = t->next_cycles;\n```\n\n- 用户态创建完 vcpu 后，可以通过 vcpu 的文件描述符来进行寄存器的读写操作；\n- ioctl 通过`KVM_SET_ONE_REG/KVM_GET_ONE_REG`将最终触发寄存器的读写；\n- 如果操作的是 timer 的相关寄存器，则通过`kvm_riscv_vcpu_set_reg_timer`和`kvm_riscv_vcpu_get_reg_timer`来完成；\n- 用户态hypervisor(qemu) 可以获得该vcpu的运行时间(time) 和 compare (t->next_cycles)\n\n### guest 访问\n\n主要文件: arch/riscv/kvm/vcpu_timer.c\n\n涉及的主要流程:\n```erlang\n-+ kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n \\ -+ kvm_riscv_guest_timer_init(kvm);\n    \\ -+ gt->time_delta = -get_cycles64();\n       \\ -  csr_read(CSR_TIME); \"获取 time csr 作为time_delta 值\"\n-+ kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)\n \\ -+ kvm_riscv_vcpu_timer_init(vcpu);\n    \\ -  kvm_vcpu_timer *t = &vcpu->arch.timer;\n    | -  hrtimer_init(&t->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL); \"初始化单调timer 定时器, 相对时间\"\n    | -  t->hrt.function = kvm_riscv_vcpu_hrtimer_expired; \"定时器restart 函数\"\n-+ kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu) \"vcpu load 时更新 htimedelta\"\n \\ -+ kvm_riscv_vcpu_timer_restore(vcpu);\n    \\ -  csr_write(CSR_HTIMEDELTA, (u32)(gt->time_delta)); \"更新htimedelta csr\"\n-+ case SBI_EXT_0_1_SET_TIMER: \"guest os ecall 调用sbi, sbi 请求由kvm 接管\"\n \\ -  cp = &vcpu->arch.guest_context \"guest_context 中保存了guest 运行时的通用寄存器\"\n | -  next_cycle = (u64)cp->a0; \n | -+ kvm_riscv_vcpu_timer_next_event(vcpu, next_cycle);\n    \\ -+ kvm_riscv_vcpu_unset_interrupt(vcpu, IRQ_VS_TIMER);\n       \\ -  clear_bit(irq, &vcpu->arch.irqs_pending); \"irqs_pending 中去除 IRQ_VS_TIMER\"\n    | -  delta_ns = kvm_riscv_delta_cycles2ns(ncycles, gt, t);\n    | -  t->next_cycles = ncycles;\n    | -+ hrtimer_start(&t->hrt, ktime_set(0, delta_ns), HRTIMER_MODE_REL); \"启动定时器, 周期为 delta_ns\"\n       \\ ----+ kvm_riscv_vcpu_hrtimer_expired(struct hrtimer *h)  \"定时器到期时, 调用该restart 函数\"\n             \\ -|+ if (kvm_riscv_current_cycles(gt) < t->next_cycles) \"定时器到期小于ncycles时, \"\n                 \\ -  delta_ns = kvm_riscv_delta_cycles2ns(t->next_cycles, gt, t);\n                 | -  hrtimer_forward_now(&t->hrt, ktime_set(0, delta_ns)); \"重定时定时器\"\n                 | -  return HRTIMER_RESTART;\n             | -|+ else\n                 \\ -+ kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_VS_TIMER);   \"设置 vcpu->arch.irqs_pending  IRQ_VS_TIMER\"\n                    \\ -  set_bit(irq, &vcpu->arch.irqs_pending);\n                    | -  kvm_vcpu_kick(vcpu);\n```\n\n\n上述流程有些混乱, 先梳理一下\n\n先回忆一下普通os的tick:\n- 设置time\n- 设置compare\ntime 追上compare 后, 触发timer 中断, 在中断处理函数中设置下一轮的compare. 循环往复.\n\n#### guest timer tick 处理\n\n从前文 kvm_riscv_vcpu_get_reg_timer 中的 `KVM_REG_RISCV_TIMER_REG(compare)` 来看, 就比较容易理解上述流程了.\nos 中调度时, tick 到期后, 需要重新设置compare.\n在riscv 中, guest os 设置compare 是需要发 `SBI_EXT_0_1_SET_TIMER` 的请求\n导致陷入到 kvm 中, kvm 接收的请求中第一个参数 `next_cycle` 即为下一轮的 compare 数.\n\n在guest 因设置 compare 请求导致陷入到 kvm 中, kvm 处理 `SBI_EXT_0_1_SET_TIMER`:\n- 首先清除了 IRQ_VS_TIMER 中断, 确保本轮tick中不再有有的timer 中断产生\n- 计算下一轮到期的时间 delta_ns (cycle 转换为 host的纳秒单位)\n- 启动定时器, 到期时间为 当前时间+delta_ns\n- 退出 kvm, 重返到 vcpu 运行环境\n\n定时器到期时, 触发中断重新陷入到 kvm 中, 处理函数为 kvm_riscv_vcpu_hrtimer_expired\n> 注意这时并不一定打断了设置compare的 vcpu的运行, 该函数有可能是被其他cpu 异步处理的.\n\n- 该函数首先判断到期的时间是否是小于 guest 设置的compare, 如果小于的话, 说明时间还没到, 需要重新计算定时时间, 启动定时器\n- 时间到了, 设置对应 vcpu->arch.irqs_pending 加入 IRQ_VS_TIMER, 如果是异步的处理, 调用 kvm_vcpu_kick(vcpu), 让该vcpu 退出运行, 回到kvm.\n- kvm 在下一轮 run vcpu 运行时会检查 vcpu->arch.irqs_pending, 如果有 IRQ_VS_TIMER, 会通过hvip 向该vcpu 注入虚拟timer 中断. 这样vcpu 再运行时, 在guest os中, 就能收到timer 中断, 进而由其 timer 中断处理函数处理. 这个流程可以理解为普通的os的tick到期的情况.\n\n上述过程可见, guest timer tick 处理路径还是比较长的, 效率也比较低\n\n#### guest time\n\n从上面看更新 htimedelta的地方只有 `gt->time_delta` , 这个变量的赋值来自于 kvm_arch_init_vm, 为负的vm 实例的创建时间.\n所以vcpu的 time 为 mtime+htimedelta = vm的运行时间.\n\n### sstc vstimecmp\nriscv 支持sstc 后, 增加了vstimecmp的csr\n\n开启/关闭 Sstc 的 stimecmp 功能是通过设置 \n- menvcfg.STCE (bit 31) 开启后支持 HS-mode的stimecmp 功能\n- henvcfg.STCE (bit 31) 开启后支持 VS-mode的stimecmp 功能\n\n> 如果 menvcfg.STCE=0, 则 VS 访问 stimecmp 会导致 illegal insn exception\n> 如果 henvcfg.STCE=0, menvcfg.STCE=1, 则VS访问 stimecmp 会导致virtual insn execption\n\n在Sstc.stimecmp 开启后还要开启 mcounteren 和 hcounteren的TM 位后, guest 才能直接访问 stimecmp 而不会导致异常.\n在 mcounteren.tm=1 且 hcounteren.tm=1 时, guest 可以直接访问 stimecmp csr, 而tm位被清0后, guest 访问stimecmp csr 会导致virtual insn exception.\n\nguest 在满足上述 `[m/h]envcfg.STCE` 和 `[m/h]counteren.TM` 后可以直接操作 stimecmp csr 来设置timer tick, 就不必再通过sbi 陷入到kvm中设置 compare, 也不需要kvm 维护定时器, 同时也不需要kvm 注入timer 虚拟中断给vcpu, 减少了两次陷入kvm, 大大提升了guest 处理 tick的效率. \ntick 到期后, 由硬件来保证vcpu 直接收到timer的虚拟中断, vcpu 不用陷入到kvm 就可以处理一轮轮的tick.\n\n\n## 中断虚拟化\n\n本章分两部分:\n- 不支持中断直通, 即只是中断注入的情况\n- 中断直通 aia\n\n### plic 中断注入\n\n中断控制器是qemu 模拟出来的\n参考前面的介绍\n\n通常 kvm_init函数会调用`kvm_irqchip_create`函数，后者在vm fd上调用ioctl(`KVM_CREATE_IRQCHIP`)告诉内核需要在KVM中模拟PLIC中断芯片。\n但是会检查 `KVM_CAP_IRQCHIP` 能力, 这里riscv 并不支持, 所以这条路不会走\n\n```erlang\n-+ kvm_irqchip_create(KVMState *s)\n \\ -  kvm_check_extension(s, KVM_CAP_IRQCHIP) \"这个地方检查没过, riscv 并不支持\"\n | -  ret = kvm_arch_irqchip_create(s);\n```\n\n大概看下 qemu中中断注册以及中断控制器模拟的流程:\n\n```erlang\ns->irqchip = virt_create_plic(memmap, 0, base_hartid, hart_count);\nif (i == 0) {\n\tmmio_irqchip = s->irqchip;\n\tvirtio_irqchip = s->irqchip;\n\tpcie_irqchip = s->irqchip;\n}\n\n-+ riscv_cpu_init(Object *obj)\n \\ -+ qdev_init_gpio_in(DEVICE(cpu), riscv_cpu_set_irq, IRQ_LOCAL_MAX + IRQ_LOCAL_GUEST_MAX);\n    \\ -  NamedGPIOList *gpio_list = qdev_get_named_gpio_list(DEVICE(cpu), name); \"name为NULL\"\n    | -+ gpio_list->in = qemu_extend_irqs(gpio_list->in, gpio_list->num_in, handler, opaque, n);\n       \\ -+ for i in n \"n为IRQ_LOCAL_MAX + IRQ_LOCAL_GUEST_MAX 共79\"\n\t      \\ -+  gpio_list->in[i] = qemu_allocate_irq(handler, opaque, i); \"新建了79个irq\"\n             \\ -  irq = IRQ(object_new(TYPE_IRQ));\n             | -  irq->handler = handler;\n             | -  irq->opaque = opaque;\n             | -  irq->n = n;\n-+ s->irqchip[i] = virt_create_plic(memmap, i, base_hartid, hart_count);\n \\ -+ sifive_plic_create(hwaddr addr, char *hart_config, num_harts, hartid_base, num_sources)\n    \\ -  DeviceState *dev = qdev_new(TYPE_SIFIVE_PLIC);\n    | -+ sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);\n\t   \\ ---+ sifive_plic_realize(DeviceState *dev) \"mmio_irqchip = s->irqchip[i] irq设备的初始化\"\n\t        \\ -+ qdev_init_gpio_in(dev, sifive_plic_irq_request, s->num_sources); \"sifive_plic_irq_request 为handler\"\n\t           \\ -  NamedGPIOList *gpio_list = qdev_get_named_gpio_list(dev, NULL);\n\t           | -  gpio_list->in = qemu_extend_irqs(gpio_list->in, gpio_list->num_in, sifive_plic_irq_request, opaque, n);\n\t        | -+ qdev_init_gpio_out(dev, s->s_external_irqs, s->num_harts);\n\t           \\ -  NamedGPIOList *gpio_list = qdev_get_named_gpio_list(dev, NULL);\n\t           | -+ for i in num_harts\n\t              \\ -  object_property_add_link(OBJECT(dev), propname, TYPE_IRQ, &s->s_external_irqs[i],\n                                 object_property_allow_set_link, OBJ_PROP_LINK_STRONG);\n\t| -+ for i in num_harts\n\t   \\ -  CPUState *cpu = qemu_get_cpu(hartid_base + i);\n\t   | -|+ if plic->addr_config[j].mode == PLICMode_S\n\t       \\ -+ qdev_connect_gpio_out(dev, i, qdev_get_gpio_in(DEVICE(cpu), IRQ_S_EXT)); \"i 为cpuid\"\n\t          \\ -  input_pin = qdev_get_gpio_in(DEVICE(cpu), IRQ_S_EXT) \n\t\t\t             \"找到前面为cpu创建的gpio_list->in[IRQ_S_EXT], IRQ_S_EXT为9, 对应supervisor external interrupt\"\n\t          | -  object_property_set_link(OBJECT(dev), propname, OBJECT(input_pin), &error_abort);\n\t\t\t             \"这个地方建立了链接 object_property_add_link 时 s_external_irqs[i] 指向了 cpu 的gpio_list->in[IRQ_S_EXT]\"\n\t\t\t             \"/machine/soc0/harts[0]/unnamed-gpio-in[9]\"\n-+ serial_mm_init(system_memory, memmap[VIRT_UART0].base, 0, \n\t\tqdev_get_gpio_in(DEVICE(mmio_irqchip), UART0_IRQ), \n\t\t399193, serial_hd(0), DEVICE_LITTLE_ENDIAN);\t\t\n \\ -+ qemu_irq irq = qdev_get_gpio_in(DEVICE(mmio_irqchip), UART0_IRQ)\n    \\ -+ NamedGPIOList *gpio_list = qdev_get_named_gpio_list(DEVICE(mmio_irqchip), NULL); \n\t\t\t    \"这个地方会找到 sifive_plic 设备初始化时建的gpio_list\"\n       \\ -+ for node in dev->gpios\n          \\ -  g_strcmp0(name, ngl->name) == 0\n          | -  return ngl\n    | -  return gpio_list->in[UART0_IRQ];\n | -+ SerialMM *smm = SERIAL_MM(qdev_new(TYPE_SERIAL_MM));\n    \\ ---+ serial_mm_realize(DeviceState *dev)\n         \\ -+ sysbus_init_irq(SYS_BUS_DEVICE(smm), &smm->serial.irq);\n            \\ -  qdev_init_gpio_out_named(DEVICE(dev), &smm->serial.irq, SYSBUS_DEVICE_GPIO_IRQ, 1);\n | -+ sysbus_connect_irq(SYS_BUS_DEVICE(smm), 0, irq);\n    \\ -+ qdev_connect_gpio_out_named(DEVICE(dev), SYSBUS_DEVICE_GPIO_IRQ, n, irq);\n       \\ -  object_property_set_link(OBJECT(dev), propname, OBJECT(input_pin), );\n               \"smm->serial.irq link 指向 mmio_irqchip 即 sifive_plic中断控制器的 gpio_list[in]->[UART0_IRQ]\"\n-+ sifive_plic_irq_request(void *opaque, int irq, int level)\n \\ -  SiFivePLICState *s = opaque;\n | -  sifive_plic_set_pending(s, irq, level > 0);\n | -+ sifive_plic_update(s);\n    \\ -  PLICMode mode = plic->addr_config[addrid].mode;\n    | -+ case PLICMode_S: \n       \\ -+ qemu_set_irq(plic->s_external_irqs[hartid - plic->hartid_base], level);\n                           \"s->external_irqs 指向了 cpu的gpio_list->in[IRQ_S_EXT]\"\n          \\ -+ irq->handler(irq->opaque, irq->n, level);\n             \\ -+ riscv_cpu_set_irq(opaque, irq, level) \"指向了为cpu安装的中断处理函数 riscv_cpu_set_irq\"\n                \\ -+ case IRQ_S_EXT:\n                   \\ -+ kvm_riscv_set_irq(cpu, irq, level);\n                      \\ -+ kvm_vcpu_ioctl(CPU(cpu), KVM_INTERRUPT, &virq); \n       --------------------------------> 陷入kernel <------------------------------------------------\n                         \\ -+ kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_VS_EXT);\n                            \\ -  set_bit(irq, &vcpu->arch.irqs_pending);\n                            | -  set_bit(irq, &vcpu->arch.irqs_pending_mask);\n                            | -  kvm_vcpu_kick(vcpu);\n                                  \"Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.\"\n-+ kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)\n \\ -+ kvm_riscv_vcpu_flush_interrupts(vcpu);\n    \\ -  val = READ_ONCE(vcpu->arch.irqs_pending[0]) & mask;\n    | -  csr->hvip |= val;\n | -+ kvm_riscv_update_hvip(vcpu);   \n    \\ -  csr_write(CSR_HVIP, csr->hvip);\n | - kvm_riscv_vcpu_enter_exit(vcpu); \"进入guest\"\n```\n\n从上面的过程分析调用链\nqemu使用GPIO来实现中断系统\n1. 首先cpu有gpio_in 接口\n2. 中断控制器 sifive_plic 有gpio_in 和 gpio_out, gpio_out 和 cpu 的gpio_in 接口关联\n3. 设备的gpio_out 和 sifive_plic的gpio_in 接口关联\n4. 当有中断发生时, 设备通过gpio_out 通知 sifive_plic, sifive_plic 通过gpio_out 通知 cpu的gpio_in\n5. cpu的gpio_in 的中断处理函数`riscv_cpu_set_irq`处理最终的中断, 并将中断状态通过kvm `ioctl(KVM_INTERRUPT)` 命令通知kvm, 由kvm完成最终的中断注入流程, 更新hvip\n6. 进入guest os后(V=1), hvip 注入中断会导致 V=1 时sip 置位, 如果sie相应位置位了, vcpu 会跳到中断入口, guest os 进而处理中断\n\n\n#### 中断注册(使能)流程\n不支持设备直通时, 外设都是qemu 模拟出来的, 外设注册中断也是通过 模拟的中断控制器注册的中断\nguest 在request_irq 的最后会通过设置cpu 亲和性使能特定的中断.\n\n使能的逻辑最终会陷入到 `sifive_plic_write` enable 区域\n\n```c\n//addrid 代表hart的偏移, wordid 代表中断号的偏移\nplic->enable[addrid * plic->bitfield_words + wordid] = value;  \n```\n\n\n#### 中断触发流程\n我们可以以uart 为入口点, uart调用了`qdev_get_gpio_in(DEVICE(mmio_irqchip), UART0_IRQ)` 绑定了 `UART_IRQ=10`的中断号的中断\n\n先看下uart mmio write处理的调用栈, 这里模拟了uart的中断控制器, 写入uart的配置寄存器后, uart需要触发中断给到kvm, kvm再注入到guest.\n这个中断的栈是比较重要的, 建议后面再详细看一下, 涉及了serial mmio 配置寄存器模拟的write, qemu调用printf 打印guest的信息, 以及qemu 打印完后, 模拟中断控制器, 将中断回给kvm, kvm最终将中断注入到guest的过程.\n\nqemu中最终的中断处理函数是为 cpu 注册的中断处理函数 `riscv_cpu_set_irq`处\n\n```erlang\n#0  riscv_cpu_set_irq (opaque=0xaaaaaadc047c80, irq=9, level=1) at ../target/riscv/cpu.c:695\n#1  0x00aaaaaadb76d1d8 in qemu_set_irq (irq=0xaaaaaadc05e670, level=1) at ../hw/core/irq.c:45\n#2  0x00aaaaaadb645f60 in sifive_plic_update (plic=0xaaaaaadc06aea0) at ../hw/intc/sifive_plic.c:121\n#3  0x00aaaaaadb646bc0 in sifive_plic_irq_request (opaque=0xaaaaaadc06aea0, irq=10, level=0) at ../hw/intc/sifive_plic.c:316\n#4  0x00aaaaaadb76d1d8 in qemu_set_irq (irq=0xaaaaaadc06c880, level=0) at ../hw/core/irq.c:45\n#5  0x00aaaaaadb28c880 in qemu_irq_lower (irq=0xaaaaaadc06c880) at /home/liguang/program/3rdparty/buildroot-2022.08.1/output/build/qemu-7.0.0/include/hw/irq.h:17\n#6  0x00aaaaaadb28cfcc in serial_update_irq (s=0xaaaaaadc3c47b0) at ../hw/char/serial.c:144\n#7  0x00aaaaaadb28d654 in serial_xmit (s=0xaaaaaadc3c47b0) at ../hw/char/serial.c:251\n#8  0x00aaaaaadb28dc04 in serial_ioport_write (opaque=0xaaaaaadc3c47b0, addr=0, val=103,\n size=1) at ../hw/char/serial.c:359\n#9  0x00aaaaaadb28f268 in serial_mm_write (opaque=0xaaaaaadc3c4490, addr=0, value=103, size=1) at ../hw/char/serial.c:1009\n#10 0x00aaaaaadb5dca84 in memory_region_write_accessor (mr=0xaaaaaadc3c4920, addr=0, value=0xffffff8da80008, size=1, shift=0, mask=255, attrs=...) at ../softmmu/memory.c:492\n#11 0x00aaaaaadb5dcdc8 in access_with_adjusted_size (addr=0, value=0xffffff8da80008, size=1, access_size_min=1, access_size_max=8, access_fn=0xaaaaaadb5dc970 <memory_region_write_accessor>, mr=0xaaaaaadc3c4920, attrs=...) at ../softmmu/memory.c:554\n#12 0x00aaaaaadb5e04c4 in memory_region_dispatch_write (mr=0xaaaaaadc3c4920, addr=0, data=103, op=MO_8, attrs=...) at ../softmmu/memory.c:1514\n#13 0x00aaaaaadb5f0df0 in flatview_write_continue (fv=0xaaaaaadc42f380, addr=268435456, attrs=..., ptr=0xffffff8d27f028, len=1, addr1=0, l=1, mr=0xaaaaaadc3c4920) at ../softmmu/physmem.c:2814\n#14 0x00aaaaaadb5f0fb4 in flatview_write (fv=0xaaaaaadc42f380, addr=268435456, attrs=..., buf=0xffffff8d27f028, len=1) at ../softmmu/physmem.c:2856\n#15 0x00aaaaaadb5f14b4 in address_space_write (as=0xaaaaaadbdd8c48 <address_space_memory>, addr=268435456, attrs=..., buf=0xffffff8d27f028, len=1) at ../softmmu/physmem.c:2952\n#16 0x00aaaaaadb5f1558 in address_space_rw (as=0xaaaaaadbdd8c48 <address_space_memory>, addr=268435456, attrs=..., buf=0xffffff8d27f028, len=1, is_write=true) at ../softmmu/physmem.c:2962\n#17 0x00aaaaaadb759448 in kvm_cpu_exec (cpu=0xaaaaaadc047c80) at ../accel/kvm/kvm-all.c:2929\n#18 0x00aaaaaadb75b1b4 in kvm_vcpu_thread_fn (arg=0xaaaaaadc047c80) at ../accel/kvm/kvm-accel-ops.c:49\n#19 0x00aaaaaadb983e94 in qemu_thread_start (args=0xaaaaaadc06ad00) at ../util/qemu-thread-posix.c:556\n```\n\n外设发送中断给cpu时, 在`sifive_plic_irq_request` 中检查中断的使能\n\n```erlang\n-+ sifive_plic_irq_request(void *opaque, int irq, int level)\n \\ -+ sifive_plic_set_pending(s, irq, level > 0);\n    \\ -  atomic_set_masked(&plic->pending[irq >> 5], 1 << (irq & 31), -!!level); \"设置中断号 对应pending位\"\n | -+ sifive_plic_update(s);\n    \\ -+ for (addrid = 0; addrid < plic->num_addrs; addrid++) \"遍历hart\"\n       \\ -+ level = !!sifive_plic_claimed(plic, addrid);\n          \\ -+ for (i = 0; i < plic->bitfield_words; i++) \"遍历中断号\"\n             \\ -  pending_enabled_not_claimed = \"检查中断号pending 以及 hart 对应的enable\"\n                        (plic->pending[i] & ~plic->claimed[i]) &\n                            plic->enable[addrid * plic->bitfield_words + i];\n             | -|+ if pending_enabled_not_claimed              \n                 \\ -  return max_irq;\n             | -|+ else\n                 \\ -  return 0;\n\t            \"判断给M-mode 还是给 S-mode, level为0代表关闭中断, level 为 1 代表需要注入中断\"\n       | -  uint32_t hartid = plic->addr_config[addrid].hartid;               \n       | -+ case PLICMode_M:\n          \\ -  qemu_set_irq(plic->m_external_irqs[hartid - plic->hartid_base], level); \n                \t\"enable了该中断的hart 需要注入中断,  其他的hart 不需要注入中断, hvip IRQ_VS_EXT 位 置0\"\n       | -+ case PLICMode_S:\n          \\ -  qemu_set_irq(plic->s_external_irqs[hartid - plic->hartid_base], level);\n```\n\n#### guest 中断处理流程\nkvm 在 kvm_riscv_vcpu_enter_exit 重新进入guest 后, 先前hvip 注入的IRQ_VS_EXT(10) 号中断转换为 sip IRQ_EXT(9) 号中断,\nguest os 直接跳到 stvec 的中断入口的地方.\n\nguest os 在中断处理函数中, 最终需要查中断控制器, 检查是哪一个外设的中断, 该查询操作最终陷入到 `sifive_plic_read`函数中\n落到 pending_base的地址,\n```c\nstatic uint64_t sifive_plic_read(void *opaque, hwaddr addr, unsigned size) {\n    } else if (addr_between(addr, plic->pending_base, plic->num_sources >> 3)) {\n        uint32_t word = (addr - plic->pending_base) >> 2;\n        return plic->pending[word];\n        ...\n}\n```\n查到对应的中断号后, 还需要设置claim, 声明中断已经处理完成.\n该操作会落到 context_base 地址, 为写请求, 所以落到 write 函数里.\n\n```c\nstatic void sifive_plic_write(void *opaque, hwaddr addr, uint64_t value, unsigned size) {\n\telse if (addr_between(addr, plic->context_base,\n                            plic->num_addrs * plic->context_stride)) {\n\t    ...\n        } else if (contextid == 4) {\n            if (value < plic->num_sources) {\n                sifive_plic_set_claimed(plic, value, false);\n                sifive_plic_update(plic);\n            }\n        ...\n}\n```\n\n通过 `sifive_plic_set_claimed` 函数声明中断处理完成, 通过 `sifive_plic_update` 关闭该hart 上的中断信号, 即清除hvip的IRQ_VS_EXT位.\n\n```c\nbool level = !!sifive_plic_claimed(plic, addrid);\nqemu_set_irq(plic->s_external_irqs[hartid - plic->hartid_base], level);\n```\n\n### AIA imsic 中断处理\n\n> 该章节中涉及的代码来自于 https://github.com/avpatel/linux/ riscv_kvm_aia_irqchip_v3 分支\n\nqemu 版本 github 主线 https://github.com/qemu/qemu 或 https://github.com/avpatel/qemu\nkvmtool 版本 https://github.com/avpatel/kvmtool riscv_aia_v1 分支\n\n使用 qemu linux kernel  x86 平台模拟 riscv 主机\n使用 kvmtool 编译的 lkvm 执行 guest kernel, guest kernel 和 host kernel 使用的都是 riscv_kvm_aia_irqchip_v3 编译出的kernel\n\n```shell\n\"host 模拟riscv 主机\"\n$QEMU -m 2G -nographic \\\n\t-M virt,aclint=on,aia=aplic-imsic,aia-guests=3 \\\n\t-kernel $KERNEL_BIN \\\n\t-drive file=$ROOT_IMAGE,format=raw,id=hd0 \\\n\t-device virtio-blk-device,drive=hd0 \\\n\t-append \"root=/dev/vda rw earlycon=sbi console=ttyS0 crashkernel=64M\" \\\n\t-smp $SMP \\\n\t$DEBUG \\\n\t-device virtio-net-device,netdev=net0 \\\n    -netdev user,id=net0,net=192.168.100.1/24,hostfwd=tcp::${HOST_PORT}-:22,hostfwd=tcp::6666-:6666 \\\n    -device virtio-rng-pci \\\n    -device edu \\\n    -bios $OPENSBI_BIN \\\n\n\"kvmtool 启动 kvm-mode guest\"\n./lkvm run -k Image -d rootfs.ext2\n```\n\n\n在介绍imsic 之前, 先看下riscv kvm 的virtual insn exception 的陷入路径\n其中guest 读写imsic 相关csr 的模拟会经由这个路径最终转发到kvm进行处理\n\n```erlang\n-+ kvm_riscv_vcpu_exit(struct kvm_vcpu *vcpu, struct kvm_run *run,\n\t\t\tstruct kvm_cpu_trap *trap)\n \\ -  switch (trap->scause)\n | -+ case EXC_VIRTUAL_INST_FAULT:\t\"同时check vcpu->arch.guest_context.hstatus & HSTATUS_SPV\"\n    \\ -+ virtual_inst_fault(vcpu, run, trap);\n       \\ -  insn = trap->stval;\n       | -  switch ((insn & INSN_OPCODE_MASK) >> INSN_OPCODE_SHIFT) \n       | -+ case INSN_OPCODE_SYSTEM:\n          \\ -+ system_opcode_insn(vcpu, run, insn);\n             \\ -+ for (i = 0; i < ARRAY_SIZE(system_opcode_funcs); i++) \"遍历 system_opcode_funcs\"\n                \\ -  ifn = &system_opcode_funcs[i]; \"(insn & ifn->mask) == ifn->match\"\n                | -  ifn->func(vcpu, run, insn) \"match ifn->mask opcode 时转入对应的处理函数\"\t\n```\n\n看一下 system_opcode_funcs, 包含了对guest 中因 `csrrw csrrs csrrc csrrwi CSRRSI CSRRCI` 及 WFI 指令导致异常陷入kvm时的处理\n\n```c\nstatic const struct insn_func system_opcode_funcs[] = {\n\t{\n\t\t.mask  = INSN_MASK_CSRRW,\n\t\t.match = INSN_MATCH_CSRRW,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_CSRRS,\n\t\t.match = INSN_MATCH_CSRRS,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_CSRRC,\n\t\t.match = INSN_MATCH_CSRRC,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_CSRRWI,\n\t\t.match = INSN_MATCH_CSRRWI,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_CSRRSI,\n\t\t.match = INSN_MATCH_CSRRSI,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_CSRRCI,\n\t\t.match = INSN_MATCH_CSRRCI,\n\t\t.func  = csr_insn,\n\t},\n\t{\n\t\t.mask  = INSN_MASK_WFI,\n\t\t.match = INSN_MATCH_WFI,\n\t\t.func  = wfi_insn,\n\t},\n};\n```\n\n来看一下 csr_insn\n\n```erlang\n-+ csr_insn(struct kvm_vcpu *vcpu, struct kvm_run *run, ulong insn)\n \\ -  csr_num = insn >> SH_RS2; \" csrw/csrr 的操作csr\"\n | -  rs1_num = (insn >> SH_RS1) & MASK_RX; \"csrw/csrr 中的通用寄存器 index\"\n | -  rs1_val = GET_RS1(insn, &vcpu->arch.guest_context); \"\"\n | -  csr_funcs = { .base = CSR_SIREG,      .count = 1, .func = kvm_riscv_vcpu_aia_rmw_ireg }, \\\n\t\t\t\t  { .base = CSR_STOPEI,     .count = 1, .func = kvm_riscv_vcpu_aia_rmw_topei },\n | -+ for (i = 0; i < ARRAY_SIZE(csr_funcs); i++) \"遍历csr_funcs\"\n    \\ -|+ if ((tcfn->base <= csr_num) && (csr_num < (tcfn->base + tcfn->count))) \n                \"match 参数传入的csr_num 与 csr_funcs 注册的 csr_num\"\n        \\ -+ cfn->func(vcpu, csr_num, &val, new_val, wr_mask) \"调用对应的 csr_funcs 注册的函数\" \n```\n\n如操作的csr 为 stopei 寄存器, 则会由 kvm_riscv_vcpu_aia_rmw_topei 进行处理 \n\n```erlang\n-+ kvm_riscv_vcpu_aia_rmw_topei(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned int csr_num,\n\t\t\t\t unsigned long *val,\n\t\t\t\t unsigned long new_val,\n\t\t\t\t unsigned long wr_mask)\n\\ -+ kvm_riscv_vcpu_aia_imsic_rmw(vcpu, KVM_RISCV_AIA_IMSIC_TOPEI,\n\t\t\t\t\t    val, new_val, wr_mask) \"wr_mask 代表为写请求\"\n   \\ -+ imsic_swfile_topei_rmw(vcpu, val, new_val, wr_mask);\n      \\ -  imsic *imsic = vcpu->arch.aia.imsic_state; \"imsic_state 是保存在vcpu 中的\"\n   \t  \\ -+ topei = __imsic_swfile_topei(imsic);\n   \t     \\ -+ for (i = 1; i < max_msi; i++) \"max_msi 来自于 swfile->eithreshold 和 imsic->nr_msis\"\n   \t        \\ -|+ if (test_bit(i, swfile->eie) && test_bit(i, swfile->eip)) \"i 越小, 代表优先级越高, i 从0开始遍历, \n   \t        \t\t\t\t\t\t\t\t\t\t\t\teip&eie 的i位都置1了, 说明i位中断pending, 代表最高优先级的中断\"\n   \t            \\ -  return (i << TOPEI_ID_SHIFT) | i;\n   \t  | -  *val = topei;\t\"读最大优先级的pending 中断\"\n   \t  | - \"省略csrw stopei 的处理...\"\t     \t\t\t\t \n```\n\n\n上述逻辑符合 riscv-aia spec 中的描述, 在csrw/csrr stopei 时需要陷入到kvm中进行处理\n这里需要关注下 属于vcpu的 `imsic_state` 结构\n\n```c\nstruct imsic_mrif_eix {\n\tunsigned long eip[BITS_PER_TYPE(u64) / BITS_PER_LONG];\n\tunsigned long eie[BITS_PER_TYPE(u64) / BITS_PER_LONG];\n};\n\nstruct imsic_mrif {\n\tstruct imsic_mrif_eix eix[IMSIC_MAX_EIX];\n\tunsigned long eithreshold;\n\tunsigned long eidelivery;\n};\n\nstruct imsic {\n\tstruct kvm_io_device iodev;\n\n\tu32 nr_msis;\n\tu32 nr_eix;\n\tu32 nr_hw_eix;\n\t/* IMSIC VS-file */\n\trwlock_t vsfile_lock;\n\tint vsfile_cpu;\n\tint vsfile_hgei;\n\tvoid __iomem *vsfile_va;\n\tphys_addr_t vsfile_pa;\n\n\t/* IMSIC SW-file */\n\tstruct imsic_mrif *swfile;\n\tphys_addr_t swfile_pa;\n};\n```\n\n为什么需要软件维护 swfile 这样的数据\n\n为什么模拟这么一套 imsic的机制进来, 可能是为了兼容 guest os的aia 中断机制.\n且imsic 做到了kvm 中进行模拟, 应该比做到qemu 中模拟中断控制器的效率更高.\n对应 `kvm_irqchip_in_kernel` 的情况, qemu 中调用 `kvm_riscv_aia_create` -> `kvm_device_access(aia_fd, KVM_DEV_RISCV_AIA_GRP_CTRL,  KVM_DEV_RISCV_AIA_CTRL_INIT, NULL, true, NULL);` 对aia 进行初始化, 初始化后\n`kvm->arch.aia.initialized = true;`\n\n在vcpu 退出到kvm后, 下一轮进入guest 前, 会对imsic 的状态进行更新\n\n#### kvm_riscv_vcpu_aia_update\n\n```erlang\n-+ kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)\n \\ -+ while (ret > 0) {\n    \\ -  kvm_riscv_vcpu_aia_update(vcpu);\n    | -  kvm_riscv_vcpu_enter_exit(vcpu);\n    | -  kvm_riscv_vcpu_exit(vcpu, run, &trap);\n\n-+ kvm_riscv_vcpu_aia_update(struct kvm_vcpu *vcpu)\n \\ -+ kvm_riscv_vcpu_aia_imsic_update(vcpu);\n    \\ -  kvm_vcpu_aia *vaia = &vcpu->arch.aia_context;\n    | -  imsic = vaia->imsic_state;\n    | -  old_hgei = imsic->hgei;\n    | -  old_hgei_cpu = imsic->hgei_cpu;\n    | -|+ if (old_hgei_cpu != vcpu->cpu) \"初次分配 IMSIC VS-file\"\n        \\ -  hgctrl = per_cpu_ptr(&aia_hgei, cpu)\n        | -  ret = __ffs(hgctrl->free_bitmap); \"返回最低位之后第一个1的位置\"\n        \\ -+ kvm_riscv_aia_alloc_hgei(vcpu->cpu, vcpu,\n\t\t\t\t       &new_vsfile_va, &new_vsfile_pa); \"分配新的IMSIC VS-file\"\n           \\ -  lc = imsic_get_local_config(cpu); \"硬件 imsic 支持, lc 会传回imsic 驱动中的 imsic_local_config\"\n           | -  *hgei_va = lc->msi_va + (ret * IMSIC_MMIO_PAGE_SZ);\n           | -  *hgei_pa = lc->msi_pa + (ret * IMSIC_MMIO_PAGE_SZ); \"硬件imsic 的guest interrupt file的mmio地址?\"\n        | -  new_vsfile_hgei = ret;\n        | -  imsic_vsfile_local_clear(new_hgei, imsic->nr_hw_longs); \"清零 IMSIC VS-file\"\n        | -  kvm_riscv_gstage_ioremap(kvm, gpa:vcpu->arch.aia_context.imsic_addr, \"建立imsic gpa -> hpa 的 G-stage 页表\"\n\t\t\t\t       hpa:new_vsfile_pa, IMSIC_MMIO_PAGE_SZ, true, true);\n\t\t\t\t         \"arch.aia.imsic_addr 是由qemu 传过来的, 配置的 memmap[VIRT_IMSIC_S].base\"\n\t\t| -  imsic->vsfile_cpu = vcpu->cpu; \"imsic 关联物理cpu\"\t\t\t        \n\t\t| -  imsic->vsfile_va = new_vsfile_va;\n\t\t| -  imsic->vsfile_pa = new_vsfile_pa;\n\t\t| -+ imsic_swfile_read(vcpu, clear: true, &tmrif);  \"/* Read and clear register state from IMSIC SW-file */\"\n\t\t             \"读入 tmrif 临时内存\"\n\t\t   \\ -+ memcpy(mrif, imsic->swfile, sizeof(*mrif));  \"将 imsic->swfile 拷贝给tmrif\"\n\t\t| -+ imsic_vsfile_local_update(new_vsfile_hgei, imsic->nr_hw_eix, &tmrif);\n\t\t   \\ -  new_hstatus |= ((unsigned long)vsfile_hgei) << HSTATUS_VGEIN_SHIFT; \n\t\t\t\t\t\t   \"更新 hstatus, 注意hstatus.vgein, vsfile_hgei为 vcpu 在 cpu->free_bitmap 的占位\"        \n\t\t   | -  csr_write(CSR_HSTATUS, new_hstatus);\n\t\t   | -+ for (i = 0; i < nr_eix; i++) \"nr_eix = imsic->nr_hw_eix 为 eip/eie 的数目, 遍历eip/eie\"\n\t\t      \\ -  eix = &mrif->eix[i];\n\t\t      | -+ imsic_eix_set(IMSIC_EIP0 + i * 2, eix->eip[0]); \n\t\t\t      \"从 imsic->swfile 拷贝到的临时内存中取出eip的值, 最终通过 CSR_VSISELECT CSR_VSIREG 更新真实imsic 中断控制器的 eip, \n\t\t\t\t      下eie 的设置同eip\"\n\t\t\t\t \\ -  csr_write(CSR_VSISELECT, __c);\n\t\t\t\t | -  csr_set(CSR_VSIREG, __v);    \n\t\t      | -  imsic_eix_set(IMSIC_EIE0 + i * 2, eix->eie[0]);\n\t\t   | -  csr_write(CSR_HSTATUS, old_hstatus);  \"这个地方又把hstatus 设置回old_hstatus\" \n```\n\n简单分析下上面函数的几个重点:\n1. hstatus.vgein的设置, 为物理hart 分配vcpu时, 会在其关联的 free_bitmap 中分配占位, 而该占位的index 可以视为 vcpuid, 将vcpuid 最终存到了hstatus.vgein下\n    更新物理imsic 中断控制器的eip/eie 前设置了新的hstatus.vgein, 更新完后又恢复到old hstatus.vgein, 正好证明imsic 控制器的guest interrupt file 是由hstatus.vgein 片选的.\n2. 注意软件维护的imsic->swfile 内存, imsic 数据结构是关联到vcpu的, 而swfile 代表的是软件维护的备份的 guest interrupt file 内存, 设置硬件imsic 的eip/eie 的数据来源为swfile.\n3. 该函数中通过 `kvm_riscv_gstage_ioremap` 设置了一次 gpa->hpa 的 G-stage 页表, gpa 为 vcpu->arch.aia.imsic_addr, hpa 为从硬件关联的 imsic 中断控制器(drivers/irqchip/riscv-imsic.c) 中 imsic_get_local_config 取到的 msi_pa + vcpu(guest_index) 的 guest interrupt file 的 mmio 地址, 建立了 G-stage 页表后, guest os 访问 qemu 模拟的 imsic 控制器的 mmio 地址就能直接访问到真实的 imsic 的 guest interrupt file 的 mmio 地址上了? 这一块还是有写疑问, 需要后面 check #TODO 这个地方进一步调研后发现建立的 io G-stage 页表并没有带有 ` PTE_U ` 的 flag, 而根据 SPEC 的行为, 没有 PTE_U 时, load/store 操作 gva 时会导致 G-stage 翻译失败, 陷入 LOAD/STORE guest page fault. 也就是说 guest os 直接访问 imsic 的地址时, 并没有因为映射了 G-stage 页表就会通过 mmu 的 2-stage 地址转换, 反而还是会陷入 kvm. 那么设置 G-stage 页表的作用是什么呢? #TODO\n\n接下来我们看下更新 kvm 为 vcpu 维护的 imsic->swfile.\n\nguest 有三种方式设置直通的中断\n- guest 通过 csrw/csrr 访问 siselect sireg 设置 eip/eie.\n- guest 通过直接操作 imsic 控制器的 mmio 地址设置 eip/eie, 访问 seteipnum 地址触发中断. \n- 直通的 pcie 设备(走 vfio 驱动) 通过发送 msi 消息触发 msi 的中断.\n\n####  guest 访问 siselect sireg\n\n这种方式同 访问stopei, guest os 在 csrr/csrw sireg 陷入kvm\n\n```erlang\n| -  new_val = rs1_val;\n| -  isel = csr_read(CSR_VSISELECT) & ISELECT_MASK; \"陷入到kvm后, guest的siselect 转换为host的 viselect, \n\t\t\t\t\t\t\t\t\t\t\t\t\t不用额外处理 guest 中 siselect 的读写?\"\n-+ kvm_riscv_vcpu_aia_imsic_rmw(struct kvm_vcpu *vcpu, unsigned long isel,\n\t\t\t\t unsigned long *val, unsigned long new_val,\n\t\t\t\t unsigned long wr_mask)\n \\ -  imsic = vcpu->arch.aia_context.imsic_state;\t\t\t\t \n | -+ imsic_mrif_rmw(imsic->swfile, imsic->nr_eix, isel, val, new_val, wr_mask);\n    \\ -  switch (isel)\t\t\t\t \n    | -+ case IMSIC_EIP0 ... IMSIC_EIP63:\n       \\ -  pend = true;\n       | -  num = isel - IMSIC_EIP0;\n       | -  eix = &mrif->eix[num / 2];\n       | -  ei = (pend) ? &eix->eip[0] : &eix->eie[0];\n       | -+ imsic_mrif_atomic_rmw(imsic->swfile, ei, new_val, wr_mask); \"更新imsic->swfile 对应的 eipx 状态\"\n   | -   \"... 省略eie的处理, 过程同eip\"\n```\n\n最终将 eip/eie 的状态保存了kvm维护的vcpu->imsic->swfile中, vcpu 下一轮进入guest 中通过前面介绍的`kvm_riscv_vcpu_aia_update` 更新到硬件imsic相应的guest interrupt file中.\n\n#### 访问 imsic mmio 由kvm 注入中断\n\nguest 通过访问imsic mmio 地址, 通过 SETIPNUM 地址向某一个vcpu 设置中断.\ndoorbell 机制, vcpu 没在运行, 此时通过访问 imsic 的 mmio 地址通过 SETIPNUM 向某一个 vcpu 触发中断.\n\n```erlang\n----->qemu<-------\n-+ kvm_riscv_aia_create(       \"kvm_irqchip_in_kernel 时\"\n            aplic_s, msimode, socket,\n            VIRT_IRQCHIP_NUM_SOURCES,\n            hart_count,\n            memmap[VIRT_APLIC_S].base + socket * memmap[VIRT_APLIC_S].size,\n            memmap[VIRT_IMSIC_S].base + socket * VIRT_IMSIC_GROUP_MAX_SIZE);\n \\ -  aia_fd = kvm_create_device(kvm_state, KVM_DEV_TYPE_RISCV_AIA, false);\n | -+ for (int i = 0; i < hart_count; i++)\n    \\ -+ kvm_device_access(aia_fd, KVM_DEV_RISCV_AIA_GRP_ADDR, KVM_DEV_RISCV_AIA_ADDR_IMSIC(i),\n                                &imsic_addr, true, NULL);\n | -+ kvm_device_access(aia_fd, KVM_DEV_RISCV_AIA_GRP_CTRL, KVM_DEV_RISCV_AIA_CTRL_INIT, NULL, true, NULL);                         \n------> kernel <-----------\n    \\ -+ case KVM_DEV_RISCV_AIA_GRP_CTRL:\n       \\ -+ case KVM_DEV_RISCV_AIA_CTRL_INIT:\n          \\ -+ r = aia_init(dev->kvm);\n               \\ -+ kvm_for_each_vcpu(idx, vcpu, kvm) \"遍历kvm的所有vcpu\"\n                  \\ -+ kvm_riscv_vcpu_aia_imsic_init(vcpu); \n                     \\ -  imsic = kzalloc(sizeof(*imsic), GFP_KERNEL); \"为每个vcpu 分配imsic\"\n                     | -  swfile_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,  get_order(sizeof(*imsic->swfile))); \n                \t\t\t\t\t\t\t\t\t\t\t\"分配 swfile 内存\"\n                     | -  imsic->swfile = page_to_virt(swfile_page);\n                     | -+ kvm_iodevice_init(&imsic->iodev, &imsic_iodoev_ops); \n                \t\t\t\t\"创建 kvm_io_dev, 读写函数为 imsic_mmio_read imsic_mmio_write\"\n                        \\ -  imsic_iodoev_ops = {.read = imsic_mmio_read, .write = imsic_mmio_write}                     \n                     | -  kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, vcpu->arch.aia_context.imsic_addr, \n\t\t\t                     KVM_DEV_RISCV_IMSIC_SIZE, &imsic->iodev); \"将该设备加到 KVM_MMIO_BUS 总线上\n\t\t\t\t\t                     地址范围为 [imsic_addr , imsic_addr+ KVM_DEV_RISCV_IMSIC_SIZE]\"\n\t\t\t\t\t                     \n\"guest 访问 gpa 为  [imsic_addr , imsic_addr+ KVM_DEV_RISCV_IMSIC_SIZE] 的地址范围时, 应该是SETIPNUM 地址\n\t\t 会先由kvm 查找 KVM_MMIO_BUS 上的地址范围, 落在其内, 最终转发给其对应的读写函数, 具体过程参考arm的vgic的处理流程\"\n1. ->\t\t\t\t                     \n-+ imsic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,  gpa_t addr, int len, const void *val)       \n \\ -  msi.address_hi = addr >> 32;\n | -  msi.address_lo = (u32)addr;\n | -  msi.data = *((const u32 *)val);\n | -+ kvm_riscv_aia_inject_msi(vcpu->kvm, &msi);\n    \\ -  target = (((gpa_t)msi->address_hi) << 32) | msi->address_lo;\n    | -  tppn = target >> IMSIC_MMIO_PAGE_SHIFT;\n    | -  iid = msi->data; \"中断号\"\n    | -  g = tppn & (BIT(aia->nr_guest_bits) - 1); \"通过 imsic 的mmio地址判断 给到哪个 guest interrupt file, 即算出 guest index\"\n    | -+ kvm_for_each_vcpu(idx, vcpu, kvm) \"遍历kvm的所有vcpu\"\n       \\ -  ippn = vcpu->arch.aia_context.imsic_addr >> IMSIC_MMIO_PAGE_SHIFT; \n\t\t\t       \"vcpu的imsic_addr 是特定的, 这个地址是前面 qemu 通过 KVM_DEV_RISCV_AIA_GRP_ADDR 发到kvm的\"\n\t   | -|+ if (ippn == tppn)\n\t       \\ -  toff = target & (IMSIC_MMIO_PAGE_SZ - 1); \"toff 代表 IMSIC_MMIO_SETIPNUM_BE 还是 IMSIC_MMIO_SETIPNUM_LE\"\n\t       \\ -+\tkvm_riscv_vcpu_aia_imsic_inject(vcpu, guest_index:g, offset:toff, iid); \n\t          \\ -  iid = (offset == IMSIC_MMIO_SETIPNUM_BE) ? __swab32(iid) : iid;\n\t          | -  eix = &imsic->swfile->eix[iid / BITS_PER_TYPE(u64)];\n\t          | -  set_bit(iid & (BITS_PER_TYPE(u64) - 1), eix->eip); \"由中断号 iid 定位到对应的eip, 设置swfile的eip\"\n\t          | -|+ if (imsic->vsfile_cpu >= 0)\n\t              \\ -  writel(iid, imsic->vsfile_va + IMSIC_MMIO_SETIPNUM_LE); \"直接写host 真实的中断控制器的 vs interrupt file的内存, 触发vs中断.\"\n\t              | -  kvm_vcpu_kick(vcpu);\n\t          | -|+ else \n\t              \\ -+ imsic_swfile_extirq_update(vcpu); \n\t                 \\ -  imsic_mrif_topei(imsic->swfile, imsic->nr_eix, imsic->nr_msis)) \n                                        \"更新 vcpu的 imsic->swfile 的 stopei 为对应的中断号和优先级\" \n\t                 | -+ kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_VS_EXT); \"直接由hvip 给vcpu 注入中断\"\n\t                    \\ -  set_bit(irq, vcpu->arch.irqs_pending);\n\t                    | -  kvm_vcpu_kick(vcpu);   \"将vcpu 踢出来, 退出到kvm, 下一轮进guest 时会通过 kvm_riscv_vcpu_aia_update 函数\n                                                  将swfile 更新到硬件中断控制器的guest interrupt file 中\"                 \n```\n\n第一条路径更适合于其他vcpu 向某一个vcpu 注入直通的中断\n- 如果可以直接拿到真实 imsic virtual interrupt file 的地址, 该地址是从 host imsic 驱动中拿到的该 vcpu 对应的 cpu 上的 virtual interrupt file 地址, 则可以直接写 SETIPNUM 触发相应的 guest 直通中断.\n- 如拿不到真实 imsic virtual interrupt file 地址, 则更新中断到了 vcpu->imsic->swfile 内存中, 而 kvm_vcpu_kick 将 vcpu 踢出来, 退出到 kvm, 下一轮进 guest 时会通过 kvm_riscv_vcpu_aia_update 函数将 vcpu->imsic->swfile 状态更新到硬件中断控制器的 guest interrupt file 中\n\n> 值得注意的是, 经过调试发现, guest os 中发送 ipi 中断 (`imsic_ipi_send` 函数), 也会经过上述路径最终写入到了 virtual interrupt file 的 SETIPNUM, 触发了对应 vcpu 的 guest 中断, 但是最终还是走了 kvm_vcpu_kick 将对应 vcpu 从 sleep 或 guest 运行状态中拖出到 kvm 下? 如果 vcpu 处在 guest 运行时, 不是可以直接触发直通中断吗, 为什么还需要 kick 呢? 这一点不太理解 #TODO\n\n![](attachments/guest_vs_int.png)\n\n```erlang\n2. ->\n-+ case KVM_SIGNAL_MSI:\n \\ -+ kvm_send_userspace_msi(kvm, &msi);\n    \\ -  route.msi.address_lo = msi->address_lo;\n    | -  route.msi.address_hi = msi->address_hi;\n    | -  route.msi.data = msi->data;\n    | -  route.msi.devid = msi->devid;\n    | -+ kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false)\n       \\ -  msi.address_lo = e->msi.address_lo;\n       | -  msi.address_hi = e->msi.address_hi;\n       | -  msi.data = e->msi.data;\n       | -  msi.devid = e->msi.devid;\n       | -+ kvm_riscv_aia_inject_msi(kvm, &msi);\n```\n第二条路径中, user_space 通过ioctl(KVM_SIGNAL_MSI) 发送msi 消息过来注册中断, 这个通常是pcie设备的模拟, pcie 设备注册中断时会通过该路径注册中断.\n\n#### imsic doorbell 中断\n\n在 aia_hgei_init 函数中, 注册了IRQ_S_GEXT (12)的中断处理函数 `hgei_interrupt`, 在IRQ_S_GEXT 的中断到来时进入 `hgei_interrupt` 进行处理, 读对应的直通guest中断映射的vcpuid, 唤醒对应的vcpu进入 KVM_RUN的循环中, 进而处理对应的直通中断. \n处理imsic->swfile的pending, 注入中断到虚拟机.\n\n```erlang\n-+ kvm_riscv_aia_init\n \\ -+ aia_hgei_init\n    \\ -+ domain = irq_find_matching_fwnode(riscv_get_intc_hwnode(), DOMAIN_BUS_ANY);\n       \\ -  hgei_parent_irq = irq_create_mapping(domain, IRQ_S_GEXT); \"hwirq 映射的 virq\"\n       | -  request_percpu_irq(hgei_parent_irq, hgei_interrupt, \"riscv-kvm\", &aia_hgei); \"doorbell的中断处理函数为 hgei_interrupt\"\n-+ hgei_interrupt\n \\ -  hgei_mask = csr_read(CSR_HGEIP) & csr_read(CSR_HGEIE);\n | -  csr_clear(CSR_HGEIE, hgei_mask); \"清理hgeie\"\n | -+ for_each_set_bit(i, &hgei_mask, BITS_PER_LONG)\n\t\\ -  kvm_vcpu_kick(hgctrl->owners[i]) \"hgei_mask 代表vcpuid, 踢vcpu 到 KVM_RUN 循环中, 紧接着处理对应的异常\"\n```\n\n#### qemu MSI/MSIX 信息\n\n当guest os kernel 写入vfio-device的配置空间配置msi/msix时 (向msi/msi-x的capability structure中写入msi/msi-x enable bit), 会陷入到kvm mmio_exit, 进而陷入到qemu中提前注册的处理函数 vfio_pci_write_config\n最终下发ioctl KVM_SET_GSI_ROUTING 发给kvm, kvm 经由imsic 注册对应的 `kvm_kernel_irq_routing_entry`, msi 类型, 其entry的 set 设置为 `kvm_set_msi`\n这一层为 guest的pcie 设备启用msi的中断\n\n```erlang\nmemory_region_init_io(&e->mmio, OBJECT(e), &pcie_mmcfg_ops, e, \"pcie-mmcfg-mmio\", PCIE_MMCFG_SIZE_MAX);\nstatic const MemoryRegionOps pcie_mmcfg_ops = {\n    .read = pcie_mmcfg_data_read,\n    .write = pcie_mmcfg_data_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n};\n-+ pci_host_config_write_common(pci_dev, addr, limit, val, len);\n \\ -+ pci_host_config_write_common(pci_dev, addr, limit, val, len);\n    \\ -+ pci_dev->config_write(pci_dev, addr, val, MIN(len, limit - addr));\n       \\ -+ vfio_pci_write_config(pci_dev, addr, val, MIN(len, limit - addr));\n          \\ -|+ if (pdev->cap_present & QEMU_PCI_CAP_MSI\n              \\ -+ vfio_msi_enable(vdev);\n                 \\ -  vdev->nr_vectors = msi_nr_vectors_allocated(&vdev->pdev);\n                 | -+ for (i = 0; i < vdev->nr_vectors; i++)\n                    \\ -  VFIOMSIVector *vector = &vdev->msi_vectors[i];\n                    | -+ vfio_add_kvm_msi_virq(vdev, vector, i, false);\n                       \\ -+ vector->virq = kvm_irqchip_add_msi_route(&vfio_route_change, vector_n, &vdev->pdev)\n                          \\ -  virq = kvm_irqchip_get_virq(s);\n                          | -  kroute.gsi = virq;\n                          | -  kroute.type = KVM_IRQ_ROUTING_MSI;\n                          | -  kroute.u.msi.address_lo = (uint32_t)msg.address;\n                          | -  kroute.u.msi.data = le32_to_cpu(msg.data);\n                          | -  kroute.u.msi.devid = pci_requester_id(dev);\n                          | -+ kvm_add_routing_entry(s, &kroute); \"将kroute 写到 KVMState 中\"\n                          | -  c->changes++;\n                 | -+ vfio_commit_kvm_msi_virq_batch(vdev);\n                    \\ -+ kvm_irqchip_commit_route_changes(&c);\n                          \\ -|+ if c->changes\n                              \\ -+ kvm_irqchip_commit_routes(c->s);\n                                 \\ -  kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);\n\t\t\t\t\t\t\t\t\t--------->kernel<-----------------\n\t\t\t\t\t\t\t\t\t\t-+ case KVM_SET_GSI_ROUTING:\n\t\t\t\t\t\t\t\t\t\t \\ -|+ if kvm_arch_can_set_irq_routing\n\t\t\t\t\t\t\t\t\t\t     \\ -+ kvm_set_irq_routing(kvm, entries, routing.nr, routing.flags);\n\t\t\t\t\t\t\t\t\t\t        \\ -+ for (i = 0; i < nr; ++i)\n\t\t\t\t\t\t\t\t\t\t           \\ -+ setup_routing_entry(kvm, new, e, ue);\n\t\t\t\t\t\t\t\t\t\t              \\ -+ kvm_set_routing_entry(kvm, e, ue);\n\t\t\t\t\t\t\t\t\t\t                 \\ -  switch (ue->type)\n\t\t\t\t\t\t\t\t\t\t                 | -+ case KVM_IRQ_ROUTING_MSI:\n\t\t\t\t\t\t\t\t\t\t                    \\ -  e->set = kvm_set_msi; \n                                                                      \"entry的set函数设置为 kvm_set_msi, 进而接入 aia的中断注册函数\"\n\t\t\t\t\t\t\t\t\t\t                    | -  e->msi.address_lo = ue->u.msi.address_lo;   \"标记地址\"\n\t\t\t\t\t\t\t\t\t\t                    | -  e->msi.address_hi = ue->u.msi.address_hi;\n\t\t\t\t\t\t\t\t\t\t                    | -  e->msi.data = ue->u.msi.data; \"标记eventid\"\n\t\t\t\t\t\t\t\t\t\t                    | -  e->msi.devid = ue->u.msi.devid; \"标记 deviceid\"\n\t\t\t\t\t| -+ for (i = 0; i < vdev->nr_vectors; i++)\n\t\t\t\t\t   \\ -+ vfio_connect_kvm_msi_virq(&vdev->msi_vectors[i]);\n\t\t\t\t\t      \\ -  event_notifier_init(&vector->kvm_interrupt, 0)\t\"注册kvm_interrupt的eventfd, 不激活\"\t        \n                          | -+ kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n:&vector->kvm_interrupt, NULL, vector->virq)\n                             \\ -+ kvm_irqchip_assign_irqfd(s, event:n, rn, virq, true);\n                                \\ -  fd = event_notifier_get_fd(event);\n                                | -  irqfd = {.fd = fd, .gsi = virq, } \"从eventfd 构建 irqfd\"\n                                | -+ kvm_vm_ioctl(s, KVM_IRQFD, &irqfd)  \n                                  ------------------->kernel<----------------------------\n                                     \\ -+ case KVM_IRQFD\n                                        \\ -+ kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n                                           \\ -+ kvm_irqfd_assign(kvm, args);\n                                              \\ -  irqfd->gsi = args->gsi; \"gsi 就是 virq\"\n                                              | -  INIT_WORK(&irqfd->inject, irqfd_inject); \n                                              \t\t\t\"初始化工作队列, 该eventfd对应的处理函数为 irqfd_inject\"\n                                              | -  eventfd = eventfd_ctx_fileget(f.file); \"fd 分配eventfd\"\n                                              | -  irqfd->eventfd = eventfd;\n                                              | -  events = vfs_poll(f.file, &irqfd->pt); \"在fd上poll 等待事件\"\n                                              | -|+ if (events & EPOLLIN)\n\t\t\t\t\t\t\t\t\t\t\t\t  \\ -+ schedule_work(&irqfd->inject); \"只考虑有数据，即POLLIN的情形, 调用inject 回调\"\n\t\t\t\t\t\t\t\t\t\t\t\t     \\ -+ irqfd_inject(struct work_struct *work)\n\t\t\t\t\t\t\t\t\t\t\t\t        \\ -  irqfd = container_of(work, struct kvm_kernel_irqfd, inject); \n\t\t\t\t\t\t\t\t\t\t\t\t        | -  struct kvm *kvm = irqfd->kvm; \"找到对应的虚拟机实例\"\n\t\t\t\t\t\t\t\t\t\t\t\t        | -  \"irqfd_inject函数用来注入使用中断控制器芯片的中断类型，\n\t\t\t\t\t\t\t\t\t\t\t\t              if判断中断是边沿触发还是水平触发，如果是边沿触发则会调用两次kvm_set_irq\"\n\t\t\t\t\t\t\t\t\t\t\t\t        | -+ kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, irqfd->gsi, 1, false);\n\t\t\t\t\t\t\t\t\t\t\t\t           \\ -  i = kvm_irq_map_gsi(kvm, irq_set, irq = irqfd->gsi); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t         \"获取该gsi索引上注册的中断路由项(kvm_kernel_irq_routing_entry), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 这个中断路由项是由arch的 kvm_set_routing_entry 注册的\"\n\t\t\t\t\t\t\t\t\t\t\t\t           | -+ while i--\n\t\t\t\t\t\t\t\t\t\t\t\t              \\ -  irq_set[i].set(&irq_set[i], kvm, irq_source_id, level, line_status); \n\t\t\t\t\t\t\t\t\t\t\t\t                     \"会挨个调用每个中断路由项上的set方法触发中断\" \n\t\t\t\t | -+ vfio_enable_vectors(vdev, msix:false);\n\t\t\t\t\t\t\t\"构造irq_set, 准备发送给kernel的vfio驱动\"\n\t\t\t\t    \\ -  irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER;\t\t\t\t\t\t\t\t\n\t\t\t\t    | -  irq_set->index = VFIO_PCI_MSI_IRQ_INDEX\n\t\t\t\t    | -  fds = (int32_t *)&irq_set->data;\n\t\t\t\t    | -+ for (i = 0; i < vdev->nr_vectors; i++)\n\t\t\t\t       \\ -+ fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt)  \n\t\t\t\t       | -  fds[i] = fd;   \n\t\t\t\t    | -+ ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set); \"发起 VFIO_DEVICE_SET_IRQS\"    \n\t\t\t\t        ----------->kernel vfio驱动<---------------\n\t\t\t\t       \\ -+ case VFIO_DEVICE_SET_IRQS\n\t\t\t\t          \\ -+ vfio_pci_ioctl_set_irqs(vdev, uarg);\n                                \t\"irq_set 的内容填到hdr中\"\n\t\t\t\t             \\ -+ vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index, hdr.start, hdr.count, data);\n\t\t\t\t                \\ -  switch (index)\n\t\t\t\t                | -+ case VFIO_PCI_MSI_IRQ_INDEX:\n\t\t\t\t\t\t\t\t   \\ -  switch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK)\n\t\t\t\t\t\t\t\t   | -+ case VFIO_IRQ_SET_ACTION_TRIGGER\n\t\t\t\t\t\t\t\t      \\ -+ func = vfio_pci_set_msi_trigger;\n\t\t\t\t\t\t\t\t| -+ func: vfio_pci_set_msi_trigger(vdev, index, start, count, flags, data);\n\t\t\t\t\t\t\t\t   \\ -|+ if (flags & VFIO_IRQ_SET_DATA_EVENTFD)\n                                             \t\"vdev->irq_type = VFIO_PCI_MSI_IRQ_INDEX 时\"\n\t\t\t\t\t\t\t\t       \\ -+ vfio_msi_set_block(vdev, start, count, fds, msix); \n\t\t\t\t\t\t\t\t          \\ -+ for (i = 0, j = start; i < count && !ret; i++, j++)\n\t\t\t\t\t\t\t\t             \\ -  fd = fds[i]\n\t\t\t\t\t\t\t\t             | -+ vfio_msi_set_vector_signal(vdev, j, fd, msix:false);\n\t\t\t\t\t\t\t\t                \\ -  irq = pci_irq_vector(pdev, vector);\n\t\t\t\t\t\t\t\t                | -  trigger = eventfd_ctx_fdget(fd); \"获取eventfd\"\n\t\t\t\t\t\t\t\t                | -  vdev->ctx[vector].name = kasprintf(GFP_KERNEL_ACCOUNT,  \"vfio-msi%s[%d](%s)\",  \n\t\t\t\t\t\t\t\t\t\t                msix ? \"x\" : \"\", vector, pci_name(pdev)); \"格式化输出中断名\"杯盘占比扩大一定是青光眼吗\n\t\t\t\t\t\t\t\t                | -+ request_irq(irq, vfio_msihandler, 0, vdev->ctx[vector].name, trigger); \n                                                        \"申请中断, irq 为 virq\"\n\t\t\t\t\t\t\t\t                      \"中断处理函数为 vfio_msihandler, trigger 为eventfd\"\n\\ -----+ vfio_msihandler(trigger) \"中断到来时, 来到该函数处理\"\n\t  \\ -+ eventfd_signal(trigger, 1);  \"触发eventfd\"\n\t\t \\ ----+ irqfd_inject() \"触发 kvm对端 在该eventfd 上poll的线程, 激活其 工作队列, 最终走到 irqfd_inject 函数\"\n\t\t\t   \\ -  \"省略....\"\n\t\t\t   | -+ irq_set[i].set(&irq_set[i], kvm, irq_source_id, level, line_status); \"会挨个调用每个中断路由项上的set方法触发中断\" \n\t\t\t\t  \\ -+ e->set: kvm_set_msi(struct kvm_kernel_irq_routing_entry *e, kvm, irq_source_id, level, line_status)\n\t\t\t\t\t \\ -+ kvm_riscv_aia_inject_msi(kvm, &msi); \"最终走到 imsic的 中断注入流程\"\n```\n\n在 irgfd_inject 中回调 e->set 即 kvm_set_msi 函数, 最终走入 `kvm_riscv_aia_inject_msi` 中触发对应的中断.\n`irqfd_inject` 函数通过将中断信号发送到指定的IRQ文件描述符来向虚拟机注入中断。虚拟机将接收到该中断信号，并根据中断的类型和处理程序进行相应的处理。\n\n关注下 irqfd 的触发方, 发起方是vfio 注册的中断处理函数\n在 vfio 驱动中, 为pcie的每个 vector 注册了一个中断, 中断处理函数为 vfio_msihandler\n在 guest 启用 pcie 设备启用该vector 上的中断时, 会因设置pcie的配置空间最终走到 `vfio_msi_enable` 函数中.\n\n- 首先为每个vector 注册了一个 irq_entry, 每个entry的set 函数设置为了 kvm_set_msi 函数\n- 为每个vector 注册了一个irqfd, 并开启了一个 work 工作队列, 等待eventfd poll 事件到来, 等到之后进入 irqfd_inject 函数处理\n- 为每个vector 申请了一个中断, 中断处理函数为 vfio_msihandler, 中断名\"vfio-msi[i]\"\n- 在pcie 设备因中断到来时, 先触发host kernel的该函数, 写vector绑定的eventfd\n- 写vector绑定的eventfd 会导致 irqfd 对应的work 工作队列被激活, 最终进入 irqfd_inject 函数路由相关的中断entry, 最终走到 imsic的中断注入函数中 `kvm_set_msi`->`kvm_riscv_aia_inject_msi`\n- kvm_riscv_aia_inject_msi 会解析msi消息, 判断target 是给到哪个vcpu的, 访问的是不是 setipnum 地址, 如果是setipnum, 则更新swfile->stopei, 更新swfile eip, 开启对应的guest 直通的中断, hvip 注入中断给vcpu, 将vcpu 唤醒\n\n![](attachments/pcie_msi.png)\n\n\n\n\n\n\n\n\n\n","tags":["riscv","qemu","kvm"],"categories":["RISCV","虚拟化"]},{"title":"riscv 硬件安全机制.md","url":"/2023/08/18/hxd_new/安全/riscv 硬件安全机制/","content":"\n# PMP\n\nRISC-V架构提供了一种PMP物理内存保护机制，用于隔离M模式与S/U模式下的内存访问。只有M模式才有权限配置PMP。\n\nPMP包含几组(通常是8到16个)地址寄存器以及相应的配置寄存器，这些配置寄存器可以授予或拒绝S/U模式的读、写和执行权限。\n\nPMP同时也能保护内存映射I/O (MMIO)，M模式可信固件可以通过配置PMP来约束处理器对外设I/O的访问。\n\n\n\n配置cpu csr\n物理内存保护设置寄存器（PMPCFG）\n物理内存保护地址寄存器（PMPADDR）\nPMP 共实现了 8 个地址寄存器 pmpaddr0-pmpaddr7，存放表项的物理地址\n\n缺点:\n> 仅适用于单一核心, 无法与其他核心同步, 需要添加同步控制.\n> 只能够对内存进行保护\n\n![](attachments/pmp1.png)\n\n\n![](attachments/pmp2.png)\n\n![](attachments/pmp3.png)\n\nGPU/PPU/NPU never check\n\n# IOPMP\n\n\n\n> ANDES thead 安全扩展\n>\n> 进riscv 主线进展: The IOPMP specification is still under discussion, and its ratification target date is Q4, 2023.\n\n![](attachments/iopmp1.png)\n\n\n![](attachments/iopmp2.png)\n- A source-ID represents a bus master or a group of bus masters with the same permission.\n- A bus master has one, but could be the same as another.\n- A bus master with multi-channel, multi-VM or multi-mode may need 1+ SIDs.\n\n![](attachments/iopmp3.png)\n\n IOPMP被用来规范请求。谁可以访问哪些数据？\n Source-ID, entry, ports, matching rules and violation responses.\n\n总线上的其他主设备同样需要对内存的访问进行保护，也就是外设需要增加IOPMP。IOPMP可以像PMP一样定义访问权限，他会检查从总线或者主设备过来的读、写传输是否符合权限访问规则，只有合法的读、写请求才能进一步传输到目标设备上。通常有3种方法来连接IOPMP：\n\n## 请求端连接IOPMP\n\n\n在每个主设备和总线之间增加一个IOPMP，类似RISC-V的PMP。不同的主设备需要分别新增一个IOPMP，IOPMP之间互相独立。这种设计较为简单，也提供了灵活性，但IOPMP不能在主设备之间共享。如下图所示:\n\n![](attachments/source_pmp.png)\n\n \n## 目标端连接IOPMP\n\n目标端的IOPMP需要对不同主设备发来的传输进行区分，这就需要每个主设备的访问请求都要附带额外的Master ID。如下图所示:\n\n![](attachments/target_iopmp.png)\n\n\n## 请求端和目标端级联IOPMP\n\n在复杂的SoC系统中，往往存在IOPMP级联的使用情况。典型的场景就是RISC-Cores自身带有PMP，处理器并不需要目标端的IOPMP再次对他的访问进行过滤。通用的处理方法是，在IOPMP的表项里取消对CPU访问的约束，但缺点是这会占用IOPMP表项，也会影响效率。为了提高IOPMP级联下的访问效率，IOPMP需要提供一种机制来直通部分主设备的访问，比如提供可配置的以直通模式访问的主设备列表。\n\nANDES/THEAD\n\n# sifive shield\n\nSiFive WorldGuard是一个用于隔离代码执行和数据保护的细粒度安全模型。SiFive Worldguard提供SoC级别的信息控制，具有先进的隔离控制，基于每个世界的多个权限级别。SiFive WorldGuard为多域安全提供了核心驱动和进程ID驱动的模式，为核心、缓存、互连、外围和内存提供数据保护。\n\n![](attachments/WG1.png)\n在多核处理器中，如上图所示，世界ID标记被用来将进程相互隔离，以确保保护和隔离的执行。在SoC内部，WID标记从核心延伸到缓存、互连、外设、总线master、DMA区域和存储器。应用程序或操作系统环境可以在一个高性能的多核系统中被隔离和保护。对于单核更常见的嵌入式系统，PID驱动的世界ID在用户和机器模式之间保护和隔离执行。\n\n\n\n这个解决方案并没有取代RISC‑V核心的PMP机制（适用于单核的存储器），也没有取代存储器管理单元（MMU），而是将它们扩展到有其他发起者的多核系统，并提供更强的安全性\n\n对于更复杂的多核平台，PMP和特权模式方法有一个主要的限制。由于特权模式和PMP作用域仅限于其核心和软件，它们只能控制单个核心的内存映射区域。特权管理寄存器属于那个单一的内核，所以它们的值和产生的控制既不与其他内核共享，也不和其他核心协同，因此需要复杂的同步工作。在这种情况下，使用受信任的核心可能是首选。\n\nPMP方法的另一个限制适用于\"fractured\" 物理地址内存map。在这种情况下，所需的PMP条目数可能会变得太大，无法接受。SiFive WorldGuard解决方案是一个很好的选择。\n\n\n![](attachments/WG2.png)\n发起方（绿色）都配备了一个wgMarker，标记他们的出站请求\n\n受信核心，通过发送标有受信任的WID的请求来配置wgMarkers（蓝色）和wgCheckers（粉红色）。\n\nAny marked transaction goes through the wg-aware bus and blocks (e.g., L2 cache) until the targeted wgChecker is reached\n\nThe wgChecker (regardless of complexity) determines if the WID and related meta-data (access type) are consistent with the rules it contains; if it matches, the transaction is authorized\n\n请求从其WID信息中释放出来，被发送到资源（中断控制器、调试模块）或出站端口（内存端口、外围端口、系统端口）。\n\n\n\n# VirtualZone\n\n玄铁C系列处理器的安全拓展\n\n\n\n该扩展主要基于RISC-V架构提供的PMP保护机制和多层特权模型，虚拟出多个相互隔离的可执行域(Zone)，从而实现了RISC-V架构上的可信执行环境（TEE），并保护Zone内的软硬件信息，包括软件、内存、外设、I/O等免受其他Zone的非法访问。处理器资源包括Cache、中断、内存、代码执行等经过隔离之后，处理器将分时地运行在不同的Zone内，配合SoC其他的保护机制如IOPMP，共同构建一个基于软硬件协同工作的安全系统。\n\n\n\n虽然RISC-V架构的处理器具备物理内存保护、多层权限模型、内存管理单元等技术来支持可信执行环境功能的实现，但处理器仍然需要支持其他安全规范才能创建完全可用的安全执行环境。为了满足TEE(Trusted Execution Environment)的隔离要求，玄铁C系列处理器在RISC-V架构基础上进行了安全扩展。 该系列处理器在软件的协调下可以虚拟出多个执行域(Zone)，每个Zone增加了域标识，也就是Zone ID，整体架构如Figure 2所示。每个Zone可以独立地运行各自的操作系统以及基于该操作系统的应用程序。操作系统运行在超级用户特权模式，应用程序运行在普通用户特权模式。处理器根据需要在不同的Zone里切换运行。当处理器切换到某一Zone运行时，他将实时占用整个物理核，并且处理器的域标识也将同时被更新成相应执行域的标识。Zone的切换由运行在最高模式(机器模式)下的可信固件(TF)来完成。\n\n![](attachments/thead_tee1.png)\n\nZone之间访问隔离通过PMP(Physical Memory Protection)实时切换来实现，PMP是RISC-V特权ISA的一部分，用于隔离机器模式和超级用户模式/普通用户模式之间的物理地址访问，玄铁处理器的L1/L2 Cache同时也受PMP保护。\n\n\n\n当硬件线程从一个Zone切换到另一个Zone时，PMP配置同时也需要切换。M模式可信固件需要先保存当前Zone的PMP配置，然后载入下一个即将切换的Zone的PMP配置，完成对内存和内存映射I/O (MMIO)访问权限的切换。\n\n\n\n当多个Zone需要共享内存时，可以将需要共同访问的内存区域的访问权限同时授予给多个Zone，也就是将该块内存的允许访问权限写到每个Zone的PMP配置表里，PMP表会在Zone切换时由可信固件进行更新。Figure 3是一个典型的多个Zone的PMP配置图， SHM区域是Zone间允许共同访问的共享内存区域。\n\n\n\n机器模式可以通过PMP的锁定功能将机器模式的访问限制在有限的区域内，比如只允许机器模式访问、执行划分给可信固件的内存区域，以减少受到对机器模式攻击的影响，也就是Supervisor Memory Access Prevention（SMAP）和Supervisor Memory Execution Prevention（SMEP），从而增加对关键信息的保护。\n\n\n\n![](attachments/pmp_config.png)\n\n\n\n下图是玄铁处理器采用PMP、IOPMP来构建安全SoC的系统参考框图:\n\n\n![](attachments/thead_tee2.png)\n\n当不同Zone之间需要切换时，运行在机器模式的可信固件需要对Zone的上下文进行保存和切换。虽然看起来这会带来开销，但像ARM TrustZone的虚拟化技术同样需要对世界进行切换，这部分切换的工作同样被隐藏在Monitor的可信固件中。不同的是，ARM TrustZone只虚拟出了2个世界，而玄铁RISC-V处理器在安全扩展之后，最多允许同时支持16个Zone，这为以后的软件安全方案提供了更多的可能。\n\n\n\n# Mips 软件tee方案\n\n在mips 指令集架构上比较著名的tee方案为SierraTEE\n\nSierraTEE 采用mips的硬件虚拟化辅助来实现teeos 和 richos 之间的运行环境隔离\n\n下图为 SierraTEE 的基础框架:\n\n\n\n![](attachments/sierra_TEE_mips.png)\n\n\n\n绿色部分为 SierraTEE 的组件.\n\n- host os中 user mode下的GPI 库, 即通用的api, app 可以通过该库的api 发送安全请求, 该请求首先会发到 host os的kernel的负责接管安全需求的driver.\n- host os中 os mode下的 kernel 中添加的 Secure Driver, 该Driver 负责向 hypervisor 发送安全请求\n- hypervisor 虚拟化mode下的 hypervisor TEE HAL, 用来接收 rich os 和 teeos的请求\n- secure os, 该os 和 rich os 处于同一mode, 可以把该os理解为guest os. hypervisor monitor 监视层收到 host os的安全请求后, 会进行os切换, 切换到对应的 teeos 处理对应的请求.\n- secure os的GPI库, 即符合某个规范的通用api, 该api 是给secure os下的app 用的, secure os下的app 也叫ta, 每个ta负责单一的业务.\n- secure os下的app, 也叫ta, 负责单一业务, 每个ta 都有一个uuid, host os下的app 要处理某一安全业务时, 需要指定对应的 ta的uuid, 来处理特定的业务.\n\n\n\n可以看到 SierraTEE 是利用了mips的硬件虚拟化辅助来实现运行环境隔离的.\n\n通过vcpu的调度由 host os 切换到 guest os. host os为richos, guest os 为 teeos, 两者之间的通信由高一权限级别的hypervisor mode接管.\n\n\n\n# riscv tee 方案\n\nriscv 开源的tee方案有伯克利的keystone 和 上交大实验室的 蓬莱 方案.\n\n两者的架构差不多\n\n下图是大概的架构\n\n\n\n![](attachments/riscv_tee.png)\n\n\n\n其中绿色部分为 keystone/蓬莱 方案增加的组件.\n\n- rich os 中 secure clint api 库, 供richos 下的u-mode下的app使用, 用来发送安全请求\n- rich os的kernel 中添加 secure driver, 负责承接 u-mode下的app请求, 并负责解析加载 tee enclave app elf, 发送安全请求给opensbi\n- M-mode的opensbi中新增的 secure hal 负责richos 和 tee运行环境的切换, 还有PMP 的配置, tee 运行环境的内存和rich os的运行内存是隔离的, 由cpu的core的配置的pmp策略进行保护\n- tee 运行环境包含了 S-mode 的rt 运行时和 U-mode的enclave app 两部分构成, 最终由enclave app负责具体的安全边界计算. 而rt 运行时则负责 trap 中断等.\n\n值得注意的是这两个方案目前都比较基础, secure 世界运行的实体还没进化到完全os的阶段, 是由运行时(Supervisor mode) + enclave app (user mode) 组成, 只能处理比较简单的请求, 也没有定义通用的符合tee规范的 GPI. 所以使用场景是受限的. enclave app所能使用的基础的软件接口非常少. 只能写比较简单的类似baremental的应用, 使用受限.\n\n\n\n而大型的teeos 如op-tee 还没有对riscv 适配完成.\n\n","tags":["riscv","keystone"],"categories":["TEE","RISCV","安全"]},{"title":"riscv iommu 玄铁升级 移植","url":"/2023/08/02/hxd_new/riscv调研/虚拟化/iommu/xt iommu 移植问题/","content":"\n首先 probe 失败的问题\n\n需要先添加 iommu capable 函数, 表明 `IOMMU_CAP_CACHE_COHERENCY` 能力为 true, 否则 probe 时会失败.\n\n```c\nstatic struct iommu_ops xt_iommu_ops = {\n\t.capable\t= xt_iommu_capable,\n}\nstatic bool xt_iommu_capable(struct device *dev, enum iommu_cap cap)\n{\n\tswitch (cap) {\n\tcase IOMMU_CAP_CACHE_COHERENCY:\n\t\treturn true;\n\tcase IOMMU_CAP_NOEXEC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n```\n\n打开 option allow_unsafe_interrupts=1\n编译为动态模块时, insmod 会读取 `/etc/modprobe.d/iommu_unsafe_interrupts.conf` 文件, 将 allow_unsafe_interrupts 设置为 1.\n```c\noptions vfio_iommu_type1 allow_unsafe_interrupts=1\n```\n如果不是动态模块, 包含在 kernel Image 中, 则需要强制打开\n```c\nstatic bool allow_unsafe_interrupts = 1;\n```\n\n其次 xt_iommu 在 base 版本上使用的一些接口在升级版本上发生了变化:\n如 `iommu_device_set_ops`  `iommu_device_set_fwnode` `bus_set_iommu` 不见了, 取而代之的是总结成了一个接口 `iommu_device_register`, 该接口支持的参数也有变化.\n其次某些函数的参数个数意义变化:\n`xt_iommu_map` `xt_iommu_unmap` , size 变成了 pgsize 和 pgcount.\n\n需要相应的适配修改.\n\nkernel 的相关 config 需要打开:\n```\nCONFIG_IOMMU_IOVA=y\nCONFIG_IOMMU_API=y\nCONFIG_IOMMU_SUPPORT=y\nCONFIG_IOMMU_DMA=y\nunset CONFIG_IOMMUFD\nCONFIG_VFIO=y\nCONFIG_VFIO_CONTAINER=y\nCONFIG_VFIO_IOMMU_TYPE1=y\nCONFIG_VFIO_VIRQFD=y\nCONFIG_VFIO_PCI_CORE=y\nCONFIG_VFIO_PCI_MMAP=y\nCONFIG_VFIO_PCI_INTX=y\nCONFIG_VFIO_PCI=y\nCONFIG_PCI=y\nCONFIG_PCI_DOMAINS=y\nCONFIG_PCI_DOMAINS_GENERIC=y\n# kvm-mode 下支持vfio\nCONFIG_KVM_VFIO=y\n```\n\n移植 iommu 后, 直通给 guest 的网卡 e1000e 报错, log 如下:\n经过分析后, 得出结论, 网卡通过 dma 发包出现异常, 最后由 ndo_tx_timeout 回调了 e1000e 的 `e1000_tx_timeout` 函数将网卡重启.\n\n由监控的 watchdog\n```c\n\t\t\t\tWARN_ONCE(1, \"NETDEV WATCHDOG: %s (%s): transmit queue %u timed out %u ms\\n\",\n\t\t\t\t\t  dev->name, netdev_drivername(dev), i, timedout_ms);\n\t\t\t\tdev->netdev_ops->ndo_tx_timeout(dev, i);\n```\n打印出了下面的堆栈:\n\n```c\n[   42.096669] NETDEV WATCHDOG: eth0 (e1000e): transmit queue 0 timed out 9960 ms\n[   42.248201] WARNING: CPU: 3 PID: 0 at net/sched/sch_generic.c:525 dev_watchdog+0x224/0x228\n[   42.250411] Modules linked in:\n[   42.250692] CPU: 3 PID: 0 Comm: swapper/3 Not tainted 6.4.0-rc1-00026-g80e62bc8487b-dirty #91\n[   42.250818] Hardware name: riscv-virtio,qemu (DT)\n[   42.250926] epc : dev_watchdog+0x224/0x228\n[   42.251014]  ra : dev_watchdog+0x224/0x228\n[   42.251042] epc : ffffffff806e48dc ra : ffffffff806e48dc sp : ff20000000693b90\n[   42.251058]  gp : ffffffff814a2b00 tp : ff600000018cd240 t0 : ffffffff8082fba0\n[   42.251074]  t1 : 0720072007200720 t2 : 4157205645445445 s0 : ff20000000693c00\n[   42.251089]  s1 : ff600000024bc498 a0 : 0000000000000042 a1 : ffffffff8147e108\n[   42.251103]  a2 : 00000000ffffefff a3 : fffffffffffffffe a4 : b6182cbfc7d9c400\n[   42.251117]  a5 : b6182cbfc7d9c400 a6 : 0000000000000050 a7 : ffffffff8048d172\n[   42.251131]  s2 : ff600000024bc000 s3 : ff600000018e3a00 s4 : ff600000024bc3e0\n[   42.251145]  s5 : 0000000000000000 s6 : ffffffff8140a980 s7 : 00000000000026e8\n[   42.251159]  s8 : ffffffff80c15470 s9 : ffffffff81408088 s10: 0000000000000101\n[   42.251173]  s11: 0000000000000282 t3 : ff60000001818f00 t4 : ff60000001818f00\n[   42.251186]  t5 : ff60000001818000 t6 : ff20000000693978\n[   42.251199] status: 0000000200000120 badaddr: 0000000000000000 cause: 0000000000000003\n[   42.251303] [<ffffffff806e48dc>] dev_watchdog+0x224/0x228\n[   42.251402] [<ffffffff800940e4>] call_timer_fn.constprop.0+0x14/0x5e\n[   42.252827] [<ffffffff800941b8>] expire_timers+0x8a/0xbc\n[   42.252840] [<ffffffff80094782>] run_timer_softirq+0xe0/0x202\n[   42.252850] [<ffffffff80844460>] __do_softirq+0x100/0x27e\n[   42.256472] [<ffffffff80024a9c>] __irq_exit_rcu+0xa8/0xde\n[   42.258214] [<ffffffff80024bb6>] irq_exit_rcu+0xc/0x14\n[   42.258389] [<ffffffff8083c238>] do_irq+0x6c/0x86\n[   42.258543] [<ffffffff800035ac>] ret_from_exception+0x0/0x64\n[   42.258646] [<ffffffff8083cb2a>] default_idle_call+0x26/0x34\n[   42.259488] [<ffffffff8005a7ee>] do_idle+0x206/0x226\n[   42.259983] [<ffffffff8005a970>] cpu_startup_entry+0x1a/0x1c\n[   42.259997] [<ffffffff8000618a>] handle_IPI+0x0/0xfc\n[   45.988551] e1000e 0000:00:01.0 eth0: Reset adapter unexpectedly\n[   46.743848] e1000e 0000:00:01.0 eth0: NIC Link is Up 1000 Mbps Full Duplex, Flow Control: Rx/Tx\n```\n\n\n首先状态上来说, 中断是正常的, 但是 dma remapping 不正常.\n在 riscv 基础版本上 (未开启 AIA), 只支持 intx 线中断模式\n`e1000_intr` 中断处理函数可以正常触发.\n\n再由不同版本对比后, 发现 qemu (host) / qemu (guest) 以及 kernel (guest) 为不变量, 变量仅有 kernel (host) 从 5.10 版本升级到了 6.4 版本.\n在 kernel 变更版本后, 相对应的 vfio 框架发生了一些变化, 在确认 5.10 -> 6.4 iommu / vfio 相关的 config 都相同时, 无明显的其他异常 log.\n无明显的排查点, 再往下追只能根据代码行为去正向跟踪.\n\n\n\n\n# qemu xmmuv1 模拟行为\n\n正常的 log, 未开启虚拟化时, host 中对 e1000e 网卡的处理就经由了 dma, 而在将 kernel 版本升级到 6.4 后, 却没触发对应的 xmmuv1_translate.\n说明 base 版本上开了 e1000e 网卡的 iommu 支持, 而升级版本后关闭了网卡的 iommu 支持.\n未开启虚拟化时, 还没有涉及到 vfio 的特性, 所以应重点排查 iommu 相关的 feature.\n\n```erlang\n#0  0x000055555591fa12 in xmmuv1_translate (mr=<optimized out>, addr=4294963200, flag=<optimized out>, iommu_idx=<optimized out>) at ../hw/riscv/xmmuv1.c:186\n#1  0x00005555559fe0b6 in address_space_translate_iommu (iommu_mr=0x555557025af0, xlat=xlat@entry=0x7fffe9c61d40, plen_out=plen_out@entry=0x7fffe9c61d38, page_mask_out=page_mask_out@entry=0x0, is_write=is_write@entry=false, is_mmio=true, target_as=0x7fffe9c61cc8, attrs=...) at ../softmmu/physmem.c:435\n#2  0x00005555559fe340 in flatview_do_translate (fv=fv@entry=0x7ffee830ab40, addr=addr@entry=4294963200, xlat=xlat@entry=0x7fffe9c61d40, plen_out=plen_out@entry=0x7fffe9c61d38, page_mask_out=page_mask_out@entry=0x0, is_write=false, is_mmio=true, target_as=0x7fffe9c61cc8, attrs=...) at ../softmmu/physmem.c:508\n#3  0x00005555559feed1 in flatview_translate (fv=fv@entry=0x7ffee830ab40, addr=addr@entry=4294963200, xlat=xlat@entry=0x7fffe9c61d40, plen=plen@entry=0x7fffe9c61d38, is_write=is_write@entry=false, attrs=...) at ../softmmu/physmem.c:568\n#4  0x0000555555a02b91 in flatview_read (fv=0x7ffee830ab40, addr=addr@entry=4294963200, attrs=attrs@entry=..., buf=buf@entry=0x7fffe9c61e10, len=len@entry=16) at ../softmmu/physmem.c:2753\n#5  0x0000555555a02cf8 in address_space_read_full (as=0x7fffe8416250, addr=addr@entry=4294963200, attrs=..., buf=buf@entry=0x7fffe9c61e10, len=len@entry=16) at ../softmmu/physmem.c:2770\n#6  0x0000555555a02e31 in address_space_rw (as=<optimized out>, addr=addr@entry=4294963200, attrs=..., attrs@entry=..., buf=buf@entry=0x7fffe9c61e10, len=len@entry=16, is_write=is_write@entry=false) at ../softmmu/physmem.c:2798\n#7  0x00005555557bd7e9 in dma_memory_rw_relaxed (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7fffe9c61e10, addr=4294963200, as=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/sysemu/dma.h:87\n#8  0x00005555557bd7e9 in dma_memory_rw (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7fffe9c61e10, addr=4294963200, as=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/sysemu/dma.h:130\n#9  0x00005555557bd7e9 in pci_dma_rw (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7fffe9c61e10, addr=<optimized out>, dev=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/hw/pci/pci_device.h:233\n#10 0x00005555557bd7e9 in pci_dma_read (len=16, buf=0x7fffe9c61e10, addr=<optimized out>, dev=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/hw/pci/pci_device.h:252\n#11 0x00005555557bd7e9 in e1000e_start_xmit (core=0x7fffe8418eb0, txr=txr@entry=0x7fffe9c61e80) at ../hw/net/e1000e_core.c:944\n#12 0x00005555557bdda6 in e1000e_set_tdt (core=<optimized out>, index=<optimized out>, val=<optimized out>) at ../hw/net/e1000e_core.c:2456\n#13 0x00005555557c1130 in e1000e_core_write (core=0x7fffe8418eb0, addr=<optimized out>, val=1, size=4) at ../hw/net/e1000e_core.c:3280\n#14 0x00005555557b7b66 in e1000e_mmio_write (opaque=<optimized out>, addr=<optimized out>, val=<optimized out>, size=<optimized out>) at ../hw/net/e1000e.c:112\n#15 0x00005555559f9060 in memory_region_write_accessor (mr=0x7fffe8418a60, addr=14360, value=<optimized out>, size=4, shift=<optimized out>, mask=<optimized out>, attrs=...) at ../softmmu/memory.c:493\n#16 0x00005555559f8a8b in access_with_adjusted_size (addr=addr@entry=14360, value=value@entry=0x7fffe9c62038, size=size@entry=4, access_size_min=<optimized out>, access_size_max=<optimized out>, access_fn=access_fn@entry=0x5555559f8ffe <memory_region_write_accessor>, mr=0x7fffe8418a60, attrs=...) at ../softmmu/memory.c:569\n#17 0x00005555559f8d58 in memory_region_dispatch_write (mr=mr@entry=0x7fffe8418a60, addr=addr@entry=14360, data=<optimized out>, data@entry=1, op=op@entry=MO_32, attrs=...) at ../softmmu/memory.c:1533\n#18 0x0000555555a3d245 in io_writex (env=env@entry=0x55555669e430, full=0x7ffef0d6cf38, mmu_idx=1, val=val@entry=1, addr=18446743867826518040, retaddr=retaddr@entry=140736773646269, op=MO_32) at ../accel/tcg/cputlb.c:1435\n#19 0x0000555555a40cf1 in do_st_4 (ra=140736773646269, memop=<optimized out>, mmu_idx=<optimized out>, val=1, p=0x7fffe9c62140, env=0x55555669e430) at ../accel/tcg/cputlb.c:2772\n#20 0x0000555555a40cf1 in do_st4_mmu (env=0x55555669e430, addr=<optimized out>, val=1, oi=<optimized out>, ra=140736773646269) at ../accel/tcg/cputlb.c:2850\n#21 0x0000555555a42727 in helper_stl_mmu (env=<optimized out>, addr=<optimized out>, val=<optimized out>, oi=<optimized out>, retaddr=<optimized out>) at ../accel/tcg/cputlb.c:2866\n```\n\n\n1. 怀疑点 CONFIG_IOMMU_DMA, 这个开关在 base 和升级版本上都开了.\n\n升级版本的开机日志:\ndmesg | grep -E \"DMAR|IOMMU\"\n```c\n[    1.156855] Failed to set up IOMMU for device Fixed MDIO bus.0; retaining platform DMA ops\n[    1.102567] Failed to set up IOMMU for device riscv-pmu; retaining platform DMA ops\n```\n\nbase 版本中的开机日志中并没有上述异常.\n\n先看下这处异常:\n\n```c\nstruct iommu_domain *iommu_get_domain_for_dev(struct device *dev)\n{\n\tstruct iommu_domain *domain;\n\tstruct iommu_group *group;\n\tgroup = iommu_group_get(dev);\n\t// error: 此处domain 为 null, 未找到 dev->group->domain\n\tdomain = group->domain;\n\treturn domain;\n}\n```\n该 domain 应该来自于 iommu driver 设置的 default_domain\n跟踪堆栈, 发现 xt_iommu driver 分配 default_domain 时失败了.\n```erlang\n#0  xt_iommu_domain_alloc (type=<optimized out>) at ../drivers/iommu/xuantie-iommu.c:365\n#1  0xffffffff804f7444 in __iommu_domain_alloc (bus=0xffffffff8150c0a0 <platform_bus_type>, type=<optimized out>) at ../drivers/iommu/iommu.c:1987\n#2  0xffffffff804f754c in iommu_group_alloc_default_domain (bus=bus@entry=0xffffffff8150c0a0 <platform_bus_type>, group=group@entry=0xff60000080015e00, type=<optimized out>) at ../drivers/iommu/iommu.c:1667\n#3  0xffffffff804f7d46 in probe_alloc_default_domain (group=0xff60000080015e00, bus=0xffffffff8150c0a0 <platform_bus_type>) at ../drivers/iommu/iommu.c:1819\n#4  bus_iommu_probe (bus=bus@entry=0xffffffff8150c0a0 <platform_bus_type>) at ../drivers/iommu/iommu.c:1882\n#5  0xffffffff804f7e24 in iommu_device_register (iommu=0xff600000801f3d20, ops=ops@entry=0xffffffff8150b120 <xt_iommu_ops>, hwdev=hwdev@entry=0xff600000802c1010) at ../drivers/iommu/iommu.c:245\n#6  0xffffffff80837748 in xt_iommu_device_probe (pdev=0xff600000802c1000) at ../drivers/iommu/xuantie-iommu.c:718\n```\n\n在 `__iommu_domain_alloc` 函数中, 这个地方退出了, 而 base 版本没有这个逻辑.\n```c\n\tif (iommu_is_dma_domain(domain) && iommu_get_dma_cookie(domain)) {\n\t\tiommu_domain_free(domain);\n\t\tdomain = NULL;\n\t}\n```\n\n将这段注释掉后, 继而需要将 pci_bus_type 注册 iommu_ops, 但其他的 bus 类型 (platform_bus_type) 不能注册, 会导致异常, base 版本上的 xtiommu 只支持 pci_bus.\n但升级版本已经没有 bus_set_iommu 相关的函数了, 只能改代码进行定制.\n\n在改完后, 网卡在进行 dma 操作时, 已经使用 xtiommu, 但仍出现了异常.\n还是表现在地址翻译时, 触发的地址 iova 不正常.\n\n正常的 log:\nxmmuv1_translate addr 4294963200\nxmmuv1_translate addr 4294963201\nxmmuv1_translate addr 4294963202\nxmmuv1_translate addr 4294963203\n...\n\n而异常的 log:\nxmmuv1_translate addr 4294963200\nxmmuv1_translate addr 4294963204\nxmmuv1_translate addr 4294963208\nxmmuv1_translate addr 4294963212\n退出\n\n堆栈:\n```erlang\n#0  0x000055555591f75b in xmmuv1_translate (mr=0x555557025af0, addr=4294963201, flag=IOMMU_RO, iommu_idx=0) at ../hw/riscv/xmmuv1.c:104\n#1  0x00005555559fe09a in address_space_translate_iommu (iommu_mr=0x555557025af0, xlat=xlat@entry=0x7ffef59fdcc8, plen_out=plen_out@entry=0x7ffef59fdd20, page_mask_out=page_mask_out@entry=0x0, is_write=is_write@entry=false, is_mmio=true, target_as=0x7ffef59fdc38, attrs=...) at ../softmmu/physmem.c:435\n#2  0x00005555559fe324 in flatview_do_translate (fv=fv@entry=0x7ffef0252180, addr=addr@entry=4294963201, xlat=xlat@entry=0x7ffef59fdcc8, plen_out=plen_out@entry=0x7ffef59fdd20, page_mask_out=page_mask_out@entry=0x0, is_write=false, is_mmio=true, target_as=0x7ffef59fdc38, attrs=...) at ../softmmu/physmem.c:508\n#3  0x00005555559feeb5 in flatview_translate (fv=fv@entry=0x7ffef0252180, addr=addr@entry=4294963201, xlat=xlat@entry=0x7ffef59fdcc8, plen=plen@entry=0x7ffef59fdd20, is_write=is_write@entry=false, attrs=..., attrs@entry=...) at ../softmmu/physmem.c:568\n#4  0x0000555555a02aa9 in flatview_read_continue (fv=fv@entry=0x7ffef0252180, addr=4294963201, addr@entry=4294963200, attrs=..., ptr=ptr@entry=0x7ffef59fde10, len=15, len@entry=16, addr1=<optimized out>, l=<optimized out>, mr=0x55555656aee0) at ../softmmu/physmem.c:2738\n#5  0x0000555555a02baf in flatview_read (fv=0x7ffef0252180, addr=addr@entry=4294963200, attrs=attrs@entry=..., buf=buf@entry=0x7ffef59fde10, len=len@entry=16) at ../softmmu/physmem.c:2757\n#6  0x0000555555a02cdc in address_space_read_full (as=0x7fffe8416250, addr=addr@entry=4294963200, attrs=..., buf=buf@entry=0x7ffef59fde10, len=len@entry=16) at ../softmmu/physmem.c:2770\n#7  0x0000555555a02e15 in address_space_rw (as=<optimized out>, addr=addr@entry=4294963200, attrs=..., attrs@entry=..., buf=buf@entry=0x7ffef59fde10, len=len@entry=16, is_write=is_write@entry=false) at ../softmmu/physmem.c:2798\n#8  0x00005555557bd7e9 in dma_memory_rw_relaxed (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7ffef59fde10, addr=4294963200, as=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/sysemu/dma.h:87\n#9  0x00005555557bd7e9 in dma_memory_rw (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7ffef59fde10, addr=4294963200, as=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/sysemu/dma.h:130\n#10 0x00005555557bd7e9 in pci_dma_rw (attrs=..., dir=DMA_DIRECTION_TO_DEVICE, len=16, buf=0x7ffef59fde10, addr=<optimized out>, dev=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/hw/pci/pci_device.h:233\n#11 0x00005555557bd7e9 in pci_dma_read (len=16, buf=0x7ffef59fde10, addr=<optimized out>, dev=<optimized out>) at /home/liguang/program/riscv-lab/qemu/include/hw/pci/pci_device.h:252\n#12 0x00005555557bd7e9 in e1000e_start_xmit (core=0x7fffe8418eb0, txr=txr@entry=0x7ffef59fde80) at ../hw/net/e1000e_core.c:944\n#13 0x00005555557bdda6 in e1000e_set_tdt (core=<optimized out>, index=<optimized out>, val=<optimized out>) at ../hw/net/e1000e_core.c:2456\n#14 0x00005555557c1130 in e1000e_core_write (core=0x7fffe8418eb0, addr=<optimized out>, val=1, size=4) at ../hw/net/e1000e_core.c:3280\n#15 0x00005555557b7b66 in e1000e_mmio_write (opaque=<optimized out>, addr=<optimized out>, val=<optimized out>, size=<optimized out>) at ../hw/net/e1000e.c:112\n```\n\n在 flatview_read_continue 处追踪, 发现步长来自于翻译结果, 进一步跟踪发现\nxt iommu 在第一级地址转换处出问题了 `riscv_one_stage`, 地址翻译出错了.\n\nqemu 中的 xt iommu 是未改动的, 且在 base 版本和升级版本都是同一份, 所以问题应该出现在 map 的地方.\n\n跟踪 kernel 中 xt_iommu_map 的过程\n```erlang\n#0  xt_iommu_map (domain=0xff6000008023a6b0, iova=4294963200, paddr=4397146112, pgsize=4096, pgcount=1, iommu_prot=7, gfp=3520, mapped=0xff20000000d13218) at ../drivers/iommu/xuantie-iommu.c:70\n#1  0xffffffff804f56bc in __iommu_map_pages (mapped=0xff20000000d13218, gfp=3520, prot=7, size=4096, paddr=<optimized out>, iova=4294963200, domain=0xff6000008023a6b0) at ../drivers/iommu/iommu.c:2359\n#2  __iommu_map (domain=domain@entry=0xff6000008023a6b0, iova=iova@entry=4294963200, paddr=<optimized out>, paddr@entry=4397146112, size=size@entry=4096, prot=prot@entry=7, gfp=gfp@entry=3520) at ../drivers/iommu/iommu.c:2405\n#3  0xffffffff804f58f4 in iommu_map_sg (domain=domain@entry=0xff6000008023a6b0, iova=iova@entry=4294963200, sg=sg@entry=0xff600000822a9ac0, nents=<optimized out>, prot=prot@entry=7, gfp=gfp@entry=3520) at ../drivers/iommu/iommu.c:2560\n#4  0xffffffff804f9644 in __iommu_dma_alloc_noncontiguous (dev=dev@entry=0xff600000802890c8, size=size@entry=4096, sgt=sgt@entry=0xff20000000d133f8, gfp=3520, attrs=attrs@entry=0, prot=...) at ../drivers/iommu/dma-iommu.c:846\n#5  0xffffffff804fa042 in iommu_dma_alloc_remap (attrs=0, prot=..., gfp=<optimized out>, dma_handle=0xff600000808ce990, size=4096, dev=0xff600000802890c8) at ../drivers/iommu/dma-iommu.c:872\n#6  iommu_dma_alloc (dev=0xff600000802890c8, size=4096, handle=0xff600000808ce990, gfp=<optimized out>, attrs=0) at ../drivers/iommu/dma-iommu.c:1462\n#7  0xffffffff80088072 in dma_alloc_attrs (dev=0xff600000802890c8, size=4096, dma_handle=dma_handle@entry=0xff600000808ce990, flag=flag@entry=3264, attrs=attrs@entry=0) at ../kernel/dma/mapping.c:522\n#8  0xffffffff805aea92 in dma_alloc_coherent (gfp=3264, dma_handle=0xff600000808ce990, size=<optimized out>, dev=<optimized out>) at ../include/linux/dma-mapping.h:423\n#9  e1000_alloc_ring_dma (adapter=0xff600000811a4980, adapter=0xff600000811a4980, ring=0xff600000808ce980) at ../drivers/net/ethernet/intel/e1000e/netdev.c:2317\n#10 e1000e_setup_tx_resources (tx_ring=0xff600000808ce980) at ../drivers/net/ethernet/intel/e1000e/netdev.c:2345\n#11 0xffffffff805b044a in e1000e_open (netdev=0xff600000811a4000) at ../drivers/net/ethernet/intel/e1000e/netdev.c:4630\n```\n\n追踪 map 的过程, 发现 xt iommu 驱动代码中做 mmu 映射时, 启用的 sv39 mode, 第一级的 pgd_shift 错误了使用了系统中定义的\n`PGDIR_SHIFT`\n\n这个值是跟着系统的页表模式走的, 当前系统使用了 sv57 mode 5 级页表, 所以这个值是 48, 而 sv39 mode 这个值应该是 30.\n```c\n\tfor (i = 0; i < loop; ++i) {\n\t\tvpn2_idx = (iova >> PGDIR_SHIFT) & PAGE_TABLE_LEVEL_MASK;\n\t\tvpn1_idx = (iova >> PMD_SHIFT) & PAGE_TABLE_LEVEL_MASK;\n\t\tvpn0_idx = (iova >> PAGE_SHIFT) & PAGE_TABLE_LEVEL_MASK;\n```\n\n将 PGDIR_SHIFT 修改为 PGDIR39_SHIFT (30) 后\n再进行测试, 发现 host 中启用 xt iommu 进行 dma 的寻址终于正常了.\n\nhost 中正常后, 再进行 guest 直通网卡测试\n发现 guest kvm-mode 下直通的 e1000e 网卡也正常工作了\n\n\n","tags":["riscv"],"categories":["玄铁","RISCV","移植"]},{"title":"nuclei opensbi optee 方案","url":"/2023/07/18/hxd_new/安全/nuclei opensbi optee 方案/","content":"\n# sm_init 调用栈\n\n```c\n#0  sm_init (cold_boot=cold_boot@entry=1) at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/lib/sbi/optee/sm.c:120\n#1  0x00000000a00026aa in nuclei_final_init (cold_boot=<optimized out>)\n    at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/platform/nuclei/evalsoc/platform.c:66\n#2  0x00000000a0000c18 in sbi_platform_final_init (cold_boot=1, plat=0xa00138a8 <platform>)\n    at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/include/sbi/sbi_platform.h:401\n#3  init_coldboot (hartid=0, scratch=0xa002d000) at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/lib/sbi/sbi_init.c:295\n#4  sbi_init (scratch=0xa002d000) at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/lib/sbi/sbi_init.c:425\n#5  0x00000000a00004b6 in _start_warm () at /home/liguang/program/riscv-lab/nuclei-linux-sdk/opensbi/firmware/fw_base.S:443\n```\n\n重点关注 sm_init 函数\n\n```erlang\n-+ void sm_init(bool cold_boot)\n \\ -|+ if cold_boot\n     \\ -+ sbi_ecall_register_extension(&ecall_optee);\n        \\ -  .extid_start = SBI_EXT_OPTEE  \"0x4F505445\"\n        | -  .handle = sbi_ecall_optee_handler,  \"注册 optee ext handler\"\n     | -  sm_region_id = smm_init(); \"添加 opensbi text 段 pmp entry， 并保存 id为 sm_region_id\"\n     | -  os_region_id = osm_init(); \"添加 0xfffffffff bottom entry\"\n     | -  tee_region_id = teem_init(); \"添加 FW_OPTEE_TZDRAM_BASE  optee_os 的text 内存 pmp entry\"\n     | -  shm_region_id = shm_init(); \"添加 share memory （secure与non sec 的共享内存的） pmp entry\"\n     | -  plicm_region_id = plicm_init(); \"添加 plic 的 mmio的 pmp entry\"\n     | -  timer_region_id = timerm_init(); \"添加 timer 的 mmio的pmp entry\"\n  \"没有判断 cold_boot 说明是所有核都会走\"\n| -+ pmp_init() \"将所有可用的 pmpaddr pmpcfg 置0\"\n| -+ pmp_set_keystone(sm_region_id, PMP_NO_PERM); \"设置 opensbi text 段不可读，这个是对 S-mode 有效，对 M-mode 不起作用\"\n| -+ pmp_set_keystone(os_region_id, PMP_ALL_PERM); \"设置优先级最低的 osm entry 0xfffffffff 保底读写执行权限，排在它前面的 entry 如果设置了不一样的权限， 以前面的 entry 设置的为准\"\n| -+ pmp_set_keystone(tee_region_id, PMP_NO_PERM); \"设置 optee text 无权限\"\n| -|+ if cold_boot\n    \\ -+ opteed_init()\n       \\ -  sbi_memset(psci_ns_context, 0, sizeof(psci_ns_context));  \"normal world context 初始化为 0\"\n       | -  sbi_memset(opteed_sp_context, 0, sizeof(opteed_sp_context)); \"secure world context 初始化为 0\"\n       | -+ img_entry_point.sec_attr = SECURE;   \"保存状态， 后面会用. 该结构体最终会被放到 当前 cpu context 中\"\n       | -+ img_entry_point.pc = OPTEE_OS_LOAD_ADDR;  \"optee 的 text 段起始地址\"\n       | -  img_entry_point.arg0 = current_hartid(); \"cpu core id\"\n       | -  img_entry_point.arg1 = 8*1024*1024;\n       | -  img_entry_point.arg2 = FW_JUMP_FDT_ADDR; \"fdt 的地址，optee 和 opensbi 共用一个 fdt\"\n       | -+ cm_init_my_context(&img_entry_point); \n          \\ -+ cm_init_context_by_index(current_hartid(), &img_entry_point);\n             \\ -+ ctx = cm_get_context_by_index(cpu_idx, &img_entry_point->sec_attr);  \"根据 cpu id 和 sec_attr 属性找到 context 指针\"\n                \\ -  if secure? &opteed_sp_context[cpu_idx].cpu_ctx : &psci_ns_context[cpu_idx]; \n\t\t                \"secure 和 non sec 分别有一个context 数组， 按cpuid 保存对应的 当前cpu的context\"\n\t\t     | -+ cm_setup_context(ctx, ep); \"填 context \"\n\t\t        \\ -  ctx->sec_attr = (ep->sec_attr == SECURE) ? SECURE : NON_SECURE;\n\t\t        | -  ctx->gp_regs.mepc = ep->pc;\n\t\t        | -  ctx->gp_regs.mstatus = (1 << MSTATUS_MPP_SHIFT);  \"S-mode\"\n\t\t        | -  ctx->gp_regs.a0 = ep->arg0;\n\t\t        | -  ctx->gp_regs.a1 = ep->arg1;\n\t\t        | -  ctx->gp_regs.a2 = ep->arg2;\n\t\t        | -  ctx->gp_regs....   直到 arg7\n\t\t        | -|+ if ep->sec_attr == SECURE\n\t\t            \\ -  ctx->s_csrs.sie = 0;   \"初始 sie 为0, S-mode 中断关闭\"\n\t  | -  saved_mie = csr_read(CSR_MIE); \"保存中断使能状态\"\n\t  | -  csr_write(CSR_MIE, 0); \"关闭所有中断\"\n\t  | -  rc = opteed_synchronous_sp_entry(optee_ctx); \"进入 sec world optee_os 的准备工作, 及要进入 optee_os, 下面拆解\"\n\t  -----------------------------------------------------------------------------------------------------\n\t     \"回到 M-mode的 opensbi\"\n\t  -----------------------------------------------------------------------------------------------------\n\t  | -+ ... sbi_ecall_optee_handler 处理流程 -->1 \n\t  | -  csr_write(CSR_MIE, saved_mie); \"恢复中断状态\"\n\t  | -  sbi_memset(&img_entry_point, 0, sizeof(entry_point_info_t));\n\t  | -  img_entry_point.sec_attr = NON_SECURE;　\"下一个 image　为　non sec 的 u-boot\"\n\t  | -  cm_init_my_context(&img_entry_point); \"初始化 non sec 的 context\"\n\t  | -  cm_set_next_eret_context(NON_SECURE);         \n```\n\n\n下面对 opteed_synchronous_sp_entry 进行拆解\n\n```erlang\n-+ uint64_t opteed_synchronous_sp_entry(optee_context_t *optee_ctx)\n \\ -+ cm_sysregs_context_restore(SECURE); \"从context 中恢复 s 开头的 csr, 这里主要是 sepc sie \"\n | -+ cm_set_next_eret_context(SECURE);\n    \\ -+ ctx = cm_get_context(security_state); \"拿 当前 cpu的 context 指针\"\n    | -+ cm_set_next_context(ctx); \n       \\ -  next_cpu_context_ptr[current_hartid()] = context; \"设置 next_cpu_context_ptr 全局变量, 保存当前cpu的下一个 context\"\n    | -|+ if secure_state == SECURE ?\n        \\ -+ switch_plic_int_enable_mode(SECURE); \"设置中断使能状态为 secure_state 方案\"\n        | -+ switch_vector_sec();\n           \\ -  csr_write(CSR_MTVEC, &_trap_handler_sec);  \"设置 secure 方案的 trap handler\"\n        | -  osm_pmp_set(PMP_NO_PERM); \"bottom pmp entry 设置所有内存无权限\"\n        | -  shm_pmp_set(PMP_ALL_PERM); \"sec 与 non sec 的 share memory 设置 all 权限\"\n        | -  plicm_pmp_set(PMP_ALL_PERM);\n        | -  timerm_pmp_set(PMP_ALL_PERM);\n        | -  teem_pmp_set(PMP_ALL_PERM);  \"设置 tee 的 text data bss 等的 all 权限\"\n | -+ rc = opteed_enter_sp(&optee_ctx->c_rt_ctx); \"进入汇编函数, 保存当前 opensbi的 cpu context, \n\t\t\t\t\t\t 恢复 context 中保存的上下文, 即为 optee_os 准备的初始的 cpu context\"\n    \\ -  REG_L s1, SBI_TRAP_REGS_OFFSET(mepc)(s0)\n    | -  csrw CSR_MEPC, s1\n    | -  REG_L s1, SBI_TRAP_REGS_OFFSET(mstatus)(s0)\n    | -  csrw CSR_MSTATUS, s1\n    | -  mret \"进入到 optee_os, M-mode 切换为 S-mode\" \n```\n\n\n-->1  optee_os 初始化完毕后, 会发 ecall 调用, 调用号 SBI_EXT_OPTEE \"0x4F505445\" 回到 opensbi 中, opensbi 由前面设置的 `_trap_handler_sec` 处理, 进而由\nopensbi `sbi_ecall_optee_handler` 处理该 ecall 调用,其中 funcid 为 `TEESMC_OPTEED_RETURN_ENTRY_DONE`\n\n```erlang\n-+ static int sbi_ecall_optee_handler(unsigned long extid, unsigned long funcid,\n\t\t\t\t    const struct sbi_trap_regs *regs,\n\t\t\t\t    unsigned long *out_val,\n\t\t\t\t    struct sbi_trap_info *out_trap)\n \\ -+ switch (funcid)\n    \\ -+ case TEESMC_OPTEED_RETURN_ENTRY_DONE\t\t\t    \n       \\ -+ cm_gpregs_context_save(SECURE, regs); \"保存 optee_os 的上下文到 context 中\"\n          \\ -  ctx = cm_get_context(security_state);\n          | -  sbi_memcpy(&ctx->gp_regs, trap_reg, sizeof(struct sbi_trap_regs));  \"regs 已经由 _trap_handler_sec 保存下来了, 这里转移到 context 下\"\n       | -+ cm_sysregs_context_save(SECURE); \"保存 s 开头的 csr 到 context 下, 这里不用参数, 因为 M-mode 基本上不会改动 S-mode 的寄存器, 直接读即可\"\n       | -  optee_vector_table = (optee_vectors_t *) regs->a1; \"regs->a1锚点 optee_os的 thread_vector_table 基址在 ecall 时会保存到 a1 寄存器中, 进而转移到这里\"\n       | -  if optee_vector_table ? set_optee_pstate(optee_ctx->state, OPTEE_PSTATE_ON) \"optee_os的 power state, 这里on 表示正在运行\"\n       | -+ opteed_synchronous_sp_exit(optee_ctx, regs->a1); \"回到 进入 optee_os 时的地方\"\n          \\ -+ cm_sysregs_context_save(SECURE);\n             \\ -+ opteed_exit_sp(optee_ctx->c_rt_ctx, ret);\n                \\ -  REG_L s0, (12-13) * __SIZEOF_POINTER__(sp)\n                | -  ... \"恢复 callee 即 s0-s11 寄存器\"\n                | -  REG_L ra, (0-13) * __SIZEOF_POINTER__(sp) \"恢复 ra\"\n                | -  ret \"回到 进入 optee_os 时的地方 接着往下执行\"\n```\n\n\n# optee_os 启动流程\n\n上面讲到在调用 opteed_synchronous_sp_entry->opteed_enter_sp mret 后进入了 optee_os 中\n下面就讲下 optee_os 的启动流程.\n\noptee_os/core/arch/riscv/kernel/entry.S\n\n```erlang\n-+ _start\n \\ -  mv s1, a0 \"保存hartid\"\n | -  la a0, reset_vect_table\n | -  csrw stvec, a0 \"保存 stvec 中断入口 为 reset_vect_table\"\n | -+ clear_bss __bss_start, __bss_end\n | -+ set_sp s1 \"为 hartid 设置 sp\"\n | -+ jal thread_init_thread_core_local \"初始化线程本地存储\"\n | -+ jal dcache_cleaninv_range __text_start, cached_mem_end  \"dcache inv clean\"\n | -+ jal console_init \"初始化console\"\n | -+ jal core_init_mmu_map(0, boot_mmu_config) \"初始化mmu 映射mmu 页表\"\n | -+ jal enable_mmu(hartid) \"开启mmu\"\n | -+ jal boot_init_primary_early \"主核初始化\"\n    \\ -+ init_primary()\n       \\ -+ thread_init_core_local_stacks() \"由于std smc需要支持线程（thread）功能，而每个线程都需要含有独立的线程栈，\n\t\t       用于保存该线程相关的上下文。该函数用于为每个cpu核初始化相关的线程栈, tmp_stack_va_end用于指定每个ARM核的栈空间\"\n\t   | -+ thread_set_exceptions(THREAD_EXCP_ALL);  \"由于在接下来的初始化流程中需要切换异常向量表的基地址，\n\t\t\t\t\t\t   因此在切换之前需要先mask掉相关的异常使能位\"       \n\t   | -  primary_save_cntfrq()\t\"未实现\"\t\t\t   \n       | -  init_vfp_sec()  \"未实现,初始化浮点运算单元vfp\" \n       | -  thread_get_core_local()->curr_thread = 0;  \"curr_thread用于表示当前核使用的是哪个线程空间。\"\n       | -+ init_runtime(); \"初始化tee运行时所需的各种内存\"\n       | -+ thread_init_boot_thread(); \"将当前执行上下文转换为启动线程，\n\t\t\t       它主要包括从当前cpu的线程栈内存中分配一个栈空间，初始化线程页表和线程状态等\"\n\t   | -+ thread_init_primary();\t\"该函数主要用于增强线程的运行安全，如设置线程栈的canary值，以用于监测栈溢出\"\n\t   | -+ thread_init_per_cpu();  \n\t      \\ -+ thread_init_tvec();\t \"为每个cpu 设置中断入口为 thread_trap_vect\"\n\t   | -+ init_sec_mon(nsec_entry);   \"未实现\"\n | -+ jal boot_init_primary_late(fdt)\t\"该函数用于建立optee的系统运行环境，\n\t\t\t\t\t 包括从devcicetree中解析相关的配置，初始化中断控制器，调用initcall回调函数等\" \n\t\\ -+ init_external_dt(fdt); \"初始化devicetree，包括映射其物理内存，初始化dtb overlay等\"\t\n\t| -+ tpm_map_log_area(get_external_dt()); \"初始化tpm的log buffer，其主要操作是为log buffer建立虚拟地址页表\"\n\t| -+ discover_nsec_memory(); \"optee与non secure world可通过共享内存通信，它一共支持静态映射和动态映射两种共享内存方式。\n\t\t\t\t其中静态映射shm在optee启动时就为其建立了相应的内存页表，\n\t\t\t\t而动态映射方式可以在运行过程中动态地为shm建立页表。该接口用于从devicetree中获取non secure内存，以支持动态共享内存机制\"\n\t| -+ update_external_dt(); \"在devicetree中添加与optee相关的一些节点和属性，这些节点和属性将由hlos内核解析并用于初始化相应的模块。\n\t\t\t\t\t如它会创建/firmware/optee节点，并在该节点中配置一些与optee相关的属性\"\n\t| -+ configure_console_from_dt() \"从devicetree中解析串口参数，并将optee的控制台切换为该串口\"\n\t| -  main_init_gic(); \"未实现\"\n\t| -  init_vfp_nsec(); \"未实现\"\n\t| -+ init_tee_runtime(); \n\t   \\ -+ core_mmu_init_ta_ram(); \"用户空间中使用的栈空间是从 tee_mm_sec_ddr 内存池中分配出来的，\n\t\t\t\t\t   该内存池属于MEM_AREA_TA_RAM内存区域，该区域是由OPTEE分配，用于运行TA镜像。\"\n\t\t \\ -+ tee_mm_init(&tee_mm_sec_ddr, ps, size, CORE_MMU_USER_CODE_SHIFT, TEE_MM_POOL_NO_FLAGS);\n\t   | -+ call_initcalls(); -->2 \"调用已注册的initcall回调函数, 被各模块用于注册启动时调用的初始化接口, core/include/initcall.h\"\t\t\t   \n | -+ jal thread_clr_boot_thread \"thread 结束阶段, 将thread->state 置为 THREAD_STATE_FREE\"\n | -+ ecall SBI_EXT_OPTEE a6->TEESMC_OPTEED_RETURN_ENTRY_DONE a1-> thread_vector_table load offset -->3 \n\t\t\t\t\t \"ecall 回opensbi, 将optee_os 的 vector address load offset(此处就是其物理地址,这里mmu 是直接映射的) 放到 a1 中, 给opensbi 用, \n\t\t\t\t\t 参照 sbi_ecall_optee_handler 的 regs->a1锚点 \"\n```\n\n-->2 initcall 按顺序执行\n\n```c\n#define preinit_early(fn)\t\t__define_initcall(preinit, 1, fn)\n#define preinit(fn)\t\t\t__define_initcall(preinit, 2, fn)\n#define preinit_late(fn)\t\t__define_initcall(preinit, 3, fn)\n\n#define early_init(fn)\t\t\t__define_initcall(init, 1, fn)\n#define early_init_late(fn)\t\t__define_initcall(init, 2, fn)\n#define service_init(fn)\t\t__define_initcall(init, 3, fn)\n#define service_init_late(fn)\t\t__define_initcall(init, 4, fn)\n#define driver_init(fn)\t\t\t__define_initcall(init, 5, fn)\n#define driver_init_late(fn)\t\t__define_initcall(init, 6, fn)\n#define release_init_resource(fn)\t__define_initcall(init, 7, fn)\n\n#define boot_final(fn)\t\t\t__define_initcall(final, 1, fn)\n```\n\n-->3 thread_vector_table\n\n```c\nFUNC thread_vector_table , : , .identity_map, , nobti\n\t.option push\n\t.option norvc\n\tj\tvector_std_smc_entry\n\tj\tvector_fast_smc_entry\n\tj\tvector_cpu_on_entry\n\tj\tvector_cpu_off_entry\n\tj\tvector_cpu_resume_entry\n\tj\tvector_cpu_suspend_entry\n\tj\tvector_fiq_entry\n\tj\tvector_system_off_entry\n\tj\tvector_system_reset_entry\n\t.option pop\nEND_FUNC thread_vector_table\n```\n\n\n\n# 中断处理\n\n原生的 riscv 下并没有安全世界/非安全世界的区分, 没有对中断进行区分.\n而 arm trustzone 下可以根据 SCR.NS bit 位来标记进入安全世界还是非安全世界或者在进 monitor 时, 是来自于安全世界还是非安全世界.\n且 arm 在硬件上做到了将非安全中断绑定到 irq 事件, 安全中断绑定到了 fiq 事件. irq 由 REE 处理, fiq 由 TEE 处理. \n\n因此 riscv 想做 tee 方案, \n- 需要由软件管理安全世界/非安全世界的运行状态\n- 需要有软件管理非安全中断和安全中断\n上述这两点增加了软件实现的复杂度\n\n看下 nuclei 上怎么做到上述这两点的\n\n## 安全状态标记\n\n![](attachments/nuclei_optee_switch.png)\n\nopensbi 中实现 ATF 类似的功能, 不同的是, 需要由软件维护安全状态.\n- opteeos 初始化阶段, opensbi 在平台初始化节点, 通过 mret 进入 optee_os, optee_os 完成初始化后返回 opensbi, opensbi 需要保存 optee 的 context, 即安全世界上下文\n- ree os 运行阶段, 当需要 optee 服务时, ree os 通过 ecall 发送 optee 请求, opensbi 收到请求, 保存当前 cpu 状态到非安全 context, 然后恢复安全世界上下文, 将请求给 optee_os 处理. optee_os 处理完后, 发送 ecall 到 opensbi, opensbi 保存安全世界上下文恢复非安全世界上下文, 保存 optee 返回值, 恢复到 ree os 执行.\n维护安全状态中引入了多个数组指针, 保存当前 cpu 安全世界上下文/非安全世界上下文的指针. 以及 next context\n\n从 next context 的 sec_attr 判断是来自 安全世界还是非安全世界\n```c\nstatic int is_caller_non_secure(void)\n{\n\tcpu_context_t *ctx;\n\tctx = cm_get_next_context();\n\treturn (ctx->sec_attr == NON_SECURE);\n}\n```\n\n安全世界状态切换时, 需要更新维护 next context. 这点是比较容易理解的, 无论当前 cpu 是处在安全世界(TEE)还是非安全世界(TEE) 中, 进入这个模式前, 都需要 opensbi 切换世界状态的代码参与, 而这个代码 `cm_set_next_context` 维护了 sec_attr 的状态.\n\n而 arm 类似判断来自于安全世界/非安全世界的 smc 调用时, 用的 SCR.NS 硬件状态.\n\n\n## 维护中断状态\n\n要实现类似 arm FIQ/IRQ 的能力, nuclei 做了如下方案\n- 软件维护了一个表记录哪些中断是安全中断 (arm 使用 group 标记)\n- 安全中断应该由 M-mode 响应还是由 S-mode 响应\n\t- 进入 TEE, 设置安全中断由 S-mode 响应, 非安全中断由 M-mode 响应.\n\t- 进入 REE, 设置安全中断由 M-mode 响应, 非安全中断由 S-mode 响应.\n\n当处在 M-mode 时, 中断都由 M-mode 响应, 根据中断类型再分发给 TEE/REE\n\nplic_secure_int 数组中每个元素是由 hartid 和中断号组成，各占16bit, plic_secure_int[0]是个特殊值记录安全中断总个数。\n- plic_secure_int[0]：表示有 plic_secure_int[0] & 0xFFFF 个安全中断\n- plic_secure_int[x] 表示 plic_secure_int[x] & 0xFFFF 这个安全中断绑定到了hartid为plic_secure_int[x] >> 16 的core上\n\n```c\n// 注册安全中断\nint plic_register_sec_interrupt(unsigned int intr) {\n\thartid = current_hartid();\n\t// 检查安全中断是否已经被注册. 已经注册则返回\n\tfor (i = 0 ; i < cnt ; i++)\n\t\tif ((plic_secure_int[i + 1] & 0xFFFF) == intr)\n\t\t\treturn true;\n\t// 注册安全中断\n\tplic_secure_int[cnt + 1] = (hartid << 16) | intr;\n\t// 更新安全中断总个数\n\tplic_secure_int[0] = (0xFFFF << 16) | (cnt + 1);\t\t\t\n\t\n}\n\nint plic_is_sec_interrupt(int intr)\n{\n\tint i;\n     // plic_secure_int[0]是个特殊值记录安全中断总个数。\n\tfor(i = 0; i < (plic_secure_int[0] & 0xFFFF); i++)\n\t\tif (intr == (plic_secure_int[i+1] & 0xFFFF))\n\t\t\treturn true;\n\treturn false;\n}\n\n\nvoid switch_plic_int_enable_mode(int next_state)\n{\n\tint en_mode, plic_int_num;\n\tint i, j;\n\tunsigned int* secint;\n\n\tplic_int_num = irqchip_plic_get_interrupt_num();\n\tsecint = plic_get_sec_interrupt_tab();\n\tfor(i = 1; i <= plic_int_num; i++) {\n\t\ten_mode = irqchip_plic_get_en_mode(i, NON_SECURE);\n\t\tif (en_mode == -1 || plic_is_sec_interrupt(i))\n\t\t/* skip disabled interrupt and secure interrupt */\n\t\t\tcontinue;\n\t\telse {\n\t\t\t/*\n\t\t\t * set all non-secure interrupt enable to S mode when next_state is NON_SECURE\n\t\t\t * set all non-secure interrupt enable to M mode when next_state is SECURE\n\t\t\t */\n\t\t\tirqchip_plic_set_en_mode((u32*)&i, next_state == NON_SECURE, NON_SECURE);\n\t\t}\n\t}\n\t/*\n\t * set all secure interrupt enable to M mode when next_state is NON_SECURE\n\t * set all secure interrupt enable to S mode when next_state is SECURE\n\t */\n\tfor(j = 0; j < (secint[0] & 0xFFFF); j++)\n\t\tirqchip_plic_set_en_mode(&secint[j+1], !(next_state == NON_SECURE), SECURE);\n}\n\nint irqchip_plic_set_en_mode(unsigned int *pintid, unsigned int mode, int secure)\n{\n\thartid = current_hartid();\n\t// 判断安全中断是否绑定到了一个hartid 上, 如果没有则重新绑定到当前hartid上\n\tif (secure == 0) {\n\t\t/* judge if int_id is bind to a hart */\n\t\tif ((*pintid >> 16) != 0xFFFF) {\n\t\t\t/*\n\t\t\t * int_id have been bind to a hart, bind hart\n\t\t\t * is not equal current return do nothing\n\t\t\t */\n\t\t\tif ((*pintid >> 16) != hartid)\n\t\t\t\treturn SBI_EFAIL;\n\t\t} else {\n\t\t\t/* bind int_id to current hart id */\n\t\t\t*pintid = (hartid << 16) | (*pintid & 0xFFFF);\n\t\t}\n\t\t// 安全中断, int_id 取 低16位\n\t\tint_id = *pintid & 0xFFFF;\n\t}\n\telse\n\t    // 非安全中断, int_id = *pintid\n\t\tint_id = *pintid;\n    // 取plic 结构体\n\tplic = plic_hartid2data[hartid];\n\t// 取 intid 对应的 plic寄存器里的 stride offset\n\tint_src_idx = int_id / 32;\n...\n\t// 设置 plic 寄存器的 对应 int_id的 ie 使能位, 使能位分为 S-mode 和 M-mode的, 分别设置\n\t// plic_hartid2context[hartid][!!mode] 中保存了对应hartid的 world_index, world_index在 plic里实际为 M-mode 还是 S-mode\n\t// mode为0 plic_hartid2context[hartid][0]  存的是 M-mode 的 offset, plic_hartid2context[hartid][!0=1]  存的是 S-mode 的 offset\n\t// mode:  next_state == NON_SECURE       next_state为sec,     则 mode 为 0, M-mode offset 置1, S-mode offset 置0\n\t// mode:  !(next_state == NON_SECURE)    next_state为sec,     则 mode 为 1, S-mode offset 置1, M-mode offset 置0\n\t// mode:  next_state == NON_SECURE       next_state为non_sec, 则 mode 为 1, S-mode offset 置1, M-mode offset 置0\n\t// mode:  !(next_state == NON_SECURE)    next_state为non_sec, 则 mode 为 0, M-mode offset 置1, S-mode offset 置0\n\t// 即要进入sec 时,     将非安全中断 M-mode 使能, S-mode 关闭, 将安全中断 M-mode 关闭, S-mode 使能\n\t// 即要进入non_sec 时, 将非安全中断 S-mode 使能, M-mode 关闭, 将安全中断 M-mode 使能, S-mode 关闭\n\t\n\t\t/*set M/S mode, M:1,S;0, or M:0,S:1*/\n\t\tie_val = plic_get_ie(plic, plic_hartid2context[hartid][!!mode], int_src_idx);\n\t\tie_val |= 1 << (int_id % 32);\n\t\tplic_set_ie(plic, plic_hartid2context[hartid][!!mode], int_src_idx, ie_val);\n\n\t\tie_val = plic_get_ie(plic, plic_hartid2context[hartid][!mode], int_src_idx);\n\t\tie_val &= ~(1 << (int_id % 32));\n\t\tplic_set_ie(plic, plic_hartid2context[hartid][!mode], int_src_idx, ie_val);\n\n\treturn 0;\n}\n\nvoid plic_set_ie(struct plic_data *plic, u32 cntxid, u32 word_index, u32 val)\n{\n\tplic_ie = (void *)plic->addr +\n\t\t   PLIC_ENABLE_BASE + PLIC_ENABLE_STRIDE * cntxid;\n\twritel(val, plic_ie + word_index * 4);\n}\n```\n\n与 arm 差异\n\n维护中断是否是安全中断/非安全中断\n- nuclei riscv 哪个中断号是安全的, 哪个是不安全的, 由软件维护\n- arm 由设置 gic group 寄存器确定了, 然后硬件维护中断状态, 根据运行模式将中断绑定到 fiq 或 irq\n中断的处理:\n- nuclei riscv , optee 只处理安全中断, ree 只处理非安全中断, M-mode opensbi 处理剩下的, 因为在运行到 tee 时, 非安全中断的 S-mode ie 关闭了, 在运行到 ree 时, 安全中断在 S-mode ie 被关闭了\n- arm 上, tee ree 还是会处理 irq fiq, 需要陷入到 monitor 或 EL3 转给对方.\n","tags":["riscv","optee_os"],"categories":["TEE","optee_os","RISCV"]},{"title":"riscv aosp requirements (thead)","url":"/2023/07/11/hxd_new/riscv调研/riscv_aosp_requirements(thead)/","content":"\n![](attachments/riscv_aosp_requirements.png)\n\n# RISC-V Better Atomics (Load-Acquire/Store-Release)\n\n是 RISC-V 体系结构的一种扩展，旨在提供更强大的原子操作支持。\n在并发编程中，原子操作是一种确保多个线程或处理器可以安全地对共享变量进行操作的机制。原子操作需要满足一定的一致性和同步性质，以避免数据竞争和不确定的行为。\n\nRISC-V Better Atomics 扩展引入了一对新的原子指令，即 Load-Acquire 和 Store-Release。\n- Load-Acquire 用于读取共享变量，并确保读取操作具有\"acquire\"语义，即保证在此原子操作之前的所有存储操作都可见。\n- Store-Release 用于写入共享变量，并确保写入操作具有\"release\"语义，即保证在此原子操作之后的所有加载操作都能看到最新的值。\n\n使用 RISC-V Better Atomics 可以更好地控制并发访问共享变量的顺序和一致性。它提供了更细粒度的原子操作语义，以满足高性能和并发编程的需求。\n\n在 RISCV-V 的 A 扩展下\n- Load-Acquire 指令通常以 `lr.` 或 `amoswap` 的形式出现，例如 `lr.w`（Load-Reserved Word）用于加载一个字（32位数据）并获取内存序。\n- Store-Release 指令通常以 `sc.` 或 `amoswap` 的形式出现，例如 `sc.w`（Store-Conditional Word）用于将一个字（32位数据）存储到内存中并释放内存序。\n\n# Saturating Operations\n\n饱和操作（Saturating Operations）是一种特殊的操作，用于处理数值溢出的情况。当执行某种算术操作时，如果结果超出了数据类型的表示范围，饱和操作将会将结果截断为数据类型所能表示的最大或最小值，而不是简单地截断为溢出的结果。\n\nRISC-V 架构中的饱和操作主要应用于整数数据类型。以下是一些常见的饱和操作指令：\n\n1.  SLL.SAT：饱和左移指令，将一个寄存器中的整数左移指定的位数，并将结果截断为数据类型的最大或最小值。\n2.  SRA.SAT：饱和右算术移位指令，将一个寄存器中的整数右算术移位指定的位数，并将结果截断为数据类型的最大或最小值。\n3.  SRL.SAT：饱和右逻辑移位指令，将一个寄存器中的整数右逻辑移位指定的位数，并将结果截断为数据类型的最大或最小值。\n4.  ADD.SAT：饱和加法指令，将两个寄存器中的整数相加，并将结果截断为数据类型的最大或最小值。\n5.  SUB.SAT：饱和减法指令，将两个寄存器中的整数相减，并将结果截断为数据类型的最大或最小值。\n\n这些饱和操作指令使得处理数值溢出的情况更加方便和可控，避免了溢出错误对程序执行的影响。\n\n需要注意的是，饱和操作并不是所有 RISC-V 架构中都支持的标准指令。具体支持的指令和操作会根据特定的处理器和实现而有所不同。因此，在编写程序时，建议参考相关的处理器手册或编程指南，以了解特定处理器对饱和操作的支持情况和具体的指令格式。\n\n# Half-width floats (Zfh)\n\n半精度浮点数（Half-width floats）是一种浮点数表示格式，用于表示较小的浮点数范围。在 RISC-V 中，半精度浮点数采用 IEEE 754 标准的半精度浮点格式。\n\n半精度浮点数使用 16 位（2 字节）来表示一个浮点数，其中包括符号位、指数位和尾数位。具体的格式如下：\n\n-   符号位（1 位）：用于表示浮点数的正负。\n-   指数位（5 位）：用于表示浮点数的指数部分，可以表示范围为 -14 到 +15。\n-   尾数位（10 位）：用于表示浮点数的尾数部分。\n\n半精度浮点数相比于单精度浮点数（32 位）和双精度浮点数（64 位）具有较小的范围和精度，但占用更少的存储空间。在一些资源受限的场景中，如嵌入式系统或移动设备，半精度浮点数可以用于节省存储空间和提高计算效率。\n\n> 玄铁 910 支持半精度浮点类指令\n\n![](attachments/c910_half_float.png)\n\n# Bitmanip\n\nRISC-V Bitmanip 扩展是 RISC-V 指令集架构的一部分，用于进行位操作和位操作相关的操作。Bitmanip 扩展引入了一组指令，以提供对位操作的支持，包括位移、位计数、位反转、位扩展等功能。\n\nBitmanip 扩展的主要目的是增强 RISC-V 的位操作能力，使开发者能够更高效地处理位级操作和位级数据操作。这对于一些应用场景，如加密算法、图形处理、数据压缩等，非常有用.\n\nBitmanip 扩展引入了一些常用的位操作指令，例如：\n\n-   `clz`: 计算无符号整数的前导零位数。\n-   `ctz`: 计算无符号整数的尾部零位数。\n-   `pcnt`: 计算无符号整数的位计数，即二进制表示中的位为 1 的个数。\n-   `slo`: 逻辑左移操作，将指定位数的位从右边移入。\n-   `sro`: 逻辑右移操作，将指定位数的位从左边移入。\n-   `rol`: 循环左移操作，将位向左循环移动。\n-   `ror`: 循环右移操作，将位向右循环移动。\n\n这些指令使得开发者能够更高效地进行位级操作和位级数据处理，简化代码编写和提高运行效率。\n\n需要注意的是，具体的 Bitmanip 指令和功能会根据 RISC-V 架构扩展的版本和实现而有所不同。因此，建议查阅相关的处理器手册或编程指南以获取详细的信息和指令使用示例。\n\n> 玄铁 C910 支持扩展的位操作指令 \n\n![](attachments/c910_bitmap.png)\n\n# J extension\n\nRISC-V J 的扩展旨在使 RISC-V 成为传统解释或 JIT 编译的语言或需要大型运行时库或语言级虚拟机的语言的一个有吸引力的目标, 包括 C# JAVA python 等.\n\nhttps://github.com/riscv/riscv-j-extension\n\nRISC-V 指针屏蔽（PM）是一个功能，当启用时，会导致 MMU 忽略有效地址的前 N 位。使得这些比特可以以应用程序选择的任何方式使用。所描述的扩展版本专门针对标签检查。当一个地址被访问时，存储在被屏蔽位中的标签与基于范围的标签进行比较。这被用于动态安全检查器，如 HWASAN[1]。这样的工具可以应用于所有的特权模式（U、S 和 M）。\n\n\n# ABI gaps \n\n需要 TLSDESC 等\n\n## TLSDESC\n\nRISC-V TLSDESC，全称为 Thread Local Storage Descriptor，是 RISC-V 指令集架构的一部分，用于支持线程本地存储（Thread Local Storage，TLS）的访问。\n\nTLS 是一种机制，允许每个线程在共享内存的基础上拥有自己独立的数据区域，这对于多线程编程非常重要。TLS 可以用于存储线程特定的数据，例如线程的局部变量或全局状态。\n\nRISC-V TLSDESC 扩展引入了以下指令：\n\nTLSDESC_CALL (TLS Descriptor Call)：调用 TLS 描述符以获取线程本地存储数据的地址。\nTLS 描述符是一个特殊的数据结构，用于获取线程本地存储数据的地址。TLSDESC_CALL 指令用于调用 TLS 描述符，并将返回的地址存储在指定的寄存器中，以便后续访问线程本地存储数据。\n\n需要注意的是，RISC-V TLSDESC 扩展是可选的，并不是所有的 RISC-V 架构都支持该扩展。具体的支持情况可以参考特定处理器的文档或规格说明。\n\nTLSDESC 扩展的引入使得在 RISC-V 架构上能够更方便地使用线程本地存储，提供了对多线程编程的支持\n\n\n>arm 中通过 `TPIDR_EL0` 寄存器，每个线程可以访问自己的 TLS 数据，而不需要使用全局变量或其他机制。线程局部存储是一种为每个线程分配独立内存空间的机制，用于保存线程特定的数据。\n通过将 TLS 基址存储在 `TPIDR_EL0` 寄存器中，线程可以通过读取该寄存器来迅速获取自己的 TLS 数据的访问地址。\n\n\n# HWASAN\n\n(Hardware-assisted Address Sanitizer）是一种基于硬件辅助的地址检测工具，用于检测和调试软件中的内存错误和安全问题。它类似于其他架构上的 AddressSanitizer（ASan）工具，但专门针对 RISC-V 架构进行了优化。\n\n该实现依赖于 J-extension（又称 \"指针屏蔽）的可用性。目前，这个扩展不是官方的\n需要修改编译器 (llvm) 适配该实现\n\n# TEE\n\nthere's an Ever ratcheting bar on the hardware features that are required whether it's ***trusted execution environments confidential compute virtualization*** or ***even runtime detection of memory safety errors in the hardware***\n\n需要虚拟化实现的 TEE 或者硬件内存安全错误检测机制 (如 ARM 的 trustzone 或 sifive 的 worldguard 机制)\n\n> 玄铁 c910 支持 VirtualZone 技术 (PMP+IOPMP)\n\n# virtualization\n\n硬件虚拟化, 可以用来辅助实现内存的安全隔离机制\ntrusted execution environments confidential compute virtualization\n\n# C910 extension 小结\n\n![](attachments/c910_extension.png)\n\n","tags":["riscv"],"categories":["AOSP","玄铁"]},{"title":"nuclei riscv isa 测试","url":"/2023/07/11/hxd_new/riscv调研/riscv 测试/","content":"\n# nuclei sdk\n\n## 目录结构\n\n```shell\nnuclei-sdk\n├── Build  #build 生成目录\n├── Components  # 空目录\n├── NMSIS       # dsp nn的静态库和头文件\n├── OS          # FreeRTOS RTThread ucosii 头文件及源码目录\n├── SoC         # demosoc gd32vf103 bsp 头文件及源码目录\n├── application # baremental FreeRTOS RTThread ucosii 下跑的app 源码\n├── doc         # 文档\n├── logs        # 测试框架生成目录\n├── test        # riscv 指令集 中断 fpu pmp timer 等相关测试项, 在baremental下的测试\n└── tools       # 测试框架脚本\n```\n\n## 编译baremental app\n\n例子\n\n```shell\nmake PROGRAM=application/baremetal/helloworld SOC=demosoc BOARD=nuclei_fpga_eval all\n```\n\n## 运行baremental app\n\n例子\n```shell\nnuclei_qemu/bin/qemu-system-riscv64  -M nuclei_n -cpu nuclei-ux600 -nodefaults -nographic -serial stdio -kernel application/baremetal/helloworld/helloworld.elf\n```\n\n## riscv isa 测试框架\n指test下的对riscv isa的测试\n\n主要的文件在 test/core/* 下.\n编译时根据 指定的 SOC 指定使用的bsp的代码\n如SOC 指定 demosoc\n使用的 SoC/demosoc/Common/ 下的源文件\nBOARD指定为nuclei_fpga_eval \n引用的头文件 `SoC/demosoc/Board/nuclei_fpga_eval`\n\n```shell\n\"-I/home/liguang/work_space/nuclei-sdk/test/core\",\n\"-I/home/liguang/work_space/nuclei-sdk/test\",\n\"-I/home/liguang/work_space/nuclei-sdk/NMSIS/Core/Include\",\n\"-I/home/liguang/work_space/nuclei-sdk/SoC/demosoc/Board/nuclei_fpga_eval/Include\",\n\"-I/home/liguang/work_space/nuclei-sdk/SoC/demosoc/Common/Include\"\n```\n\n```shell\n    SoC/demosoc/Common/Source/GCC/intexc_demosoc.S, # 中断 trap 上下文切换 相关\n    SoC/demosoc/Common/Source/GCC/startup_demosoc.S,  #bsp 初始启动相关源码\n    SoC/demosoc/Common/Source/Drivers/demosoc_gpio.c, # gpio\n    SoC/demosoc/Common/Source/Drivers/demosoc_uart.c, # uart\n    SoC/demosoc/Common/Source/Stubs/newlib/clock_getres.c, #clock time\n    SoC/demosoc/Common/Source/Stubs/newlib/clock_gettime.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/clock_settime.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/close.c,   #文件相关, 大部分是空的桩函数\n    SoC/demosoc/Common/Source/Stubs/newlib/execve.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/exit.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/fork.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/fstat.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/getpid.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/gettimeofday.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/isatty.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/kill.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/link.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/lseek.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/open.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/read.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/sbrk.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/stat.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/times.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/unlink.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/wait.c,\n    SoC/demosoc/Common/Source/Stubs/newlib/write.c,\n    SoC/demosoc/Common/Source/demosoc_common.c, # delay_1ms get_cpu_freq measure_cpu_freq\n    # 大部分为startup.S 中的c 函数实现 SystemInit system_default_exception_handler _premain_init _postmain_fini 等 \n    SoC/demosoc/Common/Source/system_demosoc.c, \n    test/core/main.c,\n    test/core/test_atomic.c,\n    test/core/test_compiler.c,\n    test/core/test_csr.c,\n    test/core/test_eclic.c,\n    test/core/test_fpu.c,\n    test/core/test_pmp.c,\n    test/core/test_timer.c\n```\n\n### 执行原理\nctest_main\n从 .data.ctest 内存开始的地方进行扫描, 扫描 magic 为 CTEST_IMPL_MAGIC 的 `struct ctest` 数据\n执行其 run 方法.\n```c\n                    if (test->setup && *test->setup) (*test->setup)(test->data);\n                    if (test->data)\n                        test->run(test->data);\n                    else\n                        test->run();\n\n#define CTEST(sname, tname) CTEST_IMPL_CTEST(sname, tname, 0)\n#define CTEST_IMPL_CTEST(sname, tname, tskip) \\\n    static void CTEST_IMPL_FNAME(sname, tname)(void); \\\n    CTEST_IMPL_STRUCT(sname, tname, tskip, NULL, NULL, NULL); \\\n    static void CTEST_IMPL_FNAME(sname, tname)(void)\n\n#define CTEST_IMPL_SECTION __attribute__ ((used, section (\".data.ctest\"), aligned(1)))\n\n#define CTEST_IMPL_STRUCT(sname, tname, tskip, tdata, tsetup, tteardown) \\\n    static struct ctest CTEST_IMPL_TNAME(sname, tname) CTEST_IMPL_SECTION = { \\\n        .ssname=#sname, \\\n        .ttname=#tname, \\\n        .run = CTEST_IMPL_FNAME(sname, tname), \\\n        .data = tdata, \\\n        .setup = (ctest_setup_func*) tsetup, \\\n        .teardown = (ctest_teardown_func*) tteardown, \\\n        .skip = tskip, \\\n        .magic = CTEST_IMPL_MAGIC }\nex:\nCTEST(pmp, pmpreg)\nrun = ctest_pmp_pmpreg_run\n```\n\n### 跑测\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230226213811.png)\n\n## 芯来自动测试框架\n\nci 构建\n.gitlab-ci.yml\n\ntools/script 下封装了大量跑测全部工程的脚本.\n待了解, 不是本次调研的重点.\n\n如根据 appcfg hwcfg 选择指定的SOC/BOARD/CORE 跑测对应的 application\n\n```json\n    \"run_config\": {\n        \"target\" : \"qemu\",\n        \"hardware\" : {\n            \"baudrate\": 115200,\n            \"timeout\": 60\n        },\n        \"qemu\" : {\n            \"timeout\": 60\n        }\n    },\n    \"build_target\": \"clean all\",\n    \"build_config\": {\n        \"SOC\": \"demosoc\",\n        \"BOARD\": \"nuclei_fpga_eval\",\n        \"CORE\": \"ux600\",\n        \"DOWNLOAD\": \"ilm\",\n        \"ARCH_EXT\": \"\"\n    },\n```\n\n\n```shell\n# build 构建脚本\npython3 tools/scripts/nsdk_cli/nsdk_bench.py --appcfg tools/scripts/nsdk_cli/configs/application.json --hwcfg tools/scripts/nsdk_cli/configs/nuclei_fpga_eval_qemu.json --parallel=\"-j\" --logdir logs/nuclei_fpga_eval_ci\n# 跑测脚本\npython3 tools/scripts/nsdk_cli/nsdk_bench.py --appcfg tools/scripts/nsdk_cli/configs/application.json --hwcfg tools/scripts/nsdk_cli/configs/nuclei_fpga_eval_qemu.json --parallel=\"-j\" --logdir logs/nuclei_fpga_eval_ci --run\n```\n上述跑测是用qemu测的\n\n生成的报告\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230226213812.png)\n\n部分报告\nreport.md\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230226213813.png)\n## xlspike 跑测\n```shell\ntools/scripts/misc/dobench/run.sh\n\n...\nBuild command: make  -C application/baremetal/benchmark/coremark  SOC=demosoc BOARD=nuclei_fpga_eval DOWNLOAD=ilm CPU_SERIES=200 SIMULATION=1 SIMU=xlspike CORE=n203e showflags\n\nRun application on xlspike\n...\n```\n\n这个脚本也是用 nsdk_bench.py 跑的, 只是模拟器换成了 xlspike\n```shell\npython3 $NSDK_BENCH_PY --appcfg $appcfg --hwcfg $hwcfg --parallel=-j --logdir $logdir --make_options \\\"$SIMU_OPTS \n    $mkopts\\\" $RUN_OPTS\n    \npython3 /home/liguang/work_space/nuclei-sdk/tools/scripts/nsdk_cli/nsdk_bench.py --appcfg /home/liguang/work_space/nuclei-sdk/tools/scripts/misc/dobench/app.json --hwcfg /home/liguang/work_space/nuclei-sdk/tools/scripts/misc/dobench/bench_nx600.json --parallel=-j --logdir /home/liguang/work_space/nuclei-sdk/tools/scripts/misc/dobench/gen/0.3.8-1-g9cfda9b1fa-dirty/dobench//barebench/nx600 --make_options \"SIMULATION=1 SIMU=xlspike \" --run --run_target xlspike\n```\n\n总共为 n200/n300/n600/n900/nx600/nx900 的  application/baremetal/benchmark下的 coremark dhrystone whetstone\n编译了json 配置的 指令集的elf, 并用nuclei的 xl_spike 进行跑测.\n\n```json\n        \"rv32emc\": {\"CORE\":\"n203e\"},\n        \"rv32imac\": {\"CORE\":\"n203\"},\n        \"rv32imacb\": {\"CORE\":\"n203\", \"ARCH_EXT\":\"b\"}\n        ...\n        \"rv32imac\": {\"CORE\":\"n300\"},\n        \"rv32imacb\": {\"CORE\":\"n300\", \"ARCH_EXT\":\"b\"},\n        \"rv32imacbp\": {\"CORE\":\"n300\", \"ARCH_EXT\":\"bp\"},\n        \"rv32imafc\": {\"CORE\":\"n300f\", \"ARCH_EXT\":\"\"},\n        \"rv32imafcb\": {\"CORE\":\"n300f\", \"ARCH_EXT\":\"b\"},\n        \"rv32imafcp\": {\"CORE\":\"n300f\", \"ARCH_EXT\":\"p\"},\n        \"rv32imafcbp\": {\"CORE\":\"n300f\", \"ARCH_EXT\":\"bp\"},\n        \"rv32imafdc\": {\"CORE\":\"n300fd\", \"ARCH_EXT\":\"\"},\n        \"rv32imafdcb\": {\"CORE\":\"n300fd\", \"ARCH_EXT\":\"b\"},\n        \"rv32imafdcp\": {\"CORE\":\"n300fd\", \"ARCH_EXT\":\"p\"},\n        \"rv32imafdcbp\": {\"CORE\":\"n300fd\", \"ARCH_EXT\":\"bp\"}\n        ...\n        \"rv64imac\": {\"CORE\":\"nx600\"},\n        \"rv64imacb\": {\"CORE\":\"nx600\", \"ARCH_EXT\":\"b\"},\n        \"rv64imacbp\": {\"CORE\":\"nx600\", \"ARCH_EXT\":\"bp\"},\n        \"rv64imafc\": {\"CORE\":\"nx600f\", \"ARCH_EXT\":\"\"},\n        \"rv64imafcb\": {\"CORE\":\"nx600f\", \"ARCH_EXT\":\"b\"},\n        \"rv64imafcp\": {\"CORE\":\"nx600f\", \"ARCH_EXT\":\"p\"},\n        \"rv64imafcbp\": {\"CORE\":\"nx600f\", \"ARCH_EXT\":\"bp\"},\n        \"rv64imafdc\": {\"CORE\":\"nx600fd\", \"ARCH_EXT\":\"\"},\n        \"rv64imafdcb\": {\"CORE\":\"nx600fd\", \"ARCH_EXT\":\"b\"},\n        \"rv64imafdcp\": {\"CORE\":\"nx600fd\", \"ARCH_EXT\":\"p\"},\n        \"rv64imafdcbp\": {\"CORE\":\"nx600fd\", \"ARCH_EXT\":\"bp\"}\n\n```\n\n其中的一条指令\n```shell\nBuild application application/baremetal/benchmark/dhrystone, with target: clean\nBuild command: make -j -C application/baremetal/benchmark/dhrystone  SOC=demosoc BOARD=nuclei_fpga_eval DOWNLOAD=ilm CPU_SERIES=600 SIMULATION=1 SIMU=xlspike DHRY_MODE=inline CORE=nx600fd ARCH_EXT=bp clean\nBuild command return value: 0\nBuild application application/baremetal/benchmark/dhrystone, with target: dasm\nBuild command: make -j -C application/baremetal/benchmark/dhrystone  SOC=demosoc BOARD=nuclei_fpga_eval DOWNLOAD=ilm CPU_SERIES=600 SIMULATION=1 SIMU=xlspike DHRY_MODE=inline CORE=nx600fd ARCH_EXT=bp dasm\nBuild command return value: 0\nBuild application application/baremetal/benchmark/dhrystone, with target: showtoolver\nBuild command: make  -C application/baremetal/benchmark/dhrystone  SOC=demosoc BOARD=nuclei_fpga_eval DOWNLOAD=ilm CPU_SERIES=600 SIMULATION=1 SIMU=xlspike DHRY_MODE=inline CORE=nx600fd ARCH_EXT=bp showtoolver\nBuild command return value: 0\nBuild application application/baremetal/benchmark/dhrystone, with target: showflags\nBuild command: make  -C application/baremetal/benchmark/dhrystone  SOC=demosoc BOARD=nuclei_fpga_eval DOWNLOAD=ilm CPU_SERIES=600 SIMULATION=1 SIMU=xlspike DHRY_MODE=inline CORE=nx600fd ARCH_EXT=bp showflags\nBuild command return value: 0\nBuild application application/baremetal/benchmark/dhrystone, time cost 0.73 seconds, passed: True\nRun application on xlspike\nxl_spike doesn't exist in PATH, please check!\n\n   * - dasm\n\n     - build and dissemble application with selected configuration\n  - add ``showflags`` target to show compiling information and flags\n  - add ``showtoolver`` target to show tool version used\n     \n```\n\n总共生成的文件列表:\n```shell\n├── allcfg.json\n├── allrst.json\n├── app_failed.txt\n├── app_passed.txt\n├── n200\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv32emc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv32imacb\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv32emc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv32imacb\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv32emc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv32imacb\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── n300\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv32imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv32imafdcp\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── n600\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv32imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv32imafdcp\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── n900\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv32imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv32imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv32imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv32imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imacbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafcp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv32imafdcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv32imafdcp\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── nx600\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv64imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv64imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv64imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv64imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv64imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imacb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imacbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv64imafdcp\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── nx900\n│   ├── app_failed.txt\n│   ├── app_passed.txt\n│   ├── appcfg.json\n│   ├── application\n│   │   └── baremetal\n│   │       └── benchmark\n│   │           ├── coremark\n│   │           │   ├── rv64imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   ├── rv64imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── coremark.dasm\n│   │           │   │   ├── coremark.elf\n│   │           │   │   ├── coremark.map\n│   │           │   │   └── coremark.verilog\n│   │           │   └── rv64imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── coremark.dasm\n│   │           │       ├── coremark.elf\n│   │           │       ├── coremark.map\n│   │           │       └── coremark.verilog\n│   │           ├── dhrystone\n│   │           │   ├── rv64imac\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imacb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imacbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafcp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdc\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdcb\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   ├── rv64imafdcbp\n│   │           │   │   ├── build.log\n│   │           │   │   ├── dhrystone.dasm\n│   │           │   │   ├── dhrystone.elf\n│   │           │   │   ├── dhrystone.map\n│   │           │   │   └── dhrystone.verilog\n│   │           │   └── rv64imafdcp\n│   │           │       ├── build.log\n│   │           │       ├── dhrystone.dasm\n│   │           │       ├── dhrystone.elf\n│   │           │       ├── dhrystone.map\n│   │           │       └── dhrystone.verilog\n│   │           └── whetstone\n│   │               ├── rv64imac\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imacb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imacbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafcp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdc\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdcb\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               ├── rv64imafdcbp\n│   │               │   ├── build.log\n│   │               │   ├── whetstone.dasm\n│   │               │   ├── whetstone.elf\n│   │               │   ├── whetstone.map\n│   │               │   └── whetstone.verilog\n│   │               └── rv64imafdcp\n│   │                   ├── build.log\n│   │                   ├── whetstone.dasm\n│   │                   ├── whetstone.elf\n│   │                   ├── whetstone.map\n│   │                   └── whetstone.verilog\n│   ├── hwcfg.json\n│   ├── mergedcfg.json\n│   ├── report.html\n│   ├── report.md\n│   ├── result.csv\n│   ├── result.json\n│   ├── runresult.json\n│   ├── runresult.xlsx\n│   ├── runresult.xlsx.csvdict.json\n│   └── runresult.xlsx.csvtable.json\n├── report.html\n├── report.md\n├── result.csv\n├── runresult.json\n├── runresult.xlsx\n├── runresult.xlsx.csvdict.json\n└── runresult.xlsx.csvtable.json\n```\n# riscv-tests\nhttps://github.com/riscv-software-src/riscv-tests\n\n## 目录结构\n\n```shell\n├── benchmarks # benchmarks \n├── debug # cpu gdb 测试环境\n├── env #python env 环境\n├── isa # 指令集测试\n├── mt  # 矩阵乘法测试\n└── target # 生成目录\n```\n\n## gdb 测试环境\n\ndebug 下的测试主要是针对cpu本身的测试, cpu 设置好初始环境后进行loop, 然后通过gdb 执行对应的汇编指令跑测, 判断测试结构是否符合预期.\n\n这部分主要包含两个部分:\n```shell\ntargets\n├── RISC-V\n│   ├── __pycache__\n│   │   ├── spike32.cpython-39.pyc\n│   │   └── spike64.cpython-39.pyc\n│   ├── spike-1.cfg\n│   ├── spike-2-hwthread.cfg\n│   ├── spike-2.cfg\n│   ├── spike-multi.cfg\n│   ├── spike-multi.py\n│   ├── spike32-2-hwthread.py\n│   ├── spike32-2.py\n│   ├── spike32.lds\n│   ├── spike32.py\n│   ├── spike64-2-hwthread.py\n│   ├── spike64-2-rtos.py\n│   ├── spike64-2.py\n│   ├── spike64.lds\n│   └── spike64.py\n└── SiFive\n    ├── Freedom\n    │   ├── E300.py\n    │   ├── Freedom.cfg\n    │   ├── Freedom.lds\n    │   ├── U500.py\n    │   └── U500Sim.py\n    ├── HiFive1-flash.lds\n    ├── HiFive1-flash.py\n    ├── HiFive1.cfg\n    ├── HiFive1.lds\n    ├── HiFive1.py\n    ├── HiFiveUnleashed-flash.lds\n    ├── HiFiveUnleashed-flash.py\n    ├── HiFiveUnleashed.cfg\n    ├── HiFiveUnleashed.lds\n    ├── HiFiveUnleashed.py\n    └── HiFiveUnleashed_setup.bin\n```\n\n\n## 模拟运行:\n通过openocd + spike 测试\n\nhttps://github.com/riscv-software-src/riscv-isa-sim\n```\n$ spike --rbb-port=9824 -m0x10100000:0x20000 rot13-64\nListening for remote bitbang connection on port 9824.\n\n$ openocd -f spike.cfg\nOpen On-Chip Debugger 0.10.0-dev-00002-gc3b344d (2017-06-08-12:14)\n...\nriscv.cpu: target state: halted\n\n$ riscv64-unknown-elf-gdb\ntarget remote localhost:3333\n```\n\n>有条件下厂商需要定制 riscv 公版的spike, 如芯来的为 xl_spike, 没找到源码\n\n### 跑测例子\n```shell\n./gdbserver.py ./targets/RISC-V/spike64.py MemTest8\nUsing $misa from hart definition: 0x8000000000141125\n[MemTest8] Starting > logs/20230226-170843-spike64-MemTest8.log\n[MemTest8] pass in 2.26s\n::::::::::::::::::::::::::::[ ran 1 tests in 2s ]:::::::::::::::::::::::::::::\n1 tests returned pass\n```\n\n解析:\n```python\nclass SimpleMemoryTest(GdbTest):\n    def access_test(self, size, data_type):\n        assertEqual(self.gdb.p(f\"sizeof({data_type})\"), size)\n        a = 0x86753095555aaaa & ((1<<(size*8))-1)\n        b = 0xdeadbeef12345678 & ((1<<(size*8))-1)\n        addrA = self.hart.ram\n        addrB = self.hart.ram + self.hart.ram_size - size\n        self.gdb.p(f\"*(({data_type}*)0x{addrA:x}) = 0x{a:x}\") # 设置 *addrA = a \n        self.gdb.p(f\"*(({data_type}*)0x{addrB:x}) = 0x{b:x}\") # 设置 *addrB = b\n        assertEqual(self.gdb.p(f\"*(({data_type}*)0x{addrA:x})\"), a) # 判断 *ddrA 是否=a \n        assertEqual(self.gdb.p(f\"*(({data_type}*)0x{addrB:x})\"), b) # 判断 *ddrB 是否=b\n\nclass MemTest8(SimpleMemoryTest):\n    def test(self):\n        self.access_test(1, 'char')\n```\n\n拆解下这个测试干了哪些事情:\n#### 编译\n最终生成的 elf 文件为 spike64_checksum-8000000000141125\n```shell\nriscv64-unknown-elf-gcc -g programs/checksum.c programs/tiny-malloc.c programs/infinite_loop.S -DDEFINE_MALLOC -DDEFINE_FREE programs/entry.S programs/init.c -DNHARTS=1 -I ../env -T targets/RISC-V/spike64.lds -nostartfiles -mcmodel=medany -DXLEN=64 -o spike64_checksum-8000000000141125 -march=rv64imafc -mabi=lp64\n```\n\n#### spike 运行\n```shell\nspike -p1 --isa RV64IMAFC --dm-auth --dm-progsize 0 --dm-sba 64 --dm-abstract-rti 30 -m0x1212340000:0x10000000 --rbb-port 0 spike64_checksum-8000000000141125\n```\n\n#### openocd \n```shell\nREMOTE_BITBANG_HOST=localhost REMOTE_BITBANG_PORT=34113 WORK_AREA=0x1212340000 USE_FREERTOS=0 openocd --command 'gdb_port 0' --command 'tcl_port disabled' --command 'telnet_port disabled' -f targets/RISC-V/spike-1.cfg\n```\n\n#### gdb执行\n```shell\nriscv64-unknown-elf-gdb \\\n...\nmonitor riscv reset_delays 127\ntarget extended-remote localhost:40541\ninfo threads\ninfo threads\n  Id   Target Id         Frame \n* 1    Remote target     0x00000012123406ae in ?? ()\n\np/x sizeof(char)\n$1 = 0x1\np/x *((char*)0x1212340000) = 0xaa\np/x *((char*)0x122233ffff) = 0x78\np/x *((char*)0x1212340000)\n0xaa\np/x *((char*)0x122233ffff)\n0x78\nResult: pass\n```\n\n### fpga 运行:\n通过 openocd + fpga 测试\n这个没有跑测环境, 大概推测是由 fpga 运行对应的bin\nopenocd 连接调试环境, 通过gdb 连接openocd, 给fpga 发送cmd 进行测试\n\n## 其他几个目录的测试\n\n### isa\n\n为cpu指令集测试, 包含 S/U/M 模式下的 I, M, A, F, D, V测试\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230226213814.png)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230226213815.png)\n\n```shell\n rv32mi-p-breakpoint\n rv32mi-p-csr\n rv32mi-p-illegal\n rv32mi-p-lh-misaligned\n rv32mi-p-lw-misaligned\n rv32mi-p-ma_addr\n rv32mi-p-ma_fetch\n rv32mi-p-mcsr\n rv32mi-p-sbreak\n rv32mi-p-scall\n rv32mi-p-sh-misaligned\n rv32mi-p-shamt\n rv32mi-p-sw-misaligned\n rv32mi-p-zicntr\n rv32si-p-csr\n rv32si-p-dirty\n rv32si-p-ma_fetch\n rv32si-p-sbreak\n rv32si-p-scall\n rv32si-p-wfi\n rv32ua-p-amoadd_w\n rv32ua-p-amoand_w\n rv32ua-p-amomax_w\n rv32ua-p-amomaxu_w\n rv32ua-p-amomin_w\n rv32ua-p-amominu_w\n rv32ua-p-amoor_w\n rv32ua-p-amoswap_w\n rv32ua-p-amoxor_w\n rv32ua-p-lrsc\n rv32ua-v-amoadd_w\n rv32ua-v-amoand_w\n rv32ua-v-amomax_w\n rv32ua-v-amomaxu_w\n rv32ua-v-amomin_w\n rv32ua-v-amominu_w\n rv32ua-v-amoor_w\n rv32ua-v-amoswap_w\n rv32ua-v-amoxor_w\n rv32ua-v-lrsc\n rv32uc-p-rvc\n rv32uc-v-rvc\n rv32ud-p-fadd\n rv32ud-p-fclass\n rv32ud-p-fcmp\n rv32ud-p-fcvt\n rv32ud-p-fcvt_w\n rv32ud-p-fdiv\n rv32ud-p-fmadd\n rv32ud-p-fmin\n rv32ud-p-ldst\n rv32ud-p-recoding\n rv32ud-v-fadd\n rv32ud-v-fclass\n rv32ud-v-fcmp\n rv32ud-v-fcvt\n rv32ud-v-fcvt_w\n rv32ud-v-fdiv\n rv32ud-v-fmadd\n rv32ud-v-fmin\n rv32ud-v-ldst\n rv32ud-v-recoding\n rv32uf-p-fadd\n rv32uf-p-fclass\n rv32uf-p-fcmp\n rv32uf-p-fcvt\n rv32uf-p-fcvt_w\n rv32uf-p-fdiv\n rv32uf-p-fmadd\n rv32uf-p-fmin\n rv32uf-p-ldst\n rv32uf-p-move\n rv32uf-p-recoding\n rv32uf-v-fadd\n rv32uf-v-fclass\n rv32uf-v-fcmp\n rv32uf-v-fcvt\n rv32uf-v-fcvt_w\n rv32uf-v-fdiv\n rv32uf-v-fmadd\n rv32uf-v-fmin\n rv32uf-v-ldst\n rv32uf-v-move\n rv32uf-v-recoding\n rv32ui-p-add\n rv32ui-p-addi\n rv32ui-p-and\n rv32ui-p-andi\n rv32ui-p-auipc\n rv32ui-p-beq\n rv32ui-p-bge\n rv32ui-p-bgeu\n rv32ui-p-blt\n rv32ui-p-bltu\n rv32ui-p-bne\n rv32ui-p-fence_i\n rv32ui-p-jal\n rv32ui-p-jalr\n rv32ui-p-lb\n rv32ui-p-lbu\n rv32ui-p-lh\n rv32ui-p-lhu\n rv32ui-p-lui\n rv32ui-p-lw\n rv32ui-p-or\n rv32ui-p-ori\n rv32ui-p-sb\n rv32ui-p-sh\n rv32ui-p-simple\n rv32ui-p-sll\n rv32ui-p-slli\n rv32ui-p-slt\n rv32ui-p-slti\n rv32ui-p-sltiu\n rv32ui-p-sltu\n rv32ui-p-sra\n rv32ui-p-srai\n rv32ui-p-srl\n rv32ui-p-srli\n rv32ui-p-sub\n rv32ui-p-sw\n rv32ui-p-xor\n rv32ui-p-xori\n rv32ui-v-add\n rv32ui-v-addi\n rv32ui-v-and\n rv32ui-v-andi\n rv32ui-v-auipc\n rv32ui-v-beq\n rv32ui-v-bge\n rv32ui-v-bgeu\n rv32ui-v-blt\n rv32ui-v-bltu\n rv32ui-v-bne\n rv32ui-v-fence_i\n rv32ui-v-jal\n rv32ui-v-jalr\n rv32ui-v-lb\n rv32ui-v-lbu\n rv32ui-v-lh\n rv32ui-v-lhu\n rv32ui-v-lui\n rv32ui-v-lw\n rv32ui-v-or\n rv32ui-v-ori\n rv32ui-v-sb\n rv32ui-v-sh\n rv32ui-v-simple\n rv32ui-v-sll\n rv32ui-v-slli\n rv32ui-v-slt\n rv32ui-v-slti\n rv32ui-v-sltiu\n rv32ui-v-sltu\n rv32ui-v-sra\n rv32ui-v-srai\n rv32ui-v-srl\n rv32ui-v-srli\n rv32ui-v-sub\n rv32ui-v-sw\n rv32ui-v-xor\n rv32ui-v-xori\n rv32um-p-div\n rv32um-p-divu\n rv32um-p-mul\n rv32um-p-mulh\n rv32um-p-mulhsu\n rv32um-p-mulhu\n rv32um-p-rem\n rv32um-p-remu\n rv32um-v-div\n rv32um-v-divu\n rv32um-v-mul\n rv32um-v-mulh\n rv32um-v-mulhsu\n rv32um-v-mulhu\n rv32um-v-rem\n rv32um-v-remu\n rv64mi-p-access\n rv64mi-p-breakpoint\n rv64mi-p-csr\n rv64mi-p-illegal\n rv64mi-p-ld-misaligned\n rv64mi-p-lh-misaligned\n rv64mi-p-lw-misaligned\n rv64mi-p-ma_addr\n rv64mi-p-ma_fetch\n rv64mi-p-mcsr\n rv64mi-p-sbreak\n rv64mi-p-scall\n rv64mi-p-sd-misaligned\n rv64mi-p-sh-misaligned\n rv64mi-p-sw-misaligned\n rv64mi-p-zicntr\n rv64si-p-csr\n rv64si-p-dirty\n rv64si-p-icache-alias\n rv64si-p-ma_fetch\n rv64si-p-sbreak\n rv64si-p-scall\n rv64si-p-wfi\n rv64ssvnapot-p-napot\n rv64ua-p-amoadd_d\n rv64ua-p-amoadd_w\n rv64ua-p-amoand_d\n rv64ua-p-amoand_w\n rv64ua-p-amomax_d\n rv64ua-p-amomax_w\n rv64ua-p-amomaxu_d\n rv64ua-p-amomaxu_w\n rv64ua-p-amomin_d\n rv64ua-p-amomin_w\n rv64ua-p-amominu_d\n rv64ua-p-amominu_w\n rv64ua-p-amoor_d\n rv64ua-p-amoor_w\n rv64ua-p-amoswap_d\n rv64ua-p-amoswap_w\n rv64ua-p-amoxor_d\n rv64ua-p-amoxor_w\n rv64ua-p-lrsc\n rv64ua-v-amoadd_d\n rv64ua-v-amoadd_w\n rv64ua-v-amoand_d\n rv64ua-v-amoand_w\n rv64ua-v-amomax_d\n rv64ua-v-amomax_w\n rv64ua-v-amomaxu_d\n rv64ua-v-amomaxu_w\n rv64ua-v-amomin_d\n rv64ua-v-amomin_w\n rv64ua-v-amominu_d\n rv64ua-v-amominu_w\n rv64ua-v-amoor_d\n rv64ua-v-amoor_w\n rv64ua-v-amoswap_d\n rv64ua-v-amoswap_w\n rv64ua-v-amoxor_d\n rv64ua-v-amoxor_w\n rv64ua-v-lrsc\n rv64uc-p-rvc\n rv64uc-v-rvc\n rv64ud-p-fadd\n rv64ud-p-fclass\n rv64ud-p-fcmp\n rv64ud-p-fcvt\n rv64ud-p-fcvt_w\n rv64ud-p-fdiv\n rv64ud-p-fmadd\n rv64ud-p-fmin\n rv64ud-p-ldst\n rv64ud-p-move\n rv64ud-p-recoding\n rv64ud-p-structural\n rv64ud-v-fadd\n rv64ud-v-fclass\n rv64ud-v-fcmp\n rv64ud-v-fcvt\n rv64ud-v-fcvt_w\n rv64ud-v-fdiv\n rv64ud-v-fmadd\n rv64ud-v-fmin\n rv64ud-v-ldst\n rv64ud-v-move\n rv64ud-v-recoding\n rv64ud-v-structural\n rv64uf-p-fadd\n rv64uf-p-fclass\n rv64uf-p-fcmp\n rv64uf-p-fcvt\n rv64uf-p-fcvt_w\n rv64uf-p-fdiv\n rv64uf-p-fmadd\n rv64uf-p-fmin\n rv64uf-p-ldst\n rv64uf-p-move\n rv64uf-p-recoding\n rv64uf-v-fadd\n rv64uf-v-fclass\n rv64uf-v-fcmp\n rv64uf-v-fcvt\n rv64uf-v-fcvt_w\n rv64uf-v-fdiv\n rv64uf-v-fmadd\n rv64uf-v-fmin\n rv64uf-v-ldst\n rv64uf-v-move\n rv64uf-v-recoding\n rv64ui-p-add\n rv64ui-p-addi\n rv64ui-p-addiw\n rv64ui-p-addw\n rv64ui-p-and\n rv64ui-p-andi\n rv64ui-p-auipc\n rv64ui-p-beq\n rv64ui-p-bge\n rv64ui-p-bgeu\n rv64ui-p-blt\n rv64ui-p-bltu\n rv64ui-p-bne\n rv64ui-p-fence_i\n rv64ui-p-jal\n rv64ui-p-jalr\n rv64ui-p-lb\n rv64ui-p-lbu\n rv64ui-p-ld\n rv64ui-p-lh\n rv64ui-p-lhu\n rv64ui-p-lui\n rv64ui-p-lw\n rv64ui-p-lwu\n rv64ui-p-ma_data\n rv64ui-p-or\n rv64ui-p-ori\n rv64ui-p-sb\n rv64ui-p-sd\n rv64ui-p-sh\n rv64ui-p-simple\n rv64ui-p-sll\n rv64ui-p-slli\n rv64ui-p-slliw\n rv64ui-p-sllw\n rv64ui-p-slt\n rv64ui-p-slti\n rv64ui-p-sltiu\n rv64ui-p-sltu\n rv64ui-p-sra\n rv64ui-p-srai\n rv64ui-p-sraiw\n rv64ui-p-sraw\n rv64ui-p-srl\n rv64ui-p-srli\n rv64ui-p-srliw\n rv64ui-p-srlw\n rv64ui-p-sub\n rv64ui-p-subw\n rv64ui-p-sw\n rv64ui-p-xor\n rv64ui-p-xori\n rv64ui-v-add\n rv64ui-v-addi\n rv64ui-v-addiw\n rv64ui-v-addw\n rv64ui-v-and\n rv64ui-v-andi\n rv64ui-v-auipc\n rv64ui-v-beq\n rv64ui-v-bge\n rv64ui-v-bgeu\n rv64ui-v-blt\n rv64ui-v-bltu\n rv64ui-v-bne\n rv64ui-v-fence_i\n rv64ui-v-jal\n rv64ui-v-jalr\n rv64ui-v-lb\n rv64ui-v-lbu\n rv64ui-v-ld\n rv64ui-v-lh\n rv64ui-v-lhu\n rv64ui-v-lui\n rv64ui-v-lw\n rv64ui-v-lwu\n rv64ui-v-ma_data\n rv64ui-v-or\n rv64ui-v-ori\n rv64ui-v-sb\n rv64ui-v-sd\n rv64ui-v-sh\n rv64ui-v-simple\n rv64ui-v-sll\n rv64ui-v-slli\n rv64ui-v-slliw\n rv64ui-v-sllw\n rv64ui-v-slt\n rv64ui-v-slti\n rv64ui-v-sltiu\n rv64ui-v-sltu\n rv64ui-v-sra\n rv64ui-v-srai\n rv64ui-v-sraiw\n rv64ui-v-sraw\n rv64ui-v-srl\n rv64ui-v-srli\n rv64ui-v-srliw\n rv64ui-v-srlw\n rv64ui-v-sub\n rv64ui-v-subw\n rv64ui-v-sw\n rv64ui-v-xor\n rv64ui-v-xori\n rv64um-p-div\n rv64um-p-divu\n rv64um-p-divuw\n rv64um-p-divw\n rv64um-p-mul\n rv64um-p-mulh\n rv64um-p-mulhsu\n rv64um-p-mulhu\n rv64um-p-mulw\n rv64um-p-rem\n rv64um-p-remu\n rv64um-p-remuw\n rv64um-p-remw\n rv64um-v-div\n rv64um-v-divu\n rv64um-v-divuw\n rv64um-v-divw\n rv64um-v-mul\n rv64um-v-mulh\n rv64um-v-mulhsu\n rv64um-v-mulhu\n rv64um-v-mulw\n rv64um-v-rem\n rv64um-v-remu\n rv64um-v-remuw\n rv64um-v-remw\n```\n是通过spike 进行测试的.\n跑测结果\n```shell\n# 对所有测试项进行测试, 会通过Makefile中的指定对应的isa 进行测试\nmake run\n```\n\n例子\n编译 执行\n```shell\n# 编译\nriscv64-unknown-elf-gcc -march=rv64g -mabi=lp64 -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles -DENTROPY=0xcaa8519 -std=gnu99 -O2 -I./../env/v -I./macros/scalar -T./../env/v/link.ld ./../env/v/entry.S ./../env/v/*.c rv64ui/lui.S -o rv64ui-v-lui\n# 执行\n# 执行结果放在 *.out 文件中, 无log为正常现象\nspike --isa=rv64gc_zfh_zicboz_svnapot rv64ui-v-lui 2> rv64ui-v-lui.out \n```\n\n### benchmarks\n\n跑测执行\n```shell\nmake run\n# 例子 qsort 编译\n...\nriscv64-unknown-elf-gcc -I./../env -I./common -I./median -I./qsort -I./rsort -I./towers -I./vvadd -I./multiply -I./mm -I./dhrystone -I./spmv -I./mt-vvadd -I./mt-matmul -I./pmp -DPREALLOCATE=1 -mcmodel=medany -static -std=gnu99 -O2 -ffast-math -fno-common -fno-builtin-printf -fno-tree-loop-distribute-patterns -o qsort.riscv ./qsort/qsort_main.c ./common/syscalls.c ./common/crt.S -static -nostdlib -nostartfiles -lm -lgcc -T ./common/test.ld\n\n# 执行\nspike --isa=rv64gc qsort.riscv > qsort.riscv.out\n# 结果\ncat qsort.riscv.out\nmcycle = 127363\nminstret = 127368\n...\n```\n\nqsort 主要源码:\n```c\n  setStats(1);  // 计时开始\n  sort( DATA_SIZE, input_data ); //对 dataset1.h 存的 input_data 进行排序\n  setStats(0); // 计时结束, 输出时间\n\n  // Check the results\n  return verify( DATA_SIZE, input_data, verify_data ); // 判断排序结果是否和 预期的 dataset1.h 存的 verify_data 一致, 不一致, 退出case报错\n```\n\n跑分测试\n\n```shell\n├── Makefile\n├── common      # 公共源文件, 启动相关\n│   ├── crt.S\n│   ├── syscalls.c\n│   ├── test.ld\n│   └── util.h\n├── dhrystone\n│   ├── dhrystone.c\n│   ├── dhrystone.h\n│   └── dhrystone_main.c\n├── median\n│   ├── dataset1.h  # 存放预期的执行结果\n│   ├── median.c\n│   ├── median.h\n│   ├── median_gendata.pl\n│   └── median_main.c\n├── mm\n│   ├── common.h\n│   ├── gen.scala\n│   ├── mm.c\n│   ├── mm_main.c\n│   └── rb.h\n├── mt-matmul\n│   ├── dataset.h # 存放预期的执行结果\n│   ├── matmul.c\n│   ├── matmul_gendata.pl\n│   └── mt-matmul.c\n├── mt-vvadd\n│   ├── dataset.h  # 存放预期的执行结果\n│   ├── mt-vvadd.c\n│   ├── vvadd.c\n│   └── vvadd_gendata.pl\n├── multiply\n│   ├── dataset1.h\n│   ├── multiply.c\n│   ├── multiply.h\n│   ├── multiply_gendata.pl\n│   └── multiply_main.c\n├── pmp\n│   └── pmp.c\n├── qsort\n│   ├── dataset1.h # 存放预期的执行结果\n│   ├── qsort_gendata.pl\n│   └── qsort_main.c\n├── qsort.riscv.out.tags\n├── readme.txt\n├── rsort\n│   ├── dataset1.h\n│   └── rsort.c\n├── spmv\n│   ├── dataset1.h # 存放预期的执行结果\n│   ├── spmv_gendata.scala\n│   └── spmv_main.c\n├── towers\n│   └── towers_main.c\n└── vvadd\n    ├── dataset1-large.h # 存放预期的执行结果\n    ├── dataset1.h\n    ├── vvadd_gendata.pl\n    └── vvadd_main.c\n```\n\n\n### mt\n矩阵乘法相关, 编译报错, 不是重点, 暂时跳过\n```shell\n├── Makefile\n├── ad_matmul.c\n├── ae_matmul.c\n├── af_matmul.c\n├── ag_matmul.c\n├── ai_matmul.c\n├── ak_matmul.c\n├── al_matmul.c\n├── am_matmul.c\n├── an_matmul.c\n├── ap_matmul.c\n├── aq_matmul.c\n├── ar_matmul.c\n├── at_matmul.c\n├── av_matmul.c\n├── ay_matmul.c\n├── az_matmul.c\n├── bb_matmul.c\n├── bc_matmul.c\n├── bf_matmul.c\n├── bh_matmul.c\n├── bj_matmul.c\n├── bk_matmul.c\n├── bm_matmul.c\n├── bo_matmul.c\n├── br_matmul.c\n├── bs_matmul.c\n├── ce_matmul.c\n├── cf_matmul.c\n├── cg_matmul.c\n├── ci_matmul.c\n├── ck_matmul.c\n├── cl_matmul.c\n├── cm_matmul.c\n├── crt.o\n├── cs_matmul.c\n├── cv_matmul.c\n├── cy_matmul.c\n├── dc_matmul.c\n├── df_matmul.c\n├── dm_matmul.c\n├── do_matmul.c\n├── dr_matmul.c\n├── ds_matmul.c\n├── du_matmul.c\n├── dv_matmul.c\n├── mt-vvadd.o\n├── syscalls.o\n├── vvadd0.c\n├── vvadd0.o\n├── vvadd1.c\n├── vvadd2.c\n├── vvadd3.c\n└── vvadd4.c\n```\n\n# sifive freedom-e-sdk\n\nhttps://github.com/sifive/freedom-e-sdk\n\n## 目录结构\n```shell\n❯ tree -L 1 -d\n.\n├── FreeRTOS-metal #FreeRTOS 相关\n├── bsp # board 相关\n├── doc\n├── docker\n├── freedom-devicetree-tools # device tree 编译相关\n├── freedom-metal # baremental 相关\n├── pip-cache # python 环境相关\n├── scl-metal # software crypto库\n├── scripts # 编译 执行相关脚本\n├── software # baremental app\n└── venv # python 环境相关\n```\n\n## software case\n\n```shell\n❯ tree -L 1 -d\n.\n├── atomics\n├── cflush\n├── clic-hardware-vector-interrupts\n├── clic-nested-interrupts\n├── clic-nonvector-interrupts\n├── clic-selective-vector-interrupts\n├── coremark\n├── csr\n├── dhrystone\n├── empty\n├── example-buserror\n├── example-freertos-blinky\n├── example-freertos-minimal\n├── example-freertos-pmp-blinky\n├── example-hca-metal\n├── example-hello\n├── example-hpm\n├── example-i2c\n├── example-itim\n├── example-l2pf\n├── example-l2pm\n├── example-lim\n├── example-pmp\n├── example-privilege-level\n├── example-pwm\n├── example-remapper\n├── example-rnmi\n├── example-rtc\n├── example-spi\n├── example-user-mode\n├── example-user-syscall\n├── example-vm-test\n├── example-watchdog\n├── hello\n├── local-interrupt\n├── local-vector-interrupts\n├── mem-latency\n├── minimal-boot\n├── multicore-hello\n├── plic-interrupts\n├── return-fail\n├── return-pass\n├── sifive-welcome\n├── software\n├── software-interrupt\n├── test-coreip\n├── timer-interrupt\n├── uart-interrupt\n└── vm-test\n```\n\n\n\n## 基础编译\n\n```shell\nmake TARGET=${target} PROGRAM=${program}\n```\n\n## 引用的文件\n\n头文件:\nPLATFORM_HEADER = bsp/qemu-sifive-s51/metal-platform.h\nMACHINE_HEADER = bsp/qemu-sifive-s51/metal.h\nMACHINE_INLINE = bsp/qemu-sifive-s51/metal-inline.h\n\nmarch=rv64imac -mabi=lp64\n\n\n\nld: bsp/qemu-sifive-s51/metal.default.lds\n\n\n\nfreedom-metal/src/ 下的文件会编译为 `bsp/qemu-sifive-s51/install/lib/debug/libmetal.a`\nfreedom-metal/gloss/ 下的文件编译为  `bsp/qemu-sifive-s51/install/lib/debug/libmetal-gloss.a`\n\n```makefile\nlibmetal_a_SOURCES = \\\n\tsrc/drivers/fixed-clock.c \\\n\tsrc/drivers/fixed-factor-clock.c \\\n\tsrc/drivers/inline.c \\\n\tsrc/drivers/riscv_clint0.c \\\n\tsrc/drivers/riscv_cpu.c \\\n\tsrc/drivers/riscv_plic0.c \\\n\tsrc/drivers/sifive_remapper2.c \\\n\tsrc/drivers/sifive_buserror0.c \\\n\tsrc/drivers/sifive_ccache0.c \\\n\tsrc/drivers/sifive_clic0.c \\\n\tsrc/drivers/sifive_fe310-g000_hfrosc.c \\\n\tsrc/drivers/sifive_fe310-g000_hfxosc.c \\\n\tsrc/drivers/sifive_fe310-g000_lfrosc.c \\\n\tsrc/drivers/sifive_fe310-g000_pll.c \\\n\tsrc/drivers/sifive_fe310-g000_prci.c \\\n\tsrc/drivers/sifive_global-external-interrupts0.c \\\n\tsrc/drivers/sifive_gpio-buttons.c \\\n\tsrc/drivers/sifive_gpio-leds.c \\\n\tsrc/drivers/sifive_gpio-switches.c \\\n\tsrc/drivers/sifive_gpio0.c \\\n\tsrc/drivers/sifive_i2c0.c \\\n\tsrc/drivers/sifive_l2pf0.c \\\n\tsrc/drivers/sifive_l2pf1.c \\\n\tsrc/drivers/sifive_local-external-interrupts0.c \\\n\tsrc/drivers/sifive_pl2cache0.c \\\n\tsrc/drivers/sifive_prci0.c \\\n\tsrc/drivers/sifive_pwm0.c \\\n\tsrc/drivers/sifive_rtc0.c \\\n\tsrc/drivers/sifive_spi0.c \\\n\tsrc/drivers/sifive_test0.c \\\n\tsrc/drivers/sifive_trace.c \\\n\tsrc/drivers/sifive_uart0.c \\\n\tsrc/drivers/sifive_simuart0.c \\\n\tsrc/drivers/sifive_wdog0.c \\\n\tsrc/drivers/ucb_htif0.c \\\n\tsrc/remapper.c \\\n\tsrc/atomic.c \\\n\tsrc/button.c \\\n\tsrc/cache.c \\\n\tsrc/clock.c \\\n\tsrc/cpu.c \\\n\tsrc/entry.S \\\n\tsrc/scrub.S \\\n\tsrc/trap.S \\\n\tsrc/gpio.c \\\n\tsrc/hpm.c \\\n\tsrc/i2c.c \\\n\tsrc/init.c \\\n\tsrc/interrupt.c \\\n\tsrc/led.c \\\n\tsrc/lock.c \\\n\tsrc/memory.c \\\n\tsrc/pmp.c \\\n\tsrc/prci.c \\\n\tsrc/privilege.c \\\n\tsrc/pwm.c\\\n\tsrc/rtc.c \\\n\tsrc/shutdown.c \\\n\tsrc/spi.c \\\n\tsrc/switch.c \\\n\tsrc/synchronize_harts.c \\\n\tsrc/timer.c \\\n\tsrc/time.c \\\n\tsrc/trap.S \\\n\tsrc/tty.c \\\n\tsrc/uart.c \\\n\tsrc/vector.S \\\n\tsrc/watchdog.c\n\nlibmetal_gloss_a_SOURCES = \\\n\tgloss/crt0.S \\\n\tgloss/nanosleep.c \\\n\tgloss/sys_access.c \\\n\tgloss/sys_chdir.c \\\n\tgloss/sys_chmod.c \\\n\tgloss/sys_chown.c \\\n\tgloss/sys_clock_gettime.c \\\n\tgloss/sys_close.c \\\n\tgloss/sys_execve.c \\\n\tgloss/sys_exit.c \\\n\tgloss/sys_faccessat.c \\\n\tgloss/sys_fork.c \\\n\tgloss/sys_fstat.c \\\n\tgloss/sys_fstatat.c \\\n\tgloss/sys_ftime.c \\\n\tgloss/sys_getcwd.c \\\n\tgloss/sys_getpid.c \\\n\tgloss/sys_gettimeofday.c \\\n\tgloss/sys_isatty.c \\\n\tgloss/sys_kill.c \\\n\tgloss/sys_link.c \\\n\tgloss/sys_lseek.c \\\n\tgloss/sys_lstat.c \\\n\tgloss/sys_open.c \\\n\tgloss/sys_openat.c \\\n\tgloss/sys_read.c \\\n\tgloss/sys_sbrk.c \\\n\tgloss/sys_stat.c \\\n\tgloss/sys_sysconf.c \\\n\tgloss/sys_times.c \\\n\tgloss/sys_unlink.c \\\n\tgloss/sys_utime.c \\\n\tgloss/sys_wait.c \\\n\tgloss/sys_write.c\n# software 下的源文件\nsoftware/minimal-boot/minimal-boot.c\n```\n\n## 跑测\n\n```shell\n./scripts/test-qemu-targets\n```\n\nscripts/test-qemu-targets\n```python\n#TARGETS=(qemu-sifive-e31 qemu-sifive-s51 qemu-sifive-u54 qemu-sifive-u54mc )\nTARGETS=(qemu-sifive-s51 )\nPROGRAMS=(minimal-boot )\n\nfor target in ${TARGETS[@]} ; do\n    for program in ${PROGRAMS[@]} ; do\n\n        build_output_file=$( mktemp -p ./ tmp.${target}.${program}.build.XXXXXXXXXX)\n        run_output_file=$( mktemp -p ./ tmp.${target}.${program}.run.XXXXXXXXXX)\n\n        case $program in\n            hello)              expected_output=\"Hello, World!\";;\n            minimal-boot)       expected_output=\"minimal-boot\";;\n            *)                  expected_output=\"\";;\n        esac\n\n        >&2 echo \"Building ${program} on ${target}\"\n\n        make TARGET=${target} PROGRAM=${program} 2>&1 | tee ${build_output_file}\n        timeout --foreground ${TIMEOUT_SECONDS}s bash -c \"make TARGET=${target} PROGRAM=${program} simulate 2>/dev/null | tee ${run_output_file}\"\n\n        if [ ! -f ${run_output_file} -o `cat ${run_output_file} | grep -c \"${expected_output}\"` -eq 0 ] ; then\n            >&2 echo \"${program} on ${target} failed to produce the expected output\"\n        else\n            >&2 echo \"${program} on ${target} passed\"\n        fi\n\n        # Make sure we clean up after ourselves\n        make TARGET=${target} PROGRAM=${program} clean 2>&1 >/dev/null\n    done\n```\n\n跑测命令:\n\n```shell\nscripts/simulate --elf /home/liguang/program/riscv-lab/freedom-e-sdk/software/minimal-boot/debug/minimal-boot.elf --qemu qemu-system-riscv64 --qemu-config bsp/qemu-sifive-s51/qemu.cfg\n```\n\n实际跑测命令:\n\n```shell\nqemu-system-riscv64 -M sifive_e -kernel /home/liguang/program/riscv-lab/freedom-e-sdk/software/minimal-boot/debug/minimal-boot.elf -nographic\n```\n\n## build benchmark\n## Building an Benchmark Program\n\nBuilding a benchmark program is slightly special in that certain section is required to be loaded in specific memory region. A specialize linker file has been created for its optimal run.\n\n```shell\nmake PROGRAM=dhrystone TARGET=coreip-e31-arty LINK_TARGET=ramrodata software\n```\n\n## Debugging a Target Program\n\n```\nmake [PROGRAM=hello] [TARGET=sifive-hifive1] [CONFIGURATION=debug] debug\n```\n","tags":["riscv","nuclei"],"categories":["RISCV","测试"]},{"title":"riscv-hyp-test 测试框架","url":"/2023/06/11/hxd_new/riscv调研/虚拟化/riscv-hyp-test 测试框架/","content":"\n# test_page\n\n测试 2-stage translation 页表的 PTE的集合\nvs 为 vs-stage translation 的pte\nh  为 g-stage  translation 的pte\n\n```c\nstruct {\n    uint64_t vs;\n    uint64_t h;\n} test_page_perm_table [] = {\n     # index    -----------    vs  ---------------------- h ------#\n\t[VSRWX_GRWX]      =   {PTE_V | PTE_RWX,         PTE_V | PTE_RWX},\n}\n```\n\n页表属性按照PTE的 7:0 位设置相关的bit位\n\n![image-20211126175029553](images/image-20211126175029553.png)\n\n# hspt_init\n\n测试框架执行 hspt_init 对2-stage 页表进行初始化\n如 tinst_tests 测试项, 该测试集对指令进行测试\n\n```erlang\n-+ tinst_tests\n \\ -+ hspt_init\n    \\ -  addr = 0x00000000;\n    | -+ for(int i = 0; i < 4; i++)\n       \\ -  hspt[0][i] = PTE_V | PTE_AD | PTE_RWX | (addr >> 2);  \"设置第一级页表 pgd\"\n       | -  addr += PGSIZE << (2 * 9)   \"设置完后, hspt[0][0] -> hspt[0][3] 为 0 0x4000000 0x80000000 0xc0000000 base 地址\"\n    | -  hspt[0][4] = PTE_V | (((uintptr_t)&hspt[1][0]) >> 2);   \"设置PPN 二级页表\"\n    | -  hspt[1][0] = PTE_V | (((uintptr_t)&hspt[2][0]) >> 2);   \"设置 PPN 三级页表\"\n    | -  addr = TEST_PPAGE_BASE; \"0x88000000\"\n    | -+ for(int i = 0; i < TEST_PAGE_MAX; i++)  \"TEST_PAGE_MAX = 512, 一共设置512个PTE\"\n       \\ -+ hspt[2][i] = (addr >> 2) | PTE_AD | test_page_perm_table[i].vs; \n\t\t\t\t\t\t\t       \"设置PTE 物理地址为 0x88000000 - 0x881ff000 / 间隔 1page\"\n\t\t\t\t\t\t\t       \"每个PTE 对应的测试集的权限不同, 取自 test_page_perm_table.vs 权限集\"\n       | -  addr += PAGE_SIZE;\n    | -  CSRW(satp, satp);   \"M-mode 或 Hs-mode 下设置satp 为 hspt 基地址即 hspt[0][0]的基址\"\n | -  goto_priv(PRIV_HS); \"进入hs-mode\"\n | -  uintptr_t vaddr_f = hs_page_base(VSI_GI); \"VSI_GI=100, vs_page_base 0x100000000 + 100* PGSIZE = 0x100064000\"\n                            \"访问不了, 应该报错\"\n | -  TEST_SETUP_EXCEPT(); \"初始化 except 数据 为 0\"\n | -  value = lb(vaddr_f); \"lb load vaddr_f 的数据\"\n | -  TEST_ASSERT(excpt.cause == CAUSE_LPF) \"测试应该陷入 M-mode handler, 且mcause 应为 13 load page fault\"\n                                            \" 如果未触发异常, 或mcause 不对, case 报错\"\n```\n\n大概回顾下页表结构\n可见这个是针对sv39 的页表\n回顾下 sv39 页表的查表方法\n\nsv39 in RV64:\n\n当在 satp 寄存器中启用了分页时，`S 模式和 U 模式`中的`虚拟地址`会以从根部遍历页表的方式转换为物理地址。\n\n- satp.PPN 给出了一级页表的基址, VA[38:30]给出了一级页号, 因此处理器会读取位于地址(satp.PPN × 4096 + VA[38:30] × 8)的页目录项\n- 该 PTE 包含二级页表的基址, VA[29:21]给出了二级页号, 因此处理器读取位于地址(PTE.PPN × 4096 + VA[29:21] × 8)的页目录项\n- 该 PTE 包含了三级页表的基址, VA[20:12] 给出了三级页号, 处理器读取位于地址(PTE.PPN × 4096 + VA[20:12] × 8)的页目录项\n- 该页表项的 PTE. PPN 就是物理地址对应的 PPN * 4096 + offset 得到物理地址\n\nPTE 的 [0-9] 位为权限位, [10-53] 的 44 位为 PPN.\n\nsv39 上. 虚拟地址范围 39 位, 0-38 位 , 物理地址范围 56位, 0-55 位 \n\n#页表\n\n![](attachments/sv39_pte.png)\n\n# hpt_init\n\n此项为设置G-stage translation\n\n```c\nvoid hpt_init(){\n\n    for(int i = 0; i < 2048; i++){\n        hpt_root[i] = 0;\n    }\n\n    uintptr_t addr = 0x0;\n    for(int i = 0; i < 4; i++){\n        // 设置 hpt_root[0/1/2/3] 大页   addr 为 0x0 0x4000_0000 0x8000_0000 0x10000_0000 \n        hpt_root[i] = \n            PTE_V | PTE_U | PTE_AD | PTE_RWX | (addr >> 2);  \n        addr +=  SUPERPAGE_SIZE(0);\n    }\n    // 覆盖 hpt_root[2], 该页变为 页表项  指向 hpt[0][0]\n    hpt_root[MEM_BASE/SUPERPAGE_SIZE(0)] =\n        PTE_V | (((uintptr_t)&hpt[0][0]) >> 2);\n\n    addr = MEM_BASE; // (0x8000_0000)\n    for(int i = 0; i < 512; i++) hpt[0][i] = 0;\n    for(int i = 0; i < MEM_SIZE/SUPERPAGE_SIZE(1)/2; i++){   // i < 64\n        hpt[0][i] = \n            PTE_V | PTE_U | PTE_AD | PTE_RWX | (addr >> 2);  // 设置 2M的PTE 大页\n        addr +=  SUPERPAGE_SIZE(1);   //0x20_0000  //2M\n    }    \n    // 覆盖 hpt_root[4] 其变为页表项 2级页表, 指向 hpt[1][0] 3级页表\n    hpt_root[4] =\n        PTE_V | (((uintptr_t)&hpt[1][0]) >> 2);\n\n    hpt_root[2047] =\n        PTE_V | (((uintptr_t)&hpt[1][0]) >> 2);\n    \n    // hpt[1][0] 的3级页表 指向 hpt[2][0] 的pte\n    hpt[1][0] = \n        PTE_V | (((uintptr_t)&hpt[2][0]) >> 2);\n\n    hpt[1][511] = \n        PTE_V | (((uintptr_t)&hpt[2][0]) >> 2);\n\n    addr = TEST_PPAGE_BASE; //0x8800_0000 开始的物理地址\n    // 设置hpt[2][0] 到 hpt[2][511] 的PTE, 映射的物理地址从0x8800_0000 开始\n    for(int i = 0; i < TEST_PAGE_MAX; i++){\n        hpt[2][i] = (addr >> 2) | PTE_AD |\n            test_page_perm_table[i].h;  \n        addr +=  PAGE_SIZE;\n    }\n    \n    // hpt[1][1] 的3级页表 指向 hpt[3][0] 的pte\n    hpt[1][1] = \n        PTE_V | (((uintptr_t)&hpt[3][0]) >> 2);\n    addr = TEST_PPAGE_BASE; //0x8800_0000 开始的物理地址\n    // 设置hpt[3][0] 到 hpt[3][511] 的PTE, 映射的物理地址从0x8800_0000 开始\n    for(int i = 0; i < 512; i++){\n        hpt[3][i] = (addr >> 2) | \n            PTE_V | PTE_U | PTE_AD | PTE_RWX; \n        addr +=  PAGE_SIZE;\n    }  \n\n    // hpt_root[5] 为2级页表项, 指向 hpt[4][0] \n    hpt_root[5] =\n        PTE_V | (((uintptr_t)&hpt[4][0]) >> 2);\n    addr = TEST_PPAGE_BASE; // 0x8800_0000\n    // hpt[4][0] - hpt[4][511] 为 大页 PTE, 每个PTE 覆盖 2M 范围 \n    for(int i = 0; i < 512; i++){\n        hpt[4][i] = (addr >> 2) |\n             PTE_V | PTE_U | PTE_AD | PTE_RWX;  \n        addr +=  SUPERPAGE_SIZE(1); // +2M\n    }  \n\n    if(curr_priv == PRIV_HS || curr_priv == PRIV_M){\n        uintptr_t hsatp = (((uintptr_t)hpt_root) >> 12) | (0x8ULL << 60);\n        CSRW(CSR_HGATP, hsatp);\n    } else {\n        ERROR(\"trying to set hs hgatp from lower privilege\");\n    }\n}\n```\n\n\n再来看下 vs-stage的页表创建过程:\n\n```c\nvoid vspt_init(){\n\n    uintptr_t addr;\n\n    addr = 0x00000000;\n    for(int i = 0; i < 4; i++){\n        vspt[0][i] = \n            PTE_V | PTE_AD | PTE_RWX | (addr >> 2);  \n        addr +=  SUPERPAGE_SIZE(0);\n    }\n\n    vspt[0][MEM_BASE/SUPERPAGE_SIZE(0)] =   //vspt[0][2] 2级 -> vspt[1][0] 3级\n        PTE_V | (((uintptr_t)&vspt[1][0]) >> 2);\n\n    addr = MEM_BASE;\n    for(int i = 0; i < 512; i++) vspt[1][i] = 0;\n    // vspt[1][0] - vspt[1][63]  建立大页, 覆盖地址从 0x8000_0000 到 0x8000_0000 + 2M * 64 地址范围\n    for(int i = 0; i <  MEM_SIZE/SUPERPAGE_SIZE(1)/2; i++){\n        vspt[1][i] = \n           PTE_V | PTE_AD | PTE_RWX | (addr >> 2);  \n        addr +=  SUPERPAGE_SIZE(1);\n    }\n\n\t// vspt[0][4] 2级 -> vspt[2][0] 3级\n    vspt[0][4] =\n        PTE_V | (((uintptr_t)&vspt[2][0]) >> 2);\n\n    // vspt[0][5] =\n    //     PTE_V | PTE_U | PTE_AD | (((uintptr_t)&vspt[2][0]) >> 2);\n\n    // vspt[2][0] 3级页表 -> vspt[3][0] PTE\n    vspt[2][0] = \n        PTE_V | (((uintptr_t)&vspt[3][0]) >> 2);\n\n    addr = TEST_VPAGE_BASE; // 0x10000_0000   PTE \n    // vspt[3][0] -> vspt[3][511]  PTE GPA 地址范围 0x10000_0000 -- 0x10000_0000 + 2M\n    for(int i = 0; i < TEST_PAGE_MAX; i++){\n        vspt[3][i] = (addr >> 2) | PTE_AD |\n            test_page_perm_table[i].vs;  \n        addr +=  PAGE_SIZE;\n    }\n    // vspt[2][1] 3级 -> vspt[4][0]\n    vspt[2][1] = \n        PTE_V | (((uintptr_t)&vspt[4][0]) >> 2);\n\n    addr = 4 * SUPERPAGE_SIZE(0) + SUPERPAGE_SIZE(1); // 0x10000_0000 + 2M\n    // vspt[4][0] - vspt[4][511] PTE 地址范围   0x10000_0000 + 2M --  0x10000_0000 + 4M\n    for(int i = 0; i < 512; i++){\n        vspt[4][i] = (addr >> 2) | \n            PTE_V | PTE_AD | PTE_RWX; \n        addr +=  PAGE_SIZE;\n    }  \n\n    // vspt[0][5] 二级页表 -> vspt[5][0] 三级页表\n    vspt[0][5] = \n        PTE_V | (((uintptr_t)&vspt[5][0]) >> 2);\n\n    // vspt[5][0] - vspt[5][511] 为大页 PTE , 覆盖的地址范围为 0x14000_0000 - 0x14000_0000+ 2M*512\n    addr = 5 * SUPERPAGE_SIZE(0);  // 0x14000_0000   5G\n    for(int i = 0; i < 512; i++){\n        vspt[5][i] = (addr >> 2) |\n             PTE_V | PTE_AD | PTE_RWX;  \n        addr +=  SUPERPAGE_SIZE(1);\n    }  \n\n    uintptr_t satp = (((uintptr_t)vspt) >> 12) | (0x8ULL << 60);\n    if(curr_priv == PRIV_VS){\n        CSRW(satp, satp);\n    } else if(curr_priv == PRIV_HS || curr_priv == PRIV_M){\n        CSRW(CSR_VSATP, satp);\n    } else {\n        ERROR(\"\");\n    }\n}\n```\n\n\n\n\n```c\nuintptr_t addr1 = phys_page_base(SWITCH1); // 0x8800_0000 + 108 * 4k\nuintptr_t addr2 = phys_page_base(SWITCH2); // 0x8800_0000 + 109 * 4k\nuintptr_t vaddr1 = vs_page_base(SWITCH1); // 0x10000_0000 + 108 * 4k\nuintptr_t vaddr2 = vs_page_base(SWITCH2); // 0x10000_0000 + 109 * 4k\n```\n\n先看 vs-stage 的翻译, 0x10000_0000 + 108 * 4k\n首先 satp = vsatp. PPN = vspt >> 12, 对应sv39模式, \n- va[38:30] (9位) 给出了一级页号偏移为 4, 在一级页表的物理页中找到二级页表的物理页号 `vspt[0][4]`\n- va[29:21] (9位)  给出了二级页号偏移为 0,  在二级页表的物理页中找到三级页表的物理页号 `vspt[2][0]`\n- va[20:12] (9位)  给出了三级页号偏移为 108, 在三级页表的物理页中找到要访问位置的物理页号 `vspt[3][108]`\n- 物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址  \n\t`vspt[3][108].ppn << 12 + 0 (offset) = 0x10000_0000 + 108*4k + 0`\n\n所以 vs-stage 0x10000_0000 - 0x10000_0000 + 4M 的范围是直接映射的.\n\n再来看G-stage的翻译过程, GPA为 0x10000_0000 + 108 * 4k\n对应于 sv39x4, hgatp.PPN 给出了一级页表首地址\n- GPA[40:30] (11位) 给出了一级页号偏移为 4, 在一级页表的物理页中找到二级页表的物理页号 `hpt_root[4]`\n- GPA[29:21] (9位) 给出了二级页号偏移为 0,  在二级页表的物理页中找到三级页表的物理页号 `hpt[1][0]`\n- GPA[20:12] (9位) 给出了三级页号偏移为 108,  在三级页表的物理页中找到要访问位置的物理页号 `hpt[2][108]`\n- 物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址 , 对应的权限是 `test_page_perm_table[108].h=PTE_U | PTE_RWX`\n\t`hpt[2][108].ppn << 12 + 0 (offset) = 0x8800_0000 + 108*4k + 0`\n\n翻译后, addr1 与 vaddr1 正好是对应的 HPA 与 GVA的映射关系\n\n再来看下 second_stage_only_translation 的测试项:\n```c\nvs_page_base_limit(TOP) = 0x1fffffff000  \"即 0x20000_0000 前的最后一个 2M \"\n```\n\n由于vstap 写了 0, guest os 未启用分页, 所以guest os 直接访问的就是GPA\n对应于 sv39x4, hgatp.PPN 给出了一级页表首地址\n- GPA[40:30] (11位) 给出了一级页号偏移为 2047 (11个1), 在一级页表的物理页中找到二级页表的物理页号 `hpt_root[2047]`\n- GPA[29:21] (9位) 给出了二级页号偏移为 511 (9个1),  在二级页表的物理页中找到三级页表的物理页号 `hpt[1][511]`\n- GPA[20:12] (9位) 给出了三级页号偏移为 511 (9个1),  在三级页表的物理页中找到要访问位置的物理页号 `hpt[2][511]`\n- 物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址 , 对应的权限是 `test_page_perm_table[511].h=PTE_U | PTE_RWX`\n\t`hpt[2][511].ppn << 12 + 0 (offset) = 0x8800_0000 + 511*4k + 0`\n\n\n\n最后看下VS-mode下可以切换页表, 而页表都是落在原始地址范围 hpt 0x80020000 hspt 0x80032000 vspt 0x8002c000 \n先看下 vs-stage的转换 0x80020000\n\n首先 satp = vsatp. PPN = vspt >> 12, 对应sv39模式, \n- va[38:30] (9位) 给出了一级页号偏移为 2, 在一级页表的物理页中找到二级页表的物理页号 `vspt[0][2]`\n- va[29:21] (9位)  给出了二级页号偏移为 0,  在二级页表的物理页中找到三级页表的物理页号 `vspt[1][0]`, 此处为大页, 所以页目录walk 终止.\n- va[20:12] (9位) 和 va[11:10] 最终给出了页内偏移为 0x20000, 最终的GPA 地址为 \n\t`vspt[1][0].ppn << 12 << 9 + 0x20000 = 0x8000_0000 + 0x20000`\n\n同理GVA-GPA的映射关系为 0x80032000 -  0x80032000 0x8002c000 - 0x8002c000\n所以 `0x8000_0000 - 0x8000_0000+64*0x200000  (0x8800_0000)` 范围是线性映射的, GVA等同于GPA\n\n再来看G-stage的转换 0x80020000\n\n对应于 sv39x4, hgatp.PPN 给出了一级页表首地址\n- GPA[40:30] (11位) 给出了一级页号偏移为 2, 在一级页表的物理页中找到二级页表的物理页号 `hpt_root[2]`\n- GPA[29:21] (9位) 给出了二级页号偏移为 0,  在二级页表的物理页中找到三级页表的物理页号 `hpt[0][0]`, 此处为大页, 所以页目录walk 终止.\n- GPA[20:12] (9位) 和 GPA[11:10] 最终给出了页内偏移为 0x20000, 最终的HPA 地址为 \n\t`hpt[0][0].ppn << 12 << 9 + 0x20000 = 0x8000_0000 + 0x20000`\n\n同理GPA-HPA的映射关系为 0x80032000 - 0x80032000 0x8002c000 - 0x8002c000\n所以 `0x8000_0000 - 0x8000_0000+64*0x200000  (0x8800_0000)` 范围是线性映射的, GPA等同于HPA\n\n最终 VS-mode下可以切换 hs vs g-stage 的页表项, 页表项所处的地址范围 GVA 和 HPA 是线性映射的, GVA等同于 HPA.\n\n调研 qemu 和 spike 的代码, G-stage 的页表项必须带有 PTE_U 的 flag, G-stage 才能不导致 load/write exception.\n","tags":["riscv"],"categories":["虚拟化","RISCV","mmu","测试"]},{"title":"rvh h-extension 1.0 & riscv 硬件虚拟化","url":"/2023/06/11/hxd_new/riscv调研/虚拟化/rvh h-extension 1.0 & riscv 硬件虚拟化/","content":"\n# rvh h-extension 1.0\n\n![image-20240416112451638](attachments/image-20240416112451638.png)\n- sstatus 反映 Supervisor-mode(后面简称 S-mode) 下的cpu 状态, 这里仅以其 SPP(Supervisor previous previlege) 做介绍, 如第一次想从S-mode 执行到 User-mode(下简称U-mode) 下, 需要设置sstatus.SPP=U-mode (0)\n- satp (Supervisor Address Translation and Protection (satp) Register), 保存了第一级页表地址\n- sepc (Supervisor Exception Program Counter) 保存发生trap/中断 前的 pc 地址, 此处如为第一次执行该用户态应用, 则需要将其设置为用户态的入口地址\n- sret (S-mode return), 通俗来讲就是调用sret后, 硬件会设置 pc = spec, 下一条指令从sepc 的位置执行. 除此之外, sret  还会判断 sstatus.SPP 确定下一刻要将cpu 置为哪个特权模式, 此处如为第一次执行用户态应用, 需要将sstatus.SPP 置为 U-mode, 下一刻cpu会切换特权级, 从S-mode 切换到 U-mode. \n- scause S-mode 原因寄存器, 在发生异常/中断时, scause 会被硬件修改对应的位, 表明当前进入异常/中断的原因.\n\n虚拟机 os，需要完整的运行环境。\n我们考虑一个简单的linux运行需要什么环境\n- 1，通用寄存器，传参，sp，pc这些。\n- 2，CSR，比如status，cause寄存器这些，配置cpu的运行状态，或者获取cpu的运行状态等。\n- 3，内存，需要管理虚拟地址到物理地址的转换。\n- 4，trap handler，发生异常或者中断时的处理方法。\n- 5，特权等级。\n\n这些东西，通过纯软件也可以做模拟，但是效率和安全性上都会受影响，RVH ISA就是在CPU 硬件层面上给这些虚拟机OS运行环境需要的资源进行了明确的要求和定义。\n\nHS-模式的作用与S-模式相同，但有额外的指令和CSR，2-stage translation, 翻译GVA->HPA, 为guest os 提供内存和mmio的外设地址空间模拟, 常规的S模式操作系统可以在HS模式或VS模式下执行，无需修改。\n\n\n## 特权模式\n\n![image-20240416112455653](attachments/image-20240416112455653.png)\n\n\n\n\n## Hypervisor and Virtual Supervisor CSRs\n这些csr 有两类:\n- h开头的csr   供hypervisor 管理程序 vm 使用\n- vs 开头的寄存器, 给guest os 使用. 可以看作是S-mode 专属csr的备份\n 为什么需要vs* 的csr, cpu 可以切换普通的进程, 也可以在普通进程和vcpu 之间进行调度, 如果没有vs* 的csr, 那进程和vcpu的上下文就非常的混乱.\n\n在HS模式下运行的操作系统或管理程序使用s-mode CSR与异常、中断和地址转换子系统进行交互\nH-extension 定义了额外的CSR提供给HS模式，但不提供给VS模式，以管理 2-stage 地址翻译 和控制VS-mode guest os的行为：hstatus, hedeleg, hiddenleg, hvip, hip, hie, hgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta, htimedeltah, htval, htinst, and hgatp。\n\n当V=1时，VS CSRs代替了相应的s-mode的CSRs，接管了通常监督器CSRs的所有功能。S-mode CSR的指令应改为访问相应的VS CSR。当V=1时，试图通过自己的独立CSR地址直接读取或写入VS CSR会导致虚拟指令异常。VS CSRs本身只能从M模式或HS模式访问。\n\n一些标准 S-mode CSR（senvcfg、scounteren和scontext ...）没有匹配的VS CSR, 这些csr的行为在V=1 和 V=0 时都是一样的, 这意味着hypervisor 需要保存恢复这些csr的状态.\n\n### hstatus\n\n![image-20240416112459089](attachments/image-20240416112459089.png)\n\n- 当VTSR=1时，VS模式中执行SRET的尝试会引起一个虚拟指令异常。\n- 当VTW=1时（并假设mstatus.TW=0），如果WFI没有在特定的时间限制内完成，VS模式中执行WFI的尝试会引起一个虚拟指令异常。\n- 当VTVM=1时，VS模式中执行SFENCE.VMA或SINVAL.VMA或访问CSR satp的尝试会引起一个虚拟指令异常。\n\nVGEIN (Virtual Guest External Interrupt Number) 在中断直通场景下使用, 对于支持aia imsic 的中断控制器, 用于选择一个 virtual guest external interrupt file\n当VGEIN=0 时, 不选择 virtual guest external interrupt file, 表示是物理cpu的中断.\n\nHU (Hypervisor in U-mode), HU位允许管理程序的一部分在U模式下运行，以更好地保护软件错误，同时仍然保留对虚拟机的访问。\n\nHU=1, HLV, HLVX, and HSV 可以在 HS-mode 和 U mode下执行\nHU=0, 在U-mode下执行 HLV, HLVX, and HSV 会触发非法指令异常\n\nSPV  每当陷阱进入HS模式时，SPV位（进入 HS-mode 以前的模式）就会被写入。hstatus中的SPV位在陷阱时被设置为虚拟化模式V的值。如 V=0时执行SRET指令，SPV被设置为 0。\n\n\n\n### hedeleg hideleg\n\n中断代理\nmedeleg mideleg 相应位被设置后, S-mode 可以接管 部分异常/中断 \n同理 hedeleg hideleg 相应位被设置后, VS-mode 可以接管 HS-mode的部分异常/中断\n\nhideleg\n如果一个被委托给HS模式的中断（使用mideleg）被进一步委托给VS模式, 在hideleg的15:0位中，10、6和2位（对应于标准的VS级中断）是可写的，12、9、5和1位（对应于标准的S级中断）是只读零。\n\n通常  \nvirtual supervisor external interrupt (10)\nvirtual supervisor timer interrupt (6)\nvirtual supervisor software interrupt (2)\n\n对于中断注入和中断直通来说, 上述 10/6/2 bit位是必须被设置的.\nVS-mode下 guest os接收到这些中断后, 10/6/2 会被转换位 9/5/1 号中断\n> 这样是为了保持 guest os可以使用普通的kernel版本, 不需要再为guest 修改中断相关的源码\n\n一个被委托给HS模式的同步陷阱（使用medeleg）被进一步委托给VS模式，如果在陷阱之前V=1，并且相应的hedeleg位被设置。hedeleg的每一位都应是可写的或只读的零。\n\n![image-20240416112502300](attachments/image-20240416112502300.png)\n\n### hvip hip hie vsip vsie hgeip hgeie\n\n上述均为管理 guest os 相关的中断相关的csr\n\n![image-20240416112506239](attachments/image-20240416112506239.png)\n\t\t\t\t\thvip\n\nSetting VSEIP in hvip asserts a VS-level external interrupt;\nsetting VSTIP asserts a VS-level timer interrupt; \nsetting VSSIP asserts a VS-level software interrupt.\n\n![image-20240416112511051](attachments/image-20240416112511051.png)\n                        hip\n\nvsip hip hvip 之间的关系如下:\nhideleg 开启时(bit 10/6/2 不为0时)\n- vsip.SEIP = hip.VSEIP  vsip.STIP = hip.VSTIP vsip.SSIP = hip.VSSIP\n\t- VSEIP is read-only in `hip`, and is the logical-OR of these interrupt sources:\n\t\t- bit VSEIP of `hvip`;\n\t\t- bit of `hgeip` selected by `hstatus`.VGEIN\n\t\t- any other platform-specific external interrupt signal directed to VS-level.\n\t- VSTIP is read-only in `hip`, and is the logical-OR of:\n\t\t- `hvip`.VSTIP\n\t\t- any other platform-specific timer interrupt signal directed to VS-level.\n\t- VSSIP in `hip` is an alias (writable) of the same bit in `hvip`. \n\t\t- 即 vsip.SSIP = hip.VSSIP = hvip.VSSIP\n- vsie.SEIE = hie.VSEIE  vsie.STIE = hie.VSTIE vsie.SSIE = hie.SSIE\n\n真正影响guest os的是vsip , guest os 运行时处于V=1 mode, vsip被替换为sip, \n- vsip software 中断来自于hvip (来自于HS hypervisor), 或者guest os 自己.\n- vsip timer 中断来自于hvip (来自于 HS hypervisor), 或guest os 自己, 或 platform-specific timer interrupt signal directed to VS-level\n- vsip guest external 中断来自于hvip (来自于HS hypervisor), 或hstatus.VGEIN -> hgeip 或 any other platform-specific external interrupt signal directed to VS-level\n\nhgeip read-only, 由硬件置位, 在支持中断直通的中断控制器上, 由中断控制器进行置位, 代表来自于中断控制器的哪个virtual guest interrupt file. 简单来讲是表示直通的哪个vcpu收到了中断.\n\nBits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level). \nhip.SGEIP 和 hip.SGEIE 是给HS 用的, 重点看 SGEIP, 这个是hgeip & hgeie and的结果, 代表的有guest external 中断待处理.\n\n### henvcfg henvcfgh\n![image-20240416112515434](attachments/image-20240416112515434.png)\n\nFIOM (Fence of I/O implies Memory)\nFIOM=1 and V=1 时, 原子指令访问的区域排序为设备I/O，其aq和/或rl位被设置，那么该指令的排序就像它同时访问设备I/O和内存一样。\n\n![image-20240416112518813](attachments/image-20240416112518813.png)\n\nPBMTE = 1, Svpbmt extension is available for VS-stage address translation\nPBMTE=0, Svpbmt extension is not implemented for VS-stage address translation\n\nSTCE位的定义将由即将到来的Sstc扩展提供。它在henvcfg中的意义可能会在批准该扩展之前发生变化\nCBZE位的定义将由即将到来的Zicboz扩展提供。它在henvcfg中的分配可能会在批准该扩展之前发生变化。\nCBCFE和CBIE位的定义将由即将到来的Zicbom扩展提供。它们在henvcfg中的分配可能会在批准该扩展之前发生变化。\n\nRegister henvcfgh does not exist when HSXLEN=64\n\n### hcounteren\n\nHypervisor Counter-Enable Register\n控制硬件性能监测计数器对客户虚拟机的可用性\n\n![image-20240416112522067](attachments/image-20240416112522067.png)\n\nV=1时, 当 CY、TM、IR或HPMn位未设置时，试图读取cycle、time、instret或 hpmcountern寄存器会触发虚拟指令异常, 即使在 mcouteren 中对应的bit位 为1时.\n\n当这些位被设置了, VS-mode下才能读取对应的寄存器.\n在VM-mode下, 需要hcounteren 和 scounteren 的对应位都被设置才可以读取对应的寄存器\n\n### htimedelta\n\n> Hypervisor Time Delta Registers\n\n读取VS或VU模式下的time CSR，返回的是 htimedelta + time csr。\n\n### htval\n因异常进入HS-mode时，htval与stval一起被写入额外的特定异常信息，以协助软件处理陷阱。\n(htval被写入GPA, stval 被写入GVA)\n\n- 发生 guest-page-fault trap 时, htval 会被写入异常的  GPA >> 2\n- 其他异常进入的trap , htval = 0\n- 未来可能会为其他异常修改htval的行为\n\n当VS阶段的翻译未能完成时 (在第一阶段的GVA->GPA 发生异常时), 此时GPA是未知的。CSR htinst中提供了额外的信息来消除这种情况的歧义。\n\n其他情况下, 对于未对齐的地址load/store 引发的 guest page fault, htval 会被写入对应的GPA.\n对于具有可变长度指令的系统上的指令异常，非零的htval对应于指令的异常部分，如stval中的虚拟地址所示。\n\n\n### htinst\n\n因异常进入HS-mode时, htinst 被写入了触发异常的指令, 以协助软件处理trap\n\n### hgatp\n\nHypervisor Guest Address Translation and Protection Register\n\n![image-20240416112525892](attachments/image-20240416112525892.png)\n\n\n\n![image-20240416112528370](attachments/image-20240416112528370.png)\n\nMODE=Bare, VS-mode的 物理地址等于S-mode下的物理地址，除了物理内存保护外，对GPA没有进一步的内存保护。\n\n\n![image-20240416112531453](attachments/image-20240416112531453.png)\n\n2 more bits at the high end in VPN[2]\n\n> 对于实现39位虚拟地址的机器（Sv39），这使得管理程序扩展可以支持多达41位的客户物理地址空间，而不需要硬件支持48位的虚拟地址（Sv48）或回落到使用影子页表模拟更大的地址空间。\n\nVMID (guest os id) 的位数不是固定的, VMIDLEN 在64位中 最多 14位\n\n如果hgatp 发生了改变, 需要执行HFENCE.GVMA 刷新G-stage 页表\n\n### v开头的csr\nvsstatus vsip vsie vstvec vsscratch vsepc vscause vstval vsatp\n\n不过多介绍, 行为同S-mode的 s开头的csr 行为一致\n\n\n虚拟化H扩展定义了一个硬件状态位，称作V状态，可以为0或1，V状态不同，定义和访问的CSR寄存器也不同。\n\n- 当V为0时\n  - 以“s”开头的CSR寄存器表示当前操作系统的状态\n  - “h”开头的用于支持和实现虚拟化软件\n  - “vs”开头的代表运行在虚拟化技术上的系统状态。\n- 当V为1时\n  - “s”开头的寄存器指向了前文以“vs”开头的寄存器。\n\n## Hypervisor Instructions\n\n### Hypervisor Virtual-Machine Load and Store Instructions \n\n![image-20240416112535307](attachments/image-20240416112535307.png)\n\n管理程序虚拟机的加载和存储指令只在M模式或HS模式下有效，或者在hstatus.HU=1时在U模式下有效。\n每条指令都像V=1一样执行显式内存访问；\n也就是说，具有地址转换和保护，以及适用于VS模式或VU模式的内存访问的endianness。\nhstatus.SPVP控制访问的权限级别。\n\n- 当SPVP=0时，显式内存访问在VU模式下完成，\n- 而当SPVP=1时，在VS模式下完成。\n当V=1时，应用两阶段地址转换，HS sstatus.SUM被忽略。HS sstatus.MXR 使地址翻译的两个阶段（VS阶段和G阶段）都可以读到只有执行权限的page，而vsstatus.MXR只影响第一个翻译阶段（VS阶段）\n\nLB、LBU、LH、LHU、LW、LWU和LD，都有一个相应的虚拟机加载指令。\nHLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, 和HLV.D。\n对于每条RV32I或RV64I存储指令，SB、SH、SW和SD，都有一个相应的虚拟执行指令\n当然，指令HLV.WU、HLV.D和HSV.D对RV32是无效的。\n\n指令HLVX.HU HLVX.WU 与 HLV.HU和HLV.WU相同，只是在地址转换过程中，执行权限取代了读权限。\n也就是说，在地址转换的两个阶段有执行权限的页都有读权限。\n对于由地址转换产生的HS-mode的HPA，其需要具有执行和读权限.\n\n在VS-mode 或 VU-mode 下执行这些指令会触发虚拟指令异常\nhstatus.HU=0时, 在U-mode下执行这些指令会触发指令异常\n\n\n### Hypervisor Memory-Management Fence Instructions\n\n![image-20240416112538467](attachments/image-20240416112538467.png)\n\nHFENCE.VVMA和HFENCE.GVMA执行的功能与SFENCE.VMA（第4.2.1节）类似\n只是 HFENCE.VVMA 适用于由CSR vsatp 控制的VS-stage translation (GVA->GPA)\nHFENCE.GVMA 适用于 CSR hgatp 控制的 G-stage translation (GPA->HPA)。\n指令SFENCE.VMA只适用于由当前satp控制的 1-stage translation\n\n> 特殊的, 在guest os 中执行sfence.vma 适用于 vs-stage translation\n\nHFENCE.VVMA is valid only in M-mode or HS-mode\n\n执行HFENCE.VVMA保证任何已经对当前 hart 可见的先前存储在所有隐式读取之前被排序，该hart 为VS阶段地址转换所做的指令为\n- HFENCE.VVMA\n\nHFENCE.GVMA 在 M-mode下有效或\n当mstatus.TVM=0时，HFENCE.GVMA在HS模式下有效\n\n排序指令, 执行 HFENCE.GVMA 后, 先前执行的存储指令对于 排在 HFENCE.GVMA 后面的隐式内存读取指令是可见的\n\n\n## Machine-Level CSRs\n\nh-extension 引入后修改了 mstatus、mideleg、mip和mie，并增加了CSRs mtval2和mtinst。\n\n### mstatus\n\n增加了两个bit MPV GVA\n\n当因异常进入 m-mode时, mpv (Machine Previous Virtualization Mode) 被设置\nmret执行时，硬件状态位 V 被设置为 MPV，除非MPP=3，在这种情况下V仍然是0。\n\n当因异常进入 m-mode时, GVA (Guest Virtual Address) 被设置\n因这些异常 (breakpoint, address misaligned, access fault, page fault, or guest-page fault)\nmtval 被写入 guest virtual address, GVA is set to 1. \nFor any other trap into M-mode, GVA is set to 0.\n\n\n\n修改了 TVM MPRV (Modify PRiVilege)\nTVM=1时, HS-mode 不能访问hgatp, 不能执行 HFENCE.GVMA 和 HINVAL.GVMA\n\n\nMPRV=0, translation and protection behave as normal, using the translation and protection mechanisms of the current privilege mode\n\n当MPRV=1时，显式内存访问被翻译和保护，endianness被应用\n\n![image-20240416112542233](attachments/image-20240416112542233.png)\n\n\n\n### mideleg\n\nh-extension 加入后, 其10/6/2 变成了只读\n如果 guest external interrupts(GEILEN) 不为0时, 12 bit 也变成只读, 意味着这种情况下 VS-level的interrupts 总是被委托给 VS-mode\n\nmideleg 中bit位是0的, 在 hideleg hip hie的相应bit是只读的\n\n### mip mie\n\nSGEIP, VSEIP, VSTIP VSSIP in mip 等同于 hip的相应bit位\nSGEIE, VSEIE, VSTIE VSSIE in mie 等同于 hie的相应bit位\n\n### mtval2\nMachine Second Trap Value Register\n在发生异常进入 M-mode后, mtval2 被写入额外的 异常特定的信息\n\n- guest-page-fault 异常, mtval2 要么是0 要么是 GPA >> 2, 对于其他异常, 总是为0, 未来可能被扩展\n如果是因为 vs-stage 发生的 guest-page-fault, gpa是无效的, 需要借助 mtinst 进行辨别\n\n对于地址未对齐导致的 guest page fault, mtval2中的非零GPA 对应于mtval中的虚拟地址所表示的访问的page fault部分。\n对于变长地址指令, mtval2 对应于 mtval 表示的虚拟地址 page fault部分.\n\n### mtinst\n\nMachine Trap Instruction Register\n\n在发生异常进入 M-mode 后, 提供发生异常的指令信息\n\n## 2-stage translation\n\nvs-stage vsatp    GVA->GPA\nG-stage  hgatp    GPA->HPA\n\n### G-stage translation\n\nG阶段地址翻译是Sv32、Sv39、Sv48或Sv57的通常基于页面的虚拟地址翻译方案的一个变种。在每种情况下，传入地址的大小都会扩大2比特（到34、41、50或59比特）。为了适应2个额外的位，根页表（仅）被扩展了4倍，即16KiB，而不是通常的4KiB。\n\nG-stage 阶段发生 page fault 时, 触发的异常是 guest-page-fault exceptions\n所有G阶段PTE中的G位被保留用于以后进行扩展\n\nG-stage 的pte 的权限同样会被检查, 如果是因权限问题导致的page fault, 异常原因是 instruction, load, or store/AMO guest page fault\n\n### Guest-Page Faults\n\n该类异常通常会被委托给HS-mode, 需要设置medeleg 的对应bit. 如不进行委托, 则有m-mode 进行处理.\n发生异常时, mtval 或 stval 会写入发生page fault时的 GVA.\nmtval2 或 htval 会写0或GPA>>2.\nCSR mtinst或htinst 会被写入 page fault时的指令信息\n\n当一条指令获取或非对齐的内存访问跨越了一个页面边界时，会涉及两个不同的地址转换。在这种情况下发生客户页面故障时，写入mtval/stval的fault 虚拟地址与普通page fault所需的相同。因此，如果该页边界的字节在被访问的字节之间，page fault 的 虚拟地址可能是一个高于指令的原始虚拟地址的页边界地址。\n\n当发生该异常时, 是由于 VS-stage 阶段导致的, 写到 mtval2/htval的GPA 等同于 写到mtval/stval的VA 地址.\n\n### Memory-Management Fences\n\n讨论 HFENCE.VVMA 和 HFENCE.GVMA 的使用\n见前文\n\n因修改PMP 导致影响到了2-stage 页表所在的物理地址或页表所指向的物理地址的情况下\nM-mode 的软件修改了PMP的设置后, 需要同步给虚拟内存子系统\n\n对于HS-mode的软件所使用的虚拟地址, M-mode 下可以通过sfence.vma 0 0 刷新页表\n\nhfence.gvma 0 0 刷新所有的G-stage 和 VS-stage 的页表缓存\n防止错误使用了 被修改的 pmp 设置影响到的物理地址对应的 缓存的页表项 .\n\n## Traps\n\n### Trap Cause Codes\n\nH-extension加入后, cause中添加了:\n\nVS级中断（中断2、6、10）、S-mode 级guest external interrupt（中断12）、虚拟指令异常（22）和 guest page fault（20、21、23。此外，来自VS模式的 ecall 调用 被指定为10，而来自HS-mode 或S-mode的ecall 调用则像往常一样使用原因9。\n\n#cause #riscv_cause scause mcause\n\n![image-20240416112546720](attachments/image-20240416112546720.png)\n\n当V=1时，如果尝试的指令是HS legal的，但由于权限不足或由于HS-mode CSR（如scounteren或hcounteren）明确禁用该指令而被阻止执行的, 通常会触发一个虚拟指令异常（代码22），而不是非法指令异常. \n如果一条指令在HS模式下执行是有效的（对于指令寄存器操作数的某些值），假设CSR mstatus的字段TSR和TVM都是零，那么它就是HS legal 的。\n\n\n具体来说，在以下情况下触发一个虚拟指令异常:\n\n- in VS-mode, attempts to access a counter CSR when the corresponding bit in hcounteren is 0 and the same bit in mcounteren is 1;\n- in VU-mode, attempts to access a counter CSR when the corresponding bit in either hcounteren or scounteren is 0 and the same bit in mcounteren is 1;\n- in VS-mode or VU-mode, attempts to execute a hypervisor instruction (HLV, HLVX, HSV, or HFENCE);\n- in VS-mode or VU-mode, attempts to access an implemented hypervisor CSR or VS CSR when the same access (read/write) would be allowed in HS-mode, assuming mstatus.TVM=0;\n- in VU-mode, attempts to execute WFI when mstatus.TW=0, or to execute a supervisor instruction (SRET or SFENCE);\n- in VU-mode, attempts to access an implemented supervisor CSR when the same access (read/write) would be allowed in HS-mode, assuming mstatus.TVM=0;\n- in VS-mode, attempts to execute WFI when hstatus.VTW=1 and mstatus.TW=0, unless the instruction completes within an implementation-specific, bounded time;\n- in VS-mode, attempts to execute SRET when hstatus.VTSR=1;\n- in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA instruction or to access satp, when hstatus.VTVM=1.\n\n对RISC-V特权架构的其他扩展可能会增加当V=1时导致虚拟指令异常的情况集合。\n\n![image-20240416112551526](attachments/image-20240416112551526.png)\n                                       h-extension 加入后的 同步异常优先级\n     \n 如果一条指令可能引起多个同步异常，表8.7中优先级递减的顺序表明哪个异常被采取并以mcause或scause报告。\n\n### Trap Entry\n\n当陷阱发生在VS模式或VU模式时，它将进入M模式，除非由medeleg或mideleg委托，在这种情况下，它将进入HS模式，除非由hedeleg或hideleg进一步委托，在这种情况下，它将进入VS模式。\n\n未设置委托, MPV and MPP in mstatus 根据进入trap/中断 前的模式设置为对应的值\n![image-20240416112555070](attachments/image-20240416112555070.png)\n\n如果设置了委托 mideleg medeleg, trap / 中断 进 HS-mode前会将 sstatus的SPV SPP 设置为对应的值\n![image-20240416112558910](attachments/image-20240416112558910.png)\n\n当进一步设置了 hideleg hedeleg, trap/中断 进 VS-mode 前讲 vsstatus SPP 设置为对应值\nV 始终为1\n![image-20240416112602991](attachments/image-20240416112602991.png)\n\n### mtinst htinst\n\n当因为 trap 进入 M-mode 或 HS-mode时\nmtinst 或 htinst 被更新为:\n- 0\n- trap 时的 instruction\n- 自定义值 (trapping instruction 不是标准的)\n- 特定的伪指令\n\n除非需要一个伪指令值，否则写入 mtinst 或 htinst 的值可能总是零，这表明硬件在寄存器中没有为这个特定的陷阱提供任何信息 \n\n写入陷阱指令 CSR 的值有两个目的。 \n- 首先是提高陷阱处理程序中指令仿真的速度，部分是通过允许处理程序跳过从内存中加载陷阱指令，部分是通过避免一些解码和执行指令的工作。\n- 第二个目的是通过伪指令提供关于由 VS 阶段地址转换的隐式内存访问引起的 guest page fault 的额外信息。 \n\n在中断时，写入陷阱指令寄存器的值总是零。\n\n\n表8.11显示了每个标准异常原因可能被自动写入陷阱指令寄存器的值。对于阻止获取指令的例外情况，可以只写零或一个伪指令值。只有trapping 的指令是非标准的，才能自动写入一个自定义值。未来的标准或扩展可能允许其他值被写入，从先前建立的允许值集合中选择。\n\n![image-20240416112606153](attachments/image-20240416112606153.png)\n\n同步异常可以向陷阱指令寄存器写入捕获指令的标准转换，只针对由显式内存访问（来自加载、存储和AMO指令）产生的异常。目前只为这些内存访问指令定义了标准转换。\n如果一个没有定义转换的标准指令发生了同步陷阱，陷阱指令寄存器应以零写入（或者在某些情况下，以特殊的伪指令值写入）。\n\n对于一个标准的压缩指令（16位大小），转换后的指令如下:\n- 转换为32位等效指令。\n- bit 1 被替换为 0\n\n对于guest page fault，在以下情况下，陷阱指令寄存器被写入一个特殊的伪指令值。\n(a) 该故障是由VS阶段地址转换的隐式内存访问引起的，\n(b) 一个非零值（GPA）被写入mtval2或htval。\n如果这两个条件都满足，写入mtinst或htinst的值必须取自下表；不允许为零。\n\n![image-20240416112609501](attachments/image-20240416112609501.png)\n\n伪指令 0x00003020 用于硬件试图自动更新VS级页表中的位A和/或D的情况。\n所有其他用于VS阶段地址转换的隐式内存访问将被读取。\n如果硬件从未自动更新VS级页表中的位A或D（将此留给软件），那么写入伪指令的情况就不会出现。这样的页表更新实际上必须是原子性的，而不仅仅是一个简单的写\n\n### Trap Return\n\nMRET指令被用来从一个进入M模式的陷阱返回。MRET首先根据mstatus.MPP mstatus.MPV 中的值确定新的特权模式是什么，然后MRET 设置 mstatus MPV=0，MPP=0，MIE=MPIE，和MPIE=1。最后，MRET设置先前确定的特权模式，并设置pc=mepc。\n\nSRET指令用于从进入HS模式或VS模式的陷阱返回。它的行为取决于当前的虚拟化模式。\n\n当以M模式或HS模式执行时（即V=0），SRET首先根据 hstatus.SPV 和 sstatus.SPP 中的值确定新的特权模式是什么，然后SRET设置hstatus.SPV=0，在sstatus中设置SPP=0，SIE=SPIE，和SPIE=1。最后，SRET设置先前确定的特权模式，并设置pc=sepc。\n\n当以VS模式执行时（即V=1），SRET根据 vsstatus.SPP 设置特权模式，在vsstatus设置SPP=0、SIE=SPIE和SPIE=1，最后设置pc=vsepc。\n\n![image-20240416112612609](attachments/image-20240416112612609.png)\n- hstatus cpu 虚拟模式状态寄存器, 此处关注的是其 SPV位, 该位决定 sret 运行后将cpu 的V状态, V=0 还是 V=1\n- sstatus (S-mode) cpu 运行状态寄存器, 此处 host os 和 guest os 都用到了该csr, sret 返回时, 需要综合判断 hstatus.SPV 和 sstatus.SPP, 来确定下一刻cpu 从当前的HS-mode 返回到 VS-mode/HS-mode/U-mode/VU-mode\n- hgatp (Hypervisor Guest Address Translation and Protection Register), 用于G-stage 页表翻译, 需要将其设置为guest os的G-stage 的第一级页表基址\n- hideleg/hedeleg (Hypervisor Trap Delegation Registers) hypervisor 中断/异常委托寄存器, 此处只需要在第一次进入guest os 时设置\n- stvec S-mode 下中断/异常向量入口地址\n- htval hinst 用于判断导致异常时发生的异常指令. 如G-stage page fault, hinst 反映了发生异常时执行的什么指令, htval 表示发生异常时GPA的地址\n- mmio 地址触发的G-stage page fault, 一般表明是模拟外设的地址空间出现了page fault, 此类异常一般会由用户态的管理程序(qemu)进行模拟\n- sret 根据hstatus.SPV 和 sstatus.SPP 位决定返回 HS-mode/U-mode/VS-mode/VU-mode 中的哪一个.\n- scause S-mode 原因寄存器, 在发生异常/中断时, scause 会被硬件修改对应的位, 表明当前进入异常/中断的原因.\n\n## History\n| 0         | 2017/5/7   |\n| :-------- | ---------- |\n| 0.1-draft | 2017/11/10 |\n| 0.2-draft | 2018/10/15 |\n| 0.2       | 2018/12/3  |\n| 0.3       | 2019-03-06 |\n| 0.4       | 2019/6/17  |\n| 0.5       | 2019/10/30 |\n| 0.6       | 2020/2/9   |\n| 0.6.1     | 2020/5/6   |\n| 0.6.2     | 2021/7/31  |\n| 1.0.0-rc  | 2021/9/16  |\n| 1.0.0     | 2021/11/30 |\n| 1.0       | 2021/12/1  |\n\n\n\n1.0 -> now\n\n- Add FLH, FSH to defined transformed instructions for H extension \n- Clarify that henvcfg.PBMTE is read-only zero if Svpbmt is not implemented\n- 其他一些细微的修改, 如文档描述换个说法表达等\n\n0.6.1 -> 1.0 差异\n\n1.0 新增 \n- hgatp 新增 sv57x4 mode\n- henvcfg (hypervisor environment configuration)\n- 其他一些细微的修改, 如文档描述换个说法等.\n\n# riscv 硬件虚拟化\n\n## riscv qemu-kvm 框架\n\n![image-20240416112618610](attachments/image-20240416112618610.png)\n\n## arm vs riscv 硬件虚拟化\n\n![image-20240416112621851](attachments/image-20240416112621851.png)\n\n### riscv-aia\n\nriscv 体系下, 中断直通需要 支持 aia 架构的 riscv-imsic \n\nhttps://github.com/riscv/riscv-aia/\n\nriscv-imsic stable\n![image-20240416112625946](attachments/image-20240416112625946.png)\n\nriscv-imsic release\n![image-20240416112629030](attachments/image-20240416112629030.png)\n\n### riscv-iommu\n\n设备直通需要 iommu 组件, riscv 体系下, iommu 属于 non-isa 部分.\n\n> Non-ISA specifications do not add new instructions, create or change opcodes, or in any way modify the RISC-V ISA. They do help us to develop an ecosystem around the ISA Specifications.\n\nhttps://github.com/riscv-non-isa/riscv-iommu/\n\n![image-20240416112632130](attachments/image-20240416112632130.png)\n\n","tags":["riscv","硬件虚拟化"],"categories":["虚拟化","RISCV"]},{"title":"riscv iommu board 移植","url":"/2023/06/02/hxd_new/riscv调研/虚拟化/iommu/riscv-iommu移植到boston/","content":"\n问题1：\n\nboston 使用的 pcie 总线 xinlinx_pcie_root_realize 在调用 pci_bridge_initfn 后， qemu系统中查询 pci_bus 失败\n\nobject_resolve_path_type(\"\", TYPE_PCI_BUS, NULL)\n\n导致qemu 模拟的iommu 设备无法正常注册\n\nriscv_iommu_sys_realize 函数中不能找到 pci_bus，没有走 riscv_iommu_pci_setup_iommu 函数。\n\nbus->iommu_fn 为 空\n\n\n\n问题2：\n\n正常情况下 board 注册完时，会通过 notify 调用 pci_done\n\n最终， 会调用 bus->iommu_fn 函数\n\nriscv_iommu_find_as->riscv_iommu_space->memory_region_init_iommu(as->iova_mr, TYPE_RISCV_IOMMU_MEMORY_REGION)\n\naddress_space_init(&as->iova_as, MEMORY_REGION(&as->iova_mr), TYPE_RISCV_IOMMU_PCI)\n\n而 boston board 没有走这条链路。\n这个链路是 qemu guest 起来之前走的，因此与 dts 配置无关。\n\n问题 3：\n\nboston 上添加 gpex 总线\n原来的 xinlinx 总线还是会影响到 pci_bus，导致不能正常初始化 iommu 设备\n需要删除 xinlinx 总线的创建。\n\n问题 4：\n\ne1000e 网卡没有与 iommu 进行交互\n\ngpex 总线的 dts 配置中需要设置 iommu-map\n第一项代表 rid-base，对应 pcie 设备的总线号 15-8 位\n第二项表示 iommu 的 phandle\n第四项代表 length， match <rid-base:rid-base+length> 范围内的 pcie 设备\ne1000e 网卡的总线号 0000 在该范围内，系统起来后，会将 e1000e 网卡加到 iommu group 中。\n\n问题 5：\n\n复制 virt 的 pcie dts 配置后， e1000e 网卡中断不正常。\n调研后发现是 interrupt-map 配置有问题。\n\ninterrupt-map\n<child-address , child-id parent-phandle, 中断号>\n\nvirt 的中断控制器 plic 配置的 interrupt-cells 为 1, 即只有 <中断号>\n\n到了 boston 上， parent aplic_s 的 interrupt-cells 为 2，代表 <中断号，中断类型>\n所以 interrupt-map 应该配置为\n<child-address , child-id parent-phandle, 中断号，中断类型>\n第一项占位取决与 address-cells\n\n问题 6：\n\nvfio 配置，VFIO_SET_IOMMU 需要打开 allow_unsafe_interrupts 选项，否则 group 会 attach 不上 container\n\n问题 7\n\n在 close(group_fd)  或 VFIO_IOMMU_UNMAP_DMA 时会包 folio 的 panic\n原因为 unmap_dma 时会调用 riscv_iommu_iova_to_phys 接口翻译 iova->phys\n在该函数中，翻译时取页内偏移时调用了 iova & PAGE_MASK，而 PAGE_MASK 是 ~(1<<12 -1), 这个地方应该 & ~PAGE_MASK, 才是取页内偏移。由于计算物理地址有误，导致了后续的物理地址 unpin 错误。\n\n\n\n\n\n\n","tags":["riscv"],"categories":["iommu","RISCV","移植"]},{"title":"玄铁 iommu SPEC","url":"/2023/06/02/hxd_new/riscv调研/虚拟化/iommu/thead iommu/","content":"\n# SPEC\n\n## Feature\n\n`iommucap` register\n- S bit: 支持 2-stage 地址翻译\n- A bit: 支持 AIA\n- MRF: 支持 imsic 的 MRF 模式\n\n`iommucapen`  register\nE bit , E=1 时, iommu 开启.\n\n## device table walk\n\n- RSID  (Requester Source ID) 设备源ID\n- RSIDHI\n- RSIDLO\n\n## device table entry\n\ndtbase 寄存器, 保存 device table 的首地址.\n\n![](attachments/dtbase.png)\n\n- 当 rsiddiv 不为 0 时, device table 有两级\n- 当 rsiddiv 为 0 时, device table 只有一级.\n\n在 rsiddiv 不为 0 时\n第一级的 device table entry 结构如下:\n\n![](attachments/level-1-device-table-entry.png)\n第二级的 device table entry 结构如下:\n\n![](attachments/level-2-device-table-entry.png)\n在 rsiddiv 为 0 时, 只有一级 device table entry, 也如上图 (图 6) 结构所示\n\n- V 有效位, V=0, 关闭该设备的地址翻译.\n- S 控制是否开启 2-stage 地址翻译\n- F 控制是否开启 1-stage 地址翻译\n- Addr 指向 translation descriptor\n\n### device table walk 流程\n\n1 级 device table walk.\n\nWhen the `rsiddiv` is zero, the IOMMU uses only one level of device table. [012](bookxnotepro://opennote/?nb={3a1986dd-2e2c-496c-b496-3dcd019000f8}&book=47d9e37ff12e32f77f7afb8b396d27fa&page=11&x=264&y=717&id=24&uuid=44583efd21547c62f545e42fe5d110a4)\n\n![](attachments/1-stage-device-walk.png)\n\n2 级 device table walk\n\nWhen `rsiddiv` is not zero, the IOMMU uses two levels of device table [013](bookxnotepro://opennote/?nb={3a1986dd-2e2c-496c-b496-3dcd019000f8}&book=47d9e37ff12e32f77f7afb8b396d27fa&page=12&x=306&y=88&id=23&uuid=a3bbaee5591164038316fcff706a577c)\n\n![](attachments/2-stage-device-walk.png)\n\n\n## Register-based Device Table\n\n如果 device table 不是以 dtbase 实现的, 即非内存驻留的方式.\n而是 iommu 提供地址寄存器 dte[x], x< 2^RSIDLEN-1, 该方式只支持一级 device table entry.\n\n![](attachments/dte.png)\n\n- P 位为 1 时, iommu 在引起 walk fault 时暂停该次翻译, P = 0, iommu 终止该次翻译.\n- V 有效位\n- Addr 指向 Translation Descriptor\n\n## Translation Descriptor\n\n地址翻译描述符\n\n\n![](attachments/Desc.png)\n\n\n128-191 位主要作用是保留 RSID. 并对 device table walk 和 address table walk 发生 fault 时的行为进行配置\n\n![](attachments/128-191-desc.png)\n\nBit 0-1 Bit 2-3 Configuration Bits 控制 walk fault 行为\n\n![](attachments/configuration.png)\nBit 4 为 1 时, 1-stage device table walk 总是使用 Pause mode\nBit 5 为 1 时, 1-stage address table walk 总是使用 Pause mode\n如果 device table entry 的 S bit 为 0, Bit 4 Bit 5 被忽略.\n\n![](attachments/127-64-desc.png)\n\n当 desc.S2MODE != 0 时, 43-0 位为 GPA 的页号\n\nIf the S2MODE field is not zero, bits 0-63 contains the 4K-aligned physical page number of the register MMIO page for the IOMMU allocated by the hypervisor. [011](bookxnotepro://opennote/?nb={3a1986dd-2e2c-496c-b496-3dcd019000f8}&book=47d9e37ff12e32f77f7afb8b396d27fa&page=10&x=306&y=88&id=25&uuid=3ba129d9ec6654aa3575089a17a4ec74)\n\n![](attachments/1-stage-desc.png)\n\n当 desc.S2MODE = 0 时, 63-0 位为 1-stage 的控制域\n\n![](attachments/2-stage-desc.png)\n\n\n## Address Translation\n\nTranslation Descriptor 在内存中.\n\n除了进行地址转换外，IOMMU 还根据相关地址表项中的权限位向源设备授予权限。\n如果请求的访问类型没有在表项中被授予，IOMMU 就会报告一个错误情况。\n由各个设备协商并在 IOMMU 翻译表中设置适当的权限。例如，由设备驱动来配置权限.\n\nIOMMU 支持两个阶段的地址转换。两个翻译阶段都可以独立地启用和禁用。\n当第一阶段转换被启用时，操作系统通常使用它将设备分配给各个进程。\n当启用第二阶段转换时，管理程序通常使用它将设备分配给虚拟机。\n虚拟机可以进一步启用第一阶段转换，以控制设备对虚拟机内进程的分配。\n\n### 1-stage 地址翻译\n\n当 desc.S2MODE = 0 时, 进行 1-stage 地址转换. 根据 dtbase 找到 device table, 根据 RSID 找到对应的 device table entry, 根据 desc 的 63-0 的 S1PPN 找到一级页表的 pgd. 根据 63-0 的 S1MODE 模式进行地址翻译, 翻译过程同 mmu.\n\n![](attachments/1-stage-address-trans.png)\n\n### 2-stage 地址翻译\n\n当 desc.S2MODE 不为 0 时, 进行 2-stage 地址翻译.\n\n![](attachments/1-stage-desc.png)\n\n根据末级 device table entry 的 F/S 的设备确定是只进行 G-stage 翻译还是需要进行 G-stage 和 S-stage 翻译. \n\n如果只进行 G-stage (S 位为 1, F 位为 0), 则 RPAddr 为 GPA pgd. 继而根据 desc.S2MODE 进行页表翻译, 翻译过程同 mmu\n\n如果要进行 2-stage 翻译, 则以下表的流程? 没看懂, desc 在 S2MODE 打开时, 只有一个 PRAddr 地址, 这个 PRAddr 指向的是什么? #TODO\n\n![](attachments/2-stage-trans.png)\n根据对 simple code 的解读, 可以先大概看下 2-stage 地址翻译的过程:\n\n```c\n// rsiddiv 不为0 时, 为两级 device table\ndtbase = dtbase_reg;\nrsiddiv = rsiddiv_reg;\nrsid_hi = rsid >> rsiddiv;\nrsid_lo = rsid & ((1 << rsiddiv) - 1);\nlv1_dte_addr = dtbase + (rsid_hi << 3); // 保存了第一级 device table entry 的地址\nlv1_dte = memory_load8(lv1_dte_addr); \nlv2_dte_addr = lv1_dte + (rsid_lo << 3); // 保存了第二级 device table entry 的地址\nout_dte = memory_load8(lv2_dte_addr); // 第二级device_table_entry 的内容  |Addr|F|S|V|\nif (out_dte & DTE_V_BIT)  \n\t*output_addr = input_addr;\nu64 desc_addr = out_dte & ~0x7; //取出 Translation Desc\ndev_conf = memory_load8(desc_addr + 16); //desc 191-128 位 为 device configuration 配置\ns1_atp = memory_load8(desc_addr);     // desc 63-0 位为 第一级 vs-stage satp\ns2_atp = memory_load8(desc_addr + 8);  // desc 127-64 位为 第二级 G-stage hgatp\nviommu_reg_addr = memory_load8(desc_addr + 24); // ? desc 255-192位 保存 guest_dtbase GPA\nviommu_reg_addr &= ~RPADDR_MASK;\nguest_dtbase = memory_load8(viommu_reg_addr);\nguest_dtbase_phys = riscv_one_stage(s2_atp, guest_dtbase, ACC_READ, &res, &exp_addr); //通过s2_atp hgatp 将 guest_dtbase GPA -> guest_dtbase_phys HPA\nguest_rsid = (memory_load8(desc_addr + 128) & (0 xFFFFFFFFUL << 32)) >> 32; // guest_rsid 保存在 desc_addr + 128 字节的位置\n\n------------- 嵌套进行 下一级翻译 ----------------------------\ndtbase = guest_dtbase_phys[3];\nrsiddiv = guest_dtbase_phys[1];\nrsid_hi = guest_rsid >> rsiddiv;\nrsid_lo = guest_rsid & ((1 << rsiddiv) - 1);\nlv1_dte_addr = dtbase + (rsid_hi << 3);\nlv1_dte_addr_phys = riscv_one_stage(s2_atp, lv1_dte_addr, ACC_READ, &res, &exp_addr)\nlv1_dte = memory_load8(lv1_dte_addr_phys);\nlv2_dte_addr = lv1_dte + (rsid_lo<< 3);\nlv2_dte_addr_phys = riscv_one_stage (s2_atp , lv2_dte_addr , ACC_READ , &res , &exp_addr);\n// 到该级只有 1-stage, 该处末级 device table entry 的 F位为1, S位必须为0.\nout_dte = memory_load8(lv2_dte_addr_phys);\ndesc_addr = out_dte & ~0x7;\ndev_conf_phys = riscv_one_stage(s2_atp, desc_addr + 16, ACC_READ, &res, &exp_addr);\ns1_atp_phys = riscv_one_stage(s2_atp, desc_addr, ACC_READ, &res, &exp_addr);\ns1_atp = memory_load8(s1_atp_phys);\n*output_addr = riscv_two_stages(s1_atp, s2_atp, input_addr, access_type, &res, &exp_addr); // 最终才进行2-stage 地址翻译.\n```\n通过上述 simple code 的解析, 大概和上图的流程基本一致.\n为什么设计的这么麻烦, 需要两次 device table walk 的流程?\n第二次 device table walk 过程中, 所涉及的地址还全是 GPA, 需要 s2_atp 进行地址翻译到 HPA, 才能进行下一步翻译.\n\n## Fault Reporting\n支持两种模式\n- pause mode \n\t在 fault 上报之前暂停翻译, 软件处理 fault, 软件可以选择终止翻译事务还是恢复翻译事务, 如软件选择了恢复 (映射好对应的页表), iommu 硬件可以恢复该翻译事务.\n\tiommu 的具体行为取决于其在哪个阶段触发了 fault.\n\t- device table walk 过程中触发了 fault, iommu 只能终止该事务\n\t- address table walk 过程中触发了 fault, iommu 可以根据 desc 128-191 中的 Bit 0-1 2-3 4 5 bit 的配置选择恢复还是 abort 该事务.\n- abort mode 终止地址翻译并将 fault 上报给软件\n\n### 寄存器\n\n`iommuinten.E` 控制是否启用 iommu 的中断.\n\n![](attachments/iommu_iommuinten.png)\n\n同一时刻可能有多个异常产生, 对应多个进程可能发生的 fault 异常.\n\n`iommuintno` 中断号\n\n![](attachments/interrupt_number.png)\n\n如果 iommu 支持 AIA, Translation Descriptor 被扩展, 增加到 Bit 384 位宽.\n\n![](attachments/imsic_desc.png)\n\n`iommucause` 原因寄存器\n\n![](attachments/iommucause.png)\n\n![](attachments/cause.png)\n\n`ftval` 寄存器提供 fault 的地址\n\n![](attachments/ftval.png)\n\n`resume` 寄存器, pause mode 下使用\n\n![](attachments/resume.png)\n\n- T = 1 代表恢复, T=0 代表终止事务\nT=1 时, iommu 会重新开始该次翻译事务.\n\n### 中断发送\n\nIOMMU 可能设计用于两种类型的中断系统，传统 PLIC 和 AIA。\n\n当使用 PLIC 时，当支持 2-stage 时，不提供单独的中断。\n当使用 IMSIC 时, iommu 可以直接将中断分发给对应的 vcpu, 这可以直接通过写 imsic 的 setipnum 来实现.\n\n## TLB\n\n提供 `invltlb` RSID 刷新 RSID 对应设备的 tlb entry.\n\n## 排序一致性\n\nIOMMU 对于特定的 RSID 翻译事务保持顺序, 当该 RSID 的某个翻译事务触发 fault 时, 排在其后面的翻译事务只能等待, 直到该事务被终止或恢复完成. 因此需要按 RSID 来将事务缓存到 buffer 中的能力.\n\n处理该错误可能导致 IOMMU 或软件直接取消事务，在这种情况下，IOMMU 对具有相同 RSID 的所有后续事务返回错误。\n\n## IOPMP\n\nIOMMU 与 IOPMP 相互补充，对恶意设备的恶意 DMA 请求提供深度防御。\n当前 IOMMU 的设计完全控制了授予每个设备的权限。然而，当设备表的 V 位被清除时，设备获得对物理内存的直接访问。此外，IOMMU 的未来版本预计将与 PCI-Express 的地址翻译服务(ATS)一起工作。ATS 允许设备将 DMA 请求标记为“已翻译”，以便 IOMMU 简单地将请求传递给互连。这是一个潜在的安全漏洞，因为恶意设备总是可以将任何 DMA 请求标记为“已翻译”。在这种情况下，IOMMU 可以与指定给定设备允许的物理地址范围的 IOPMP 配对，即使请求被标记为已翻译，IOPMP 也能够拒绝访问。\n\n\n\n","tags":["riscv","thead"],"categories":["iommu","RISCV"]},{"title":"mips iommu","url":"/2023/06/01/hxd_new/riscv调研/虚拟化/iommu/mips iommu/","content":"\n# SPEC\n\n![](attachments/mips_iommu.png)\n\n## Device Table\n\n![](attachments/device_table.png)\n![](attachments/device_table1.png)\n\n## IOMMU Register Interface\n\n> TLB 操作时才会用到下面这些寄存器\n\n![](attachments/iommu_csr.png)\n\nIOMMU EntryLo0 and EntryLo1 Register Format\n\n![](attachments/EntryL.png)\n\nphysical frame number  (物理地址页号)  35-6 共 30bit.\n\nPFNX   PFN[39:36] stored in EntryLo0/EntryLo1 bits 35:32 \nPFN    PFN[35:12] stored in EntryLo0/EntryLo1 bits 29:6\n\n## IOMMU EntryHi Register\n![](attachments/entryhi.png)\n\nVPN  虚拟地址页号 39-13 共 27 bit\n\nVPNU  Bits 39:32 of vpn\nVPN2  Bits 31:13 of vpn\n\n## PageMask Register\n\nThe PageMask register in the IOMMU is required to define the page size of a TLB entry.\n指定 TLB entry 的 page size.\n\n![](attachments/pagem.png)\n\nMask 32:13 共 20 位\n\n掩码字段是一个位掩码，其中逻辑“1”表示虚拟地址的对应位不参与 TLB 匹配。请注意，只有有限范围的 PageMask 值是合法的(即，用“1”从低位向上填充 PageMaskMask 字段，每次两个)。最大页面大小为4 GB。\nmask 32-13   12-0 (page ) 为 0\n0x11            16k     2^2 page 不参与地址匹配\n0x1111          64k     2^4 page 不参与地址匹配\n0x111111        256k\n...             ...\n0xFFFFF         4G\n\n## IOMMU Global Configuration Register\n\nGlobal Configuration register (GCFG) \n\n![](attachments/GCFG.png)\n\n- DVNUM  一共多少个 device table entry\n- VZEN   是否启用 iommu 的虚拟化\n- IE  是否打开 iommu 的中断\n- PW  是否实现了 Page Walker, 该字段总是 0, 表明 mips iommu 不支持 page walker\n- EN 是否启用 iommui\n\n## TLB Commands\n\n- write\n\t支持 TLB 的 Index 和 Random 写。EntryLo0, EntryLol, EntryHi 和 PageMask 数据寄存器必须在写命令本身执行之前写入。\n- Read\n\tEntryLo0, EntryLol, EntryHi 和 PageMask 数据寄存器在执行 TLB 读命令时加载 TLB 表项的内容。对 EntryLo0, EntryLol, EntryHi 和 PageMask 寄存器的读取将数据返回到通用寄存器(GPRs)。\n- Probe\n\t该命令探测是否存在与 EntryHi 和 PageMask 寄存器的内容匹配的条目。\n- Invalidate\n\tExecution of the invalidate command invalidates any entry that matches EntryHi.GuestID.\n- Invalidate Flush.\n\tExecution of the invalidate flush command invalidates all entries in the IOMMU TLB. \n\n![](attachments/tlb_command.png)\n\n## IOMMU Segmentation Control Register \n\n包含  segctl0/segctl1/segctl2 寄存器\n如果 cpu 是 64 位的, 则不会用到这三个寄存器\n\nConfiguration of the memory segmentation system when the P6600 core is in 32-bit EVA mode.\n\n\n\n","tags":["mips"],"categories":["iommu","mips"]},{"title":"riscv iommu SPEC 调研","url":"/2023/06/01/hxd_new/riscv调研/虚拟化/iommu/riscv iommu 调研/","content":"\n# DMA 重映射\n\n## iommu 作用\n\n1. 安全性, 防止恶意访问\nIn the absence of an IOMMU, a device driver must program devices with Physical Addresses, which implies that DMA from a device could be used to access any memory, such as privileged memory,and cause malicious or unintended corruptions. This may be caused by hardware bugs, devicedriver bugs, or by malicious software/hardware. [013](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=12&x=298&y=177&id=1&uuid=af139cddc2dfa91d432ff922023ee850)\n\n在没有IOMMU的情况下，设备驱动程序必须用物理地址对设备进行编程，这意味着来自设备的DMA可以被用来访问任何内存，如特权内存，并造成恶意或意外的损坏。这可能是由硬件错误、设备驱动程序错误或恶意软件/硬件造成的。\n\n2. 使传统的32位外设可以访问超过4G的内存区间, 不再需要软件做 bounce buffers, 提高性能\nLegacy 32-bit devices cannot access the memory above 4 GiB. [013](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=12&x=213&y=347&id=6&uuid=7085ca7dbcdb0955f9f86c751dd5df11)\nThe integration of the IOMMU,through its address remapping capability, offers a simple mechanism for the DMA to directly accessany address in the system [013](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=12&x=298&y=363&id=5&uuid=cb87334d7d9280ed36e7baea8eda3498)\nWithout an IOMMU, the OS must resort to copying data through buffers (also known as bounce buffers) allocated in memory below 4GiB.  [013](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=12&x=298&y=394&id=7&uuid=53223096efef7883a2be4a4acbb0d501)\n\n3. The IOMMU can be useful as it permits to allocate large regions of memory without the need to becontiguous in physical memory [013](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=12&x=298&y=446&id=8&uuid=627d4c1a80c81b4c87bea2ab66234e8b)\n可以使用连续物理内存\n\n# 中断重映射\n\n## MSI 重映射\nTo handle MSIs from a device controlled by a guest OS, the hypervisor configures an IOMMU toredirect those MSIs to a guest interrupt file in an IMSIC (see Figure 3) or to a memory-residentinterrupt file. The IOMMU is responsible to use the MSI address-translation data structures suppliedby the hypervisor to perform the MSI redirection. Because every interrupt file, real or virtual,occupies a naturally aligned 4-KiB page of address space, the required address translation is from avirtual (guest) page address to a physical page address, [015](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=14&x=298&y=82&id=9&uuid=0b17ccb8398d87638846e4095e09efc7)\n\nhypervisor配置了一个IOMMU，将这些guest 的MSI (GPA) 重定向到IMSIC中的guest interrupt file (HPA)\n\n利用 iommu 重定向能力 使的 guest msi的GPA地址访问直接映射为 HPA的msi的地址访问, 从而让guest 可以直接读写物理msi mmio, 实现中断重映射能力, 中断直通给vcpu.\n>MSI 的地址重映射(GPA->HPA)是hypervisor 帮guest os做的 iommu 映射\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183736.png)\n\n# Device-Directory-Table DDT \n\nbase format dc\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183737.png)\n\nextended format dc\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183738.png)\n\n\n\n## Non-leaf DDT entry\n\nA valid (`V==1`) non-leaf DDT entry provides PPN of the next level DDT.\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183739.png)\n\n## Leaf DDT entry\n\nThe leaf DDT page is indexed by DDI[0] and holds the device-context (DC). [024](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=23&x=229&y=504&id=53&uuid=7ba2849bd5ddaccef81a871e3c0a3ca4)\nIn base-format the DC is 32-bytes. In extended-format the DC is 64-bytes. [024](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=23&x=224&y=532&id=54&uuid=db3d50652021fccf712ea95dd3407934)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183740.png)\n\n下面是base format dc DDI[0]的描述\n\n### Translation control (tc)\nTranslation control (tc) [025](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=24&x=111&y=362&id=35&uuid=11270bd854eed966f15f912906df9826)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183741.png)\n\nThe PDTV is expected to be set to 1 when DC is associated with a device that supports multiple process contexts and thus generates a valid `process_id` with its memory accesses. For PCIe, for example, if the request has a PASID then the PASID is used as the process_id. [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=298&y=278&id=55&uuid=3d6f36e6044b432bce4ea4b8df3cea4f)\n\ntc.PDTV = 0 时, fsc 为 iostap/iovstap, 即1-stage 映射基址\ntc.PDTV = 1 时, fsc 为 pdtp (associated with a device that supports multiple process contexts)\n\n### iohgatp\nIO hypervisor guest address translation and protection (iohgatp) [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=218&y=325&id=40&uuid=b4e258c3044072478995760419d0c2a1)\n\nThe iohgatp field holds the PPN of the root G-stage page table and a virtual machine identified by aguest soft-context ID (GSCID) [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=298&y=357&id=56&uuid=4a5486db71a78a099289c771e351df76)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183742.png)\n\nThe root page table as determined by iohgatp.PPN is 16 KiB and must be aligned to a 16-KiBboundary. If the root page table is not aligned to 16 KiB as required, then all entries in that G-stageroot page table appear to an IOMMU as UNSPECIFIED and any address an IOMMU may compute anduse for accessing an entry in the root page table is also UNSPECIFIED. [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=298&y=568&id=59&uuid=f9a5bc9d49ee4811ca489fe36e5ef904)\n\n#### iohgatp.mode\n\nThe G-stage page table format and MODE encoding follow the format defined by the privileged specification. [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=298&y=448&id=58&uuid=5737ea7c19b31b7a3fa346f469aedf19)\nmode-> Bare or 同hgatp的mode\n\n### fsc\nFirst-Stage context (fsc) [027](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=26&x=112&y=717&id=41&uuid=21aa8c530120e1737aefeaf591d431c8)\n\n>**tc.PDTV = 0 & iohgatp.mode = Bare 该域表示 iosatp**;\n **tc.PDTV = 0 & iohgatp.mode != Bare 该域表示 iovstatp**\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183743.png)\n格式同satp\n\n>**tc.PDTV = 1 该域表示 PDTP**\n\nWhen PDTV is 1, the fsc field holds the process-directory table pointer (pdtp). [028](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=27&x=251&y=181&id=51&uuid=7a371630148259d6069a1d2efc4bfbab)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183744.png)\nWhen the device supports multiple process contexts, selected by the process_id, the PDT is used to determine the S/VS-stage page table and associated PSCID for virtual address translation and protection. [028](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=27&x=298&y=195&id=57&uuid=704bd79779680091579e9e3c6227014e)\n\nThe pdtp field holds the PPN of the root PDT and the MODE field that determines the number of levels of the PDT.\n\nPDT 和 PSCID 结合找出对应的页表基址\n\n#### pdtp.mode\n\n^a5d0fe\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183745.png)\n\n### ta\nTranslation attributes (ta) [028](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=27&x=118&y=744&id=42&uuid=69925e087e34fd9d49941888189aaae0)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183746.png)\nThe PSCID field of ta provides the process soft-context ID that identifies the address-space of the process. PSCID facilitates address-translation fences on a per-address-space basis. \nThe PSCID field in ta is used as the address-space ID if PDTV is 0 and the iosatp/iovsatp MODE field is not Bare. [029](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=28&x=298&y=153&id=60&uuid=772809c34a1f0026e8ce14d094285f26)\n\n>tc.pdtv = 0 & iosatp/iovsatp.mode != Bare 时, ta.PSCID 表示ASID\n\n# PDT Process-Directory-Table\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183747.png)\n\n## Non-leaf PDT entry\nV == 1 表示为 非leaf 节点\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183748.png)\n\n## Leaf PDT entry\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183749.png)\n\n### First-Stage context (fsc)\n\nFirst-Stage context (fsc) [031](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=30&x=112&y=752&id=63&uuid=7d965a06f3bf7cd3e281ab8e08d7e2e3)\n\nThe software assigned `process soft-context ID` (PSCID) is used as the address space ID (ASID) for the process identified by the S/VS-stage page table. [032](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=31&x=298&y=249&id=68&uuid=aa9391510e6dd4e75e3f5a425caf669f)\n\npdtv = 1\nThe pdtp field holds the PPN of the root PDT and the MODE field that determines the number of levels of the PDT.\n![](#^a5d0fe)\npdtp.mode 确定了使用几级页表\n\n### Translation attributes (ta)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183750.png)\n\nPC is valid if the V bit is 1; If it is 0, all other bits in PC are don’t care and may be freely used bysoftware. [031](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=30&x=298&y=565&id=62&uuid=8b0610aa049b3004ff28d0917527516f)\n\n# MSI page table\n\nMSI page table pointer (msiptp) [029](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=28&x=130&y=200&id=105&uuid=03f5cad350609a341380c49e729e6cb8)\nDC.msiptp\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183751.png)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183752.png)\nAn MSI page table is a flat array of MSI page table entries (MSI PTEs) [032](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=31&x=220&y=549&id=69&uuid=9a4fc4e2f36c0300997e256728877a8a)\nMsi page table 只有一级页表\n\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183753.png)\n\n地址A匹配\n\na write to guest physical address A is recognized as an MSI to a virtual interrupt file [029](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=28&x=298&y=620&id=32&uuid=00e659c32fc0f1a22189406e7f71792b)\n`(A >> 12) & ~msi_addr_mask = (msi_addr_pattern & ~msi_addr_mask)`\n认为是msi 地址\n\nEach MSI PTE may specify either the address of a real guest interruptfile that substitutes for the targeted virtual interrupt file (下图1), or a memory-residentinterrupt file in which to store incoming MSIs for the virtual interrupt file(下图2) . [032](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=31&x=298&y=659&id=70&uuid=a82fb67ece64d14370ac7f97b5777121)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183736.png)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183754.png)\n\n## MSI PTE write-through mode\n> also called msipte\n\nIf V = 1 and the custom-use bit C = 0, then bit 2 of the first doubleword is field W (Write-through). If W = 1, the MSI PTE specifies write-through mode for incoming MSIs, and if W = 0, it specifies MRIFmode. [033](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=32&x=298&y=248&id=71&uuid=9bf03715220c7a2a1fcdaec41cfe054f)\n\nWhen an MSI PTE has fields V = 1, C = 0, and W = 1 (write-through mode), the PTE’s complete\nformat is:\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183755.png)\nAn MSI PTE in write-through mode allows a hypervisor to route an MSI intended for a virtual interrupt file to go instead to a guest interrupt file of a real IMSIC in the machine. [033](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=32&x=298&y=700&id=75&uuid=7a8d5116f15fdf42e5242d02b1605a9d)\n\n# Memory-Mapped Register\n所有的寄存器在下面的这个表格中\nTable 10. IOMMU Memory-mapped register layout [065](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=64&x=165&y=111&id=82&uuid=fbc89b081b25dc0c41dc5a0339ec85ef)\n\n其中比较重要的有ddtp\n\n## ddtp\nDevice-directory-table pointer (ddtp) [069](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=68&x=249&y=339&id=79&uuid=66add32406226e7cc5fe776658d9d8dc)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183756.png)\n\niommu_mode\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183757.png)\n\n## IOMMU capabilities\nIOMMU capabilities (capabilities) [066](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=65&x=237&y=377&id=83&uuid=5bec8e3489b06b26574198e309ef753c)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183758.png)\n\n# 翻译过程\n\n## Process to translate an IOVA\nProcess to translate an IOVA [038](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=37&x=212&y=433&id=89&uuid=a470690869760fbc6a625a0aa1935812)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183759.png)\n\n整个翻译过程还是比较复杂的, 需要根据多个字段判断是DC/PC/MSI table\n最终将pte确定后, 根据iohgatp.mode 确定是2-stage 还是1-stage 的SPA/GPA翻译.\n\n> 用device_id 来确定DDT的叶子节点DDTE 是必须的, 无论最终是 locate DC/PC/MSI, 都需要DDTE的解读.\n\n## Process to translate addresses of MSIs\nProcess to translate addresses of MSIs [043](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=42&x=210&y=208&id=106&uuid=16afb37bff89b251cd7b28987a79a19f)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183800.png)\n> 1. 省略了MRIF 模式, 这部分比较复杂, 一般也用不到, 等用到的时候再另行分析\n> 2. 非MRIF模式, 即msipte.W=1时, 提取的IMSIC的interrupt file 的index no为 extract(iova>>12, DC.msi_addr_mask)\n> \t◦ x = a b c d e f g h\n      ◦ y = 1 0 1 0 0 1 1 0\n      ◦ r = acfg\n>3. 最终配置的地址为 msipte.PPN << 12 | iova[11:0], 其中 msipte = DC.msiptp.PPN << 12 | interrupt_file_no * 16;\n\n## Process to locate the Device-context\nProcess to locate the Device-context [040](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=39&x=203&y=649&id=108&uuid=32f59050090fb6934fa634aae1ab8e5f)\nuse device_id, 该流程是和前面的 translate iova 结合来看的\n\nThe device context is located using the hardware provided unique device_id. The supported device_id width may be up to 24-bit.  [019](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=18&x=307&y=646&id=109&uuid=ef6a81a347ef868b8f10abfff041425e)\n\n- capabilities.MSI_FLAT == 0\n\tDDI[0] -> device_id[6:0]\n\tDDI[1] -> device_id[15:7]  \n\tDDI[2] -> device_id[23:16]\n- capabilities.MSI_FLAT == 1\n\tDDI[0] -> device_id[5:0]\n\tDDI[1] -> device_id[14:6]  \n\tDDI[2] -> device_id[23:15]\n\n如capabilities.MSI_FLAT == 0 时, base dc walk 图\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183737.png)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183801.png)\n\n## Process to locate the Process-context\nProcess to locate the Process-context [042](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=41&x=206&y=113&id=110&uuid=c979d9d5f81054e2dc06a52fe1bf09c1)\nuse process_id\nThe hardware identities associated with transaction - the device_id and if applicable the process_id. The IOMMU uses the hardware identities to retrieve the context information to perform the requested address translations [017](bookxnotepro://opennote/?nb={099a166b-225a-49cb-8e24-c62470e81426}&book=dcd586fe959468291e63d9bc2d652fe7&page=16&x=316&y=630&id=111&uuid=58d25899b608185269bbfb61da057465)\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183747.png)\n\nprocess_id 是20 bit, 由pdtp.MODE 确定几级页表\n![](#^a5d0fe)\nPDI[0] = process_id[7:0]\nPDI[1] = process_id[16:8]\nPDI[2] = process_id[19:17]\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183802.png)\n\n# Queue Interface\n\n1. A command-queue (CQ) used by software to queue commands to the IOMMU.\n2. A fault/event queue (FQ) used by IOMMU to bring faults and events to software attention.\n3. A page-request queue (PQ) used by IOMMU to report “Page Request” messages received from\nPCIe devices. This queue is supported if the IOMMU supports PCIe defined Page Request\nInterface\n\n## CQ\ncmdq\n\nThe PPN of the base of this in-memory queue and the size of the queue is configured into a\nmemory-mapped register called command-queue base (cqb).\n\nThe tail of the command-queue resides in a software controlled read/write memory-mapped\nregister called command-queue tail (cqt).\n\nThe head of the command-queue resides in a read-only memory-mapped IOMMU controlled\nregister called command-queue head (cqh)\n\nIf cqh == cqt, the command-queue is empty. \nIf cqt == (cqh - 1) the command-queue is full.\n\n### IOMMU Page-Table cache invalidation commands\n\nIOTINVAL.VMA ensures that previous stores made to the S/VS-stage page tables by the harts are\nobserved by the IOMMU before all subsequent implicit reads from IOMMU to the corresponding\nS/VS-stage page tables.\n\nIOTINVAL.GVMA ensures that previous stores made to the G-stage page tables are observed before all\nsubsequent implicit reads from IOMMU to the corresponding G-stage page tables. Setting PSCV to 1\nwith IOTINVAL.GVMA is illegal.\n\n### IOMMU Command-queue Fence commands\n\nA IOFENCE.C command guarantees that all previous commands fetched from the CQ have been\ncompleted and committed\n\n## FQ\n\nfaultq\n\nFault/Event queue is an in-memory queue data structure used to report events and faults raised\nwhen processing transactions.\n\nThe PPN of the base of this in-memory queue and the size of the queue is configured into a\nmemory-mapped register called fault-queue base (fqb).\n\nThe tail of the fault-queue resides in a IOMMU controlled read-only memory-mapped register called\nfqt. \n\nThe fqh is an index into the next fault record that SW should process next.\n\n![](attachments/FQ_record.png)\nCAUSE:\n\n![](attachments/cause-1.png)\n![](attachments/cause1.png)\n\n## PQ\npriq or  Page-Request-Queue\n\nPage-request queue is an in-memory queue data structure used to report PCIe ATS “Page Request”\nand \"Stop Marker\" messages to software. \n\nThe base PPN of this in-memory queue and the size of the queue is configured into a memory-mapped register called page-request queue base (pqb).\n\nThe tail of the queue resides in a IOMMU controlled read-only memory-mapped register called pqt.\n\nThe head of the queue resides in a software controlled read/write memory-mapped register called\npqh.\n\nIf pqh == pqt, the page-request queue is empty.\nIf pqt == (pqh - 1) the page-request queue is full.\n\n# PCIe 相关\n\nATS & PRI\nAddress Translate Service\nPage Request Interface\n\nPCIe 设备可以发出缺页请求，iommu硬件在解析到缺页请求后可以直接将缺页请求写入 PRI queue (PQ), 软件在建立好页表后，可以通过CMD queue 发送 PRI response 给 PCIe 设备。具体的 ATS 和 PRI 的实现是硬件相关的\n软件控制 DMA 发起后，设备先发起 ATC 请求，从 IOMMU 请求该 va 对应的 pa，如果 IOMMU 里已经有 va 到 pa 的映射，那么设备可以得到 pa，然后设备再用 pa 发起一次内存访问，该访问将直接访问对应 pa 地址，不在 IOMMU 做地址翻译;\n如果 IOMMU 没有 va 到 pa 的映射, 那么设备得到这个消息后会继续向 IOMMU 发 PRI 请求，设备得到从 IOMMU 来的 PRI response 后发送内存访问请求，该请求就可以在 IOMMU 中翻译得到 pa, 最终访问到物理内存。\n\n从上述链路的角度看, 设备端相当于做了tlb的事情.\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221221183803.png)\nATS机制想要解决的问题（优势)：\n\n1. 能够分担主机（CPU）侧的查表压力，特别是大带宽、大拓扑下的IO数据流，CPU侧的IOMMU的查表将会成为性能瓶颈，而ATS机制正好可以提供将这些查表压力卸载到不同的设备中，对整个系统实现“who consume it， who pay for it”。\n2. 决定查表性能的好坏的一个最为关键的点是TLB的预测。而像传统PCIe IO数据流，在CPU侧集中式做IOMMU的查表，对于其TLB的预测（prefetch）是很困难，极为不友好的。因为很多不同workload的IO流汇聚到一点，对于TLB的预测的冲击很大，流之间的干扰很大，很难做出准确的预测，从而TLB的命中率始终做不到太高，从而影响IO性能。而ATS的机制恰好提供了一个TLB的预测卸载到源头去的机制，让用户（设备）自己根据自己自身的业务流来设计自己的预测策略，而且用户彼此之间的预测模型不会受到彼此的影响，从而大大提高了用户自己的预测的准确性。抽象来看，这时候的设备更像是CPU核，直接根据自身跑的workload来预测本地的TLB，从而提升预测性能，进而提升整系统的预测性能。\n","tags":["riscv"],"categories":["iommu","RISCV"]},{"title":"riscv-ras-eri","url":"/2023/05/13/hxd_new/riscv调研/ras 调研/riscv-ras-eri/","content":"\nRERI 规范在 SoC 中增加了 RAS 功能，通过内存映射寄存器接口提供错误报告的标准机制，提供记录检测到的错误(包括其严重性、性质和位置)的功能，并配置了向 RAS 处理程序组件发送错误信号的方法。\nRAS 处理程序可以使用此信息来确定合适的恢复操作，这些操作可能包括\n- 终止(例如，终止一个进程等)\n- 重新启动部分或全部系统等，以便从错误中恢复。\n- 此外，该规范应支持软件发起的 RAS 处理程序的错误记录、报告和测试。\n- 最后，该规范应提供实现错误处理的最大灵活性，并应与其他标准(如 PCIe、CXL 等)定义的 RAS 框架共存。\n\n错误级别\n- CE Corrected error.\n- UDE Uncorrected deferred error.\n- UUE Uncorrected urgent error.\n\n# 寄存器\n\n![](ras%20调研/attachments/riscv-ras-eri.png)\n\n比较重要的 csr:\n\n- Address register (addr_i) \n\tThe addr_i WARL register reports the address associated with the detected error\n- Information register (info_i)\n\tThe info_i WARL register provides additional information about the error when status_i.iv is 1\n- Status register (status_i)\n\tThe status_i is a read-write WARL register that reports errors detected by the hardware unit \n\t![](ras%20调研/attachments/riscv-ras-eri-1.png)\n- Error bank information (bank_info)\n\t![](ras%20调研/attachments/riscv-ras-eri-2.png)\n\tinst_id 字段标识组件的一个包或至少一个芯片内的唯一实例;在整个系统中最好是独一无二的。系统的供应商将 inst_id 定义为组件的唯一标识符。返回值为0表示该字段未实现。\n\tn_err_recs 字段表示错误记录的数量。\n- Control register (control_i)\n\tcontrol_i 是一个读/写 WARL 寄存器，用于控制错误库中相应错误记录的错误报告。\n\tThe ces, udes, and uues are WARL fields used to enable signaling of CE, UDE, and UUE respectively When they are logged\n    \n","tags":["ras"],"categories":["RAS","RISCV"]},{"title":"arm ras 方案调研","url":"/2023/05/12/hxd_new/riscv调研/ras 调研/arm ras 方案调研/","content":"\n华为 hisi 1620\n\n\n# APEI \n\nUEFI\nACPI Platform Error Interfaces\n\n> Provides a standard way to convey error info From Firmware to OS\n\n![](attachments/apei.png)\n\n\n## BERT\n\nBoot Error Record Table\nRecord fatal errors, then report it in the second boot\n记录启动过程中的关键错误信息, 在下一次启动时报告错误.\n\n- 在 OS 未接管平台的控制权限之前 firmware（如 BIOS 或者 UEFI）检测到错误，导致系统无法继续启动，可以通过 BIOS/FIRMWARE 将这种类型的错误写入到特定的存储位置。这样一来，在下一次的正常启动过程中，OS 可以通过特定的方法将之前保存的错误读取出来分析并处理。\n- 当**系统运行过程**中 firmware 检测到了**致命错误**，以至于 **firmware 决定不通知 OS 而是直接重启**（如 CPU 风扇突然坏了，瞬间过热，如果不立刻重启会烧毁 CPU），**在重启前 firmware 可以记录下相关的错误信息以便之后分析出错原因**。\n\n> 注：**只有 BIOS/FIRMWARE 才有能力对 BERT 执行写入操作**；对于 OS 而言，BERT 仅仅是一个**只读的表**。BERT 出现的意义在于希望采用**一种统一的接口**来记录特定类型的硬件错误（主要是一些致命的），从而简化 BIOS/FIRMWARE 和 OS 的实现。\n\n\n![](attachments/BERT.png)\n\n```erlang\n-+ ApeiEntryPoint(ImageHandle, SystemTable)\n \\ -|+ if SetupData.EnRasSupport\n\t\t\t \"通过协议的 GUID 查找对应的协议, 查找acpi 表格协议\"\n     \\ -+ gBS->LocateProtocol(&gEfiAcpiTableProtocolGuid, NULL, &mAcpiTableProtocol); \n\t\t     \"查找 ACPI 标准数据表协议, 操作系统和驱动程序可以获取系统硬件配置信息，进行系统初始化和配置，以及支持电源管理等功能。\"\n     | -+ gBS->LocateProtocol(&gEfiAcpiSdtProtocolGuid, NULL, &mAcpiSdtProtocol); \n     | -+ gBS->AllocatePool (EfiReservedMemoryType, sizeof (APEI_TRUSTED_FIRMWARE_STRUCTURE), (VOID**)&mApeiTrustedfirmwareData) \"分配内存池\"\n     | -  gBS->SetMem (mApeiTrustedfirmwareData, sizeof (APEI_TRUSTED_FIRMWARE_STRUCTURE), 0)); \"memset 0\"\n     | -+ OemInitBertTable (ImageHandle);\n        \\ -  BERT_CONTEXT Context;\n        | -+ BertHeaderCreator (&Context, BOOT_ERROR_REGION_SIZE); \"Bert 表分配内存\"\n           \\ -  Context->BertHeader = AllocateZeroPool (sizeof (EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER));\n           | -  Context->Block = AllocateReservedZeroPool (ErrorBlockSize);\n\t\t           \"构造header 包含上图的 OEMID OEM_table_id creator_id等如 EFI_ACPI_ARM_OEM_REVISION EFI_ACPI_ARM_CREATOR_ID\"\n           | -  *Context->BertHeader = (EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER) {  \n\t\t           ARM_ACPI_HEADER(\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_SIGNATURE,\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER,\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_REVISION\n\t\t\t\t      ),\n           | -  ErrorBlockInitial (Context.Block, EFI_ACPI_6_2_ERROR_SEVERITY_NONE);\n           | -+ BertSetAcpiTable (&Context); \"初始化 Bert Table\"\n\t\t           \"ACPI 表格是存储着系统硬件配置信息和固件与操作系统通信信息的数据结构。在 UEFI 中，\n\t\t\t           有时需要向 UEFI 固件中添加自定义的 ACPI 表格，\n\t\t\t           以便在操作系统启动时提供特定的系统配置信息，或支持特定的硬件功能\"\n              \\ -+ mAcpiTableProtocol->InstallAcpiTable (    \"通过Acpi 表格协议安装 Bert 表\"\n                                 mAcpiTableProtocol,\n                                 Bert,\n                                 Bert->Header.Length,\n                                 &AcpiTableHandle);     \n```\n\n## linux driver\n\n> `drivers/acpi/apei/bert.c`\n\n```erlang\n-+ bert_init\n \\ -+ acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab); \"获取bert table\"\n | -  region_len = bert_tab->region_length; \"获取 bert_table length\"\n | -  apei_resources_init(&bert_resources); \"初始化 apei_resources 结构体\"\n       \"向bert_resources 下添加IOMEM 类型的资源，以便在发生错误时能够正确地处理这些资源。 \"\n | -  apei_resources_add(&bert_resources, bert_tab->address, region_len, true); \n | -+ apei_resources_request(&bert_resources, \"APEI BERT\");\n | -+ boot_error_region = ioremap_cache(bert_tab->address, region_len);\n | -|+ if boot_error_region\n     \\ -+ bert_print_all(boot_error_region, region_len);\n        \\ - \"Error records from previous boot\"\n        | -+ cper_estatus_print(KERN_INFO HW_ERR, estatus);\n           \\ -  \" %s event severity: %s\", severity \"打印log错误级别\"\n           | -+ foreach section\n\t          \\ -+ cper_estatus_print_section(newpfx, gdata, sec_no)\n\t             \\ -  severity = gdata->error_severity;\n\t             | -  printk(\"%s\"\"Error %d, type: %s\\n\", pfx, sec_no, cper_severity_str(severity));\n\t             | -  printk(\"%s\"\"fru_id: %pUl\\n\", pfx, gdata->fru_id);   \"fru_id fru_text等, 见上图的表结构\"\n\t             | -  printk(\"%s\"\"fru_text: %.20s\\n\", pfx, gdata->fru_text);\n\t\t                ...\n```\n\n## ERST\n\nError Record Serialization Table\nProvides details necessary to communicate with on-board persistent storage for error recording\n\n提供必要的详细信息, 协同存储错误记录\n\nERST 本质上是一个用来**永久存储错误的抽象接口**。**软件可以通过 ERST 表**将各种错误信息保存到 ERST 中，再由 ERST 写入到可用于永久存储的物理介质中。ERST 并没有一个严格的定义来界定什么是“错误”，换言之，软件可以保存任何信息到 ERST 中，只要软件认为是有意义，有价值的信息就可以.\n物理介质未必一定是 flash 或 NVRAM，可以是网络存储或者其他。\n\nERST 的主要作用就是用来存储各种硬件或者平台相关的错误，错误类型包括:\n- Corrected Error（CE）\n- Uncorrected Recoverable Error（UCR) \n- Uncorrected Non-Recoverable Error，或者说 Fatal Error。\n\n换言之，只要是软件可以记录的错误，都可以将其保存到 ERST 当中。加上之前谈到的 BERT 表，这样一来，无论系统运行在哪个阶段，当出现硬件或平台相关的错误时，通过 APEI 接口，都有办法将错误保存下来。这样一来就可以在之后通过适当的方法将错误读取出来进行分析，从而加快定位产生错误的原因并加以解决。\n\n\n![](attachments/ERST.png)\n\n## EINJ\n\nError Injection Table\nProvides a generic Interface which OSPM can inject hardware Errors to the platform without requiring platform Specific software.\n\n提供通用接口方便 os 向硬件注入错误.\n\n![](attachments/EINJ.png)\n\n## GHES of HEST\n\nGeneric Hardware Error Source - GHES\nHardware Error Source Table   - HEST\n\nHOW to get trigger: Notification Structure\nWHERE are the error records:\n\nError Status Address\n(GAS : Generic Address Structure)\n\nHOW to release records’ mem:\nRead Ack Register\n\n在 HEST 中定义了很多硬件相关的错误源和错误类型。定义这些硬件错误源的目的**在于标准化软硬件错误接口的实现**。有了 HEST，当发生特定类型的硬件错误，如 PCI-E 设备产生了一个 Uncorrected Recoverable 类型的错误时，BIOS/FIRMWARE 有统一的方法更新特定的寄存器和内部状态，软件有统一的方法去处理和解析错误。HEST 中定义了很多硬件错误源，如 MCE、PCI-E、GHES 等等。\n\n其中最为特殊也是最为重要的硬件错误源类型就是 GHES (Generic Hardware Error Source)。GHES 是一个**通用硬件错误源**，换言之，任何类型的硬件错误都可以使用 GHES 来定义，而无需使用之前提到的特定硬件错误源，如内存控制器错误等。\n\n当前无论是软件还是 BIOS/FIRMWARE 的实现，基本上都是只使用 **GHES 来实现 HEST 的功能**，至于其他特定的硬件错误源，基本上都没有使用（PCI-E AER 的部分代码检测了 PCI-E 类型的硬件错误源）。\n\n在 FFM (Firmware-First handling) 使能的情况下，一般而言，所有 CE 类型的错误通过 SCI 中断报告给 OS，然后 OS 在 HEST/GHES 中查表，检测并处理可能的硬件错误；所有 UC 和 Fatal 类型的错误通过 NMI 报告给 OS，然后 OS 在 NMI 的 handler 中查表，检测并处理可能的硬件错误。这些规定并不是硬性要求的，平台设计者完全可以根据需要使用 NMI 来处理所有的错误类型，包括 CE, UC 和 Fatal 类型的错误，也可以只使用 NMI 来处理 UC 和 Fatal 类型的错误，而使用轮询的方式来处理 CE 类型的错误。\n\n![](attachments/HEST.png)\n\n### linux kernel ghes 处理\n\nGhes_probe 函数中，根据 HEST 表中传递的检测错误类型，查看相关 kernel 配置选项是否支持。包括 arm 相关的 SEA 错误，NMI，本地中断。\n调用 ghes_new 函数，初始化 struct ghes 结构。初始化 ghes 结构，映射表中 Error Status Address。为存放错误信息数据申请内存。\n\n根据上报错误方式，注册不同的处理流程，包括如下：\n（1）轮询方式，根据表中传递的 poll_interval 时间，创建定时器。在定时器处理函数 ghes_poll_func 中，调用 ghes_proc。在这个函数中：\n\t\tA、读取 GHES 结构中传递的 Error Status Address。首先将读到的 struct acpi_hest_generic_status 结构拷贝到前面申请的内存中，检测相关错误信息长度是否合法。然后将后面的错误信息拷贝。\n\t\tB、如上报错误的严重级别大于 GHES_SEV_PANIC，则将错误信息打印，清除错误状态以及记录错误信息的内存块。然后进入 kernel panic。\n\t\tC、调用 ghes_do_proc 函数处理错误。这个函数中，获取错误数据块中各 section 中 section_type 以及 error_severity。同时判断 fru_id 和 fru_text 字段是否有效。 1>如为内存相关错误，以下为错误类型分类\n\t* @ `HW_EVENT_ERR_CORRECTED`: Corrected Error - 表示检测到 ECC 纠正的错误\n\t* @ `HW_EVENT_ERR_UNCORRECTED` : 表示 ECC 无法纠正的错误，但不是致命的错误 (可能是在未使用的内存区域，或者内存控制器可以从中恢复，例如，通过重新尝试操作)\n\t* @ `HW_EVENT_ERR_DEFERRED`:  Deferred Error - 表示处理不紧急的不可纠正的错误。这可能是由于硬件数据中毒，系统可以继续操作，直到中毒的数据被消耗。也可以采取主动的措施，例如，offlining 页面等。\n\t* @ `HW_EVENT_ERR_FATAL`: 致命错误-无法恢复的不可更正错误。\n\t* @ `HW_EVENT_ERR_INFO`: 规范定义了第四种类型的错误: 信息日志。\n   首先获取 struct cper_sec_mem_err 数据块。调用\n\t`Ghes_edac_report_mem_error` 函数，这个函数中，将错误信息中包括错误类型，错误地址，内存颗粒，错误内存位置填充到错误报告 buffer 中（struct edac_raw_error_desc）。\n\t错误类型如下:\n\t![](attachments/edac_error.png)\n\t把错误写到 ftrace 的一个跟踪项中，最后调用 `edac_raw_mc_handle_error`\n\t分别通过 `edac_ce_error` 处理 ECC 类型的错误以及调用 `edac_ue_error` 处理其他错误。 \n\t最后调用 `ghes_handle_memory_failure`，\n\t如果\n\t- 错误级别为可修复级别且 `CPER_SEC_ERROR_THRESHOLD_EXCEEDED` 置位（表示内核中止使用这个资源）\n\t- 错误是可恢复的类型。满足上述条件之一则调用 `memory_failure_queue` 函数。这个函数在检测到页面的硬件内存损坏时由硬件错误处理程序调用。它调度错误页面的恢复，包括删除页面，杀死进程等。\n\n   **如为 pcie aer 错误**\n   PCIe AER 错误需要发送到 AER 驱动程序进行报告和恢复。GHES 的严重程度与以下 AER 严重程度相对应，并需要进行以下处理:\n    - GHES_SEV_CORRECTABLE -> AER_CORRECTABLE  --- 需要由 AER 驱动报告，但不需要恢复。\n    - GHES_SEV_RECOVERABLE -> AER_NONFATAL\n    - GHES_SEV_RECOVERABLE && CPER_SEC_RESET -> AER_FATAL\n   这两种情况都需要 AER 驱动报告和恢复。\n   `GHES_SEV_PANIC` 不会进行这种处理，因为内核必须将进入 panic 状态。\n\n (2) 如果为外部中断，则通过 GHES 中传递的中断号，申请中断处理函数，在中断处理函数 `ghes_irq_func` 调用 `ghes_proc`。下面的处理流程和上面轮询一致。\n (3) 同样的如果为 SCI 中断，调用 notifier_call 回调函数 ghes_notify_hed，遍历 ghes_hed 链表，分别执行 ghes_proc 函数，处理错误\n (4) 如果为 NMI 中断，处理错误级别大于 `GHES_SEV_PANIC`，则直接 kernel panic。否则如配置 `CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG`，则调到工作队列处理函数 `ghes_proc_in_irq` 中。执行相当于下半部的处理过程。最终调用 `ghes_do_proc` 函数执行上述相关错误的处理。\n\n","tags":["arm","ras"],"categories":["RAS"]},{"title":"RAS 调研","url":"/2023/05/12/hxd_new/riscv调研/ras 调研/RAS 调研/","content":"\n# RAS\n\nRAS（Reliability、Availability and Serviceability），即可靠性、可用性、可维护性。\n\n以下是 RAS 的三个主要目标:\n1. 提升系统可运行时间。\n\tRAS 技术可以提升服务器的可靠性，一般通过测量平均故障时间（MTTF）、年崩溃率（ACR）或年服务率（ASR）来度量。一个可靠的系统将保持运行更长的时间，因此更加可用。\n\n2. 减少非计划停机时间。\n\t当非计划停机出现时，可以通过测量平均修复时间 MTTR 来度量服务器的可维护性。一个可维护的系统可以快速恢复正常运行。\n\t硬件和固件协同支撑日志记录，帮助识别和隔离故障，让操作者可以进行预防性或主动性的维护。如果出现停机，可以快速地将系统重新上线，减少维护成本，并减轻停机对企业的后果。\n\t\n3. 维护数据完整性。 \n\tRAS 技术提供了多种机制来防止数据损坏并纠正出错的数据。当检测到错误数据时，会确保它在可控制的范围内，避免引起更严重的问题。\n\n# x86 HPC ras 调研\n\n## 错误分类\n\n![](attachments/error_class.png)\n- 可纠正错误 CE\n\t- 当检测到可纠正错误CE时，对错误位置进行标记，并通过对应模块的RAS技术快速修复错误，用户不会感知到这类错误的发生\n- 不可纠正错误 UCE\n\t- 尝试对故障进行隔离。比如通过隔离内存坏块、总线降频等手段，维持系统的运行。若发生了更为严重的故障，系统直接宕机，这时需要通过带外管理软件HDM恢复或重启系统\n- 硬件永久性故障\n\t- 需要更换新的硬件或者启用备用设备进行修复。通过对部分硬件的热插拔功能，可以支持用户在系统不断电的情况下，进行故障设备的更换，使服务器恢复正常工作。\n\n![](attachments/error_process-1.png)\n\n## 故障上报\n\nRAS 技术主要是通过 MCA 机制、AER 机制实现的 [009](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=8&x=205&y=149&id=6&uuid=b3d0c275035114e953e31019c68ccafa)\n\n## MCA\n\nMCA (Machine Check Architecture) 机制可以上报并尽可能地修复系统总线、ECC、奇偶校验、缓存和 TLB 等等错误，识别故障源并将故障信息记录在 MC Bank 中。\n\n> MCA 是一个跟随着新处理器的发布不断增加新的特性和增强功能而不断进化的技术。\n\n\nMCE (Machine Check Exception) 的产生通常是由于以下几个原因:\n1. 违反了主板设计指南，例如因为布线导致信号的干扰和完整性问题。\n2. 处理器工作在非正常的状态，比如超频等进而导致处理器出现意料之外的行为。\n3. 环境因素，比如环境太热，太冷，潮湿或者有辐射。\n4. 风扇或者散热器安装的有问题导致过热。\n5. 没有及时的升级 micorode，导致有些 fix 没有集成进来。\n6. BIOS 或者 OS 的配置有问题导致 MCE 的异常处理没有很好的工作。\n7. 板子上的设备如果外插卡，内存条等有问题也可能会导致 MCE。\n\n\n在 MCA 架构的出现之前，OS 对 MCE 的处理非常有限，经常就是简单的重启系统\n对于管理员而言，简单的系统重启难以接受，而且出错现场经常无法保存，从而无法排错。即使能够保留下一些日志，除非有很强的专业知识，否则完全不知道真正产生错误的原因是什么。\n\n这些问题都在新的 MCA 中得到了解决和改进。利用新的 MCA 架构，CPU 可以按照配置产生 MCE(machine check exceptions)。\n对于可以修正的（Correctable）MCE，硬件可以自动从错误状态中恢复，而且并不需要重启系统\n\n早期的可修正的 MCE 并不需要产生中断，从 45nm Intel 64 处理器（CPUID 06H_1AH）开始引入了 corrected machine check error interrupt（CMCI）的机制，用户通过配置相应的 model-specific registers （MSR）允许可修正的 MCE 也会产生中断，软件可以捕捉到该中断并进行相应的处理。\n对于不可修正的（uncorrectable）MCE，这时系统已经处于不再安全和可以信赖的操作模式，系统必须重启才能恢复。软件可以根据不同的错误源产生的错误类别，错误的严重程度，软件可以选择隔离错误，记录错误，甚至屏蔽错误源（对于不重要的非致命的错误类型）以避免干扰，或是必须要复位系统。\n在新的 MCA 架构下，错误的记录管理，以及可读性都有了很大的提高。他可以\n- 帮助 CPU 设计人员和 CPU 调试人员诊断，隔离和了解处理器故障。\n- 帮助系统管理员检测在服务器长期运行期间遭受的短暂故障和与老化有关的故障。\n\nMCA 恢复功能是基于 intel 至强可扩展系列处理器的服务器的容错功能的一部分。这些功能使系统在检测到未纠正的错误时可以继续运行。\n如果没有这些功能，则系统将崩溃，并且可能需要更换硬件或重新引导系统。\n\n通过 MCA 机制:\n- CPU 内部的可纠正错误和不可纠正错误均可上报并记录\n- 并纠正硬件可纠正错误。\n- 对于不可纠正错误，通常会进行热重启。\nMCA 的作用域包括处理器中的所有模块，Core、Uncore 和 IIO（通过 IOMCA）\n\n## AER\n\nIIO AER (Integrated I/O Advanced Error Reporting) 机制 - PCI Express 的可选扩展功能\n它提供了比标准 PCI Express 错误报告机制更强大的错误报告功能，包括 PCI Express AER、Traffic Switch、IRP、IIO 核心、英特尔 VT-D、CBDMA 和其他特定于英特尔的扩展。\n\n负责侦测、记录并发送各种 IIO 模块下的子模块的错误信号，作用域包括 IIO 模块下的所有子模块，如 PCIe 接口，DMI，IIO 的核心逻辑和 Intel VT-d 等。\n\n## UPI\n\nintel upi (Ultra Path Interconnect，极速通道互联)\nUPI 可纠正错误上报：UPI 错误记录及信号发送的功能。\n\n\n## MCA 错误上报模式\n处理器提供了以下几种不同的 MCA 错误上报模式： [010](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=9&x=207&y=462&id=3&uuid=b13d51f1e1d91562db647a45fe1152f0)\n\n- Legacy IA-32 MCA 模式\n\t已经有几代英特尔处理器均支持 Legacy IA32 MCA 模式，该模式是大多数操作系统都支持的。\n- Corrupt Data Containmen 模式 \n\tCDC（Corrupt Data Containment Mode）模式是对 MCA 机制的一种强化。当启动 CDC 模式并检测到不可纠正错误时，检测代理将设置“poison”位和数据一起转发给请求代理。 \n- Enhanced MCA Gen1 (EMCA Gen1) Mode \n\t该模式是 Legacy IA-32 MCA 模式的第一代增强模式，是为了实现固件优先的错误报告模型。\n- Enhanced MCA Gen2 (EMCA Gen2) Mode \n\t第二代增强的 Legacy IA-32 MCA 模式。主要的目的是创建一个可通过操作系统启用的模式，并且进一步扩大固件第一模型（FFM）的错误报告范围。 \n- IOMCA Mode \n    允许 IIO 的不可纠正致命错误和不可纠正非致命错误通过 MCE 发送错误信号。\n\n\n## 故障上报中断 \n[011](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=10&x=141&y=390&id=4&uuid=35c1053435988cbd4c0a426e78fdd41a)\n\n![](attachments/error_interrupt.png)\n![](attachments/error_interrupt1.png)\n\n## 错误处理流程\n[012](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=11&x=141&y=180&id=5&uuid=b4f66eff0ac1963c9c63b9bd8b634d12)\n\n![](attachments/error_process.png)\n\n### 可纠正错误的处理 CE\n如上图所示的橙色流程。\n\n针对系统发生的可纠正错误，通过漏桶算法及设置可纠正错误阈值，可以实现在可纠正错误频繁发生时，触发 SMI (System Management Interrupt，系统管理中断) 中断通知 BIOS 进行错误处理，BIOS 接收到 SMI 中断请求后会根据不同的中断类型进行相对应的错误处理，在确保系统正常运行的同时，对发生错误的器件进行定位，隔离，搜集相关的错误状态寄存器信息，并上报 HDM 相关的错误事件及详细的错误状态寄存器信息，可供用户或服务器维护人员进一步分析问题发生原因。 \n\n### 不可纠正可恢复错误的处理 DE\n\n如上图深绿色流程\n\n对于不可纠正错误，如果这个错误是软件可恢复的（recoverable），则此错误并不会影响系统运行，只会将此错误数据将打上错误标记，并触发 SMI 中断，BIOS 收到此 SMI 中断后会搜集相关的错误寄存器信息，并对错误器件进行定位并上报 HDM 相关的错误信息及详细的错误状态寄存器信息。 \n\n### 不可纠正错误的处理 UE\n\n如上图所示的黄褐色流程\n\n如果 x86 系统发生了不可纠正且不可恢复的错误，CATERR_N 管脚会被拉低，这种错误会造成系统挂死，将会触发 HDM 的错误搜集程序，HDM 可以获取 x86 系统的错误状态寄存器信息，保证可以在系统挂死的情况下仍能在第一时间获取到错误现场信息，定位出错误根源并及时反馈给用户相关的信息。 \n\n\n## 错误日志记录\n\n使用 MCA Bank、AER 状态寄存器、内存可纠正错误状态寄存器和 Intel UPI 错误状态寄存器实现 Core、Uncore 以及 IIO 模块的错误日志记录。\n\n\n## 故障处理\n\n### 内存故障处理 \n\n![](attachments/ram_error_process.png)\n![](attachments/ram_error_p1.png)\n\n- SDDC 提供错误检查和校正，用于校正 DIMM 上的单个 DRAM 颗粒故障（硬错误）和多比特故障。\n- ADDDC（MR），同样需要在 Virtual Lockstep 模式下启用，并且只支持可纠正区域。ADDDC 功能支持对于 x4 DDR4 的 DIMM，每个 IMC 纠正 2 个 DIMM 区域（Bank 或 Rank）\n\n### CPU 故障处理\n\n当出现内核级错误，处理手段主要涉及到 Core Disable For Fault Resilient Boot 功能和 Core Corrupt Data Containment Enabled for DCU/IFU 功能。\n\n- Core Disable For FRB 功能 (Core Disable For Fault Resilient Boot)\n\t随着处理器内核数量的逐代增加，单个故障点从整个处理器转移到处理器内部的较小模块，比如单个 Core 或 LLC 的一部分。当出现了故障，除了可以禁用整个 CPU 之外，现在可以做到禁用特定的核。 \n\tCore 的禁用需要保留至少一个 Core 是活动的，才能完成系统引导过程。\n- Core Corrupt Data Containment Enabled for DCU/IFU 功能\n\t处理器支持 DCU/IFU 的内核缺陷数据包容特性，在启用 MCA 恢复-执行路径的高级 RAS 特性的情况下，可以将某些类型的**不可纠正数据错误**上报为**不可纠正可恢复错误**（SRAR 类型的UCR）而非致命错误。 \n\t“Error containment”位被一路传递给 DCU/IFU，从而允许隔离损坏的数据\n\n### PCIe 故障处理\n\n- PCIe Link Retraining and Recovery\n\tPCI Express 接口在出现链路降级时结合恢复机制，可以在不影响挂起的事务的情况下，进行重建链。如果在特定 lane 上出现了降级，恢复机制会按照 Platform Design Guide (PDG)定义的链路降级规则，降低链路宽度（例如，x16 链路将降级到 x8 链路）。如果在多个 lane 上出现降级，恢复算法会尝试在下一个允许的速度下重建链。\n- PCI Express Corrup Data Containment 功能（又称为 Data Poisoning）\n\t当接收端检测到**不可纠正的数据错误**时，使用“bad data”状态标识该错误数据，再将数据转发给目标，这种错误报告形式被称为“data poisoning”。接收 poison 数据的目标端，必须**忽略数据**，或者将数据带着“poison”标识存储起来。PCIE和一致性接口在事务分组中提供 poison 字段来标识错误数据。 \n\t`Data Poisoning` 功能不仅限于发送的请求。需要用数据完成的请求也可以标识 poison 数据。\n\n### UPI 故障处理\n\n- Intel UPI Corrupt Data Containment (损坏数据抑制)\n\t- 当 UPI Date Poison 功能开启时\n\t\tIntel UPI 只是一个 poison 标识的管道。UPI TX/RX 接接收到 poison 数据，会继续将数据传送到目的地，并且不会触发错误信号或记录错误日志。这样将由数据的消费者来决定如何处理不可纠正的数据错误。 \n\t- 当 UPI Date Poison 功能关闭时 \n\t\tUPI 将看不到带有 poison 状态的数据，所有单元都返回到 Legacy MCA 模式，Intel UPI RX 收到 poison 数据，会发出一个错误信号并立即记录。 \n- Intel UPI Dynamic Link Width Reduction\n\t在物理 lane 故障的情况下，支持从全带宽减小到 x8，半带宽支持仅用于 x8 位的最小集合，以允许任何单个数据通道失败。所得到的动态链路带宽减少模式是 lane[7:0]或[19:12]，就是说只要不是所有故障都在[7:0]和[19:12]上，多 lane 故障就可以被恢复。\n\n## RAS 系统架构 (新华三)\n\n![](attachments/ras_frame.png)\n\n- HDM：故障定位系统的核心，它负责故障的收集、汇总和分析，并通过 Web 管理界面事件日志以及故障告警等方式向客户呈现。 \n- 处理器平台：服务器采用 Intel Skylake 至强 CPU 平台，该平台较上一代基础上增强了 RAS 的能力，增强了对处理器、内存、PCIe 设备硬件故障的管理能力。 \n- CPLD (Complex Programmable Logic Device)：向下与各个硬件模块，包括电源、风扇以及其他底层硬件（除 CPU、内存、硬盘和 PCIe 标卡外）接口，捕获硬件异常状态，向上与 HDM 互连，传递故障信息。 \n- BIOS：主要实现 CPU、内存、PCIe 以及存储设备的故障收集和定位，向 HDM 提供故障定位的结果，对 OS 层面来说，BIOS 提供 WHEA 等 OS 级故障管理的接口。  \n- FIST（可选部件）：FIST 服务器配套管理软件。SDS 日志会记录服务器平台在每个使用周期过程中产生的从硬件到软件，从主 CPU 到 BIOS、OS 到 BMC 的大小事件。SDS 日志需通过 FIST 来解析。根据该功能查找服务器的使用记录或判断服务器的健康状况，客服或者工程师可以追寻服务器健康问题的蛛丝马迹，快速定位问题，从而提高服务器的可服务性。 \n- IFIST（可选部件）：iFIST 是一款内嵌于服务器的单机管理工具，通过 iFIST 可以配置 RAID、安装操作系统、安装驱动程序和诊断服务器健康状况，以满足用户对单台服务器进行直接管理的需求。  \n- 客户界面：主要通过 HDM 的 Web 界面，可以方便客户在远程或者本地进行系统维护工作，当然在主要部件上也会有故障指示灯。 \n- 各类协议：故障管理系统中所用到的接口、协议包括：LPC，PECI，PCIe，UART，I2C，SMBUS，LocalBus 等。 \n\n## RAS 功能表 (新华三)\n\nRAS 功能一览表 [016](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=15&x=148&y=162&id=33&uuid=743c975caa603ab5a85338b0d670bf54)\n![](attachments/ras_function.png)\n## RAS 功能简介\n\nRAS 功能简介 [019](bookxnotepro://opennote/?nb={59747e4f-483e-44bc-a127-6a987058cfe6}&book=6035548b7a4e90f59412a5e53ba8d5c2&page=18&x=131&y=71&id=7&uuid=6994f9d47a34009d8d718abbf4aa5285)\n\n# riscv reri architecture\n\n这个应该是类似于 X86 的 MCA\n\n## 介绍\n\n通过内存映射寄存器接口提供错误报告的标准机制，提供记录检测到的错误(包括其严重性、性质和位置)的功能，并配置了向 RAS 处理程序组件发送错误信号的方法。RAS 处理程序可以使用此信息来确定合适的恢复操作，这些操作可能包括:\n- 终止计算(例如，终止一个进程等)\n- 重新启动部分或全部系统等，以便从错误中恢复。\n\n此外，该规范应支持软件发起的 RAS 处理程序的错误记录、报告和测试。\n最后，该规范应提供实现错误处理的最大灵活性，并应与其他标准(如 PCle、CXL 等)定义的 RAS 框架共存。\n\n## 错误级别\n\n- CE Corrected error.  同 x86 CE (可纠正错误)\n- UDE Uncorrected deferred error. 同 x86 DE (不可纠正可恢复错误)\n- UUE Uncorrected urgent error.  同 x84 UE (不可纠正错误)\n\n## feature\n- 标识错误严重等级和错误代码\n- 内存映射的错误记录寄存器, 错误记录 bank\n- 规则- 高优先级的错误记录可以覆盖低优先级的错误记录 (UUE > UDE > CE)\n- 可纠正错误 (CE) 计数\n- RAS handler 用于测试的错误注入机制\n\n## 错误上报\n\n主体: \n- riscv hart\n- 内存控制器\n\n可支持一个或多个错误记录 bank\n每个错误记录对应于组件的一个硬件单元，并报告由该硬件单元检测到的错误。\n一个硬件单元可以实现多个错误记录。\n由于组件中的一个或多个硬件单元检测到错误，或由于一个硬件单元检测到一个或多个错误，所以同一时间有一个或多个错误记录是有效的.\n\n\n## 寄存器\n\n每个错误记录对应一组寄存器，用于控制该错误记录，报告状态、地址和其他与该错误记录中的错误有关的信息\n\n![](attachments/riscv-ras-eri.png)\n\n比较重要的 csr:\n\n- Error bank information (bank_info)\n\t![](attachments/riscv-ras-eri-2.png)\n\t系统的供应商将 inst_id 定义为组件的唯一标识符。返回值为 0 表示该字段未实现。\n\tN_err_recs 字段表示错误记录的数量。\n\n- Summary of valid error records (valid_summary)\n\t ![](attachments/valid_sum.png)\n\t - sv=1 时, 软件通过 valid_bitmap 确定 bank 中的哪条错误记录是有效的, 哪条有效, 就说明哪组 i csr 是有效的. `i` 表示第 `i` 个错误记录的 index.\n\t\t 一条错误记录有一组 csr , 由 status_i, control_i, info_i, addr_i 等组成.\n\t - sv=0 时, 软件需要遍历 status_i.v 来确定 error 记录是否有效.\n\n- Status register (status_i)\n\tThe status_i is a read-write WARL register that reports errors detected by the hardware unit\n\t![](attachments/riscv-ras-eri-1.png)\n\t- v = 1 代表该条错误记录有效\n\t- ce 为 1, 代表该错误记录为可纠正错误\n\t- de 为 1, 代表该错误记录为不可纠正可恢复错误\n\t- ue 为 1, 代表该条错误记录为不可纠正验证错误\n\t- at 代表该条错误记录所涉及的地址是 VA/HPA/GPA 中的哪个\n\t- c 为 1, 表示错误可能是可控的，但 RAS 处理程序可能能够也可能无法从此类错误中恢复系统。RAS 处理程序必须根据错误记录中提供的附加信息(如检测到损坏的内存地址等)做出恢复决定。\n\t- pri 代表该条错误记录在该类错误中的优先级. 数越大优先级越高\n\t- mo 为 1, 代表相同类型的错误已发生过多次\n\t- tt 代表导致该错误记录时的访问类型, 有隐式/显式读/写等\n\t- iv=1 代表该条错误记录携带了额外信息, 额外信息被写入到 info_i 中.\n\t- siv=1 代表该条错误记录携带了额外补充信息, 额外补充信息被写入到 suppl_info_i 中.\n\t- tsv=1 代表该条错误记录携带了时间戳, 时间戳写入到 timestamp_i 中\n\t- scrub=1 代表该条错误记录为 CE, 且地址上的错误数据已经被纠正.\n\t- ec (error code), 代表该条错误记录的错误识别代码\n\t\t![](attachments/error_code.png)\n\t\t![](attachments/error_code1.png)\n\t- cec (corrected-Error-counter), 当 control_i.cece=1 时, cec 代表当前已发生 CE 的错误记录的总计数.\n- Control register (control_i)\n\t![](attachments/control_i.png)\n\tControl_i 是一个读/写 WARL 寄存器，用于控制错误库中相应错误记录的错误报告。\n\tThe ces, udes, and uues are WARL fields used to enable signaling of CE, UDE, and UUE respectively When they are logged.\n\t- control_i.sinv 清除 status_i 的 v 位. \n\t- else = 1, 记录错误记录的错误上报功能启用. =0, 关闭, 关闭时 CE 错误的硬件纠错机制仍然是开的, 建议在关闭时硬件组件继续对由硬件组件产生或存储的数据产生错误进行检测和纠正. 建议在关闭的情况下仍然抑制病毒数据\n\t- ces/udes/uues 分别控制 CE/UDE/UUE 错误的错误上报.\n\t\t![](attachments/control_i_flag.png)\n\t\t错误记录产生的信号除了引起中断/事件通知外，还可以用来携带额外的信息，以帮助平台中的 RAS 处理程序.\n\t\t错误信号可以通过平台特定的方式配置中断类型, 通知平台中的 RAS 处理程序。例如，高优先级的 RAS 信号可被配置为引起高优先级的 RAS 本地中断、外部中断或 NMI，低优先级的 RAS 信号可被配置为引起低优先级的 RAS 本地中断或外部中断。\n\t- cece = 1, 打开 status_i.cec (CE 错误计数)\n\t- eid (error-injection-delay), 错误注入延时. 前面讲了错误注入机制是为了测试目的. eid 中有值时, 开始以特定的频率向下递减, 当 eid 达到 0 时, 产生一条错误记录, 错误记录就是对应 status_i 中的错误记录, 在错误上报开关打开后, 会产生对应的中断通知 RAS 处理程序.\n\t  只会产生错误记录, 并不会产生错误反映到硬件上, 因此不是用来验证硬件错误的.\n\t  软件应确保该机制不会被滥用而产生安全问题.\t  \n- Address register (addr_i) \n\tThe addr_i WARL register reports the address associated with the detected error\n- Information register (info_i)\n\tThe info_i WARL register provides additional information about the error when status_i.iv is 1\n\t此字段结合 status_i.ec 错误代码看, 可用于报告特定于错误的信息，以帮助定位失败的组件、指导恢复操作、确定错误是暂时的还是永久的，等等。该字段可用于报告有关组件中错误位置的更详细信息，例如，检测错误的集合和方式、出错的奇偶校验组、ECC 错误状态、协议 FSM 状态、导致断言失败的输入等。\n- Supplemental information register (suppl_info_i)\n\t与 status_i.ec 结合, 代表特定的信息.\n\n# riscv ras 硬件方案 (develop simple)\n\n![](attachments/riscv_ras_arch.png)\n\nhttps://riscv-europe.org/media/proceedings/posters/2023-06-06-Daniele-ROSSI-abstract.pdf\n\n- Error Mux\n\t多路错误接收复用器, 接收硬件错误信号, 根据硬件错误信号生成错误消息 (包括错误识别代码, 错误类型等), 将错误消息存放到 FIFO Buffer 中.\n\n- DE Controller 处理不可纠正可恢复错误。\n\t为了执行它的任务，读/写信号也是必需的。实际上，如果在读取操作期间访问了存储带有 DE 的数据的内存位置，那么这些有毒的数据将被消耗掉。因此，需要将 DE 升级为紧急错误 UE。相反，跟踪一个写操作到一个有延迟错误的位置，允许我们使相应的错误记录无效，因为在这种情况下，旧的数据将被新的数据覆盖。\n\n- Main controller\n\t用于选择用于定位错误记录的寄存器组, 采用了一种全组相连的 cache 缓存策略, 在错误产生时, 它会找到空闲的 bank (即确定 bank csr 组的 index), 将该错误记录存到该组寄存器下.\n\t如果所有错误记录都被占用了 (没有空闲的), 由它选择丢弃新的错误记录, 或者按照优先级将新的错误记录覆盖掉旧的. 优先级的顺序 UE>DE>CE, 对应其中每个子类别, 会按照 status_i.pri 来排序.\n\n- FIFO Buffer, 缓存来自 Error Mux 的错误记录消息\n\n- Error Record Banks\n\t即对应 Feature Register, 即前面介绍的 riscv reri architecture 中的所有的寄存器. 这些 csr 是 memory-mapped. 应该不在 cpu 内部, 而在 soc 范围, 设计时需要符合 riscv reri architecture 规范.\n\n- IRQ Gen 单元\n\t负责在不同场景中产生中断信号, 需要根据 riscv 寄存器组中 control_i 的设定来判断是否要生成中断信号. 不同的错误生成不同的中断 (根据错误级别可配置本地中断、外部中断或 NMI)\n\n# Linux\n\nDocumentation/admin-guide/ras. Rst\n主要是 EDAC (Error Detection And Correction)\n包括两个子系统，\n- Edac_mc \n\t负责收集内存控制器报告的错误\n- Edac_device。\n\t负责其他控制器（比如 L3 Cache 控制器）报告的错误。\n\t通常是把控制器的驱动写成一个 platform device，然后在 probe 的时候注册为 edac_mc 或者 edac_device。\n\n```c\nedac_mc_handle_error()\nedac_raw_mc_handle_error()\nedac_device_handle_ce()\nedac_device_handle_ue()\n```\n\n这些报告函数主要干这些事：\n\n1. Printk：把错误打印到 print ring buffer 里面\n2. Trace_mc_event：把错误写到 ftrace 的一个跟踪项中\n3. 统计：把这个错误报告到根据 DIMM 条，Rank，Row 的分类进行统计，为后续进行硬件替换提供参考\n4. 如果硬件报这是个 UE，而且这个控制器要求 UE 即停机，则复位系统\n\n> Printk 是个参考，是不适合正式处理的\n> Trace_xxx 是个跟踪，不开跟踪就不能工作，统计不能用于单个处理。\n\n\n所以，当我们给 Linux 实现 RAS 特性的（硬件的）时候，必须有意识地用 page_fault 一类的异常来控制传播范围，只把中断的报告看作是统计上的补充。\n\n当硬件侦测到一个错误，它有两种方法报告 CPU:\n- 一种方法是中断。这是个异步的过程，很容易造成传播范围不可控。\n\t- 如果这是 CE 的，错误已经被硬件主动修复，或者可以有手段修复（比如通过产生同步异常）。\n\t- 是 UE 的，这基本上就要导致停机乃至整体隔离了。\n\n- 第二种错误的报告方法是把错误随着 CPU 核的读写响应（消息）返回给 CPU，让 CPU 产生一个同步异常\n\t- 这种异常体现在 CPU 核上，就是一个 page_fault 中断，只是不同的类型，CPU 可以通过给对应的进程发 SIGBUS 一类的信号来控制这个错误。\n\n# Bios uefi\n\n## ACPI APEI 表\n\nEDAC 是比较原始的实现，需要为每个平台的控制器写独立的驱动。ACPI 标准的 APEI 表从 BIOS 层提供了标准的报告形式。APEI 是 ACPI Platform Error Interface 的缩写，它包括多张表：\n\n1. BERT: Boot Error Record Table，这个用于记录前一次复位前 BIOS 记下来的错误，Linux 读到这个记录会打印出来，以便知道比如上次因为 UE 而服务的原因\n2. EINJ：Error INJection，BIOS 提供的硬件故障注入的接口，Linux 把这个封装成 debugfs 的属性了，可以通过这个注入需要的硬件错误\n3. ERST：Error Record Serialization Table，这个表用于配合 BERT，从 OS 侧辅助 BIOS 把临时前的错误信息保存到持久设备中。做硬件的同学要考虑适配这套框架，保证错误可以被固化到持久的存储中\n4. HEST: Hardware Error Source Table，这个描述系统有多少个错误检测设备，Linux 中这个被实现为多个（每条记录一个）平台设备\n5. GHES：General Hardware Error Source，这是硬件报错的接口。Linux 中，这个被实现为 HEST 定义的设备的驱动，每个那样的平台设备，Probe 到这个驱动上后，再注册为一个 edac_mc 设备，这样就和 EDAC 框架结合起来了\n\n从这里可以看到，APEI 一定程度上是基于 EDAC 框架的，但它同时也提供独立于 EDAC 之外的功能。所以，高级的标准的服务器，更应该选择的是走 APEI 路线，而不是 EDAC 的路线。\n\n只要硬件提供 APEI 接口，Linux 上就不需要额外的驱动了。\n\n## 异常内存页隔离\n\n如果我们发现异常的内存问题:\n- 一种办法当然可以立即停机。\n- 还有一种方法是隔离掉这片内存。\n\t这个功能依然做在 GHES 上，`ghes_handle_memory_failure()` 调用 mm/mm-failure.c 中的异常函数，Linux 会把这个 page 标记为 HWPOISON 的，之后相关的页，VM 或者进程就会被隔离掉。 \n\n> 不能避免错误被传播出去。但对一般数据中心来说，可能也够了。对大部分数据中心来说，你能说你这个节点不可信就够了，本来也不指望你还能提供内存双备这种不计成本的高级特性来。\n\n# Reference\n\nAMD64 Architecture Programmer’s Manual, Volume 2: System Programming\nIntel Xeon Processor E7 Family: Reliability, Availability, and Serviceability - White paper\nArm® Reliability, Availability, and Serviceability (RAS) Specification - Armv8 Architecture Profile, July 2019.\nRERI (RAS Error-record Register Interface) task group. URL:https://lists.riscv.org/g/tech-ras-eri.","tags":["ras","x86"],"categories":["RAS"]},{"title":"riscv aosp requirements","url":"/2023/05/11/hxd_new/riscv调研/riscv aosp requirements/","content":"\n![](attachments/riscv_aosp_requirements.png)\n\n# RISC-V Better Atomics (Load-Acquire/Store-Release)\n\n是 RISC-V 体系结构的一种扩展，旨在提供更强大的原子操作支持。\n在并发编程中，原子操作是一种确保多个线程或处理器可以安全地对共享变量进行操作的机制。原子操作需要满足一定的一致性和同步性质，以避免数据竞争和不确定的行为。\n\nRISC-V Better Atomics 扩展引入了一对新的原子指令，即 Load-Acquire 和 Store-Release。\n- Load-Acquire 用于读取共享变量，并确保读取操作具有\"acquire\"语义，即保证在此原子操作之前的所有存储操作都可见。\n- Store-Release 用于写入共享变量，并确保写入操作具有\"release\"语义，即保证在此原子操作之后的所有加载操作都能看到最新的值。\n\n使用 RISC-V Better Atomics 可以更好地控制并发访问共享变量的顺序和一致性。它提供了更细粒度的原子操作语义，以满足高性能和并发编程的需求。\n\n在 RISCV-V 的 A 扩展下\n- Load-Acquire 指令通常以 `lr.` 或 `amoswap` 的形式出现，例如 `lr.w`（Load-Reserved Word）用于加载一个字（32位数据）并获取内存序。\n- Store-Release 指令通常以 `sc.` 或 `amoswap` 的形式出现，例如 `sc.w`（Store-Conditional Word）用于将一个字（32位数据）存储到内存中并释放内存序。\n\n# Saturating Operations\n\n饱和操作（Saturating Operations）是一种特殊的操作，用于处理数值溢出的情况。当执行某种算术操作时，如果结果超出了数据类型的表示范围，饱和操作将会将结果截断为数据类型所能表示的最大或最小值，而不是简单地截断为溢出的结果。\n\nRISC-V 架构中的饱和操作主要应用于整数数据类型。以下是一些常见的饱和操作指令：\n\n1.  SLL.SAT：饱和左移指令，将一个寄存器中的整数左移指定的位数，并将结果截断为数据类型的最大或最小值。\n2.  SRA.SAT：饱和右算术移位指令，将一个寄存器中的整数右算术移位指定的位数，并将结果截断为数据类型的最大或最小值。\n3.  SRL.SAT：饱和右逻辑移位指令，将一个寄存器中的整数右逻辑移位指定的位数，并将结果截断为数据类型的最大或最小值。\n4.  ADD.SAT：饱和加法指令，将两个寄存器中的整数相加，并将结果截断为数据类型的最大或最小值。\n5.  SUB.SAT：饱和减法指令，将两个寄存器中的整数相减，并将结果截断为数据类型的最大或最小值。\n\n这些饱和操作指令使得处理数值溢出的情况更加方便和可控，避免了溢出错误对程序执行的影响。\n\n需要注意的是，饱和操作并不是所有 RISC-V 架构中都支持的标准指令。具体支持的指令和操作会根据特定的处理器和实现而有所不同。因此，在编写程序时，建议参考相关的处理器手册或编程指南，以了解特定处理器对饱和操作的支持情况和具体的指令格式。\n\n# Half-width floats (Zfh)\n\n半精度浮点数（Half-width floats）是一种浮点数表示格式，用于表示较小的浮点数范围。在 RISC-V 中，半精度浮点数采用 IEEE 754 标准的半精度浮点格式。\n\n半精度浮点数使用 16 位（2 字节）来表示一个浮点数，其中包括符号位、指数位和尾数位。具体的格式如下：\n\n-   符号位（1 位）：用于表示浮点数的正负。\n-   指数位（5 位）：用于表示浮点数的指数部分，可以表示范围为 -14 到 +15。\n-   尾数位（10 位）：用于表示浮点数的尾数部分。\n\n半精度浮点数相比于单精度浮点数（32 位）和双精度浮点数（64 位）具有较小的范围和精度，但占用更少的存储空间。在一些资源受限的场景中，如嵌入式系统或移动设备，半精度浮点数可以用于节省存储空间和提高计算效率。\n\n> 玄铁 910 支持半精度浮点类指令\n\n# Bitmanip (wave 支持 zba and zbb)\nRISC-V Bitmanip 扩展是 RISC-V 指令集架构的一部分，用于进行位操作和位操作相关的操作。Bitmanip 扩展引入了一组指令，以提供对位操作的支持，包括位移、位计数、位反转、位扩展等功能。\n\nBitmanip 扩展的主要目的是增强 RISC-V 的位操作能力，使开发者能够更高效地处理位级操作和位级数据操作。这对于一些应用场景，如加密算法、图形处理、数据压缩等，非常有用.\n\nBitmanip 扩展引入了一些常用的位操作指令，例如：\n\n-   `clz`: 计算无符号整数的前导零位数。\n-   `ctz`: 计算无符号整数的尾部零位数。\n-   `pcnt`: 计算无符号整数的位计数，即二进制表示中的位为 1 的个数。\n-   `slo`: 逻辑左移操作，将指定位数的位从右边移入。\n-   `sro`: 逻辑右移操作，将指定位数的位从左边移入。\n-   `rol`: 循环左移操作，将位向左循环移动。\n-   `ror`: 循环右移操作，将位向右循环移动。\n\n这些指令使得开发者能够更高效地进行位级操作和位级数据处理，简化代码编写和提高运行效率。\n\n需要注意的是，具体的 Bitmanip 指令和功能会根据 RISC-V 架构扩展的版本和实现而有所不同。因此，建议查阅相关的处理器手册或编程指南以获取详细的信息和指令使用示例。\n\n> kingv 支持 Bitmanip extension\n\n![](attachments/kingv_isa.png)\n\nZba扩展（Bitmanip Extension）引入了用于位级操作的指令，包括位逻辑操作（AND、OR、XOR）、位计数、位提取和位字段插入。这些指令可以高效地操作整数寄存器中的单个位和位字段，从而实现对位的精细控制。\nZbb扩展（Bitmanip Extension B）进一步增强了位操作的功能，引入了额外的指令用于位排列、位翻转和位计数等操作。这些指令提供了更高级的位操作功能，在密码学、数据压缩和信号处理等各种应用中非常有用。\nZba和Zbb扩展都是RISC-V体系结构的可选功能，在支持这些扩展的处理器中实现。要使用这些扩展，软件工具和编译器需要提供支持，以生成使用Zba和Zbb指令的代码。具体实现或处理器型号的可用性和对这些扩展的支持可能有所不同。\n\n> 玄铁 C910 支持扩展的位操作指令 \n\n![](attachments/c910_bitmap.png)\n\n# J extension (Zjpm+Zjid Shougun 支持 J extension?)\n\nRISC-V J 的扩展旨在使 RISC-V 成为传统解释或 JIT 编译的语言或需要大型运行时库或语言级虚拟机的语言的一个有吸引力的目标, 包括 C# JAVA python 等.\n\nhttps://github.com/riscv/riscv-j-extension\n\nRISC-V 指针屏蔽（PM）是一个功能，当启用时，会导致 MMU 忽略有效地址的前 N 位。使得这些比特可以以应用程序选择的任何方式使用。所描述的扩展版本专门针对标签检查。当一个地址被访问时，存储在被屏蔽位中的标签与基于范围的标签进行比较。这被用于动态安全检查器，如 HWASAN[1]。这样的工具可以应用于所有的特权模式（U、S 和 M）。\n\n> Shougun 支持 J extension?\n\n![](attachments/shougun_isa.png)\n# ABI gaps \n\n需要 TLSDESC 等\n\n## TLSDESC\n\nRISC-V TLSDESC，全称为 Thread Local Storage Descriptor，是 RISC-V 指令集架构的一部分，用于支持线程本地存储（Thread Local Storage，TLS）的访问。\n\nTLS 是一种机制，允许每个线程在共享内存的基础上拥有自己独立的数据区域，这对于多线程编程非常重要。TLS 可以用于存储线程特定的数据，例如线程的局部变量或全局状态。\n\nRISC-V TLSDESC 扩展引入了以下指令：\n\nTLSDESC_CALL (TLS Descriptor Call)：调用 TLS 描述符以获取线程本地存储数据的地址。\nTLS 描述符是一个特殊的数据结构，用于获取线程本地存储数据的地址。TLSDESC_CALL 指令用于调用 TLS 描述符，并将返回的地址存储在指定的寄存器中，以便后续访问线程本地存储数据。\n\n需要注意的是，RISC-V TLSDESC 扩展是可选的，并不是所有的 RISC-V 架构都支持该扩展。具体的支持情况可以参考特定处理器的文档或规格说明。\n\nTLSDESC 扩展的引入使得在 RISC-V 架构上能够更方便地使用线程本地存储，提供了对多线程编程的支持\n\n\n>arm 中通过 `TPIDR_EL0` 寄存器，每个线程可以访问自己的 TLS 数据，而不需要使用全局变量或其他机制。线程局部存储是一种为每个线程分配独立内存空间的机制，用于保存线程特定的数据。\n通过将 TLS 基址存储在 `TPIDR_EL0` 寄存器中，线程可以通过读取该寄存器来迅速获取自己的 TLS 数据的访问地址。\n\n\n# HWASAN\n\n(Hardware-assisted Address Sanitizer）是一种基于硬件辅助的地址检测工具，用于检测和调试软件中的内存错误和安全问题。它类似于其他架构上的 AddressSanitizer（ASan）工具，但专门针对 RISC-V 架构进行了优化。\n\n该实现依赖于 J-extension（又称 \"指针屏蔽）的可用性。目前，这个扩展不是官方的\n需要修改编译器 (llvm) 适配该实现\n\n# TEE\n\nthere's an Ever ratcheting bar on the hardware features that are required whether it's ***trusted execution environments confidential compute virtualization*** or ***even runtime detection of memory safety errors in the hardware***\n\n需要虚拟化实现的 TEE 或者硬件内存安全错误检测机制 (如 ARM 的 trustzone 或 sifive 的 worldguard 机制)\n\n> 玄铁支持 VirtualZone 技术 (PMP+IOPMP)\n\n# virtualization\n\n硬件虚拟化, 可以用来辅助实现内存的安全隔离机制\ntrusted execution environments confidential compute virtualization\n\n# C910 VS wave shougun/kingv\n\n![](attachments/c910_vs_wave-1.png)\n\n","tags":["riscv"],"categories":["AOSP"]},{"title":"ras 软件方案调研","url":"/2023/05/11/hxd_new/riscv调研/ras 调研/ras 软件方案调研/","content":"\n> uefi 代码示例来自华为 hisi 1620\n\n# APEI \n\nUEFI\nACPI Platform Error Interfaces\n\n> Provides a standard way to convey error info From Firmware to OS\n\n![](attachments/apei.png)\n\n\n## BERT\n\nBoot Error Record Table\nRecord fatal errors, then report it in the second boot\n记录启动过程中的关键错误信息, 在下一次启动时报告错误.\n\n- 在 OS 未接管平台的控制权限之前 firmware（如 BIOS 或者 UEFI）检测到错误，导致系统无法继续启动，可以通过 BIOS/FIRMWARE 将这种类型的错误写入到特定的存储位置。这样一来，在下一次的正常启动过程中，OS 可以通过特定的方法将之前保存的错误读取出来分析并处理。\n- 当**系统运行过程**中 firmware 检测到了**致命错误**，以至于 **firmware 决定不通知 OS 而是直接重启**（如 CPU 风扇突然坏了，瞬间过热，如果不立刻重启会烧毁 CPU），**在重启前 firmware 可以记录下相关的错误信息以便之后分析出错原因**。\n\n> 注：**只有 BIOS/FIRMWARE 才有能力对 BERT 执行写入操作**；对于 OS 而言，BERT 仅仅是一个**只读的表**。BERT 出现的意义在于希望采用**一种统一的接口**来记录特定类型的硬件错误（主要是一些致命的），从而简化 BIOS/FIRMWARE 和 OS 的实现。\n\n\n![](attachments/BERT.png)\n\n```erlang\n-+ ApeiEntryPoint(ImageHandle, SystemTable)\n \\ -|+ if SetupData.EnRasSupport\n\t\t\t \"通过协议的 GUID 查找对应的协议, 查找acpi 表格协议\"\n     \\ -+ gBS->LocateProtocol(&gEfiAcpiTableProtocolGuid, NULL, &mAcpiTableProtocol); \n\t\t     \"查找 ACPI 标准数据表协议, 操作系统和驱动程序可以获取系统硬件配置信息，进行系统初始化和配置，以及支持电源管理等功能。\"\n     | -+ gBS->LocateProtocol(&gEfiAcpiSdtProtocolGuid, NULL, &mAcpiSdtProtocol); \n     | -+ gBS->AllocatePool (EfiReservedMemoryType, sizeof (APEI_TRUSTED_FIRMWARE_STRUCTURE), (VOID**)&mApeiTrustedfirmwareData) \"分配内存池\"\n     | -  gBS->SetMem (mApeiTrustedfirmwareData, sizeof (APEI_TRUSTED_FIRMWARE_STRUCTURE), 0)); \"memset 0\"\n     | -+ OemInitBertTable (ImageHandle);\n        \\ -  BERT_CONTEXT Context;\n        | -+ BertHeaderCreator (&Context, BOOT_ERROR_REGION_SIZE); \"Bert 表分配内存\"\n           \\ -  Context->BertHeader = AllocateZeroPool (sizeof (EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER));\n           | -  Context->Block = AllocateReservedZeroPool (ErrorBlockSize);\n\t\t           \"构造header 包含上图的 OEMID OEM_table_id creator_id等如 EFI_ACPI_ARM_OEM_REVISION EFI_ACPI_ARM_CREATOR_ID\"\n           | -  *Context->BertHeader = (EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER) {  \n\t\t           ARM_ACPI_HEADER(\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_SIGNATURE,\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER,\n\t\t\t\t      EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_REVISION\n\t\t\t\t      ),\n           | -  ErrorBlockInitial (Context.Block, EFI_ACPI_6_2_ERROR_SEVERITY_NONE);\n           | -+ BertSetAcpiTable (&Context); \"初始化 Bert Table\"\n\t\t           \"ACPI 表格是存储着系统硬件配置信息和固件与操作系统通信信息的数据结构。在 UEFI 中，\n\t\t\t           有时需要向 UEFI 固件中添加自定义的 ACPI 表格，\n\t\t\t           以便在操作系统启动时提供特定的系统配置信息，或支持特定的硬件功能\"\n              \\ -+ mAcpiTableProtocol->InstallAcpiTable (    \"通过Acpi 表格协议安装 Bert 表\"\n                                 mAcpiTableProtocol,\n                                 Bert,\n                                 Bert->Header.Length,\n                                 &AcpiTableHandle);     \n```\n\n## linux driver\n\n> `drivers/acpi/apei/bert.c`\n\n```erlang\n-+ bert_init\n \\ -+ acpi_get_table(ACPI_SIG_BERT, 0, (struct acpi_table_header **)&bert_tab); \"获取bert table\"\n | -  region_len = bert_tab->region_length; \"获取 bert_table length\"\n | -  apei_resources_init(&bert_resources); \"初始化 apei_resources 结构体\"\n       \"向bert_resources 下添加IOMEM 类型的资源，以便在发生错误时能够正确地处理这些资源。 \"\n | -  apei_resources_add(&bert_resources, bert_tab->address, region_len, true); \n | -+ apei_resources_request(&bert_resources, \"APEI BERT\");\n | -+ boot_error_region = ioremap_cache(bert_tab->address, region_len);\n | -|+ if boot_error_region\n     \\ -+ bert_print_all(boot_error_region, region_len);\n        \\ - \"Error records from previous boot\"\n        | -+ cper_estatus_print(KERN_INFO HW_ERR, estatus);\n           \\ -  \" %s event severity: %s\", severity \"打印log错误级别\"\n           | -+ foreach section\n\t          \\ -+ cper_estatus_print_section(newpfx, gdata, sec_no)\n\t             \\ -  severity = gdata->error_severity;\n\t             | -  printk(\"%s\"\"Error %d, type: %s\\n\", pfx, sec_no, cper_severity_str(severity));\n\t             | -  printk(\"%s\"\"fru_id: %pUl\\n\", pfx, gdata->fru_id);   \"fru_id fru_text等, 见上图的表结构\"\n\t             | -  printk(\"%s\"\"fru_text: %.20s\\n\", pfx, gdata->fru_text);\n\t\t                ...\n```\n\n## ERST\n\nError Record Serialization Table\nProvides details necessary to communicate with on-board persistent storage for error recording\n\n提供必要的详细信息, 协同存储错误记录\n\nERST 本质上是一个用来**永久存储错误的抽象接口**。**软件可以通过 ERST 表**将各种错误信息保存到 ERST 中，再由 ERST 写入到可用于永久存储的物理介质中。ERST 并没有一个严格的定义来界定什么是“错误”，换言之，软件可以保存任何信息到 ERST 中，只要软件认为是有意义，有价值的信息就可以.\n物理介质未必一定是 flash 或 NVRAM，可以是网络存储或者其他。\n\nERST 的主要作用就是用来存储各种硬件或者平台相关的错误，错误类型包括:\n- Corrected Error（CE）\n- Uncorrected Recoverable Error（UCR) \n- Uncorrected Non-Recoverable Error，或者说 Fatal Error。\n\n换言之，只要是软件可以记录的错误，都可以将其保存到 ERST 当中。加上之前谈到的 BERT 表，这样一来，无论系统运行在哪个阶段，当出现硬件或平台相关的错误时，通过 APEI 接口，都有办法将错误保存下来。这样一来就可以在之后通过适当的方法将错误读取出来进行分析，从而加快定位产生错误的原因并加以解决。\n\n\n![](attachments/ERST.png)\n\n## EINJ\n\nError Injection Table\nProvides a generic Interface which OSPM can inject hardware Errors to the platform without requiring platform Specific software.\n\n提供通用接口方便 os 向硬件注入错误.\nEINJ 的主要作用是用来注入错误并触发错误，或者说，EINJ 是一个用来测试的表。EINJ 可以注入各种类型的硬件错误，这些注入的错误不是模拟的，而是通过 EINJ 和底层 firmware 以及硬件配合真实产生的。通过 EINJ 注入的硬件错误是真正的错误，和硬件真实发生的错误没有差别。这样一来，平台设计者和软件开发人员可以使用 EINJ 在软硬件发布之前测试平台的软硬件环境是否可靠，是否具有足够的容错性以及完备性，而不必等到在平台发布之后的使用过程中出现错误时再来检测系统是否可靠。\nEINJ 支持的错误注入方式非常丰富。从错误类型上划分，和 ERST 一样，包括 Corrected Error（CE），Uncorrected Recoverable Error（UCR），以及 Uncorrected Non-Recoverable Error，或者说 Fatal Error。从错误来源划分，可以分为 Processor，Memory，以及 PCI-E 设备等类型。通过交叉组合，至少有 9 种可以注入的错误。\n至少有 9 种可以注入的错误。\n\n- 0x00000001 Processor Correctable\n- 0x00000002 Processor Uncorrectable non-fatal\n- 0x00000004 Processor Uncorrectable fatal\n- 0x00000008 Memory Correctable\n- 0x00000010 Memory Uncorrectable non-fatal\n- 0x00000020 Memory Uncorrectable fatal\n- 0x00000040 PCI Express Correctable\n- 0x00000080 PCI Express Uncorrectable fatal\n- 0x00000100 PCI Express Uncorrectable non-fatal\n- 0x00000200 Platform Correctable\n- 0x00000400 Platform Uncorrectable non-fatal\n- 0x00000800 Platform Uncorrectable fatal\n\n使用 EINJ 进行错误注入有两个步骤：\n1. 根据需要产生错误注入需要的 trigger 表（trigger action table），这个 trigger 表是 BIOS/FIRMWARE 根据用户需要注入的错误类型动态生成的，不能人为手工构造；\n2. 是触发这个 trigger 表，让其在合适的位置产生需要的错误。至于产生了错误之后，如何处理错误，如何修复错误之类的事情，和 EINJ 无关。\n\nEINJ 的注入过程基本上是一个 2 步操作：\n1. 使用 SET_ERROR_TYPE 这个 ACTION 向 EINJ 表中注入一个错误\n2. 根据第一步设定的错误，与 EINJ 相关的 firmware 会动态生成一个 Trigger Error Action 表，使用 GET_TRIGGER_ERROR_ACTION_TABLE 这个动作可以得到这个 trigger 表，然后操作这个 trigger 表可以触发之前注入的错误，从而达到测试特定错误类型的目的。\n\n在整个过程当中，关键点是从 GET_TRIGGER_ERROR_ACTION_TABLE 动作完成后得到的 trigger 表的基地址。这个 trigger 表的基地址作为入口参数被 __einj_error_trigger 函数调用，最终完成错误触发。简单来说，__einj_error_trigger 需要完成两件事：\n\n- 根据 GET_TRIGGER_ERROR_ACTION_TABLE 返回的 trigger 表的地址（本质上是一个复合结构）进行相应的 IO 资源分配（这里的 IO 资源主要由 GAS 提供）\n- 调用 ACPI_EINJ_TRIGGER_ERROR 动作完成错误触发。\n\n![](attachments/EINJ.png)\n\n### kernel driver\n\n```shell\n$ cd /sys/kernel/debug/apei/einj\n# See which errors can be injected\n$ cat available_error_type\n# Set memory address for injection\n$ echo 0x12345000 > param1\n$ Mask 0xfffffffffffff000 - anywhere in this page\n$ echo $((-1 << 12)) > param2\n# Choose correctable memory error\n$ echo 0x8 > error_type \n# Inject now\n$ echo 1 > error_inject \n```\n\nACPI 5.0 BIOS 也可能允许注入特定于供应商的错误。在这种情况下，名为 vendor 的文件将包含标识信息，从 BIOS 中希望可以允许希望使用的应用程序使用特定于供应商的扩展，以告知他们正在 BIOS 上运行支持它。\n所有供应商扩展都在其中设置了 0x80000000 位 error_type。文件 vendor_flags 控制对 param1 的解释和 param2（1 =处理器，2 =内存，4 = PCI）。\n\n\n## GHES of HEST\n\nGeneric Hardware Error Source - GHES\nHardware Error Source Table   - HEST\n\nHOW to get trigger: Notification Structure\nWHERE are the error records:\n\nError Status Address\n(GAS : Generic Address Structure)\n\nHOW to release records’ mem:\nRead Ack Register\n\n在 HEST 中定义了很多硬件相关的错误源和错误类型。定义这些硬件错误源的目的**在于标准化软硬件错误接口的实现**。有了 HEST，当发生特定类型的硬件错误，如 PCI-E 设备产生了一个 Uncorrected Recoverable 类型的错误时，BIOS/FIRMWARE 有统一的方法更新特定的寄存器和内部状态，软件有统一的方法去处理和解析错误。HEST 中定义了很多硬件错误源，如 MCE、PCI-E、GHES 等等。\n\n其中最为特殊也是最为重要的硬件错误源类型就是 GHES (Generic Hardware Error Source)。GHES 是一个**通用硬件错误源**，换言之，任何类型的硬件错误都可以使用 GHES 来定义，而无需使用之前提到的特定硬件错误源，如内存控制器错误等。\n\n当前无论是软件还是 BIOS/FIRMWARE 的实现，基本上都是只使用 **GHES 来实现 HEST 的功能**，至于其他特定的硬件错误源，基本上都没有使用（PCI-E AER 的部分代码检测了 PCI-E 类型的硬件错误源）。\n\n在 FFM (Firmware-First handling) 使能的情况下，一般而言，所有 CE 类型的错误通过 SCI 中断报告给 OS，然后 OS 在 HEST/GHES 中查表，检测并处理可能的硬件错误；所有 UC 和 Fatal 类型的错误通过 NMI 报告给 OS，然后 OS 在 NMI 的 handler 中查表，检测并处理可能的硬件错误。这些规定并不是硬性要求的，平台设计者完全可以根据需要使用 NMI 来处理所有的错误类型，包括 CE, UC 和 Fatal 类型的错误，也可以只使用 NMI 来处理 UC 和 Fatal 类型的错误，而使用轮询的方式来处理 CE 类型的错误。\n\n![](attachments/HEST.png)\n\n### linux kernel ghes 处理\n\nGhes_probe 函数中，根据 HEST 表中传递的检测错误类型，查看相关 kernel 配置选项是否支持。包括 arm 相关的 SEA 错误，NMI，本地中断。\n调用 ghes_new 函数，初始化 struct ghes 结构。初始化 ghes 结构，映射表中 Error Status Address。为存放错误信息数据申请内存。\n\n根据上报错误方式，注册不同的处理流程，包括如下：\n（1）轮询方式，根据表中传递的 poll_interval 时间，创建定时器。在定时器处理函数 ghes_poll_func 中，调用 ghes_proc。在这个函数中：\n\t\tA、读取 GHES 结构中传递的 Error Status Address。首先将读到的 struct acpi_hest_generic_status 结构拷贝到前面申请的内存中，检测相关错误信息长度是否合法。然后将后面的错误信息拷贝。\n\t\tB、如上报错误的严重级别大于 GHES_SEV_PANIC，则将错误信息打印，清除错误状态以及记录错误信息的内存块。然后进入 kernel panic。\n\t\tC、调用 ghes_do_proc 函数处理错误。这个函数中，获取错误数据块中各 section 中 section_type 以及 error_severity。同时判断 fru_id 和 fru_text 字段是否有效。 1>如为内存相关错误，以下为错误类型分类\n\t* @ `HW_EVENT_ERR_CORRECTED`: Corrected Error - 表示检测到 ECC 纠正的错误\n\t* @ `HW_EVENT_ERR_UNCORRECTED` : 表示 ECC 无法纠正的错误，但不是致命的错误 (可能是在未使用的内存区域，或者内存控制器可以从中恢复，例如，通过重新尝试操作)\n\t* @ `HW_EVENT_ERR_DEFERRED`:  Deferred Error - 表示处理不紧急的不可纠正的错误。这可能是由于硬件数据中毒，系统可以继续操作，直到中毒的数据被消耗。也可以采取主动的措施，例如，offlining 页面等。\n\t* @ `HW_EVENT_ERR_FATAL`: 致命错误-无法恢复的不可更正错误。\n\t* @ `HW_EVENT_ERR_INFO`: 规范定义了第四种类型的错误: 信息日志。\n   首先获取 struct cper_sec_mem_err 数据块。调用\n\t`Ghes_edac_report_mem_error` 函数，这个函数中，将错误信息中包括错误类型，错误地址，内存颗粒，错误内存位置填充到错误报告 buffer 中（struct edac_raw_error_desc）。\n\t错误类型如下:\n\t![](attachments/edac_error.png)\n\t把错误写到 ftrace 的一个跟踪项中，最后调用 `edac_raw_mc_handle_error`\n\t分别通过 `edac_ce_error` 处理 ECC 类型的错误以及调用 `edac_ue_error` 处理其他错误。 \n\t最后调用 `ghes_handle_memory_failure`，\n\t如果\n\t- 错误级别为可修复级别且 `CPER_SEC_ERROR_THRESHOLD_EXCEEDED` 置位（表示内核中止使用这个资源）\n\t- 错误是可恢复的类型。满足上述条件之一则调用 `memory_failure_queue` 函数。这个函数在检测到页面的硬件内存损坏时由硬件错误处理程序调用。它调度错误页面的恢复，包括删除页面，杀死进程等。\n\n   **如为 pcie aer 错误**\n   PCIe AER 错误需要发送到 AER 驱动程序进行报告和恢复。GHES 的严重程度与以下 AER 严重程度相对应，并需要进行以下处理:\n    - GHES_SEV_CORRECTABLE -> AER_CORRECTABLE  --- 需要由 AER 驱动报告，但不需要恢复。\n    - GHES_SEV_RECOVERABLE -> AER_NONFATAL\n    - GHES_SEV_RECOVERABLE && CPER_SEC_RESET -> AER_FATAL\n   这两种情况都需要 AER 驱动报告和恢复。\n   `GHES_SEV_PANIC` 不会进行这种处理，因为内核必须将进入 panic 状态。\n\n (2) 如果为外部中断，则通过 GHES 中传递的中断号，申请中断处理函数，在中断处理函数 `ghes_irq_func` 调用 `ghes_proc`。下面的处理流程和上面轮询一致。\n (3) 同样的如果为 SCI 中断，调用 notifier_call 回调函数 ghes_notify_hed，遍历 ghes_hed 链表，分别执行 ghes_proc 函数，处理错误\n (4) 如果为 NMI 中断，处理错误级别大于 `GHES_SEV_PANIC`，则直接 kernel panic。否则如配置 `CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG`，则调到工作队列处理函数 `ghes_proc_in_irq` 中。执行相当于下半部的处理过程。最终调用 `ghes_do_proc` 函数执行上述相关错误的处理。\n\n```erlang\n-+ ghes_probe(platform_device* ghes_dev)\n \\ - acpi_hest_generic *generic = ghes_dev->dev.platform_data;\n | -+ switch (generic->notify.type)\n    \\ -|+ case ACPI_HEST_NOTIFY_POLLED:\n        \\ -+ ghes_add_timer(ghes);\n    | -|+ case ACPI_HEST_NOTIFY_EXTERNAL:\n        \\ -+ acpi_gsi_to_irq(generic->notify.vector, &ghes->irq);\n        | -  request_irq(ghes->irq, ghes_irq_func, IRQF_SHARED, \"GHES IRQ\", ghes); \"申请中断. 中断处理函数为 ghes_irq_func\"\n    | -|+ case ACPI_HEST_NOTIFY_SCI ACPI_HEST_NOTIFY_GSIV ACPI_HEST_NOTIFY_GPIO\n\t    \\ -  register_acpi_hed_notifier(&ghes_notifier_hed); \n\t\t        \"`register_acpi_hed_notifier`是一个用于注册ACPI HED（Hardware Error Device）通知的函数。\n\t\t        HED是一种ACPI设备，用于监测硬件错误并报告给操作系统。HED通知允许内核注册一个回调函数，\n\t\t        当硬件错误发生时，内核会调用这个回调函数来处理错误。\"\n        | -  list_add_rcu(&ghes->list, &ghes_hed);\n    | -|+ case ACPI_HEST_NOTIFY_SEA:\n\t\t    \"`ACPI_HEST_NOTIFY_SEA`表示SEA（Software Error Announcement）错误通知类型。\n\t\t    当系统中的硬件出现错误时，硬件错误设备（Hardware Error Device，HED）可以使用SEA通知类型向操作系统报告错误信息。\n\t\t    SEA通知类型用于通知操作系统发生了一个由硬件处理的错误事件，并提供相关的错误信息。\"\n        \\ -+ ghes_sea_add(ghes);\n           \\ -  list_add_rcu(&ghes->list, &ghes_sea);\n    | -|+ case ACPI_HEST_NOTIFY_NMI:\n\t\t     \"`ACPI_HEST_NOTIFY_NMI`表示NMI（Non-Maskable Interrupt）错误通知类型。\n\t\t     当系统中的硬件出现严重的错误时，硬件错误设备（Hardware Error Device，HED）可以使用NMI通知类型向操作系统发出NMI中断，\n\t\t     以通知操作系统发生了一个严重的硬件错误事件。\"\n        \\ -+ ghes_nmi_add(ghes);\n           \\ -+ register_nmi_handler(NMI_LOCAL, ghes_notify_nmi, 0, \"ghes\");\n              \\ ---+ ghes_notify_nmi(cmd, regs)\n\t\t\t\t   \\ -+ ghes_in_nmi_spool_from_list(&ghes_nmi, FIX_APEI_GHES_NMI)\n\t\t\t\t\t  \\ -+ list_for_each_entry_rcu(ghes, rcu_list, list)\n\t\t\t\t\t\t \\ -+ ghes_in_nmi_queue_one_entry(ghes, fixmap_idx) \n\t\t\t\t\t\t\t\t\"将 GHES 错误信息封装成一个 NMI 消息，\n\t\t\t\t\t\t\t\t并将该消息推入 NMI 队列。之后，当系统处理 NMI 中断时，\n\t\t\t\t\t\t\t\t可以调用注册的 GHES 错误处理回调函数，从而处理 GHES 错误。\"\n\t\t\t\t\t\t    \\ -+ sev = ghes_severity(estatus->error_severity); \"获取严重级别\"\n\t\t\t\t\t\t\t   \\ -|+ if sev >= GHES_SEV_PANIC \"错误级别 > panic\"\n\t\t\t\t\t\t\t\t   \\ -  __ghes_panic(ghes, estatus, buf_paddr, fixmap_idx);  \"调用panic\"\\\n\t\t\t\t\t\t\t| - \"构造 estatus_node, 从ghes 数据中获取 \"\t   \n\t\t\t\t\t\t    | -+ llist_add(&estatus_node->llnode, &ghes_estatus_llist); \n\t\t\t\t\t\t         \"加入全局链表 ghes_estatus_llist 中\"\n\t\t\t\t\t\t         \"该链表在 ghes_proc_in_irq 中处理\"\t\t\t\t\t\t            \n    | -|+ case ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED:\n             \"`ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED`表示软件委派错误通知类型。\n             当系统中的硬件出现错误时，硬件错误设备（Hardware Error Device，HED）可以使用软件委派通知类型向操作系统报告错误信息。\n             这种通知类型允许硬件错误设备将错误信息委托给操作系统的特定软件模块来处理，而不是直接由硬件设备进行错误处理。\"\n        \\ -+ apei_sdei_register_ghes(ghes);\n           \\ -+ sdei_register_ghes(ghes, ghes_sdei_normal_callback, ghes_sdei_critical_callback); \n                  \"往下指向 arch 实现, 如 arm的 sdei_register_ghes 函数 drivers/firmware/arm_sdei.c\"\n              \\ ---+ ghes_sdei_normal_callback \"回调\"\n                   \\ -+ __ghes_sdei_callback(ghes, FIX_APEI_GHES_SDEI_NORMAL);\n                      \\ -+ irq_work_queue(&ghes_proc_irq_work); \n                           \"中断处理程序中调用`irq_work_queue`函数，将IRQ工作推入队列，\n                           从而在合适的时机执行所需的工作。\n                           即中断下半部的处理, 处理函数为 ghes_proc_in_irq\"\n                         \\ ---+ init_irq_work(&ghes_proc_irq_work, ghes_proc_in_irq);\n```","tags":["ras"],"categories":["RAS"]},{"title":"安全相关策略","url":"/2023/05/09/hxd_new/riscv调研/安全/安全相关策略/","content":"\n1. Crypto Acceleration: Not only for speed, but code protection\n2. True Random-Number Generators\n3. Memory Encryption: No leak from external bus!\n4. Secure Boot\n5. Trusted Execution Environment: RISC-V PMP IOPMP / Virtual Zone\n6. Tamper Pins Detection: Detect unauthorized opening or tampering\n7. Bus Monitors: Advanced hardware security\n8. hsm Hardware Secure Modules\n\n# secure boot\n\nChain of Trust:\n- bootrom (ZSBL)\n- spl (FSBL)\n- opensbi\n- u-boot\n- kernel\n- rootfs\n- system\nbootrom spl opensbi u-boot kernel rootfs 之间形成链式校验\n> spl opensbi u-boot kernel rootfs 需要进行加密并加签, 在启动过程中需要解密并验签\n\nsystem 采用dm-verity 校验.\n之间可以引入hsm 进行算法加密和校验请求\n\n![](attachments/Pasted%20image%2020230210104557.png)\n\nThe main services and features of the secure boot code are:\n• Provides a Root of Trust for the SoC\n• Initiates a Chain of Trust for the SoC\n• Performs the First-Stage Boot Loader (FSBL) digital signature validation\n• Supports Device Identifier Composition Engine (DICE)\n• Guarantees Post-Quantum Cryptography (PQC) crypto-agility\n• Proposes a secure exchange protocol for code/data programming, tests, and key provi-sioning services\n• Proposes a secure boot code secure patch mechanism\n• Considers domestic cryptographic requirements\n• Complies with good practices and security standards\n• Provides high flexibility in the proposed options above (enable/disable)\n\n\nHardware Mechanisms and Requirements\nRequirements:\n• The secure boot code MUST be stored in the SoC internal ROM\n• The secure boot code MUST boot the FSBL in less than boot-time ms\n• The size for the ROM containing the secure boot code MUST be at least 64KB\n• The secure boot code MUST be ready for PQC crypto-agility\n• The public keys MUST be stored in the OTP\n• The OTP size MUST be at least 2KB (for ECDSA, more if RSA) for the secure boot code\n• The OTP size MUST be at least 4KB for crypto-agility\n• The OTP controller MUST be able to grant/revoke read-and-write access privileges\n◦ For all or parts of the OTP\n◦ The DICE UDS read access MUST be deactivable by the secure boot code\n◦ The DICE UDS write access MUST be disabled\n• The OTP read/write access privileges MUST be based on time condition\n◦ For all or parts of the OTP\n• The OTP read/write access privileges MAY be based on authentication conditions\n◦ For all or parts of the OTP\n• The secure boot code MUST support the ECDSA p384/SHA384 digital signature algo-\nrithm\n• The secure boot code MUST support the SM2/SM3 digital signature algorithm\n• The secure boot code MUST support the FALCON digital signature algorithm\n• The secure boot code MAY support the ECDSA p256/SHA256 digital signature algorithm\n• The secure hash SHA-384 implementation MUST be a hardware block (for performance\nrequirements)\n◦ This hardware block MUST be accessible from the core executing the secure boot\ncode\n• The secure hash SM3 implementation MUST be a hardware block (for performance\nrequirements)\n◦ This hardware block MUST be accessible from the core executing the secure boot\ncode\n• The ECDSA and SM2 algorithms MUST have hardware support for performance (e.g.,\nmodular multiplication)\n◦ This hardware block MUST be accessible from the core executing the secure boot\ncode\n• A communication interface MUST be available to the secure boot code, usually a UART\n◦ This interface is used for initial and recovery programming\n• A GPIO MUST be available for triggering the secure communication session\n• The internal RAM size MUST be at least 64KB\n◦ It depends on the size of the applets (a feature used in the communication protocol to\nextend commands; it’s very helpful to simplify the secure boot code)\n• The NVM where the FSBL is located MUST be available to the secure boot code in read\n(for execution) and write (for programming) modes\n• The debug availability policy MUST be specified\n◦ If available, the secure boot code MAY be in charge of enabling it\n• The secure boot code MUST contain anti-fault mechanisms during sensitive computations\n◦ Note: The other subsequent parts of the secure boot process, too\n• The secure boot code software validation MUST assess the robustness against faults\n(and not be only a functional validation)\n• The [rng] (for secure provisioning service) MUST be accessible by the secure boot code\n• A [hash-function] hardware block and a managing FSM MUST be available for secure\nboot code verification before start\n• The secure boot code MUST be in charge of the DICE CDI computation for the FSBL\nusing the UDS from the OTP\n◦ The UDS read access MUST be disabled after CDI computation\n◦ The debug interface MUST NOT be available before UDS read access disabling\n• The secure boot code MUST be written using good practices for secure coding, including\nthose presented in: https://www.ssi.gouv.fr/uploads/2020/05/anssi-guide-regles_de_pro-\ngrammation_pour_le_developpement_securise_de_logiciels_en_langage_c-v1.1.pdf\n• The secure boot code MUST clean any sensitive information contained in the volatile\nmemory after its use\n• The secure boot code MUST support GPT parsing for FSBL image booting\n• The secure boot code MUST implement an anti-rollback protection mechanism\n◦ The anti-rollback mechanism MUST support at least 32 versions\n▪ It requires 128 bytes for version storage\n◦ The anti-rollback mechanism MUST use the internal OTP\n\nDCIE\nDICE是一个用于设备身份、证明和数据加密的行业标准。它要求使用一些加密原语（哈希、HMAC）和每个SoC唯一的256位秘密，命名为UDS。这个UDS必须得到严格的保护，以防止嵌入式软件的任何读取访问。其原理是将一个独特的、可重复的秘钥与设备上运行的每个软件阶段层联系起来。最初的秘钥，也就是与FSBL绑定的秘钥，又称第0层，是由安全启动码使用FSBL的哈希值计算出来的。FSBL可以通过计算下一个CDI，对应于下一个软件阶段（如U-boot）来重现相同的方案，以此类推，直到达到最后一个应用阶段。然后，任何一层都有自己的秘钥（公钥对也可以从CDI中得到）。\n\n\n# Key Management\n\nPublic Keys:\n- SiFive Update Key (SUK)\n\t- This key is owned by SiFive, hardcoded in ROM, and used for the CUK initial pro-gramming using the digital-signature algorithm\n- SiFive Signature Key (SSK)\n\t- This key is owned by SiFive, and used for digital signatures during SXP sessions and the FSBL signature in phase #1, as long as no CUK/CSK has been programmed\n\t- The SSK value is hardcoded in ROM, and is used by default if no other key is pro-grammed in the OTP\n- Customer Update Key (CUK)\n\t- This key is owned by the customer, stored in OTP, and used for the CSK initial pro-gramming, revocation, and update using the digital-signature algorithm\n- Customer Signing Key (CSK)\n\t- This key is owned by the customer, stored in OTP, and, with its signature by the CUK, is used for the SXP sessions signatures, the FSBL signature using the digital-signature algorithm, and some secure debug data signatures\n- Debug Protection Key (DPK)\n\t- This key is owned by the customer, stored in OTP, and used for the secure debug authentication protocol, using the digital-signature algorithm\n- PQC Customer Signing Key (pqc-CSK)\n\t- This key is owned by the customer, stored in NVM, signed with the pqc-CUK, and, with its hash stored in OTP, is used for the SXP sessions signatures and the FSBL signature using the pqc-digital-signature algorithm, addressing crypto-agility\n- PQC Customer Update Key (pqc-CUK)\n\t- This key is owned by the customer, stored in NVM, and, with its hash stored in OTP, is used for the pqc-CSK initial programming, revocation, and update using the pqc-digital-signature algorithm, addressing crypto-agility\n- PQC Debug Protection Key (pqc-DPK)\n\t- This key is owned by the customer, stored in NVM, signed with the pqc-CUK, and, with its hash stored in OTP, is used for the secure debug authentication protocol using the pqc-digital-signature algorithm, addressing crypto-agility\n\nPrivate Key Pairs:\n- ECC Key Pair (ECCK)\n\t- This [asymmetric-encryption] public key pair is owned by the customer, stored in OTP, unique per SoC, and in the read-controlled area for FSBL image decryption key encapsulation\n\nSymmetric Keys:\n- Firmware Encryption Key (FEK)\n\t- This [encryption-algorithm] secret key is owned by the customer, unique per SoC, stored in OTP, and in the read-controlled area for SXP sessions and FSBL image decryption\n- Unique Device Secret (UDS)\n\t- The UDS is a DICE initial secret value, owned by the customer, unique per SoC, stored in OTP, and in the read-controlled area, for DICE FSBL (layer0) CDI computation","tags":["secure boot"],"categories":["安全"]},{"title":"qemu scsi 磁盘直通","url":"/2023/04/09/hxd_new/虚拟化/qemu scsi 磁盘直通/","content":"\n# 概述\nvirtio-scsi 提供了直接连接 SCSI LUN 的能力，并且也提供了继承目标设备特性的能力：\n通过 virtio-scsi 控制器连接的虚拟硬盘或 CD，可以从 host 主机通过 QEMU scsi-block 设备实现物理 SCSI 设备的直通 (pass-through)，这样就可以实现每个 guest 使用上百个设备，也提供了极高的存储性能。\n\nguest 与 host 链路:\nguest: app -> 文件系统-> Block Layer -> SCSI Layer -> scsi_mod\nhost:  SCSI Layer -> Block Device Driver -> Hardware\n\n前端 后端\nvirtio-scsi---qemu virtio-scsi\nvirtio-scsi---kernel vhost-scsi\n\n# 直通方式 \n\n## kernel vhost-scsi\n\nQEMU负责对该PCI设备的模拟，只是把来自virtqueue的数据处理逻辑拿到内核空间了。QEMU需要告知内核vhost-scsi模块关于virtqueue的内存信息及Guest的内存映射，这样其实省去了Guest到QEMU用户态空间，再到宿主机内核空间多次数据复制； 但是，将queue的ID写到PCI配置空间的这步操作还是存在。\n\n![image-20240416111040666](attachments/image-20240416111040666.png)\n\n## 通过vfio-pci直接进行SATA控制器直通\n\n所有PC上的SATA控制器都在PCI总线上运行。您可以插入备用SATA控制器并通过它。所有连接的磁盘将直接传递给客户机。该解决方案几乎没有延迟或开销，并提供了最高的吞吐量。该解决方案的缺点是您将需要专门用于VM的第二个SATA控制器。来宾运行时，主机上的磁盘也将不可用。\n\n![image-20240416111048252](attachments/image-20240416111048252.png)\n\n通过vfio-pci直接NVMe驱动器直通\n\n与SATA控制器直通相似，通过NVMe驱动器也有助于提高性能。实际上，由于NVMe驱动器的疯狂吞吐量，性能提升甚至更高。开销也很低。\n后端qemu直接对接宿主机上的块设备，不经过文件系统。但是这样的性能和中间有文件系统来对比，差别不会很大。\n\n# virtio-scsi\n\nvirtio-scsi功能是一个新的准虚拟化的SCSI控制器设备。它是KVM Virtualization的另一种存储实现的基础，它取代了virtio-blk，并改进了它的能力。它提供了与virtio-blk相同的性能，并增加了以下直接的好处。\n- 提高可扩展性--虚拟机可以连接到更多的存储设备（virtio-scsi可以处理每个虚拟SCSI适配器的多个块设备）。\n- 标准命令集virtio-scsi使用标准SCSI命令集，简化了新特征的添加。\n- 命名为virtio-scsi磁盘的标准设备使用与裸机系统相同的路径。这简化了物理到虚拟和虚拟到虚拟的迁移。\n- SCSI设备直通式virtio-scsi可以直接向guest 提供物理存储设备。\nVirtio-SCSI提供了直接连接到SCSI LUN的能力，与virtio-blk相比，显著提高了可扩展性。virtio-SCSI的优点是它能够处理数百个设备，而virtio-blk只能处理大约30个设备并耗尽PCI插槽。旨在取代virtio-blk，virtio-scsi保留了virtio-blk的性能优势，同时提高了存储的可扩展性，允许通过一个控制器访问多个存储设备，并使客户操作系统的重用成为可能。\n\npass-through the SCSI messages from the virtual machine kernel directly to the real device (virtio-scsi back end)\nThe virtio-scsi back end allows the guest to directly send SCSI requests back to the real device. \n![image-20240416111054089](attachments/image-20240416111054089.png)\nAll SCSI commands responses are sent by the real device, passing through QEMU. This mechanism allows the guest device to use all the features that the real device implements. Read and write requests from the guest are also sent directly to the real device.\n\n```shell\n-device virtio-scsi-pci,id=scsi0,bus=pci.0,addr=0x2 \\\n-device scsi-block,bus=scsi0.0,channel=0,scsi-id=0,lun=2,drive=drive-scsi0-0-0-2,id=scsi0-0-0-2 \\\n-drive file=/dev/disk/by-id/scsi-3600605b000a2c110ff0004053d84a61b,format=raw,if=none,id=drive-scsi0-0-0-2,cache=none\n```\n\n当fd有信号之后会唤醒eventfd等待队列上的对象，这里会执行vhost_poll_wakeup函数，该函数把work挂到vhost_dev的work_list中，然后唤醒vhost_dev的work线程，也就是在绑定用户态进程时创建的线程，vhost_scsi_handle_kick\n\n```c\n\tvs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;\n\tvs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;\n\tfor (i = VHOST_SCSI_VQ_IO; i < VHOST_SCSI_MAX_VQ; i++) {\n\t\tvqs[i] = &vs->vqs[i].vq;\n\t\tvs->vqs[i].vq.handle_kick = vhost_scsi_handle_kick;\n\t}\n```\nqemu 通过 vhost_dev_enable_notifiers -> virtio_bus_set_host_notifier 对几个vq绑定了ioeventfd, \n\nguest os觉得有必要通知host对virtqueue上的请求进行处理，就会执行`vp_notify()`，相当于执行一次port I/O（或者mmio），虚拟机则会退出guest mode, 由kvm 处理guest store execption, kvm先判断自己能不能处理, 即查对应的mmio 区间是否注册了对应的处理函数, 这个地方由于ioeventfd的注册过程中注册了对应mmio的处理函数为 `ioeventfd_write`, 该函数给对应的fd发信号, 而vq上的poll返回后调用响应的handle_kick, 此处vhost-scsi 内核模块最终响应 `vhost_scsi_handle_kick` 函数处理vq, vq中封装的是scsi message. host 将scsi message 下发给hardware.\n\nqemu virtio-scsi方案的演进，块设备模拟仍然是由qemu来做，只是把virtio backend放到了host kernel中，由kernel去处理virtqueue。 host kernel要处理virtqueue需要知道地址，因此qemu会把virtqueue的内存信息和guest的GPA-HVA的映射告知内核vhost-scsi模块，host kernel直接接收virtqueue中的请求并下发到后端，缩短了io路径，省去了host上用户态到内核态的拷贝\n\n存储栈: \nguest os:  文件系统层 -> 块设备层(block layer) -> scsi层(virtio-scsi 后端) \nhost os:   scsi层 (vhost-scsi) -> hardware驱动 -> hardware\n\n这里的直通是 通过 virtio-scsi -- vhost-scsi 模拟了传统存储栈中的scsi layer, 替代了 scsi upper midi layer的功能, 创建出了 lun, lun是接收scsi cmd的实体, 每个lun需要有一个实体的hardware的驱动, 如对应sata设备会加载sd公版驱动.\n上述scsi cmd最终转发到sd驱动中.\n\n# 总结\n非PCI方式的完整块设备映射，还是借助了virtio半虚拟化；\n走PCI方式的直通, 通过vfio-pci实现的直接sata控制器直通和直接NVMe驱动器直通，这两种是真正意义上的passthrough，宿主机需要开启IOMMU；另外，需要对磁盘做vfio相关的配置，才能最终提供给虚机使用。\n\n综上，\n\n从virtio半虚拟化出发，为提高本地盘性能，可以将后端qemu virtio-scsi，替换为kernel vhost-scsi. 这种方式并未真正的直通, guest os的设备中断和数据请求都需要经过kvm, 这里所谓的直通只是将数据封装形式从之前的文件系统的消息转变为了scsi message, 该message 需要借助virtio 的vq在前后端(virtio-scsi -- vhost-scsi)之间传递, 由这两个脚手架模拟了传统存储栈中的scsi layer.\n存储栈参考 https://blog.csdn.net/Wang20122013/article/details/122090135\n\n从直通方式提升性能，可以使用通过vfio-pci实现的直接sata控制器直通和直接NVMe驱动器直通这两种。\n\n","tags":["qemu","scsi"],"categories":["qemu"]},{"title":"qemu 镜像启动相关实验","url":"/2023/04/09/hxd_new/虚拟化/qemu 镜像启动相关实验/","content":"\n\n# 多分区镜像如何挂载\n\n利用mount -o offset选项进行挂载。即偏移地址。\n```shell\nsudo mount -v -o offset=1048576 -t vfat sdimage.img ~/mount/boot/\n```\nUnits: sectors of 1 * 512 = 512 bytes\n一个扇区为512bytes。\n\n```shell\nsudo fdisk -l starfive-jh7110-VF2_515_v2.5.0-69-minimal-desktop.img\nDevice                                                  Start     End Sectors  Size Type\nstarfive-jh7110-VF2_515_v2.5.0-69-minimal-desktop.img1   2048   34815   32768   16M Linux filesystem\nstarfive-jh7110-VF2_515_v2.5.0-69-minimal-desktop.img2  34816  239615  204800  100M EFI System\nstarfive-jh7110-VF2_515_v2.5.0-69-minimal-desktop.img3 239616 3479518 3239903  1.6G Linux filesystem\n```\n\n如挂载第三个分区\noffset =  239616 * 512 \n\n```shell\nsudo mount -o offset=122683392 starfive-jh7110-VF2_515_v2.5.0-69-minimal-desktop.img test_mnt_dir \n```\n\n# qcow2 格式\n\n## 制作\n\n```shell\nqemu-img create -f qcow2 image.qcow2 1G\n```\n\n## 挂载\n\n```shell\nsudo qemu-nbd --connect=/dev/nbd0 image.qcow2\n```\n\nconnect 后, 如果该镜像中有分区的话, 需要等几秒中, 等分区节点出来\n> connect 时注意该镜像文件未被使用, 否则后续步骤会有问题\n\n创建分区\n```shell\nsudo fdisk /dev/ndb0\nn p 选start sector 回车  选end sector 回车 w 保存\n```\n创建文件系统\n```shell\nsudo mkfs.ext4 /dev/nbd0p1\n```\n\n```shell\nsudo fdisk -l /dev/nbd0\nDisk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: gpt\nDisk identifier: 664E2EB5-C2C5-414B-AFBC-A422A6627DC8\n\nDevice      Start      End  Sectors Size Type\n/dev/nbd0p1   128 20971392 20971265  10G Linux filesystem\n```\n\n```shell\nsudo fdisk -l /dev/nbd0\nsudo mount /dev/nbd0p1 mnt_dir\n```\n> 系统只有一个loop设备时, 需要将其他的loop设备卸载后, 才能挂载该节点\n> \n## 卸载\n修改里面的文件修改完后, 要及时卸载\n```shell\nsudo umount mnt_dir\nsudo qemu-nbd --disconnect /dev/nbd0\n```\n\n# u-boot extlinux\n\n## conf\n\n```shell\nlabel l0\n\tmenu label Debian GNU/Linux bookworm/sid 6.0.0-6-riscv64 # menu 显示项\n\tlinux /boot/vmlinux-6.0.0-6-riscv64                      # 内核\n\tinitrd /boot/initrd.img-6.0.0-6-riscv64                  # ramdisk\n\tfdtdir /boot/dtbs/                                       # dtb \n\tappend root=LABEL=rootfs rw noquiet root=LABEL=rootfs    # rootfs\n```\n\n注意下面几项:\n\n### initrd \n```shell\nfile initrd.img-6.0.0-6-riscv64\ninitrd.img-6.0.0-6-riscv64: gzip compressed data, was \"mkinitramfs-MAIN_aDjhxR\", last modified: Sun Jan  8 06:50:27 2023, from Unix\n```\n\nLinux kernel提出了一个RAM disk的解决方案，把一些启动所必须的用户程序和驱动模块放在RAM disk中，这个RAM disk看上去和普通的disk一样，有文件系统，有cache，内核启动时，首先把RAM disk挂载起来，等到init程序和一些必要模块运行起来之后，再切到真正的文件系统之中。\n\n查看initramfs的内容\n```shell\nmkdir initrdtmp && cd initrdtmp\nzcat ../initrd.img-6.0.0-6-riscv64 ../initrd.img-6.0.0-6-riscv64.gz|cpio -i --make-directories\n```\n\ninitrd 不一定非得用 `mkinitramfs` 来制作, 使用制作busybox 时的 `cpio -H newc` 也是可以的\n\n```shell\nfind .| cpio -o -H newc | gzip > ../busybox_rootfs.cpio.gz\n```\n\n### linux\n\n支持 bzImage Image 格式编译出来的vmlinux elf\n\n### fdtdir\n\nfdtdir 指定 dtb的目录, 一般名字会根据Machine 参数指定\n需要注意dtb 一定是匹配的.\nqemu 使用时, 可以使用下面的命令生成对应的 dtb 文件, 注意cpu 内存 machine的配置要和 qemu 启动虚拟机的命令指定的参数一致\n```shell\nsudo qemu-system-riscv64 -machine virt,dumpdtb=qemu-riscv.dtb -cpu rv64 -m 2G -smp 2\n```\n\n### append\n\n指定kernel cmdline\n如 rootfs 启动, rootfs 在 /dev/mmcblk1p3 节点\n```shell\nappend root=/dev/mmcblk1p3 rw console=tty0 console=ttyS0,115200 init=/init\n```\n\n如qemu 启动, 在指定hda 等参数后, 生成的节点一般是vda\n则使用下面的配置即可\n```shell\nappend root=/dev/vda rw init=/init #或rdinit=/linuxrc\n```\n\n本根分区启动, 适用于只有一个分区的情况:\n\n```shell\nappend root=LABEL=rootfs rw noquiet\n```\n# u-boot 编译\n\n注意一定是 S-mode的, 别选错了\n```shell\nmake qemu-riscv64_smode_defconfig O=virt_build\nmake O=virt_build -j12\n```\n\n\n\n\n","tags":["qemu"],"categories":["实验"]},{"title":"qemu usb 设备直通","url":"/2023/04/09/hxd_new/虚拟化/usb 设备直通/","content":"\n### USB控制器类型\n\n简单地讲，OHCI、UHCI都是USB1.1的接口标准，**而EHCI是对应USB2.0的接口标准**，**最新的xHCI是USB3.0的接口标准**。\n\n-   OHCI（Open Host Controller Interface）是支持USB1.1的标准，但它不仅仅是针对USB，还支持其他的一些接口，比如它还支持Apple的火线（Firewire，IEEE 1394）接口。与UHCI相比，OHCI的硬件复杂，硬件做的事情更多，所以实现对应的软件驱动的任务，就相对较简单。主要用于非x86的USB，如扩展卡、嵌入式开发板的USB主控。\n-   UHCI（Universal Host Controller Interface），是Intel主导的对USB1.0、1.1的接口标准，与OHCI不兼容。UHCI的软件驱动的任务重，需要做得比较复杂，但可以使用较便宜、较简单的硬件的USB控制器。Intel和VIA使用UHCI，而其余的硬件提供商使用OHCI。\n-   EHCI（Enhanced Host Controller Interface），是Intel主导的USB2.0的接口标准。EHCI仅提供USB2.0的高速功能，而依靠UHCI或OHCI来提供对全速（full-speed）或低速（low-speed）设备的支持。\n-   xHCI（eXtensible Host Controller Interface），是最新最火的USB3.0的接口标准，它在速度、节能、虚拟化等方面都比前面3中有了较大的提高。xHCI支持所有种类速度的USB设备（USB 3.0 SuperSpeed, USB 2.0 Low-, Full-, and High-speed, USB 1.1 Low- and Full-speed）。xHCI的目的是为了替换前面3中（UHCI/OHCI/EHCI）。\n\n# usb 层级\n用lsusb -t还可以看到USB设备的层级关系\n```shell\n[root@localhost xqk]# lsusb -t\n/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/2p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/8p, 480M\n        |__ Port 1: Dev 3, If 0, Class=Mass Storage, Driver=usb-storage, 480M\n\n\nBus 02.Port 1\n    表示第二个USB主控制器，Port号为1\n    \nDev 1, Class=root_hub\n    分配的设备号为1，类型是root_hub\n    \nDriver=ehci-pci/2p\n    root_hub的类型是ehci（usb 2.0），总共有两个port\n    \n|__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/8p, 480M\n    root_hub的其中一个port有个Hub设备，port的id是1，此Hub有8个port。\n    \n    |__ Port 1: Dev 3, If 0, Class=Mass Storage, Driver=usb-storage, 480M  \n    Hub的其中一个port有大容量USB设备，port的id为1.3（树状结构，依次以.作为低一级设备成员）\n```\n\n# USB设备直通\n\n虚拟机使用USB设备可以通过两种方式：\n- PCI 设备直通\n\n\tPCI usb card, 直接将 usb controller 直通给虚拟机\n- 设备直通\n\n这里重点说下非PCI方式的usb 设备直通\nqemu支持hostaddr，hostport以及vendorid，productid等信息的组合, 相对于libvirt，多了hostport的支持，hostport即是主机usb的port。\n```\n  (1) vendorid+productid -- match for a specific device, pass it to\n      the guest when it shows up somewhere in the host.\n\n  (2) hostbus+hostport -- match for a specific physical port in the\n      host, any device which is plugged in there gets passed to the\n      guest.\n\n  (3) hostbus+hostaddr -- most useful for ad-hoc pass through as the\n      hostaddr isn't stable, the next time you plug in the device it\n      gets a new one ...\n```\n\n## 注意点\n\n-   devnum会变化\n    在host上同一个USB口上插拔U盘，会导致devnum的变化（增加），而port对应于USB的物理口，不会随着插拔U盘而变化，但是libvirt不支持传入port，只能自己适配开发。\n-   是否需要开启vt-d iommu\n    通常情况下，直通物理设备（PCI）时需要开启vt-d，USB设备有些不同，USB设备是由controller控制，而各种类型的控制器都是qemu模拟的，只不过最终直接打开物理机上的USB设备而已，数据还是由qemu控制。因此USB设备直通不需要开启vt-d iommu。\n-   No free USB ports\n    模拟的控制器对应的port数量有限，如果要直通多个USB设备，就会造成port数目不够。piix3-uhci有两个port，ehci与nec-xhci有6个port（一般够用）。当数目不够时，可以添加hub设备来增加额外的port。\n    ```\n     <hub type='usb'/>\n    ```\n    hub设备包含8个port。\n\n-   不要直通主机hub设备\n    主机上的root_hub以及hub直通给虚拟机没有任何意义，一方面虚拟机中的root_hub是模拟控制器自带的，而hub是需要单独添加hub设备，另一方面直通hub设备，虚拟机占用主机hub，会导致主机上hub下的USB设备不可用。\n\n# qemu usb 非PCI 直通解读\n\n>qemu默认不支持 usb-host, 需要在编译时打开 `--enable-libusb` 编译, 依赖libusb 库.\n\n按上一章的参数介绍, 简单看下代码结构\n注意\n>USB设备是由controller控制，而各种类型的控制器都是qemu模拟的，只不过最终直接打开物理机上的USB设备而已，数据还是由qemu控制\n\nqemu 命令行方式添加usb 直通设备\n```shell\n -device usb-host,hostbus=BUS,hostaddr=ADDR,id=[hostdev0]\n -device usb-host,vendorid=VID,productid=PRID,id=[hostdev0]\n # 对应lsusb的Bus xxx, Device xxx\n```\n>注意上述命令需要以 sudo 运行 qemu 命令, 否则libusb 库无法打开给usb设备.\n\n添加这个设备后, 最终会走到 TYPE_USB_HOST_DEVICE 设备的具现化函数中\nTYPE_DEVICE -> TYPE_USB_DEVICE -> TYPE_USB_HOST_DEVICE\n\n```erlang\n-+ usb_host_realize(USBDevice *udev, Error **errp)\n \\ -  ldev = usb_host_find_ref(s->match.bus_num, s->match.addr);\n      \"libusb 库函数查找 hostbus, hostaddr 匹配的usb设备\"\n | -+ usb_host_open(s, ldev, 0);\n    \\ -  bus_num = libusb_get_bus_number(dev); addr = libusb_get_device_address(dev);\n         s->dev     = dev;\n         s->bus_num = bus_num;\n         s->addr    = addr;\n    \\ -+ usb_host_detach_kernel(s);\n       \\ -  libusb_detach_kernel_driver(s->dh, i); \"从主机中解绑\"\n    | -  USBDevice *udev = USB_DEVICE(s);\n    | -  usb_ep_init(udev);\n    | -+ usb_host_ep_update(s); \"将设备绑定到 qemu 模拟的usb controller 上\"\n       \\ -  libusb_get_active_config_descriptor(s->dev, &conf);\n       | -+ for i in conf->bNumInterfaces \"遍历接口描述符\"\n          \\ -  intf = &conf->interface[i].altsetting[0];\n\t      \\ -+ for e in intf->bNumEndpoints \"遍历端点描述符\"\n\t         \\ -  endp = &intf->endpoint[e];\n\t         | -  devep = endp->bEndpointAddress;\n\t         | -  pid = (devep & USB_DIR_IN) ? USB_TOKEN_IN : USB_TOKEN_OUT; \"是in 端点还是 out端点\"\n\t         | -  ep = devep & 0xf;\n\t         | -  \n    | -+ usb_device_attach(udev, &local_err);\n       \\ -  USBPort *port = udev->port;\n       | -+ usb_attach(port);\n          \\ -  USBDevice *dev = port->dev;\n          | -  port->ops->attach(port); \"usb controller 注册的port, 如usb2.0 ehci\"\n          | -  dev->state = USB_STATE_ATTACHED;\n          | -+ usb_device_handle_attach(dev);\n             \\ -  klass->handle_attach(dev);  \"按设备类型进行, 不一定实现了这个方法\"\n```\n\n这里重点说下 `port->ops->attach(port)` , 这个是由 qemu 模拟的usb controller 注册的port, 这里以usb2.0 的ehci 看下注册过程\n\n```c\nvoid usb_ehci_realize(EHCIState *s, DeviceState *dev, Error **errp)\n{\n    for (i = 0; i < s->portnr; i++) {\n        usb_register_port(&s->bus, &s->ports[i], s, i, &ehci_port_ops,\n                          USB_SPEED_MASK_HIGH);\n        s->ports[i].dev = 0;\n    }\n}\nstatic USBPortOps ehci_port_ops = {\n    .attach = ehci_attach,\n    .detach = ehci_detach,\n    .child_detach = ehci_child_detach,\n    .wakeup = ehci_wakeup,\n    .complete = ehci_async_complete_packet,\n};\n```\n\n所以 `port->ops->attach(port)` 指向了 `ehci_port_ops.ehci_attach`, 重点看下这个函数\n```c\nstatic void ehci_attach(USBPort *port)\n{\n    EHCIState *s = port->opaque;\n    uint32_t *portsc = &s->portsc[port->index];\n    const char *owner = (*portsc & PORTSC_POWNER) ? \"comp\" : \"ehci\";\n    ...\n    *portsc |= PORTSC_CONNECT;\n    *portsc |= PORTSC_CSC; //该位表示 bus 上接入usb 设备\n    -+ ehci_raise_irq(s, USBSTS_PCD); \n               // 给guest 发送中断, 通知guest usb设备接入了, USBSTS_PCD 为usb的特定中断类型\n     \\ ---+ qemu_set_irq(s->irq, level); \n}\n\nstatic void usb_ehci_sysbus_realize(DeviceState *dev, Error **errp)\n{\n    SysBusDevice *d = SYS_BUS_DEVICE(dev);\n    EHCISysBusState *i = SYS_BUS_EHCI(dev);\n    EHCIState *s = &i->ehci;\n    usb_ehci_realize(s, dev, errp);\n    sysbus_init_irq(d, &s->irq); \"中断的注册在这里\"\n}\n```\n\n```c\n    memory_region_init_io(&s->mem_opreg, OBJECT(dev), &ehci_mmio_opreg_ops, s,\n                          \"operational\", s->portscbase);\ns->async_bh = qemu_bh_new(ehci_work_bh, s);\nstatic void ehci_opreg_write(void *ptr, hwaddr addr,\n                             uint64_t val, unsigned size) {\n    ...\n    qemu_bh_schedule(s->async_bh);\n}\nstatic void ehci_work_bh(void *opaque) {\n   -+ ehci_advance_async_state(ehci);\n    \\ -+ ehci_advance_state(EHCIState *ehci, int async)\n       \\ -+ ehci_state_execute(q);\n          \\ -+ ehci_execute\n             \\ -+ usb_handle_packet(p->queue->dev, &p->packet);\n                \\ -+ usb_process_one(p);\n                   \\ -+ usb_device_handle_data(dev, p);\n                      \\ -+ klass->handle_data(dev, p);\n                         \\ -+ usb_host_handle_data(dev, p)\n                            \\ -  libusb_fill_bulk_transfer()\n                            | -  libusb_submit_transfer(r->xfer);\n}\n```\n从上述过程中可以大概了解到\n1. 传入的usb设备需要先借助libusb 库与host 进行解绑 detach, 此时该usb设备与host就没啥关系了\n2. 与host解绑后, 需要绑定到qemu模拟的usb 控制器上, 由qemu 模拟的usb控制器控制usb设备的行为, usb控制器有MemoryRegion等的设定, 以让 guest 进行io的模拟\n3. 中断相关的仍然是使用的qemu的虚拟的中断控制器进行中断的触发\n4. 数据流中最终起作用的是 usb 设备的ep 端点, 最终数据流通过 `libusb_*_transfer` 等数据相关的接口以ep参数控制对应的端点进行发送接收数据.","tags":["qemu","usb"],"categories":["usb"]},{"title":"虚拟化技术简介.md","url":"/2023/04/02/hxd_new/riscv调研/虚拟化/虚拟化技术简介/","content":"\n## 虚拟化技术概述\n\n### 虚拟机特性:\n\n- 指令模拟 (guest 和 host 可以是不同的isa)\n- 本地指令直接执行( guest 和 host isa是相同的)\n\n### 系统资源虚拟化:\n\n- cpu虚拟化\n- 内存虚拟化\n- io 虚拟化\n\n### 常见的虚拟机软件:\n\n- vmware\n- virtual box\n- Parallels Desktop\n- Xen\n- linux-kvm qemu\n- Xvisor\n\n![image-20240416111454675](attachments/image-20240416111454675.png)\n\n### Hypervisor Virtual Machine Manager(VMM) 的功能\n\n- 控制所有的系统资源(CPU 内存 网络 存储等)\n- 创建虚拟机并分配响应的资源\n- 管理虚拟机的生命周期\n\nVMM 调度程序和操作系统的调度进程类似,  操作系统调度的基本单位是进程/线程, VMM调度的单位是虚拟处理器. 当虚拟cpu被调度到时, VMM调度程序负责将vcpu上下文装载到物理处理器上, 然后vcpu所对应的guest os 指令开始真正被执行. 当时间片用完或虚拟处理器主动让出, 调度程序被触发. 调度程序根据调度策略, 挑选下一个vcpu继续运行.\n与操作系统一样, VMM的调度策略可以有多种, 如平均时间片策略, 或按vcpu的权重分配时间片进行调度等.\n虚拟机之间可以通信, VMM需要实现对应的通信机制, 并向虚拟机提供对应的api(可以是时间通知, 共享内存等), 需要严格的安全权限检查.\n\n虚拟机环境管理包括创建/删除/暂停/查询/迁移等, 由虚拟机管理软件和VMM 管理接口组成.\n\n#### 物理资源的管理\n\n1. 处理器管理\n包括系统启动检测获取所有物理处理器, 对每个处理器进行初始化, 如设置运行模式, 设置页表, 设置中断处理函数等; 将所有的处理器纳入调度序列, 由调度程序对其进行调度. 还支持hot plug, 当有处理器插入时, vmm获得通知, 将其纳入调度序列. 当处理器拔出时,  vmm 得到通知, 将该处理器上执行的任务迁移到其他处理器上, 并将其从管理队列中删除. \n\n> 云服务存在多个处理器节点, 当某些节点出现故障时, 其上运行的guest os 不会宕机, 而是转移到其他正常工作的cpu节点上; \n   同样为了安全的扩充处理器资源, 在不断电的基础上进行cpu的扩充进而降低系统负载, 对服务器来说也是必要的;\n2. 内存管理\n\t系统启动时VMM检测并获取所有内存, 对获得的内存进行初始化, 包括分页设置页表等; 提供内存分配的接口, 给虚拟机分配内存, 并且维护虚拟机物理地址和实际物理地址的映射关系\n3. 中断管理\n\t根据中断来源, 或直接处理, 或转发给guest os 处理\n4. 系统时间维护\n\tVMM 拥有和时间相关的硬件资源, VMM 负责维护系统时间, 同时向各guest os 提供虚拟化的时间\n5. 设备管理\n\t所有的外设都属于VMM, VMM需要包含所有设备的驱动程序. 在混合模型下, 大部分的外部设备属于guest os, 少部分的设备属于VMM\n\n### 虚拟化的优点:\n\n- 更高的系统安全性和可用性\n\t- VMM 作为监视层, 运行在比os更高的特权层\n\t- 控制过滤虚拟机的行为\n\t- 监控虚拟机状态, 故障快速恢复\n- 最大化硬件资源使用率\n\t- 在一个物理主机上创建多个虚拟机共享主机资源, 节约硬件成本\n- 系统易扩展\n\t- 修改虚拟机的配置来适应业务的负载变化\n- 方便的可移植性\n\t- 虚拟机的系统消除物理主机的硬件差异\n\t- 虚拟机以文件镜像的格式封装\n- 硬件级别的隔离特性\n\t- 通过iommu技术隔离外设\n\n### 不同类型的VMM:\n\n#### baremetal vmm (type1)\n\n- 启动时bootloader/BIOS 直接将执行权限交给hypervisor\n- 直接运行在硬件上, 不依赖基础操作系统\n- 可以控制所有的guest os\n- 交互少, 性能好, 稳定\n- 无法直接利用现有操作系统生态, 硬件兼容性差, 驱动开发工作量大\n\t\n\t> VMM根据产品定位, 有选择的挑选一些io 设备来支持, 如面向服务器市场, 只会挑选服务器上的io设备来开发驱动, 另外调度和电源管理等的很多功能需要在VMM中重新实现\n- 典型代表: Xen\n![image-20240416111459876](attachments/image-20240416111459876.png)\n\n#### hosted vmm (type2)\n\n- 启动时bl/BIOS 先启动host os, hypervisor/VMM 相当于host os中跑的一个应用\n- 需要通过host os 来访问硬件资源\n- vmm 只能控制guest os, 不能控制host os中的其他部分\n- guest os 和 host os 交互调用链长, 影响性能\n- 攻击窗口多, 安全性差\n- 可以直接利用现有操作系统生态, 硬件兼容性好\n- 典型代表: linux kvm\n![image-20240416111504708](attachments/image-20240416111504708.png)\n\nKVM的思想是在Linux内核的基础上添加虚拟机管理模块，重用Linux内核中已经完善的进程调度、内存管理、IO管理等代码，使之成为一个可以支持运行虚拟机的Hypervisor\n\n![image-20240416111508288](attachments/image-20240416111508288.png)\n\n#### 混合模型\n\n上述两种模式的集合体, VMM依然位于最底层, 拥有所有的物理资源, 与type1 模式不同的是, VMM会让出大部分io设备的控制权, 将它们交给guest os 控制, 相应的, VMM虚拟化的职责被分担, 处理器和内存的虚拟化仍由VMM 完成, 而IO虚拟化则由VMM和guest os 合作完成.\n\n## Hypervisor 的实现\n\n### 半虚拟化:\n\n- 将guest os 降权, 使其无法直接访问系统特权资源\n- vmm 提供访问系统特权资源的hyper call api\n- 修改guest os, 用hyper call api 访问系统特权资源\n- 高效轻量, 性能好\n- guest os 修改量大, 使用不便\n\n### 全虚拟化:\n\n- 将guest os 运行在vmm 创建的独立环境里\n- vmm 将内核特权访问操作翻译成一系列对vmm 的请求 (软件方案)\n- guest os对虚拟化环境不感知, 不需要修改guest os\n- vmm 实现复杂\n- vmm和guest os 之间翻译产生的负载比较大, 性能差\n\n硬件虚拟化在半虚拟化和全虚拟化基础上提供了硬件辅助\n\n用来简化VMM实现, 提高性能\n\n- intel VT-x VT-d\n- AMD svm iommu\n- ARM hypervisor层 smmu\n- riscv h-extension层 iommu\n\n## CPU 虚拟化\n\n 虚拟CPU上下文\n\n- 类似于进程上下文的概念，当虚拟机发生退出时，需要保存虚拟CPU中各寄 存器的状态\n- 发生虚拟CPU调度时，需要保存当前虚拟CPU的上下文并加载待调度虚拟 CPU上下文\n\n![image-20240416111513395](attachments/image-20240416111513395.png)\n\n### 软件方案\n\nx86 虚拟化技术早期, 没有cpu虚拟化的硬件支持, VMM 运行在特权级, guest os运行在非特权级(用户态), 这种方式称为特权级压缩（Ring Compression). guest os 上内核运行特权指令时, 通常会触发异常, 进入特权级, 由VMM 截获异常并进行处理, 但是有一些`非特权敏感指令`并不会触发异常, 这种状态下, VMM就需要扫描guest os的内核的所有的这些不会触发异常的敏感指令, 将其翻译成支持虚拟化的指令(会触发异常的指令), vmm 再去处理这些翻译后指令触发的异常.\n\n> 修改系统资源的，或者在不同模式下行为有不同表现的，都属于敏感指令\n\n### 硬件辅助方案\n\n软件方案是非常低效的, 且vmm 实现过于复杂, Intel VT-x、AMD SVM、ARM EL2、RISC-V H-Extension, 加入了一层特权级别, guest os 运行在这一层上, 这一层上所有特权指令均会触发异常, 可以被VMM截获处理\n\n![image-20240416111517531](attachments/image-20240416111517531.png)\n\n### 中断虚拟化\n\n#### 虚拟化系统中, 设置中断处理流程\n\n    1. 设备产生一个水平/边缘触发中断信号\n    2. 中断控制器响应该信号, 让cpu 进入VMM host 内核态的 中断异常模式\n    3. CPU 调用VMM 中断服务程序, 通过IRQ number 找到对应的guest os, 通过`中断注入程序`向guest os 注入virtual irq\n    4. guest os cpu进入guest 内核态的中断异常模式\n    5. guest os 调用中断服务程序, 通过virtual irq number 找到对应的驱动中断处理函数\n    6. 完成中断处理 \n\n![image-20240416111521451](attachments/image-20240416111521451.png)\n\n## 内存虚拟化\n\n### 常见的内存虚拟化技术\n\n1. 地址空间分区\n\t- 简单, 但不灵活\n2. 半虚拟化 shadow page table\n\t- 虚拟地址模拟物理地址, 性能好, 需要修改guest os\n\n### 硬件虚拟化- 二级地址翻译\n\n>  实际上是扩展了影子页表技术, 硬件辅助化的措施:    新增寄存器，供硬件MMU读取, 由硬件mmu 完成二级页表翻译, 避免由软件翻译, 运行时无需vmm 介入.\n\n1. IPA (intermediate physical address) guest 物理地址\n2. 虚拟机物理地址空间由IPA 描述, 不直接指向真实物理地址\n3. 每个VM的IPA地址独立, 可以相同, 可以重叠, 也可以完全不同\n4. 通过两级地址翻译找到真实物理地址\n\t1) VA->IPA (guest os)\n\t\tarm64 使用TTBRn_EL1寄存器和页表, riscv 使用stap寄存器\n\t2) IPA->PA (VMM)\n\t\tarm64 使用VTTBR_EL2寄存器和stage2 页表, riscv 使用hgatp 寄存器\n\n## IO 模拟\n\n![image-20240416111526004](attachments/image-20240416111526004.png)\n\n- type2 类 用户态设备模型:\n\n  - QEMU/KVM\n\n  - 用户态设备模型, 运行库生态健壮, 可复用性高\n\n  - 多次上下文切换\n\n\n- type1 类 baremental 设备模型:\n\n  - xvisor xen\n\n  - 减少了多次上下文切换\n\n  - 缩短io模拟路径\n\n  - 移植性差\n\n### 设备类型\n\n1) MMIO (Memory-mapped I/O)\n    特定物理内存区域映射了设备的寄存器, os通过页表以访问内存的方式访问设备寄存器, RISCV 仅支持MMIO\n2) DMA\n    无需CPU控制, DMA控制器接管地址总线\n\n### IO 虚拟化基本任务\n\n- 访问截获\n- 提供设备接口\n\t- 虚拟设备接口, 如暴露虚拟pci 设备\n\t- 直通设备接口, 如intel VT-d 技术\n\t- 对虚拟机完全“透明”\n- 实现设备功能\n\t- type1 类baremental VMM 需要实现设备驱动, 设备模型; \n\t- type2 类需要实现用户态设备模型  运行库等\n\n### MMIO模拟过程\n\n虚拟机陷入过程\n- 访存指令，非特权指令\n- 页表不存在相应页表项 -> 缺页异常 -> 陷入VM\n\nHypervisor中的处理\n\n- 为MMIO区域注册一个MMIO处理函数\n- 处理函数定位到需要访问的I/O端口\n\n### DMA 模拟\n\n- guest 驱动程序配置DMA 相关寄存器, 源地址 目的地址 (GPA) 及 长度\n- 陷入VMM, 设备模型用VMM 提供的`内存管理功能` 将源地址目的地址 (GPA) 翻译为 HPA, 配置物理DMA 的地址寄存器为HPA, 同时需要建立HPA 与 HVA的映射关系, 对其进行占位, 防止别的进程或vcpu把这块物理内存给抢走. 这个地方纯软件实现比较复杂, 涉及到映射给 guest 的虚拟设备地址与真实设备地址之间的转换, 如果为memory->memory, 会简单一些\n- guest 客户机驱动程序通过配置虚拟DMA的 命令控制寄存器发起 DMA操作\n- 陷入VMM, 设备模型截获这个操作后, 配置物理DMA命令控制寄存器\n- DMA 自行在HPA 间搬运数据\n- DMA 搬运完毕后, 通过中断通知vmm 设备模型, vmm设备模型返回到guest os中, DMA 请求结束\n\n### 硬件io虚拟化辅助-设备直通\n\n软件实现I/O虚拟化的技术中，所有的虚拟机都共享物理平台上的硬件设备。如果物理条件好，有足够的硬件，就可以考虑让每个虚拟机独占一个物理设备，这样无疑会提高系统的性能。把某一个设备直接分配给一个虚拟机，让虚拟机可以直接访问该物理设备而不需要通过VMM或被VMM截获，这就是设备直通技术。\n\nintel 的 VT-d与AMD的IOMMU技术 arm的smmu 技术。SMMU 与 IOMMU 提供了外设的中断重映射和DMA重映射功能, 使guest os使用该外设同host os 使用外设一样, 在使用过程中不需要陷入VMM.\n\n中断重映射会将来自外部设备的中断拦截下来, 通过查询中断映射表找到真正的中断路由信息然后发送给真正的CPU。 guest 可以直接收到中断, 处理流程同物理主机处理中断的流程一样.\n\n## ARM 硬件虚拟化技术:\n\n### CPU 特权层扩展\n\n- EL2 层(arm64) / HYP (arm32) 模式下运行vmm\n- guest os 运行在原有的特权模式, 不需要修改guest os\n- vmm所在层权限更高, 可以控制guest os 访问硬件的权限\n\n![image-20240416111531638](attachments/image-20240416111531638.png)\n\n#### 模式切换\n\n虚拟机 → Hypervisor \n\n- EL1 → EL2 \n- 敏感指令触发(可通过HCR_EL2寄存器细粒度 控制)\n\nHypervisor → 虚拟机\n\n- EL2 → EL1\n- eret指令触发\n\n#### 上下文切换\n\n- EL1与EL2各自有一套系统寄存器\n- 虚拟CPU调度时，需要将原虚拟CPU系统寄 存器保存至内存并从内存中加载目标虚拟 CPU寄存器\n\n因为有了硬件虚拟化的支持，所以hypervisor的实现 基本是基于硬件的 trap 和 软件的emulator 来实现的。guest os 访问一些特权寄存器或者指令，会进到 hypervisor ，然后会调用特权寄存器的访问函数来访问特权寄存器。如果是要访问硬盘，或者网络，会通过io 模拟器，来访问具体的模拟器。\n\n![image-20240416111535749](attachments/image-20240416111535749.png)\n\nCPU的虚拟化，就是让多个Guest os 分时的运行在同一个CPU上，都有自己独立的物理地址空间，让 hypervisor在EL2 层来帮助多个VM 来进行上下文的切换，这个和linux 进程的概念非常的相似，不过保存的上下文寄存器不一样，这里有两个重要的寄存器，`HCR_EL2` 和 `ESR_EL2`。HCR_EL2 是用来配置VM的参数，就是产生trap的条件，什么情况下会产生trap陷入到hypervisor ，右边是一个运行两个VM的例子。`WFI`指令是说明自己工作做完了，是idle状态了。\n\n![image-20240416111539904](attachments/image-20240416111539904.png)\n\nARM CPU虚拟化通过硬件trap和软件模拟完成\n\n1. HCR_EL2 hyper配置寄存器\n   1) 配置vm产生硬件trap的条件,  如TLB/cache的操作, 一些特殊指令\n2. ESR_EL2 异常寄存器\n   1) 当trap发生时, 确定vm产生硬件trap的原因\n\n#### 执行特权指令示例:\n\n> 与特权级无关的一般的指令和通用寄存器在任何特权级都可以任意执行。而每个特权级都对应一些特殊指令和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不只是具有有读写 CSR 的指令，还有其他功能的特权指令。\n>\n> 如果低优先级下的处理器执行了高优先级的指令，会产生非法指令错误的异常，于是位于高特权级的执行环境能够得知低优先级的软件出现了该错误, 进而陷入到高特权级处理该指令\n\n![image-20240416111543865](attachments/image-20240416111543865.png)\n\n#### 访问特定寄存器示例:\n\n![image-20240416111547192](attachments/image-20240416111547192.png)\n\n\n\n> 使用陷入来虚拟化操作需要大量计算。比如功能寄存器ID_AA64MMFR0_EL1(用来报告处理器内存相关特性的，操作系统可能会读取该寄存器来决定在内核中开启或关闭某些特性)，不经常被操作系统访问。当将对这些寄存器的访问捕获到虚拟机监控程序中以模拟读取时，计算是可以接受的。\n> 但是对于访问频率高的寄存器，比如MPIDR_EL1，或者在性能关键代码中，需要尽可能地优化陷入，对这些寄存器，ARM提供了其它策略，hypervisor可以在进入VM时先配置好这些寄存器的值。例如，当VM中读到`MPIDR_EL1`(在多处理器系统中，为进程调度提供一个额外的PE（process element）识别机制)时会自动返回`VMPIDR_EL2`的值而不发生陷入\n\n### MMU虚拟化支持\n\n- LPAE(arm32 大地址拓展技术) , stage2 translation\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221010161226.svg)\n\n### 中断虚拟化\n\nHypervisor对虚拟中断的处理比较复杂，Hypervisor本身需要机制来在EL2处理中断，还需要机制来将外设的中断信号发送到目标虚拟机VM（或vCPU）上，为了使能这些机制，**ARM体系架构包含了对虚拟中断的支持（vIRQs，vFIQs，vSErrors）；**\n\n处理器只有在`EL0/EL1`执行状态下，才能收到虚拟中断，在EL2/EL3状态下不能收到虚拟中断；\n\nHypervisor通过设置`HCR_EL2`寄存器来控制向EL0/EL1发送虚拟中断，比如为了使能vIRQ，需要设置HCR_EL2.IMO，设置后便会将物理中断发送至EL2，然后使能将虚拟中断发送至EL1；\n\n有两种方式可以产生虚拟中断：\n\n1）在处理器内部控制`HCR_EL2`寄存器产生虚拟中断, hypervisor还需要为VM模拟中断控制器的操作\n\n2）通过GIC中断控制器（v2版本以上)；\n\n![image-20221020105426023](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20221020105426023.png)\n\n如果一个PE上运行了多个guest os, 即一个PE上绑定了多个vcpu, 同时每个vcpu上跑的os是不同的.\n\n发送虚拟中断则需要在安装中断时绑定vcpu 与 中断号. \n\n\n\n#### 虚拟CPU接口直接访问\n\n- 为虚拟CPU接口提供专用寄存器，区别于物理CPU接口\n- 运行在EL1中的Guest OS对CPU接口系统寄存器的访问可以被重定向到相应的寄存器而不会触发虚拟机陷入\n\n\n\n### arch_timer 虚拟化\n\n- hypervisor timer, virtual timer\n\n无需陷入VMM, 防止引入不确定性的时延. 对于os 来说, timer tick 涉及到任务调度, 越精确越好.\n\n### smmu\n\n- stage2 translation for DMA\n\n- 一种DMA重映射机制\n\n- 扩大设备DMA寻址范围, 当系统无法提供大块连续物理内存时，也可以通过SMMU转换让设备可以访问分散物理内存\n\n- IOMMU在ARM-V8架构下的解决方案，与VT-d类似\n\n- SMMU与MMU共用一套阶段-2页 表\n\n- 设备直通\n\n  - 虚拟机直接接管设备，虚机可以直接访问MMIO空间，VMM配置好`SMMU`之后，设备DMA读写请求也无需VMM介入\n\n- 为每个虚拟机划定可用的设备, 起到隔离保护作用\n\n#### 虚拟机网卡如何进行DMA?\n\n![image-20240416111555905](attachments/image-20240416111555905.png)\n\n- 网卡驱动将数据的guest 物理地址填入网卡DMA 寄存器\n- SMMU 硬件将发给DMA的guest 物理地址转换为真实设备物理地址\n\nSMMU 为系统除CPU 之外的任何具有DMA 能力的设备提供地址翻译服务和保护功能\n\n- PCIE DMA 设备\n- platform DMA 设备\n- GPU/VE 加速器\n\n![image-20240416111559481](attachments/image-20240416111559481.png)\n\n## RISCV 虚拟化技术\n\n### 已有的RISC-V虚拟化方案实现\n\n目前已有的实现有Xvisor和KVM，Xvisor是1类虚拟化软件，而KVM属于2类。\n\nRISC-V规范定义了RISC-V H-extension,在原来的3级特权架构的基础上，对原有的Supervisor模式进行了扩展，引入了Hypervisor-Extended Supervisor mode (HS)\n\n![image-20240416111603241](attachments/image-20240416111603241.png)\n\n虚拟化H扩展定义了一个硬件状态位，称作V状态，可以为0或1，V状态不同，定义和访问的CSR寄存器也不同。\n\n- 当V为0时\n  - 以“s”开头的CSR寄存器表示当前操作系统的状态\n  - “h”开头的用于支持和实现虚拟化软件\n  - “vs”开头的代表运行在虚拟化技术上的系统状态。\n- 当V为1时\n  - “s”开头的寄存器指向了前文以“vs”开头的寄存器。\n\n![image-20240416111606294](attachments/image-20240416111606294.png)\n\n![image-20240416111610806](attachments/image-20240416111610806.png)\n\n#### 模式切换\n\n- 虚拟机 → Hypervisor\n  - VS mode → HS mode(先进入M mode，再由M mode 转发给HS mode)\n  - 敏感指令触发\n- Hypervisor → 虚拟机\n  - HS mode → VS mode\n  - sret指令触发\n\n#### 上下文切换\n\n- 为VS-mode提供VS CSR\n- 虚拟CPU调度时，同样需要从内存中保存和加载相应的寄存器\n\n### 2级mmu 地址转换\n\n使用stap 与`hgatp` 寄存器完成2级 地址转换, 原理一样\nva->ipa (guest os) satp\nipa -> pa (host os) hgatp\n\n### 中断\n\n*hedeleg* 虚拟异常代理寄存器\n\n*hideleg* 虚拟中断代理寄存器\n\n默认状态下, 在各级代理寄存器未设置时, 所有的trap 和 中断都被指向到 M 模式的trap (即mtvec 指定的入口函数处), 在指定了 `medeleg` 和 `mdieleg`后, 相应bit位的trap 和 中断 指向到 HS 模式的trap (即stvec 指定的入口函数处),  进一步, 在指定了 `hedeleg` 和 `hideleg` 后, 相应bit位的trap 和 中断指向到 VS 模式下的trap(即vstvec 指定的入口函数处)\n\n![image-20240416111616014](attachments/image-20240416111616014.png)\n\nhedeleg 中, 9-11 bit, 20-23 bit 是readonly的, 只能是0\n\n第0, 3, 8, 12, 13, 15 为推荐设置bit\n\n![image-20240416111619570](attachments/image-20240416111619570.png)\n\nhideleg 中, 0-15 中, 只有10, 6, 2 能被设置. 当hideleg中, bit 10被设置后, 10号中断来了后, 被代理到VS-mode后, code 10 会被自动转换为 code 9; 同样的 6号中断被自动转换为 5, 2号中断被自动转换为 1号. 这样做的目的是为guest os 中的 kernel 不用进行额外的修改来适配虚拟机.\n\n除此之外, HS模式可以使用`hvip`寄存器，来向VS模式注入虚拟的中断。\n\n### timer\n\n提供`htimedelta` `htimedeltah` 寄存器, 在VS VU 模式下访问timer 寄存器会返回真实的time与htimedelta的和. 通过`hideleg` 代理实现guest timer的中断, 不需要陷入VMM.\n\n### io模拟\n\n为了虚拟数据吞吐，HS模式可以使用“陷入-模拟”法。即在访问内存映射外设对应的地址时，产生相应的中断，通过模拟外设的运行来实现后续的过程。这种方式可以模拟PLIC外设、VirtIO外设和其它一些软件模拟的吞吐外设。\n\niommu 同 ARM SMMU 技术一样提供了设备直通能力, 提供了DMA 重映射和中断重映射机制, 某个外设可以被guest 独占, guest os 访问外设的流程如host os 一样, 无需陷入VMM. \n\nRISCV iommu 最近才有正式的文档发布, 距离开源实现还需要一些时间.\n\n![image-20240416111624137](attachments/image-20240416111624137.png)\n\n​                                                                                 no-iommu\n\n\n\n![image-20240416111627418](attachments/image-20240416111627418.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twith iommu\n\n## ARM Vs RISCV 硬件虚拟化辅助\n\n![image-20240416111631093](attachments/image-20240416111631093.png)\n\n","tags":["riscv"],"categories":["虚拟化","RISCV"]},{"title":"Linux PCI 驱动框架分析(2)","url":"/2023/03/21/hxd_new/虚拟化/Linux PCI 驱动框架分析（2）/","content":"\n# 背 景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  Kernel 版本：4.14\n2.  ARM64 处理器\n3.  使用工具：Source Insight 3.5， Visio\n\n# 1. 概述\n\n-   本文将分析 Linux PCI 子系统的框架，主要围绕 Linux PCI 子系统的初始化以及枚举过程分析；\n-   如果对具体的硬件缺乏了解，建议先阅读上篇文章`《Linux PCI驱动框架分析（一）》`；\n\n话不多说，直接开始。\n\n# 2. 数据结构\n\n![image-20240416110922011](attachments/image-20240416110922011.png)\n\n-   PCI 体系结构的拓扑关系如图所示，而图中的不同数据结构就是用于来描述对应的模块；\n-   Host Bridge 连接 CPU 和 PCI 系统，由`struct pci_host_bridge`描述；\n-   `struct pci_dev`描述 PCI 设备，以及 PCI-to-PCI 桥设备；\n-   `struct pci_bus`用于描述 PCI 总线，`struct pci_slot`用于描述总线上的物理插槽；\n\n来一张更详细的结构体组织图：\n\n![image-20240416110925629](attachments/image-20240416110925629.png)\n\n-   总体来看，数据结构对硬件模块进行了抽象，数据结构之间也能很便捷的构建一个类似 PCI 子系统物理拓扑的关系图；\n-   顶层的结构为`pci_host_bridge`，这个结构一般由 Host 驱动负责来初始化创建；\n-   `pci_host_bridge`指向 root bus，也就是编号为 0 的总线，在该总线下，可以挂接各种外设或物理 slot，也可以通过 PCI 桥去扩展总线；\n\n# 3. 流程分析\n\n## 3.1 设备驱动模型\n\nLinux PCI 驱动框架，基于 Linux 设备驱动模型，因此有必要先简要介绍一下，实际上 Linux 设备驱动模型也是一个大的 topic，先挖个坑，有空再来填。来张图吧：\n\n![image-20240416110928852](attachments/image-20240416110928852.png)\n\n-   简单来说，Linux 内核建立了一个统一的设备模型，分别采用总线、设备、驱动三者进行抽象，其中设备与驱动都挂在总线上，当有新的设备注册或者新的驱动注册时，总线会去进行匹配操作（`match`函数），当发现驱动与设备能进行匹配时，就会执行 probe 函数的操作；\n-   从数据结构中可以看出，`bus_type`会维护两个链表，分别用于挂接向其注册的设备和驱动，而`match`函数就负责匹配检测；\n-   各类驱动框架也都是基于图中的机制来实现，在这之上进行封装，比如 I2C 总线框架等；\n-   设备驱动模型中，包含了很多`kset/kobject`等内容，建议去看看之前的文章`《linux设备模型之kset/kobj/ktype分析》`\n-   好了，点到为止，感觉要跑题了，强行拉回来。\n\n## 3.2 初始化\n\n既然说到了设备驱动模型，那么首先我们要做的事情，就是先在内核里边创建一个 PCI 总线，用于挂接 PCI 设备和 PCI 驱动，我们的实现来到了`pci_driver_init()`函数：\n\n![image-20240416110932256](attachments/image-20240416110932256.png)\n\n-   内核在 PCI 框架初始化时会调用`pci_driver_init()`来创建一个 PCI 总线结构（全局变量`pci_bus_type`），这里描述的 PCI 总线结构，是指驱动匹配模型中的概念，PCI 的设备和驱动都会挂在该 PCI 总线上；\n-   从`pci_bus_type`的函数操作接口也能看出来，`pci_bus_match`用来检查设备与驱动是否匹配，一旦匹配了就会调用`pci_device_probe`函数，下边针对这两个函数稍加介绍；\n\n### 3.2.1 pci_bus_match\n\n![image-20240416110935169](attachments/image-20240416110935169.png)\n\n-   设备或者驱动注册后，触发`pci_bus_match`函数的调用，实际会去比对`vendor`和`device`等信息，这个都是厂家固化的，在驱动中设置成`PCI_ANY_ID`就能支持所有设备；\n-   一旦匹配成功后，就会去触发`pci_device_probe`的执行；\n\n### 3.2.2 pci_device_probe\n\n![image-20240416110938431](attachments/image-20240416110938431.png)\n\n-   实际的过程也是比较简单，无非就是进行匹配，一旦匹配上了，直接调用驱动程序的 probe 函数，写过驱动的同学应该就比较清楚后边的流程了；\n\n## 3.3 枚举\n\n-   我们还是顺着设备驱动匹配的思路继续开展；\n-   3.2 节描述的是总线的创建，那么本节中的枚举，显然就是设备的创建了；\n-   所谓设备的创建，就是在 Linux 内核中维护一些数据结构来对硬件设备进行描述，而硬件的描述又跟上文中的数据结构能对应上；\n\n枚举的入口函数：`pci_host_probe`\n\n![image-20240416110941635](attachments/image-20240416110941635.png)\n\n-   设备的扫描从`pci_scan_root_bus_bridge`开始，首先需要先向系统注册一个`host bridge`，在注册的过程中需要创建一个`root bus`，也就是`bus 0`，在`pci_register_host_bridge`函数中，主要是一系列的初始化和注册工作，此外还为总线分配资源，包括地址空间等；\n-   `pci_scan_child_bus`开始，从`bus 0`向下扫描并添加设备，这个过程由`pci_scan_child_bus_extend`来完成；\n-   从`pci_scan_child_bus_extend`的流程可以看出，主要有两大块：\n    1.  PCI 设备扫描，从循环也能看出来，每条总线支持 32 个设备，每个设备支持 8 个功能，扫描完设备后将设备注册进系统，pci_scan_device 的过程中会去读取 PCI 设备的配置空间，获取到 BAR 的相关信息，细节不表了；\n    2.  PCI 桥设备扫描，PCI 桥是用于连接上一级 PCI 总线和下一级 PCI 总线的，当发现有下一级总线时，创建子结构，并再次调用`pci_scan_child_bus_extend`的函数来扫描下一级的总线，从这个过程看，就是一个递归过程。\n-   从设备的扫描过程看，这是一个典型的 DFS（`Depth First Search`）过程，熟悉数据结构与算法的同学应该清楚，这就类似典型的走迷宫的过程；\n\n如果你对上述的流程还不清楚，再来一张图：\n\n![image-20240416110947931](attachments/image-20240416110947931.png)\n\n-   图中的数字代表的就是扫描的过程，当遍历到 PCI 桥设备的时候，会一直穷究到底，然后再返回来；\n-   当枚举过程结束后，系统中就已经维护了 PCI 设备的各类信息了，在设备驱动匹配模型中，总线和设备都已经具备了，剩下的就是写个驱动了；","tags":["驱动"],"categories":["PCI","linux"]},{"title":"Linux PCI 驱动框架分析(1)","url":"/2023/03/21/hxd_new/虚拟化/Linux PCI 驱动框架分析（1）/","content":"\n# 背景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  Kernel 版本：4.14\n2.  ARM64 处理器\n3.  使用工具：Source Insight 3.5， Visio\n\n# 1. 概述\n\n从本文开始，将会针对 PCIe 专题来展开，涉及的内容包括：\n\n1.  PCI/PCIe 总线硬件；\n2.  Linux PCI 驱动核心框架；\n3.  Linux PCI Host 控制器驱动；\n\n不排除会包含 PCIe 外设驱动模块，一切随缘。\n\n\n作为专题的第一篇，当然会先从硬件总线入手。  \n进入主题前，先讲点背景知识。  \n在 PC 时代，随着处理器的发展，经历了几代 I/O 总线的发展，解决的问题都是 CPU 主频提升与外部设备访问速度的问题：\n\n1.  第一代总线包含`ISA`、`EISA`、`VESA`和`Micro Channel`等；\n2.  第二代总线包含`PCI`、`AGP`、`PCI-X`等；\n3.  第三代总线包含`PCIe`、`mPCIe`、`m.2`等；\n\n`PCIe（PCI Express）`是目前 PC 和嵌入式系统中最常用的高速总线，PCIe 在 PCI 的基础上发展而来，在软件上 PCIe 与 PCI 是后向兼容的，PCI 的系统软件可以用在 PCIe 系统中。\n\n\n本文会分两部分展开，先介绍 PCI 总线，然后再介绍 PCIe 总线，方便在理解上的过渡，开始旅程吧。\n\n# 2. PCI Local Bus\n\n## 2.1 PCI 总线组成\n\n-   `PCI总线（Peripheral Component Interconnect，外部设备互联）`，由 Intel 公司提出，其主要功能是连接外部设备；\n-   `PCI Local Bus`，PCI 局部总线，局部总线技术是 PC 体系结构发展的一次变革，是在`ISA总线`和`CPU总线`之间增加的一级总线或管理层，可将一些高速外设，如图形卡、硬盘控制器等从`ISA总线`上卸下，而通过局部总线直接挂接在 CPU 总线上，使之与高速`CPU总线`相匹配。PCI 总线，指的就是`PCI Local Bus`。\n\n先来看一下 PCI Local Bus 的系统架构图：\n\n![image-20240416110614230](attachments/image-20240416110614230.png)\n\n从图中看，与 PCI 总线相关的模块包括：\n\n1.  `Host Bridge`，比如 PC 中常见的`North Bridge（北桥）`；  \n    图中处理器、Cache、内存子系统通过 Host Bridge 连接到 PCI 上，Host Bridge 管理 PCI 总线域，是联系处理器和 PCI 设备的桥梁，完成处理器与 PCI 设备间的数据交换。其中数据交换，包含`处理器访问PCI设备的地址空间`和`PCI设备使用DMA机制访问主存储器`，在 PCI 设备用 DMA 访问存储器时，会存在 Cache 一致性问题，这个也是 Host Bridge 设计时需要考虑的；  \n    此外，Host Bridge 还可选的支持仲裁机制，热插拔等；\n    \n2.  `PCI Local Bus`；  \n    PCI 总线，由 Host Bridge 或者 PCI-to-PCI Bridge 管理，用来连接各类设备，比如声卡、网卡、IDE 接口等。可以通过 PCI-to-PCI Bridge 来扩展 PCI 总线，并构成多级总线的总线树，比如图中的`PCI Local Bus #0`和`PCI Local Bus #1`两条 PCI 总线就构成一颗总线树，同属一个总线域；\n    \n3.  `PCI-To-PCI Bridge`；  \n    `PCI桥`，用于扩展 PCI 总线，使采用 PCI 总线进行大规模系统互联成为可能，管理下游总线，并转发上下游总线之间的事务；\n    \n4.  `PCI Device`；  \n    PCI 总线中有三类设备：PCI 从设备，PCI 主设备，桥设备。  \n    PCI 从设备：被动接收来自 Host Bridge 或者其他 PCI 设备的读写请求；  \n    PCI 主设备：可以通过总线仲裁获得 PCI 总线的使用权，主动向其他 PCI 设备或主存储器发起读写请求；  \n    桥设备：管理下游的 PCI 总线，并转发上下游总线之间的总线事务，包括`PCI桥`、`PCI-to-ISA桥`、`PCI-to-Cardbus桥`等。\n    \n\n## 2.2 PCI 总线信号定义\n\nPCI 总线是一条共享总线，可以挂接多个 PCI 设备，PCI 设备通过一系列信号与 PCI 总线相连，包括：地址 / 数据信号、接口控制信号、仲裁信号、中断信号等。如下图：\n\n![image-20240416110619128](attachments/image-20240416110619128.png)\n\n-   左侧红色框里表示的是 PCI 总线必需的信号，而右侧蓝色框里表示的是可选的信号；\n-   `AD[31:00]`：地址与数据信号复用，在传送时第一个时钟周期传送地址，下一个时钟周期传送数据；\n-   `C/BE[3:0]#`：PCI 总线命令与字节使能信号复用，在地址周期中表示的是 PCI 总线命令，在数据周期中用于字节选择，可以进行单字节、字、双字访问；\n-   `PAR`：奇偶校验信号，确保`AD[31:00]`和`C/BE[3:0]#`传递的正确性；\n-   `Interface Control`：接口控制信号，主要作用是保证数据的正常传递，并根据 PCI 主从设备的状态，暂停、终止或者正常完成总线事务：\n    -   `FRAME#`：表示 PCI 总线事务的开始与结束；\n    -   `IRDY#`：信号由 PCI 主设备驱动，信号有效时表示 PCI 主设备数据已经 ready；\n    -   `TRDY#`：信号由目标设备驱动，信号有效时表示目标设备数据已经 ready；\n    -   `STOP#`：目标设备请求主设备停止当前总线事务；\n    -   `DEVSEL#`：PCI 总线的目标设备已经准备好；\n    -   `IDSEL`：PCI 总线在配置读写总线事务时，使用该信号选择 PCI 目标设备；\n-   `Arbitration`：仲裁信号，由`REQ#`和`GNT#`组成，与 PCI 总线的仲裁器直接相连，只有 PCI 主设备需要使用该组信号，每条 PCI 总线上都有一个总线仲裁器；\n-   `Error Reporting`：错误信号，包括`PERR#`奇偶校验错误和`SERR`系统错误；\n-   `System`：系统信号，包括时钟信号和复位信号；\n\n看一下`C/BE[3:0]`都有哪些命令吧：\n\n![image-20240416110624548](attachments/image-20240416110624548.png)\n\n## 2.3 PCI 事务模型\n\nPCI 使用三种模型用于数据的传输：\n\n![image-20240416110646652](attachments/image-20240416110646652.png)\n\n1.  `Programmed I/O`：通过 IO 读写访问 PCI 设备空间；\n2.  `DMA`：PIO 的方式比较低效，DMA 的方式可以直接去访问主存储器而无需 CPU 干预，效率更高；\n3.  `Peer-to-peer`：两台 PCI 设备之间直接传送数据；\n\n## 2.4 PCI 总线地址空间映射\n\nPCI 体系架构支持三种地址空间：\n\n![image-20240416110651082](attachments/image-20240416110651082.png)\n\n1.  `memory空间`：  \n    针对 32bit 寻址，支持 4G 的地址空间，针对 64bit 寻址，支持 16EB 的地址空间；\n    \n2.  `I/O空间`  \n    PCI 最大支持 4G 的 IO 空间，但受限于 x86 处理器的 IO 空间（16bits 带宽），很多平台将 PCI 的 IO 地址空间限定在 64KB；\n    \n3.  `配置空间`  \n    x86 CPU 可以直接访问`memory空间`和`I/O空间`，而配置空间则不能直接访问；  \n    每个 PCI 功能最多可以有 256 字节的配置空间；  \n    PCI 总线在进行配置的时候，采用 ID 译码方式，使用设备的 ID 号，包括`Bus Number`，`Device Number`，`Function Number`和`Register Number`，每个系统支持 256 条总线，每条总线支持 32 个设备，每个设备支持 8 个功能，由于每个功能最多有 256 字节的配置空间，因此总的配置空间大小为：256B * 8 * 32 * 256 = 16M；\n    \n    有必要再进一步介绍一下配置空间：  \n    x86 CPU 无法直接访问配置空间，通过 IO 映射的数据端口和地址端口间接访问 PCI 的配置空间，其中地址端口映射到`0CF8h - 0CFBh`，数据端口映射到`0CFCh - 0CFFh`；  \n    \n    ![image-20240416110655409](attachments/image-20240416110655409.png)\n    \n    -   图为配置地址寄存器构成，PCI 的配置过程分为两步：\n        1.  CPU 写 CF8h 端口，其中写的内容如图所示，BUS，Device，Function 能标识出特定的设备功能，Doubleword 来指定配置空间的具体某个寄存器；\n        2.  CPU 可以 IO 读写 CFCh 端口，用于读取步骤 1 中的指定寄存器内容，或者写入指定寄存器内容。这个过程有点类似于通过 I2C 去配置外接芯片；\n    \n    那具体的配置空间寄存器都是什么样的呢？每个功能 256Byte，前边 64Byte 是 Header，剩余的 192Byte 支持可选功能。有种类型的 PCI 功能：Bridge 和 Device，两者的 Header 都不一样。\n    \n    -   Bridge  \n        \n        ![image-20240416110659912](attachments/image-20240416110659912.png)\n        \n    -   Device  \n        \n        ![image-20240416110703859](attachments/image-20240416110703859.png)\n        \n\n配置空间中有个寄存器字段需要说明一下：`Base Address Register`，也就是`BAR空间`，当 PCI 设备的配置空间被初始化后，该设备在 PCI 总线上就会拥有一个独立的 PCI 总线地址空间，这个空间就是`BAR空间`，`BAR空间`可以存放 IO 地址空间，也可以存放存储器地址空间。\n\n-   PCI 总线取得了很大的成功，但随着 CPU 的主频不断提高，PCI 总线的带宽也捉襟见肘。此外，它本身存在一些架构上的缺陷，面临一系列挑战，包括带宽、流量控制、数据传送质量等；\n-   PCIe 应运而生，能有效解决这些问题，所以 PCIe 才是我们的主角；\n\n# 3. PCI Express\n\n## 3.1 PCIe 体系结构\n\n先看一下 PCIe 架构的组成图：  \n\n![image-20240416110708127](attachments/image-20240416110708127.png)\n\n-   `Root Complex`：CPU 和 PCIe 总线之间的接口可能会包含几个模块（处理器接口、DRAM 接口等），甚至可能还会包含芯片，这个集合就称为`Root Complex`，它作为 PCIe 架构的根，代表 CPU 与系统其它部分进行交互。广义来说，`Root Complex`可以认为是 CPU 和 PCIe 拓扑之间的接口，`Root Complex`会将 CPU 的 request 转换成 PCIe 的 4 种不同的请求（Configuration、Memory、I/O、Message）；\n-   `Switch`：从图中可以看出，`Swtich`提供扇出能力，让更多的 PCIe 设备连接在 PCIe 端口上；\n-   `Bridge`：桥接设备，用于去连接其他的总线，比如 PCI 总线或 PCI-X 总线，甚至另外的 PCIe 总线；\n-   `PCIe Endpoint`：PCIe 设备；\n-   图中白色的小方块代表`Downstream`端口，灰色的小方块代表`Upstream`端口；\n\n前文提到过，PCIe 在软件上保持了后向兼容性，那么在 PCIe 的设计上，需要考虑在 PCI 总线上的软件视角，比如`Root Complex`的实现可能就如下图所示，从而看起来与 PCI 总线相差无异：\n\n![image-20240416110712560](attachments/image-20240416110712560.png)\n\n-   Root Complex 通常会实现一个内部总线结构和多个桥，从而扇出到多个端口上；\n-   Root Complex 的内部实现不需要遵循标准，因此都是厂家 specific 的；\n\n而`Switch`的实现可能如下图所示：\n\n![image-20240416110715854](attachments/image-20240416110715854.png)\n\n-   Switch 就是一个扩展设备，所以看起来像是各种桥的连接路由；\n\n## 3.2 PCIe 数据传输\n\n![image-20240416110719784](attachments/image-20240416110719784.png)\n\n-   与 PCI 总线不同（PCI 设备共享总线），PCIe 总线使用端到端的连接方式，互为接收端和发送端，全双工，基于数据包的传输；\n-   物理底层采用差分信号（PCI 链路采用并行总线，而 PCIe 链路采用串行总线），一条 Lane 中有两组差分信号，共四根信号线，而 PCIe Link 可以由多条 Lane 组成，可以支持 1、2、4、8、12、16、32 条；\n\nPCIe 规范定义了分层的架构设计，包含三层：\n\n![image-20240416110723864](attachments/image-20240416110723864.png)\n\n1.  Transaction 层\n    \n    -   负责 TLP 包（`Transaction Layer Packet`）的封装与解封装，此外还负责 QoS，流控、排序等功能；\n2.  Data Link 层\n    \n    -   负责 DLLP 包（`Data Link Layer Packet`）的封装与解封装，此外还负责链接错误检测和校正，使用 Ack/Nak 协议来确保传输可靠；\n3.  Physical 层\n    \n    -   负责`Ordered-Set`包的封装与解封装，物理层处理 TLPs、DLLPs、Ordered-Set 三种类型的包传输；\n\n数据包的封装与解封装，与网络包的创建与解析很类似，如下图：\n\n![image-20240416110727997](attachments/image-20240416110727997.png)\n\n-   封装的时候，在 Payload 数据前添加各种包头，解析时是一个逆向的过程；\n\n来一个更详细的 PCIe 分层图：\n\n![image-20240416110731440](attachments/image-20240416110731440.png)\n\n## 3.3 PCIe 设备的配置空间\n\n为了兼容 PCI 软件，PCIe 保留了 256Byte 的配置空间，如下图：\n\n![image-20240416110735220](attachments/image-20240416110735220.png)\n\n此外，在这个基础上将配置空间扩展到了 4KB，还进行了功能的扩展，比如 Capability、Power Management、MSI 中断等：\n\n![image-20240416110749946](attachments/image-20240416110749946.png)\n\n-   扩展后的区域将使用 MMIO 的方式进行访问；\n\n草草收场吧，对 PCI 和 PCIe 有一些轮廓上的认知了，可以开始 Source Code 的软件分析了，欲知详情、下回分解！","tags":["驱动"],"categories":["PCI","linux"]},{"title":"Linux PCI 驱动框架分析(3)","url":"/2023/03/21/hxd_new/虚拟化/Linux PCI 驱动框架分析（3）/","content":"\n# 背 景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  Kernel 版本：4.14\n2.  ARM64 处理器\n3.  使用工具：Source Insight 3.5， Visio\n\n# 1. 概述\n\n先回顾一下 PCIe 的架构图：\n\n![image-20240416111001038](attachments/image-20240416111001038.png)\n\n-   本文将讲 PCIe Host 的驱动，对应为`Root Complex`部分，相当于 PCI 的`Host Bridge`部分；\n-   本文会选择 Xilinx 的`nwl-pcie`来进行分析；\n-   驱动的编写整体偏简单，往现有的框架上套就可以了，因此不会花太多笔墨，点到为止；\n\n# 2. 流程分析\n\n-   但凡涉及到驱动的分析，都离不开驱动模型的介绍，驱动模型的实现让具体的驱动开发变得更容易；\n-   所以，还是回顾一下上篇文章提到的驱动模型：Linux 内核建立了一个统一的设备模型，分别采用总线、设备、驱动三者进行抽象，其中设备与驱动都挂在总线上，当有新的设备注册或者新的驱动注册时，总线会去进行匹配操作（`match`函数），当发现驱动与设备能进行匹配时，就会执行 probe 函数的操作；\n\n![image-20240416111004708](attachments/image-20240416111004708.png)\n\n-   `《Linux PCI驱动框架分析（二）》`中提到过 PCI 设备、PCI 总线和 PCI 驱动的创建，PCI 设备和 PCI 驱动挂接在 PCI 总线上，这个理解很直观。针对 PCIe 的控制器来说，同样遵循设备、总线、驱动的匹配模型，不过这里的总线是由虚拟总线`platform`总线来替代，相应的设备和驱动分别为`platform_device`和`platform_driver`；\n\n那么问题来了，`platform_device`是在什么时候创建的呢？那就不得不提到`Device Tree`设备树了。\n\n## 2.1 Device Tree\n\n-   设备树用于描述硬件的信息，包含节点各类属性，在 dts 文件中定义，最终会被编译成 dtb 文件加载到内存中；\n-   内核会在启动过程中去解析 dtb 文件，解析成`device_node`描述的`Device Tree`；\n-   根据`device_node`节点，创建`platform_device`结构，并最终注册进系统，这个也就是 PCIe Host 设备的创建过程；\n\n我们看看 PCIe Host 的设备树内容：\n```c\npcie: pcie@fd0e0000 {\n\tcompatible = \"xlnx,nwl-pcie-2.11\";\n\tstatus = \"disabled\";\n\t#address-cells = <3>;\n\t#size-cells = <2>;\n\t#interrupt-cells = <1>;\n\tmsi-controller;\n\tdevice_type = \"pci\";\n    \n\tinterrupt-parent = <&gic>;\n\tinterrupts = <0 118 4>,\n\t\t     <0 117 4>,\n\t\t     <0 116 4>,\n\t\t     <0 115 4>,\t/* MSI_1 [63...32] */\n\t\t     <0 114 4>;\t/* MSI_0 [31...0] */\n\tinterrupt-names = \"misc\", \"dummy\", \"intx\", \"msi1\", \"msi0\";\n\tmsi-parent = <&pcie>;\n    \n\treg = <0x0 0xfd0e0000 0x0 0x1000>,\n\t      <0x0 0xfd480000 0x0 0x1000>,\n\t      <0x80 0x00000000 0x0 0x1000000>;\n\treg-names = \"breg\", \"pcireg\", \"cfg\";\n\tranges = <0x02000000 0x00000000 0xe0000000 0x00000000 0xe0000000 0x00000000 0x10000000\t/* non-prefetchable memory */\n\t\t  0x43000000 0x00000006 0x00000000 0x00000006 0x00000000 0x00000002 0x00000000>;/* prefetchable memory */\n\tbus-range = <0x00 0xff>;\n    \n\tinterrupt-map-mask = <0x0 0x0 0x0 0x7>;\n\tinterrupt-map =     <0x0 0x0 0x0 0x1 &pcie_intc 0x1>,\n\t\t\t    <0x0 0x0 0x0 0x2 &pcie_intc 0x2>,\n\t\t\t    <0x0 0x0 0x0 0x3 &pcie_intc 0x3>,\n\t\t\t    <0x0 0x0 0x0 0x4 &pcie_intc 0x4>;\n    \n\tpcie_intc: legacy-interrupt-controller {\n\t\tinterrupt-controller;\n\t\t#address-cells = <0>;\n\t\t#interrupt-cells = <1>;\n\t};\n};\n```\n\n关键字段描述如下：\n\n-   `compatible`：用于匹配 PCIe Host 驱动；\n-   `msi-controller`：表示是一个 MSI（`Message Signaled Interrupt`）控制器节点，这里需要注意的是，有的 SoC 中断控制器使用的是 GICv2 版本，而 GICv2 并不支持 MSI，所以会导致该功能的缺失；\n-   `device-type`：必须是`\"pci\"`；\n-   `interrupts`：包含 NWL PCIe 控制器的中断号；\n-   `interrupts-name`：`msi1, msi0`用于 MSI 中断，`intx`用于旧式中断，与`interrupts`中的中断号对应；\n-   `reg`：包含用于访问 PCIe 控制器操作的寄存器物理地址和大小；\n-   `reg-name`：分别表示`Bridge registers`，`PCIe Controller registers`， `Configuration space region`，与`reg`中的值对应；\n-   `ranges`：PCIe 地址空间转换到 CPU 的地址空间中的范围；\n-   `bus-range`：PCIe 总线的起始范围；\n-   `interrupt-map-mask`和`interrupt-map`：标准 PCI 属性，用于定义 PCI 接口到中断号的映射；\n-   `legacy-interrupt-controller`：旧式的中断控制器；\n\n## 2.2 probe 流程\n\n-   系统会根据 dtb 文件创建对应的 platform_device 并进行注册；\n-   当驱动与设备通过`compatible`字段匹配上后，会调用 probe 函数，也就是`nwl_pcie_probe`；\n\n![image-20240416111009578](attachments/image-20240416111009578.png)\n\n看一下`nwl_pcie_probe`函数：\n\n![image-20240416111013477](attachments/image-20240416111013477.png)\n\n-   通常 probe 函数都是进行一些初始化操作和注册操作：\n    1.  初始化包括：数据结构的初始化以及设备的初始化等，设备的初始化则需要获取硬件的信息（比如寄存器基地址，长度，中断号等），这些信息都从 DTS 而来；\n    2.  注册操作主要是包含中断处理函数的注册，以及通常的设备文件注册等;\n\n-   针对 PCI 控制器的驱动，核心的流程是需要分配并初始化一个`pci_host_bridge`结构，最终通过这个`bridge`去枚举 PCI 总线上的所有设备；\n-   `devm_pci_alloc_host_bridge`：分配并初始化一个基础的`pci_hsot_bridge`结构；\n-   `nwl_pcie_parse_dt`：获取 DTS 中的寄存器信息及中断信息，并通过`irq_set_chained_handler_and_data`设置`intx`中断号对应的中断处理函数，该处理函数用于中断的级联；\n-   `nwl_pcie_bridge_init`：硬件的 Controller 一堆设置，这部分需要去查阅 Spec，了解硬件工作的细节。此外，通过`devm_request_irq`注册`misc`中断号对应的中断处理函数，该处理函数用于控制器自身状态的处理；\n-   `pci_parse_request_of_pci_ranges`：用于解析 PCI 总线的总线范围和总线上的地址范围，也就是 CPU 能看到的地址区域；\n-   `nwl_pcie_init_irq_domain`和`mwl_pcie_enable_msi`与中断级联相关，下个小节介绍；\n-   `pci_scan_root_bus_bridge`：对总线上的设备进行扫描枚举，这个流程在`Linux PCI驱动框架分析（二）`中分析过。`brdige`结构体中的`pci_ops`字段，用于指向 PCI 的读写操作函数集，当具体扫描到设备要读写配置空间时，调用的就是这个函数，由具体的 Controller 驱动实现；\n\n## 2.3 中断处理\n\nPCIe 控制器，通过 PCIe 总线连接各种设备，因此它本身充当一个中断控制器，级联到上一层的中断控制器（比如 GIC），如下图：\n\n![image-20240416111017752](attachments/image-20240416111017752.png)\n\n-   PCIe 总线支持两种中断的处理方式：\n    1.  Legacy Interrupt：总线提供`INTA#, INTB#, INTC#, INTD#`四根中断信号，PCI 设备借助这四根信号使用电平触发方式提交中断请求；\n    2.  MSI(`Message Signaled Interrupt`) Interrupt：基于消息机制的中断，也就是往一个指定地址写入特定消息，从而触发一个中断；\n\n针对两种处理方式，`NWL PCIe`驱动中，实现了两个`irq_chip`，也就是两种方式的中断控制器：\n\n![image-20240416111020774](attachments/image-20240416111020774.png)\n\n-   `irq_domain`对应一个中断控制器（`irq_chip`），`irq_domain`负责将硬件中断号映射到虚拟中断号上；\n-   来一张旧图吧，具体文章可以去参考中断子系统相关文章；\n\n![image-20240416111024251](attachments/image-20240416111024251.png)\n\n再来看一下`nwl_pcie_enable_msi`函数：\n\n![image-20240416111028689](attachments/image-20240416111028689.png)\n\n-   在该函数中主要完成的工作就是设置级联的中断处理函数，级联的中断处理函数中最终会去调用具体的设备的中断处理函数；\n\n所以，稍微汇总一下，作为两种不同的中断处理方式，套路都是一样的，都是创建`irq_chip`中断控制器，为该中断控制器添加`irq_domain`，具体设备的中断响应流程如下：\n\n1.  设备连接在 PCI 总线上，触发中断时，通过 PCIe 控制器充当的中断控制器路由到上一级控制器，最终路由到 CPU；\n2.  CPU 在处理 PCIe 控制器的中断时，调用它的中断处理函数，也就是上文中提到过的`nwl_pcie_leg_handler`，`nwl_pcie_msi_handler_high`，和`nwl_pcie_leg_handler_low`；\n3.  在级联的中断处理函数中，调用`chained_irq_enter`进入中断级联处理；\n4.  调用`irq_find_mapping`找到具体的 PCIe 设备的中断号；\n5.  调用`generic_handle_irq`触发具体的 PCIe 设备的中断处理函数执行；\n6.  调用`chained_irq_exit`退出中断级联的处理；\n\n## 2.4 总结\n\n-   PCIe 控制器驱动，各家的 IP 实现不一样，驱动的差异可能会很大，单独分析一个驱动毕竟只是个例，应该去掌握背后的通用框架；\n-   各类驱动，大体都是硬件初始化配置，资源申请注册，核心是处理与硬件的交互（一般就是中断的处理），如果需要用户来交互的，则还需要注册设备文件，实现一堆`file_operation`操作函数集；\n-   好吧，我个人不太喜欢分析某个驱动，草草收场了；\n\n下篇开始，继续回归到虚拟化，期待一下吧。","tags":["驱动"],"categories":["PCI","linux"]},{"title":"Linux 虚拟化 KVM-Qemu 分析（7）之 timer 虚拟化.md","url":"/2023/03/21/hxd_new/虚拟化/Linux 虚拟化 KVM-Qemu 分析（7）之 timer 虚拟化/","content":"\n# 背景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  KVM 版本：5.9.1\n2.  QEMU 版本：5.0.0\n3.  工具：Source Insight 3.5， Visio\n4.  文章同步在博客园：`https://www.cnblogs.com/LoyenWang/`\n\n# 1. 概述\n\n先从操作系统的角度来看一下 timer 的作用吧：\n\n![image-20240416110453083](attachments/image-20240416110453083.png)\n\n通过 timer 的中断，OS 实现的功能包括但不局限于上图：\n\n-   定时器的维护，包括用户态和内核态，当指定时间段过去后触发事件操作，比如 IO 操作注册的超时定时器等；\n-   更新系统的运行时间、wall time 等，此外还保存当前的时间和日期，以便能通过`time()`等接口返回给用户程序，内核中也可以利用其作为文件和网络包的时间戳；\n-   调度器在调度任务分配给 CPU 时，也会去对 task 的运行时间进行统计计算，比如 CFS 调度，Round-Robin 调度等；\n-   资源使用统计，比如系统负载的记录等，此外用户使用 top 命令也能进行查看；\n\n\ntimer 就像是系统的脉搏，重要性不言而喻。ARMv8 架构处理器提供了一个 Generic Timer，与 GIC 类似，Generic Timer 在硬件上也支持了虚拟化，减少了软件模拟带来的 overhead。\n\n\n本文将围绕着 ARMv8 的 timer 虚拟化来展开。\n\n# 2. ARMv8 Timer 虚拟化\n\n## 2.1 Generic Timer\n\n看一下 ARMv8 架构下的 CPU 内部图：\n\n![image-20240416110458595](attachments/image-20240416110458595.png)\n\n-   `Generic Timer`提供了一个系统计数器，用于测量真实时间的消逝；\n-   `Generic Timer`支持虚拟计数器，用于测量虚拟的时间消逝，一个虚拟计数器对应一个虚拟机；\n-   `Timer`可以在特定的时间消逝后触发事件，可以设置成`count-up`计数或者`count-down`计数；\n\n来看一下`Generic Timer`的简图：\n\n![image-20240416110502169](attachments/image-20240416110502169.png)\n\n或者这个：\n\n![image-20240416110505795](attachments/image-20240416110505795.png)\n\n-   `System Counter`位于`Always-on`电源域，以固定频率进行系统计数的增加，`System Counter`的值会广播给系统中的所有核，所有核也能有一个共同的基准了，`System Counter`的频率范围为 1-50MHZ，系统计数值的位宽在 56-64bit 之间；\n-   每个核有一组 timer，这些 timer 都是一些比较器，与`System Counter`广播过来的系统计数值进行比较，软件可以配置固定时间消逝后触发中断或者触发事件；\n-   每个核提供的 timer 包括：1）`EL1 Physical timer`；2）`EL1 Virtual timer`；此外还有在 EL2 和 EL3 下提供的 timer，具体取决于 ARMv8 的版本；\n-   有两种方式可以配置和使用一个 timer：1）`CVAL(comparatoer)`寄存器，通过设置比较器的值，当`System Count >= CVAL`时满足触发条件；2）`TVAL`寄存器，设置`TVAL`寄存器值后，比较器的值`CVAL = TVAL + System Counter`，当`System Count >= CVAL`时满足触发条件，`TVAL`是一个有符号数，当递减到 0 时还会继续递减，因此可以记录 timer 是在多久之前触发的；\n-   timer 的中断是私有中断`PPI`，其中`EL1 Physical Timer`的中断号为 30，`EL1 Virtual Timer`的中断号为 27；\n-   timer 可以配置成触发事件产生，当 CPU 通过`WFE`进入低功耗状态时，除了使用`SEV`指令唤醒外，还可以通过`Generic Timer`产生的事件流来唤醒；\n\n## 2.2 虚拟化支持\n\n`Generic Timer`的虚拟化如下图：\n\n![image-20240416110509533](attachments/image-20240416110509533.png)\n\n-   虚拟的 timer，同样也有一个 count 值，计算关系：`Virtual Count = Physical Count - <offset>`，其中 offset 的值放置在`CNTVOFF`寄存器中，`CNTPCT/CNTVCT`分别用于记录当前物理 / 虚拟的 count 值；\n-   如果 EL2 没有实现，则将 offset 设置为 0,，物理的计数器和虚拟的计数器值相等；\n-   `Physical Timer`直接与`System counter`进行比较，`Virtual Timer`在`Physical Timer`的基础上再减去一个偏移；\n-   Hypervisor 负责为当前调度运行的 vCPU 指定对应的偏移，这种方式使得虚拟时间只会覆盖 vCPU 实际运行的那部分时间；\n\n示例如下：\n\n![image-20240416110513314](attachments/image-20240416110513314.png)\n\n-   6ms 的时间段里，每个 vCPU 运行 3ms，Hypervisor 可以使用偏移寄存器来将 vCPU 的时间调整为其实际的运行时间；\n\n# 3. 流程分析\n\n## 3.1 初始化\n\n先简单看一下数据结构吧：\n\n![image-20240416110517205](attachments/image-20240416110517205.png)\n\n-   在 ARMv8 虚拟化中，使用`struct arch_timer_cpu`来描述`Generic Timer`，从结构体中也能很清晰的看到层次结构，创建 vcpu 时，需要去初始化 vcpu 架构相关的字段，其中就包含了 timer；\n-   `struct arch_timer_cpu`包含了两个 timer，分别对应物理 timer 和虚拟 timer，此外还有一个高精度定时器，用于 Guest 处在非运行时的计时工作；\n-   `struct arch_timer_context`用于描述一个 timer 需要的内容，包括了几个字段用于存储寄存器的值，另外还描述了中断相关的信息；\n\n初始化分为两部分：\n\n1.  架构相关的初始化，针对所有的 CPU，在 kvm 初始化时设置：\n\n![](attachments/image-20240416110521308.png)\n\n-   `kvm_timer_hyp_init`函数完成相应的初始化工作；\n-   `arch_timer_get_kvm_info`从 Host Timer 驱动中去获取信息，主要包括了虚拟中断号和物理中断号，以及 timecounter 信息等；\n-   vtimer 中断设置包括：判断中断的触发方式（只支持电平触发），注册中断处理函数`kvm_arch_timer_handler`，设置中断到 vcpu 的 affinity 等；\n-   ptimer 中断设置与 vtimer 中断设置一样，同时它的中断处理函数也是`kvm_arch_timer_handler`，该处理函数也比较简单，最终会调用`kvm_vgic_inject_irq`函数来完成虚拟中断注入给 vcpu；\n-   `cpuhp_setup_state`用来设置 CPU 热插拔时 timer 的响应处理，而在`kvm_timer_starting_cpu/kvm_timer_dying_cpu`两个函数中实现的操作就是中断的打开和关闭，仅此而已；\n\n2.  vcpu 相关的初始化，在创建 vcpu 时进行初始化设置：\n\n![image-20240416110543191](attachments/image-20240416110543191.png)\n\n-   针对 vcpu 的 timer 相关初始化比较简单，回到上边那张数据结构图看一眼就明白了，所有的初始化工作都围绕着`struct arch_timer_cpu`结构体；\n-   `vcpu_timer`：用于获取 vcpu 包含的`struct arch_timer_cpu`结构；\n-   `vcpu_vtimer/vcpu_ptimer`：用于获取`struct arch_timer_cpu`结构体中的`struct arch_timer_context`，分别对应 vtimer 和 ptimer；\n-   `update_vtimer_cntvoff`：用于更新 vtimer 中的 cntvoff 值，读取物理 timer 的 count 值，更新 VM 中所有 vcpu 的 cntvoff 值；\n-   `hrtimer_init`：用于初始化高精度定时器，包含有三个，`struct arch_timer_cpu`结构中有一个`bg_timer`，vtimer 和 ptimer 所对应的`struct arch_timer_context`中分别对应一个；\n-   `kvm_bg_timer_expire`：`bg_timer`的到期执行函数，当需要调用`kvm_vcpu_block`让 vcpu 睡眠时，需要先启动`bg_timer`，`bg_timer`到期时再将 vcpu 唤醒；\n-   `kvm_hrtimer_expire`：vtimer 和 ptimer 的到期执行函数，最终通过调用`kvm_timer_update_irq`来向 vcpu 注入中断；\n\n## 3.2 用户层访问\n\n可以从用户态对 vtimer 进行读写操作，比如 Qemu 中，流程如下：\n\n![image-20240416110538838](attachments/image-20240416110538838.png)\n\n-   用户态创建完 vcpu 后，可以通过 vcpu 的文件描述符来进行寄存器的读写操作；\n-   以 ARM 为例，ioctl 通过`KVM_SET_ONE_REG/KVM_GET_ONE_REG`将最终触发寄存器的读写；\n-   如果操作的是 timer 的相关寄存器，则通过`kvm_arm_timer_set_reg`和`kvm_arm_timer_get_reg`来完成；\n-   读写的寄存器包括虚拟 timer 的 CTL/CVAL，以及物理 timer 的 CTL/CVAL 等；\n\n## 3.3 Guest 访问\n\nGuest 对 Timer 的访问，涉及到系统寄存器的读写，将触发异常并 Trap 到 Hyp 进行处理，流程如下：\n\n![image-20240416110534774](attachments/image-20240416110534774.png)\n\n-   Guest OS 访问系统寄存器时，Trap 到 Hypervisor 进行处理；\n-   Hypervisor 对异常退出进行处理，如果发现是访问系统寄存器造成的异常，则调用`kvm_handle_sys_reg`来处理；\n-   `kvm_handle_sys_reg`：调用`emulate_sys_reg`来对系统寄存器进行模拟，在该函数中首先会查找访问的是哪一个寄存器，然后再去调用相应的回调函数；\n-   kvm 中维护了`struct sys_reg_desc sys_reg_descs[]`系统寄存器的描述表，其中`struct sys_reg_desc`结构体中包含了对该寄存器操作的函数指针，用于指向最终的操作函数，比如针对 Timer 的`kvm_arm_timer_write_sysreg/kvm_arm_timer_read_sysreg`读写操作函数；\n-   Timer 的读写操作函数，主要在`kvm_arm_timer_read/kvm_arm_timer_write`中完成，实现的功能就是根据物理的 count 值和 offset 来计算等；\n\n\ntimer 的虚拟化还是比较简单，就此打住了。\n\n### PS：\n\n按计划，接下里该写 IO 虚拟化了，然后紧接着 Qemu 的源码相关分析。不过，在写 IO 虚拟化之前，我会先去讲一下 PCIe 的驱动框架，甚至可能还会去研究一下网络，who knows，反正这些也都是 IO 相关。  \n`Any way，I will be back soon!`\n\n# 参考\n\n`《AArch64 Programmer's Guides Generic Timer》`  \n`《Arm Architecture Reference Manual》`","tags":["arm","qemu","kvm","timer"],"categories":["虚拟化","kvm"]},{"title":"Linux 虚拟化 KVM-Qemu 分析（4）之 CPU 虚拟化（2）.md","url":"/2023/03/20/hxd_new/虚拟化/Linux 虚拟化 KVM-Qemu 分析（4）之 CPU 虚拟化（2）/","content":"\n# 背景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  KVM 版本：5.9.1\n2.  QEMU 版本：5.0.0\n3.  工具：Source Insight 3.5， Visio\n4.  文章同步在博客园：`https://www.cnblogs.com/LoyenWang/`\n\n# 1. 概述\n\n-   本文围绕 ARMv8 CPU 的虚拟化展开；\n-   本文会结合 Qemu + KVM 的代码分析，捋清楚上层到底层的脉络；\n-   本文会提供一个 Sample Code，用于类比 Qemu 和 KVM 的关系，总而言之，大同小异，大题小做，大道至简，大功告成，大恩不言谢；\n\n先来两段前戏。\n\n## 1.1 CPU 工作原理\n\nAI 的世界，程序的执行不再冰冷，CPU 对`a.out`说，`hello啊，world已经ok啦，下来return吧!`\n\n既然要说 CPU 的虚拟化，那就先简要介绍一下 CPU 的工作原理：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104448340-2137603419.png)\n\n-   CPU 的根本任务是执行指令，我们常说的`取指-译码-执行-访存-写回`，就是典型的指令 Pipeline 操作；\n-   从 CPU 的功能出发，可以简要分成三个逻辑模块：\n    1.  `Control Unit`：CPU 的指挥中心，协调数据的移动；\n    2.  `ALU`：运算单元，执行 CPU 内部所有的计算；\n    3.  `Register`：寄存器和`Cache`，都算是 CPU 内部的存储单元，其中寄存器可用于存储需要被译码和执行的指令、数据、地址等；\n-   CPU 从内存中读取指令进行译码并执行，执行的过程中需要去访问内存中的数据，CPU 内部的寄存器可以暂存中间的指令和数据等信息，通常说的 CPU 的`context`指的就是 CPU 寄存器值；\n\n在硬件支持虚拟化之前，Qemu 纯软件虚拟化方案，是通过`tcg（tiny code generator）`的方式来进行指令翻译，翻译成 Host 处理器架构的指令来执行。硬件虚拟化技术，是让虚拟机能直接执行在 Host CPU 上，让 Host CPU 直接来执行虚拟机，结合 CPU 的实际工作原理，应该怎么来理解呢？来张图：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104500308-138886064.png)\n\n-   CPU 通过`pc`寄存器获取下一条执行指令，进行取指译码执行等操作，因此给定 CPU 一个 Context，自然就能控制其执行某些代码；\n-   CPU 的虚拟化，最终目标让虚拟机执行在 CPU 上，无非也是要进行 CPU 的 Context 切换，控制 CPU 去执行对应的代码，下文会进一步阐述；\n\n既然都讲 CPU 了，那就捎带介绍下 ARMv8 的寄存器吧：\n\n1.  通用寄存器：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104509594-1890798486.png)\n\n-   图中描述的是`EL3`以下，`AArch32`与`AArch64`寄存器对应关系；\n-   `AArch64`中，总共 31 个通用寄存器，64bit 的为 X0-X30，32bit 的为 W0-W30；\n\n2.  特殊用途寄存器：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104519960-2096557039.png)\n\n-   这些特殊用途的寄存器，主要分为三种：1）存放异常返回地址的`ELR_ELx`；2）各个 EL 的栈指针`SP_ELx`；3）CPU 的状态相关寄存器；\n\n3.  CPU 的状态`PSTATE`：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104530457-40443985.png)\n\n-   CPU 的状态在`AArch32`时是通过`CPSR`来获取，在`AArch64`中，使用`PSTATE`，`PSTATE`不是一个寄存器，它表示的是保存当前 CPU 状态信息的一组寄存器或一些标志信息的统称；\n\n好了，ARMv8 的介绍该打住了，否则要跑偏了。。。\n\n## 1.2 guest 模式\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104541723-159485278.png)\n\n-   Linux 系统有两种执行模式：kernel 模式与 user 模式，为了支持虚拟化功能的 CPU，KVM 向 Linux 内核提供了 guest 模式，用于执行虚拟机系统非 I/O 的代码；\n-   user 模式，对应的是用户态执行，Qemu 程序就执行在 user 模式下，并循环监听是否有 I/O 需要模拟处理；\n-   kernel 模式，运行 kvm 模块代码，负责将 CPU 切换到 VM 的执行，其中包含了上下文的 load/restore；\n-   guest 模式，本地运行 VM 的非 I/O 代码，在某些异常情况下会退出该模式，Host OS 开始接管；\n\n好了啦，前戏结束，开始直奔主题吧。\n\n# 2. 流程分析\n\n不管你说啥，我上来就是一句中国万岁，对不起，跑题了。我上来就是一张 Qemu 初始化流程图：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104601000-1844983544.png)\n\n-   看过 Qemu 源代码的人可能都有种感觉，一开始看好像摸不到门框，这图简要画了下关键模块的流程；\n-   Qemu 的源代码，后续的文章会详细介绍，本文只 focus 在`vcpu`相关部分；\n\n除了找到了`qemu_init_vcpu`的入口，这张图好像跟本文的 vcpu 的虚拟化关系不是很大，不管了，就算是给后续的 Qemu 分析打个广告吧。\n\n## 2.1 vcpu 的创建\n\n### 2.1.1 qemu 中 vcpu 创建\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104614683-924133375.png)\n\n-   Qemu 初始化流程图中，找到了`qemu_init_vcpu`的入口，顺着这个`qemu_init_vcpu`就能找到与底层 KVM 模块交互的过程；\n-   Qemu 中为每个 vcpu 创建了一个线程，操作设备节点来创建和初始化 vcpu；\n\n所以，接力棒甩到了 KVM 内核模块。\n\n### 2.1.2 kvm 中 vcpu 创建\n\n来一张前文的图：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104623675-27372564.png)\n\n-   前文中分析过，系统在初始化的时候会注册字符设备驱动，设置好了各类操作函数集，等待用户层的`ioctl`来进行控制；\n-   `Qemu`中设置`KVM_CREATE_VCPU`，将触发`kvm_vm_ioctl_create_vcpu`的执行，完成 vcpu 的创建工作；\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104631898-2017289936.png)\n\n-   在底层中进行 vcpu 的创建工作，主要是分配一个`kvm_vcpu`结构，并且对该结构中的字段进行初始化；\n-   其中有一个用于与应用层进行通信的数据结构`struct kvm_run`，分配一页内存，应用层会调用 mmap 来进行映射，并且会从该结构中获取到虚拟机的退出原因；\n-   `kvm_arch_vcpu_create`主要完成体系架构相关的初始化，包括 timer，pmu，vgic 等；\n-   `create_hyp_mappings`将`kvm_vcpu`结构体建立映射，以便在`Hypervisor`模式下能访问该结构；\n-   `create_vcpu_fd`注册了`kvm_vcpu_fops`操作函数集，针对 vcpu 进行操作，`Qemu`中设置`KVM_ARM_VCPU_INIT`，将触发`kvm_arch_vcpu_ioctl_vcpu_init`的执行，完成的工作主要是 vcpu 的核心寄存器，系统寄存器等的 reset 操作，此外还包含了上层设置下来的值，放置在`struct kvm_vcpu_init`中；\n\n## 2.2 vcpu 的执行\n\n### 2.2.1 qemu 中 vcpu 的执行\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104644801-1443039913.png)\n\n-   `Qemu`中为每一个 vcpu 创建一个用户线程，完成了 vcpu 的初始化后，便进入了 vcpu 的运行，而这是通过`kvm_cpu_exec`函数来完成的；\n-   `kvm_cpu_exec`函数中，调用`kvm_vcpu_ioctl(,KVM_RUN,)`来让底层的物理 CPU 进行运行，并且监测 VM 的退出，而这个退出原因就是存在放在`kvm_run->exit_reason`中，也就是上文中提到过的应用层与底层交互的机制；\n\n### 2.2.2 kvm 中 vcpu 的执行\n\n用户层通过`KVM_RUN`命令，将触发 KVM 模块中`kvm_arch_vcpu_ioctl_run`函数的执行：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104657586-2025556327.png)\n\n-   vcpu 最终是要放置在物理 CPU 上执行的，很显然，我们需要进行 context 的切换：保存好 Host 的 Context，并切换到 Guest 的 Context 去执行，最终在退出时再恢复回 Host 的 Context；\n-   `__guest_enter`函数完成最终的 context 切换，进入 Guest 的执行，当 Guest 退出时，`fixup_guest_exit`将会处理`exit_code`，判断是否继续返回 Guest 执行；\n-   当最终 Guest 退出到 Host 时，Host 调用`handle_exit`来处理异常退出，根据`kvm_get_exit_handler`去查询异常处理函数表对应的处理函数，最终进行执行处理；\n\n# 3. Sample Code\n\n-   上文已经将 Qemu+KVM 的 CPU 的虚拟化大概的轮廓已经介绍了，方方面面，问题不大；\n-   来一段 Sample Code 类比 Qemu 和 KVM 的关系，在 Ubuntu16.04 系统上进行测试；\n\n简要介绍一下：\n\n1.  tiny_kernel.S，相当于 Qemu 中运行的 Guest OS，完成的功能很简单，没错，就是`Hello, world`打印；\n2.  tiny_qemu.c，相当于 Qemu，用于加载 Guest 到 vCPU 上运行，最终通过 kvm 放到物理 CPU 上运行；\n\n鲁迅在 1921 年的时候，说过这么一句话：`Talk is cheap, show me the code`。\n```c\n- tiny_kernel.S：\n\nstart:\n/* Hello */\nmov     $0x48, %al\noutb    %al, $0xf1\nmov     $0x65, %al\noutb    %al, $0xf1\nmov     $0x6c, %al\noutb    %al, $0xf1\nmov     $0x6c, %al\noutb    %al, $0xf1\nmov     $0x6f, %al\noutb    %al, $0xf1\nmov     $0x2c, %al\noutb    %al, $0xf1\n\n/* world */\nmov     $0x77, %al\noutb    %al, $0xf1\nmov     $0x6f, %al\noutb    %al, $0xf1\nmov     $0x72, %al\noutb    %al, $0xf1\nmov     $0x6c, %al\noutb    %al, $0xf1\nmov     $0x64, %al\noutb    %al, $0xf1\n\nmov     $0x0a, %al\noutb    %al, $0xf1\n\nhlt\n\n-   `tiny_qemu.c`：\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/kvm.h>\n#include <sys/mman.h>\n\n#define KVM_DEV     \"/dev/kvm\"\n#define TINY_KERNEL_FILE    \"./tiny_kernel.bin\"\n#define PAGE_SIZE  0x1000\n\nint main(void)\n{\n    int kvm_fd;\n    int vm_fd;\n    int vcpu_fd;\n    int tiny_kernel_fd;\n    int ret;\n    int mmap_size;\n    \n    struct kvm_sregs sregs;\n    struct kvm_regs regs;\n    struct kvm_userspace_memory_region mem;\n    struct kvm_run *kvm_run;\n    void *userspace_addr;\n\n    /* open kvm device */\n    kvm_fd = open(KVM_DEV, O_RDWR);\n    assert(kvm_fd > 0);\n\n    /* create VM */\n    vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, 0);\n    assert(vm_fd >= 0);\n\n    /* create VCPU */\n    vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, 0);\n    assert(vcpu_fd >= 0);\n\n    /* open tiny_kernel binary file */\n    tiny_kernel_fd = open(TINY_KERNEL_FILE, O_RDONLY);\n    assert(tiny_kernel_fd > 0);\n    /* map 4K into memory */\n    userspace_addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    assert(userspace_addr > 0);\n    /* read tiny_kernel binary into the memory */\n    ret = read(tiny_kernel_fd, userspace_addr, PAGE_SIZE);\n    assert(ret >= 0);\n\n    /* set user memory region */\n    mem.slot = 0;\n    mem.flags = 0;\n    mem.guest_phys_addr = 0;\n    mem.memory_size = PAGE_SIZE;\n    mem.userspace_addr = (unsigned long)userspace_addr;\n    ret = ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &mem);\n    assert(ret >= 0);\n\n    /* get kvm_run */\n    mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, NULL);\n    assert(mmap_size >= 0);\n    kvm_run = (struct kvm_run *)mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu_fd, 0);\n    assert(kvm_run >= 0);\n\n    /* set cpu registers */\n    ret = ioctl(vcpu_fd, KVM_GET_SREGS, &sregs);\n    assert(ret >= 0);\n    sregs.cs.base = 0;\n    sregs.cs.selector = 0;\n    ret = ioctl(vcpu_fd, KVM_SET_SREGS, &sregs);\n    memset(®s, 0, sizeof(struct kvm_regs));\n    regs.rip = 0;\n    ret = ioctl(vcpu_fd, KVM_SET_REGS, ®s);\n    assert(ret >= 0);\n\n    /* vcpu run */\n    while (1) {\n        ret = ioctl(vcpu_fd, KVM_RUN, NULL);\n        assert(ret >= 0);\n\n        switch(kvm_run->exit_reason) {\n            case KVM_EXIT_HLT:\n                printf(\"----KVM EXIT HLT----\\n\");\n                close(kvm_fd);\n                close(tiny_kernel_fd);\n                return 0;\n            case KVM_EXIT_IO:\n                putchar(*(((char *)kvm_run) + kvm_run->io.data_offset));\n                break;\n            default:\n                printf(\"Unknow exit reason: %d\\n\", kvm_run->exit_reason);\n                break;\n        }\n    }\n\n    return 0;\n}\n```\n\n为了表明我没有骗人，上一张在 Ubuntu16.04 的虚拟机上运行的结果图吧：\n\n![](https://img2020.cnblogs.com/blog/1771657/202010/1771657-20201011104712313-1064794656.png)","tags":["arm","qemu","kvm"],"categories":["虚拟化","kvm"]},{"title":"KVM-Qemu 分析（3）之 KVM 源码","url":"/2023/03/19/hxd_new/虚拟化/Linux 虚拟化 KVM-Qemu 分析（3）之 KVM 源码/","content":"\n# 背景\n\n-   `Read the fucking source code!` --By 鲁迅\n-   `A picture is worth a thousand words.` --By 高尔基\n\n说明：\n\n1.  KVM 版本：5.9.1\n2.  QEMU 版本：5.0.0\n3.  工具：Source Insight 3.5， Visio\n4.  文章同步在博客园：`https://www.cnblogs.com/LoyenWang/`\n\n# 1. 概述\n\n-   从本文开始将开始`source code`的系列分析了；\n-   `KVM`作为内核模块，可以认为是一个中间层，向上对接用户的控制，向下对接不同架构的硬件虚拟化支持；\n-   本文主要介绍体系架构初始化部分，以及向上的框架；\n\n![image-20240416110125240](attachments/image-20240416110125240.png)\n\n# 2. KVM 初始化\n\n-   贝多芬曾经说过，一旦你找到了代码的入口，你就扼住了软件的咽喉；\n-   我们的故事，从`module_init(arm_init)`开始，代码路径：`arch/arm64/kvm/arm.c`；\n\n老规矩，先来一张图（`图片中涉及到的红色框函数，都是会展开描述的`）：\n\n![image-20240416110142495](attachments/image-20240416110142495.png)\n\n-   内核的功能模块，基本上的套路就是：1）完成模块初始化，向系统注册；2）响应各类请求，这种请求可能来自用户态，也可能来自异常响应等；\n-   `kvm`的初始化，在`kvm_init`中完成，既包含了体系结构相关的初始化设置，也包含了各类回调函数的设置，资源分配，以及设备注册等，只有当初始化完成后，才能响应各类请求，比如创建虚拟机等；\n    1.  回调函数设置：`cpuhp_setup_state_nocall`与 CPU 的热插拔相关，`register_reboot_notifer`与系统的重启相关，`register_syscore_ops`与系统的休眠唤醒相关，而这几个模块的回调函数，最终都会去调用体系结构相关的函数去打开或关闭`Hypervisor`；\n    2.  资源分配：`kmem_cache_create_usercopy`与`kvm_async_pf_init`都是创建`slab缓存`，用于内核对象的分配；\n    3.  `kvm_vfio_ops_init`：`VFIO`是一个可以安全将设备`I/O`、中断、DMA 导出到用户空间的框架，后续在将 IO 虚拟化时再深入分析；\n-   图片中红色的两个函数，是本文分析的内容，其中`kvm_arch_init`与前文`ARMv8`硬件虚拟化支持紧密相关，而`misc_register`与上层操作紧密相关；\n\n## 2.1 `kvm_arch_init`\n\n-   `It's a big topic, I'll try to put it in a nutshell.`\n-   这部分内容，设计 ARMv8 体系结构，建议先阅读`《Linux虚拟化KVM-Qemu分析（二）之ARMv8虚拟化》`；\n-   红色框的函数是需要进一步展开讲述的；\n\n![image-20240416110149365](attachments/image-20240416110149365.png)\n\n-   `is_hyp_mode_available`用于判断 ARMv8 的`Hyp`模式是否可用，实际是通过判断`__boot_cpu_mode`的值来完成，该值是在`arch/arm64/kernel/head.S`中定义，在启动阶段会设置该值：\n\n![image-20240416110157924](attachments/image-20240416110157924.png)\n\n-   `is_kernel_in_hyp_mode`，通过读取 ARMv8 的`CurrentEL`，判断是否为`CurrentEL_EL2`；\n-   ARM 架构中，`SVE`的实现要求`VHE`也要实现，这个可以从`arch/arm64/Kconfig`中看到，`SVE`的模块编译：`depends on !KVM || ARM64_VHE`。`SVE（scalable vector extension）`，是`AArch64`下一代的`SIMD（single instruction multiple data）`指令集，用于加速高性能计算。其中`SIMD`如下：\n\n![image-20240416110206914](attachments/image-20240416110206914.png)\n\n-   `init_common_resources`，用于设置`IPA`的地址范围，将其限制在系统能支持的物理地址范围之内。`stage 2`页表依赖于`stage 1`页表代码，需要遵循一个条件：`Stage 1`的页表级数 >= `Stage 2`的页表级数；\n\n### 2.1.1 `init_hyp_mode`\n\n![image-20240416110216437](attachments/image-20240416110216437.png)\n\n-   放眼望去，`init_hyp_mode`解决的问题就是各种映射，最终都会调用到`__create_hyp_mappings`，先来解决这个映射问题：\n\n![image-20240416110224472](attachments/image-20240416110224472.png)\n\n-   看过之前内存管理子系统的同学，应该熟悉这个页表映射建立的过程，基本的流程是给定一个虚拟地址区间和物理地址，然后从`pgd`开始逐级往下去建立映射。ARMv8 架构在实际映射过程中，`P4D`这一级页表并没有使用。\n\n让我们继续回到`init_hyp_mode`的正题上来，这个函数完成了`PGD`页表的分配，完成了`IDMAP代码段`的映射，完成了其他各种段的映射，完成了异常向量表的映射，等等。此外，再补充几点内容：\n\n1.  `ARMv8异常向量表`\n\n![image-20240416110233444](attachments/image-20240416110233444.png)\n\n-   ARMv8 架构的 AArch64 执行态中，每种 EL 都有 16 个 entry，分为四类：`Synchronous，IRQ，FIQ，SError`。以系统启动时设置 hypervisor 的异常向量表`__hyp_stub_vectors`为例：\n\n![image-20240416110239895](attachments/image-20240416110239895.png)\n\n-   当从不同的`Exception Level`触发异常时，根据执行状态，去选择对应的`handler`处理，比如上图中只有`el1_sync`有效，也就是在`EL1`状态触发`EL2`时跳转到该函数；\n\n2.  `pushsection/popsection`\n\n-   在`init_hyp_mode`函数中，完成各种段的映射，段的定义放置在`vmlinux.lds.S`中，比如`hyp.idmap.text`：\n\n![image-20240416110245685](attachments/image-20240416110245685.png)\n\n-   可以通过`pushsection/popsection`来在目标文件中来添加一个段，并指定段的属性，比如 \"ax\" 代表可分配和可执行，这个在汇编代码中经常用到，比如`hyp-init.S`中，会将代码都放置在`hyp.idmap.text`中：\n\n![image-20240416110253334](attachments/image-20240416110253334.png)\n\n-   除了`pushsection/popsection`外，通过`#define __hyp_text __section(.hyp.text) notrace __noscs`的形式也能将代码放置在指定的段中；\n\n3.  `Hypervisor相关寄存器`\n\n-   讲几个关键的相关寄存器：  \n    1）`sctlr_el2(System Control Register)`：可以用于控制 EL2 的 MMU 和 Cache 相关操作；  \n    2）`ttbr0_el2(Translation Table Base Register 0)`：用于存放页表的基地址，上文中提到分配的`hyp_pgd`就需要设置到该寄存器中；  \n    3）`vbar_el2(Vector Base Address Register)`：用于存放异常向量表的基地址；\n\n我们需要先明确几点：\n\n1.  `Hyp`模式下要执行的代码，需要先建立起映射；\n2.  映射`IDMAP代码段`和其他代码段，明确这些段中都有哪些函数，这个可以通过`pushsection/popsection`以及`__hyp_text`宏可以看出来；\n3.  最终的目标是需要建立好页表映射，并安装好异常向量表；\n\n貌似内容比较零碎，最终的串联与谜题留在下一小节来解答。\n\n### 2.1.2 `init_subsystems`\n\n先看一下函数的调用流程：\n\n![image-20240416110301469](attachments/image-20240416110301469.png)\n\n-   `VGIC`，`timer`，以及电源管理相关模块在本文中暂且不深入分析了，本节主要关心`cpu_hyp_reinit`的功能；\n-   绿色框中的函数，会陷入到`EL2`进行执行；\n\n看图中有好几次异常向量表的设置，此外，还有页表基地址、栈页的获取与设置等，结合上一小节的各类映射，是不是已经有点迷糊了，下边这张图会将这些内容串联起来：\n\n![image-20240416110306248](attachments/image-20240416110306248.png)\n\n-   在整个异常向量表创建的过程中，涉及到三个向量表：`__hyp_stub_vectors`，`__kvm_hyp_init`， `__kvm_call_hyp`，这些代码都是汇编实现；\n-   在系统启动过程中 (`arch/arm64/kernel/head.S`)，调用到`el2_setup`函数，在该函数中设置了一个临时的异常向量表，也就是先打一个桩，这个从名字也可以看出来，该异常向量表中仅实现了`el2_sync`的`handler`处理函数，可以应对两种异常：1）设置新的异常向量表；2）重置异常向量表，也就是设置回`__hyp_stub_vectors`；\n-   在`kvm`初始化时，调用了`__hyp_set_vectors`来设置新的异常向量表：`__kvm_hyp_init`。这个向量表中只实现了`__do_hyp_init`的处理函数，也就是只能用来对`Hyp模式`进行初始化。上文提到过`idmap段`，这个代码就放置在`idmap段`，以前分析内存管理子系统时也提到过`idmap`，为什么需要这个呢？`idmap: identity map`，也就是物理地址和虚拟地址是一一映射的，防止 MMU 在使能前后代码不能执行；\n-   `__kvm_call_hyp`函数，用于在`Hyp模式`下执行指定的函数，在`cpu_hyp_reinit`函数中调用了该函数，传递的参数包括了新的异常向量表地址，页表基地址，`Hyp`的栈地址，`per-CPU`偏移等，最终会调用`__do_hyp_init`函数完成相应的设置。\n\n到此，页表和异常向量表的设置算是完成了。\n\n## 2.2 `misc_register`\n\n`misc_register`用于注册字符设备驱动，在`kvm_init`函数中调用此函数完成注册，以便上层应用程序来使用`kvm模块`：\n\n![image-20240416110317124](attachments/image-20240416110317124.png)\n\n-   字符设备的注册分为三级，分别代表`kvm`, `vm`, `vcpu`，上层最终使用底层的服务都是通过`ioctl`函数来操作；\n-   `kvm`：代表 kvm 内核模块，可以通过`kvm_dev_ioctl`来管理 kvm 版本信息，以及 vm 的创建等；\n-   `vm`：虚拟机实例，可以通过`kvm_vm_ioctl`函数来创建`vcpu`，设置内存区间，分配中断等；\n-   `vcpu`：代表虚拟的 CPU，可以通过`kvm_vcpu_ioctl`来启动或暂停 CPU 的运行，设置 vcpu 的寄存器等；\n\n以`Qemu`的使用为例：\n\n1.  打开`/dev/kvm`设备文件；\n2.  `ioctl(xx, KVM_CREATE_VM, xx)`创建虚拟机对象；\n3.  `ioctl(xx, KVM_CREATE_VCPU, xx)`为虚拟机创建 vcpu 对象；\n4.  `ioctl(xx, KVM_RUN, xx)`让 vcpu 运行起来；\n\n# 3. 总结\n\n本文主要从两个方向来介绍了`kvm_init`：\n\n1.  底层的体系结构相关的初始化，主要涉及的就是`EL2`的相关设置，比如各个段的映射，异常向量表的安装，页表基地址的设置等，当把这些准备工作做完后，才能在硬件上去支持虚拟化的服务请求；\n2.  字符设备注册，设置好各类`ioctl`的函数，上层应用程序可以通过字符设备文件，来操作底层的 kvm 模块。这部分内容深入的分析，留到后续的文章再展开了；\n\n实际在看代码过程中，一度为很多细节绞尽乳汁，对不起，是绞尽脑汁，每有会意，便欣然忘食，一文也无法覆盖所有内容，草率了。","tags":["arm","kvm"],"categories":["虚拟化","kvm"]},{"title":"arm smmuv3 代码分析","url":"/2023/03/19/hxd_new/虚拟化/arm smmuv3 代码分析/","content":"\n\n\n本文主要分析 linux kernel 中 SMMUv3 的代码 (drivers/iommu/arm-smmu-v3.c)\nlinux kernel 版本是 linux 5.7, 体系结构是 aarch64\n\n# smmu 的位置\n\n![](attachments/smmuv1.png)\n\nSMMU 的作用是把 CPU 提交给设备的 VA 地址，直接作为设备发出的地址，变成正确的物理地址，访问到物理内存上。\n和 mmu 不同的是，一个 smmu 可以有多个设备连着，他们的页表不可能复用，SMMU 用 stream id 作区分。\n一个设备有多个进程，所以 smmu 单元也要支持多页表，smmu 使用 substream id 区分多进程的页表。\n\n# smmu 的设备节点定义\n在讨论 smmu 的代码前，先看下 smmu 的设备节点是怎么定义的：\nExample：\n\n\n```c\nsmmu@2b400000 {\n                compatible = \"arm,smmu-v3\";\n                reg = <0x0 0x2b400000 0x0 0x20000>;\n                interrupts = <GIC_SPI 74 IRQ_TYPE_EDGE_RISING>,\n                             <GIC_SPI 75 IRQ_TYPE_EDGE_RISING>,\n                             <GIC_SPI 77 IRQ_TYPE_EDGE_RISING>,\n                             <GIC_SPI 79 IRQ_TYPE_EDGE_RISING>;\n                interrupt-names = \"eventq\", \"priq\", \"cmdq-sync\", \"gerror\";\n                dma-coherent;\n                #iommu-cells = <1>;\n                msi-parent = <&its 0xff0000>;\n        };\n```\n\ncompatible: 用于匹配 smmu 驱动。\nreg：smmu 设备的物理基地址。\ninterrupts: 描述与中断名称对应的 smmu 中断源，上述分别对应中断类型，中断号以及中断触发方式。\ninterrupt-names: 中断名称。\neventq，当 event queue 从空变为非空状态时上报中断。\npriq, 当 pri queue 从空变为非空状态时上报中断。\ncmdq-sync, command queue 中 CMDQ_SYNC 命令完成时产生中断。\ngerror，event 记录到 event queue 过程中产生的错误会记录在 SMMU_GERROR 寄存器中，并产生中断。\ncombined，组合中断，需要硬件支持，如果提供了组合中断，则将优先使用组合中断。\ndma-coherent：表示设备通过 smmu 进行的 DMA 访问是否 cache coherent 的，假设 DMA 把外设的数据搬运到内存的某个位置，cpu 去读那段地址，因为 cache 命中了，读到的还是旧的值，这就是 cache 的不 coherent。\n`#iommu-cells`: 一个 cell 代表一个 streamid, smmu-v3 必须定义为 1。\nmsi-parent：指定 msi 中断控制器。\n\n# SMMU 结构体\n\n```c\nstruct arm_smmu_domain {\n\tstruct arm_smmu_device\t\t*smmu;\n\tstruct mutex\t\t\tinit_mutex; /* Protects smmu pointer */\n\n\tstruct io_pgtable_ops\t\t*pgtbl_ops;\n\tbool\t\t\t\tnon_strict;\n\tatomic_t\t\t\tnr_ats_masters;\n\n\tenum arm_smmu_domain_stage\tstage;\n\tunion {\n\t\tstruct arm_smmu_s1_cfg\ts1_cfg;\n\t\tstruct arm_smmu_s2_cfg\ts2_cfg;\n\t};\n\n\tstruct iommu_domain\t\tdomain;\n\n\tstruct list_head\t\tdevices;\n\tspinlock_t\t\t\tdevices_lock;\n};\n```\n\narm_smmu_device: 指定 smmu 设备\nio_pgtable_ops: io 页表映射定义的一系列操作\nnon_strict: smmu non-strict 模式，在该补丁集中引入 add non-strict mode support for arm-smmu-v3，\n主要是为了解决开启 smmu 后，频繁的 unmap，需要频繁的 invalid tlb 带来的性能损失， 所以不在每一次 unmap 后都进行 tlb invalidate 操作，而是累计一定次数或者时间后执行 invalid all 操作，但这样是有一定的安全风险（页表虽然释放了但是还是在 tlb 中有残留，可能被利用到）。可以通过启动参数控制。\nnr_ats_masters: ats 的设备数量，enable_ats 时数量 + 1， disable ats 时数量减 1\narm_smmu_domain_stage: 代表 smmu 支持的方式，支持 stage1 的转换，stage2 的转换，stage1 + stage2 的转换，以及 bypass 模式。\narm_smmu_s1_cfg: stage1 转换需要的数据结构\narm_smmu_s2_cfg: stage2 转换需要的数据结构\n\n# smmu 驱动初始化\n从 smmu 驱动的 probe 函数开始分析\n\n```erlang\n+->arm_smmu_device_probe() //smmu设备驱动probe入口函数\n\t+-> arm_smmu_device_dt_probe() //smmu设备树解析\n\t+-> platform_get_irq_byname() // smmu设备中断解析\n\t+-> arm_smmu_device_hw_probe() // smmu硬件规格探测\n\t+-> arm_smmu_init_structures() //smmu 数据结构初始化\n\t+-> arm_smmu_device_reset() // smmu设备复位, 硬件初始化配置\n\t+-> iommu_device_register() // iommu设备注册\n\t+-> arm_smmu_set_bus_ops() // 给支持的总线设置bus->iommu_ops\n```\n\n对 probe 中调用的这些函数进行详细分析\n## (1)arm_smmu_device_dt_probe\n\n\n```c\nstatic int arm_smmu_device_dt_probe(struct platform_device *pdev,\n\t\t\t\t    struct arm_smmu_device *smmu)\n{\n\tint ret = -EINVAL;\n\tif (of_property_read_u32(dev->of_node, \"#iommu-cells\", &cells))   ---- (a)\n\t\tdev_err(dev, \"missing #iommu-cells property\\n\");\n\telse if (cells != 1)\n\t\tdev_err(dev, \"invalid #iommu-cells value (%d)\\n\", cells);\n\telse\n\t\tret = 0;\n\t\t\n\tparse_driver_options(smmu);          ----- (b)\n\t\n\tif (of_dma_is_coherent(dev->of_node))         ---- (c)\n\t\tsmmu->features |= ARM_SMMU_FEAT_COHERENCY;\n\n\treturn ret;\n}\n```\n\na. 读取设备树，看 smmu 的设备节点定义中 `#iommu-cells` 是否为 1， 如果不为 1 则直接 bypass 掉 smmu\n\nb. parse_driver_options, 主要解析 smmu 是否有需要规避的硬件 bug\n\nc. 解析 smmu 设备中的 dma-coherent 属性\n\n## (2) platform_get_irq_byname\n\n\n```c\n/* Interrupt lines */\n\n\tirq = platform_get_irq_byname_optional(pdev, \"combined\");  \n\tif (irq > 0)\n\t\tsmmu->combined_irq = irq;\n\telse {\n\t\tirq = platform_get_irq_byname_optional(pdev, \"eventq\"); \n\t\tif (irq > 0)\n\t\t\tsmmu->evtq.q.irq = irq;\n\n\t\tirq = platform_get_irq_byname_optional(pdev, \"priq\");\n\t\tif (irq > 0)\n\t\t\tsmmu->priq.q.irq = irq;\n\n\t\tirq = platform_get_irq_byname_optional(pdev, \"gerror\");\n\t\tif (irq > 0)\n\t\t\tsmmu->gerr_irq = irq;\n\t}\n```\n\n分别获取 dts 节点中定义的 \"combined\", “eventq”, “priq”, \"gerror\" 中断号\n\n## (3) arm_smmu_device_hw_probe\n该函数主要探测 smmu 设备的硬件规格，主要是通过读 SMMU 的 IDR0,IDR1,IDR5 寄存器确认\n\n### SMMU_IDR0:\n\n\n\n| 域段        | offset | 作用                                                         |\n| ----------- | ------ | ------------------------------------------------------------ |\n| ST_LEVEL    | 28: 27 | 确认 stream table 格式是线性 table 还是 2-level table        |\n| TERM_MODEL  | 26     | fault 的处理方式，                                           |\n| STALL_MODEL | 25: 24 | 确认是否是 stall mode。 该模式下 smmu 会暂停引发 stall 的 transaction, 然后 stall，之后根据软件的 commad 是 resume 还是 stall_term 来决定 stall 命令是 retry 还是 terminate。当前只允许 4 种 fault 类型被 stall: F_TRANSLATION, F_ACCESS, F_ADDR_SIZE. F_PERMISSION.【spec 5.5 Fault configuration (A,R,S bits)】 |\n| TTENDIAN    | 22: 21 | 确认 traslation table 支持的大小端模式                       |\n| CD2L        | 19     | 确认是否支持 2-level 的 CD table                             |\n| VMW         | 17     | 用于控制 vmid wildcards 的功能和范围。 vmid wildcard， vmid 的模糊匹配，是为了方便 tlb 无效化， 两种 tlb 无效化的方式：command 和广播 tlb 无效都会使用到 vmid wildcards |\n| VMID16      | 18     | 确认是否支持 16bit VMID。 每一个虚拟机都被分配一个 ID 号，这个 ID 号用于标记某个特定的 TLB 项属于哪一个 VM。每一个 VM 有它自己的 ASID 空间。例如两个不同的 VMs 同时使用 ASID 5，但指的是不同的东西。对于虚拟机而言，通常 VMID 会结合 ASID 同时使用。 |\n| PRI         | 16     | 确认是否支持 page request interface。 属于 pcie 硬件特性，PCIe 设备可以发出缺页请求，SMMU 硬件在解析到缺页请求后可以直接将缺页请求写入 PRI queueu, 软件在建立好页表后，可以通过 CMD queue 发送 PRI response 给 PCIe 设备。[ [Linux SVA 特性分析\\]](https://blog.csdn.net/scarecrow_byr/article/details/100983619) |\n| SEV         | 14     | 确认是否支持 WFE wake-up 事件的产生。 当 SEV == 1 时，command queue 从满到非满状态会触发 WFE wake-up event。 此外，当 CMD_SYNC 完成且要求 SIG_SEV 时也会产生 WFE wake-up event |\n| MSI         | 13     | 确认是否支持 MSI 消息中断                                    |\n| ASID16      | 12     | 确认是否支持 16bit ASID.。 在 TLB 的表项中，每个项都有一个 ASID，当切换进程的时候，TLB 中可以存在多个进程的页表项, 不再需要清空 TLB，因为 B 进程用不了里面 A 进程的页表项，可以带来性能提升。[[TLB flush 操作\\]](http://www.wowotech.net/memory_management/tlb-flush.html) |\n| ATS         | 10     | Address Translation Service， 也是 pcie 的硬件特性，有 ATS 能力的 PCIE，自带地址翻译功能，如果它要发出一个地址，进入 PCIE 总线的时候，一定程度上可以认为就是物理地址。ats 会在设备中缓存 va 对应的 pa, 设备随后使用 pa 做内存访问时无需经过 SMMU 页表转换，可以提高性能。 【[PCIe/SMMU ATS analysis note](https://blog.csdn.net/scarecrow_byr/article/details/74276940)】 |\n| HTTU        | 7:6    | Hardware Translation Table Update，在访问或写入相关页面后，硬件自动更新相关页面的 Access flag、Dirty state。该特性和 armv8.1 的 tthm 特性一样，在没有 tthm 特性之前，软件去更新页表的 young 和 dirty page, 会有一定的开销。 |\n| S1P         | 1      | 确认是否支持 stage1 转换，va->pa                             |\n| S2P         | 0      | 确认是否支持 stage2 转换，ipa->pa                            |\n\n### SMMU_IDR1:\n\n\n\n| 域段          | offset | 作用                                                         |\n| ------------- | ------ | ------------------------------------------------------------ |\n| TABLES_PRESET | 30     | 确认 smmu_strtab_base 和 smmu_strtab_base_cfg 的基地址是否固定， smmu_strtab_base 是 stream table 的物理基地址，smmu_strtab_base_cfg 是 stream table 的配置寄存器 |\n| QUEUES_PRESET | 29     | 确认 smmu queue 的基地址是否固定，queue 指的是 smmu event queue, smmu cmd queue, smmu pri queue |\n| CMDQS         | 25:21  | cmd queue 最大 entry 数目, 等于 log2(entries)， 最大是 19    |\n| EVENTQS       | 20:16  | event queue 的最大 entry 数目，等于 log2(entries)， 最大是 19 |\n| PRIQS         | 15:11  | pri queue 最大 entry 数目，等于 log2(entries)， 最大是 19    |\n| SSIDSIZE      | 10:6   | 确认硬件支持 substreamID 的 bit 数，范围为【0，20】， 0 表示不支持 substreamid |\n| SIDSIZE       | 5:0    | 确认硬件支持 streamID 的 bit 数，范围为【0，32】， 0 表示支持一个 stream |\n\n\nIDR1 主要用来设置 smmu 各个 queue 的 entry 数量, 设置 ssid 和 sid 的 size.\n\n\n\n### SMMU_IDR5:\n\n\n| 域段      | offset | 作用                                                         |\n| --------- | ------ | ------------------------------------------------------------ |\n| STALL_MAX | 31:16  | smmu 支持的最大未完成 stall 事务数                           |\n| VAX       | 11:10  | 表示 smmu 支持的 va 地址是 48bit 还是 52bit                  |\n| GRAN64K   | 6      | 支持 64KB 翻译粒度， Translation Granule 表示 translation table 的 size 大小， 页表粒度是 smmu 管理的最小地址空间 |\n| GRAN16K   | 5      | 支持 16KB 翻译粒度                                           |\n| GRAN4K    | 4      | 支持 4KB 翻译粒度                                            |\n| OAS       | 2:0    | 表示 output address size, 32bit ~ 52bit                      |\n\n\n\nIDR5 主要设置 smmu ias(input address size) 和 oas (output address size), ias 代表 IPA，oas 代表 PA。\n\n## (4) arm_smmu_init_structures()\nsmmu 相关的数据结构的内存申请和初始化\n\n```c\nstatic int arm_smmu_init_structures(struct arm_smmu_device *smmu)\n{\n\tint ret;\n\n\tret = arm_smmu_init_queues(smmu); ----------------- (a)\n\tif (ret)\n\t\treturn ret;\n\t\n\treturn arm_smmu_init_strtab(smmu);  ----------------- (b)\n\n}\n```\n\n\n\n(a) arm_smmu_init_queues() 会初始化三个 queue, 分别为 cmd queue, event queue, pri queue.\nSMMU 使用这 3 个队列做基本的事件管理。\nevent queue 用于记录软件配置错误的状态信息，smmu 将配置错误信息记录到 event queue 中，软件会通过从 event queue 读取配置错误信息，然后进行相应的配置错误处理。\n软件使用 command queue 和 smmu 硬件进行交互，软件写命令发送到 command queue 中，smmu 会从 command queue 中读取命令进行处理。\npri queue 需要硬件支持 pri 特性，和 event queue 类似，当有相应硬件事件发生时，硬件把相应的描述符写入 pri queue, 然后上报中断。\n\n(b) arm_smmu_init_strtab\n\n\n```c\nstatic int arm_smmu_init_strtab(struct arm_smmu_device *smmu)\n{\n\tu64 reg;\n\tint ret;\n\n\tif (smmu->features & ARM_SMMU_FEAT_2_LVL_STRTAB)  \n\t\tret = arm_smmu_init_strtab_2lvl(smmu);\n\telse\n\t\tret = arm_smmu_init_strtab_linear(smmu);\n\t\n\tif (ret)\n\t\treturn ret;\n\t\n\t/* Set the strtab base address */\n\treg  = smmu->strtab_cfg.strtab_dma & STRTAB_BASE_ADDR_MASK; \n\treg |= STRTAB_BASE_RA;\n\tsmmu->strtab_cfg.strtab_base = reg;\n\t\n\t/* Allocate the first VMID for stage-2 bypass STEs */\n\tset_bit(0, smmu->vmid_map);\n\treturn 0;\n}\n```\n\n首先确认 SMMU 的 stream table 的组织方式是线性 table 还是 2-level table.\n如果是 linear table:\n\n![image-20240416105935403](attachments/image-20240416105935403.png)\n\n使用 STRTAB_BASE + sid * 64（一个 STE 的大小为 64B）找到 STE\n\n\n```erlang\n+-> arm_smmu_init_strtab_linear\n\t// 计算stream table的size, 如果使用linear 查找，stream table的size = sid * 64（sid表示有多少个ste, 一个STE的大小为64B）\n\t+-> size = (1 << smmu->sid_bits) * (STRTAB_STE_DWORDS << 3); \n\t// 申请Stream table的内存\n\t+-> strtab = dmam_alloc_coherent()\n\t// 配置stream table（STRTAB_BASE_CFG）的format, 决定stream table的格式是linear\n\t+-> reg  = FIELD_PREP(STRTAB_BASE_CFG_FMT, STRTAB_BASE_CFG_FMT_LINEAR);\n\t// 配置stream table（STRTAB_BASE_CFG）的log2size, ste的entry数目是2 ^ log2size\n\t+-> reg |= FIELD_PREP(STRTAB_BASE_CFG_LOG2SIZE, smmu->sid_bits);  \n\t// cfg->num_l1_ents对应的是sid, 对SMMU下的所有sid逐一调用arm_smmu_write_strtab_ent\n\t+-> arm_smmu_init_bypass_stes(strtab, cfg->num_l1_ents) \n\t\t+-> arm_smmu_write_strtab_ent()\n\t\t\t// 发送CMDQ_OP_PREFETCH_CFG\n\t\t\t+-> arm_smmu_cmdq_issue_cmd()\n```\n\n如果是 2-level table:\n\n\n![image-20240416105955813](attachments/image-20240416105955813.png)\n\n先通过 sid 的高位找到 L1_STD（STRTAB_BASE + sid[9:8] * 8, 一个 L1_STD 的大小为 8B）, L1_STD 定义了下一级查找的基地址，然后通过 sid 找到具体的 STE（l2ptr + sid[7:0] * 64）.\n\n结合代码分析：\n\n\n```erlang\n+-> arm_smmu_init_strtab_2lvl()\n\t\t\"计算l1的大小, 一个l1 std的大小为8byte, 对应的l1_std = sid[maxbit:split], maxbit是log2Size - 1, 所以l1的大小等于2 ^ (log2Size - split) * 8  \"\n\t+-> l1size = cfg->num_l1_ents * (STRTAB_L1_DESC_DWORDS << 3);\n\t\t\"申请L1 stream table的空间\"\n\t+->  strtab = dmam_alloc_coherent()\n\t\t\"配置stream table（STRTAB_BASE_CFG）的format, 决定stream table的格式是2-level\"\n\t+-> reg  = FIELD_PREP(STRTAB_BASE_CFG_FMT, STRTAB_BASE_CFG_FMT_2LVL);\n\t\t\"配置stream table（STRTAB_BASE_CFG）的log2size,2级ste的entry是2 ^ log2size, l1 std的 entry大小为2 ^ (log2size - split)\"\n\t+-> reg |= FIELD_PREP(STRTAB_BASE_CFG_LOG2SIZE, size);\n\t\t\"配置stream table（STRTAB_BASE_CFG）的split, split的值可以被配置为6/8/10, \t分别对应l1 std能够指向的最大二级ste的空间为4k/16k/64k\"\n\t+-> reg |= FIELD_PREP(STRTAB_BASE_CFG_SPLIT, STRTAB_SPLIT);\n\t\t\" 分配L1STD的内存, 并配置L1 descriptor的SPAN，SPAN表示L2 table包含多少个STE \"\n\t+-> arm_smmu_init_l1_strtab()\n```\n\n申请 l1 Stream table 的内存，内存大小为 2 ^ (log2Size - split) * 8\n申请 L1 STD 的内存， L1 STD 在 stream table 的索引是 streamID[maxbit: split]\n配置完 stream table 的结构和各级大小后，再配置 stream table 的基地址:\n\n\n```erlang\n\t\t\"配置stream table（STRTAB_BASE_CFG）的RA和addr, addr对应的是stream table的物理地址ra为read allocate hint \"\n\t+-> reg  = smmu->strtab_cfg.strtab_dma & STRTAB_BASE_ADDR_MASK;\n\t+-> reg |= STRTAB_BASE_RA;\n```\n\n至此 stream table 的初始化流程结束\n\n## (5) arm_smmu_device_reset\n该函数主要是进行 smmu 的硬件配置\n主要流程如下：\n\n\n```erlang\n+-> arm_smmu_device_reset()\n\t\t\"写SMMU_CR0来disable smmu,并通过SMMU_CR0ACK检查CR0是否被clear\"\n\t+-> arm_smmu_device_disable()\n\t\t\"配置读取ste和command queue的属性\"\n\t+-> writel_relaxed(ARM_SMMU_CR1);\n\t\t\"random crap\"\n\t+-> writel_relaxed(ARM_SMMU_CR2);\n\t\t\"配置 ARM_SMMU_STRTAB_BASE 寄存器，分别对应stream table的物理基地址以及格式，大小等\"\n\t+->writeq_relaxed(smmu->strtab_cfg.strtab_base, ARM_SMMU_STRTAB_BASE);\n\t+->writel_relaxed(smmu->strtab_cfg.strtab_base_cfg, ARM_SMMU_STRTAB_BASE);\n\t\t/* 配置cmd queue相关寄存器\n\t\t * ARM_SMMU_CMDQ_BASE   是配置command queue的基地址\n\t\t * ARM_SMMU_CMDQ_PROD， 可以表示取出命令的位置\n\t\t * ARM_SMMU_CMDQ_CONS， 可以表示输入命令的位置\n\t\t * ARM_SMMU_CMDQ_PROD和ARM_SMMU_CMDQ_CONS初始化时配置为相同的值，都为0\n\t\t * 通过CMDQ_PROD和CMDQ_CONS， 可以判断command queue是否还有空间\n\t\t */\n\t+-> writeq_relaxed(smmu->cmdq.q.q_base, smmu->base + ARM_SMMU_CMDQ_BASE);\n\t+-> writel_relaxed(smmu->cmdq.q.llq.prod, smmu->base + ARM_SMMU_CMDQ_PROD);\n\t+-> writel_relaxed(smmu->cmdq.q.llq.cons, smmu->base + ARM_SMMU_CMDQ_CONS);\n\t\t\"最后配置command queue的en，对command queue进行使能\"\n\t+-> enables = CR0_CMDQEN;\n\t\t\"配置event queue相关寄存器， 流程和command queue类似\"\n\t+-> config event queue\n\t\t\"如果支持pri, 则配置pri queue相关寄存器, 流程和上面一致\"\n\t+-> config pri queue\n\t\t\"申请并使能smmu支持的相关中断（eventq irq, priq irq, gerror irq）\"\n\t+-> arm_smmu_setup_irqs()\n\t\t\"enable smmu, 写SMMU_CR0，并通过SMMU_CR0ACK检查CR0是否被enable\"\n\t+-> arm_smmu_write_reg_sync(smmu, enables, ARM_SMMU_CR0, ARM_SMMU_CR0ACK);\n```\n\n再着重讲下 smmu 的中断注册：arm_smmu_setup_irqs()\n\n\n```erlang\n+-> arm_smmu_setup_irqs()\n\t+-> arm_smmu_setup_unique_irqs()\n\t\t+-> arm_smmu_setup_msis(smmu);\n\t\t\t+->  arm_smmu_write_msi_msg()\n\t\t+-> devm_request_irq(smmu->dev, irq, arm_smmu_gerror_handler, 0, \"arm-smmu-v3-gerror\", smmu);\n```\n\narm_smmu_write_msi_msg() 函数里会去：\n\n配置 MSI 中断的目的地址\n配置 MSI 的中断数据\n配置 MSI 中断的写地址的属性\n配置完成后，当中断产生时，最终会进入中断注册的处理函数， 以 gerror 的中断处理为例：\n\n\n```erlang\n arm_smmu_gerror_handler()\n\t \t\"读gerror和gerrorrn寄存器，确认gerror中断发生的错误类型\"\n \t+-> gerror = readl_relaxed(smmu->base + ARM_SMMU_GERROR);\n \t+-> gerrorn = readl_relaxed(smmu->base + ARM_SMMU_GERRORN);\n\t \t\"完成中断处理后，写gerror和gerrorn对应的的位一致，global中断处理完成\"\n \t+-> writel(gerror, smmu->base + ARM_SMMU_GERRORN);\n```\n\n对于 PCI 设备，ATS,  \nPRI 和 PASID 的概念同时存在于 PCIe 和 SMMU 规范中。对于 ATS 的介绍可以参考这里:  \nhttps://blog.csdn.net/scarecrow_byr/article/details/74276940\n。简单讲，ATS 特性由设备侧的 ATC 和 SMMU 侧的 ATS 同时支持，其目的是在设备中缓存 va 对应的 pa，设备随后使用 pa 做内存访问时无需经过 SMMU 页表转换，可以提高性能。\nPRI(page request interface) 也是需要设备和 SMMU 一起工作，PCIe 设备可以发出缺页请求，SMMU 硬件在解析到缺页请求后可以直接将缺页请求写入 PRI queueu, 软件在建立好页表后，可以通过CMD queue 发送 PRI response 给 PCIe 设备。具体的 ATS 和 PRI 的实现是硬件相关的，目前市面上还没有实现这两个硬件特性的 PCIe 设备，但是我们可以设想一下 ATS 和 PRI 的硬件实现，最好的实现应该是软件透明的，也就是软件配置给设备 DMA 的访问地址是 va. \n软件控制 DMA 发起后，硬件先发起 ATC 请求，从 SMMU 请求该 va 对应的 pa，如果 SMMU 里已经有 va 到 pa 的映射，那么设备可以得到 pa，然后设备再用 pa 发起一次内存访问，该访问将直接访问对应 pa 地址，不在 SMMU 做地址翻译;\n如果 SMMU 没有 va 到 pa 的映射, 那么设备得到这个消息后会继续向 SMMU 发 PRI 请求，设备得到从 SMMU 来的 PRI response 后发送内存访问请求，该请求就可以在 SMMU 中翻译得到 pa, 最终访问到物理内存。\n\nPRI 请求是基于 PCIe 协议的, 平台设备无法用 PRI 发起缺页请求。实际上，平台设备是无法靠自身发起缺页请求的，SMMU 用 stall 模式支持平台设备的缺页，当一个平台设备的内存访问请求到达 SMMU 后，如果 SMMU 里没有为 va 做到 pa 的映射，硬件会给 SMMU 的 event queue 里写一个信息，SMMU 的 event queue 中断处理里可以做缺页处理，然后 SMMU 可以回信息给设备 (fix me: 请求设备重发，还是 smmu 缺页处理后已经把该访问翻译后送到上游总线)。\n实际上, SMMU 使用 event queue 来处理各种错误异常，这里的 stall 模式是借用了 event queue 来处理缺页。\n\n## (6) iommu_device_register\n注册 iommu 设备, 主要设计一个操作，就是将 smmu 设备添加到 iommu_device_list 中\n\n\n```c\nint iommu_device_register(struct iommu_device *iommu)\n{\n\tspin_lock(&iommu_device_lock);\n\tlist_add_tail(&iommu->list, &iommu_device_list);\n\tspin_unlock(&iommu_device_lock);\n\treturn 0;\n}\n```\n\n着重讲下和 iommu_device 相关的两个重要数据结构 iommu_group 和 iommu_domain\n看下 iommu_device 结构体的定义\n\n\n```c\nstruct iommu_device {\n\tstruct list_head list;\n\tconst struct iommu_ops *ops;\n\tstruct fwnode_handle *fwnode;\n\tstruct device *dev;\n};\n```\n\niommu_device 中定义了 iommu_ops 以及 struct device,\n在 struct device 中，有 iommu_group 的成员，iommu_group 又包含了 iommu_domain。\niommu_device->device->iommu_group->iommu_domain\n\niommu_domain 的具体定义：\n\n\n```c\nstruct iommu_domain {\n\tunsigned type;\n\tconst struct iommu_ops *ops;\n\tunsigned long pgsize_bitmap;\t/* Bitmap of page sizes in use */\n\tiommu_fault_handler_t handler;\n\tvoid *handler_token;\n\tstruct iommu_domain_geometry geometry;\n\tvoid *iova_cookie;\n};\n```\n\n每一个 domain 代表一个具体的设备使用 iommu 的详细 spec\n在 arm_smmu_domain 结构体中，又将 arm_smmu_domain 和 iommu_domain 关联， 所以 iommu_ops 指向 SMMU 驱动。所以最终 ARM 是用 arm_smmu_domain 来管理驱动和设备之间的关联的。\n\niommu_group 的具体定义：[drivers/iommu/iommu.c: iommu_group]\n\n\n```c\nstruct iommu_group {\n\tstruct kobject kobj;\n\tstruct kobject *devices_kobj;\n\tstruct list_head devices;\n\tstruct mutex mutex;\n\tstruct blocking_notifier_head notifier;\n\tvoid *iommu_data;\n\tvoid (*iommu_data_release)(void *iommu_data);\n\tchar *name;\n\tint id;\n\tstruct iommu_domain *default_domain;\n\tstruct iommu_domain *domain;\n};\n```\n\n\n为什么会有一个 iommu_group 的概念，直接将 device 和 iommu_domain 关联不香吗？\n假设我们通过 iommu 提供设备的 DMA 能力，当发起 dma_map 的时候，设备设置了 streamid, 但是多个设备的 streamid 有可能是一样的。 那么这时候修改其中一个设备的页表体系，也就相当于修改了另一个设备的页表体系。所以，修改页表的最小单位不是设备，而是 streamid。\n因此，为了避免这种情况，增加了一个 iommu_group 的概念，iommu_group 代表共享同一个 streamid 的一组 device（表述在 / sys/kernel/iommu_group 中）。\n有了 iommu_group, 设备发起 dma_map 操作时，会定位 streamid 和 iommu_group, group 定位了 iommu_device 和 iommu_domain，iommu_domain 定位了 asid，这样，硬件要求的全部信息都齐了。\n(Linux iommu 和 vfio 概念空间解构)\n\n## (7) arm_smmu_set_bus_ops\n给 smmu 支持的总线设置 bus->iommu_ops， 让总线具有了 iommu attach 的能力。\n\n\n```c\n\tarm_smmu_set_bus_ops(&arm_smmu_ops)\n\t+-> bus_set_iommu(&pci_bus_type, ops);\n\t+-> bus_set_iommu(&amba_bustype, ops);\n\t+-> bus_set_iommu(&platform_bus_type, ops);\n```\n\narm_smmu_ops 结构体定义如下：\n\n\n```c\nstatic struct iommu_ops arm_smmu_ops = {\n\t.capable\t\t= arm_smmu_capable,\n\t.domain_alloc\t\t= arm_smmu_domain_alloc,\n\t.domain_free\t\t= arm_smmu_domain_free,\n\t.attach_dev\t\t= arm_smmu_attach_dev,            \n\t.map\t\t\t= arm_smmu_map,\n\t.unmap\t\t\t= arm_smmu_unmap,\n\t.flush_iotlb_all\t= arm_smmu_flush_iotlb_all,\n\t.iotlb_sync\t\t= arm_smmu_iotlb_sync,\n\t.iova_to_phys\t\t= arm_smmu_iova_to_phys,\n\t.add_device\t\t= arm_smmu_add_device,\n\t.remove_device\t\t= arm_smmu_remove_device,\n\t.device_group\t\t= arm_smmu_device_group,\n\t.domain_get_attr\t= arm_smmu_domain_get_attr,\n\t.domain_set_attr\t= arm_smmu_domain_set_attr,\n\t.of_xlate\t\t= arm_smmu_of_xlate,\n\t.get_resv_regions\t= arm_smmu_get_resv_regions,\n\t.put_resv_regions\t= generic_iommu_put_resv_regions,\n\t.pgsize_bitmap\t\t= -1UL, /* Restricted during device attach */\n};\n```\n\n主要分析 smmu 的两个关键操作：arm_smmu_attach_dev 和 arm_smmu_add_device\narm_smmu_add_device: 将 smmu 设备添加到总线\n\narm_smmu_add_device()\n\t\n\n```erlang\n\t+-> smmu = arm_smmu_get_by_fwnode(fwspec->iommu_fwnode);\n\t/* for each sid, 如果是2-level ste, 为l2 ste分配内存\n\t *在之前的init_l1_strtab， 已经初始化了L1_std, L1_STD定义了下一级查找的基地址，\n\t * 现在可以通过sid 找到具体的STE（l2ptr + sid[7:0] * 64）\n\t * 这个函数先为每一个sid分配L2_STE的内存， 分配完成后在为每一个SID进行cfg配置\n\t */\n\t+-> arm_smmu_init_l2_strtab()\n\t\t\"将device和group关联起来\"\n\t+-> iommu_device_link()\n```\n\n\n总线扫描发现了设备，总线的发现流程负责调用 iommu_ops(arm_smmu_ops) 给这个设备加上 iommu_group，然后让 iommu_group 指向对应的 iommu 控制器\n\narm_smmu_attach_dev, 尝试为设备寻找到驱动\n\n\n```erlang\narm_smmu_attach_dev()\n\t\t\" 从iommu_domain 中得到arm_smmu_domain\"\n\t+-> smmu_domain = to_smmu_domain(iommu_domain );\n\t\t\"一般情况下smmu_domain->smmu = NULL\"\n\t\t\"在arm_smmu_add_device中，我们已经为STE项分配了内存\"\n\t+-> arm_smmu_domain_finalise(domain, master);\n\t\t\t\"分配asid\"\n\t\t+-> asids = arm_smmu_bitmap_alloc()\n\t\t\t\"根据smmu stage是stage1还是stage2， 如果smmu domain是stage1\"\n\t\t+-> arm_smmu_domain_finalise_s1()\n\t\t\t\t\"分配CD table的空间\"\n\t\t\t+-> arm_smmu_alloc_cd_tables(smmu_domain);\n\t\t\t\t\"配置CD descriptor的cfg\"\n\t\t\t+-> cfg->cd.tcr\t= FIELD_PREP(CTXDESC_CD_0_XXX)...\n\t\t\t\"如果smmu domain是stage2, STE已经包含了页表的s2ttb基地址和vmid，结束\"\n\t\t+-> arm_smmu_domain_finalise_s2()\n\t\t+-> finalise_stage_fn(smmu_domain, master, &pgtbl_cfg);\n```\n\n\n支持了 2-leveli 的 CD 或 linear 格式的 CD， 方式和 SID 查找 ste 类似。\n\n![image-20240416110013071](attachments/image-20240416110013071.png)\n\n结合代码分析：\n\n\n```c\nstatic int arm_smmu_alloc_cd_tables(struct arm_smmu_domain *smmu_domain)\n{\n\tint ret;\n\tsize_t l1size;\n\tsize_t max_contexts;\n\tstruct arm_smmu_device *smmu = smmu_domain->smmu;\n\tstruct arm_smmu_s1_cfg *cfg = &smmu_domain->s1_cfg;\n\tstruct arm_smmu_ctx_desc_cfg *cdcfg = &cfg->cdcfg;\n\n\tmax_contexts = 1 << cfg->s1cdmax;                -------------- (a)      \n\t\n\tif (!(smmu->features & ARM_SMMU_FEAT_2_LVL_CDTAB) ||\n\t    max_contexts <= CTXDESC_L2_ENTRIES) {\n\t\tcfg->s1fmt = STRTAB_STE_0_S1FMT_LINEAR;                -------- (b)\n\t\tcdcfg->num_l1_ents = max_contexts;\t\t\t\t\t\t\n\t\n\t\tl1size = max_contexts * (CTXDESC_CD_DWORDS << 3);      ------- (c)\n\t} else {\n\t\tcfg->s1fmt = STRTAB_STE_0_S1FMT_64K_L2;               \n\t\tcdcfg->num_l1_ents = DIV_ROUND_UP(max_contexts,\n\t\t\t\t\t\t  CTXDESC_L2_ENTRIES);\n\t\n\t\tcdcfg->l1_desc = devm_kcalloc(smmu->dev, cdcfg->num_l1_ents,\n\t\t\t\t\t      sizeof(*cdcfg->l1_desc),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!cdcfg->l1_desc)\n\t\t\treturn -ENOMEM;\n\t\n\t\tl1size = cdcfg->num_l1_ents * (CTXDESC_L1_DESC_DWORDS << 3);\n\t}\n\t\n\tcdcfg->cdtab = dmam_alloc_coherent(smmu->dev, l1size, &cdcfg->cdtab_dma,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!cdcfg->cdtab) {\n\t\tdev_warn(smmu->dev, \"failed to allocate context descriptor\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_l1;\n\t}\n\t\n\treturn 0;\n\nerr_free_l1:\n\tif (cdcfg->l1_desc) {\n\t\tdevm_kfree(smmu->dev, cdcfg->l1_desc);\n\t\tcdcfg->l1_desc = NULL;\n\t}\n\treturn ret;\n}\n```\n\n在 CD 的建立过程中，主要涉及到以下几点：\nste.S1Contextptr 中定义了 CD 的基地址, CD 的大小为 64byte\na. 需要配置 ste.S1CDMax, cdmax 为 0 表示这个 ste 只有一个 CD, 不需要使用到 substreamid, 如果 cdmax 不为 0， 那么 CD 的数目是 2 ^ S1CDMax;\nb. 需要配置 ste.S1Fmt, 如果是 linear 结构的 CD，CD 的获取方法为 S1ContextPTR + 64 * ssid; 如果是 2-level 结构的 CD， L1CD 的索引为 ssid[s1cdmax - 1: 6], L2CD 的索引为 ssid[5:0]\n\nattach_dev 完成后，如果是 stage1 相关，CD 的结构, 大小和基地址已经成功建立，成功获取 STE 后，可以通过 substreamid 找到 CD（S1ContextPTR + 64 * ssid）。找到的 CD 中包含页表 PTW 需要的 TTBR 寄存器，所以每一个 CD 对应一个页表， 这样一个 SMMU 单元，就可以有多张页表。\n\n总结：\nsmmu 驱动的初始化流程就是一个探测硬件规格，初始化硬件配置，分配 STD/STE/CD 等空间的过程。\n\n![image-20240416110053027](attachments/image-20240416110053027.png)\n\n参考资料\nLinux iommu 和 vfio 概念空间解构\nIHI0070_System_Memory_Management_Unit_Arm_Architecture_Specification\n\n","tags":["arm","smmuv3"],"categories":["linux","驱动"]},{"title":"riscv 硬件虚拟化概况","url":"/2023/03/11/hxd_new/riscv调研/虚拟化/硬件虚拟化/","content":"\n# riscv qemu-kvm 框架\n\n![image-20240416112007309](attachments/image-20240416112007309.png)\n\n# arm vs riscv 硬件虚拟化\n\n![image-20240416112011154](attachments/image-20240416112011154.png)\n\n## riscv-aia\n\nriscv 体系下, 中断直通需要 支持 aia 架构的 riscv-imsic \n\nhttps://github.com/riscv/riscv-aia/\n\nriscv-imsic stable\n![image-20240416112014887](attachments/image-20240416112014887.png)\n\nriscv-imsic release\n![image-20240416112018975](attachments/image-20240416112018975.png)\n\n## riscv-iommu\n\n设备直通需要 iommu 组件, riscv 体系下, iommu 属于 non-isa 部分.\n\n> Non-ISA specifications do not add new instructions, create or change opcodes, or in any way modify the RISC-V ISA. They do help us to develop an ecosystem around the ISA Specifications.\n\nhttps://github.com/riscv-non-isa/riscv-iommu/\n\n![image-20240416112022820](attachments/image-20240416112022820.png)\n\n","tags":["riscv"],"categories":["虚拟化","RISCV"]},{"title":"硬件虚拟化及设备直通框架","url":"/2023/03/11/hxd_new/riscv调研/虚拟化/硬件虚拟化及设备直通框架/","content":"\n# riscv qemu-kvm 框架\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230303134427.png)\n\n# arm vs riscv 硬件虚拟化\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230303134428.png)\n\n## riscv-aia\n\nriscv 体系下, 中断直通需要 支持 aia 架构的 riscv-imsic \n\nhttps://github.com/riscv/riscv-aia/\n\nriscv-imsic stable\n![image-20240416112108734](attachments/image-20240416112108734.png)\n\nriscv-imsic release\n![image-20240416112103799](attachments/image-20240416112103799.png)\n\n## riscv-iommu\n\n设备直通需要 iommu 组件, riscv 体系下, iommu 属于 non-isa 部分.\n\n> Non-ISA specifications do not add new instructions, create or change opcodes, or in any way modify the RISC-V ISA. They do help us to develop an ecosystem around the ISA Specifications.\n\nhttps://github.com/riscv-non-isa/riscv-iommu/\n\n![image-20240416112059789](attachments/image-20240416112059789.png)\n\n# 设备直通\n\n![image-20240416112056260](attachments/image-20240416112056260.png)\n\n## 软硬件架构支撑\n\n- pcie 支持\n- 中断直通\n- iommu\n\nqemu-kvm 架构中的设备直通都是针对的PCIE设备\nqemu 框架中使用vfio 模式支撑 PCIE 设备直通体系.\n\n设备直通包含两方面:\n- 中断直通\n- DMA 重映射\n\n### arm 下的PCIE 设备直通\n\n正常的pcie 设备 kvm 注入中断的过程:\n1. QEMU通过对设备ioctl（VFIO_DEVICE_SET_IRQS）将VFIO设备中断与eventfd关联，并对VFIO设备申请中断并填充中断处理函数vfio_msihandler()；\n2. QEMU中将guest要求的中断virq与eventfd关联，即当eventfd收到事件时，会往guest OS注入中断，这是通过QEMU对调用ioctl(KVM_IRQFD)实现的；\n3. Guest OS对可以产生MSI/MSIX中断的内存映射区（设备配置空间或设备BAR空间）发起写操作时，会产生VM Exit到QEMU，QEMU将写的数据填写到设备的BAR空间中MSIX对应的Table中，从而触发ITS产生中断；\n4. 当VFIO设备收到中断时，首先触发vfio-pci设备的中断处理函数vfio_msihandler()，它会调用eventfd_signal()向与virq关联的eventfd发送事件，eventfd收到事件后往guest OS注入中断；\n\n而在GICv4 lpi升级到vlpi 后, 上述步骤变为:\n1. QEMU通过对设备ioctl（VFIO_DEVICE_SET_IRQS）将VFIO设备中断与eventfd关联\n2. Guest OS对可以产生MSI/MSIX中断的内存映射区（设备配置空间或设备BAR空间）发起写操作时, 或pcie 外设写MSI/MSIX 中断内存映射区后, guest os 正在运行, 由guest os 自己处理中断; 如guest os不在运行, 则中断由gicv4的doorbell机制, 由doorbell的中断处理函数注入中断给vcpu. 切换vcpu的guest os运行处理中断.\n\n\n### 中断直通硬件支撑\n\n#### riscv-imsic\n\nimsic 中新增了 guest interrupt file 的逻辑, 每一个guest interrupt file 绑定一个物理cpu上的某个 vcpu\n\n软件在申请中断时, 需要写msi 地址, 表明要申请哪个硬件中断号, 绑定的是哪个cpu 或 vcpu (选择的是 M-level interrupt file 还是S-level interrupt file 还是哪个 guest interrupt file )\n\n外设硬件写msi地址后, imsci 中断控制器做出相应, 发出中断相应到 cpu csr, 根据申请中断时绑定的 interrupt file 来决定操作哪个csr:\n- 绑定了 M-level的interrupt file, 则写 mip 的 SEIP 置位\n- 绑定了 S-level 的interrupt file, 则将 sip 的 SEIP 置位\n- 绑定了 guest interrupt file[X], 则将 hgeip的对应 X bit 置位.\n\n软件在收到中断后, 由中断管理程序查询 [m/s/vs]topi 寄存器(IMSIC 添加) , 查询最高优先级的硬件中断号, 转到对应的中断handler 进行处理.\n\n#### mips gic 虚拟化\n\nA generic External Interrupt Controller (EIC) typically has a number of input Interrupt Ports that are statically tied to devices in the system. It also has one logical output port to each core in the system, where the port has independent channels for root and guest interrupts. Input port interrupts are routed to the output ports. Logic within the EIC is implementation-dependent, although each slice of logic for the interface to the core can also have a root and guest section to configure interrupts separately for root and guest for the core. The following sections describe the interface virtualization.\n\n一个通用的外部中断控制器（EIC）通常有一些输入的中断端口，这些端口与系统中的设备静态地联系在一起。它也有一个逻辑输出端口到系统中的每个核心，其中端口有独立的通道用于root 和guest interrupts。输入端口中断被路由到输出端口。EIC内的逻辑是依赖于实现的，尽管每个用于内核接口的逻辑片也可以有一个根和客户部分来分别配置内核的root和guest 的中断\n\nIf an EIC interrupt port is tied to either a root or guest-owned device (and not just root), the port should be modified such that it can be programmed with GuestID. In a multi-core system, each port also identifies a core destination. An interrupt can then be routed to a specific core through a specific interrupt channel (root or guest) for the core.\n\nThe logical output port to a core is split into the Root Interrupt Bus and Guess Interrupt Bus. These two independent channels route root and guest interrupts to the core. The following steps are required to deliver up to two interrupts (one for root, one for guest) in a cycle. The description assumes that interrupts are prioritized and represented by an Interrupt Priority Level.\n1. Prioritize all incoming root (GuestID=0) interrupts every cycle based on assigned Interrupt Priority Level (IPL).\n• Deliver highest priority interrupt for the cycle on Root Interrupt Bus.\n2. Prioritize all incoming guest (GuestID!=0) interrupts every cycle based on assigned Interrupt Priority Level (IPL).\n• If prioritized GuestID != resident GuestID, deliver interrupt on Root Interrupt Bus. Otherwise, deliver on Guest Interrupt Bus.\nThe resident GuestID is established from an input to the EIC from each core.\nThe External Interrupt Controller may reassign an interrupt from the Root Interrupt Bus to the Guest Interrupt Bus if the guest interrupt on the Root Interrupt Bus can be delivered to the core guest context as a result of a context switch, that is, the guest is now resident. Such handling is optional because root software can accomplish the same task by reprogramming the interrupt controller before switching guest context. The EIC can reassign active interrupts in this way as long as the core has not registered interrupt. This may be established by checking the Interrupt Priority Level that accompanies the interrupt acknowledgment.\n\n\n#### 中断直通场景分析\n\n背景:\n不同的vcpu可以运行不同guest os.\n一个物理cpu 有三套寄存器 \n- v 开头的 vsip vsie 等\n- h 开头的 hvip hip hie hgeie hgeip 等\n- s 开头的 sip sie 等\n\n当V=0 => V=1 时, v开头的寄存器会替换成 s 开头的寄存器, 此时变成vcpu的执行环境\nV=1 时, 只能访问 s 开头的寄存器.\n\n在设备直通场景时, 0 < hstatus.VGEIN <= GEILEN(物理cpu上托管的vcpu的数量), \n\n需要HS vmm 对 hgeie hstatus操作, 对应物理cpu上托管的vcpu\n如当前物理cpu上托管了8个vcpu, 正在运行的是第2个vcpu\n- 对 hstatus.VGEIN 设置为2\n- 对 hgeie 的前8个bit 置1, 表示物理cpu 管了8个ready vcpu 的中断状态, 这8个vcpu都要处理guest external interrupt.\n\n在前面前提下, 硬件需要将hip.VSEIP 与 hgeip的状态区分.\n前面hip.VSEIP 的来源:  \"**bit of `hgeip` selected by `hstatus`.VGEIN**\"\n\n在设备直通场景(设置了hstatus.VGEIN时), 中断控制器需要判断给哪个vcpu, 导致的直接结果就是要设置hgeip 的哪个bit, 同时硬件应该将 hip.VSEIP 置为hgeip 与 hstatus.VGEIN 逻辑与 的结果. 而hip.SGEIP 置为 hgeip & hgeie 逻辑与的结果.\n\n假如中断控制器要发给第 `3` 个vcpu, 就需要将hgeip 的第 `3` 个bit 置1\n\n- 情景1 : 假设物理cpu的状态 V=1 mode 正在运行第二个vcpu, hstatus.VGEIN = 2:\n\t此时因为正在运行的是第二个vcpu, hstatus.VGEIN=2, 则hip.VSEIP = 0, 而 hip.SGEIP 为 1, 因为vsip.SEIP->sip.SEIP = hip.VSEIP, 此时vsip.SEIP 没有置位(此时假设只有外部中断, SSIP STIP 都是0), 此时硬件根据vsip penging为无信号, 而hip.SGEIP 有信号, 不能将中断委托给vcpu, 而应将中断给到 host os HS-mode的vmm.\n\t\n\t从vcpu陷入到hypervisor vmm 后, vmm 需要check hip.SGEIP & hie SGEIE(或hip&hie), 有待处理的虚拟外部中断, 进而查hgeip, 查到是第 `3` 个vcpu的, 则切换到第 `3` 个vcpu 运行, 切换前将hstatus.VGEIN 设置为3. 此时vsip.SEIP = hip.VSEIP 会被置1(hgeip 逻辑与 hstatus.VGEIN) , 第 3 个vcpu 陷入V=1 mode, 处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\n- 情景2: 假设物理cpu的状态 V=0 mode, 处于host下\n\t中断由host os接收\n\thypervisor vmm 需要check hip.SGEIP & hie SGEIE (或hip&hie), 有待处理的虚拟外部中断, 进而查hgeip, 查到是第三个vcpu的, 则切换到第三个vcpu 运行, 切换前将hstatus.VGEIN 设置为3. 此时vsip.SEIP = hip.VSEIP 会被置1(hgeip 逻辑与 hstatus.VGEIN) , 第三个vcpu 陷入V=1 mode, 处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\n- 情景3: 假设物理cpu的状态 V=1 mode 正在运行第三个vcpu, hstatus.VGEIN = 3:\n    hgeip 逻辑与 hstatus.VGEIN 不为0, hip.VSEIP 置1.\n\t因为vsip.SEIP->sip.SEIP = hip.VSEIP, 此时vsip.SEIP 置位, 此时硬件根据vsip penging有信号, hip.SGEIP 有信号, 应将中断给到 vcpu guest os.\n\tvcpu处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\n\nPCIE 设备在 riscv-iommu 支持下可以直接写 msi 地址, 发送对应的中断给对应的vcpu, riscv-iommu的该硬件设计简化了hypervisor和中断子系统的软件程序.\n\n![image-20240416112051360](attachments/image-20240416112051360.png)\n\n## arm gicv4 下的PCIE 设备直通过程\n\n中断直通场景下的问题比较多, 比较重要的有下面几个:\n1. PCIE 设备是怎样开关中断?\n2. PCIE 设备是怎样发送中断的? 中断是怎么由os处理的?\n3. guest os 下的pcie设备是虚拟的外设, 虚拟的pcie设备怎么和真实的pcie设备建立关联的, 启用中断的操作怎么反映的PCIE的真实物理地址上的?\n4. guest os 下申请中断, guest os只有虚拟中断控制器, 它是怎样和真实的中断控制器建立连接的, 怎样设置的虚拟中断路由, 中断控制器怎么绑定的vcpu 和 对应的硬件中断号?\n\n\n对于PCIE设备，一般支持MSI中断和MSIX中断，MSI和MSIX中断都是通过对某个映射内存区域写数据（写的地址为Message Addr，写的数据为Message Data），从而触发基于信息的中断。\n产生MSI中断的内存映射区在PCIE设备的配置空间，而产生MSIX中断的内存映射区在PCIE设备的BAR空间\nMSI中断最多支持32个，且要求申请的中断连续\n而MSIX中断可支持的比较多（2048），不要求申请的中断连续；\n\n这里仅对 MSI 类型进行分析\n\n1. PCIE 外设开启中断\n在 host os下的流程\n1) 写 PCIE 的 MSI对应的配置空间, 最终反映到了外设的寄存器上, 对相应的enable 位置1, 中间过程是比较复杂的, 这里暂时略过, 属于pcie driver 的范围. \n设置linux virq 和 相应外设硬件中断号的映射关系.\n2) kernel 申请virq 同硬件中断号建立映射, 最终建立硬件中断号同 irq handler 的映射关系\n\n2. PCIE 外设发送中断及中断处理流程\nkernel 查询中断控制器或查cpu的csr 判断哪个硬件中断号pending了, 然后根据硬件中断号找到对应的linux virq, 最终找到中断handler 进行处理\n\nguestos 下直通的PCIE 开启中断流程\n\n1. PCIE 外设开启中断\n这里就比较复杂了\n>首先需要说明, guest 下的中断控制器 pcie 外设等 外部控制器相关的都是qemu 模拟的\n在直通场景下, guest os下看到的外设 外部控制器这些也全是模拟的, 并不能直接访问到真实外设/控制器的物理地址\n\n这里就涉及到两部分\n- 对中断控制器的模拟, 在直通时怎么将虚拟中断控制器的输入反馈给 真实的中断控制器\n- 对PCIE 设备的模拟, 在直通时怎么将虚拟外设的操作反馈给真实的外设\n\n另外还有一部分是软件的流程, guest kernel下相关的 deviceid - 硬件中断号-vcpu的关系怎么路由给 host os的vmm? 为什么这么做, 大概有两点:\n- vcpu 退出了, 运行在host os下, 需要host的 cpu 接管vcpu的中断(类似的doorbell机制), 进而需要对对应的vcpu 注入中断, 再调度到vcpu\n- 无论是否直通, 外设的中断信号都是发送给真实的中断控制器的, 而guest os下都是虚拟的中断控制器, 最终建立 deviceid - 硬件中断号 -vcpu 的路由都是在host os下的vmm中完成的\n\n2. PCIE 设备是怎样发送中断的, 中断是怎样处理的?\n\nPCIE 设备硬件发送中断信号给中断控制器, 中断控制器中通过中断路由表查表找到deviceid 对应的硬件中断号 cpu/vcpuid, 最后给托管vcpu的对应的物理cpu 设置pending 信号及 硬件中断号相关的寄存器等设置对应的位.\n- 物理cpu运行在host os时, 由doorbell机制处理, 对vcpu注入中断, 调度到vcpu, vcpu下的guest os 查询虚拟中断控制器或特有的vcpu相关的寄存器查询硬件中断号, 找到对应的linux virq, 最终找到irq handler 进行处理\n- 物理cpu处在运行该vcpuid的上下文时, vcpu下的guest os 查询虚拟中断控制器或特有的vcpu相关的寄存器查询硬件中断号, 找到对应的linux virq, 最终找到irq handler 进行处理\n- 物理cpu 处在另一个vcpuid的上下文时, 此时由于cpu的doorbell机制, vcpu不能收到中断, 而是由host os收到中断, 此时会因中断陷入到host os的vmm, 然后cpu 查询中断信息, 判断是哪个vcpu的中断, 然后给对应的vcpu 注入中断, 最后由该vcpu guest os 查询虚拟中断控制器或特有的vcpu相关的寄存器查询硬件中断号, 找到对应的linux virq, 最终找到irq handler 进行处理\n\n\n参考arm的架构\n添加的内容:\n\n1. kernel中kvm module下 gic 控制器ops 相关的埋桩\n2. 中断控制器的driver 对应的kvm相关的ops 实现\n3. qemu 中 虚拟中断控制器的注册流程, 最终下发给kvm, 让kvm 建立对应的映射关系.\n4. guest 虚拟中断控制器的mmio 模拟, 这部分在kvm的管理的内存下, 需要中断控制器 driver 实现 mmio的注册, 因guest page fault 陷入虚拟中断控制器对应的mmio后的读写流程, 解析guest os 下的deviceid-硬件中断号-vcpu的映射关系, 在真实的中断控制器下建立对应的vcpu的中断路由. 建立cpu-vcpu的doorbell 路由及中断注入的流程.\n\nPCIE的部分:\n1. qemu中添加 PCIE 配置空间 BAR 空间等的mmio的模拟\n2. qemu vfio 框架中需要的所有PCIE相关的driver pcie相关的机制都要准备好.\n3. iommu 部分, 需要建立 PCIE空间(设备相关的地址空间)的 dma remap 等, 需要 iommu driver 完成.\n4. 中断部分, 需要qemu-kvm 联合将msi/msix 空间的mmio的读写进行解析, 最终转化为 对真实的中断控制器的操作, 建立真实的中断路由\n当虚拟机因为写PCI配置空间而发生VM-exit时，最终会完成msi和msix的使能，在qemu侧会设置eventfd的处理函数，并通过kvm将irqfd注册到内核中，进而注册虚拟中断给虚拟机。\n\n![image-20240416112118303](attachments/image-20240416112118303.png)\n\n# 直通框架依赖的kvm的feature\n\nriscv kvm上未实现的feature\n- ioeventfd\n\n存在这样一种情况，即I/O请求本身只是作为一个通知事件，这个事件本身可能是通知KVM或者QEMU完成另一个具体的I/O，这种情况下没有必要像普通I/O一样等待数据完全写完，而是只需要完成一个简单的通知。\n如果这种I/O请求也使用之前同步的方式完成，很明显会增加不必要的路径。\nioeventfd就是对这种通知I/O进行的优化，用户层程序（如QEMU）可以为虚拟机特定的地址关联一个eventfd，并对该eventfd进行事件监听，然后调用ioctl(`KVM_IOEVENTFD`)向KVM注册这段地址, 当虚拟机内部因为I/O发生VM Exit时，KVM可以判断其地址是否有对应的eventfd，如果有就直接调用eventfd_signal发送信号到对应的fd，这样，QEMU就能够从其事件监听循环返回，进而进行处理\n\n这里与一般的mmio 的处理流程有差别的地方就是对guest 来说, 这是一个异步调用, guest 在读写某数据时, 并不会等这个数据读写完, 而是直接再次进入到guest中了. 该vcpu 只会陷入到 kvm下一次, 然后通知用户态进程, 该用户态进程并不是和这个vcpu处在同一个cpu上, 该vcpu只陷入到HS-mode的kvm一次, 就继续回到guest os中了. \n\n- irqfd\nioeventfd是虚拟机内部操作系统通知KVM/QEMU的一种快捷通道, 与之类似，irqfd是KVM/QEMU通知虚拟机内部操作系统的快捷通道。irqfd将一个`eventfd`与一个全局的中断号联系起来，当向这个eventfd发送信号时，就会导致对应的中断注入到虚拟机中\n\n\n\n\n\n\n\n","tags":["riscv","设备直通"],"categories":["虚拟化","RISCV"]},{"title":"riscv kvm 提交整理","url":"/2023/03/11/hxd_new/riscv调研/虚拟化/kvm 提交整理/","content":"\n# 1.     RISC-V: Add initial skeletal KVM support\n\n    This patch adds initial skeletal KVM RISC-V support which has:\n    1. A simple implementation of arch specific VM functions\n       except kvm_vm_ioctl_get_dirty_log() which will implemeted\n       in-future as part of stage2 page loging.\n    2. Stubs of required arch specific VCPU functions except\n       kvm_arch_vcpu_ioctl_run() which is semi-complete and\n       extended by subsequent patches.\n    3. Stubs for required arch specific stage2 MMU functions.\n\n这个补丁增加了初始的KVM RISC-V 框架\n它具有。\n1. 除了kvm_vm_ioctl_get_dirty_log()之外，一个简单的arch特定虚拟机函数的实现，它将作为第二阶段页面记录的一部分在未来实施。\n2. 除了kvm_arch_vcpu_ioctl_run()是半完全的并由后续补丁扩展外，所需的特定arch VCPU函数的stub。\n3. 所需的arch 特定第二阶段MMU功能的 stub 。\n\n# 2.     RISC-V: KVM: Implement VCPU create, init and destroy functions\n\n    This patch implements VCPU create, init and destroy functions\n    required by generic KVM module. We don't have much dynamic\n    resources in struct kvm_vcpu_arch so these functions are quite\n    simple for KVM RISC-V.\n\n这个补丁实现了通用KVM模块所需的VCPU创建、启动和销毁功能。我们在结构kvm_vcpu_arch中没有很多动态资源，所以这些函数对于KVM RISC-V来说非常简单。\n\n# 3.         RISC-V: KVM: Implement VCPU interrupts and requests handling\n\n    This patch implements VCPU interrupts and requests which are both\n    asynchronous events.\n    \n    The VCPU interrupts can be set/unset using KVM_INTERRUPT ioctl from\n    user-space. In future, the in-kernel IRQCHIP emulation will use\n    kvm_riscv_vcpu_set_interrupt() and kvm_riscv_vcpu_unset_interrupt()\n    functions to set/unset VCPU interrupts.\n    \n    Important VCPU requests implemented by this patch are:\n    KVM_REQ_SLEEP       - set whenever VCPU itself goes to sleep state\n    KVM_REQ_VCPU_RESET  - set whenever VCPU reset is requested\n    \n    The WFI trap-n-emulate (added later) will use KVM_REQ_SLEEP request\n    and kvm_riscv_vcpu_has_interrupt() function.\n    \n    The KVM_REQ_VCPU_RESET request will be used by SBI emulation (added\n    later) to power-up a VCPU in power-off state. The user-space can use\n    the GET_MPSTATE/SET_MPSTATE ioctls to get/set power state of a VCPU.\n\n这个补丁实现了VCPU中断和请求，它们都是异步事件。\nVCPU中断可以使用用户空间的KVM_INTERRUPT ioctl进行设置/取消。\n在未来，内核IRQCHIP仿真将使用kvm_riscv_vcpu_set_interrupt()和kvm_riscv_vcpu_unset_interrupt()函数来设置/取消VCPU中断。\n这个补丁实现的重要VCPU请求是。\nKVM_REQ_SLEEP -每当VCPU本身进入睡眠状态时设置\nKVM_REQ_VCPU_RESET -每当VCPU复位时设置\nWFI trap-n-emulate（稍后添加）将使用KVM_REQ_SLEEP请求和kvm_riscv_vcpu_has_interrupt()函数。\nKVM_REQ_VCPU_RESET请求将被SBI仿真使用（稍后添加），以使VCPU处于断电状态。\n用户空间可以使用GET_MPSTATE/SET_MPSTATE ioctls来获取/设置VCPU的电源状态。\n\n\n\n# 4.     RISC-V: KVM: Implement KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls\n\n    For KVM RISC-V, we use KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls to access\n    VCPU config and registers from user-space.\n    \n    We have three types of VCPU registers:\n    1. CONFIG - these are VCPU config and capabilities\n    2. CORE   - these are VCPU general purpose registers\n    3. CSR    - these are VCPU control and status registers\n    \n    The CONFIG register available to user-space is ISA. The ISA register is\n    a read and write register where user-space can only write the desired\n    VCPU ISA capabilities before running the VCPU.\n    \n    The CORE registers available to user-space are PC, RA, SP, GP, TP, A0-A7,\n    T0-T6, S0-S11 and MODE. Most of these are RISC-V general registers except\n    PC and MODE. The PC register represents program counter whereas the MODE\n    register represent VCPU privilege mode (i.e. S/U-mode).\n    \n    The CSRs available to user-space are SSTATUS, SIE, STVEC, SSCRATCH, SEPC,\n    SCAUSE, STVAL, SIP, and SATP. All of these are read/write registers.\n    \n    In future, more VCPU register types will be added (such as FP) for the\n    KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls.\n\n对于KVM RISC-V，我们使用KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls来访问VCPU配置和用户空间的寄存器。\n我们有三种类型的VCPU寄存器。\n1. CONFIG - 这些是VCPU配置和能力\n2. CORE - 这些是VCPU通用寄存器\n3. CSR--这些是VCPU控制和状态寄存器 \n用户空间可用的CONFIG寄存器是ISA。ISA寄存器是一个读写寄存器，用户空间在运行VCPU之前只能写入所需的VCPU ISA功能。用户空间可用的CORE寄存器是PC、RA、SP、GP、TP、A0-A7、T0-T6、S0-S11和MODE。其中大部分是RISC-V通用寄存器，除了PC和MODE。PC寄存器代表程序计数器，而MODE寄存器代表VCPU的特权模式（即S/U模式）。\n用户空间可用的CSR有SSTATUS、SIE、STVEC、SSCRATCH、SEPC、SCAUSE、STVAL、SIP和SATP。\n所有这些都是读/写寄存器。\n\n在未来，更多的VCPU寄存器类型将被添加到KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls中（如FP）。\n\n\n\n# 5.     RISC-V: KVM: Implement VCPU world-switch\n\n    This patch implements the VCPU world-switch for KVM RISC-V.\n    \n    The KVM RISC-V world-switch (i.e. __kvm_riscv_switch_to()) mostly\n    switches general purpose registers, SSTATUS, STVEC, SSCRATCH and\n    HSTATUS CSRs. Other CSRs are switched via vcpu_load() and vcpu_put()\n    interface in kvm_arch_vcpu_load() and kvm_arch_vcpu_put() functions\n    respectively.\n\n这个补丁实现了KVM RISC-V的VCPU world 切换。KVM RISC-V世界切换（即__kvm_riscv_switch_to()）大多切换通用寄存器、SSTATUS、STVEC、SSCRATCH和HSTATUS CSR。其他CSR分别通过kvm_arch_vcpu_load()和kvm_arch_vcpu_put()函数中的vcpu_load()和vcpu_put()接口进行切换。\n\n# 6.     RISC-V: KVM: Handle MMIO exits for VCPU\n\n    We will get stage2 page faults whenever Guest/VM access SW emulated\n    MMIO device or unmapped Guest RAM.\n    \n    This patch implements MMIO read/write emulation by extracting MMIO\n    details from the trapped load/store instruction and forwarding the\n    MMIO read/write to user-space. The actual MMIO emulation will happen\n    in user-space and KVM kernel module will only take care of register\n    updates before resuming the trapped VCPU.\n    \n    The handling for stage2 page faults for unmapped Guest RAM will be\n    implemeted by a separate patch later.\n\n每当Guest/VM访问SW模拟的MMIO设备或未映射的Guest RAM时，我们将得到阶段2的page fault。这个补丁通过从被困的加载/存储指令中提取MMIO 指令细节并将MMIO读/写转发到用户空间来实现MMIO读/写仿真。实际的MMIO仿真将发生在用户空间，KVM内核模块将只负责在恢复被困的VCPU之前进行寄存器更新。对未映射的Guest RAM的第2阶段page fault的处理将由一个单独的补丁来实现。\n\n\n# 7.     RISC-V: KVM: Handle WFI exits for VCPU\n\n    We get illegal instruction trap whenever Guest/VM executes WFI\n    instruction.\n    \n    This patch handles WFI trap by blocking the trapped VCPU using\n    kvm_vcpu_block() API. The blocked VCPU will be automatically\n    resumed whenever a VCPU interrupt is injected from user-space\n    or from in-kernel IRQCHIP emulation.\n\n每当Guest/VM执行WFI指令时，我们会得到非法指令陷阱。这个补丁通过使用kvm_vcpu_block()API阻塞VCPU来处理WFI陷阱。每当从用户空间或内核IRQCHIP仿真中注入VCPU中断时，被阻塞的VCPU将被自动恢复。\n\n# 8.     RISC-V: KVM: Implement VMID allocator\n\n    We implement a simple VMID allocator for Guests/VMs which:\n    1. Detects number of VMID bits at boot-time\n    2. Uses atomic number to track VMID version and increments\n       VMID version whenever we run-out of VMIDs\n    3. Flushes Guest TLBs on all host CPUs whenever we run-out\n       of VMIDs\n    4. Force updates HW Stage2 VMID for each Guest VCPU whenever\n       VMID changes using VCPU request KVM_REQ_UPDATE_HGATP\n\n我们为guest/虚拟机实现了一个简单的VMID分配器\n1. 在启动时检测VMID位的数量。\n2. 使用原子序数来跟踪VMID版本，并在我们用完VMID时增加VMID版本 \n3. 每当我们用完VMID时，就会在所有host CPU上刷新Guest TLB \n4. 每当VMID发生变化时，使用VCPU请求KVM_REQ_UPDATE_HGATP为每个guest VCPU强制更新HW Stage2 VMID\n\n# 9.     RISC-V: KVM: Implement stage2 page table programming\n\n    This patch implements all required functions for programming\n    the stage2 page table for each Guest/VM.\n    \n    At high-level, the flow of stage2 related functions is similar\n    from KVM ARM/ARM64 implementation but the stage2 page table\n    format is quite different for KVM RISC-V.\n\n这个补丁实现了为每个guest/虚拟机的stage2页表编程的所有必要功能。在高层次上，阶段2相关函数的流程与KVM ARM/ARM64实现相似，但阶段2页表格式与KVM RISC-V有很大不同。\n\n提供直接编程 stage-2 页表的接口\nkvm_riscv_gstage_alloc_pgd/kvm_riscv_gstage_free_pgd\ngstage_get_leaf_entry\ngstage_pte_page_vaddr 等\n\narch/riscv/kvm/mmu.c\n\n\n# 10.     RISC-V: KVM: Implement MMU notifiers ???\n\n    This patch implements MMU notifiers for KVM RISC-V so that Guest\n    physical address space is in-sync with Host physical address space.\n    \n    This will allow swapping, page migration, etc to work transparently\n    with KVM RISC-V.\n\n这个补丁为KVM RISC-V实现了MMU通知器，以便Guest物理地址空间与Host物理地址空间同步。这将允许交换、页面迁移等与KVM RISC-V透明地工作。\n\n> 当KVM_CAP_SYNC_MMU功能可用时，备份内存区域的变化会自动反映到guest中。例如，一个影响该区域的mmap()将被立即变成可见。另一个例子是madvise(MADV_DROP)。\n\n\n# 11. RISC-V: KVM: Add timer functionality\n\n    The RISC-V hypervisor specification doesn't have any virtual timer\n    feature.\n    \n    Due to this, the guest VCPU timer will be programmed via SBI calls.\n    The host will use a separate hrtimer event for each guest VCPU to\n    provide timer functionality. We inject a virtual timer interrupt to\n    the guest VCPU whenever the guest VCPU hrtimer event expires.\n    \n    This patch adds guest VCPU timer implementation along with ONE_REG\n    interface to access VCPU timer state from user space.\n\nRISC-V hypervisor 规范没有任何虚拟定时器功能。由于这个原因，guest VCPU定时器将通过SBI调用进行编程。host os将为每个客户VCPU使用一个单独的hrtimer事件来提供定时器功能。每当客体VCPU的hrtimer事件过期时，我们就向客体VCPU注入一个虚拟定时器中断。这个补丁增加了客户VCPU定时器的实现以及ONE_REG接口，以便从用户空间访问VCPU定时器的状态。\n\n# 12.     RISC-V: KVM: FP lazy save/restore\n\n    This patch adds floating point (F and D extension) context save/restore\n    for guest VCPUs. The FP context is saved and restored lazily only when\n    kernel enter/exits the in-kernel run loop and not during the KVM world\n    switch. This way FP save/restore has minimal impact on KVM performance.\n\n这个补丁为客户VCPU增加了浮点（F和D扩展）上下文保存/恢复。只有在内核进入/退出 run-loop 时，才会延迟的保存和恢复FP上下文，而不是在KVM世界切换时。这样，FP保存/恢复对KVM性能的影响就很小。\n\n# 13.     RISC-V: KVM: Implement ONE REG interface for FP registers\n\n    Add a KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctl interface for floating\n    point registers such as F0-F31 and FCSR. This support is added for\n    both 'F' and 'D' extensions.\n\n为F0-F31和FCSR等浮点寄存器添加一个KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctl接口。这个支持是为F和D的扩展添加的。\n\n# 14.     RISC-V: KVM: Add SBI v0.1 support\n\n    The KVM host kernel is running in HS-mode needs so we need to handle\n    the SBI calls coming from guest kernel running in VS-mode.\n    \n    This patch adds SBI v0.1 support in KVM RISC-V. Almost all SBI v0.1\n    calls are implemented in KVM kernel module except GETCHAR and PUTCHART\n    calls which are forwarded to user space because these calls cannot be\n    implemented in kernel space. In future, when we implement SBI v0.2 for\n    Guest, we will forward SBI v0.2 experimental and vendor extension calls\n    to user space.\n\nKVM host os 以HS模式运行，所以我们需要处理来自VS模式下运行的 guest os的SBI调用。这个补丁在KVM RISC-V中增加了SBI v0.1支持。除了GETCHAR和PUTCHART调用被转发到用户空间，几乎所有SBI v0.1调用都在KVM内核模块中实现，因为这些调用不能在内核空间中实现。在未来，当我们为Guest实现SBI v0.2时，我们将把SBI v0.2的实验和vendor 扩展调用转发给用户空间。\n\n# 16.     RISC-V: KVM: Fix GPA passed to __kvm_riscv_hfence_gvma_xyz() functions\n\n    The parameter passed to HFENCE.GVMA instruction in rs1 register\n    is guest physical address right shifted by 2 (i.e. divided by 4).\n    \n    Unfortunately, we overlooked the semantics of rs1 registers for\n    HFENCE.GVMA instruction and never right shifted guest physical\n    address by 2. This issue did not manifest for hypervisors till\n    now because:\n      1) Currently, only __kvm_riscv_hfence_gvma_all() and SBI\n         HFENCE calls are used to invalidate TLB.\n      2) All H-extension implementations (such as QEMU, Spike,\n         Rocket Core FPGA, etc) that we tried till now were\n         conservatively flushing everything upon any HFENCE.GVMA\n         instruction.\n    \n    This patch fixes GPA passed to __kvm_riscv_hfence_gvma_vmid_gpa()\n    and __kvm_riscv_hfence_gvma_gpa() functions.\n\nrs1寄存器中传递给HFENCE.GVMA指令的参数是GPA右移2（即除以4）。不幸的是，我们忽略了HFENCE.GVMA指令的rs1寄存器的语义，也没有将客户的物理地址右移2。这个问题直到现在还没有在管理程序中表现出来，\n因为:\n1）目前，只有__kvm_riscv_hfence_gvma_all()和SBI HFENCE调用被用来使TLB失效。\n2）到目前为止，我们尝试的所有H扩展实现（如QEMU、Spike、Rocket Core FPGA等）都是保守地在任何HFENCE.GVMA指令上刷新一切。\n这个补丁修复了传递给__kvm_riscv_hfence_gvma_vmid_gpa()和__kvm_riscv_hfence_gvma_gpa()函数的GPA。\n> bug, 不关注\n\n# 17.     KVM: RISC-V: Unmap stage2 mapping when deleting/moving a memslot\n\n    Unmap stage2 page tables when a memslot is being deleted or moved.  It's\n    the architectures' responsibility to ensure existing mappings are removed\n    when kvm_arch_flush_shadow_memslot() returns.\n\n当一个memslot被删除或移动时，unmap stage2页表。当kvm_arch_flush_shadow_memslot()返回时，架构有责任确保现有的映射被移除。\n\n# 18.     KVM: Let/force architectures to deal with arch specific memslot data\n\n    Pass the \"old\" slot to kvm_arch_prepare_memory_region() and force arch\n    code to handle propagating arch specific data from \"new\" to \"old\" when\n    necessary.  This is a baby step towards dynamically allocating \"new\" from\n    the get go, and is a (very) minor performance boost on x86 due to not\n    unnecessarily copying arch data.\n    \n    For PPC HV, copy the rmap in the !CREATE and !DELETE paths, i.e. for MOVE\n    and FLAGS_ONLY.  This is functionally a nop as the previous behavior\n    would overwrite the pointer for CREATE, and eventually discard/ignore it\n    for DELETE.\n    \n    For x86, copy the arch data only for FLAGS_ONLY changes.  Unlike PPC HV,\n    x86 needs to reallocate arch data in the MOVE case as the size of x86's\n    allocations depend on the alignment of the memslot's gfn.\n    \n    Opportunistically tweak kvm_arch_prepare_memory_region()'s param order to\n    match the \"commit\" prototype.\n\n将 \"old slot \"传递给kvm_arch_prepare_memory_region()，必要时强制arch-specific 代码处理从 \"new \"传播到 \"old \"的arch 特定数据。这是朝着动态分配 \"从头开始的新 \"迈出的一小步，也是对x86的一个（非常）小的性能提升，因为没有不必要地复制arch 数据。\n对于PPC HV，在！CREATE和！DELETE路径中复制rmap，即对于MOVE和FLAGS_ONLY。这在功能上是一个问题，因为之前的行为会覆盖CREATE的指针，并最终丢弃/忽略它用于DELETE。对于x86，只复制FLAGS_ONLY变化的档案数据。与PPC HV不同，在MOVE情况下，x86需要重新分配arch 数据，因为x86 分配的大小取决于memslot gfn的排列。\n机会性地调整kvm_arch_prepare_memory_region() param顺序以匹配 \"commit \"原型。\n\n内存memslot 动态分配相关优化 \n    \n# 19.     KVM: RISC-V: Use \"new\" memslot instead of userspace memory region  ???\n\n    Get the slot ID, hva, etc... from the \"new\" memslot instead of the\n    userspace memory region when preparing/committing a memory region.  This\n    will allow a future commit to drop @mem from the prepare/commit hooks\n    once all architectures convert to using \"new\".\n    \n    Opportunistically wait to get the various \"new\" values until after\n    filtering out the DELETE case in anticipation of a future commit passing\n    NULL for @new when deleting a memslot.\n\n在准备/提交内存区域时，从 \"new- memslot \"而不是用户空间内存区域获取slot ID、hva等。这将允许未来的提交在所有架构转换为使用 \"新 \"时，从准备/提交的钩子中删除@mem。机会性地等待得到各种 \"new 值 ， 直到过滤掉 DELETE 的情况后 ， 以期待未来的提交在删除一个 memslot 时通过 @new 的 NULL\n\n# 20.    KVM: RISC-V: Use common KVM implementation of MMU memory caches\n\n    Use common KVM's implementation of the MMU memory caches, which for all\n    intents and purposes is semantically identical to RISC-V's version, the\n    only difference being that the common implementation will fall back to an\n    atomic allocation if there's a KVM bug that triggers a cache underflow.\n    \n    RISC-V appears to have based its MMU code on arm64 before the conversion\n    to the common caches in commit c1a33aebe91d (\"KVM: arm64: Use common KVM\n    implementation of MMU memory caches\"), despite having also copy-pasted\n    the definition of KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE in kvm_types.h.\n    \n    Opportunistically drop the superfluous wrapper\n    kvm_riscv_stage2_flush_cache(), whose name is very, very confusing as\n    \"cache flush\" in the context of MMU code almost always refers to flushing\n    hardware caches, not freeing unused software objects.\n    \n    No functional change intended.\n\n使用MMU内存缓存的普通KVM实现，就所有的意图和目的而言，它与RISC-V-s版本在语义上是相同的，唯一的区别是，如果有一个KVM错误触发了缓存下溢，普通实现将退回到原子分配。RISC-V似乎在转换到提交c1a33aebe91d中的普通缓存之前将其MMU代码基于arm64（KVM：arm64：使用MMU内存缓存的普通KVM实现），尽管在kvm_types.h中也复制了KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE的定义。机会性地放弃多余的包装器kvm_riscv_stage2_flush_cache()，其名称非常非常令人困惑，因为在MMU代码的上下文中，缓存刷新 \"几乎总是指刷新硬件缓存，而不是释放未使用的软件对象。没有功能变化的意图。\n\n# 21.     RISC-V: KVM: Add SBI v0.2 base extension\n\n    SBI v0.2 base extension defined to allow backward compatibility and\n    probing of future extensions. This is also the only mandatory SBI\n    extension that must be implemented by SBI implementors.\n\nSBI v0.2基础扩展的定义是允许向后兼容和探测未来的扩展。这也是唯一的强制性SBI扩展，必须由SBI实现者来实现。\n\n# 22.     RISC-V: KVM: Add SBI HSM extension in KVM\n\n    SBI HSM extension allows OS to start/stop harts any time. It also allows\n    ordered booting of harts instead of random booting.\n    \n    Implement SBI HSM exntesion and designate the vcpu 0 as the boot vcpu id.\n    All other non-zero non-booting vcpus should be brought up by the OS\n    implementing HSM extension. If the guest OS doesn't implement HSM\n    extension, only single vcpu will be available to OS.\n\nSBI HSM扩展允许操作系统在任何时候开始/停止 harts。它还允许有序启动 hart，而不是随机启动。实施SBI HSM exntesion，并将vcpu 0指定为boot vcpu id。所有其他非零的非启动vcpus都应该由实现HSM扩展的操作系统提出。如果guest os 没有实现HSM扩展，那么只有单个vcpu可以被操作系统使用。\n\n# 23.     RISC-V: KVM: Forward SBI experimental and vendor extensions\n\n    The SBI experimental extension space is for temporary (or experimental)\n    stuff whereas SBI vendor extension space is for hardware vendor specific\n    stuff. Both these SBI extension spaces won't be standardized by the SBI\n    specification so let's blindly forward such SBI calls to the userspace.\n\nSBI实验性扩展空间用于临时（或实验性）特性，而SBI vendor 扩展空间用于硬件vendor 特性。这两个SBI扩展空间都不会被SBI规范化，我们可以盲目地将这种SBI调用转发给 kvm的 用户空间。\n\n\n# 24. KVM: RISC-V: Avoid spurious virtual interrupts after clearing hideleg CSR\n避免在清除隐藏的CSR后出现虚假的虚拟中断\n    When the last VM is terminated, the host kernel will invoke function\n    hardware_disable_nolock() on each CPU to disable the related virtualization\n    functions. Here, RISC-V currently only clears hideleg CSR and hedeleg CSR.\n    This behavior will cause the host kernel to receive spurious interrupts if\n    hvip CSR has pending interrupts and the corresponding enable bits in vsie\n    CSR are asserted. To avoid it, hvip CSR and vsie CSR must be cleared\n    before clearing hideleg CSR.\n\n当最后一个虚拟机被终止时，主机内核将在每个CPU上调用函数hardhard_disable_nolock()来禁用相关的虚拟化函数。在这里，RISC-V目前只清除了hideleg CSR和hedeleg CSR。如果hvip CSR有待定的中断，并且vsie CSR中相应的启用位被断言，这种行为将导致主机内核收到虚假的中断。为了避免这种情况，hvip CSR和vsie CSR必须在清除隐藏的CSR之前被清除。\n\n# 25.     kvm/riscv: rework guest entry logic\n\n    In kvm_arch_vcpu_ioctl_run() we enter an RCU extended quiescent state\n    (EQS) by calling guest_enter_irqoff(), and unmask IRQs prior to exiting\n    the EQS by calling guest_exit(). As the IRQ entry code will not wake RCU\n    in this case, we may run the core IRQ code and IRQ handler without RCU\n    watching, leading to various potential problems.\n    \n    Additionally, we do not inform lockdep or tracing that interrupts will\n    be enabled during guest execution, which caan lead to misleading traces\n    and warnings that interrupts have been enabled for overly-long periods.\n    \n    This patch fixes these issues by using the new timing and context\n    entry/exit helpers to ensure that interrupts are handled during guest\n    vtime but with RCU watching, with a sequence:\n    \n            guest_timing_enter_irqoff();\n    \n            guest_state_enter_irqoff();\n            < run the vcpu >\n            guest_state_exit_irqoff();\n    \n            < take any pending IRQs >\n    \n            guest_timing_exit_irqoff();\n    \n    Since instrumentation may make use of RCU, we must also ensure that no\n    instrumented code is run during the EQS. I've split out the critical\n    section into a new kvm_riscv_enter_exit_vcpu() helper which is marked\n    noinstr.\n\nRCU锁及开关中断相关优化\n\n# 26.     RISC-V: KVM: Add common kvm_riscv_vcpu_sbi_system_reset() function\n\n    We rename kvm_sbi_system_shutdown() to kvm_riscv_vcpu_sbi_system_reset()\n    and move it to vcpu_sbi.c so that it can be shared by SBI v0.1 shutdown\n    and SBI v0.3 SRST extension.\n\n我们将kvm_sbi_system_shutdown()重命名为kvm_riscv_vcpu_sbi_system_reset()，并将其移至vcpu_sbi.c，以便它可以被SBI v0.1关闭和SBI v0.3 SRST扩展共享。\n\n    The SBI v0.3 specification defines SRST (System Reset) extension which\n    provides a standard poweroff and reboot interface. This patch implements\n    SRST extension for the KVM Guest.\n\nSBI v0.3规范定义了SRST（系统重置）扩展，它提供了一个标准的断电和重启接口。这个补丁实现了KVM Guest的SRST扩展。\nguest os 重启\n\n# 27.     RISC-V: KVM: Add common kvm_riscv_vcpu_wfi() function\n\n    The wait for interrupt (WFI) instruction emulation can share the VCPU\n    halt logic with SBI HSM suspend emulation so this patch adds a common\n    kvm_riscv_vcpu_wfi() function for this purpose.\n等待中断（WFI）指令仿真可以与SBI HSM暂停仿真共享VCPU停止逻辑，所以这个补丁为此增加了一个通用的kvm_riscv_vcpu_wfi()函数。\n\n# 28.     RISC-V: KVM: Implement SBI HSM suspend call\n\n    The SBI v0.3 specification extends SBI HSM extension by adding SBI HSM\n    suspend call and related HART states. This patch extends the KVM RISC-V\n    HSM implementation to provide KVM guest a minimal SBI HSM suspend call\n    which is equivalent to a WFI instruction.\n\nSBI v0.3规范通过添加SBI HSM暂停调用和相关的HART状态扩展了SBI HSM的扩展。这个补丁扩展了KVM RISC-V HSM的实现，为KVM guest os提供了一个最小的SBI HSM暂停调用，相当于一个WFI指令。\n\n# 29.     RISC-V: KVM: Add Sv57x4 mode support for G-stage\n\n    Latest QEMU supports G-stage Sv57x4 mode so this patch extends KVM\n    RISC-V G-stage handling to detect and use Sv57x4 mode when available.\n最新的QEMU支持G阶段的Sv57x4模式，所以这个补丁扩展了KVM RISC-V G阶段的处理，以检测并在可用时使用Sv57x4模式。\n\n# 30.     RISC-V: KVM: Treat SBI HFENCE calls as NOPs\n\n    We should treat SBI HFENCE calls as NOPs until nested virtualization\n    is supported by KVM RISC-V. This will help us test booting a hypervisor\n    under KVM RISC-V.\n\n我们应该把SBI HFENCE调用当作NOP，直到KVM RISC-V支持嵌套虚拟化。这将有助于我们在KVM RISC-V下测试启动一个管理程序。\n\n# 31.     RISC-V: KVM: Add remote HFENCE functions based on VCPU requests\n\n    The generic KVM has support for VCPU requests which can be used\n    to do arch-specific work in the run-loop. We introduce remote\n    HFENCE functions which will internally use VCPU requests instead\n    of host SBI calls.\n    \n    Advantages of doing remote HFENCEs as VCPU requests are:\n    1) Multiple VCPUs of a Guest may be running on different Host CPUs\n       so it is not always possible to determine the Host CPU mask for\n       doing Host SBI call. For example, when VCPU X wants to do HFENCE\n       on VCPU Y, it is possible that VCPU Y is blocked or in user-space\n       (i.e. vcpu->cpu < 0).\n    2) To support nested virtualization, we will be having a separate\n       shadow G-stage for each VCPU and a common host G-stage for the\n       entire Guest/VM. The VCPU requests based remote HFENCEs helps\n       us easily synchronize the common host G-stage and shadow G-stage\n       of each VCPU without any additional IPI calls.\n    \n    This is also a preparatory patch for upcoming nested virtualization\n    support where we will be having a shadow G-stage page table for\n    each Guest VCPU.\n\n通用的KVM支持VCPU请求，可以用来在run-loop中做arch specific工作。我们引入了远程HFENCE函数，它在内部将使用VCPU请求而不是主机SBI调用。\n\n作为VCPU请求做远程HFENCE的好处是:\n1）一个guest os的多个VCPU可能在不同的物理 CPU上运行，所以并不总是能够确定物理cpuCPU掩码来做主机SBI调用。例如，当VCPU X想在VCPU Y上做HFENCE时，有可能VCPU Y被阻塞或在用户空间（即vcpu->cpu < 0）。\n2）为了支持嵌套虚拟化，我们将为每个VCPU提供一个单独的影子G阶段，为整个Guest/VM提供一个通用的G-stage 页表。基于VCPU请求的远程HFENCEs帮助我们轻松地同步每个VCPU的物理的G-stage页表和独立的影子G-stage页表，而不需要任何额外的IPI调用。\n\n这也是即将到来的嵌套虚拟化支持的一个准备补丁，我们将为每个guest VCPU提供一个影子G阶段的页表。\n\n# 32.     RISC-V: KVM: Cleanup stale TLB entries when host CPU changes\n\n    On RISC-V platforms with hardware VMID support, we share same\n    VMID for all VCPUs of a particular Guest/VM. This means we might\n    have stale G-stage TLB entries on the current Host CPU due to\n    some other VCPU of the same Guest which ran previously on the\n    current Host CPU.\n    \n    To cleanup stale TLB entries, we simply flush all G-stage TLB\n    entries by VMID whenever underlying Host CPU changes for a VCPU.\n\nVMID 相关. 增加在重新执行vcpu时刷新所有G-stage tlb的功能.\n\n在支持硬件VMID的RISC-V平台上，我们为一个特定的guest/VM的所有VCPU共享相同的VMID。这意味着我们在当前的主机CPU上可能有陈旧的G级TLB条目，这是因为之前在当前的主机CPU上运行的同一guest的其他VCPU。为了清理陈旧的TLB条目，我们只需在底层主机CPU为VCPU改变时，通过VMID刷新所有G级TLB条目。\n\n# 33.     RISC-V: KVM: Add extensible system instruction emulation framework\n\n    We will be emulating more system instructions in near future with\n    upcoming AIA, PMU, Nested and other virtualization features.\n    \n    To accommodate above, we add an extensible system instruction emulation\n    framework in vcpu_insn.c.\n我们将在不久的将来用即将到来的AIA、PMU、Nested和其他虚拟化功能模拟更多的系统指令。为了适应上述情况，我们在vcpu_insn.c中增加了一个可扩展的系统指令仿真框架。\n\n# 34.     RISC-V: KVM: Add extensible CSR emulation framework\n\n    We add an extensible CSR emulation framework which is based upon the\n    existing system instruction emulation. This will be useful to upcoming\n    AIA, PMU, Nested and other virtualization features.\n    \n    The CSR emulation framework also has provision to emulate CSR in user\n    space but this will be used only in very specific cases such as AIA\n    IMSIC CSR emulation in user space or vendor specific CSR emulation\n    in user space.\n    \n    By default, all CSRs not handled by KVM RISC-V will be redirected back\n    to Guest VCPU as illegal instruction trap.\n\n我们增加了一个可扩展的CSR仿真框架，它是基于现有的系统指令仿真的。这对即将到来的AIA、PMU、Nested和其他虚拟化功能很有用。CSR仿真框架也有在用户空间仿真CSR的规定，但这将只用于非常特殊的情况，如AIA IMSIC CSR仿真在用户空间或vendor厂商特定的CSR仿真在用户空间。默认情况下，所有未被KVM RISC-V处理的CSR将被重定向回Guest VCPU作为非法指令陷阱。\n\n# 35.     RISC-V: KVM: Add G-stage ioremap() and iounmap() functions\n\n    The in-kernel AIA IMSIC support requires on-demand mapping / unmapping\n    of Guest IMSIC address to Host IMSIC guest files. To help achieve this,\n    we add kvm_riscv_stage2_ioremap() and kvm_riscv_stage2_iounmap() functions.\n    These new functions for updating G-stage page table mappings will be called\n    in atomic context so we have special \"in_atomic\" parameter for this purpose.\n中断AIA IMSIC 相关\n内核 AIA IMSIC 的支持需要按需将guest os IMSIC 地址映射 / 解除映射到主机 IMSIC guest file。为了帮助实现这一点，我们增加了kvm_riscv_stage2_ioremap()和kvm_riscv_stage2_iounmap()函数。这些用于更新G阶段页表映射的新函数将在原子上下文中被调用，因此我们有特殊的in_atomic 参数来实现这一目的。\n\n# 36.     RISC-V: KVM: Add support for Svpbmt inside Guest/VM\n\n    The Guest/VM can use Svpbmt in VS-stage page tables when allowed by the\n    Hypervisor using the henvcfg.PBMTE bit.\n    \n    We add Svpbmt support for the KVM Guest/VM which can be enabled/disabled\n    by the KVM user-space (QEMU/KVMTOOL) using the ISA extension ONE_REG\n    interface.\n当Hypervisor使用henvcfg.PBMTE位允许时，Guest/VM可以在VS阶段的页表中使用Svpbmt。我们为KVM Guest/VM添加了Svpbmt支持，它可以通过KVM用户空间（QEMU/KVMTOOL）使用ISA扩展ONE_REG接口启用/禁用。\n\n# 37.     RISC-V: KVM: Support sstc extension\n\n    Sstc extension allows the guest to program the vstimecmp CSR directly\n    instead of making an SBI call to the hypervisor to program the next\n    event. The timer interrupt is also directly injected to the guest by\n    the hardware in this case. To maintain backward compatibility, the\n    hypervisors also update the vstimecmp in an SBI set_time call if\n    the hardware supports it. Thus, the older kernels in guest also\n    take advantage of the sstc extension.\n\nSstc扩展允许guest os直接对vstimecmp CSR进行编程，而不是对管理程序进行SBI调用来对下一个事件进行编程。在这种情况下，定时器中断也是由硬件直接注入到guest os上的。为了保持向后的兼容性，如果硬件支持，管理程序也会在SBI set_time调用中更新vstimecmp。因此，客户中较早的内核也利用了sstc的扩展。\n\n# 38.     RISC-V: KVM: Allow Guest use Svinval extension\n\n    We should advertise Svinval ISA extension to KVM user-space whenever\n    host supports it. This will allow KVM user-space (i.e. QEMU or KVMTOOL)\n    to pass on this information to Guest via ISA string.\n\nRISC-V: KVM: Allow Guest use Zihintpause extension\n\n    We should advertise Zihintpause ISA extension to KVM user-space whenever\n    host supports it. This will allow KVM user-space (i.e. QEMU or KVMTOOL)\n    to pass on this information to Guest via ISA string.\n    \n    Signed-off-by: Mayuresh Chitale <mchitale@ventanamicro.com>\n    Reviewed-by: Andrew Jones <ajones@ventanamicro.com>\n    Signed-off-by: Anup Patel <anup@brainfault.org>\n\nRISC-V: KVM: Provide UAPI for Zicbom block size\n\n    We're about to allow guests to use the Zicbom extension. KVM\n    userspace needs to know the cache block size in order to\n    properly advertise it to the guest. Provide a virtual config\n    register for userspace to get it with the GET_ONE_REG API, but\n    setting it cannot be supported, so disallow SET_ONE_REG.\n\nRISC-V: KVM: Expose Zicbom to the guest\n\n    Guests may use the cbo.inval,clean,flush instructions when the\n    CPU has the Zicbom extension and the hypervisor sets henvcfg.CBIE\n    (for cbo.inval) and henvcfg.CBCFE (for cbo.clean,flush).\n    \n    Add Zicbom support for KVM guests which may be enabled and\n    disabled from KVM userspace using the ISA extension ONE_REG API.\n    \n    Also opportunistically switch the other isa extension checks in\n    kvm_riscv_vcpu_update_config() to riscv_isa_extension_available().\n\n# 39.     RISC-V: KVM: Save mvendorid, marchid, and mimpid when creating VCPU\n\n    We should save VCPU mvendorid, marchid, and mimpid at the time\n    of creating VCPU so that we don't have to do host SBI call every\n    time Guest/VM ask for these details.\n    \n    RISC-V: KVM: Add ONE_REG interface for mvendorid, marchid, and mimpid\n    \n    We add ONE_REG interface for VCPU mvendorid, marchid, and mimpid\n    so that KVM user-space can change this details to support migration\n    across heterogeneous hosts.\n\n增加 mvendorid marchid mimpid get_reg/set_reg qemu相关接口\n\n\n\n# 总结\n\n1. 通用KVM模块所需的VCPU创建、启动和销毁功能\n\n2. 实现了VCPU中断和请求, 实现vcpu 设置 睡眠KVM_REQ_SLEEP/复位KVM_REQ_VCPU_RESET/休眠WFI 请求, 用户空间可以使用GET_MPSTATE/SET_MPSTATE ioctls来获取/设置VCPU的电源状态。\n\n3. KVM_GET_ONE_REG/KVM_SET_ONE_REG ioctls来访问读写VCPU 配置寄存器/通用寄存器/vcpu 控制和状态寄存器/浮点相关寄存器, 及mvendorid mimpid (version of the processor implementation) marchid的读取.\n\n4. 实现上下文切换时各寄存器状态的保存恢复, 包括上述的配置寄存器/通用寄存器/vcpu 控制和状态寄存器/浮点相关寄存器, 及host os的相关寄存器的保存恢复\n\n5. 实现 MMIO exit 加载/存储指令中提取MMIO 指令细节并将MMIO读/写转发到用户空间来实现MMIO读/写仿真, KVM内核模块将负责提取 guest page fault中的mmio读写指令细节, 将其传达给用户态虚拟机管理程序(如qemu), 并在恢复VCPU之前进行寄存器更新\n\n6. 为guest/虚拟机实现了VMID分配器/管理, 主要功能在VMID发生变化时，使用VCPU请求KVM_REQ_UPDATE_HGATP为每个guest VCPU强制更新HW Stage2 VMID\n\n7. 实现了为每个guest/虚拟机的stage2页表编程的所有必要功能。在高层次上，阶段2相关函数的流程与KVM ARM/ARM64实现相似，但阶段2页表格式与KVM RISC-V有很大不同\n\n8. sbi相关实现, guest 调用sbi ecall相关指令时, 需要陷入到 hypervisor中, 需要kvm 模块实现对应的sbi请求. 相关sbi 规范需支持 v01->v02->v03 的演化.\n\n   除了GETCHAR和PUTCHART调用被转发到用户空间，几乎所有SBI v0.1调用都在KVM内核模块中实现, SBI v0.2的实验和vendor 扩展调用转发给用户空间\n\n   SBI HSM扩展允许操作系统在任何时候开始/停止 harts。它还允许有序启动 hart，而不是随机启动。实施SBI HSM exntesion，并将vcpu 0指定为boot vcpu id。所有其他非零的非启动vcpus都应该由实现HSM扩展的操作系统提出。如果guest os 没有实现HSM扩展，那么只有单个vcpu可以被操作系统使用。\n\n   实现 SBI v0.3规范中的SRST（系统重置）扩展, hsm暂停调用扩展\n\n   实现hfence 扩展, 为未来的嵌套虚拟化做准备\n\n9. kvm中 hva->gpa 内存memslot 动态分配相关优化 \n\n10. 为即将到来的AIA、PMU、Nested和其他虚拟化功能模拟更多的系统指令。增加了一个可扩展的系统指令仿真框架, CSR仿真框架也有在用户空间仿真CSR的规定，但这将只用于非常特殊的情况. 如AIA IMSIC CSR仿真在用户空间或vendor厂商特定的CSR仿真在用户空间\n\n10. 实现 sstc, 允许guest os直接对vstimecmp CSR进行编程，而不是通过hypervisor进行SBI调用来对下一个事件进行编程。在这种情况下，定时器中断也是由硬件直接注入到guest os上的。为了保持向后的兼容性，如果硬件支持，hypervisor也会在SBI set_time调用中更新vstimecmp.\n\n","tags":["riscv","kvm"],"categories":["虚拟化","RISCV"]},{"title":"虚拟化技术介绍","url":"/2023/03/02/hxd_new/riscv调研/虚拟化/虚拟化技术介绍/","content":"\n## 虚拟化技术概述\n\n### 虚拟机特性:\n\n- 指令模拟 (guest 和 host 可以是不同的isa)\n- 本地指令直接执行( guest 和 host isa是相同的)\n\n### 系统资源虚拟化:\n\n- cpu虚拟化\n- 内存虚拟化\n- io 虚拟化\n\n### 常见的虚拟机软件:\n\n- vmware\n- virtual box\n- xen\n- linux-kvm qemu\n\n![image-20240416111641703](attachments/image-20240416111641703.png)\n\n### Hypervisor Virtual Machine Manager(VMM) 的功能\n\n- 控制所有的系统资源(CPU 内存 网络 存储等)\n- 创建虚拟机并分配响应的资源\n- 管理虚拟机的生命周期\n\nVMM 调度程序和操作系统的调度进程类似,  操作系统调度的基本单位是进程/线程, VMM调度的单位是虚拟处理器. 当虚拟cpu被调度到时, VMM调度程序负责将vcpu上下文装载到物理处理器上, 然后vcpu所对应的guest os 指令开始真正被执行. 当时间片用完或虚拟处理器主动让出, 调度程序被触发. 调度程序根据调度策略, 挑选下一个vcpu继续运行.\n与操作系统一样, VMM的调度策略可以有多种, 如平均时间片策略, 或按vcpu的权重分配时间片进行调度等.\n虚拟机之间可以通信, VMM需要实现对应的通信机制, 并向虚拟机提供对应的api(可以是时间通知, 共享内存等), 需要严格的安全权限检查.\n\n虚拟机环境管理包括创建/删除/暂停/查询/迁移等, 由虚拟机管理软件和VMM 管理接口组成.\n\n#### 物理资源的管理\n\n1. 处理器管理\n包括系统启动检测获取所有物理处理器, 对每个处理器进行初始化, 如设置运行模式, 设置页表, 设置中断处理函数等; 将所有的处理器纳入调度序列, 由调度程序对其进行调度. 还支持hot plug, 当有处理器插入时, vmm获得通知, 将其纳入调度序列. 当处理器拔出时,  vmm 得到通知, 将该处理器上执行的任务迁移到其他处理器上, 并将其从管理队列中删除. \n\n> 云服务存在多个处理器节点, 当某些节点出现故障时, 其上运行的guest os 不会宕机, 而是转移到其他正常工作的cpu节点上; \n   同样为了安全的扩充处理器资源, 在不断电的基础上进行cpu的扩充进而降低系统负载, 对服务器来说也是必要的;\n2. 内存管理\n\t系统启动时VMM检测并获取所有内存, 对获得的内存进行初始化, 包括分页设置页表等; 提供内存分配的接口, 给虚拟机分配内存, 并且维护虚拟机物理地址和实际物理地址的映射关系\n3. 中断管理\n\t根据中断来源, 或直接处理, 或转发给guest os 处理\n4. 系统时间维护\n\tVMM 拥有和时间相关的硬件资源, VMM 负责维护系统时间, 同时向各guest os 提供虚拟化的时间\n5. 设备管理\n\t所有的外设都属于VMM, VMM需要包含所有设备的驱动程序. 在混合模型下, 大部分的外部设备属于guest os, 少部分的设备属于VMM\n\n### 虚拟化的优点:\n\n- 更高的系统安全性和可用性\n\t- VMM 作为监视层, 运行在比os更高的特权层\n\t- 控制过滤虚拟机的行为\n\t- 监控虚拟机状态, 故障快速恢复\n- 最大化硬件资源使用率\n\t- 在一个物理主机上创建多个虚拟机共享主机资源, 节约硬件成本\n- 系统易扩展\n\t- 修改虚拟机的配置来适应业务的负载变化\n\t- Aggregation 聚合技术\n- 方便的可移植性\n\t- 虚拟机的系统消除物理主机的硬件差异\n\t- 虚拟机以文件镜像的格式封装\n- 硬件级别的隔离特性\n\t- 硬件沙盒机制\n\n### 不同类型的VMM:\n\n#### baremetal vmm (type1)\n\n- 启动时bootloader/BIOS 直接将执行权限交给hypervisor\n- 直接运行在硬件上, 不依赖基础操作系统\n- 可以控制所有的guest os\n- 交互少, 性能好, 稳定\n- 无法直接利用现有操作系统生态, 硬件兼容性差, 驱动开发工作量大\n\t\n\t> VMM根据产品定位, 有选择的挑选一些io 设备来支持, 如面向服务器市场, 只会挑选服务器上的io设备来开发驱动, 另外调度和电源管理等的很多功能需要在VMM中重新实现\n- 典型代表: Xen\n![image-20240416111647411](attachments/image-20240416111647411.png)\n\n#### hosted vmm (type2)\n\n- 启动时bl/BIOS 先启动host os, hypervisor/VMM 相当于host os中跑的一个应用\n- 需要通过host os 来访问硬件资源\n- vmm 只能控制guest os, 不能控制host os中的其他部分\n- guest os 和 host os 交互调用链长, 影响性能\n- 攻击窗口多, 安全性差\n- 可以直接利用现有操作系统生态, 硬件兼容性好\n- 典型代表: linux kvm\n![image-20240416111651919](attachments/image-20240416111651919.png)\n\nKVM的思想是在Linux内核的基础上添加虚拟机管理模块，重用Linux内核中已经完善的进程调度、内存管理、IO管理等代码，使之成为一个可以支持运行虚拟机的Hypervisor\n\n![image-20240416111701026](attachments/image-20240416111701026.png)\n\n#### 混合模型\n\n上述两种模式的集合体, VMM依然位于最底层, 拥有所有的物理资源, 与type1 模式不同的是, VMM会让出大部分io设备的控制权, 将它们交给guest os 控制, 相应的, VMM虚拟化的职责被分担, 处理器和内存的虚拟化仍由VMM 完成, 而IO虚拟化则由VMM和guest os 合作完成.\n\n## Hypervisor 的实现\n\n没有硬件虚拟化技术之前，Hypervisor 的实现主要有两种，一种是半虚拟化，一种是全虚拟化\n\n### 半虚拟化:\n\n- 将guest os 降权, 使其无法直接访问系统特权资源\n- vmm 提供访问系统特权资源的hyper call api\n- 修改guest os, 用hyper call api 访问系统特权资源\n- 高效轻量, 性能好\n- guest os 修改量大, 使用不便\n\n### 全虚拟化:\n\n- 将guest os 运行在vmm 创建的独立环境里\n- vmm 将内核特权访问操作翻译成一系列对vmm 的请求 (软件方案)\n- guest os对虚拟化环境不感知, 不需要修改guest os\n- vmm 实现复杂\n- vmm和guest os 之间翻译产生的负载比较大, 性能差\n\n### 硬件虚拟化 (简化hypervisor, 提高性能)\n\n- intel VT-x VT-d\n- AMD svm\n- ARM smmu等\n\n## CPU 虚拟化\n\n 虚拟CPU上下文\n\n- 类似于进程上下文的概念，当虚拟机发生退出时，需要保存虚拟CPU中各寄 存器的状态\n- 发生虚拟CPU调度时，需要保存当前虚拟CPU的上下文并加载待调度虚拟 CPU上下文\n\n![image-20240416111705202](attachments/image-20240416111705202.png)\n\n### 软件方案\n\n#### 不同指令集架构上的软件解决方案\n\n- 解释执行 \n\n  解释器将程序二进制解码后调用指令相应的模拟函数 \n\n  采用软件模拟的方式逐条模拟虚拟机指令的执行 \n\n- 二进制翻译 \n\n  区别于解释执行技术, 二进制翻译技术以基本块为单位, 将虚拟机指令批量 翻译后保存在代码缓存中 \n\n  基本块中的敏感指令会被替换为一系列其他指令\n\n#### 相同指令集架构上的软件解决方案\n\n##### 扫描与修补\n\nx86 虚拟化技术早期, VMM 运行在特权级, guest os运行在非特权级(用户态), 这种方式称为特权级压缩（Ring Compression. guest os 上内核运行特权指令时, 通常会触发异常, 进入特权级, 由VMM 截获异常并进行处理, 但是有一些`非特权敏感指令`并不会触发异常, 这种状态下, VMM就需要扫描guest os的内核的所有的这些不会触发异常的敏感指令, 将其翻译成支持虚拟化的指令(会触发异常的指令), vmm 再去处理这些翻译后指令触发的异常.\n\n> 修改系统资源的，或者在不同模式下行为有不同表现的，都属于敏感指令\n\n##### 硬件辅助方案\n\n软件方案是非常低效的, 且vmm 实现过于复杂, Intel VT-x、AMD SVM、ARM EL2、RISC-V H-Extension, 加入了一层特权级别, guest os 运行在这一层上, 这一层上所有特权指令均会触发异常, 可以被VMM截获处理\n\n![image-20240416111708905](attachments/image-20240416111708905.png)\n\n### 中断虚拟化\n\n#### 中断控制器的模拟\n\n需要为每一个虚拟机维护一个虚拟中断控制器\n\n![image-20240416111712769](attachments/image-20240416111712769.png)\n\n#### 物理主机, 设备中断处理流程\n\n  1. 设备产生一个水平/边缘触发中断信号\n  2. 中断控制器响应该信号, 让cpu el1 进入中断异常模式\n  3. os 调用中断服务程序, 通过irq number 找到对应驱动中断处理函数\n  4. 完成中断处理\n\n![image-20240416111716987](attachments/image-20240416111716987.png)\n\n#### 虚拟化系统中, 设置中断处理流程\n\n  1. 设备产生一个水平/边缘触发中断信号\n  2. 中断控制器响应该信号, 让cpu el2 进入中断异常模式\n  3. CPU 调用VMM 中断服务程序, 通过IRQ number 找到对应的guest os, 通过`中断注入程序`向guest os 注入virtual irq\n  4. guest os el1 cpu进入中断异常模式\n  5. guest os 调用中断服务程序, 通过virtual irq number 找到对应的驱动中断处理函数\n  6. 完成中断处理\n     ![image-20240416111722144](attachments/image-20240416111722144.png)\n\n## 内存虚拟化\n\n### 常见的内存虚拟化技术\n\n1. 地址空间分区\n\t- 简单, 但不灵活\n2. 半虚拟化 shadow page table\n\t- 虚拟地址模拟物理地址, 性能好, 需要修改guest os\n3. mmu 二级地址转换\n\t- 通过mmu硬件地址翻译\n\t- 对guest os 保持透明, 不需要修改原有mmu 代码\n\t- 运行时软件不介入翻译\n\n### 硬件虚拟化- 二级地址翻译\n\n>  实际上是扩展了影子页表技术, 硬件辅助化的措施:    新增寄存器，供硬件MMU读取, 由硬件mmu 完成二级页表翻译, 避免由软件翻译\n\n1. IPA (intermediate physical address) guest 物理地址\n2. 虚拟机物理地址空间由IPA 描述, 不直接指向真实物理地址\n3. 每个VM的IPA地址独立, 可以相同, 可以重叠, 也可以完全不同\n4. 通过两级地址翻译找到真实物理地址\n\t1) VA->IPA (guest os)\n\t\tarm64 使用TTBRn_EL1寄存器和页表, riscv 使用stap寄存器\n\t2) IPA->PA (VMM)\n\t\tarm64 使用VTTBR_EL2寄存器和stage2 页表, riscv 使用hgatp 寄存器\n\t\t![img](attachments/20221010161226.svg)\n\n### 各指令集架构内存硬件虚拟化辅助新增的寄存器\n\nIntel：EPT，起始地址：EPTP（in VMCS)\n\nAMD：NPT\n\nARM：Stage-2 页表，起始地址：VTTBR_EL2\n\nRISCV: Stage-2 页表，起始地址：hgatp\n\n## IO 模拟\n\n在没有虚拟化的系统中，由BIOS或者操作系统通过遍历PCI总线上的所有设备完成设备发现过程，而在虚拟化系统中，则由VMM决定向虚拟机呈现哪些设备。具体过程要根据设备是否存在于物理总线上来进行。对于一个真实存在于物理总线的设备，如果是不可枚举的类型，例如PS/2键盘，由于这类设备是硬编码固定的，驱动程序会通过其特定的访问方式来检查设备是否存在，因此**VMM只要在相应端口上模拟出该设备**，虚拟机即可成功检测到它;如果是可枚举的类型，譬如PCI设备或者PCIe设备，这种设备通常定义了完整的设备发现方法，并允许BIOS或者操作系统在设备枚举过程中通过PCI配置空间对其资源进行配置。因此VMM不仅要模拟这些设备本身的逻辑，还要模拟PCI总线的一些属性，包括总线拓扑关系及相应设备的PCI配置空间，以便虚拟机OS在启动时能够发现这些设备\n\n所谓设备模拟就是模拟设备的功能，内容十分多样且复杂。对于像PS/2键盘、鼠标这样的设备，**VMM需要根据设备的接口规范模拟设备的所有行为，才能够无需修改驱动就在虚拟机上展现出设备应有的效果**。而对于磁盘存储系统，则不必受限于实际的磁盘控制器以及具体磁盘类型和型号。比如，对IDE硬盘其I/O端口虚拟化时，底层可以是一块磁盘，可以是一个分区，也可以是不同格式的文件; 然后在其上实现一个专门的**块设备抽象层**; 最后在块设备上使用文件系统，并引入一些真实硬件没有的高级特性，例如：加密、备份、增量存储等。\n\n系统的物理设备需要同时接受来自多个虚拟机的I/O请求。因此，VMM还要将多个虚拟机的I/O请求合并为单独一个I/O数据流发送给底层设备驱动。当VMM收到来自底层设备驱动完成I/O请求的中断时，VMM还要能够将中断响应结果转发给正确的虚拟机，以通知其I/O操作结束。同时VMM在调度各个虚拟机发送来的I/O请求处理时，必须依据一定的算法确保虚拟机I/O的QoS与设备共享的公平性。\n\n对于type2 类的拥有完整生态的操作系统, vmm 作为一个内核模块,  客户机发生io后, vmm将其拦截后, 会通过用户态接口传给用户态的设备模型处理, 设备模型运行在host os 上的用户态层, 可以使用相应的系统调用及运行库. host os及运行库, 构成了设备模型的运行环境\n\n![image-20240416111754667](attachments/image-20240416111754667.png)\n\n而对于type1 类的baremental os, 通常不存在用户态, 设备模型是位于虚拟机设备驱动程序和实际设备驱动之间的一个模块, 由guest os发过来的io请求先通过设备模型模块转化为物理io设备请求, 在通过调用物理设备驱动来完成相应的io操作. 真实的设备驱动将io操作结果通过设备模型模块返回给guest os的虚拟设备驱动.\n\n![image-20240416111758642](attachments/image-20240416111758642.png)\n\n- type2 类 用户态设备模型:\n\n  - QEMU/KVM\n\n  - 用户态设备模型, 运行库生态健壮, 可复用性高\n\n  - 多次上下文切换\n\n\n- type1 类 baremental 设备模型:\n\n  - xvisor xen\n\n  - 减少了多次上下文切换\n\n  - 缩短io模拟路径\n\n  - 移植性差\n\n### 设备类型\n1) 端口io\n\t通过特定指令访问设备相关寄存器 (x86 专用的端口访问指令，IN/OUT)\n2) MMIO\n\t特定物理内存区域映射了设备的寄存器, os通过页表以访问内存的方式访问设备寄存器, RISCV 仅支持MMIO\n3) DMA\n\t无需CPU控制, DMA控制器接管地址总线\n4) PCI\n   或端口io方式或 MMIO方式,不占用固定地址-> 热插拔\n\n### IO 虚拟化基本任务\n\n- 访问截获\n- 提供设备接口\n\t- 虚拟设备接口, 如暴露虚拟pci 设备\n\t- 直通设备接口, 如intel VT-d 技术\n\t- 对虚拟机完全“透明”\n- 实现设备功能\n\t- type1 类baremental VMM 需要实现设备驱动, 设备模型; \n\t- type2 类需要实现用户态设备模型  运行库等\n\n### 端口IO 模拟\n\n虚拟机陷入过程\n- IN/OUT、INS/OUTS -> VM-Exit\n- 保留端口号、访问数据宽度、数据传输 方向、数据传输方向\n\nVMM 处理过程:\n- I/O端口对应的处理函数在设备模型初始 化时会被注册到hypervisor中\n- 函数指针被组织成数组\n- 根据I/O端口号和访问数据宽度寻找相应 端口IO处理函数\n\n![image-20240416111803993](attachments/image-20240416111803993.png)\n### MMIO模拟过程\n虚拟机陷入过程\n- 访存指令，非特权指令\n- 页表不存在相应页表项 -> 缺页异常 -> 陷入VM\n\nHypervisor中的处理\n- MMIO内存区域较大，通常不采用PIO中的函数数组形式\n- 为MMIO区域注册一个MMIO处理函数\n- 处理函数定位到需要访问的I/O端口\n\n### DMA 模拟\n\n- guest 驱动程序配置DMA 相关寄存器, 源地址 目的地址 (GPA) 及 长度\n- 陷入VMM, 设备模型用VMM 提供的`内存管理功能` 将源地址目的地址 (GPA) 翻译为 HPA, 配置物理DMA 的地址寄存器为HPA, 同时需要建立HPA 与 HVA的映射关系, 对其进行占位, 防止别的进程或vcpu把这块物理内存给抢走. 这个地方纯软件实现比较复杂, 涉及到映射给 guest 的虚拟设备地址与真实设备地址之间的转换, 如果为memory->memory, 会简单一些\n- guest 客户机驱动程序通过配置虚拟DMA的 命令控制寄存器发起 DMA操作\n- 陷入VMM, 设备模型截获这个操作后, 配置物理DMA命令控制寄存器\n- DMA 自行在HPA 间搬运数据\n- DMA 搬运完毕后, 通过中断通知vmm 设备模型, vmm设备模型返回到guest os中, DMA 请求结束\n\n### 设备直通\n\n软件实现I/O虚拟化的技术中，所有的虚拟机都共享物理平台上的硬件设备。如果物理条件好，有足够的硬件，就可以考虑让每个虚拟机独占一个物理设备，这样无疑会提高系统的性能。把某一个设备直接分配给一个虚拟机，让虚拟机可以直接访问该物理设备而不需要通过VMM或被VMM截获，这就是设备直通技术。\n\nintel 的 VT-d与AMD的IOMMU技术 arm的smmu 技术。尽管这两种技术在一定程度上提高了I/O访问性能，但代价却是限制了系统的可扩展性\n\n- 不发生或发生少量陷入VM\n- 性能接近裸机\n\n## ARM 硬件虚拟化技术:\n\n### CPU 特权层扩展\n\n- EL2 层(arm64) / HYP (arm32) 模式下运行vmm\n- guest os 运行在原有的特权模式, 不需要修改guest os\n- vmm所在层权限更高, 可以控制guest os 访问硬件的权限\n\n![image-20240416111808663](attachments/image-20240416111808663.png)\n\n#### 模式切换\n\n虚拟机 → Hypervisor \n\n\t- EL1 → EL2 \n\t- 敏感指令触发(可通过HCR_EL2寄存器细粒度 控制)\n\nHypervisor → 虚拟机\n\n- EL2 → EL1\n- eret指令触发\n\n#### 上下文切换\n\n- EL1与EL2各自有一套系统寄存器\n- 虚拟CPU调度时，需要将原虚拟CPU系统寄 存器保存至内存并从内存中加载目标虚拟 CPU寄存器\n\n因为有了硬件虚拟化的支持，所以hypervisor的实现 基本是基于硬件的 trap 和 软件的emulator 来实现的。guest os 访问一些特权寄存器或者指令，会进到 hypervisor ，然后会调用特权寄存器的访问函数来访问特权寄存器。如果是要访问硬盘，或者网络，会通过io 模拟器，来访问具体的模拟器。\n\n![image-20240416111813128](attachments/image-20240416111813128.png)\n\nCPU的虚拟化，就是让多个Guest os 分时的运行在同一个CPU上，都有自己独立的物理地址空间，让 hypervisor在EL2 层来帮助多个VM 来进行上下文的切换，这个和linux 进程的概念非常的相似，不过保存的上下文寄存器不一样，这里有两个重要的寄存器，`HCR_EL2` 和 `ESR_EL2`。HCR_EL2 是用来配置VM的参数，就是产生trap的条件，什么情况下会产生trap ， 什么情况下不会产生trap，右边是一个运行两个VM的例子。WFI指令是说明自己工作做完了，是idle状态了。\n\n![image-20240416111820943](attachments/image-20240416111820943.png)\n\nARM CPU虚拟化通过硬件trap和软件模拟完成\n\n1. HCR_EL2 hyper配置寄存器\n   1) 配置vm产生硬件trap的条件\n   2) 有非常丰富的组合, 如TLB/cache的操作, 一些特殊指令\n2. ESR_EL2 异常寄存器\n   1) 当trap发生时, 确定vm产生硬件trap的原因\n\n#### 执行特权指令示例:\n\n> 与特权级无关的一般的指令和通用寄存器在任何特权级都可以任意执行。而每个特权级都对应一些特殊指令和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不只是具有有读写 CSR 的指令，还有其他功能的特权指令。\n>\n> 如果低优先级下的处理器执行了高优先级的指令，会产生非法指令错误的异常，于是位于高特权级的执行环境能够得知低优先级的软件出现了该错误, 进而陷入到高特权级处理该指令\n\n![image-20240416111824532](attachments/image-20240416111824532.png)\n\n#### 访问特定寄存器示例:\n\n![image-20240416111828304](attachments/image-20240416111828304.png)\n\n\n\n> 使用陷入来虚拟化操作需要大量计算。比如功能寄存器ID_AA64MMFR0_EL1，不经常被操作系统访问。当将对这些寄存器的访问捕获到虚拟机监控程序中以模拟读取时，计算是可以接受的。\n> 但是对于访问频率高的寄存器，比如MPIDR_EL1，或者在性能关键代码中，需要尽可能地优化陷入，对这些寄存器，ARM提供了其它策略，hypervisor可以在进入VM时先配置好这些寄存器的值。例如，当VM中读到`MPIDR_EL1`时会自动返回`VMPIDR_EL2`的值而不发生陷入\n\n### MMU虚拟化支持\n\n- LPAE(arm32 大地址拓展技术) , stage2 translation\n\n1. 物理直通设备MMIO \n\n   - 阶段-2页表包含物理空间地址 与虚拟机IPA之间的映射 \n\n   - 不触发VM-Exit\n\n\n2. 虚拟设备MMIO\n\n   - 阶段-2 缺页异常\n     - 将IPA地址填充到HPFAR_EL2寄存器中\n     - 访问相关信息[Read,4 bytes, x0]，填充到ESR_EL2寄存器中\n\n   - 调用emulate_access函数，完成 MMIO的模拟\n\n   - ERET指令将控制流返回给vCPU\n\n![image-20240416111832268](attachments/image-20240416111832268.png)\n\n### GIC 虚拟化\n\n- vcpu interface, hypervisor interface\n\n#### 虚拟CPU接口直接访问\n\n- 将CPU接口置于CPU内部，通过寄存器访问\n- 为虚拟CPU接口提供专用寄存器(ICV_*)，区别于物理CPU接口\n- HCR_EL2.IMO和HCR_EL2.FMO设置为1时，运行在EL1中的Guest OS对CPU接口系 统寄存器（ICC_*）的访问将被重定向到相应的ICV_*寄存器而不会触发虚拟机陷入\n\n#### 虚拟中断注入\n\n- GICv3配置使得所有的物理中断路由到EL2\n- Hypervisor检查中断目标是否为vCPU\n- 根据`ICH_LRn_EL2`寄存器中保存的虚拟中断信息向虚拟机中注入中断\n\n#### 虚拟LPI中断直接注入\n\n- GICv3引入组件中断翻译服务`ITS`，该组件通过查询若干内存表将物理中断转化为 虚拟LPI中断注入相应的虚拟机\n\n### arch_timer 虚拟化\n\n- hypervisor timer, virtual timer\n\n时钟虚拟化要为guest os提供两种设备资源：\n\n- 计时资源：clock_source设备\n- 时钟定时器: clock_event设备\n\n对于clock_event设备，ARM64平台每个处理器有4个timer，3个物理timer和1个虚拟timer。物理机用物理timer，虚拟机用虚拟timer，相互之间并无资源冲突\n\n对于clock_source设备，按照ARM64的timer的设计，有物理counter和虚拟counter，物理机使用物理counter，虚拟机使用虚拟counter\n\n### smmu\n\n- stage2 translation for DMA\n\n- 一种DMA重映射机制\n\n- 扩大设备DMA寻址范围, 当系统无法提供大块连续物理内存时，也可以通过SMMU转换让设备可以访问分散物理内存\n\n- IOMMU在ARM-V8架构下的解决方案，与VT-d类似\n\n- SMMU与MMU共用一套阶段-2页 表\n\n- 设备直通\n\n  - 设备透传就是由虚机直接接管设备，虚机可以直接访问MMIO空间，VMM配置好IOMMU之后，设备DMA读写请求也无需VMM介入\n\n- 为每个虚拟机划定可用的设备, 起到隔离保护作用\n\n  ![image-20240416111836599](attachments/image-20240416111836599.png)\n\n物理机DMA 示例\n![image-20240416111840735](attachments/image-20240416111840735.png)\n\n- 网卡模块将数据从物理地址填入网卡DMA 寄存器\n- DMA模块通过物理地址访问物理内存\n\n虚拟机网卡如何进行DMA?\n![image-20240416111845117](attachments/image-20240416111845117.png)\n\n- 网卡驱动将数据的guest 物理地址填入网卡DMA 寄存器\n\n- 通过IPA 访问总线会产生故障\n\n  1. 调用hypervisor api 直接转换VA->PA\n     缺点: 修改驱动, API 调用产生额外性能开销\n  2. 为外设添加额外虚拟化支持\n     不需要修改驱动, 驱动无感知, 无额外api调用性能开销\n     SMMU 为系统除CPU 之外的任何具有DMA 能力的设备提供地址翻译服务和保护功能\n     - PCIE DMA 设备\n     - platform DMA 设备\n     - GPU/VE 加速器\n\n  ![image-20240416111848614](attachments/image-20240416111848614.png)\n\n#### SMMU for DMA 概述\n\n流表：每个流表项对应一个设备\n\n- VMID:设备所属虚拟机\n- S2TTB：阶段-2转换页表基地址\n- S1上下文指针：指向阶段-1上下文描述符表(CD 表)\n\nCD表: \n\n- TTB0 TTB1:分别保存用户空间和内核空间阶段-1页表\n- ASID：用于标记进程的地址空间\n\nSMMU从I/O 事务中获取设备标识符，即 `StreamID`\n\nSMMU从`SMMU_STRTAB_BASE`寄存器中获取`流表`的基地址，并通过`StreamID`获取对应的`STE`(流表项)\n\n在开启阶段-1转换的情况下，通过`SubstreamID` 定位到对应的`CD`，进而获取`ASID`和阶段-1页表 `基地址`。在开启阶段-2转换的情况下，在`STE` 中获取`VMID`和阶段-2页表`基地址`以及Stream World配置信息\n\nSMMU根据DMA地址、ASID、VMID、Stream World 查 询TLB。如果TLB命中，可以直接获得目标物理地址以及访问权限信息。如果TLB未命中，通过相应地址翻译过程获得对应的目标物理地址， 并将映射关系填充到TLB中\n\n设备根据目标物理地址进行数据传输\n\n![image-20240416111852573](attachments/image-20240416111852573.png)\n\n## RISCV 虚拟化技术\n\n### 已有的RISC-V虚拟化软件实现\n\n目前已有的实现有Xvisor和KVM，Xvisor是1类虚拟化软件，而KVM属于2类。\n\nRISC-V规范定义了RISC-V H-extension,在原来的3级特权架构的基础上，对原有的Supervisor模式进行了扩展，引入了Hypervisor-Extended Supervisor mode (HS)\n\n虚拟化H扩展定义了一个硬件状态位，称作V状态，可以为0或1，V状态不同，定义和访问的CSR寄存器也不同。\n\n- 当V为0时\n  - 以“s”开头的CSR寄存器表示当前操作系统的状态\n  - “hs”开头的用于支持和实现虚拟化软件\n  - “vs”开头的代表运行在虚拟化技术上的系统状态。\n- 当V为1时\n  - “s”开头的寄存器指向了前文以“vs”开头的寄存器。\n\n![image-20240416111856820](attachments/image-20240416111856820.png)\n\n#### 模式切换\n\n- 虚拟机 → Hypervisor\n  - VS mode → HS mode(先进入M mode，再由M mode 转发给HS mode)\n  - 敏感指令触发\n- Hypervisor → 虚拟机\n  - HS mode → VS mode\n  - sret指令触发\n\n#### 上下文切换\n\n- 为VS-mode提供VS CSR\n- 虚拟CPU调度时，同样需要从内存中保存和加载相应 的寄存器\n\n![image-20240416111900776](attachments/image-20240416111900776.png)\n![image-20240416111905467](attachments/image-20240416111905467.png)\nIn HS-mode (V=0):\n\n- s 开头的寄存器含义不变\n- h开头的寄存器指示hypervisor 的能力\n- vs 开头的寄存器指示vs 模式下的状态 (context switch时使用)\nVS-mode(V=1):\n- s开头的寄存器指向 vs 开头的寄存器\n\n### 2级mmu 地址转换\n\n使用stap 与`hgatp` 寄存器完成2级 地址转换, 原理一样\nva->ipa (guest os) satp\nipa -> pa (host os) hgatp\n\n### 中断\n\n*hedeleg* 虚拟异常代理寄存器\n\n*hideleg* 虚拟中断代理寄存器\n\n默认状态下, 在各级代理寄存器未设置时, 所有的trap 和 中断都被指向到 M 模式的trap (即mtvec 指定的入口函数处), 在指定了 `medeleg` 和 `mdieleg`后, 相应bit位的trap 和 中断 指向到 HS 模式的trap (即stvec 指定的入口函数处),  进一步, 在指定了 `hedeleg` 和 `hideleg` 后, 相应bit位的trap 和 中断指向到 VS 模式下的trap(即vstvec 指定的入口函数处)\n\n![image-20240416111912801](attachments/image-20240416111912801.png)\n\nhedeleg 中, 9-11 bit, 20-23 bit 是readonly的, 只能是0\n\n第0, 3, 8, 12, 13, 15 为推荐设置bit\n\n![image-20240416111916682](attachments/image-20240416111916682.png)\n\nhideleg 中, 0-15 中, 只有10, 6, 2 能被设置. 当hideleg中, bit 10被设置后, 10号中断来了后, 被代理到VS-mode后, code 10 会被自动转换为 code 9; 同样的 6号中断被自动转换为 5, 2号中断被自动转换为 1号. 这样做的目的是为guest os 中的 kernel 不用进行额外的修改来适配虚拟机.\n\n除此之外, HS模式可以使用`hvip`寄存器，来向VS模式注入虚拟的中断。\n\n\n#### Hypervisor Status Register (hstatus)\n![image-20240416111920612](attachments/image-20240416111920612.png)\n\nWhen VTSR=1, an attempt in VS-mode to execute SRET raises a virtual instruction exception. \nWhen VTW=1 (and assuming `mstatus`.TW=0), an attempt in VS-mode to execute WFI raises a virtual instruction exception if the WFI does not complete within an implementation-specific, bounded time limit.\nWhen VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or to access CSR `satp` raises a virtual instruction exception.\n\nThe VGEIN (Virtual Guest External Interrupt Number) field selects a guest external interrupt source for VS-level external interrupts. VGEIN is a **WLRL** field that must be able to hold values between zero and the maximum guest external interrupt number (known as GEILEN), inclusive. \nWhen VGEIN=0, no guest external interrupt source is selected for VS-level external interrupts. GEILEN may be zero, in which case VGEIN may be hardwired to zero. \nGuest external interrupts are explained in Section [1.2.4](https://five-embeddev.com/riscv-isa-manual/latest/hypervisor.html#sec:hgeinterruptregs), and the use of VGEIN is covered further in Section [1.2.3](https://five-embeddev.com/riscv-isa-manual/latest/hypervisor.html#sec:hinterruptregs).\n\nField HU (Hypervisor User mode) controls whether the virtual-machine load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode. When HU=1, these instructions can be executed in U-mode the same as in HS-mode. When HU=0, all hypervisor instructions cause an illegal instruction trap in U-mode.\n\n#### hip & hie\nRegisters `hip` and `hie` are HSXLEN-bit read/write registers that supplement HS-level’s `sip` and `sie` respectively. The `hip` register indicates pending VS-level and hypervisor-specific interrupts, while `hie` contains enable bits for the same interrupts. As with `sip` and `sie`, an interrupt _i_ will be taken in HS-mode if bit _i_ is set in both `hip` and `hie`, and if supervisor-level interrupts are globally enabled.\n\n![image-20240416111924324](attachments/image-20240416111924324.png)\n\nBits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level).\nSGEIP is read-only in `hip`, and is 1 if and only if the bitwise logical-AND of CSRs `hgeip` and `hgeie` is nonzero in any bit.\n\nBits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts. VSEIP is read-only in `hip`, and is the logical-OR of these interrupt sources:\n- bit VSEIP of `hvip`;\n- bit of `hgeip` selected by `hstatus`.VGEIN\n- any other platform-specific external interrupt signal directed to VS-level.\n\nBits `hip`.VSTIP and `hie`.VSTIE are the interrupt-pending and interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only in `hip`, and is the logical-OR of:\n- `hvip`.VSTIP\n- any other platform-specific timer interrupt signal directed to VS-level.\n\nBits `hip`.VSSIP and `hie`.VSSIE are the interrupt-pending and interrupt-enable bits for VS-level software interrupts. VSSIP in `hip` is an alias (writable) of the same bit in `hvip`.\n\n#### Hypervisor Guest External Interrupt Registers (`hgeip` and `hgeie`)\n\nhgeip indicates pending guest external interrupts for this hart.\nhgeie contains enable bits for the guest external interrupts at this hart.\nGuest external interrupts represent interrupts directed to individual virtual machines at VS-level.\n只有在设备直通场景下使用\n\ninterrupts from the device are intended for a specific virtual machine. Each bit of `hgeip` summarizes _all_ pending interrupts directed to one virtual hart, as collected and reported by an interrupt controller. To distinguish specific pending interrupts from multiple devices, software must query the interrupt controller.\n\nSupport for guest external interrupts requires an interrupt controller that can collect virtual-machine-directed interrupts separately from other interrupts.\n\n中断控制器需要收集virtual guest external interrupt, 和 物理cpu的external interrupt 区分开, guest 只能接收virtual external guest interrupt\n\nThe number of bits implemented in `hgeip` and `hgeie` for guest external interrupts is GEILEN (hstatus.VGEIN)\nbits GEILEN:1 shall be writable in `hgeie`, and all other bit positions shall be hardwired to zeros in both `hgeip` and `hgeie`.\n\nGuest external interrupt number _i_ at one physical hart is typically expected not to be the same as guest external interrupt _i_ at any other hart. \nFor any one physical hart, the maximum number of virtual harts that may directly receive guest external interrupts is limited by GEILEN.\n\nA hypervisor is always free to _emulate_ devices for any number of virtual harts without being limited by GEILEN. **Only direct pass-through (direct assignment) of interrupts is affected by the GEILEN limit, and the limit is on the number of virtual harts receiving such interrupts, not the number of distinct interrupts received.** The number of distinct interrupts a single virtual hart may receive                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            is determined by the interrupt controller.\n\nThe enable bits in `hgeie` do not affect the VS-level external interrupt signal selected from `hgeip` by `hstatus`.VGEIN.\n\n#### vsip & vsie\nhideleg not zero, `vsip`.SEIP and `vsie`.SEIE are aliases of `hip`.VSEIP and `hie`.VSEIE.\n`vsip`.STIP and `vsie`.STIE are aliases of `hip`.VSTIP and `hie`.VSTIE.\n`vsip`.SSIP and `vsie`.SSIE are aliases of `hip`.VSSIP and `hie`.VSSIE.\n\n\n#### 小结\n\nhideleg 开启时, \n- vsip.SEIP = hip.VSEIP  vsip.STIP = hip.VSTIP vsip.SSIP = hip.VSSIP\n\t- VSEIP is read-only in `hip`, and is the logical-OR of these interrupt sources:\n\t\t- bit VSEIP of `hvip`;\n\t\t- bit of `hgeip` selected by `hstatus`.VGEIN\n\t\t- any other platform-specific external interrupt signal directed to VS-level.\n\t- VSTIP is read-only in `hip`, and is the logical-OR of:\n\t\t- `hvip`.VSTIP\n\t\t- any other platform-specific timer interrupt signal directed to VS-level.\n\t- VSSIP in `hip` is an alias (writable) of the same bit in `hvip`. \n\t\t- 即 vsip.SSIP = hip.VSSIP = hvip.VSSIP\n- vsie.SEIE = hie.VSEIE  vsie.STIE = hie.VSTIE vsie.SSIE = hie.SSIE\n\n真正影响guest os的是vsip , guest os 运行时处于V=1 mode, vsip被替换为sip, \n- vsip software 中断来自于hvip (来自于HS hypervisor), 或者guest os 自己.\n- vsip timer 中断来自于hvip (来自于 HS hypervisor), 或guest os 自己, 或 platform-specific timer interrupt signal directed to VS-level\n- vsip guest external 中断来自于hvip (来自于HS hypervisor), 或hstatus.VGEIN -> hgeip 或 any other platform-specific external interrupt signal directed to VS-level\n\n下面这两句应该怎么理解?\n- Bits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level). \n- Bits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts.\n\n直译: \nSGEIP 和 SGEIE 是给HS 用的, 重点看 SGEIP, 这个是hgeip & hgeie and的结果, 代表的有guest external 中断待处理.\nhip.VSEIP 和 hip.VSEIE 是给VS 用的, 这个好理解, 这两个直接反应到vsip的相应bit上了.\n\n结合这句:\nif GEILEN is nonzero, bits GEILEN:1 shall be writable in `hgeie`\nOnly direct pass-through (direct assignment) of interrupts is affected by the GEILEN limit, and the limit is on the number of virtual harts receiving such interrupts, not the number of distinct interrupts received\n\n大概猜测, 在设备直通场景时, 0 - hstatus.VGEIN - GEILEN(物理cpu上托管的vcpu的数量), 不同的vcpu可以运行不同guest os.\n一个物理cpu 有三套寄存器 \n- v 开头的 vsip vsie 等\n- h 开头的 hvip hip hie hgeie hgeip 等\n- s 开头的 sip sie 等\n当V=0 -> V=1 时, v开头的寄存器会替换成 s 开头的寄存器, 此时变成vcpu的执行环境\nV=1 时, 只能访问 s 开头的寄存器.\n\n需要HS vmm 对 hgeie hstatus操作, 对应物理cpu上托管的vcpu\n如当前物理cpu上托管了8个vcpu, 正在运行的是第2个vcpu\n- 对 hstatus.VGEIN 设置为2\n- 对 hgeie 的前8个bit 置1, 表示物理cpu 管了8个vcpu, 这8个vcpu都要处理guest external interrupt.\n\n在前面前提下, 硬件需要将hip.VSSIP 与 hgeip的状态区分.\n前面hip.VSSIP 的来源处说的比较模糊: bit of `hgeip` selected by `hstatus`.VGEIN\n\n不太好理解, 大概猜测:\nPLIC 在设备直通场景(设置了hstatus.VGEIN时), guest 外部中断源需要区分给哪个vcpu, 导致的直接结果就是要设置hgeip 的哪个bit, 同时硬件应该将 hip.VSEIP 置为hgeip 与 hstatus.VGEIN 逻辑与 的结果. 而hip.SGEIP 置为 hgeip & hgeie 逻辑与的结果.\n\n虚拟机接管, 因为vsip.SEIP = hip.VSEIP, 假如中断控制器要发给第三个vcpu, 就需要将hgeip 的第三个bit 置1, 则hip.VSEIP = 0, 而 hip.SGEIP 为 1, 表明有待处理的guest external interrupt.\n\n在第二个vcpu 因tick到期 退出到hypervisor vmm 后, vmm 需要check hip.SGEIP, 此时有待处理的虚拟外部中断, 进而查hgeip, 查到是第三个vcpu的, 则切换到第三个vcpu 运行, 切换前将hstatus.VGEIN 设置为3. 此时vsip.SEIP = hip.VSEIP 会被置1, 第三个vcpu 陷入V=1 mode, 处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理guest external 中断(10号中断会换成9号中断), guest os 需要查询plic 中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将sip.SEIP 清0, 返回到 hypervisor vmm 后, 因为 sip.SEIP -> vsip.SEIP = hip.VSEIP 同样已经被置0了.\n\n#### 备注\nhgeip read-only csr, 由硬件操作\nhgeie rw csr, 由软件操作\nhip.SGEIP read-only bit, 由硬件操作\nhip.VSEIP read-only bit, 由硬件操作\n\n\n### 陷入模拟\n\n为了虚拟数据吞吐，HS模式可以使用“陷入-模拟”法。即在访问内存 映射外设对应的地址时，产生相应的中断，通过模拟外设的运行来实现后续的过程。这种方式可以模拟PLIC外设、VirtIO外设和其它一些软件模拟的吞吐外设。\n\nRISC-V可以通过核的CSR寄存器注入中断，因此不需要为虚拟化而特殊设计中断控制器外设。RISC-V的时钟和核间中断可通过SBI软件辅助完成，而Aarch64需要特殊设计的计时器外设来支持虚拟化功能。\n\n### 不足\n\nRISC-V对虚拟化的支持仍然只集中在CPU的虚拟化上。H-extension已经实现了与KVM和QEMU中的Xvisor的功能完备性。然而，目前还没有任何硬件实现是公开的，而且在可预见的未来，具有硬件虚拟化支持的商业RISC-V内核也不会被发布。RISC-V在虚拟化方面仍有一些差距。\n\n- 在ISA层面上，需要cache管理操作这样的功能。\n\n  - 尽管现有的管理程序层提供了逻辑上的CPU和内存隔离，但由于虚拟机（VM）之间共享的微架构资源（如最后一级的缓存、互连和内存控制器）造成的相互干扰，恶意的虚拟机可以通过增加对共享资源的消耗来实施拒绝服务（DoS）攻击, 或者利用现有的定时侧信道来间接访问其他虚拟机的数据 (Intel Cache Allocation Technology)\n\n- 缺少对虚拟化至关重要的组件是IOMMU。需要一个IOMMU来实现高效的虚拟化，通过允许直接分配DMA能力的设备给虚拟机，同时保证虚拟机和管理程序本身之间的强隔离。提供设备直通的能力. 这方面最近才有正式的文档发布, 距离开源实现还需要一些时间.\n\n  https://github.com/riscv-non-isa/riscv-iommu/releases\n\n  ![image-20240416111929646](attachments/image-20240416111929646.png)\n\n### Xvisor RISCV\n\n![image-20240416111935167](attachments/image-20240416111935167.png)\n\n#### Xvisor 上下文保存/恢复\n\n![image-20240416111938947](attachments/image-20240416111938947.png)\n\n![image-20240416111942274](attachments/image-20240416111942274.png)\n\n#### Xvisor 中断处理流程\n\n![image-20240416111948496](attachments/image-20240416111948496.png)\n\n#### Xvisor mmio 陷入模拟\n\n![image-20240416111952904](attachments/image-20240416111952904.png)\n\n## ARM Vs RISCV 硬件虚拟化辅助\n\n![image-20240416111957015](attachments/image-20240416111957015.png)\n\n","tags":["riscv"],"categories":["虚拟化","RISCV"]},{"title":"Zicbom 与 mcache 指令对比","url":"/2023/01/21/hxd_new/riscv调研/Zicbom 与 mcache 指令对比/","content":"\n# zicbom 提供的 cache 指令\n| Zicbom 指令 | 作用 |\n| ---- | ---- |\n| CBO.FLUSH | l1 & l2 cache 内容刷新到主存, 并将 cache line 状态置为无效, 下次访问该地址时, 会从主存 load 回来 |\n| CBO.CLEAN | cache line 处于修改状态, 会将 cache line 的内容刷新回主存, 不改变该 cache line 的状态   |\n| CBO.INVAL | 将 cache line 置为无效, 再次访问地址时, 会从主存上 load 回来 |\n\n# mcache\n\n缓存操作用于控制操作，如初始化、失效、驱逐等。以下是缓存操作的简要描述：\n1. 索引写回失效（Index Writeback Invalidate）：如果指定索引处的缓存行状态为有效且脏，该行将被写回到由缓存标记指定的内存地址。完成该操作后，缓存行的状态将设置为无效。如果行有效但不脏，则将行的状态设置为无效。\n2. 命中失效（Hit Invalidate）：如果缓存包含指定地址，该缓存行的状态将设置为无效。    \n3. 命中写回失效（Hit Writeback Inv）：如果缓存包含指定地址且该行有效且脏，该行的内容将写回到主存。完成该操作后，缓存行的状态将设置为无效。如果行有效但不脏，则将行的状态设置为无效。    \n4. 命中写回（Hit Writeback）：如果缓存包含指定地址且该行有效且脏，该行的内容将写回到主存。完成操作后，行的状态保持有效，但脏状态被清除。\n5. 获取并锁定（Fetch And Lock）：如果缓存包含指定地址，锁定该行。如果缓存不包含指定地址，从主存重新填充该行，然后锁定该行。 (只对 l2 cache 有效)\n\n# 对比\n对应于 cbo 指令:\n\n- mcache Hit Invalidate 与 CBO.INVAL 等效\n- mcache Hit Writeback 与 CBO.CLEAN 等效\n- mcache Hit WriteBack Inv 与 CBO.FLUSH 等效\n\n不同: \n1. cbo 的三条指令针对的是所有 cache (l1 l2)等, \n\tmcache 的这三条指令粒度更细, 需要分别指定 l1 和 l2 进行操作\n\t如:\n\tHit Writeback 有 Hit_Writeback_D 和 Hit_Writeback_S 两个操作 type, 分别用来 writeback l1 cache 和 l2 cache\n\n2. CBO 的三条指令是可以在 S-mode 及 M-mode 下执行的\n\t而 mcache 指令只能在 M-mode 下执行, S-mode 需要 cache 相关操作只能通过陷入到 M-mode 的 opensbi 来完成.\n\n3. mcache 另外提供了 index 操作, 主要方便用来回写并清空所有 l1 l2 cache line(不需要知道具体地址, 只需要按 index 覆盖 cacheline 内存范围即可)\n\t另外还提供了 Index invalidate icache Hit invalidate icache 和 fill icache 以及 fetch & lock l2 cache 的行为.\n","tags":["riscv","cache"],"categories":["RISCV","cache"]},{"title":"busybox 任意toolchain 制作动态版本","url":"/2023/01/11/hxd_new/wave/busybox 任意toolchain 制作动态版本/","content":"\n```shell\nmkdir riscv_build\nexport CROSS_COMPILE=riscv64-mti-linux-gnu- ARCH=riscv\nmake defconfig O=riscv_build\nmake -j12\nmake install O=riscv_build\n```\n\n# 上述默认为动态编译\n\n## 如果需要静态编译\n```shell\nmake menuconfig O=riscv_build\n\nLocation:                                                           \n-> Busybox Settings                                        \n   -> Build Options     \n      [*] Build BusyBox as a static binary (no shared libs)      \n```\n\n# 融合动态库\n\n```shell\n#riscv_build/_install 为 busybox 等生成的目录\nrsync -rl <toolchain_path>/sysroot/riscv/ _install/        #融合系统目录\n\n# 生成 init \ncd _install\nln -s bin/busybox init\n\n# 删除 _install 下的所有 *.o *.a 文件, 缩小体积\ncd _install\nfind . -type f -name \"*. O\" | xargs rm -f\nfind . -type f -name \"*. A\" | xargs rm -f   \n```\n\n# 生成 cpiogz 最终文件\n\n```shell\n把 install.sh 拷过来放到 riscv_build下\n执行 ./install.sh\n```\n\n# install.sh 脚本内容\n\n```shell\n#!/bin/bash\nsudo rm -rf rootfs\nmkdir rootfs\ncd rootfs\n\ncp -r ../_install/* .\nmkdir dev usr bin sbin lib etc proc tmp sys var root mnt\ncd etc\ncat > inittab <<- EOF\n::sysinit:/etc/init.d/rcS\n::respawn:-/bin/login\n::restart:/sbin/init\n::ctrlaltdel:/sbin/reboot\n::shutdown:/bin/umount -a -r\n::shutdown:/sbin/swapoff -a\nEOF\n\ncat > profile <<- EOF\n# /etc/profile: system-wide .profile file for the Bourne shells\necho\n# echo -n \"Processing /etc/profile...\"\n# no-op\n# Set search library path\n# echo \"Set search library path in /etc/profile\"\nexport LD_LIBRARY_PATH=/lib:/usr/lib\n# Set user path\n# echo \"Set user path in /etc/profile\"\nPATH=/bin:/sbin:/usr/bin:/usr/sbin\nexport PATH\n# Set PS1\n# Note: In addition to the SHELL variable, ash supports \\u, \\h, \\W, \\$, \\!, \\n, \\w, \\nnn (octal numbers corresponding to ASCII characters)\n# And \\e[xx;xxm (color effects), etc.\n# Also add an extra '\\' in front of it! \n# echo \"Set PS1 in /etc/profile\"\nexport PS1=\"\\\\e[00;32m[$USER@\\\\w\\\\a]\\\\$\\\\e[00;34m\"\n# echo \"Done\"\nalias ll='ls -al'\nEOF\n\n\ncat > fstab <<- EOF\nproc /proc proc defaults 0 0\nnone /tmp tmpfs defaults 0 0\nmdev /dev tmpfs defaults 0 0\nsysfs /sys sysfs defaults 0 0\nEOF\n\ncat > passwd <<- EOF\nroot:x:0:0:root:/root:/bin/sh\nEOF\n\ncat > group <<- EOF\nroot:x:0:root\nEOF\n\ncat > shadow <<- EOF\nroot:4rs6NCNMjYULk:19366:0:99999:7:::\nEOF\n\nmkdir init.d\ncd init.d\n\ncat > rcS <<- EOF\n#! /bin/sh\n#echo \"----------mount all\"\n/bin/mount -a\n#echo \"----------Starting mdev......\"\n#/bin/echo /sbin/mdev > /proc/sys/kernel/hotplug\nmdev -s\necho \"********************************************************\"\necho \" mini Rootfs\"\necho \"********************************************************\"\nEOF\n\ncd ../../dev\nsudo mknod -m 666 console c 5 1\nsudo mknod -m 666 null c 1 3\ncd ../\n\nsudo chmod 777 etc/init.d/rcS\n\nln -s bin/busybox init\ncd ../\nsudo chown -R root:root rootfs\ncd rootfs\nfind .| cpio -o -H newc | gzip > ../busybox_rootfs.cpio.gz\n\n```","tags":["busybox"],"categories":["linux"]},{"title":"xv6-riscv调研","url":"/2023/01/11/hxd_new/riscv调研/xv6-riscv/","content":"\nhttps://github.com/mit-pdos/xv6-riscv/\n一个简单，类UNIX的 MIT(麻省理工) 教学用操作系统\n\n\n\n\n\n# 用户态 syscall\n\nXv6内核提供了Unix内核传统上提供的服务和系统调用的子集\n\n| **系统调用**                            | **描述**                                                    |\n| --------------------------------------- | ----------------------------------------------------------- |\n| `int fork()`                            | 创建一个进程，返回子进程的PID                               |\n| `int exit(int status)`                  | 终止当前进程，并将状态报告给wait()函数。无返回              |\n| `int wait(int *status)`                 | 等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。  |\n| `int kill(int pid)`                     | 终止对应PID的进程，返回0，或返回-1表示错误                  |\n| `int getpid()`                          | 返回当前进程的PID                                           |\n| `int sleep(int n)`                      | 暂停n个时钟节拍                                             |\n| `int exec(char *file, char *argv[])`    | 加载一个文件并使用参数执行它; 只有在出错时才返回            |\n| `char *sbrk(int n)`                     | 按n 字节增长进程的内存。返回新内存的开始                    |\n| `int open(char *file, int flags)`       | 打开一个文件；flags表示read/write；返回一个fd（文件描述符） |\n| `int write(int fd, char *buf, int n)`   | 从buf 写n 个字节到文件描述符fd; 返回n                       |\n| `int read(int fd, char *buf, int n)`    | 将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0    |\n| `int close(int fd)`                     | 释放打开的文件fd                                            |\n| `int dup(int fd)`                       | 返回一个新的文件描述符，指向与fd 相同的文件                 |\n| `int pipe(int p[])`                     | 创建一个管道，把read/write文件描述符放在p[0]和p[1]中        |\n| `int chdir(char *dir)`                  | 改变当前的工作目录                                          |\n| `int mkdir(char *dir)`                  | 创建一个新目录                                              |\n| `int mknod(char *file, int, int)`       | 创建一个设备文件                                            |\n| `int fstat(int fd, struct stat *st)`    | 将打开文件fd的信息放入*st                                   |\n| `int stat(char *file, struct stat *st)` | 将指定名称的文件信息放入*st                                 |\n| `int link(char *file1, char *file2)`    | 为文件file1创建另一个名称(file2)                            |\n| `int unlink(char *file)`                | 删除一个文件                                                |\n\n用户态的基础接口\n\n- 文件操作 open read write close link unlink stat fstat mkdir chdir\n- 进程相关 fork dup wait pipe getpid exit kill\n- log相关 printf\n- 内存  malloc free\n- 时间相关 uptime(获取当前的tick) sleep\n\n# 文件系统\n\n提供了一个精简版的文件系统, 支持ramdisk, 支持文件读写\n\n可改code, 将用户态程序打包进文件系统, 将文件系统镜像融入到 kernel, 使之成为 kernel .rodata段的内容, 作为ramdisk使用\n\n不依赖加载器, 可以将用户态应用程序和 `little kernel` 打包到一起\n\n\n\n# cpu mode\n\n从M-mode 启动到 S-mode 的xv6 little kernel, 最后启动到 U-mode 的sh 终端\n\n\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230222173951.png)\n\n\n\n# smp\n\n支持多核启动\n\n\n\n# 内存布局\n\n启用mmu\n\nkernel 为线性映射 VA 等同于 PA\n\nXv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。\n\n![image-20230222143152947](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230222173952.png)\n\n​\t\t\t\t\t\t                                          内核地址空间\n\n\n\n内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是`KERNBASE=0x80000000`。直接映射简化了读/写物理内存的内核代码。例如，当 `fork` 为子进程分配用户内存时，分配器返回该内存的物理地址；`fork` 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。\n\n\n\n有几个内核虚拟地址不是直接映射：\n\n- trampoline 页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。Xv6在内核页表和每个用户页表中的同一个虚拟地址上映射了trampoline页\n- 内核栈页。每个进程都有自己的内核栈，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的守护页。守护页的 PTE 是无效的（不设置 `PTE_V` 位），这样如果内核栈溢出，很可能会引起异常，内核会报错。如果没有防护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。\n\n内核通过高地址映射使用它的栈空间，栈空间也可以通过直接映射的地址被内核访问。\n\n\n\n每个用户态进程都有一个单独的页表，当 xv6 在进程间切换时，也会改变页表\n\n![image-20230222143445243](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20230222173953.png)\n\n​\t\t\t\t\t\t                                    用户态进程地址空间\n\n\n\n为了检测用户栈溢出分配的栈内存，xv6 会在 stack 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个缺页异常。\n\n用户页表并不映射内核, 因为RISC-V硬件在trap过程中不切换页表，所以用户页表必须包含`uservec`的映射，即`stvec`指向的trap处理程序地址。`uservec`必须切换`satp`，使其指向内核页表；为了在切换后继续执行指令，`uservec`必须被映射到内核页表与用户页表相同的地址。\n\n\n\n# 调度\n\n***轮询调度***\n\nxv6周期性地强制切换，以应对长时间不进行sleep操作的计算进程, 用定时器中断来驱动上下文切换\n\n**sleep**和**wakeup**允许一个进程放弃CPU，并睡眠等待某一事件，并允许另一个进程将睡眠的进程唤醒\n\n\n\n# 优点\n\n文件结构简单, 资料丰富, 编出的文件小, 不依赖加载器, 支持比较常用的posix api.\n\n\n\n","tags":["riscv","xv6"],"categories":["os"]},{"title":"TI crypto","url":"/2022/10/25/hxd_new/TI crypto/","content":"\n- [[#introduction|introduction]]\n- [[#sign secure boot|sign secure boot]]\n- [[#KEK and DKEY|KEK and DKEY]]\n\t- [[#KEK and DKEY#如何使用DKEK (了解)|如何使用DKEK (了解)]]\n- [[#OTP|OTP]]\n- [[#keyWriter|keyWriter]]\n\n# main domain\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154628.png)\n\n加密硬件加速器 – 带 ECC 的 PKA、AES、SHA、 RNG、DES 和 3DES\nAsymmetrische Kryptografie: RSA und ECC-Funktionen \n• Hash-Funktionen: Message Digest Algorithm (MD5), SHA1 und SHA2-224/256/384/512 \n• Symmetrische Kryptografie-Funktionen: AES-128/192/256 \n• Hardware-TRNG-Modul mit Nachbearbeitung für einen deterministischen Zufallsbitgenerator (DRBG)\n\n# wakeup domain DMSC\n\n![](../images/Pasted%20image%2020220714094900.png)\n\nMain components of the DMSC are:\n•Arm Cortex-M3 processor core (ARMv7-M architecture profile)\n•160 KB ROM to allow boot sequence, authentication and provide security service (M3 accessible only)\n- Two separate local memory banks for Instruction code (I-code) and Data space (D-code) with single error correction and double error detection\n- Firewall enabled 32-bit VBUSP CBASS interconnect\n- Interrupt Aggregator with support of up to 80 interrupt inputs to the DMSC\n- Four dual-mode 32-bit timers\n- DMSC control module - contains various control, configuration and status MMRs for power management functions\n- Security Manager module for device security management, device type control (GP, EMU, HS), emulation and JTAG control, and key management\n- AES engine with 128, 192 and 256-bits support and DPA/EMA countermeasures\n\n##  TIFS world 安全通信能力\n\nSoC中的每个物理处理器都有能力在不同的模式下运行，如特权和非特权，安全或不安全。主机的定义超出了物理处理器的范围，也区分了处理器的操作模式。\n\nOn devices with distributed TIFS and DM services across multiple cores, the interaction between the hosts and the security and device manager is as below:\n\n![Software on different cores and secure proxy communication channels](../images/Pasted%20image%2020220714095618.png)\nSoftware on different cores and secure proxy communication channels\n\nFor secure cores the communication mechanism is as below:\n![](../images/Pasted%20image%2020220714095718.png)\n这一层通过了DMSC的加密中转, 为了开发一种安全的车辆 E/E 架构，需要在 ECU 内部实现一套复杂的加密计算过程。TI 为了解决这个问题，在 DMSC 中集成了AES，RNG，SHA 等安全加速器，用来对启动过程中的加密，验签提供硬件加速，这些硬件 IP 对上层提供的服务可以通过标准的 crypto driver 被调用\n![](../images/Pasted%20image%2020220714100126.png)\nFor messages running from `MCU R5F` the communication mechanism is as below:\n![](../images/Pasted%20image%2020220714095757.png)\nFor messages running from other non-secure cores the communication mechanism is as below:\n![](../images/Pasted%20image%2020220714095908.png)\n\n### secure Proxy J7 描述\n\n[J721E Secure Proxy Descriptions](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/j721e/sec_proxy.html)\n\n#### Secure Proxy thread allocation for NAVSS0_SEC_PROXY_0\n\n| Secure Proxy Thread ID | Direction (write or read) | Number of Messages | Host        | Host Function | IRQ (threshold)                                              | IRQ (error)                                                  |\n| ---------------------- | ------------------------- | ------------------ | ----------- | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 0                      | read                      | 2                  | A72_0       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_64, COMPUTE_CLUSTER0_GIC500SS/SPI_64 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_64, COMPUTE_CLUSTER0_GIC500SS/SPI_64 |\n| 1                      | read                      | 30                 | A72_0       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_65, COMPUTE_CLUSTER0_GIC500SS/SPI_65 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_65, COMPUTE_CLUSTER0_GIC500SS/SPI_65 |\n| 2                      | write                     | 10                 | A72_0       | high_priority | N/A                                                          | N/A                                                          |\n| 3                      | write                     | 20                 | A72_0       | low_priority  | N/A                                                          | N/A                                                          |\n| 4                      | write                     | 2                  | A72_0       | notify_resp   | N/A                                                          | N/A                                                          |\n| 5                      | read                      | 2                  | A72_1       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_66, COMPUTE_CLUSTER0_GIC500SS/SPI_66 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_66, COMPUTE_CLUSTER0_GIC500SS/SPI_66 |\n| 6                      | read                      | 30                 | A72_1       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_67, COMPUTE_CLUSTER0_GIC500SS/SPI_67 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_67, COMPUTE_CLUSTER0_GIC500SS/SPI_67 |\n| 7                      | write                     | 10                 | A72_1       | high_priority | N/A                                                          | N/A                                                          |\n| 8                      | write                     | 20                 | A72_1       | low_priority  | N/A                                                          | N/A                                                          |\n| 9                      | write                     | 2                  | A72_1       | notify_resp   | N/A                                                          | N/A                                                          |\n| 10                     | read                      | 2                  | A72_2       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_68, COMPUTE_CLUSTER0_GIC500SS/SPI_68 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_68, COMPUTE_CLUSTER0_GIC500SS/SPI_68 |\n| 11                     | read                      | 22                 | A72_2       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_69, COMPUTE_CLUSTER0_GIC500SS/SPI_69 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_69, COMPUTE_CLUSTER0_GIC500SS/SPI_69 |\n| 12                     | write                     | 2                  | A72_2       | high_priority | N/A                                                          | N/A                                                          |\n| 13                     | write                     | 20                 | A72_2       | low_priority  | N/A                                                          | N/A                                                          |\n| 14                     | write                     | 2                  | A72_2       | notify_resp   | N/A                                                          | N/A                                                          |\n| 15                     | read                      | 2                  | A72_3       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_70, COMPUTE_CLUSTER0_GIC500SS/SPI_70 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_70, COMPUTE_CLUSTER0_GIC500SS/SPI_70 |\n| 16                     | read                      | 7                  | A72_3       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_71, COMPUTE_CLUSTER0_GIC500SS/SPI_71 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_71, COMPUTE_CLUSTER0_GIC500SS/SPI_71 |\n| 17                     | write                     | 2                  | A72_3       | high_priority | N/A                                                          | N/A                                                          |\n| 18                     | write                     | 5                  | A72_3       | low_priority  | N/A                                                          | N/A                                                          |\n| 19                     | write                     | 2                  | A72_3       | notify_resp   | N/A                                                          | N/A                                                          |\n| 20                     | read                      | 2                  | A72_4       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_72, COMPUTE_CLUSTER0_GIC500SS/SPI_72 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_72, COMPUTE_CLUSTER0_GIC500SS/SPI_72 |\n| 21                     | read                      | 7                  | A72_4       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_73, COMPUTE_CLUSTER0_GIC500SS/SPI_73 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_73, COMPUTE_CLUSTER0_GIC500SS/SPI_73 |\n| 22                     | write                     | 2                  | A72_4       | high_priority | N/A                                                          | N/A                                                          |\n| 23                     | write                     | 5                  | A72_4       | low_priority  | N/A                                                          | N/A                                                          |\n| 24                     | write                     | 2                  | A72_4       | notify_resp   | N/A                                                          | N/A                                                          |\n| 25                     | read                      | 2                  | C7X_0       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_734, COMPUTE_CLUSTER0_GIC500SS/SPI_734 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_734, COMPUTE_CLUSTER0_GIC500SS/SPI_734 |\n| 26                     | read                      | 7                  | C7X_0       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_735, COMPUTE_CLUSTER0_GIC500SS/SPI_735 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_735, COMPUTE_CLUSTER0_GIC500SS/SPI_735 |\n| 27                     | write                     | 2                  | C7X_0       | high_priority | N/A                                                          | N/A                                                          |\n| 28                     | write                     | 5                  | C7X_0       | low_priority  | N/A                                                          | N/A                                                          |\n| 29                     | write                     | 2                  | C7X_0       | notify_resp   | N/A                                                          | N/A                                                          |\n| 30                     | read                      | 2                  | C7X_1       | notify        | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_732, COMPUTE_CLUSTER0_GIC500SS/SPI_732 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_732, COMPUTE_CLUSTER0_GIC500SS/SPI_732 |\n| 31                     | read                      | 7                  | C7X_1       | response      | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_733, COMPUTE_CLUSTER0_GIC500SS/SPI_733 | COMPUTE_CLUSTER0_CLEC/SOC_EVENTS_IN_733, COMPUTE_CLUSTER0_GIC500SS/SPI_733 |\n| 32                     | write                     | 2                  | C7X_1       | high_priority | N/A                                                          | N/A                                                          |\n| 33                     | write                     | 5                  | C7X_1       | low_priority  | N/A                                                          | N/A                                                          |\n| 34                     | write                     | 2                  | C7X_1       | notify_resp   | N/A                                                          | N/A                                                          |\n| 35                     | read                      | 2                  | C6X_0_0     | notify        | C66SS0_CORE0/C66_EVENT_IN_SYNC_4                             | C66SS0_CORE0/C66_EVENT_IN_SYNC_4                             |\n| 36                     | read                      | 7                  | C6X_0_0     | response      | C66SS0_CORE0/C66_EVENT_IN_SYNC_5                             | C66SS0_CORE0/C66_EVENT_IN_SYNC_5                             |\n| 37                     | write                     | 2                  | C6X_0_0     | high_priority | N/A                                                          | N/A                                                          |\n| 38                     | write                     | 5                  | C6X_0_0     | low_priority  | N/A                                                          | N/A                                                          |\n| 39                     | write                     | 2                  | C6X_0_0     | notify_resp   | N/A                                                          | N/A                                                          |\n| 40                     | read                      | 2                  | C6X_0_1     | notify        | C66SS0_CORE0/C66_EVENT_IN_SYNC_6                             | C66SS0_CORE0/C66_EVENT_IN_SYNC_6                             |\n| 41                     | read                      | 7                  | C6X_0_1     | response      | C66SS0_CORE0/C66_EVENT_IN_SYNC_7                             | C66SS0_CORE0/C66_EVENT_IN_SYNC_7                             |\n| 42                     | write                     | 2                  | C6X_0_1     | high_priority | N/A                                                          | N/A                                                          |\n| 43                     | write                     | 5                  | C6X_0_1     | low_priority  | N/A                                                          | N/A                                                          |\n| 44                     | write                     | 2                  | C6X_0_1     | notify_resp   | N/A                                                          | N/A                                                          |\n| 45                     | read                      | 2                  | C6X_1_0     | notify        | C66SS1_CORE0/C66_EVENT_IN_SYNC_4                             | C66SS1_CORE0/C66_EVENT_IN_SYNC_4                             |\n| 46                     | read                      | 7                  | C6X_1_0     | response      | C66SS1_CORE0/C66_EVENT_IN_SYNC_5                             | C66SS1_CORE0/C66_EVENT_IN_SYNC_5                             |\n| 47                     | write                     | 2                  | C6X_1_0     | high_priority | N/A                                                          | N/A                                                          |\n| 48                     | write                     | 5                  | C6X_1_0     | low_priority  | N/A                                                          | N/A                                                          |\n| 49                     | write                     | 2                  | C6X_1_0     | notify_resp   | N/A                                                          | N/A                                                          |\n| 50                     | read                      | 2                  | C6X_1_1     | notify        | C66SS1_CORE0/C66_EVENT_IN_SYNC_6                             | C66SS1_CORE0/C66_EVENT_IN_SYNC_6                             |\n| 51                     | read                      | 7                  | C6X_1_1     | response      | C66SS1_CORE0/C66_EVENT_IN_SYNC_7                             | C66SS1_CORE0/C66_EVENT_IN_SYNC_7                             |\n| 52                     | write                     | 2                  | C6X_1_1     | high_priority | N/A                                                          | N/A                                                          |\n| 53                     | write                     | 5                  | C6X_1_1     | low_priority  | N/A                                                          | N/A                                                          |\n| 54                     | write                     | 2                  | C6X_1_1     | notify_resp   | N/A                                                          | N/A                                                          |\n| 55                     | read                      | 2                  | GPU_0       | notify        | N/A                                                          | N/A                                                          |\n| 56                     | read                      | 7                  | GPU_0       | response      | N/A                                                          | N/A                                                          |\n| 57                     | write                     | 2                  | GPU_0       | high_priority | N/A                                                          | N/A                                                          |\n| 58                     | write                     | 5                  | GPU_0       | low_priority  | N/A                                                          | N/A                                                          |\n| 59                     | write                     | 2                  | GPU_0       | notify_resp   | N/A                                                          | N/A                                                          |\n| 60                     | read                      | 2                  | MAIN_0_R5_0 | notify        | R5FSS0_CORE0/INTR_224                                        | R5FSS0_CORE0/INTR_224                                        |\n| 61                     | read                      | 7                  | MAIN_0_R5_0 | response      | R5FSS0_CORE0/INTR_225                                        | R5FSS0_CORE0/INTR_225                                        |\n| 62                     | write                     | 2                  | MAIN_0_R5_0 | high_priority | N/A                                                          | N/A                                                          |\n| 63                     | write                     | 5                  | MAIN_0_R5_0 | low_priority  | N/A                                                          | N/A                                                          |\n| 64                     | write                     | 2                  | MAIN_0_R5_0 | notify_resp   | N/A                                                          | N/A                                                          |\n| 65                     | read                      | 2                  | MAIN_0_R5_1 | notify        | R5FSS0_CORE0/INTR_226                                        | R5FSS0_CORE0/INTR_226                                        |\n| 66                     | read                      | 7                  | MAIN_0_R5_1 | response      | R5FSS0_CORE0/INTR_227                                        | R5FSS0_CORE0/INTR_227                                        |\n| 67                     | write                     | 2                  | MAIN_0_R5_1 | high_priority | N/A                                                          | N/A                                                          |\n| 68                     | write                     | 5                  | MAIN_0_R5_1 | low_priority  | N/A                                                          | N/A                                                          |\n| 69                     | write                     | 2                  | MAIN_0_R5_1 | notify_resp   | N/A                                                          | N/A                                                          |\n| 70                     | read                      | 1                  | MAIN_0_R5_2 | notify        | R5FSS0_CORE1/INTR_224                                        | R5FSS0_CORE1/INTR_224                                        |\n| 71                     | read                      | 2                  | MAIN_0_R5_2 | response      | R5FSS0_CORE1/INTR_225                                        | R5FSS0_CORE1/INTR_225                                        |\n| 72                     | write                     | 1                  | MAIN_0_R5_2 | high_priority | N/A                                                          | N/A                                                          |\n| 73                     | write                     | 1                  | MAIN_0_R5_2 | low_priority  | N/A                                                          | N/A                                                          |\n| 74                     | write                     | 1                  | MAIN_0_R5_2 | notify_resp   | N/A                                                          | N/A                                                          |\n| 75                     | read                      | 1                  | MAIN_0_R5_3 | notify        | R5FSS0_CORE1/INTR_226                                        | R5FSS0_CORE1/INTR_226                                        |\n| 76                     | read                      | 2                  | MAIN_0_R5_3 | response      | R5FSS0_CORE1/INTR_227                                        | R5FSS0_CORE1/INTR_227                                        |\n| 77                     | write                     | 1                  | MAIN_0_R5_3 | high_priority | N/A                                                          | N/A                                                          |\n| 78                     | write                     | 1                  | MAIN_0_R5_3 | low_priority  | N/A                                                          | N/A                                                          |\n| 79                     | write                     | 1                  | MAIN_0_R5_3 | notify_resp   | N/A                                                          | N/A                                                          |\n| 80                     | read                      | 2                  | MAIN_1_R5_0 | notify        | R5FSS1_CORE0/INTR_224                                        | R5FSS1_CORE0/INTR_224                                        |\n| 81                     | read                      | 7                  | MAIN_1_R5_0 | response      | R5FSS1_CORE0/INTR_225                                        | R5FSS1_CORE0/INTR_225                                        |\n| 82                     | write                     | 2                  | MAIN_1_R5_0 | high_priority | N/A                                                          | N/A                                                          |\n| 83                     | write                     | 5                  | MAIN_1_R5_0 | low_priority  | N/A                                                          | N/A                                                          |\n| 84                     | write                     | 2                  | MAIN_1_R5_0 | notify_resp   | N/A                                                          | N/A                                                          |\n| 85                     | read                      | 2                  | MAIN_1_R5_1 | notify        | R5FSS1_CORE0/INTR_226                                        | R5FSS1_CORE0/INTR_226                                        |\n| 86                     | read                      | 7                  | MAIN_1_R5_1 | response      | R5FSS1_CORE0/INTR_227                                        | R5FSS1_CORE0/INTR_227                                        |\n| 87                     | write                     | 2                  | MAIN_1_R5_1 | high_priority | N/A                                                          | N/A                                                          |\n| 88                     | write                     | 5                  | MAIN_1_R5_1 | low_priority  | N/A                                                          | N/A                                                          |\n| 89                     | write                     | 2                  | MAIN_1_R5_1 | notify_resp   | N/A                                                          | N/A                                                          |\n| 90                     | read                      | 1                  | MAIN_1_R5_2 | notify        | R5FSS1_CORE1/INTR_224                                        | R5FSS1_CORE1/INTR_224                                        |\n| 91                     | read                      | 2                  | MAIN_1_R5_2 | response      | R5FSS1_CORE1/INTR_225                                        | R5FSS1_CORE1/INTR_225                                        |\n| 92                     | write                     | 1                  | MAIN_1_R5_2 | high_priority | N/A                                                          | N/A                                                          |\n| 93                     | write                     | 1                  | MAIN_1_R5_2 | low_priority  | N/A                                                          | N/A                                                          |\n| 94                     | write                     | 1                  | MAIN_1_R5_2 | notify_resp   | N/A                                                          | N/A                                                          |\n| 95                     | read                      | 1                  | MAIN_1_R5_3 | notify        | R5FSS1_CORE1/INTR_226                                        | R5FSS1_CORE1/INTR_226                                        |\n| 96                     | read                      | 2                  | MAIN_1_R5_3 | response      | R5FSS1_CORE1/INTR_227                                        | R5FSS1_CORE1/INTR_227                                        |\n| 97                     | write                     | 1                  | MAIN_1_R5_3 | high_priority | N/A                                                          | N/A                                                          |\n| 98                     | write                     | 1                  | MAIN_1_R5_3 | low_priority  | N/A                                                          | N/A                                                          |\n| 99                     | write                     | 1                  | MAIN_1_R5_3 | notify_resp   | N/A                                                          | N/A                                                          |\n| 100                    | read                      | 2                  | ICSSG_0     | notify        | N/A                                                          | N/A                                                          |\n| 101                    | read                      | 7                  | ICSSG_0     | response      | N/A                                                          | N/A                                                          |\n| 102                    | write                     | 2                  | ICSSG_0     | high_priority | N/A                                                          | N/A                                                          |\n| 103                    | write                     | 5                  | ICSSG_0     | low_priority  | N/A                                                          | N/A                                                          |\n| 104                    | write                     | 2                  | ICSSG_0     | notify_resp   | N/A                                                          | N/A                                                          |\n\n#### Secure Proxy thread allocation for MCU_NAVSS0_SEC_PROXY0\n\n| Secure Proxy Thread ID | Direction (write or read) | Number of Messages | Host       | Host Function | IRQ (threshold)          | IRQ (error)              |\n| ---------------------- | ------------------------- | ------------------ | ---------- | ------------- | ------------------------ | ------------------------ |\n| 0                      | read                      | 2                  | MCU_0_R5_0 | notify        | MCU_R5FSS0_CORE0/INTR_64 | MCU_R5FSS0_CORE0/INTR_64 |\n| 1                      | read                      | 20                 | MCU_0_R5_0 | response      | MCU_R5FSS0_CORE0/INTR_65 | MCU_R5FSS0_CORE0/INTR_65 |\n| 2                      | write                     | 10                 | MCU_0_R5_0 | high_priority | N/A                      | N/A                      |\n| 3                      | write                     | 10                 | MCU_0_R5_0 | low_priority  | N/A                      | N/A                      |\n| 4                      | write                     | 2                  | MCU_0_R5_0 | notify_resp   | N/A                      | N/A                      |\n| 5                      | read                      | 2                  | MCU_0_R5_1 | notify        | MCU_R5FSS0_CORE0/INTR_66 | MCU_R5FSS0_CORE0/INTR_66 |\n| 6                      | read                      | 20                 | MCU_0_R5_1 | response      | MCU_R5FSS0_CORE0/INTR_67 | MCU_R5FSS0_CORE0/INTR_67 |\n| 7                      | write                     | 10                 | MCU_0_R5_1 | high_priority | N/A                      | N/A                      |\n| 8                      | write                     | 10                 | MCU_0_R5_1 | low_priority  | N/A                      | N/A                      |\n| 9                      | write                     | 2                  | MCU_0_R5_1 | notify_resp   | N/A                      | N/A                      |\n| 10                     | read                      | 1                  | MCU_0_R5_2 | notify        | MCU_R5FSS0_CORE1/INTR_64 | MCU_R5FSS0_CORE1/INTR_64 |\n| 11                     | read                      | 2                  | MCU_0_R5_2 | response      | MCU_R5FSS0_CORE1/INTR_65 | MCU_R5FSS0_CORE1/INTR_65 |\n| 12                     | write                     | 1                  | MCU_0_R5_2 | high_priority | N/A                      | N/A                      |\n| 13                     | write                     | 1                  | MCU_0_R5_2 | low_priority  | N/A                      | N/A                      |\n| 14                     | write                     | 1                  | MCU_0_R5_2 | notify_resp   | N/A                      | N/A                      |\n| 15                     | read                      | 1                  | MCU_0_R5_3 | notify        | MCU_R5FSS0_CORE1/INTR_66 | MCU_R5FSS0_CORE1/INTR_66 |\n| 16                     | read                      | 2                  | MCU_0_R5_3 | response      | MCU_R5FSS0_CORE1/INTR_67 | MCU_R5FSS0_CORE1/INTR_67 |\n| 17                     | write                     | 1                  | MCU_0_R5_3 | high_priority | N/A                      | N/A                      |\n| 18                     | write                     | 1                  | MCU_0_R5_3 | low_priority  | N/A                      | N/A                      |\n| 19                     | write                     | 1                  | MCU_0_R5_3 | notify_resp   | N/A                      | N/A                      |\n\n#### Secure Proxy thread allocation for MCU_NAVSS0_SEC_PROXY0\n\n### List of priv-ids\n\n| Master name               | priv-id | secure | non-secure | privileged | user  | HOST-IDs |\n| ------------------------- | ------- | ------ | ---------- | ---------- | ----- | -------- |\n| a72_non_secure_supervisor | 1       | False  | True       | True       | False | 12,13,14 |\n| a72_secure_supervisor     | 1       | True   | False      | True       | False | 10,11    |\n| sproxy_private            | 11      | True   | True       | True       | True  | N/A      |\n| main_0_c7x_0_secure       | 21      | True   | False      | True       | True  | 20       |\n| main_0_c7x_0_nonsecure    | 21      | False  | True       | True       | True  | 21       |\n| pulsar_0                  | 96      | True   | True       | True       | False | 3,4      |\n| dm                        | 96      | True   | True       | True       | False | N/A      |\n| pulsar_1                  | 97      | True   | True       | True       | False | 5,6      |\n| main_0_icssg_0            | 136     | False  | True       | True       | True  | 50       |\n| gpu_0                     | 187     | False  | True       | True       | True  | 30       |\n| everyone                  | 195     | True   | True       | True       | True  | N/A      |\n| block_everyone            | 197     | True   | True       | True       | True  | N/A      |\n| dmsc                      | 202     | False  | True       | True       | True  | N/A      |\n| main_0_r5_0_nonsecure     | 212     | False  | True       | True       | True  | 35       |\n| main_0_r5_0_secure        | 212     | True   | False      | True       | True  | 36       |\n| main_0_r5_1_nonsecure     | 213     | False  | True       | True       | True  | 37       |\n| main_0_r5_1_secure        | 213     | True   | False      | True       | True  | 38       |\n| main_1_r5_0_nonsecure     | 214     | False  | True       | True       | True  | 40       |\n| main_1_r5_0_secure        | 214     | True   | False      | True       | True  | 41       |\n| main_1_r5_1_nonsecure     | 215     | False  | True       | True       | True  | 42       |\n| main_1_r5_1_secure        | 215     | True   | False      | True       | True  | 43       |\n| main_0_c6x_0_secure       | 220     | True   | False      | True       | True  | 25       |\n| main_0_c6x_0_nonsecure    | 220     | False  | True       | True       | True  | 26       |\n| main_0_c6x_1_secure       | 221     | True   | False      | True       | True  | 27       |\n| main_0_c6x_1_nonsecure    | 221     | False  | True       | True       | True  | 28       |\n\n### J721E Host Descriptions\n\n#### Enumeration of Host IDs\n\n| Host ID | Host Name   | Security Status | Description                             |\n| ------- | ----------- | --------------- | --------------------------------------- |\n| 0       | DMSC        | Secure          | Security Controller                     |\n| 3       | MCU_0_R5_0  | Non Secure      | Cortex R5 context 0 on MCU island       |\n| 4       | MCU_0_R5_1  | Secure          | Cortex R5 context 1 on MCU island(Boot) |\n| 5       | MCU_0_R5_2  | Non Secure      | Cortex R5 context 2 on MCU island       |\n| 6       | MCU_0_R5_3  | Secure          | Cortex R5 context 3 on MCU island       |\n| 10      | A72_0       | Secure          | Cortex A72 context 0 on Main island     |\n| 11      | A72_1       | Secure          | Cortex A72 context 1 on Main island     |\n| 12      | A72_2       | Non Secure      | Cortex A72 context 2 on Main island     |\n| 13      | A72_3       | Non Secure      | Cortex A72 context 3 on Main island     |\n| 14      | A72_4       | Non Secure      | Cortex A72 context 4 on Main island     |\n| 20      | C7X_0       | Secure          | C7x Context 0 on Main island            |\n| 21      | C7X_1       | Non Secure      | C7x context 1 on Main island            |\n| 25      | C6X_0_0     | Secure          | C6x_0 Context 0 on Main island          |\n| 26      | C6X_0_1     | Non Secure      | C6x_0 context 1 on Main island          |\n| 27      | C6X_1_0     | Secure          | C6x_1 Context 0 on Main island          |\n| 28      | C6X_1_1     | Non Secure      | C6x_1 context 1 on Main island          |\n| 30      | GPU_0       | Non Secure      | RGX context 0 on Main island            |\n| 35      | MAIN_0_R5_0 | Non Secure      | Cortex R5_0 context 0 on Main island    |\n| 36      | MAIN_0_R5_1 | Secure          | Cortex R5_0 context 1 on Main island    |\n| 37      | MAIN_0_R5_2 | Non Secure      | Cortex R5_0 context 2 on Main island    |\n| 38      | MAIN_0_R5_3 | Secure          | Cortex R5_0 context 3 on MCU island     |\n| 40      | MAIN_1_R5_0 | Non Secure      | Cortex R5_1 context 0 on Main island    |\n| 41      | MAIN_1_R5_1 | Secure          | Cortex R5_1 context 1 on Main island    |\n| 42      | MAIN_1_R5_2 | Non Secure      | Cortex R5_1 context 2 on Main island    |\n| 43      | MAIN_1_R5_3 | Secure          | Cortex R5_1 context 3 on MCU island     |\n| 50      | ICSSG_0     | Non Secure      | ICSSG context 0 on Main island          |\n\n### J721E Devices Descriptions\n\n#### Enumeration of Device IDs\n\n| Device ID | Device Name                                 |\n| --------- | ------------------------------------------- |\n| 0         | J721E_DEV_MCU_ADC12_16FFC0                  |\n| 1         | J721E_DEV_MCU_ADC12_16FFC1                  |\n| 2         | J721E_DEV_ATL0                              |\n| 3         | J721E_DEV_COMPUTE_CLUSTER0                  |\n| 4         | J721E_DEV_A72SS0                            |\n| 5         | J721E_DEV_COMPUTE_CLUSTER0_CFG_WRAP         |\n| 6         | J721E_DEV_COMPUTE_CLUSTER0_CLEC             |\n| 7         | J721E_DEV_COMPUTE_CLUSTER0_CORE_CORE        |\n| 8         | J721E_DEV_COMPUTE_CLUSTER0_DDR32SS_EMIF0_EW |\n| 9         | J721E_DEV_COMPUTE_CLUSTER0_DEBUG_WRAP       |\n| 10        | J721E_DEV_COMPUTE_CLUSTER0_DIVH2_DIVH0      |\n| 11        | J721E_DEV_COMPUTE_CLUSTER0_DIVP_TFT0        |\n| 12        | J721E_DEV_COMPUTE_CLUSTER0_DMSC_WRAP        |\n| 13        | J721E_DEV_COMPUTE_CLUSTER0_EN_MSMC_DOMAIN   |\n| 14        | J721E_DEV_COMPUTE_CLUSTER0_GIC500SS         |\n| 15        | J721E_DEV_C71SS0                            |\n| 16        | J721E_DEV_C71SS0_MMA                        |\n| 17        | J721E_DEV_COMPUTE_CLUSTER0_PBIST_WRAP       |\n| 18        | J721E_DEV_MCU_CPSW0                         |\n| 19        | J721E_DEV_CPSW0                             |\n| 20        | J721E_DEV_CPT2_AGGR0                        |\n| 21        | J721E_DEV_CPT2_AGGR1                        |\n| 22        | J721E_DEV_WKUP_DMSC0                        |\n| 23        | J721E_DEV_CPT2_AGGR2                        |\n| 24        | J721E_DEV_MCU_CPT2_AGGR0                    |\n| 25        | J721E_DEV_CSI_PSILSS0                       |\n| 26        | J721E_DEV_CSI_RX_IF0                        |\n| 27        | J721E_DEV_CSI_RX_IF1                        |\n| 28        | J721E_DEV_CSI_TX_IF0                        |\n| 29        | J721E_DEV_STM0                              |\n| 30        | J721E_DEV_DCC0                              |\n| 31        | J721E_DEV_DCC1                              |\n| 32        | J721E_DEV_DCC2                              |\n| 33        | J721E_DEV_DCC3                              |\n| 34        | J721E_DEV_DCC4                              |\n| 35        | J721E_DEV_MCU_TIMER0                        |\n| 36        | J721E_DEV_DCC5                              |\n| 37        | J721E_DEV_DCC6                              |\n| 38        | J721E_DEV_DCC7                              |\n| 39        | J721E_DEV_DCC8                              |\n| 40        | J721E_DEV_DCC9                              |\n| 41        | J721E_DEV_DCC10                             |\n| 42        | J721E_DEV_DCC11                             |\n| 43        | J721E_DEV_DCC12                             |\n| 44        | J721E_DEV_MCU_DCC0                          |\n| 45        | J721E_DEV_MCU_DCC1                          |\n| 46        | J721E_DEV_MCU_DCC2                          |\n| 47        | J721E_DEV_DDR0                              |\n| 48        | J721E_DEV_DMPAC0                            |\n| 49        | J721E_DEV_TIMER0                            |\n| 50        | J721E_DEV_TIMER1                            |\n| 51        | J721E_DEV_TIMER2                            |\n| 52        | J721E_DEV_TIMER3                            |\n| 53        | J721E_DEV_TIMER4                            |\n| 54        | J721E_DEV_TIMER5                            |\n| 55        | J721E_DEV_TIMER6                            |\n| 57        | J721E_DEV_TIMER7                            |\n| 58        | J721E_DEV_TIMER8                            |\n| 59        | J721E_DEV_TIMER9                            |\n| 60        | J721E_DEV_TIMER10                           |\n| 61        | J721E_DEV_GTC0                              |\n| 62        | J721E_DEV_TIMER11                           |\n| 63        | J721E_DEV_TIMER12                           |\n| 64        | J721E_DEV_TIMER13                           |\n| 65        | J721E_DEV_TIMER14                           |\n| 66        | J721E_DEV_TIMER15                           |\n| 67        | J721E_DEV_TIMER16                           |\n| 68        | J721E_DEV_TIMER17                           |\n| 69        | J721E_DEV_TIMER18                           |\n| 70        | J721E_DEV_TIMER19                           |\n| 71        | J721E_DEV_MCU_TIMER1                        |\n| 72        | J721E_DEV_MCU_TIMER2                        |\n| 73        | J721E_DEV_MCU_TIMER3                        |\n| 74        | J721E_DEV_MCU_TIMER4                        |\n| 75        | J721E_DEV_MCU_TIMER5                        |\n| 76        | J721E_DEV_MCU_TIMER6                        |\n| 77        | J721E_DEV_MCU_TIMER7                        |\n| 78        | J721E_DEV_MCU_TIMER8                        |\n| 79        | J721E_DEV_MCU_TIMER9                        |\n| 80        | J721E_DEV_ECAP0                             |\n| 81        | J721E_DEV_ECAP1                             |\n| 82        | J721E_DEV_ECAP2                             |\n| 83        | J721E_DEV_EHRPWM0                           |\n| 84        | J721E_DEV_EHRPWM1                           |\n| 85        | J721E_DEV_EHRPWM2                           |\n| 86        | J721E_DEV_EHRPWM3                           |\n| 87        | J721E_DEV_EHRPWM4                           |\n| 88        | J721E_DEV_EHRPWM5                           |\n| 89        | J721E_DEV_ELM0                              |\n| 90        | J721E_DEV_EMIF_DATA_0_VD                    |\n| 91        | J721E_DEV_MMCSD0                            |\n| 92        | J721E_DEV_MMCSD1                            |\n| 93        | J721E_DEV_MMCSD2                            |\n| 94        | J721E_DEV_EQEP0                             |\n| 95        | J721E_DEV_EQEP1                             |\n| 96        | J721E_DEV_EQEP2                             |\n| 97        | J721E_DEV_ESM0                              |\n| 98        | J721E_DEV_MCU_ESM0                          |\n| 99        | J721E_DEV_WKUP_ESM0                         |\n| 100       | J721E_DEV_MCU_FSS0                          |\n| 101       | J721E_DEV_MCU_FSS0_FSAS_0                   |\n| 102       | J721E_DEV_MCU_FSS0_HYPERBUS1P0_0            |\n| 103       | J721E_DEV_MCU_FSS0_OSPI_0                   |\n| 104       | J721E_DEV_MCU_FSS0_OSPI_1                   |\n| 105       | J721E_DEV_GPIO0                             |\n| 106       | J721E_DEV_GPIO1                             |\n| 107       | J721E_DEV_GPIO2                             |\n| 108       | J721E_DEV_GPIO3                             |\n| 109       | J721E_DEV_GPIO4                             |\n| 110       | J721E_DEV_GPIO5                             |\n| 111       | J721E_DEV_GPIO6                             |\n| 112       | J721E_DEV_GPIO7                             |\n| 113       | J721E_DEV_WKUP_GPIO0                        |\n| 114       | J721E_DEV_WKUP_GPIO1                        |\n| 115       | J721E_DEV_GPMC0                             |\n| 116       | J721E_DEV_I3C0                              |\n| 117       | J721E_DEV_MCU_I3C0                          |\n| 118       | J721E_DEV_MCU_I3C1                          |\n| 119       | J721E_DEV_PRU_ICSSG0                        |\n| 120       | J721E_DEV_PRU_ICSSG1                        |\n| 121       | J721E_DEV_C66SS0_INTROUTER0                 |\n| 122       | J721E_DEV_C66SS1_INTROUTER0                 |\n| 123       | J721E_DEV_CMPEVENT_INTRTR0                  |\n| 124       | J721E_DEV_GPU0                              |\n| 125       | J721E_DEV_GPU0_GPU_0                        |\n| 126       | J721E_DEV_GPU0_GPUCORE_0                    |\n| 127       | J721E_DEV_LED0                              |\n| 128       | J721E_DEV_MAIN2MCU_LVL_INTRTR0              |\n| 130       | J721E_DEV_MAIN2MCU_PLS_INTRTR0              |\n| 131       | J721E_DEV_GPIOMUX_INTRTR0                   |\n| 132       | J721E_DEV_WKUP_PORZ_SYNC0                   |\n| 133       | J721E_DEV_PSC0                              |\n| 134       | J721E_DEV_R5FSS0_INTROUTER0                 |\n| 135       | J721E_DEV_R5FSS1_INTROUTER0                 |\n| 136       | J721E_DEV_TIMESYNC_INTRTR0                  |\n| 137       | J721E_DEV_WKUP_GPIOMUX_INTRTR0              |\n| 138       | J721E_DEV_WKUP_PSC0                         |\n| 139       | J721E_DEV_AASRC0                            |\n| 140       | J721E_DEV_C66SS0                            |\n| 141       | J721E_DEV_C66SS1                            |\n| 142       | J721E_DEV_C66SS0_CORE0                      |\n| 143       | J721E_DEV_C66SS1_CORE0                      |\n| 144       | J721E_DEV_DECODER0                          |\n| 145       | J721E_DEV_WKUP_DDPA0                        |\n| 146       | J721E_DEV_UART0                             |\n| 147       | J721E_DEV_DPHY_RX0                          |\n| 148       | J721E_DEV_DPHY_RX1                          |\n| 149       | J721E_DEV_MCU_UART0                         |\n| 150       | J721E_DEV_DSS_DSI0                          |\n| 151       | J721E_DEV_DSS_EDP0                          |\n| 152       | J721E_DEV_DSS0                              |\n| 153       | J721E_DEV_ENCODER0                          |\n| 154       | J721E_DEV_WKUP_VTM0                         |\n| 155       | J721E_DEV_MAIN2WKUPMCU_VD                   |\n| 156       | J721E_DEV_MCAN0                             |\n| 157       | J721E_DEV_BOARD0                            |\n| 158       | J721E_DEV_MCAN1                             |\n| 160       | J721E_DEV_MCAN2                             |\n| 161       | J721E_DEV_MCAN3                             |\n| 162       | J721E_DEV_MCAN4                             |\n| 163       | J721E_DEV_MCAN5                             |\n| 164       | J721E_DEV_MCAN6                             |\n| 165       | J721E_DEV_MCAN7                             |\n| 166       | J721E_DEV_MCAN8                             |\n| 167       | J721E_DEV_MCAN9                             |\n| 168       | J721E_DEV_MCAN10                            |\n| 169       | J721E_DEV_MCAN11                            |\n| 170       | J721E_DEV_MCAN12                            |\n| 171       | J721E_DEV_MCAN13                            |\n| 172       | J721E_DEV_MCU_MCAN0                         |\n| 173       | J721E_DEV_MCU_MCAN1                         |\n| 174       | J721E_DEV_MCASP0                            |\n| 175       | J721E_DEV_MCASP1                            |\n| 176       | J721E_DEV_MCASP2                            |\n| 177       | J721E_DEV_MCASP3                            |\n| 178       | J721E_DEV_MCASP4                            |\n| 179       | J721E_DEV_MCASP5                            |\n| 180       | J721E_DEV_MCASP6                            |\n| 181       | J721E_DEV_MCASP7                            |\n| 182       | J721E_DEV_MCASP8                            |\n| 183       | J721E_DEV_MCASP9                            |\n| 184       | J721E_DEV_MCASP10                           |\n| 185       | J721E_DEV_MCASP11                           |\n| 186       | J721E_DEV_MLB0                              |\n| 187       | J721E_DEV_I2C0                              |\n| 188       | J721E_DEV_I2C1                              |\n| 189       | J721E_DEV_I2C2                              |\n| 190       | J721E_DEV_I2C3                              |\n| 191       | J721E_DEV_I2C4                              |\n| 192       | J721E_DEV_I2C5                              |\n| 193       | J721E_DEV_I2C6                              |\n| 194       | J721E_DEV_MCU_I2C0                          |\n| 195       | J721E_DEV_MCU_I2C1                          |\n| 197       | J721E_DEV_WKUP_I2C0                         |\n| 199       | J721E_DEV_NAVSS0                            |\n| 201       | J721E_DEV_NAVSS0_CPTS_0                     |\n| 202       | J721E_DEV_A72SS0_CORE0                      |\n| 203       | J721E_DEV_A72SS0_CORE1                      |\n| 206       | J721E_DEV_NAVSS0_DTI_0                      |\n| 207       | J721E_DEV_NAVSS0_MODSS_INTAGGR_0            |\n| 208       | J721E_DEV_NAVSS0_MODSS_INTAGGR_1            |\n| 209       | J721E_DEV_NAVSS0_UDMASS_INTAGGR_0           |\n| 210       | J721E_DEV_NAVSS0_PROXY_0                    |\n| 211       | J721E_DEV_NAVSS0_RINGACC_0                  |\n| 212       | J721E_DEV_NAVSS0_UDMAP_0                    |\n| 213       | J721E_DEV_NAVSS0_INTR_ROUTER_0              |\n| 214       | J721E_DEV_NAVSS0_MAILBOX_0                  |\n| 215       | J721E_DEV_NAVSS0_MAILBOX_1                  |\n| 216       | J721E_DEV_NAVSS0_MAILBOX_2                  |\n| 217       | J721E_DEV_NAVSS0_MAILBOX_3                  |\n| 218       | J721E_DEV_NAVSS0_MAILBOX_4                  |\n| 219       | J721E_DEV_NAVSS0_MAILBOX_5                  |\n| 220       | J721E_DEV_NAVSS0_MAILBOX_6                  |\n| 221       | J721E_DEV_NAVSS0_MAILBOX_7                  |\n| 222       | J721E_DEV_NAVSS0_MAILBOX_8                  |\n| 223       | J721E_DEV_NAVSS0_MAILBOX_9                  |\n| 224       | J721E_DEV_NAVSS0_MAILBOX_10                 |\n| 225       | J721E_DEV_NAVSS0_MAILBOX_11                 |\n| 226       | J721E_DEV_NAVSS0_SPINLOCK_0                 |\n| 227       | J721E_DEV_NAVSS0_MCRC_0                     |\n| 228       | J721E_DEV_NAVSS0_TBU_0                      |\n| 229       | J721E_DEV_NAVSS0_TCU_0                      |\n| 230       | J721E_DEV_NAVSS0_TIMERMGR_0                 |\n| 231       | J721E_DEV_NAVSS0_TIMERMGR_1                 |\n| 232       | J721E_DEV_MCU_NAVSS0                        |\n| 233       | J721E_DEV_MCU_NAVSS0_UDMASS_INTA_0          |\n| 234       | J721E_DEV_MCU_NAVSS0_PROXY0                 |\n| 235       | J721E_DEV_MCU_NAVSS0_RINGACC0               |\n| 236       | J721E_DEV_MCU_NAVSS0_UDMAP_0                |\n| 237       | J721E_DEV_MCU_NAVSS0_INTR_0                 |\n| 238       | J721E_DEV_MCU_NAVSS0_MCRC_0                 |\n| 239       | J721E_DEV_PCIE0                             |\n| 240       | J721E_DEV_PCIE1                             |\n| 241       | J721E_DEV_PCIE2                             |\n| 242       | J721E_DEV_PCIE3                             |\n| 243       | J721E_DEV_R5FSS0                            |\n| 244       | J721E_DEV_R5FSS1                            |\n| 245       | J721E_DEV_R5FSS0_CORE0                      |\n| 246       | J721E_DEV_R5FSS0_CORE1                      |\n| 247       | J721E_DEV_R5FSS1_CORE0                      |\n| 248       | J721E_DEV_R5FSS1_CORE1                      |\n| 249       | J721E_DEV_MCU_R5FSS0                        |\n| 250       | J721E_DEV_MCU_R5FSS0_CORE0                  |\n| 251       | J721E_DEV_MCU_R5FSS0_CORE1                  |\n| 252       | J721E_DEV_RTI0                              |\n| 253       | J721E_DEV_RTI1                              |\n| 254       | J721E_DEV_RTI24                             |\n| 255       | J721E_DEV_RTI25                             |\n| 256       | J721E_DEV_RTI16                             |\n| 257       | J721E_DEV_RTI15                             |\n| 258       | J721E_DEV_RTI28                             |\n| 259       | J721E_DEV_RTI29                             |\n| 260       | J721E_DEV_RTI30                             |\n| 261       | J721E_DEV_RTI31                             |\n| 262       | J721E_DEV_MCU_RTI0                          |\n| 263       | J721E_DEV_MCU_RTI1                          |\n| 264       | J721E_DEV_SA2_UL0                           |\n| 265       | J721E_DEV_MCU_SA2_UL0                       |\n| 266       | J721E_DEV_MCSPI0                            |\n| 267       | J721E_DEV_MCSPI1                            |\n| 268       | J721E_DEV_MCSPI2                            |\n| 269       | J721E_DEV_MCSPI3                            |\n| 270       | J721E_DEV_MCSPI4                            |\n| 271       | J721E_DEV_MCSPI5                            |\n| 272       | J721E_DEV_MCSPI6                            |\n| 273       | J721E_DEV_MCSPI7                            |\n| 274       | J721E_DEV_MCU_MCSPI0                        |\n| 275       | J721E_DEV_MCU_MCSPI1                        |\n| 276       | J721E_DEV_MCU_MCSPI2                        |\n| 277       | J721E_DEV_UFS0                              |\n| 278       | J721E_DEV_UART1                             |\n| 279       | J721E_DEV_UART2                             |\n| 280       | J721E_DEV_UART3                             |\n| 281       | J721E_DEV_UART4                             |\n| 282       | J721E_DEV_UART5                             |\n| 283       | J721E_DEV_UART6                             |\n| 284       | J721E_DEV_UART7                             |\n| 285       | J721E_DEV_UART8                             |\n| 286       | J721E_DEV_UART9                             |\n| 287       | J721E_DEV_WKUP_UART0                        |\n| 288       | J721E_DEV_USB0                              |\n| 289       | J721E_DEV_USB1                              |\n| 290       | J721E_DEV_VPAC0                             |\n| 291       | J721E_DEV_VPFE0                             |\n| 292       | J721E_DEV_SERDES_16G0                       |\n| 293       | J721E_DEV_SERDES_16G1                       |\n| 294       | J721E_DEV_SERDES_16G2                       |\n| 295       | J721E_DEV_SERDES_16G3                       |\n| 296       | J721E_DEV_DPHY_TX0                          |\n| 297       | J721E_DEV_SERDES_10G0                       |\n| 298       | J721E_DEV_WKUPMCU2MAIN_VD                   |\n| 299       | J721E_DEV_NAVSS0_MODSS                      |\n| 300       | J721E_DEV_NAVSS0_UDMASS                     |\n| 301       | J721E_DEV_NAVSS0_VIRTSS                     |\n| 302       | J721E_DEV_MCU_NAVSS0_MODSS                  |\n| 303       | J721E_DEV_MCU_NAVSS0_UDMASS                 |\n| 304       | J721E_DEV_DEBUGSS_WRAP0                     |\n| 305       | J721E_DEV_DMPAC0_SDE_0                      |\n| 306       | J721E_DEV_GPU0_DFT_PBIST_0                  |\n| 307       | J721E_DEV_C66SS0_PBIST0                     |\n| 308       | J721E_DEV_C66SS1_PBIST0                     |\n| 309       | J721E_DEV_PBIST0                            |\n| 310       | J721E_DEV_PBIST1                            |\n| 311       | J721E_DEV_PBIST2                            |\n| 312       | J721E_DEV_PBIST3                            |\n| 313       | J721E_DEV_PBIST4                            |\n| 314       | J721E_DEV_PBIST5                            |\n| 315       | J721E_DEV_PBIST6                            |\n| 316       | J721E_DEV_PBIST7                            |\n| 317       | J721E_DEV_PBIST9                            |\n| 318       | J721E_DEV_PBIST10                           |\n| 319       | J721E_DEV_MCU_PBIST0                        |\n| 320       | J721E_DEV_MCU_PBIST1                        |\n| 321       | J721E_DEV_C71X_0_PBIST_VD                   |\n\n### DMA Device IDs\n\nSome System Firmware TISCI message APIs require the DMA device ID be provided as part of the request. Based on [J721E_LEGACY Device IDs](devices.html) these are the valid DMA device IDs.\n\n| DMA Device Name              | DMA Device ID |\n| ---------------------------- | ------------- |\n| J721E_DEV_NAVSS0_UDMAP_0     | 212           |\n| J721E_DEV_MCU_NAVSS0_UDMAP_0 | 236           |\n\n\n\n# User Guide\n\n[TISCI User Guide — TISCI User Guide](https://software-dl.ti.com/tisci/esd/22_01_02/index.html#tisci-user-guide)\n\n-   [Chapter 1: Introduction](https://software-dl.ti.com/tisci/esd/22_01_02/1_intro/index.html)\n    -   [Introduction](https://software-dl.ti.com/tisci/esd/22_01_02/1_intro/TISCI.html)\n-   [Chapter 2: TISCI Message Documentation](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/index.html)\n    -   [Texas Instruments System Controller Interface (TISCI)](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/general/TISCI_header.html)\n    -   [General](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/index.html#general)\n    -   [Power Management (PM)](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/index.html#power-management-pm)\n    -   [Resource Management (RM)](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/index.html#resource-management-rm)\n    -   [Secure Management](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/index.html#secure-management)\n\t    -  **[Security X509 Certificate Documentation](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/sec_cert_format.html)**\n\t\t-   [Processor Boot Management TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/PROC_BOOT.html)\n\t\t-   [Firewall TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/firewall_api.html)\n\t\t-   [Secure AP Command Interface](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/sec_ap_data_transfer.html)\n\t\t-   [Runtime Debug TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/runtime_debug.html)\n\t\t-   [Extended OTP TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/extended_otp.html)\n\t\t-   **[Derived KEK TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/dkek_management.html)**\n\t\t-   [Security Handover Message Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/security_handover.html)\n\t\t-   [OTP Keywriter TISCI Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/keywriter.html)\n\t\t-   [OTP Revision Read/Write Message Description](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/otp_revision.html)\n-   [Chapter 3: Board Configuration](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/index.html)\n    -   [Board Configuration](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG.html)\n    -   [Resource Management Board Configuration](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG_RM.html)\n    -   [Security Board Configuration](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG_SEC.html)\n    -   [Power Management Board Configuration](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG_PM.html)\n    -   [Board Configuration with ROM Combined Image format](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG_COMBINED_IMG_FORMAT.html)\n-   [Chapter 4: Interpreting Trace Data](https://software-dl.ti.com/tisci/esd/22_01_02/4_trace/index.html)\n    -   [Trace Layer](https://software-dl.ti.com/tisci/esd/22_01_02/4_trace/trace.html)\n-   [Chapter 5: SoC Family Specific Documentation](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html)\n    -   [AM65x SR1](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#am65x-sr1)\n    -   [AM65x SR2](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#am65x-sr2)\n    -   [AM64x](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#am64x)\n    -   [J721E](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#j721e)\n    -   [J7200](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#j7200)\n    -   [J721S2](https://software-dl.ti.com/tisci/esd/22_01_02/5_soc_doc/index.html#j721s2)\n-   [Chapter 6: Topic User Guides](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/index.html)\n    -   [Device Group Primer](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/devgrp_usage.html)\n    -   [Domain Group Primer](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/domgrp_usage.html)\n    -   [Signing binaries for Secure Boot on HS Devices](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/secure_boot_signing.html)\n    -   [Signing Board Configuration on HS devices](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/hs_boardcfg_signing.html)\n    -   [Using Extended OTP on HS devices](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/extended_otp.html)\n    -   [Using Derived KEK on HS devices](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/dkek_management.html)\n    -   [Firewall FAQ](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/firewall_faq.html)\n    -   [SA2UL Access Outside of SYSFW](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/sa2ul_access.html)\n    -   [Performing Security Handover](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/security_handover.html)\n    -   [Secure Debug User Guide](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/secure_debug.html)\n    -   **[Key Writer](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/key_writer.html)**\n    -   [Run time read/write to KEYREV and SWREV](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/otp_revision.html)\n\n## introduction\n-   Foundational device security in DMSC\n  \n    > -   Secure boot with secure keys/root-of-trust, Security configuration and Debug unlock\n    > -   RSA or ECC Root Keys, AES symmetric key\n    > -   Utilizes PKA, SHA2 and AES Crypto accelerators\n    > -   Basic security functionality to extend root of trust (optional)\n    > -   Authenticated Key ring to extend root-of-trust keys\n    > -   SYSFW and Bootloader Rollback protection via eFuse\n    > -   Device Unique Key / Key Derivation to support 3P stacks\n\n\n![](https://software-dl.ti.com/tisci/esd/22_01_02/_images/softwareStack.png)\n\nPurpose of DMSC firmware change\n\n-   Secure HSM functions can run on a DMSC Security Island\n-   Free a main domain R5F for general customer use.\n-   Enables MCU Only mode with HSM functions on DMSC\n-   Lockstep Safety R5F runs safety critical PM & RM functions.\n\n\n## sign secure boot\n[Signing an unencrypted binary for secure boot](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/secure_boot_signing.html#signing-an-unencrypted-binary-for-secure-boot) ^unecrypted\n[signing-pm-rm-and-core-board-configurations](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/hs_boardcfg_signing.html#signing-pm-rm-and-core-board-configurations)^1b50a0\n\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154629.png)\n\n\n[Signing an unencrypted binary for secure boot](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/secure_boot_signing.html#signing-an-unencrypted-binary-for-secure-boot) ^crypted\n[signing-security-board-configuration](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/hs_boardcfg_signing.html#signing-security-board-configuration)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154630.png)\n\n\n[signing-procedure-for-optimized-boot-time](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/hs_boardcfg_signing.html#signing-procedure-for-optimized-boot-time) \n\n\n```ad-note\nThis sequence is only applicable to am65x, am65x_sr2, and j721e devices. This format is deprecated for all other devices which support the [combined boot image format](https://software-dl.ti.com/tisci/esd/22_01_02/3_boardcfg/BOARDCFG_COMBINED_IMG_FORMAT.html).\n```\n\nDue to the asymmetric key verify operation when authenticating the signed board configuration, there is ~4 ms increase in boot time compared to using an unsigned board configuration. To reduce the boot time increase, System Firmware offers an alternative way of supplying signed board configuration. This approach has two key differences from the normal approach.\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154631.png)\n1.  Populate `pmBoardCfgHash` , `rmBoardCfgHash` and `boardCfgHash` with the SHA2-512 hashes of PM Board configuration, RM board configuration and the core board configuration blobs respectively.\n<div class=\"wy-table-responsive\"><table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"13%\">\n<col width=\"17%\">\n<col width=\"18%\">\n<col width=\"24%\">\n<col width=\"28%\">\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Device\nType</th>\n<th class=\"head\">Boardcfg\nsigning\nrequired</th>\n<th class=\"head\">Signing\napproach</th>\n<th class=\"head\">TISCI message\npayload</th>\n<th class=\"head\">Boardcfg extension\nin SYSFW Outer\nCertificate</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>GP</td>\n<td>No</td>\n<td>NA</td>\n<td>Raw boardcfg</td>\n<td>NA</td>\n</tr>\n<tr class=\"row-odd\"><td>HS</td>\n<td>Yes</td>\n<td>Development</td>\n<td>Signed\ncertificate +\nencrypted\nboardcfg</td>\n<td>Do not include</td>\n</tr>\n<tr class=\"row-even\"><td>HS</td>\n<td>Yes</td>\n<td>Boot\ntime\noptimized</td>\n<td>encrypted\nboardcfg</td>\n<td>Include</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"wy-table-responsive\"><table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"13%\">\n<col width=\"17%\">\n<col width=\"18%\">\n<col width=\"24%\">\n<col width=\"28%\">\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Device\nType</th>\n<th class=\"head\">Boardcfg\nsigning\nrequired</th>\n<th class=\"head\">Signing\napproach</th>\n<th class=\"head\">TISCI message\npayload</th>\n<th class=\"head\">Boardcfg extension\nin SYSFW Outer\nCertificate</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>GP</td>\n<td>No</td>\n<td>NA</td>\n<td>Raw boardcfg</td>\n<td>NA</td>\n</tr>\n<tr class=\"row-odd\"><td>HS</td>\n<td>Yes</td>\n<td>Development</td>\n<td>Signed\ncertificate +\nraw\nboardcfg</td>\n<td>Do not include</td>\n</tr>\n<tr class=\"row-even\"><td>HS</td>\n<td>Yes</td>\n<td>Boot\ntime\noptimized</td>\n<td>raw\nboardcfg</td>\n<td>Include</td>\n</tr>\n</tbody>\n</table></div>\n\n## KEK and DKEY\n[Using Derived KEK on HS devices — TISCI User Guide](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/dkek_management.html#using-derived-kek-on-hs-devices)\n\n-   KEK is a randomly generated symmetric key\n-   KEK is made using NIST certified tester routine\n-   `KEK is different for each device` and is not correlated in any ways with keys issued on others devices.\n-   KEK is not stored in any database or retained in any manufacturing tester\n-   KEK is burnt in TI factory.\n\n```ad-warning\nKEK以硬件形式被送入DMSC内部的AES引擎。携带KEK的电子引信被标记为读和写保护。因此，KEK只能通过DMSC的AES引擎访问。每个设备的KEK都是不同的\n系统固件提供了API来获取`DKEK`的密钥，用于加密/解密，而不是将DMSC的AES引擎暴露给所有内核\n```\n\n密钥推导方法 [key-derivation-method](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/dkek_management.html#key-derivation-method)\n\n```ad-info\nDKEK的计算在每个设备上都是确定性的。对于一个给定的主机、标签和上下文，即使在同一设备上重启，导出的KEK也是一样的。\n在不同的设备上，对于相同的输入，衍生的KEK是不同的。这是由于在TI工厂中，每个设备都有一个随机的KEK被编入。\n```\n\n[Derived KEK TISCI Description — TISCI User Guide](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/dkek_management.html#derived-kek-tisci-description)\n\n[tisci-msg-sa2ul-set-dkek-set-dkek](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/dkek_management.html#tisci-msg-sa2ul-set-dkek-set-dkek)\n[tisci-msg-sa2ul-release-dkek-release-dkek](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/dkek_management.html#tisci-msg-sa2ul-release-dkek-release-dkek) erase key\n[tisci-msg-sa2ul-get-dkek-get-dkek](https://software-dl.ti.com/tisci/esd/22_01_02/2_tisci_msgs/security/dkek_management.html#tisci-msg-sa2ul-get-dkek-get-dkek)\n\n\n### 如何使用DKEK (了解)\n[using-derived-kek](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/dkek_management.html#using-derived-kek)\n\n<div class=\"section\" id=\"comparing-the-two-approaches\">\n<h3>Comparing the two approaches<a class=\"headerlink\" href=\"#comparing-the-two-approaches\" title=\"Permalink to this headline\">¶</a></h3>\n<div class=\"wy-table-responsive\"><table border=\"1\" class=\"docutils\" id=\"id1\">\n<caption><span class=\"caption-number\">Table 2 </span><span class=\"caption-text\">Comparison</span><a class=\"headerlink\" href=\"#id1\" title=\"Permalink to this table\">¶</a></caption>\n<colgroup>\n<col width=\"50%\">\n<col width=\"50%\">\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Option 1</th>\n<th class=\"head\">Option 2</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>DKEK programmed directly into SA2UL DKEK registers.</td>\n<td>DKEK is provided to host as a response to a TISCI message.</td>\n</tr>\n<tr class=\"row-odd\"><td>No separate firewalling is required for DKEK.</td>\n<td>Host must firewall memory where it is storing DKEK.</td>\n</tr>\n<tr class=\"row-even\"><td>DKEK can only be used through SA2UL. Host must set the <code class=\"docutils literal\"><span class=\"pre\">USE_DKEK</span></code>\nflag to true in the SA2UL security context. Key must not be populated\nin the SA2UL security context.</td>\n<td><p class=\"first\">DKEK can be used in two ways</p>\n<ul class=\"last simple\">\n<li>Through SA2UL - Host must program the key in its possession into\nthe SA2UL security context.</li>\n<li>Using CPU - If hardware acceleration is not required,\nencryption/decryption can be performed using CPU and the DKEK\nin the possession of the host.</li>\n</ul>\n</td>\n</tr>\n<tr class=\"row-odd\"><td>Only one host can use this approach at a time. There is only one set of\nSA2UL DKEK registers.\nAccess to these registers for encryption/decryption is controlled by DKEK\nprivid register.\nSystem Firmware programs the DKEK privid register with the privid of the host who\nhas invoked the <a class=\"reference internal\" href=\"../2_tisci_msgs/security/dkek_management.html#sec-api-sa2ul-set-dkek\"><span class=\"std std-ref\">TISCI_MSG_SA2UL_SET_DKEK</span></a>\nAPI.\nOnly this host can use DKEK via the SA2UL DKEK registers until DKEK\nis released via <a class=\"reference internal\" href=\"../2_tisci_msgs/security/dkek_management.html#sec-api-sa2ul-release-dkek\"><span class=\"std std-ref\">TISCI_MSG_SA2UL_RELEASE_DKEK</span></a></td>\n<td>Multiple hosts can use DKEK at the same time using this approach.\nEach host manages its own DKEK.</td>\n</tr>\n<tr class=\"row-even\"><td><a class=\"reference internal\" href=\"../2_tisci_msgs/security/dkek_management.html#sec-api-sa2ul-set-dkek\"><span class=\"std std-ref\">TISCI_MSG_SA2UL_SET_DKEK</span></a> and\n<a class=\"reference internal\" href=\"../2_tisci_msgs/security/dkek_management.html#sec-api-sa2ul-release-dkek\"><span class=\"std std-ref\">TISCI_MSG_SA2UL_RELEASE_DKEK</span></a>\nAPI are used in this approach.</td>\n<td><a class=\"reference internal\" href=\"../2_tisci_msgs/security/dkek_management.html#sec-api-sa2ul-get-dkek\"><span class=\"std std-ref\">TISCI_MSG_SA2UL_GET_DKEK</span></a> is used\nin this approach.</td>\n</tr>\n</tbody>\n</table></div>\n<p>We recommend using Approach 1 wherever possible to maintain the secrecy of DKEK.</p>\n</div>\n\n## OTP\n[Using Extended OTP on HS devices — TISCI User Guide](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/extended_otp.html#using-extended-otp-on-hs-devices)\n\nK3 family of devices have **a set of one-time programmable(OTP) efuses to carry root of trust keys and other information used during device boot. The purpose of these efuses is fixed.** *K3 family of devices have another set of OTP efuses for general purpose use by the customer.* We refer to these efuses as extended OTP. In this document, we describe how the extended OTP can be accessed through TISCI API. This document must be read along side\n\n```ad-warning\n两套OTP:\n1. device boot using otp\n2. *another set of OTP efuses for general purpose use by the customer.*\n\n本节只介绍了给客户用的otp\nThe extended OTP area can have a maximum of 1024 bits\n```\nThe hardware allows each individual OTP row (not MMR) to be locked to prevent modification. Once the OTP row is locked, any bit in the row can never be modified.\n\n## keyWriter\n\n[high-security-hs-device-sub-types](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/key_writer.html#high-security-hs-device-sub-types)\n\n**HS-FS (High Security - Field Securable)**: Device type before customer keys are programmed (the state in which the device leaves TI factory). In this state, device protects the ROM code, TI keys and certain security peripherals. HS-FS devices do not enforce secure boot process.\n\nSystem Firmware binary is signed by the TI Private key (TI MPK) [[#^1b50a0]]\n\n**HS-SE (High Security – Security Enforced)**: Device type after customer keys are programmed. HS-SE devices enforce secure boot.\n\n-   System Firmware binary is encrypted by the TI Encryption key (TI MEK), and signed by the TI Private key (TI MPK). *`Customer has to dual sign it with their private key (SMPK/BMPK)`*. (Refer [Signing an encrypted binary for secure boot](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/secure_boot_signing.html#pub-sign-encrypted-mek))\n\n\n[hs-fs-to-hs-se-conversion](https://software-dl.ti.com/tisci/esd/22_01_02/6_topic_user_guides/key_writer.html#hs-fs-to-hs-se-conversion)\n\nIn order to convert a HS-FS device to HS-SE device, one has to program the customer root key set (optionally backup key set) on the target device, using OTP Keywriter.\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154708.png)\n\nThe following figure illustrates the procedure to be followed to generate the required x509 certifcate for key writing.\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220622154704.png)\n\n\n<div class=\"wy-table-responsive\"><table border=\"1\" class=\"colwidths-given docutils\" id=\"id1\">\n<caption><span class=\"caption-number\">Table 4 </span><span class=\"caption-text\">Supported OTP keys</span><a class=\"headerlink\" href=\"#id1\" title=\"Permalink to this table\">¶</a></caption>\n<colgroup>\n<col width=\"20%\">\n<col width=\"35%\">\n<col width=\"45%\">\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Key</th>\n<th class=\"head\">Description</th>\n<th class=\"head\">Notes</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>BMEK</td>\n<td>Backup Manufacturer Encryption Key</td>\n<td>256-bit Customer encryption key for encrypted boot</td>\n</tr>\n<tr class=\"row-odd\"><td>BMPKH</td>\n<td>Backup Manufacturer Public Key Hash</td>\n<td>BMPK is 4096-bit customer RSA signing key</td>\n</tr>\n<tr class=\"row-even\"><td>EXTENDED OTP</td>\n<td>Extended OTP array</td>\n<td>1024 bit extended otp array</td>\n</tr>\n<tr class=\"row-odd\"><td>KEYCNT</td>\n<td>Key count</td>\n<td>2 if BMPK, SMPK are used, 1 if SMPK is used, 0 if none</td>\n</tr>\n<tr class=\"row-even\"><td>KEYREV</td>\n<td>Key revision</td>\n<td>Can have a maximum value = key count</td>\n</tr>\n<tr class=\"row-odd\"><td>MEK Options</td>\n<td>SMEK/BMEK options</td>\n<td>(Reserved for future use) 5 bit value</td>\n</tr>\n<tr class=\"row-even\"><td>MPK Options</td>\n<td>SMPK/BMPK options</td>\n<td>(Reserved for future use) 10 bit value (split into 2 parts)</td>\n</tr>\n<tr class=\"row-odd\"><td>MSV</td>\n<td>Model specific value</td>\n<td>20 bit value with 12 bit BCH code</td>\n</tr>\n<tr class=\"row-even\"><td>SMEK</td>\n<td>Secondary Manufacturer Encryption Key</td>\n<td>256-bit Customer encryption key for encrypted boot</td>\n</tr>\n<tr class=\"row-odd\"><td>SMPKH</td>\n<td>Secondary Manufacturer Public Key Hash</td>\n<td>SMPK is 4096-bit customer RSA signing key</td>\n</tr>\n<tr class=\"row-even\"><td>SWREV-BOARDCONFIG</td>\n<td>Secure Board Configuration software revision</td>\n<td>128 bit value (64 without double redundancy)</td>\n</tr>\n<tr class=\"row-odd\"><td>SWREV-SBL</td>\n<td>SBL software revision</td>\n<td>96 bit value (48 without double redundancy)</td>\n</tr>\n<tr class=\"row-even\"><td>SWREV-SYSFW</td>\n<td>Firmware software revision</td>\n<td>96 bit value (48 without double redundancy)</td>\n</tr>\n</tbody>\n</table></div>\n1.  OEM generates a random 256-bit number to be used as an AES encryption key for protecting the OTP extension data.\n2.  The AES-256 key from step 1 is used to encrypt all X509 extension fields, which require encryption protection.\n3.  The following X509 extensions are created, using the AES key encrypted with the TI FEK (public key):\n    -   Encrypting the AES-256 key with TI **FEK**\n    -   Signing the AES-256 key with the SMPK [[#^7ad323|SMPK]], and encrypting that with the TI FEK\n    -   (optionally, refer step 6) signing the AES-256 key with the BMPK [[#^edb701|BMPK]], and encrypting that with the TI FEK\n4.  All of the extensions from steps 1-3 are combined into a X.509 configuration which is used to generate and sign a certificate with the [[#^7ad323|SMPK]]. \n\nSMPK (Secondary Manufacturer Public Key)  ^7ad323\n\nBMPK ( Backup Manufacturer Public Key)   ^edb701\n\n\n\n\n\n\n\n\n\n\n\n","tags":["TI crypto"],"categories":["加密"]},{"title":"qemu 新增 riscv machine 参考.","url":"/2022/10/21/hxd_new/riscv调研/虚拟化/qemu 新增 riscv machine 参考/","content":"\nqemu 启动虚拟机时需要指定Machine 即 -M 参数指定对应的机型.\n从我们之前分析的demo看, 默认以virt 启动, 因riscv vcpu 只能运行在S/U mode 下, 所以不需要关注opensbi的部分, 只需要关注u-boot 和 kernel的部分.\n这里只说kernel的部分, kernel 在编译时也要按对应的机型编译, 如virt. 还有dtb的部分, kernel 和 qemu 中也是对应的.\n\n> 新增Machine 只是对于没有开发板时的妥协,便于开发人员在没有开发板时有一个板子的虚拟环境进行测试验证, 所以可以看到该新增Machine的模拟硬件同开发板基本上是一致的;\n> 对于虚拟化来说只有virt就可以了, virt上的feature也是最全的, 最适合跑guest os, 没有必要用其他Machine 跑guest os.\n\n# dtb 信息\n在qemu 中一般会以代码的形式写dtb的相关属性, 可以用 qemu 导出相应机型的dtb信息\n\n```shell\nqemu-system-riscv64 -machine virt,dumpdtb=virt.dtb -smp 1 -m 2G -nographic\ndtc virt.dtb > virt.dts\nqemu-system-riscv64 -machine sifive_u,dumpdtb=sifive_u.dtb -smp 2 -m 2G -nographic\ndtc sifive_u.dtb > sifive_u.dts\n```\n\n为了宏观的观察新增一个Machine 需要添加哪些部分, 可以先对比下 virt.dts 和 新增Machine 如sifive_u.dts的内容.\n\n对于dtb 中描述的硬件信息, qemu都需要模拟出来对应的硬件.\n\n## qemu 中 dtb 信息的创建\n\nqemu 对 libfdt 的接口做了二次封装，部分接口举例如下：\n\n1.  create_device_tree：初始化一颗设备树\n2.  qemu_fdt_setprop_cell：设置设备树的节点的属性，值为数字\n3.  qemu_fdt_setprop_string：设置设备树的节点的属性，值为字符串\n4.  qemu_fdt_add_subnode：添加一个子节点\n\nsifive_u.c 中 create_fdt 函数就是使用上述的接口构建了整个dtb.\n\n# memory 信息\n\n对于模拟的机型, 其中最重要的一块之一就是模拟的物理内存 GPA 的布局\n如sifive_u的\n```c\nstatic const MemMapEntry sifive_u_memmap[] = {\n    [SIFIVE_U_DEV_DEBUG] =    {        0x0,      0x100 },\n    [SIFIVE_U_DEV_MROM] =     {     0x1000,     0xf000 },\n    [SIFIVE_U_DEV_CLINT] =    {  0x2000000,    0x10000 },\n    [SIFIVE_U_DEV_L2CC] =     {  0x2010000,     0x1000 },\n    [SIFIVE_U_DEV_PDMA] =     {  0x3000000,   0x100000 },\n    [SIFIVE_U_DEV_L2LIM] =    {  0x8000000,  0x2000000 },\n    [SIFIVE_U_DEV_PLIC] =     {  0xc000000,  0x4000000 },\n    [SIFIVE_U_DEV_PRCI] =     { 0x10000000,     0x1000 },\n    [SIFIVE_U_DEV_UART0] =    { 0x10010000,     0x1000 },\n    [SIFIVE_U_DEV_UART1] =    { 0x10011000,     0x1000 },\n    [SIFIVE_U_DEV_PWM0] =     { 0x10020000,     0x1000 },\n    [SIFIVE_U_DEV_PWM1] =     { 0x10021000,     0x1000 },\n    [SIFIVE_U_DEV_QSPI0] =    { 0x10040000,     0x1000 },\n    [SIFIVE_U_DEV_QSPI2] =    { 0x10050000,     0x1000 },\n    [SIFIVE_U_DEV_GPIO] =     { 0x10060000,     0x1000 },\n    [SIFIVE_U_DEV_OTP] =      { 0x10070000,     0x1000 },\n    [SIFIVE_U_DEV_GEM] =      { 0x10090000,     0x2000 },\n    [SIFIVE_U_DEV_GEM_MGMT] = { 0x100a0000,     0x1000 },\n    [SIFIVE_U_DEV_DMC] =      { 0x100b0000,    0x10000 },\n    [SIFIVE_U_DEV_FLASH0] =   { 0x20000000, 0x10000000 },\n    [SIFIVE_U_DEV_DRAM] =     { 0x80000000,        0x0 },\n};\n```\n从这个简表上大概也能看出涉及到的硬件资源有哪些, 如clint plic qspi pwm otp uart 等等, 而对应的这些硬件资源都需要qemu 进行模拟.\n这些模拟的硬件资源的特性都应该跟硬件SPEC 上一致.\n\n# machine_init\n\n对应machine的class_init, 注册 MachineClass -> init, 如sifive_u 为 sifive_u_machine_init\n该函数由 `/hw/core/machine.c#machine_run_board_init` 调用\n该函数涉及到的初始化的硬件资源有 cpu ddr/ram qspi gpio spi sdcard, sdcard跟SPI2 相连, dtb 信息也是在该函数中调用 create_fdt 创建的\n\n以下均以sifive_u 的Machine展开介绍\n## cpu\n\nchild obj --  TYPE_RISCV_U_SOC\n`qdev_realize(DEVICE(&s->soc), NULL, &error_fatal);`\n\n涉及到的重要函数有 cpu的  类初始化 实例初始化 具现化函数, 以sifive_u 举例\nsifive_u_soc_class_init  sifive_u_soc_instance_init sifive_u_soc_realize\n\nsifive_u_soc_class_init的主要作用是指定具现化函数\n\n### instance_init\nsifive_u_soc_instance_init\n\n该函数除了定义cpu的一些属性外, 还引出了cpu关联的总线上的一些ip 硬件资源\n```c\nstatic void sifive_u_soc_instance_init(Object *obj) {\n    ... // 定义cpu的相关属性\n    object_initialize_child(obj, \"prci\", &s->prci, TYPE_SIFIVE_U_PRCI);\n    object_initialize_child(obj, \"otp\", &s->otp, TYPE_SIFIVE_U_OTP);\n    object_initialize_child(obj, \"gem\", &s->gem, TYPE_CADENCE_GEM);\n    object_initialize_child(obj, \"gpio\", &s->gpio, TYPE_SIFIVE_GPIO);\n    object_initialize_child(obj, \"pdma\", &s->dma, TYPE_SIFIVE_PDMA);\n    object_initialize_child(obj, \"spi0\", &s->spi0, TYPE_SIFIVE_SPI);\n    object_initialize_child(obj, \"spi2\", &s->spi2, TYPE_SIFIVE_SPI);\n    object_initialize_child(obj, \"pwm0\", &s->pwm[0], TYPE_SIFIVE_PWM);\n    object_initialize_child(obj, \"pwm1\", &s->pwm[1], TYPE_SIFIVE_PWM);\n}\n```\n\n这些硬件资源每一个都需要展开, 需要qemu 模拟对应的特性.\n这里抽一个简单的来看, 以otp 为例\n最重要的函数为其具现化函数 sifive_u_otp_realize\n\n对应总线上的ip, 最关键的是其 mmio的注册添加到io的memory region上, 当guest os  访问对应的物理地址时, 需要发生陷入, 最终陷入到qemu 中为该ip注册的mmio MemoryRegion上. \n\n此处, otp相关的mmio MemoryRegion的注册过程如下, 对应的陷入的读写函数为 `sifive_u_otp_read` `sifive_u_otp_write`\n```c\nstatic const MemoryRegionOps sifive_u_otp_ops = {\n    .read = sifive_u_otp_read,\n    .write = sifive_u_otp_write,\n    .endianness = DEVICE_NATIVE_ENDIAN,\n    .valid = {\n        .min_access_size = 4,\n        .max_access_size = 4\n    }\n};\n    memory_region_init_io(&s->mmio, OBJECT(dev), &sifive_u_otp_ops, s,\n                          TYPE_SIFIVE_U_OTP, SIFIVE_U_OTP_REG_SIZE);\n```\n\n在具现化函数中负责为该ip 进行具现化\n`sysbus_mmio_map(SYS_BUS_DEVICE(&s->otp), 0, memmap[SIFIVE_U_DEV_OTP].base);`\n其中 SIFIVE_U_DEV_OTP 的GPA 区域, 同硬件SPEC 上OTP的mmio 一致.\n`[SIFIVE_U_DEV_OTP] =      { 0x10070000,     0x1000 },`\n\n\n### realize\n对应 sifive_u 的 具现化函数\nsifive_u_soc_realize\n\n包含 dtb中cpu的设置\n这里设置了 u_cpus, 对应fu540, e_cpus 对应e24 单元\n调用 sysbus_realize 进行platform 总线的设置\n创建 \"riscv.sifive.u.l2lim\" 内存\nplic 初始化\nuart 初始化\nclint 初始化\nclint software interrupt 初始化\ncline timer interrupt 初始化\n各外设和ip的 mmio 设置\n\n\n\n\n\n\n\n\n","tags":["riscv"],"categories":["虚拟化","RISCV","qemu","移植"]},{"title":"cache 整理","url":"/2022/10/11/hxd_new/riscv调研/cache 整理/","content":"\n# l1/l2 cache 结构\n\n![image-20240416112815996](attachments/image-20240416112815996.png)\n\n\ncache控制器是如何判断数据是否在cache中命中呢？所以cache肯定是只能缓存主存中极小一部分数据。我们如何根据地址在有限大小的cache中查找数据呢？现在硬件采取的做法是对地址进行散列（可以理解成地址取模操作）\n\n![image-20240416112819790](attachments/image-20240416112819790.png)\n\n我们一共有8行cache line，cache line大小是8 Bytes。所以我们可以利用地址低3 bits（如上图地址蓝色部分）用来寻址8 bytes中某一字节，我们称这部分bit组合为offset。\n同理，8行cache line，为了覆盖所有行。我们需要3 bits（如上图地址黄色部分）查找某一行，这部分地址部分称之为index\n\ntag array和data array一一对应。每一个cache line都对应唯一一个tag，tag中保存的是整个地址位宽去掉index和offset使用的bit剩余部分（如上图地址绿色部分）。tag、index和offset三者组合就可以唯一确定一个地址了。因此，当我们根据地址中index位找到cache line后，取出当前cache line对应的tag，然后和地址中的tag进行比较，如果相等，这说明cache命中。如果不相等，说明当前cache line存储的是其他地址的数据，这就是cache缺失。\n\n\n\n## Directory Mapped\n\n![image-20240416112823674](attachments/image-20240416112823674.png)\n\n0x00、0x40 地址中index部分是一样的。因此，这2个地址对应的cache line是同一个。所以，当我们访问0x00地址时，cache会缺失\n, 然后数据会从主存中加载到cache中第0行cache line;\n当我们访问0x40地址时，依然索引到cache中第0行cache line，由于此时cache line中存储的是地址0x00地址对应的数据，所以此时依然会cache缺失。然后从主存中加载0x40地址数据到第一行cache line中\n\n访问0x40地址时，就会把0x00地址缓存的数据替换。这种现象叫做cache颠簸（cache thrashing）\n\n\n\n## 四路组相联\n\n![image-20240416112827437](attachments/image-20240416112827437.png)\n\n\n降低了cache颠簸的频率\n\n\n## VIPT\n\n我们可以使用虚拟地址对应的index位查找cache，与此同时(硬件上同时进行)将虚拟地址发到MMU转换成物理地址。当MMU转换完成，同时cache控制器也查找完成，此时比较cacheline对应的tag和物理地址tag域，以此判断是否命中cache。我们称这种高速缓存为VIPT(Virtually Indexed Physically Tagged)\n\n![image-20240416112831504](attachments/image-20240416112831504.png)\n\n\n## write back\n\n当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit (D)\n主存中的数据可能是未修改的数据，而修改的数据躺在cache中。**cache和主存的数据可能不一致**\n\n\n## self-modify l1 icache\n\n[self-modify](bookxnotepro://opennote/?nb={67c054d6-0f10-436d-9515-d9c218c6e4f5}&book=67d4ce80e395b4ba105f47a5182e6f63&page=835&x=170&y=315&id=1256&uuid=)\n\n![image-20240416112835829](attachments/image-20240416112835829.png)\n\n# cache coherence\n\n缓存一致性协议 MESI \n\nM : modified\nE : exclusive\nS : shared\nI : invalid\n\n协议在每一个 cache line 中维护一个两位的状态 “tag” ，这个 “tag” 在 cache line 的物理地址或者数据后\n\n![image-20240416112839686](attachments/image-20240416112839686.png)\n\n[MESI 演示](https://www.scss.tcd.ie/Jeremy.Jones/vivio/caches/MESI.htm)\n\n![image-20240416112847184](attachments/image-20240416112847184.png)\n\n![image-20240416112851863](attachments/image-20240416112851863.png)\n\n### Store Buffer / Invalidate Queue\n\n\nMESI解决了缓存一致性问题，但是它有一个性能弱点：\n处理器执行写操作时，必须等待其他处理器将其高速缓存中的相应副本数据删除, 并接收到这些处理器所回复的Invalidate Acknowledge/Read Response消息之后才能将数据写入高速缓存。\n\n![image-20240416112855625](attachments/image-20240416112855625.png)\n\n\n为了规避和减少这种等待造成的写操作的延迟(Latency), 引入了Store Buffer和Invalidate Queue。\n\nStore Buffer是处理器内部的一个容量比高速缓存器还小的私有高速存储部件，每个处理器都有其写存储器，并且一个处理器无法读取另外一个处理器上的Store Buffer中的内容。\n\n![image-20240416112858588](attachments/image-20240416112858588.png)\n\n处理器可以并不等待其他处理器返回Invalidate Acknowledge/Read Response消息而是继续执行其他指令。\n当一个处理器接收到其他处理器所回复的针对同一个缓存行的所有Invalidate Acknowledge消息的时候，该处理器会将Store Buffer中针对相应地址的写操作的结果写入相应的缓存行，此时写操作对于其他处理器来说才算完成。\n\n有了Store Buffer后，一个处理器在更新了一个变量之后，马上又读取了该变量的值，但是由于该处理器先前对该变量的更新结果可能仍然还停留在Store Buffer中，因此该变量相应的内存地址所对应的缓存行中仍存储着该变量的旧值。  \n因此处理器在执行读操作的时候会根据内存地址查询Store Buffer。  \n\n-   如果Store Buffer存在该数据，那么会直接将该数据作为结果返回。\n-   如果不存在，处理器会从高速缓存中读取数据。\n\n这种处理器直接从Store Buffer中读取数据来实现内存读操作的技术被称为存储转发(Store Buffer)\n\n\n#### Invalidate Queue\n\n引入Invalidate Queue之后，处理器在接收到Invalidate消息之后并不删除消息中指定地址的副本数据，而是将消息存入 Invalidate Queue之后就回复Invalidate Acknowledge消息，从而减少了执行写操作的处理器所需的等待问题。\n\n![image-20240416112903648](attachments/image-20240416112903648.png)\n\n#### 可见性\n\n**_可见性即一个线程对共享变量值的修改，能够及时被其他线程看到。_** 但是由于Store Buffer和Invalidate Queue的存在，使得数据可能不被其他线程及时看到。  \n\n1.  现代处理器在一些特定条件下(比如Store Buffer满，I/O指令被执行)会将Store Buffer中的内容写入高速缓存，但是这种写入并不一定是及时的，也就是说Store Buffer中的数据可能并没有刷新到高速缓存。\n2.  处理器在执行内存读取操作的时候如果没有根据Invalidate Queue中的内容将该处理器上的高速缓存中的相关副本数据删除，那么也可能导致该处理器读到的数据是过时的数据。  \n\n为了解决上面的两个问题，**首先要使写线程对共享变量所做的更新能够及时到达高速缓存，从而使该更新对其他处理器是同步的；\n其次，读线程所在的处理器要将其Invalidate Queue中的内容进行处理，保证读线程读到的数据是新的**。而底层系统会借助一类被称为内存屏障的特殊指令。  \n\n-   Store Barrier:可以使执行该指令的处理器冲刷其Store Buffer中的数据到缓存，从而保证某线程对共享变量所做的更新对读线程是可见的。\n-   Load Barrier：会根据Invalidate Queue中内容所指定的内存地址，将处理器上高速缓存中的状态标记为I，从而使该处理器后续执行这些地址的读操作时必须发送Read消息，从而保证了处理器读到的数据是新的。\n\n## CM - cluster 内部\n\nSetting the Cache Coherency Attributes for Default Memory Transfers [405](bookxnotepro://opennote/?nb={67c054d6-0f10-436d-9515-d9c218c6e4f5}&book=67d4ce80e395b4ba105f47a5182e6f63&page=404&x=310&y=650&id=1407&uuid=8043c28f729484e55b7879e23f676f65)\nCCA_Override_Value 覆盖默认的L2 配置.\n\n\n## cluster 间同步\n\n![image-20240416112907383](attachments/image-20240416112907383.png)\n\n","tags":["cache"],"categories":["cache"]},{"title":"visionfive2 启动相关参考","url":"/2022/10/11/hxd_new/riscv调研/vf2 启动相关参考/","content":"\n# 无卡启动\n\n## 配置tftpd\n\n```shell\nsudo apt install tftpd-hpa\nsudo vi /etc/default/tftpd-hpa   #编辑 /etc/default/tftpd-hpa\n# /etc/default/tftpd-hpa\n\nTFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/srv/tftp\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"-s\"\n\nsudo chmod 777 -R /srv/tftp\n```\n配置完后, tftp 使用的目录为 `/srv/tftp`\n\n将编出的 work/image.fit 拷贝到该文件夹中\n\n本机测试\n```shell\ntftp localhost\n> get image.fit\n```\n\n无错误代表没问题\n\n# 开发板 u-boot tftp 下载\n\n```shell\nStarFive # setenv ipaddr 192.168.xx.xx;setenv serverip 192.168.xx.xx\n```\n\nserverip 为 tftpd 即刚才配置好 tftpd 的ip\nipaddr 为 开发版的 ip\n\n开发板 u-boot 配置环境变量\n\n1. set enviroment parameter:\n```shell\nsetenv bootfile vmlinuz; setenv fileaddr a0000000; setenv fdtcontroladdr 0xffffffffffffffff;\n```\n2. upload image file to ddr:\n```shell\ntftpboot ${fileaddr} ${serverip}:image.fit;\n```\n> 如果下载不了, 执行下 `run bootcmd_dhcp` 再执行下  `tftpboot ${fileaddr} ${serverip}:image.fit`\n\n3. load and excute:\n```shell\nbootm start ${fileaddr};bootm loados ${fileaddr};run chipa_set_linux;booti 0x40200000 0x46100000:${filesize} 0x46000000\n```\n4. login\n```shell\nbuildroot login:root\nPassword: starfive\n```\n\n\n\n# Initialize SPI flash:\n\n```shell\nStarFive # sf probe\n```\n\n# Update SPL binary\n```shell\nStarFive # tftpboot 0xa0000000 ${serverip}:u-boot-spl.bin.normal.out\nStarFive # sf update 0xa0000000 0x0 $filesize\n```\n\n# Update U-Boot binary\n\n```shell\nStarFive # tftpboot 0xa0000000 ${serverip}:visionfive2_fw_payload.img\nStarFive # sf update 0xa0000000 0x100000 $filesize\n```","tags":["riscv"],"categories":["u-boot","visionfive2"]},{"title":"riscv 虚拟化中断相关","url":"/2022/10/11/hxd_new/riscv调研/虚拟化/riscv 虚拟化中断相关/","content":"\n#### Hypervisor Status Register (hstatus)\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221124162340.png)\n\nWhen VTSR=1, an attempt in VS-mode to execute SRET raises a virtual instruction exception. \nWhen VTW=1 (and assuming `mstatus`.TW=0), an attempt in VS-mode to execute WFI raises a virtual instruction exception if the WFI does not complete within an implementation-specific, bounded time limit.\nWhen VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or to access CSR `satp` raises a virtual instruction exception.\n\nThe VGEIN (Virtual Guest External Interrupt Number) field selects a guest external interrupt source for VS-level external interrupts. VGEIN is a **WLRL** field that must be able to hold values between zero and the maximum guest external interrupt number (known as GEILEN), inclusive. \nWhen VGEIN=0, no guest external interrupt source is selected for VS-level external interrupts. GEILEN may be zero, in which case VGEIN may be hardwired to zero. \nGuest external interrupts are explained in Section [1.2.4](https://five-embeddev.com/riscv-isa-manual/latest/hypervisor.html#sec:hgeinterruptregs), and the use of VGEIN is covered further in Section [1.2.3](https://five-embeddev.com/riscv-isa-manual/latest/hypervisor.html#sec:hinterruptregs).\n\nField HU (Hypervisor User mode) controls whether the virtual-machine load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode. When HU=1, these instructions can be executed in U-mode the same as in HS-mode. When HU=0, all hypervisor instructions cause an illegal instruction trap in U-mode.\n\n#### hip & hie\nRegisters `hip` and `hie` are HSXLEN-bit read/write registers that supplement HS-level’s `sip` and `sie` respectively. The `hip` register indicates pending VS-level and hypervisor-specific interrupts, while `hie` contains enable bits for the same interrupts. As with `sip` and `sie`, an interrupt _i_ will be taken in HS-mode if bit _i_ is set in both `hip` and `hie`, and if supervisor-level interrupts are globally enabled.\n\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221124162341.png)\n\nBits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level).\nSGEIP is read-only in `hip`, and is 1 if and only if the bitwise logical-AND of CSRs `hgeip` and `hgeie` is nonzero in any bit.\n\nBits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts. VSEIP is read-only in `hip`, and is the logical-OR of these interrupt sources:\n- bit VSEIP of `hvip`;\n- bit of `hgeip` selected by `hstatus`.VGEIN\n- any other platform-specific external interrupt signal directed to VS-level.\n\nBits `hip`.VSTIP and `hie`.VSTIE are the interrupt-pending and interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only in `hip`, and is the logical-OR of:\n- `hvip`.VSTIP\n- any other platform-specific timer interrupt signal directed to VS-level.\n\nBits `hip`.VSSIP and `hie`.VSSIE are the interrupt-pending and interrupt-enable bits for VS-level software interrupts. VSSIP in `hip` is an alias (writable) of the same bit in `hvip`.\n\n#### Hypervisor Guest External Interrupt Registers (`hgeip` and `hgeie`)\n\nhgeip indicates pending guest external interrupts for this hart.\nhgeie contains enable bits for the guest external interrupts at this hart.\nGuest external interrupts represent interrupts directed to individual virtual machines at VS-level.\n只有在设备直通场景下使用\n\ninterrupts from the device are intended for a specific virtual machine. Each bit of `hgeip` summarizes _all_ pending interrupts directed to one virtual hart, as collected and reported by an interrupt controller. To distinguish specific pending interrupts from multiple devices, software must query the interrupt controller.\n\nSupport for guest external interrupts requires an interrupt controller that can collect virtual-machine-directed interrupts separately from other interrupts.\n\n中断控制器需要收集virtual guest external interrupt, 和 物理cpu的external interrupt 区分开, guest 只能接收virtual external guest interrupt\n\nThe number of bits implemented in `hgeip` and `hgeie` for guest external interrupts is GEILEN\nbits GEILEN:1 shall be writable in `hgeie`, and all other bit positions shall be hardwired to zeros in both `hgeip` and `hgeie`.\n\nGuest external interrupt number _i_ at one physical hart is typically expected not to be the same as guest external interrupt _i_ at any other hart. \nFor any one physical hart, the maximum number of virtual harts that may directly receive guest external interrupts is limited by GEILEN.\n\nA hypervisor is always free to _emulate_ devices for any number of virtual harts without being limited by GEILEN. **Only direct pass-through (direct assignment) of interrupts is affected by the GEILEN limit, and the limit is on the number of virtual harts receiving such interrupts, not the number of distinct interrupts received.** The number of distinct interrupts a single virtual hart may receive                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            is determined by the interrupt controller.\n\nThe enable bits in `hgeie` do not affect the VS-level external interrupt signal selected from `hgeip` by `hstatus`.VGEIN.\n\n#### vsip & vsie\nhideleg not zero(bit 10/6/2 不为0时)\n- `vsip`.SEIP and `vsie`.SEIE are aliases of `hip`.VSEIP and `hie`.VSEIE.\n- `vsip`.STIP and `vsie`.STIE are aliases of `hip`.VSTIP and `hie`.VSTIE.\n- `vsip`.SSIP and `vsie`.SSIE are aliases of `hip`.VSSIP and `hie`.VSSIE.\n\n#### 小结\n\nhideleg 开启时(bit 10/6/2 不为0时)\n- vsip.SEIP = hip.VSEIP  vsip.STIP = hip.VSTIP vsip.SSIP = hip.VSSIP\n\t- VSEIP is read-only in `hip`, and is the logical-OR of these interrupt sources:\n\t\t- bit VSEIP of `hvip`;\n\t\t- bit of `hgeip` selected by `hstatus`.VGEIN\n\t\t- any other platform-specific external interrupt signal directed to VS-level.\n\t- VSTIP is read-only in `hip`, and is the logical-OR of:\n\t\t- `hvip`.VSTIP\n\t\t- any other platform-specific timer interrupt signal directed to VS-level.\n\t- VSSIP in `hip` is an alias (writable) of the same bit in `hvip`. \n\t\t- 即 vsip.SSIP = hip.VSSIP = hvip.VSSIP\n- vsie.SEIE = hie.VSEIE  vsie.STIE = hie.VSTIE vsie.SSIE = hie.SSIE\n\n真正影响guest os的是vsip , guest os 运行时处于V=1 mode, vsip被替换为sip, \n- vsip software 中断来自于hvip (来自于HS hypervisor), 或者guest os 自己.\n- vsip timer 中断来自于hvip (来自于 HS hypervisor), 或guest os 自己, 或 platform-specific timer interrupt signal directed to VS-level\n- vsip guest external 中断来自于hvip (来自于HS hypervisor), 或hstatus.VGEIN -> hgeip 或 any other platform-specific external interrupt signal directed to VS-level\n\n下面这两句应该怎么理解?\n- Bits `hip`.SGEIP and `hie`.SGEIE are the interrupt-pending and interrupt-enable bits for guest external interrupts at supervisor level (HS-level). \n- Bits `hip`.VSEIP and `hie`.VSEIE are the interrupt-pending and interrupt-enable bits for VS-level external interrupts.\n\n直译: \nSGEIP 和 SGEIE 是给HS 用的, 重点看 SGEIP, 这个是hgeip & hgeie and的结果, 代表的有guest external 中断待处理.\nhip.VSEIP 和 hie.VSEIE 是给VS 用的, 这个好理解, 这两个直接反应到vsip vsie的相应bit上了.\n\n结合这句:\nif GEILEN is nonzero, bits GEILEN:1 shall be writable in `hgeie`\nOnly direct pass-through (direct assignment) of interrupts is affected by the GEILEN limit, and the limit is on the number of virtual harts receiving such interrupts, not the number of distinct interrupts received\n\n背景:\n不同的vcpu可以运行不同guest os.\n一个物理cpu 有三套寄存器 \n\n- v 开头的 vsip vsie 等\n- h 开头的 hvip hip hie hgeie hgeip 等\n- s 开头的 sip sie 等\n当V=0 => V=1 时, v开头的寄存器会替换成 s 开头的寄存器, 此时变成vcpu的执行环境\nV=1 时, 只能访问 s 开头的寄存器.\n\n大概猜测, 在设备直通场景时, 0 < hstatus.VGEIN <= GEILEN(物理cpu上托管的vcpu的数量), \n\n需要HS vmm 对 hgeie hstatus操作, 对应物理cpu上托管的vcpu\n如当前物理cpu上托管了8个vcpu, 正在运行的是第2个vcpu\n- 对 hstatus.VGEIN 设置为2\n- 对 hgeie 的前8个bit 置1, 表示物理cpu 管了8个ready vcpu 的中断状态, 这8个vcpu都要处理guest external interrupt.\n\n在前面前提下, 硬件需要将hip.VSEIP 与 hgeip的状态区分.\n前面hip.VSEIP 的来源处说的比较模糊:  \"**bit of `hgeip` selected by `hstatus`.VGEIN**\"\n\n不太好理解, 大概猜测:\n\n在设备直通场景(设置了hstatus.VGEIN时), 中断控制器需要判断给哪个vcpu, 导致的直接结果就是要设置hgeip 的哪个bit, 同时硬件应该将 hip.VSEIP 置为hgeip 与 hstatus.VGEIN 逻辑与 的结果. 而hip.SGEIP 置为 hgeip & hgeie 逻辑与的结果.\n\n假如中断控制器要发给第三个vcpu, 就需要将hgeip 的第三个bit 置1\n- 情景1 : 假设物理cpu的状态 V=1 mode 正在运行第二个vcpu, hstatus.VGEIN = 2:\n\t此时因为正在运行的是第二个vcpu, hstatus.VGEIN=2, 则hip.VSEIP = 0, 而 hip.SGEIP 为 1, 因为vsip.SEIP->sip.SEIP = hip.VSEIP, 此时vsip.SEIP 没有置位(此时假设只有外部中断, SSIP STIP 都是0), 此时硬件根据vsip penging为无信号, 而hip.SGEIP 有信号, 不能将中断委托给vcpu, 而应将中断给到 host os HS-mode的vmm.\n\t\n\t从vcpu陷入到hypervisor vmm 后, vmm 需要check hip.SGEIP & hie SGEIE(或hip&hie), 有待处理的虚拟外部中断, 进而查hgeip, 查到是第三个vcpu的, 则切换到第三个vcpu 运行, 切换前将hstatus.VGEIN 设置为3. 此时vsip.SEIP = hip.VSEIP 会被置1(hgeip 逻辑与 hstatus.VGEIN) , 第三个vcpu 陷入V=1 mode, 处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\n- 情景2: 假设物理cpu的状态 V=0 mode, 处于host下\n\t中断由host os接收\n\thypervisor vmm 需要check hip.SGEIP & hie SGEIE (或hip&hie), 有待处理的虚拟外部中断, 进而查hgeip, 查到是第三个vcpu的, 则切换到第三个vcpu 运行, 切换前将hstatus.VGEIN 设置为3. 此时vsip.SEIP = hip.VSEIP 会被置1(hgeip 逻辑与 hstatus.VGEIN) , 第三个vcpu 陷入V=1 mode, 处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\n- 情景3: 假设物理cpu的状态 V=1 mode 正在运行第三个vcpu, hstatus.VGEIN = 3:\n    hgeip 逻辑与 hstatus.VGEIN 不为0, hip.VSEIP 置1.\n\t因为vsip.SEIP->sip.SEIP = hip.VSEIP, 此时vsip.SEIP 置位, 此时硬件根据vsip penging有信号, hip.SGEIP 有信号, 应将中断给到 vcpu guest os.\n\tvcpu处理虚拟外部中断. 如guest os kernel 将sie.SEIE 置过位, 则guest os 会处理external 中断(10号guest external中断会转换成9 号external 中断), guest os 需要查询中断控制器, 判断外部中断是谁的, 该由谁的中断处理函数处理. 处理完后将中断控制器的pending 清0(该操作导致中断控制器把hgeip清0), 返回到 hypervisor vmm 后, vsip.SEIP = hip.VSEIP 也会因hgeip 而清0.\n\t\n\n\n#### 备注\nhgeip read-only csr, 由硬件操作\nhgeie rw csr, 由软件操作\nhip.SGEIP read-only bit, 由硬件操作\nhip.VSEIP read-only bit, 由硬件操作\nsip.SEIP read-only bit, 由硬件操作, typically through a platform-specific interrupt controller.\n\n# riscv 直通场景 AIA IMSIC\n\n![riscv 直通场景](arm%20虚拟化中断.md#riscv%20直通场景)\n\n## IMSIC\n\n### hvictl\n\n> Hypervisor Virtual Interrupt Control\n\n- 触发VS major 中断(hvien 和 hvip 不支持的)\n- 支持配置VS-mode 中断优先级( hviprio1/hviprio2 之外的)\n- 模拟一个外部中断控制器, 没有使用IMSIC的 guest interrupt file. 同时支持为外部中断和virtual hart的major interrupts 配置中断优先级\n\n### hvien\n\nguest 不需要配置major 中断的优先级, 除了硬件自定义实现的那些.\nhvien 保留了低12位(ro 符合SPEC规范的), hvien 和 hvip 配合来表明注入对应的中断, 除了SPEC 规范的低12位外, 低12位由SPEC 定义, 如VSEIP/VSTIP/VSSIP. 而13:63 位用来实现硬件自定义实现的中断.\n\nhideleg 开启后, vsip 的位等同于 sip的位\n\n- hideleg 的某 bit位为0时, 而hvien的对应bit位为1, 此时vsip 的该bit位等同于hvip的该bit位\n- hideleg 的某 bit位为0时, 而hvien的对应bit位为0, 此时vsip 的该bit位是ro的, \n\n![](attachments/Pasted%20image%2020230515151813.png)\n\n","tags":["riscv"],"categories":["虚拟化","RISCV","中断"]},{"title":"riscv imsic 相关","url":"/2022/10/11/hxd_new/riscv调研/虚拟化/riscv imsic 相关/","content":"\n参考文档\nDocumentation/devicetree/bindings/interrupt-controller/riscv,imsics.yaml\n\n# dts 信息\n\nex:\n提供了两个interrupt file M-mode 和 S-mode的.\n\n```c\n    imsic_mlevel: interrupt-controller@24000000 {\n      compatible = \"riscv,qemu-imsics\", \"riscv,imsics\";\n      interrupts-extended = <&cpu1_intc 11>,\n                            <&cpu2_intc 11>,\n                            <&cpu3_intc 11>,\n                            <&cpu4_intc 11>;\n      reg = <0x28000000 0x4000>;\n      interrupt-controller;\n      #interrupt-cells = <0>;\n      msi-controller;\n      riscv,num-ids = <127>;\n    };\n\n    imsic_slevel: interrupt-controller@28000000 {\n      compatible = \"riscv,qemu-imsics\", \"riscv,imsics\";\n      interrupts-extended = <&cpu1_intc 9>,\n                            <&cpu2_intc 9>,\n                            <&cpu3_intc 9>,\n                            <&cpu4_intc 9>;\n      reg = <0x28000000 0x2000>, /* Group0 IMSICs */\n            <0x29000000 0x2000>; /* Group1 IMSICs */\n      interrupt-controller;\n      #interrupt-cells = <0>;\n      msi-controller;\n      riscv,num-ids = <127>;\n      riscv,group-index-bits = <1>;\n      riscv,group-index-shift = <24>;\n    };\n```\n\n下面对上述dts的相关属性做一个大概的介绍\n\n1. interrupts-extended\n   对应cpu1-4, 每个cpu都有这两个interrupt file M-mode和S-mode的\n   M的对应中断位为11,  代表 Machine external interrupt\n   S的对应中断位为9, 代表 Supervisor external interrupt\n2. riscv,num-ids\n   Number of interrupt identities supported by IMSIC interrupt file.\n   外部中断数量, 反映到eip和eie中, 最小63 最大 2047\n3. riscv,group-index-bits\n   Number of group index bits in the MSI target address. When not specified it is assumed to be 0.\n   总的group index bits\n4. riscv,group-index-shift\n   The least significant bit position of the group index bits in the MSI target address. When not specified it is assumed to be 24.\n5. reg\n   Base address of each IMSIC group.\n   关于MSI target address:\n   从第24 bit 开始, 上述group-index-bits 表示在Group Index中总共有几个bit 被使用\n   riscv,group-index-shift 表示Group Index中当前interrupt file 占位开始的那个bit位, 如其占了两个bit位 26-27, shift表示最开始的bit位 26.\n\n```c\n  XLEN-1           >=24                                 12    0\n  |                  |                                  |     |\n  -------------------------------------------------------------\n  |xxxxxx|Group Index|xxxxxxxxxxx|HART Index|Guest Index|  0  |\n  -------------------------------------------------------------\n```\n\n## guest os相关\n\nguest external interrupt 相关的dts信息\n\n1. riscv,num-guest-ids\n   Number of interrupt identities are supported by IMSIC guest interrupt\n   file. When not specified it is assumed to be same as specified by the\n   riscv,num-ids property.\n   guest external 硬件中断号 最小63 最大2047\n2. riscv,hart-index-bits\n   Number of HART index bits in the MSI target address. When not\n   specified it is estimated based on the interrupts-extended property.\n   MSI target address 中 Hart Index 总共使用了几个bit位.\n   最小0 最大 15\n3. riscv,guest-index-bits\n   Number of HART index bits in the MSI target address. When not\n   specified it is estimated based on the interrupts-extended property.\n   MSI target address 中 Guest Index 总共使用了几个bit位.\n   最小0 最大 7\n\n下面开始大概分析 imsic 的代码\n\n# 代码部分\n\n## imsic_init\n\ndts 相关封装的接口\n\n```c\n\tstruct imsic_fwnode_ops ops = {\n\t\t.nr_parent_irq = imsic_dt_nr_parent_irq,\n\t\t.parent_hartid = imsic_dt_parent_hartid,\n\t\t.nr_mmio = imsic_dt_nr_mmio,\n\t\t.mmio_to_resource = imsic_mmio_to_resource,\n\t\t.mmio_map = imsic_dt_mmio_map,\n\t\t.read_u32 = imsic_dt_read_u32,\n\t\t.read_bool = imsic_dt_read_bool,\n\t};\n```\n\n```erlang\n-+ imsic_init(struct imsic_fwnode_ops *fwops, struct fwnode_handle *fwnode, void *fwopaque)\n \\ -  check riscv_isa_extension_available(NULL, SxAIA) \"RISCV_ISA_EXT_SxAIA -> RISCV_ISA_EXT_SSAIA ?\"\n | -  priv = kzalloc(sizeof(*priv), GFP_KERNEL);\n | -  global = &priv->global;\n | -+ nr_parent_irqs = fwops->nr_parent_irq(fwnode, fwopaque); \n    \\ -+ imsic_dt_nr_parent_irq(fwnode, fwopaque)\n       \\ -  of_irq_count(to_of_node(fwnode));  \"一般会读到 dts的 interrupt-extended 属性中, 代表cpu的中断域\n                                                如前面dts中一共有S-mode 和 M-mode的, 每个有1-4 cpu的中断域, 这里的值 nr_parent_irqs 即为8\" \n | -  rc = fwops->read_u32(fwnode, fwopaque, \"riscv,guest-index-bits\", &global->guest_index_bits);\n         \"调用 imsic_dt_read_u32 读 riscv,guest-index-bits 读出 Msi target address 中 Guest Index 总共使用了几个bit位, \n         结果放入 priv->global->guest_index_bits\"    \n | -  rc = fwops->read_u32(fwnode, fwopaque, \"riscv,hart-index-bits\",  &global->hart_index_bits);                                    \n         \"读取 dts riscv,hart-index-bits , 读出 Msi target address 中 Hart Index 总共使用了几个bit位, 结果放入priv->global->hart_index_bits\"\n | -  rc = fwops->read_u32(fwnode, fwopaque, \"riscv,group-index-bits\", &global->group_index_bits);                       \n | -  rc = fwops->read_u32(fwnode, fwopaque, \"riscv,group-index-shift\", &global->group_index_shift);\n | -  rc = fwops->read_u32(fwnode, fwopaque, \"riscv,num-ids\", &global->nr_ids); \"多少个hwirq\"\n | -  fwops->read_u32(fwnode, fwopaque, \"riscv,num-guest-ids\", &global->nr_guest_ids) \"多少个guest 可以使用的hwirq\"\n | -+ fwops->mmio_to_resource(fwnode, fwopaque, 0, &res);\n    \\ -+ imsic_mmio_to_resource(fwnode, fwopaque, 0, &res); \"Compute base address\"\n       \\ -  of_address_to_resource(to_of_node(fwnode), index, res); \"在设备树中找到第一个\"reg\"，并将解析到的信息填充在\"res\"结构体里\"\n | -  global->base_addr = res.start;\n | -  global->base_addr &= ~(BIT(global->guest_index_bits + global->hart_index_bits + IMSIC_MMIO_PAGE_SHIFT) - 1);    \n                             \"Msi target address 中 屏蔽低 \"guest bit + hart bit +12\" 位\"\n | -  global->base_addr &= ~((BIT(global->group_index_bits) - 1) << global->group_index_shift);\n                             \"Msi target address 中 屏蔽 其他group 的bit 位, 剩下的才是本group 使用的bit位\"\n                             \"这个地方结合前面的dts信息, 这个做完之后应该就是0x28000000\"\n | -+ priv->num_mmios = fwops->nr_mmio(fwnode, fwopaque);\n    \\ -+ imsic_dt_nr_mmio(fwnode, fwopaque) \"Find number of MMIO register sets\"\n       \\ -+ while (!of_address_to_resource(to_of_node(fwnode), ret, &res))  \"依次查剩下的reg , 结果放到 res中\"\n          \\ -  ret++\n       | return ret   \"即dts中 总共几个 reg 信息\"\n | -  priv->mmios = kcalloc(priv->num_mmios, sizeof(*mmio), GFP_KERNEL); \"分配mmios 数组\"\n | -+ for i in priv->num_mmios \"i从0 开始\"\n    \\ -  mmio = &priv->mmios[i];\n    | -  rc = fwops->mmio_to_resource(fwnode, fwopaque, i, &res); \"从0 开始, 因此第一个仍是 M-mode的cpu的中断域\"\n    | -  mmio->pa = res.start;\n    | -  mmio->size = res.end - res.start + 1;   \"这个是dts中 reg 的第二个字段 决定了size\"\n    | -  mmio->va = fwops->mmio_map(fwnode, fwopaque, i);  \"为pa 建立页表映射, 返回va\"\n | -+ imsic_ids_init(priv) \"为hwirq 初始化 bitmap 位图\"\n    \\ -  priv->ids_used_bimap = kcalloc(BITS_TO_LONGS(global->nr_ids + 1), sizeof(unsigned long), GFP_KERNEL); \n    | -  priv->ids_target_cpu = kcalloc(global->nr_ids + 1, sizeof(unsigned int), GFP_KERNEL);\n    | -+ for (i = 0; i <= global->nr_ids; i++)\n       \\ -  priv->ids_target_cpu[i] = UINT_MAX;  \\\n                   \"这个ids_target_cpu数组维护了每个hwirq 同 cpuid 的映射关系, 即该hwirq 会发送到哪个hart上, 设置hwirq的亲和性时会用到\" \n    | -  bitmap_set(priv->ids_used_bimap, 0, 1); \"清空hwirq的 used bitmap\"             \n | -+ for (i = 0; i < nr_parent_irqs; i++)\n    \\ -  rc = fwops->parent_hartid(fwnode, fwopaque, i, &hartid); \"找到 对应的hartid, 这里举例的一个8个, 每个hart 有M/S 两个\"\n    | -  cpu = riscv_hartid_to_cpuid(hartid); \"hartid -> cpuid\"\n    | -  reloff = i * BIT(global->guest_index_bits) * IMSIC_MMIO_PAGE_SZ;    \"相对于 mmio base_addr 的偏移\"\n                                        \"这里将guest_index_bits 计入了, 代表每个hart的mmio 需要包含 guest interrupt file的地址空间\"\n    | -  handler = per_cpu_ptr(&imsic_handlers, cpu); \"每个cpu 一个 handler 结构\"\n    | -  handler->local.msi_pa = mmio->pa + reloff;  \"msi_pa 加上该hart mmio的 相对于 mmio_base_addr 的偏移量\"\n    | -  handler->local.msi_va = mmio->va + reloff;  \"msi_va 同上\"\n | -  domain = irq_find_matching_fwnode(riscv_get_intc_hwnode(),  DOMAIN_BUS_ANY); \"cpu-intc\"\n | -  imsic_parent_irq = irq_create_mapping(domain, RV_IRQ_EXT); \"IRQ_S_EXT 9 为S-mode 外部中断, 建立hwirq 同 linux irq的映射关系\"\n | -  irq_set_chained_handler(imsic_parent_irq, imsic_handle_irq); \n              \"cpu 来了 9号中断 S external interrupt 后, 由 imsic_handle_irq 处理函数进行处理该中断\"\n | -  imsic_ipi_domain_init(priv); \"ipi_domain\"\n | -  imsic_irq_domains_init(priv, fwnode);     \"/* Initialize IRQ and MSI domains */\"      \n | -+ cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"irqchip/riscv/imsic:starting\", imsic_starting_cpu, NULL); \n         \"注册 cpu startup 为  imsic_starting_cpu(), cpu online 时回调 startup \"     \n    \\ -+ imsic_starting_cpu(cpu)\n       \\ -  enable_percpu_irq(imsic_parent_irq, irq_get_trigger_type(imsic_parent_irq)); \n               \"软件层 所有cpu 打开 映射了 hwirq为 IRQ_S_EXT的 linux irq 的中断\"\n    | -+ imsic_ipi_enable(priv); \"\"\n       \\ -+ __imsic_id_enable(priv->ipi_id);  \"imsci 寄存器打开 ipi 中断\"\n          \\ -+ __imsic_eix_update((priv->ipi_id), 1, false, true) \n                       \"让iselect 选择对应的 eip/eie 寄存器, 然后选择置1或置0 来开关中断/开关pending\"\n             \\ -+ imsic_csr_set(isel, ireg); \n                \\ -  csr_write(CSR_ISELECT, isel)  \"更新 siselct csr\" \n                | -  csr_set(CSR_IREG, ireg)       \"更新 sireg csr\"     \n```\n\n比较重要的数据:\nglobal->base_addr\nhandler->local.msi_pa / handler->local.msi_va\n\n## imsic_handle_irq\n\nS external interrupt 中断来了之后, 会由 imsic_handle_irq 函数进行处理, 简单看一下外部中断处理的流程\n\n```erlang\n-+ imsic_handle_irq(struct irq_desc *desc)\n \\ -  imsic_handler *handler = this_cpu_ptr(&imsic_handlers); \"找到前面为每个hart 创建的handler \"\n | -  irq_chip *chip = irq_desc_get_chip(desc); \"这个芯片注册的irq的相关 ops\"\n | -  chained_irq_enter(chip, desc); \"在级联的中断处理函数中，调用`chained_irq_enter`进入中断级联处理\"\n | -+ while ((hwirq = csr_swap(CSR_TOPEI, 0)) \"读 stopei csr, 该csr 为 imsic 专属, 其 27:16 代表hwirq\"\n        \"这个地方为什么用while, 猜测可能一次有多个外部中断, 每次对stopei 清0后, 中断控制器会为其设置次一个优先级的中断标识, stopei csr 是eipx & eiex 联合选择的结果, 从高优先级->低优先级 依次选择供给stopei 相应的中断标识\"\n    \\ -  hwirq = hwirq >> TOPEI_ID_SHIFT;\n    | -  generic_handle_domain_irq(priv->base_domain, hwirq); \n        \"找到 外设驱动 request_irq 为该hwirq 注册的irq_handler 进行中断处理\" \n```\n\n还是大体上是这个结构, 这个上面也有loop, 代表需要多次处理stopei, 从高优先级->低优先级依次处理完本次来的所有的S-mode的外部中断.\n![](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221208201710.png)\n\n## chip imsic 相关hook\n\n```c\nstatic struct irq_chip imsic_irq_base_chip = {\n\t.name\t\t\t= \"RISC-V IMSIC-BASE\",\n\t.irq_mask\t\t= imsic_irq_mask,\n\t.irq_unmask\t\t= imsic_irq_unmask,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= imsic_irq_set_affinity,\n#endif\n\t.irq_compose_msi_msg\t= imsic_irq_compose_msi_msg,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE |\n\t\t\t\t  IRQCHIP_MASK_ON_SUSPEND,\n};\n```\n\n### imsic_irq_set_affinity\n\n在外设驱动注册hwirq 中断时, 会走到 irq_set_affinity, 进而调用chip的 irq_set_affinity 钩子.\n对于imsic来说, 调用 imsic_irq_set_affinity 函数设置cpu亲和性, 即该外部中断由哪个cpu进行处理\n简单分析下这个函数\n\n```er\n-+ imsic_irq_set_affinity(struct irq_data *d, const struct cpumask *mask_val, bool force)\n       \"与cpuid 相关的在 mask_val 参数中\"\n \\ -+ imsic_get_cpu(priv, mask_val, force, &target_cpu);\n    \\ -  cpumask_and(&amask, &priv->lmask, mask_val);\n    | -|+ if force\n        \\ -  cpu = cpumask_first(&amask); \"直接从 cpu_mask mask_val中选出对应的cpu\"\n    | -|+ if !force  \n        \\ -  cpu = cpumask_any_and(&amask, cpu_online_mask); \"优先从上线的cpu中再结合 cpu_mask 选出对应的cpu\"\n      \n    | -  *out_target_cpu = cpu;\n | -+ imsic_id_set_target(priv, d->hwirq, target_cpu); \"? 并没有硬件寄存器相关的操作\"\n    \\ -  priv->ids_target_cpu[id] = target_cpu; \"? \"\n```\n\n说明与hwirq 开启需要设置的csr 操作并未在这个函数中\n\n1. of_irq_get -> irq_create_of_mapping -> irq_domain_alloc_irqs -> irq_domain_alloc_irqs_hierarchy -> domain->ops->alloc(domain, irq_base, nr_irqs, arg)\n2. request_irq -> request_threaded_irq -> irq_startup ->  `__irq_startup` -> irq_enable -> unmask_irq(desc) -> chip->irq_unmask(&desc->irq_data);\n\n.alloc = imsic_irq_domain_alloc\n\n```c\nstatic const struct irq_domain_ops imsic_base_domain_ops = {\n\t.alloc\t\t= imsic_irq_domain_alloc,\n\t.free\t\t= imsic_irq_domain_free,\n};\n```\n\n相关堆栈\n\n```erlang\n#1  0xffffffff8006a134 in irq_domain_alloc_irqs_hierarchy (arg=0xff2000000060b728, nr_irqs=1, irq_base=2, domain=0xff6000007fe0c800) at ../kernel/irq/irqdomain.c:1426\n#2  __irq_domain_alloc_irqs (domain=domain@entry=0xff6000007fe0c800, irq_base=irq_base@entry=-1, nr_irqs=nr_irqs@entry=1, node=node@entry=-1, arg=arg@entry=0xff2000000060b728, realloc=realloc@entry=false, affinity=affinity@entry=0x0) at ../kernel/irq/irqdomain.c:1482\n#3  0xffffffff8006a5d0 in irq_domain_alloc_irqs (arg=0xff2000000060b728, node=-1, nr_irqs=1, domain=0xff6000007fe0c800) at ../include/linux/irqdomain.h:516\n#4  irq_create_fwspec_mapping (fwspec=fwspec@entry=0xff2000000060b728) at ../kernel/irq/irqdomain.c:825\n#5  0xffffffff8006a6ee in irq_create_of_mapping (irq_data=irq_data@entry=0xff2000000060b7a8) at ../kernel/irq/irqdomain.c:858\n#6  0xffffffff80515156 in of_irq_get (dev=dev@entry=0xff600000bfdf5200, index=index@entry=0) at ../drivers/of/irq.c:444\n```\n\nunmask_irq 相关堆栈\n\n```erlang\n#0  plic_irq_unmask (d=0xff6000007fefec20) at ../drivers/irqchip/irq-sifive-plic.c:122\n#1  0xffffffff80067d16 in unmask_irq (desc=<optimized out>) at ../kernel/irq/chip.c:435\n#2  irq_enable (desc=desc@entry=0xff6000007fefec00) at ../kernel/irq/chip.c:342\n#3  0xffffffff80067d72 in __irq_startup (desc=desc@entry=0xff6000007fefec00) at ../kernel/irq/chip.c:246\n#4  0xffffffff80067e4e in irq_startup (desc=desc@entry=0xff6000007fefec00, resend=resend@entry=true, force=force@entry=false) at ../kernel/irq/chip.c:267\n#5  0xffffffff80065a8a in __setup_irq (irq=irq@entry=1, desc=desc@entry=0xff6000007fefec00, new=new@entry=0xff6000007ff24f80) at ../kernel/irq/manage.c:1777\n#6  0xffffffff80065d7c in request_threaded_irq (irq=<optimized out>, handler=handler@entry=0xffffffff80386ca6 <vp_interrupt>, thread_fn=thread_fn@entry=0x0, irqflags=irqflags@entry=128, devname=0xff60000080172858 \"virtio2\", dev_id=dev_id@entry=0xff6000008015b800) at ../kernel/irq/manage.c:2206\n#7  0xffffffff80387540 in request_irq (dev=0xff6000008015b800, name=<optimized out>, flags=128, handler=<optimized out>, irq=<optimized out>) at ../include/linux/interrupt.h:168\n```\n\n### imsic_irq_domain_alloc\n\n```erlang\n-+ imsic_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t  unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs,\n\t\t\t\t  void *args)\n \\ -  imsic_priv *priv = domain->host_data;\t\t\t\t  \n | -  imsic_get_cpu(priv, &priv->lmask, false, &cpu); \"获取\"\n | -  imsic_cpu_page_phys(cpu, 0, &msi_addr);\n | -  hwirq = imsic_ids_alloc(priv, priv->global.nr_ids, get_count_order(nr_irqs));\n | -  imsic_id_set_target(priv, hwirq + i, cpu);\n```\n\n### unmask_irq -> imsic_irq_unmask\n\n```erlang\n-+ imsic_irq_unmask(struct irq_data *d)\n \\ -+ imsic_id_enable(irq_data_get_irq_chip_data(d), d->hwirq);\n    \\ -  bitmap_set(priv->ids_enabled_bimap, id, 1); \"used bitmap 位图中 hwirq 的bit置1\"\n    \\ -+ __imsic_id_enable(priv->ipi_id);  \"imsci 寄存器打开 ipi 中断\"\n       \\ -+ __imsic_eix_update((priv->ipi_id), 1, false, true) \n\t\t\t   \"让iselect 选择对应的 eip/eie 寄存器, 然后选择置1或置0 来开关中断/开关pending\"\n\t      \\ -+ imsic_csr_set(isel, ireg); \n\t\t     \\ -  csr_write(CSR_ISELECT, isel)  \"更新 siselct csr\" \n\t\t     | -  csr_set(CSR_IREG, ireg)       \"更新 sireg csr\"     \n   \n```\n\n最终由unmask_irq -> imsic_irq_unmask 打开中断, 最后设置了该hart的 siselct 和 sireg csr, 将对应的eipx/eiex 置位.\n\n## 小结与思考\n\n从上面中断注册和中断处理过程中, 可以看到每个 hart 对应的MSI的mmio\n对于S-mode来说, 外部中断设置的最终是\n`__imsic_id_enable(id)`\n该函数最终设置的是 eipx/eiex, 通过siselct 与 sireg 这两个csr 选择对应的 eipx/eiex, 再设置对应的值, 即可开关对应的pending/中断使能, csr 是hart 专属的, 每一个hart 都由一组csr.\n\n`imsic_irq_mask` `imsic_irq_unmask` 最终关联 `__imsic_id_enable` `__imsic_id_disable` 这一组函数\n\nirq_mask 中断屏蔽\nirq_unmask 中断打开\n\n但这其中并未发现直接的mmio 地址关联\n上述中断开关最终都是操作的siselect/sireg 寄存器, 猜测最终都是设置的该hart的 S-mode interrupt file的mmio region.\n\n与guest interrupt file 相关的设置在哪里呢, 怀疑的地方是msi相关的函数 `imsic_irq_compose_msi_msg`\n该提交中看起来并没有涉及到 guest 相关的设置.\n除了初始化函数中与guest_index 相关的内容外, 并没有其他的.\n","tags":["riscv","imsic","aia"],"categories":["虚拟化","RISCV","中断"]},{"title":"riscv spl linux 加载流程","url":"/2022/10/11/hxd_new/riscv调研/riscv spl linux 加载流程/","content":"\n以 sifive fu740 为例\n\n# 编译流程\n\n编译opensbi\n```shell\ngit clone https://github.com/riscv/opensbi.git\ncd opensbi\nmake PLATFORM=generic\nexport OPENSBI=<path to opensbi/build/platform/generic/firmware/fw_dynamic.bin>\n```\n生成 `fw_dynamic.bin`\n编译uboot 和 spl\n\n```shell\ncd <U-Boot-dir>\nmake sifive_unmatched_defconfig\nmake\n```\n生成 `spl/u-boot-spl.bin` 和 `u-boot.itb` 文件\n\n# 烧写\n```shell\nsudo sgdisk -g --clear -a 1 \\\n  --new=1:34:2081         --change-name=1:spl --typecode=1:5B193300-FC78-40CD-8002-E86C45580B47 \\\n  --new=2:2082:10273      --change-name=2:uboot  --typecode=2:2E54B353-1271-4842-806F-E436D6AF6985 \\\n  --new=3:16384:282623    --change-name=3:boot --typecode=3:0x0700 \\\n  --new=4:286720:13918207 --change-name=4:root --typecode=4:0x8300 \\\n  /dev/sdX\n```\n> sdX 表示通配, sd 卡插到电脑上, sd 卡的节点可能是 sdb sdc 等, 这里以 sdX 表示\n\n\n```shell\nsudo sgdisk -g --clear -a 1 \\\n  --new=1:34:2081         --change-name=1:spl --typecode=1:5B193300-FC78-40CD-8002-E86C45580B47 \\\n  --new=2:2082:10273      --change-name=2:uboot  --typecode=2:2E54B353-1271-4842-806F-E436D6AF6985 \\\n  --new=3:16384:282623    --change-name=3:boot --typecode=3:0x8300 \\\n  /dev/nbd0\nsudo dd if=<payload.bin> of=/dev/nbd0p2 seek=2082  \"将u-boot.itb 拷贝到sd卡的第二个分区\"\nsudo mount /dev/nbd0p3 <mnt_dir>\ncp Image dtb <mnt_dir>\nsudo umount mnt_dir\nsudo qemu-nbd --disconnect\n```\n\n上述步骤在sd卡上建了gpt 的四个分区, 分区的 **start end sector offset** 见命令, 同时指定了spl和u-boot.itb 所在分区的uuid\n\nu-boot.itb 由 `fw_dynamic.bin`, `u-boot-nodtb.bin` 和 `hifive-unmatched-a00.dtb` 组成\n\n```shell\nsudo mkfs.vfat /dev/sdX3   \"第三个分区格式化为 vfat 文件系统\"\nsudo mkfs.ext4 /dev/sdX4   \"第四个分区格式化为 ext4 文件系统\"\nsudo mount /dev/sdX3 /media/sdX3 \"第三个分区挂载到pc上\"\nsudo cp Image.gz hifive-unmatched-a00.dtb /media/sdX3/    \"将kernel 镜像 dtb 文件拷贝到 sd卡的第三个分区下\"\nsudo dd if=spl/u-boot-spl.bin of=/dev/sdX seek=34 \"将u-boot-spl.bin 拷贝到sd卡的第一个分区\"\nsudo dd if=u-boot.itb of=/dev/sdX seek=2082  \"将u-boot.itb 拷贝到sd卡的第二个分区\"\n```\n\n# 启动kernel\n\n```shell\nfatload mmc 0:3 ${kernel_addr_r} Image.gz                \"kernel_addr_r 为 ddr上运行地址\"\nfatload mmc 0:3 ${fdt_addr_r} hifive-unmatched-a00.dtb   \"dtb 地址\"\nbooti ${kernel_addr_r} - ${fdt_addr_r}                   \"手动启动kernel\"\n```\n\n# spl代码分析\n\n先分析入口汇编\n\nspl 运行在M-mode下, 其bin文件被烧到了 sd卡的第一个分区中, 由bootrom 加载, u-boot-spl.bin 包含两个部分: u-boot-spl-nodtb.bin 和 u-boot-spl.dtb\nu-boot-spl.dtb 中为spl的dtb 描述文件.\n\n```erlang\n+ _start:\n \\ -  mv tp, a0 \"tp register save hartid\"\n | -  la t0, trap_entry\n | -  csrw\tMODE_PREFIX(tvec), t0 \"设置中断mtvec 入口为 trap_entry\"\n | -  csrw\tMODE_PREFIX(ie), zero\n | -  li\tt0, MIE_MSIE\n | -  csrs   MODE_PREFIX(ie), t0   \"初始化msie\"\n | -+ call_board_init_f \"Set sp in internal/ex RAM to call board_init_f\"\n    \\ -  li t1, CONFIG_SPL_STACK \"设置初始栈基址\"\n    | -  li t0, -16\n    | -  and   sp, t1, t0   \"将堆栈16 bits对齐\"\n | -+ call_board_init_f_0 \"从堆栈开始的地方，为u-boot的global data（struct global_data）分配空间\"\n    \\ -- mv a0, sp\n    | -+ jal board_init_f_alloc_reserve\n       \\ - top -= CONFIG_VAL(SYS_MALLOC_F_LEN) \"如定义了CONFIG_SYS_MALLOC_F_LEN，需预留出early malloc所需的空间\"\n    | -  slli t0, tp, CONFIG_STACK_SIZE_SHIFT \"tp代表的是hartid, 每个hart 分配STACK_SIZE 空间\"\n    | -  sub sp, a0, t0 \"sp = a0 - t0, 地址在初始栈基址上向上增长, a0 初始栈基址 top - malloc空间\"\n    | -  bnez   tp, secondary_hart_loop \"其他hart 跳转到 secondary_hart_loop, hart 0 继续\"\n    | -+ jal board_init_f_init_reserve \"初始化uboot的global data, 置0\"\n       \\ -  \"如定义了SYS_MALLOC_F_LEN，则会初始化gd->malloc_base\"\n    | -  SREG\ttp, GD_BOOT_HART(gp) \"/* save the boot hart id to global_data */\"\n | -+ wait_for_gd_init\n    \\ -  jal    icache_enable\n    | -  jal    dcache_enable\n    | -  mv\ta0, zero\n    | -+ jalr   board_init_f\n       \\ -+ spl_early_init()\n          \\ -+ spl_common_init(true);\n             \\ -  fdtdec_setup() \"扫描spl的dtb, 创建fdt blob\"\n             \\ -  dm_init_and_scan(!CONFIG_IS_ENABLED(OF_PLATDATA)); \"扫描注册了哪些driver, 绑定device\"\n       | -+ riscv_cpu_setup(NULL, NULL);\n          \\ -+ riscv_cpu_probe();\n             \\ -+ cpu_probe_all(); \"触发riscv cpu 驱动bind\"\n                \\ -  riscv_cpu_bind() \"主要工作是 riscv timer 相关初始化\"\n                | -  riscv_cpu_ops = {.get_desc  = riscv_cpu_get_desc, .get_info  = riscv_cpu_get_info, \n                     .get_count = riscv_cpu_get_count,} \"注册 riscv_cpu_ops\"\n          | -  check supports_extension('d') supports_extension('f') \"通过前面注册的 riscv_cpu_get_desc 查询\" \n          | -  csr_write(CSR_MCOUNTEREN, GENMASK(2, 0));  \"Enable perf counters for cycle, time,\" \n       | -+ preloader_console_init();\n          \\ -  serial_init(); \"初始化uart\"\n       | -+ spl_board_init_f();\n          \\ -+ spl_soc_init();\n             \\ -+ uclass_get_device(UCLASS_RAM, 0, &dev); \"ddr init\"\n                \\ -  uclass_find_device(id, index, &dev);\n                | -+ uclass_get_device_tail(dev, ret, devp);\n                   \\ -+ device_probe(dev);\n                      \\ -+ sifive_ddr_probe(struct udevice *dev) \"ddr probe\"\n                         \\ -  clk_get_by_index(dev, 0, &priv->ddr_clk); \"从fdt 中获取\"\n                         | -  dev_read_u32(dev, \"clock-frequency\", &clock);\n                         | -  clk_enable(&priv->ddr_clk);\n                         | -+ sifive_ddr_setup(dev);\n                            \\ -  dev_read_u32_array(dev, \"sifive,ddr-params\",  (u32 *)&plat->ddr_params,\n                                   sizeof(plat->ddr_params) / sizeof(u32));\n                            | -  ... \"ddr 硬件寄存器设置参数\"\n | -  spl_clear_bss\n | -  spl_clear_bss_loop \"初始化bss\"      \n | -+ spl_stack_gd_setup\n    \\ -  jal    spl_relocate_stack_gd \"什么也没干\"\n    | -+ beqz   a0, spl_call_board_init_r\n       \\ -+ jal    board_init_r(a0=zero,a1=zero)\n          \\ -+ spl_set_bd();\n             \\ -  gd->bd = &bdata;\n          | -  mem_malloc_init(CONFIG_SYS_SPL_MALLOC_START =0x3fe430000,  CONFIG_SYS_SPL_MALLOC_SIZE); \"堆内存相关\"\n          | -  memset(&spl_image, '\\0', sizeof(spl_image));\n          | -+ board_boot_order(spl_boot_list); \"调用到board 相关的\"\n             \\ -+ spl_boot_list[0] = spl_boot_device();\n                \\ -  mode_select = readl((void *)MODE_SELECT_REG);\n                | -  if MODE_SELECT_SD: BOOT_DEVICE_MMC1 \"默认和SD_SELECT 时为 BOOT_DEVICE_MMC1\"\n          | -+ boot_from_devices(&spl_image, spl_boot_list, ARRAY_SIZE(spl_boot_list)   \n             \\ -+ for (i = 0; i < count && spl_boot_list[i] != BOOT_DEVICE_NONE; i++)\n                \\ -+ loader = spl_ll_find_loader(spl_boot_list[i]) \n                                \"定位到  SPL_LOAD_IMAGE_METHOD(\"MMC1\", 0, BOOT_DEVICE_MMC1, spl_mmc_load_image);\"\n                   \\ -+ spl_image_loader *drv = ll_entry_start(struct spl_image_loader, spl_image_loader);\n                      \\ -  .u_boot_list_2_spl_image_loader_1 \"定位到 该地址, 从 map section 找到的, 其函数为 spl_mmc_load_image\"  \n                   | -+ int n_ents = ll_entry_count(struct spl_image_loader, spl_image_loader);  \n                          \"从 u_boot_list_2_spl_image_loader_1 遍历到 u_boot_list_2_spl_image_loader_3\"\n                   | -+ for (entry = drv; entry != drv + n_ents; entry++)\n                      \\ -  find boot_device == entry->boot_device \n                | -+ spl_load_image(spl_image, loader)\n                   \\ -  bootdev.boot_device = loader->boot_device; \"boot_device 为 BOOT_DEVICE_MMC1\"\n                   | -+ loader->load_image(spl_image, &bootdev); \"调用到 spl_mmc_load_image\"\n                      \\ -+ spl_mmc_load(spl_image, bootdev, CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR = 0x822 = 2082) \n                                     \"这个地方指到了 第二个分区的 sector 位置\"\n                         \\ -+ spl_mmc_find_device(&mmc, bootdev->boot_device)\n                            \\ -+ mmc_init_device(0);\n                               \\ -  uclass_get_device(UCLASS_MMC, num, &dev);\n                               | -  m = mmc_get_mmc_dev(dev); \"mmc 驱动需要提前加载\"\n                         | -  err = mmc_init(mmc); \"mmc 初始化\"\n                         | -+ boot_mode = spl_mmc_boot_mode(bootdev->boot_device);\n                            \\ - return MMCSD_MODE_RAW \n                         | -  raw_sect = spl_mmc_get_uboot_raw_sector(mmc); \"MMCSD_MODE_EMMCBOOT case 分支并没有break\"\n                         | -+ mmc_load_image_raw_sector(spl_image, mmc, raw_sect);        \n                            \\ -  blk_dread(bd, sector, 1, header); \"从 mmc raw_sect 处 读入header\"\n                            | -+ spl_load_simple_fit(spl_image, &load, sector, header);\n                                     \"镜像为FIT 格式时 header->ih_magic = FDT_MAGIC 的情况 , 加载到指定位置, 信息填充到 spl_image下\" \n                               \\ -+ spl_simple_fit_read(&ctx, info, sector, fit)     \"uboot.itb 的 fit 描述信息\"\n                                  \\ -  buf = board_spl_fit_buffer_addr(size, sectors, info->bl_len);\n                                  | -  count = info->read(info, sector, sectors, buf); \"从mmc 中读出 FIT blob\"\n                                  | -  ctx->fit = buf; \"FIT blob 指针赋给ctx, ctx 后面使用会比较频繁\"\n                               | -+ node = spl_fit_get_image_node(&ctx, FIT_FIRMWARE_PROP, 0); \"从uboot.itb 的FIT blob 获取firmware node\"\n                                  \\ -+ spl_fit_get_image_name(ctx, type, index, &str);\n                                     \\ -  name = fdt_getprop(ctx->fit, ctx->conf_node, type, &len); \n                                         \"找 configurations node 下的firmware节点, 节点value 填充到str, 这里为 opensbi\"\n                                  | -  node = fdt_subnode_offset(ctx->fit, ctx->images_node, str); \n                                           \"查image下的  name 为 opensbi 的节点\"\n                               | -+ spl_load_fit_image(info, sector, &ctx, node, spl_image); \n                                         \"将opensbi node 节点下的信息读到 spl_image中\"\n                                         \"这里主要是填充load_addr, entry_point , 同时将数据下载到 load_addr 处\"\n                                  \\ -  fit_image_get_data_offset(fit, node, &offset) \"解析data-offset 节点, 获取bin offset\"       \n                                  | -  fit_image_get_data_size(fit, node, &len)   \"解析data-size 节点, 获取opensbi bin的长度\"\n                                  | -  src_ptr = map_sysmem(ALIGN(load_addr, ARCH_DMA_MINALIGN), len); \"分配内存, 这里直接指向load_addr处\"\n                                  | -  info->read(info, sector + get_aligned_image_offset(info, offset), nr_sectors, src_ptr)\n                                        \"下载数据到src_ptr 处\"\n                                  | -  src = src_ptr + overhead;      \n                                  | -  fit_image_verify_with_data(fit, node, gd_fdt_blob(), src, length)  \"校验hash\"\n                                  | -  memcpy(load_ptr, src, length);\n                                  | -  image_info->load_addr = load_addr; \"填充spl_image\"\n                                  | -  fit_image_get_entry(fit, node, &entry_point) \"查entry节点\"\n                                  | -  image_info->entry_point = entry_point; \"填充spl_image\"\n                               | -+ node = spl_fit_get_image_node(&ctx, \"loadables\", index); \"查loadables节点, 这个节点对应uboot\"\n                               | -  spl_load_fit_image(info, sector, &ctx, node, &uboot_image_info); \"下载uboot 节点的数据\"\n                               | -+ spl_fit_append_fdt(&uboot_image_info, info, sector, &ctx);\n                                  \\ -  node = spl_fit_get_image_node(ctx, FIT_FDT_PROP, index++); \"下载fdt 节点数据\"\n                                  | -  image_info.load_addr = uboot_image_info->load_addr + uboot_image_info->size; \n                                             \"fdt load_addr 追加到uboot镜像后面\"\n                                  | -  uboot_image_info->fdt_addr = map_sysmem(image_info.load_addr, 0);\n                                  | -  spl_load_fit_image(info, sector, ctx, node, &image_info); \"下载fdt 到 fdt_addr 处\"\n                               | -  spl_image->fdt_addr = uboot_image_info.fdt_addr; \"将fdt的load_addr 拷贝给 opensbi的spl_image 信息\"   \n                | -  spl_image->boot_device = spl_boot_list[i];\n          | -  switch (spl_image.os)      \n          | -+ case IH_OS_OPENSBI:\n             \\ -+ spl_invoke_opensbi(&spl_image);  \"跳到opensbi\"\n                \\ -  check spl_image->fdt_addr valid\n                | -  spl_opensbi_find_uboot_node(spl_image->fdt_addr, &uboot_node); \"查fdt 属性 fit images 下是否有uboot的节点\"\n                | -  fit_image_get_entry(spl_image->fdt_addr, uboot_node, &uboot_entry); \n                               \"uboot 节点下的entry (运行地址)信息填给 uboot_entry\"\n                | -  opensbi_info.next_addr = uboot_entry;\n                | -  opensbi_info.next_mode = FW_DYNAMIC_INFO_NEXT_MODE_S;\n                | -  opensbi_info.boot_hart = gd->arch.boot_hart\n                | -  opensbi_entry = (void (*)(ulong, ulong, ulong))spl_image->entry_point; \"opensbi的entry 起始运行地址\"\n                | -  invalidate_icache_all(); \"刷新icache\"\n                | -  opensbi_entry(gd->arch.boot_hart, (ulong)spl_image->fdt_addr, (ulong)&opensbi_info); \n                             \"跳到opensbi entry 运行起始地址, 携带了opensbi 下一跳的信息\"\n```\n\n>注意点:\nspl 本身带有dtb, 这部分dtb 描述了spl 初始化外设的信息, 包括cpu ddr uart 等的参数\n而uboot.itb 的dtb 会从mmc 存储中load 出来, 其描述信息会被解析用来确定firmware的信息.\n\n加载的流程为:\n1. 定位到 (u-boot + opensbi + fdt) 镜像所在的分区, 注意这个地方现在是写的死的位置 2082 sector, 由 `CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR` 定义\n2. 读取镜像的header, 判断ih_magic 是否是FIT格式还是legacy 模式\n3. FIT 格式的镜像由spl_load_simple_fit 函数加载\n4. 下载(opensbi uboot fdt) bin 数据 到其节点描述的load位置, 填充image_info结构, 保存各级 entry (运行起始地址) load 信息\n5. 跳转到opensbi, 此处opensbi 为 fw_dynamic, 需要携带下一跳 即uboot 的start_entry 和 fdt的load地址信息.\n\n整个加载的核心代码在 spl_load_simple_fit 函数中.\n对于不同的存储设备类型, 由`spl_boot_device()` 定义, 本例中默认为 BOOT_DEVICE_MMC1, \n还有以下这些供选择. 对应不同的类型由 `SPL_LOAD_IMAGE_METHOD` 方法注册对应的load_image 的 ops 函数.\n\n```c\nenum {\n\tBOOT_DEVICE_RAM,\n\tBOOT_DEVICE_MMC1,\n\tBOOT_DEVICE_MMC2,\n\tBOOT_DEVICE_MMC2_2,\n\tBOOT_DEVICE_NAND,\n\tBOOT_DEVICE_ONENAND,\n\tBOOT_DEVICE_NOR,\n\tBOOT_DEVICE_UART,\n\tBOOT_DEVICE_SPI,\n\tBOOT_DEVICE_USB,\n\tBOOT_DEVICE_SATA,\n\tBOOT_DEVICE_I2C,\n\tBOOT_DEVICE_BOARD,\n\tBOOT_DEVICE_DFU,\n\tBOOT_DEVICE_XIP,\n\tBOOT_DEVICE_BOOTROM,\n\tBOOT_DEVICE_NONE\n};\n```\n不同device 的load_image的ops 对于FIT 镜像都会调用到 `spl_load_simple_fit` 函数.\n\n在介绍该函数前, 需要先了解 uboot的FIT格式镜像, FIT(flattened image tree), 它利用了Device Tree Source files（DTS）的语法，生成的image文件也和dtb文件类似（称作itb），下面我们会详细描述\n\nuboot.itb 中会集成 opensbi uboot-nodtb 和 dtb 三部分镜像, 先看下描述文件:\n```c\ndtc u-boot.dtb\n...\n\tbinman {\n\t\tmultiple-images;\n\n\t\titb {\n\t\t\tfilename = \"u-boot.itb\";\n\n\t\t\tfit {\n\t\t\t\tdescription = \"Configuration to load OpenSBI before U-Boot\";\n\t\t\t\t#address-cells = <0x1>;\n\t\t\t\tfit,fdt-list = \"of-list\";\n\n\t\t\t\timages {\n\n\t\t\t\t\tuboot {\n\t\t\t\t\t\tdescription = \"U-Boot\";\n\t\t\t\t\t\ttype = \"standalone\";\n\t\t\t\t\t\tos = \"U-Boot\";\n\t\t\t\t\t\tarch = \"riscv\";\n\t\t\t\t\t\tcompression = \"none\";\n\t\t\t\t\t\tload = <0x80200000>;\n\n\t\t\t\t\t\tblob-ext {\n\t\t\t\t\t\t\tfilename = \"u-boot-nodtb.bin\";\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\topensbi {\n\t\t\t\t\t\tdescription = \"OpenSBI fw_dynamic Firmware\";\n\t\t\t\t\t\ttype = \"firmware\";\n\t\t\t\t\t\tos = \"opensbi\";\n\t\t\t\t\t\tarch = \"riscv\";\n\t\t\t\t\t\tcompression = \"none\";\n\t\t\t\t\t\tload = <0x80000000>;\n\t\t\t\t\t\tentry = <0x80000000>;\n\n\t\t\t\t\t\topensbi {\n\t\t\t\t\t\t\tfilename = \"fw_dynamic.bin\";  // filename 不是真实节点名\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\t@fdt-SEQ {\n\t\t\t\t\t\tdescription = \"NAME\";\n\t\t\t\t\t\ttype = \"flat_dt\";\n\t\t\t\t\t\tcompression = \"none\";\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tconfigurations {\n\t\t\t\t\tdefault = \"conf-1\";\n\n\t\t\t\t\t@conf-SEQ {\n\t\t\t\t\t\tdescription = \"NAME\";\n\t\t\t\t\t\tfirmware = \"opensbi\";\n\t\t\t\t\t\tloadables = \"uboot\";\n\t\t\t\t\t\tfdt = \"fdt-SEQ\";\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\n```\n\n> 注意, 上面的filename 不是真实节点名称, 它类似于incbin, 在mkimage 打包时会解析该prop, 将prop 描述的文件塞到 itb 镜像中, 并记录其在镜像中的offset 和 size, 记为data-offset(或data-position) 和 data-size\n\npc host 端使用 `./tools/mkimage -l ./u-boot.itb` 可以打印itb 中分区的信息.\n\n```shell\n ./tools/mkimage -l ./u-boot.itb\nFIT description: Configuration to load OpenSBI before U-Boot\nCreated:         Mon Nov 21 18:13:47 2022\n Image 0 (uboot)\n  Description:  U-Boot\n  Created:      Mon Nov 21 18:13:47 2022\n  Type:         Standalone Program\n  Compression:  uncompressed\n  Data Size:    641008 Bytes = 625.98 KiB = 0.61 MiB\n  Architecture: RISC-V\n  Load Address: 0x80200000\n  Entry Point:  unavailable\n Image 1 (opensbi)\n  Description:  OpenSBI fw_dynamic Firmware\n  Created:      Mon Nov 21 18:13:47 2022\n  Type:         Firmware\n  Compression:  uncompressed\n  Data Size:    116016 Bytes = 113.30 KiB = 0.11 MiB\n  Architecture: RISC-V\n  OS:           RISC-V OpenSBI\n  Load Address: 0x80000000\n Image 2 (fdt-1)\n  Description:  hifive-unmatched-a00\n  Created:      Mon Nov 21 18:13:47 2022\n  Type:         Flat Device Tree\n  Compression:  uncompressed\n  Data Size:    22004 Bytes = 21.49 KiB = 0.02 MiB\n  Architecture: Unknown Architecture\n Default Configuration: 'conf-1'\n Configuration 0 (conf-1)\n  Description:  hifive-unmatched-a00\n  Kernel:       unavailable\n  Firmware:     opensbi\n  FDT:          fdt-1\n  Loadables:    uboot\n```\n\n而u-boot 中可以使用`iminfo itb 文件load到的地址` 查看真实的镜像信息, 会包含 \"data-offset\" 和 \"data-size\" 节点\n\n对于多核启动流程, 上述过程并未提及.\n下面说下spl中其他核的处理过程:\n\n## 从核启动过程\n\n在上面的 spl_invoke_opensbi 函数中, 最后处理了其他核的情况\n```erlang\n-+ ret = smp_call_function((ulong)spl_image->entry_point,\n\t\t\t\t(ulong)spl_image->fdt_addr,\n\t\t\t\t(ulong)&opensbi_info, wait=1);\t\t\n \\ -  ipi_data ipi = { .addr = entry_point, .arg0 = fdt_addr, .arg1 = opensbi_info,\t};\t\t\t\t\n | -+ send_ipi_many(&ipi, wait);\n    \\ -  cpus = ofnode_path(\"/cpus\");\n    | -+ ofnode_for_each_subnode(node, cpus) \"扫描spl的fdt\"\n       \\ -  ofnode_read_u32(node, \"reg\", &reg); \"read hart ID of CPU 放在reg中\"\n       | -  !gd->arch.available_harts & (1 << reg) | continue; \"跳过not available的\"\n       | -  reg == gd->arch.boot_hart | continue; \"跳过主核\"\n       | -  gd->arch.ipi[reg].addr = ipi->addr; \n       | -  gd->arch.ipi[reg].arg0 = ipi->arg0;\n       | -  gd->arch.ipi[reg].arg1 = ipi->arg1;\n       | -  riscv_send_ipi(reg); \"主核给其他核发ipi中断\" \n       | -+ while pending\n          \\ - wait | riscv_get_ipi(reg, &pending); \"查是否pending, 如果从核没处理完该pending中断, 主核不会跳到下一阶段即 opensbi\"\n```\n\n\n>spl 中从核的初始化流程并没有设置 mstatus.mie mie, 虽然设置了mie.MSIE 和 mtvec trap entry, 但其中断并没打开.\n\n虽然中断没打开, 但是可以被外部中断信号从wfi 处叫起来.\n\n从核停在 secondary_hart_loop, 一直在loop, wfi停掉, 重点看下这个函数:\n\n> 注意CONFIG_IS_ENABLED 宏,  与CONFIG_SPL_BUILD/ CONFIG_TPL_BUILD 联合使用, 这个BUILD宏是由Makefile spl传入的.\n```makefile\n#if defined(CONFIG_TPL_BUILD)\n#define _CONFIG_PREFIX TPL_\n#elif defined(CONFIG_SPL_BUILD)\n#define _CONFIG_PREFIX SPL_\n#else\n#define _CONFIG_PREFIX\n#endif\n```\n>if CONFIG_SPL_BUILD is undefined and CONFIG_FOO is set to 'y',\n if CONFIG_SPL_BUILD is defined and CONFIG_SPL_FOO is set to 'y',\n if CONFIG_TPL_BUILD is defined and CONFIG_TPL_FOO is set to 'y',\n\n\n```c\n 0000000008000260 <secondary_hart_loop>:\n 8000260:\t10500073          \twfi\n #if CONFIG_IS_ENABLED(SMP)  \"拆解为 CONFIG_SPL_SMP 是否定义了\"\n 8000264:\t344022f3          \tcsrr\tt0,mip\n 8000268:\t0082f293          \tandi\tt0,t0, MIE_MSIE   //前面已经设置了 MIE_MSIE\n 800026c:\tfe028ae3          \tbeqz\tt0,8000260 <secondary_hart_loop>\n 8000270:\t8512                mv\ta0,tp\n 8000272:\t3f4000ef          \tjal\tra,8000666 <handle_ipi> // 进入handle_ipi\n #endif\n 8000276:\tb7ed                j\t8000260 <secondary_hart_loop>\n \nvoid handle_ipi(ulong hart)\n{\n\tint ret;\n\tvoid (*smp_function)(ulong hart, ulong arg0, ulong arg1);\n    // 检查gd->arch.ipi[hart].valid, 在主核没发起ipi 前, 这个地方是无效的, 会直接退出 handle_ipi 回到 secondary_hart_loop\n\tif (!__smp_load_acquire(&gd->arch.ipi[hart].valid))\n\t\treturn;\n\n\tsmp_function = (void (*)(ulong, ulong, ulong))gd->arch.ipi[hart].addr;\n\tinvalidate_icache_all();\n\n\t/*\n\t * Clear the IPI to acknowledge the request before jumping to the\n\t * requested function.\n\t */\n\tret = riscv_clear_ipi(hart);\n\tif (ret) {\n\t\tpr_err(\"Cannot clear IPI of hart %ld (error %d)\\n\", hart, ret);\n\t\treturn;\n\t}\n    // 执行主核设置的参数, 这个地方跳转到 opensbi 入口地址, arg0为fdt_addr, arg1 为 opensbi_info\n\tsmp_function(hart, gd->arch.ipi[hart].arg0, gd->arch.ipi[hart].arg1);\n}\n```\n\n在主核给从核发送ipi后, 从核从wfi中唤醒, 进入handle_ipi中, 跳入opensbi, 设置a0 寄存器为 uboot.itb 中带的fdt的下载到的地址fdt_addr, a1 寄存器为 opensbi_info, 携带了opensbi下一级的启动信息(uboot_entry majic version boot_hart等)\n\n\n# opensbi 启动流程\nspl 加载uboot.itb, 将opensbi 镜像下载到 ddr 0x80000000 位置, uboot 下载到0x80200000 位置\n然后启动dynamic 的opensbi, 这里不一定是dynamic的, 可以定制为payload或jump的.\n下面以dynamic 为例分析 opensbi的启动流程.\n\n首先看下opensbi的布局:\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20221125190759.svg)\n\n从其布局中需要重点了解 属于hartid的 scratch space, 这个空间在启动过程以及消息传递过程会频繁用到.\n下面看下启动过程:\n\n```c\n_start:\n\t/* Find preferred boot HART id */\n\tMOV_3R\ts0, a0, s1, a1, s2, a2 \"a0 为hartid\"\n\tcall\tfw_boot_hart    \"从spl 传递的opensbi_info 中找boot_hart 给到 a0 -> a6, 如果opensbi不是fw_dynamic的, a0->a6 为 -1\"\n\tadd\ta6, a0, zero\n\tMOV_3R\ta0, s0, a1, s1, a2, s2\n\tli\ta7, -1\n\tbeq\ta6, a7, _try_lottery     \"fw_jump 情况下, a0=a6=-1, 主核进入_try_lottery, 从核也会进_try_lottery\"\n\t/* Jump to relocation wait loop if we are not boot hart */\n\tbne\ta0, a6, _wait_relocate_copy_done \"fw_dynamic a0=a6=0, 主核进入 _try_lottery, 从核a0 > 0, 进入_wait_relocate_copy_done. \"\n_try_lottery:\n\t/* Jump to relocation wait loop if we don't get relocation lottery */\n\tlla\ta6, _relocate_lottery\n\tli\ta7, 1\n\tamoadd.w a6, a7, (a6) \"主核先抢到lottery, 不会进入_wati_relocate_copy_done, 从核进入_wait_relocate_copy_done\"\n\tbnez\ta6, _wait_relocate_copy_done\n\n\t/* Save load address */\n\tlla\tt0, _load_start\n\tlla\tt1, _fw_start\n\tREG_S\tt1, 0(t0)\n\nrelocate:\n    ...\n\t\n_relocate_done:\n    lla    t0, _boot_status    \n    li  t1, BOOT_STATUS_RELOCATE_DONE\n    REG_S   t1, 0(t0)    \"设置_boot_status = BOOT_STATUS_RELOCATE_DONE = 1\"\n \n_fdt_reloc_done:\n\t/* mark boot hart done */\n\tli\tt0, BOOT_STATUS_BOOT_HART_DONE\n\tlla\tt1, _boot_status\n\tREG_S\tt0, 0(t1)    \"设置_boot_status = BOOT_STATUS_BOOT_HART_DONE = 2\"\n\tfence\trw, rw\n\tj\t_start_warm   \"主核relocate完 设置BOOT_STATUS_BOOT_HART_DONE = 2 后进入 _start_warm\"\n    \n_wait_relocate_copy_done:\n\tlla\tt0, _fw_start\n\tlla\tt1, _link_start\n\tREG_L\tt1, 0(t1)\n\tbeq\tt0, t1, _wait_for_boot_hart  \"进_wait_for_boot_hart\"\n\tlla\tt2, _boot_status\n\tlla\tt3, _wait_for_boot_hart\n\tsub\tt3, t3, t0\n\tadd\tt3, t3, t1    \"t3 = _wait_for_boot_hart - _fw_start + _link_start\"\n1:\n\t/* waitting for relocate copy done (_boot_status == 1) */\n\tli\tt4, BOOT_STATUS_RELOCATE_DONE\n\tREG_L\tt5, 0(t2)\n\t/* Reduce the bus traffic so that boot hart may proceed faster */\n\tnop\n\tnop\n\tnop\n\tbgt     t4, t5, 1b  \"等 _boot_status == (BOOT_STATUS_RELOCATE_DONE = 1)\"\n\tjr\tt3  \"跳到 _wait_for_boot_hart\"\n\n_wait_for_boot_hart:\n\tli\tt0, BOOT_STATUS_BOOT_HART_DONE\n\tlla\tt1, _boot_status\n\tREG_L\tt1, 0(t1)\n\t/* Reduce the bus traffic so that boot hart may proceed faster */\n\tnop\n\tnop\n\tnop\n\tbne\tt0, t1, _wait_for_boot_hart  \"等 _boot_status == (BOOT_STATUS_BOOT_HART_DONE = 2)\"\n\n_start_warm:    \"主从核在 BOOT_STATUS_BOOT_HART_DONE = 2 后进入 _start_warm\"\n    lla    a4, platform\n    lwu s7, SBI_PLATFORM_HART_COUNT_OFFSET(a4)          \"从platform 中获取hart数量, ->s7\"\n    lwu s8, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(a4)     \"获取stack_size, ->s8\"\n    csrr   s6, CSR_MHARTID                              \"读取hartid ->s6\"\n    \"Find the scratch space based on HART index\"\n    lla\ttp, _fw_end\n\tmul\ta5, s7, s8\n\tadd\ttp, tp, a5          \"_fw_end + hart_cout * hart_stack_size -> tp\"\n\tmul\ta5, s8, s6           \n\tsub\ttp, tp, a5          \"_fw_end + (hart_cout - hartid) * hart_stack_size -> tp \n\t                        \"为 hartid 所在的hart_stack空间\"\n\tli\ta5, SBI_SCRATCH_SIZE    \n\tsub\ttp, tp, a5          \"hartid hart_stack - SBI_SCRATCH_SIZE 为 hartid的scratch 所在地址\"\n    csrw   CSR_MSCRATCH, tp   \"将 hartid的scratch 所在地址 赋给 mscratch\"\n    lla    a4, _trap_handler  \"设置M-mode trap 入口为 _trap_handler\"\n    csrw   CSR_MTVEC, a4\n\tcsrr   a0, CSR_MSCRATCH\n\tcall   sbi_init         \"主从核调用 sbi_init(mscratch)\"\n```\n\nplatform 为平台定义, 定义了平台相关信息\n```c\nstruct sbi_platform platform = {\n\t.opensbi_version\t= OPENSBI_VERSION,\n\t.platform_version\t=\n\t\tSBI_PLATFORM_VERSION(CONFIG_PLATFORM_GENERIC_MAJOR_VER,\n\t\t\t\t     CONFIG_PLATFORM_GENERIC_MINOR_VER),\n\t.name\t\t\t= CONFIG_PLATFORM_GENERIC_NAME,\n\t.features\t\t= SBI_PLATFORM_DEFAULT_FEATURES,\n\t.hart_count\t\t= SBI_HARTMASK_MAX_BITS,\n\t.hart_index2id\t\t= generic_hart_index2id,\n\t.hart_stack_size\t= SBI_PLATFORM_DEFAULT_HART_STACK_SIZE,\n\t.platform_ops_addr\t= (unsigned long)&platform_ops\n};\n```\n\n主从核进入 sbi_init 的c_code 后续处理流程:\n\n```erlang\n-+ sbi_init(mscratch)  \"mscratch 地址指向hartid 所在的 scratch space\"\n \\ -  u32 hartid         = current_hartid(); \"csr_read(CSR_MHARTID)\"\n | -  sbi_platform *plat = sbi_platform_ptr(scratch);\n | -+ next_mode_supported && atomic_xchg(&coldboot_lottery, 1) == 0 \n           \"主核抢到 coldboot_lottery, 设置前为0, 设置后为1, 从核抢不到, coldboot = FALSE\"\n    \\ -  coldboot = TRUE   \"主核 coldboot 为 TRUE\"\n | -|+ if coldboot\n     \\ -+ init_coldboot(scratch, hartid); \"主核进\"\n        \\ -  sbi_platform *plat = sbi_platform_ptr(scratch);\n        | -  sbi_scratch_init(scratch);\n        | -  sbi_domain_init(scratch, hartid);\n        | -  sbi_hsm_init(scratch, hartid, TRUE);\n        | -  sbi_platform_early_init(plat, TRUE);\n        | -  sbi_hart_init(scratch, TRUE);\n        | -  sbi_console_init(scratch);\n        | -  sbi_pmu_init(scratch, TRUE);\n        | -  sbi_irqchip_init(scratch, TRUE);\n        | -  sbi_ipi_init(scratch, TRUE);\n        | -  sbi_tlb_init(scratch, TRUE);\n        | -  sbi_timer_init(scratch, TRUE);\n        | -  sbi_ecall_init();\n        | -  sbi_platform_final_init(plat, TRUE);\n        | -  wake_coldboot_harts(scratch, hartid); \"Send an IPI to all HARTs waiting for coldboot\"\n        | -  sbi_hsm_prepare_next_jump(scratch, hartid);\n        | -  sbi_hart_switch_mode(hartid, scratch->next_arg1, scratch->next_addr,\n\t\t\t     scratch->next_mode, FALSE);  \"主核进下一级 uboot, 跳入uboot_entry, 携带uboot.itb中的dtb下到的地址\"\n   -|+ else !codeboot  \n     \\ -+ init_warmboot(scratch, hartid); \"其他从核进\"\n        \\ -  wait_for_coldboot(scratch, hartid); \"等主核 wake_coldboot_harts\"\n        | -  hstate = sbi_hsm_hart_get_state(sbi_domain_thishart_ptr(), hartid); \n                  \"从 hartid_to_domain_table[__hartid] 中拿hart的初始hsm_state\"\n        | -|+ if (hstate == SBI_HSM_STATE_SUSPENDED)\n            \\ -  init_warm_resume(scratch);  \"从核是suspend状态时, 即从核从挂起状态唤醒, 走resume\"\n        | -|+ else != SBI_HSM_STATE_SUSPENDED \"第一次起来时为 SBI_HSM_STATE_STOPED 状态\"\n            \\ -+ init_warm_startup(scratch, hartid); \"从核第一次boot时, 走startup\"\n               \\ -  sbi_platform *plat = sbi_platform_ptr(scratch); \n               | -+ sbi_hsm_init(scratch, hartid, FALSE);\n                  \\ -+ sbi_hsm_hart_wait(scratch, hartid);\n                     \\ -  csr_set(CSR_MIE, MIP_MSIP | MIP_MEIP); \"Set MSIE and MEIE bits to receive IPI\"\n                     \\ -+ while (atomic_read(&hdata->state) != SBI_HSM_STATE_START_PENDING)\n                        \\ -  wfi(); \"从核的opensbi第一次boot会停在这里, 等待接收ipi, 但是ipi 处理函数并不会置 state, \n                      只有ecall SBI_EXT_HSM_HART_START才会设置state 为 SBI_HSM_STATE_START_PENDING,并发起ipi\"\n               | -  sbi_platform_early_init(plat, FALSE);\n               | -  sbi_hart_init(scratch, FALSE);\n               | -  sbi_pmu_init(scratch, FALSE);\n               | -  sbi_irqchip_init(scratch, FALSE);\n               | -  sbi_ipi_init(scratch, FALSE);\n               | -  sbi_tlb_init(scratch, FALSE);\n               | -  sbi_timer_init(scratch, FALSE);\n               | -  sbi_platform_final_init(plat, FALSE);\n               | -  sbi_hsm_prepare_next_jump(scratch, hartid);  \n                    \"检查hsm_state 是否为 SBI_HSM_STATE_START_PENDING, \n                    如果是的话, 设置为 SBI_HSM_STATE_STARTED; 如果不是 将从核hang住\"\n        | -  sbi_hart_switch_mode(hartid, scratch->next_arg1, scratch->next_addr, scratch->next_mode, FALSE); \n               \"从核跳下一级, 注意ecall SBI_EXT_HSM_HART_START 的消息会重新设置 scratch的 next_arg1, next_addr, next_mode\"       \n```\n\n主从核的boot 走了不同的分支, 主核走`init_coldboot`, 从核走`init_warm_startup`\n只有主核才跳入了uboot, 从核停在了检查hsm_state 为 `SBI_HSM_STATE_START_PENDING`的地方.\n只有主核发 ecall SBI_EXT_HSM_HART_START, 主核设置了从核hartid 所属的scratch space中的hsm_state为  `SBI_HSM_STATE_START_PENDING` , 再把从核叫起后, 从核才会接着往下走.\necall SBI_EXT_HSM_HART_START 的消息会重新设置 scratch的 next_arg1, next_addr, next_mode, 对应kernel的情况, 将next_arg1 设置为了 kernel的封装的私有数据地址, next_addr 设置为 secondary_start_sbi 地址, next_mode 设置为S-mode.\nscratch的设置最终会影响到 sbi_hart_switch_mode 函数跳入下一级.\n\n从目前的逻辑看, 从核貌似并没有机会进uboot, uboot里面只是发了ipi中断, 并没有ecall SBI_EXT_HSM_HART_START 的过程.\n从核会直接跳到kernel中. 从逻辑上看, 从核也没有必要进uboot, 因为uboot是S-mode的, 它只是一个中间态.\n\n# 启动链\n\nsifive的信息, opensbi 0x80000000 uboot 0x80200000 kernel 先load到 0x84000000, relocate 到 0x80200000 执行\nkernel 先从物理地址上运行, 执行`relocate_enable_mmu` 后, 再从虚拟地址执行\nkernel 的map信息记录的都是虚拟地址, 在enable_mmu 之前, 只能进行相对跳转.\n\n# kernel before mmu 加载流程\n```c\n__HEAD\nENTRY(_start)\n        /*\n         * Image header expected by Linux boot-loaders. The image header data\n         * structure is described in asm/image.h.\n         * Do not modify it without modifying the structure and all bootloaders\n         * that expects this header format!!\n         */\n        /* jump to start kernel */\n        j _start_kernel\n        /* reserved */\n        .word 0\n        .balign 8\n#if __riscv_xlen == 64\n        /* Image load offset(2MB) from start of RAM */\n        .dword 0x200000\n#else\n        /* Image load offset(4MB) from start of RAM */\n        .dword 0x400000\n#endif\n        /* Effective size of kernel image */\n        .dword _end - _start\n        .dword __HEAD_FLAGS\n        .word RISCV_HEADER_VERSION\n        .word 0\n        .dword 0\n        .ascii RISCV_IMAGE_MAGIC\n        .balign 4\n        .ascii RISCV_IMAGE_MAGIC2\n        .word 0\n```\n\n.head.text section 开头为构建的PE header, \n我们可以找到RISC-V架构的启动协议`Documentation/riscv/boot-image-header.txt`。事实上这个文件只是简单介绍了一下`Image`文件header的结构，更详细的启动协议还是处于TODO状态，我们需要从代码进行分析。前面提到RISC-V内核比较类似于ARM64内核的格式，如下：\n\n```c\n        u32 code0;                /* Executable code */\n        u32 code1;                /* Executable code */\n        u64 text_offset;          /* Image load offset, little endian */\n        u64 image_size;           /* Effective Image size, little endian */\n```\n\n从bootloader的角度，装载并执行`Image`类型的内核只需要做两件事情：\n\n-   将整个`Image`文件放置到内存起始处向后偏移`text_offset`的内存地址\n-   跳转到`code0`的地址进行执行\n\n后续的事情，内核自理。我们看到`head.S`中有如下代码：\n`code0`和`code1`放置的就是`j _start_kernel`生成的指令。那么我们就需要从`_start_kernel`开始看起。\n\n`_start_kernel`可以看到，一开始主要做了三件事：\n1.  关闭所有的中断\n2.  设置gp寄存器指向对应的地址（该寄存器为ABI相关，用于存放`__global_pointer$`的地址，即GOT的位置，可以参考[RISCV调用协定](https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md)）\n3.  关闭FPU，内核中是不用任何浮点指令的\n\nbootloader将控制权交给内核时，`a0`寄存器保存的值即为当前CPU执行单元的ID（RISC-V中称为HART ID）。\n`_start_kernel`接下来就开始执行一个简单的`Boot Protocol`，选出一个用于启动内核的CPU，其他CPU进入等待状态。RISC-V处理器在reset之后，所有的处理单元（HART）都会一起开始执行，而Linux内核启动时为主从模型，因此需要挑选出其中一个完成部分内核启动工作，之后告知其他的处理器继续执行开始处理任务。首先确定CPU ID是否合法，即有没有超出内核编译时选择的最大支持CPU数，如果超过则非法：\n```c\n#ifdef CONFIG_SMP\n        li t0, CONFIG_NR_CPUS\n        blt a0, t0, .Lgood_cores\n        tail .Lsecondary_park\n.Lgood_cores:\n#endif\n```\n`.Lsecondary_park`分支实质上是循环调用`wfi`指令。接下来内核使用一个简单的策略选出用于启动的主CPU：先到先得。`setup.c`中定义了一个原子变量：\n```c\natomic_t hart_lottery __section(.sdata);\n```\n所有CPU都会试图通过原子操作将这个变量加1。RISC-V的原子操作指令会将原子变量的原有值保存在原子变量的目标寄存器中，也就是说，如果操作后目标寄存器的值为0的CPU为第一对其进行操作的CPU。\n\n```c\n        /* Pick one hart to run the main boot sequence */\n        la a3, hart_lottery\n        li a2, 1\n        amoadd.w a3, a2, (a3)\n        bnez a3, .Lsecondary_start\n```\n对于所有竞争失败的CPU，我们在后面进行分析，目前还是顺着主CPU进行分析。随后主CPU的操作基本如下：\n-   清空bss段，写为0\n-   设置临时内核栈与`task_struct`\n-   依次调用`setup_vm`以及`relocate_enable_mmu`设置内核的虚拟内存\n调用完 relocate_enable_mmu 后, mmu 已经准备完, 此时已经为整个kernel 运行空间建立了完整的页表映射.\n从`_start` 到 `_end`  0xffffffff80000000 - 0xffffffff81345000\n\n最后调用C语言通用代码启动内核：\n```c\n\t\tla tp, init_task \"init_task 初始的 task_struct, 即内核的第一个任务（`init/init_task.c`）\"\n\t\tla sp, init_thread_union + THREAD_SIZE \n\t\t     \"init_thread_union是通过链接脚本留出的一个PAGE（riscv平台上为4KB）大小的区域，用以充当临时内核栈\"\n        /* Start the kernel */\n        call soc_early_init\n        tail start_kernel \"启动内核\"\n```\n\n> tp 寄存器的作用: Supervisor模式下的用途：保存当前CPU运行的进程上下文，即`task_struct`结构体。查看`asm/current.h`\n\n```c\ncreate_pte_mappingstatic __always_inline struct task_struct *get_current(void)\n{\n        register struct task_struct *tp __asm__(\"tp\");\n        return tp;\n}\n```\n\n## setup_vm\n\n将内核所在的物理地址映射到PAGE_OFFSET所在虚拟地址区域\n（即将内核二进制所在的物理地址加上一个PAGE_OFFSET减去_start所的的偏移量）。因此，这里的任务实质上是建立一个临时页表，即内核临时的虚拟地址空间映射\n```erlang\nmv s1, a1    \"a1 寄存器是opensbi  传过来的fdt 的物理地址\"\nmv a0, s1 \ncall setup_vm\n-+ setup_vm(dtb_pa)\n \\ -  kernel_map.virt_addr = KERNEL_LINK_ADDR ; \"0xffffffff800000000\"\n | -  kernel_map.page_offset = _AC(CONFIG_PAGE_OFFSET, UL); \"0xff60000000000000\"\n | -  kernel_map.phys_addr = (uintptr_t)(&_start); \"0x80200000\"\n | -  kernel_map.size = (uintptr_t)(&_end) - kernel_map.phys_addr; \"kernel bin size\"\n | -  BUG_ON((kernel_map.phys_addr % PMD_SIZE) != 0); \"检查物理地址2M字节对齐\"\n | -+ set_satp_mode(); \"检查是否支持4级页表\"\n | -  kernel_map.va_pa_offset = PAGE_OFFSET - kernel_map.phys_addr; \"0xff60000000000000 - 0x80200000\"\n | -  kernel_map.va_kernel_pa_offset = kernel_map.virt_addr - kernel_map.phys_addr; \n                         \"0xffffffff800000000 - 0x80200000\"\n | -  riscv_pfn_base = PFN_DOWN(kernel_map.phys_addr); \"右移一个page 0x80200\"\n | -+ pt_ops_set_early();                    \n \t\\ -  pt_ops.alloc_pte = alloc_pte_early; \" allc_pte_early里面是BUG(),对于临时页表，kernel不允许我们建立PTE\n \t                                          临时页表, 只用到大页\"\n \t| -  pt_ops.get_pte_virt = get_pte_virt_early;\n | -  create_pgd_mapping(early_pg_dir, FIXADDR_START, fixmap_p4d, PGDIR_SIZE, PAGE_TABLE); \n                    \"FIXADDR_START 0xff1bfffffee00000 - fixmap_p4d pa 映射, early_pg_dir为基址\"\n | -  create_p4d_mapping(fixmap_p4d, FIXADDR_START, fixmap_pud, P4D_SIZE, PAGE_TABLE);\n | -  create_pud_mapping(fixmap_pud, FIXADDR_START, fixmap_pmd, PUD_SIZE, PAGE_TABLE);\n | -  create_pmd_mapping(fixmap_pmd, FIXADDR_START, fixmap_pte, PMD_SIZE, PAGE_TABLE); \n                \"建立了0xff1bfffffee00000 开始的 2M的大页     FIXADDR_START - fixmap_pte 映射\"\n | -  create_pgd_mapping(trampoline_pg_dir, kernel_map.virt_addr, \n                            trampoline_p4d, PGDIR_SIZE, PAGE_TABLE);\n | -  create_p4d_mapping(trampoline_p4d, kernel_map.virt_addr,\n\t\t\t\t            trampoline_pud, P4D_SIZE, PAGE_TABLE);\n | -  create_pud_mapping(trampoline_pud, kernel_map.virt_addr,\n\t\t\t\t            trampoline_pmd, PUD_SIZE, PAGE_TABLE);\t\t\t\t                              \t\t\t\t   \t\t\t\t   \n | -  create_pmd_mapping(trampoline_pmd, kernel_map.virt_addr,\n\t\t\t                kernel_map.phys_addr, PMD_SIZE, PAGE_KERNEL_EXEC);\n\t\t\t\"建立了 trampoline_pg_dir 为pgd 的 指向 kernel_map.virt_addr (0xffffffff800000000) 开始的2M的大页  \n\t\t\t kernel_map.virt_addr - kernel_map.phys_addr   0xffffffff800000000 - 0x80200000 映射\"        \n | -+ create_kernel_page_table(early_pg_dir, true); \n           \"建立了以 early_pg_dir 为pgd的页表映射, 为整个kernel bin 建立连续页表映射 early_pg_dir 地址 0x80c08000\n            0xffffffff800000000 - 0x80200000 映射\"\n    \\ -  end_va = kernel_map.virt_addr + kernel_map.size;\n    | -+ for (va = kernel_map.virt_addr; va < end_va; va += 2M)\n       \\ -  create_pgd_mapping(pgdir, va, \"va 虚拟地址\"\n\t\t\t\t   kernel_map.phys_addr + (va - kernel_map.virt_addr), \"对应的物理地址\"\n\t\t\t\t   PMD_SIZE, \"2M\"\n\t\t\t\t   early ? \tPAGE_KERNEL_EXEC : pgprot_from_va(va)); \"PAGE_KERNEL_EXEC 表示大页, 一个大页是2M\"\n | -  create_fdt_early_page_table(early_pg_dir, dtb_pa); \"为dtb 创建页表\"\n | -+ pt_ops_set_fixmap()\n    \\ -  pt_ops.alloc_pte = kernel_mapping_pa_to_va((uintptr_t)alloc_pte_fixmap);\n    | -  pt_ops.get_pte_virt = kernel_mapping_pa_to_va((uintptr_t)get_pte_virt_fixmap); \n             \t\t\t   \t\t   \t\t   \t\t   \t\t\n```\n\n上述过程中可以了解到最简单的一种建立五级页表映射的代码: pgd 为 trampoline_pg_dir, 建立虚拟地址 kernel_map.virt_addr 同 物理地址 kernel_map.phys_addr 的映射关系, 翻译过程为 satp-> trampoline_pg_dir -> trampoline_p4d -> trampoline_pud -> trampoline_pmd\n\n```c\n | -  create_pgd_mapping(trampoline_pg_dir, kernel_map.virt_addr, \n                            trampoline_p4d, PGDIR_SIZE, PAGE_TABLE);\n | -  create_p4d_mapping(trampoline_p4d, kernel_map.virt_addr,\n\t\t\t\t            trampoline_pud, P4D_SIZE, PAGE_TABLE);\n | -  create_pud_mapping(trampoline_pud, kernel_map.virt_addr,\n\t\t\t\t            trampoline_pmd, PUD_SIZE, PAGE_TABLE);\t\t\t\t                              \t\t\t\t   \t\t\t\t   \n | -  create_pmd_mapping(trampoline_pmd, kernel_map.virt_addr,\n\t\t\t                kernel_map.phys_addr, PMD_SIZE, PAGE_KERNEL_EXEC);\n```\n\n建立映射时传入了 PGDIR_SIZE P4D_SIZE PUD_SIZE PMD_SIZE 这几个size 导致 create_pgd_mapping create_p4d_mapping create_pud_mapping create_pmd_mapping 函数只填充了数据里的元素, 并没有走后面的流程.\n\n以 create_pgd_mapping 为例, 其中 PAGE_TABLE 表示页目录, PAGE_KERNEL_EXEC 表示该级为叶子页表项\n```c\n    uintptr_t pgd_idx = pgd_index(va);\n\tif (sz == PGDIR_SIZE) {\n\t\tif (pgd_val(pgdp[pgd_idx]) == 0)\n\t\t\tpgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pa), prot);\n\t\treturn;\n\t}\n\t...\n```\n\n\nsv48 和 sv57 对应 4level 和 5level mmu 映射:\n| 线性地址     | mmu 层级                             | Linux user address space                  | Linux kernel address space                |\n| :----------- | :----------------------------------- | :---------------------------------------- | :---------------------------------------- |\n| Sv48 (48bit) | 4level: pgd→pud→pmd→pte→page(4k)     | 0x00000000 00000000 - 0x00007FFF FFFFFFFF | 0xFFFF8000 00000000 - 0xFFFFFFFF FFFFFFFF |\n| Sv57 (57bit) | 5level: pgd→p4d→pud→pmd→pte→page(4k) | 0x00000000 00000000 - 0x00FFFFFF FFFFFFFF | 0xFF000000 00000000 - 0xFFFFFFFF FFFFFFFF |\n\n>in sv57: PMD_SIZE = 1<<21 PUD_SIZE = 1<<30 P4D_SIZE = 1<<39 PGDIR_SIZE = 1<<48\n\n```c\nvoid __init create_pgd_mapping(pgd_t *pgdp,\n\t\t\t\t      uintptr_t va, phys_addr_t pa,\n\t\t\t\t      phys_addr_t sz, pgprot_t prot)\n{\n\tpgd_next_t *nextp;\n\tphys_addr_t next_phys;\n\tuintptr_t pgd_idx = pgd_index(va);\n\n\tif (pgd_val(pgdp[pgd_idx]) == 0) {\n\t\tnext_phys = alloc_pgd_next(va); // 调用 pt_ops.alloc_p4d(__va), 返回 early_p4d\n\t\tpgdp[pgd_idx] = pfn_pgd(PFN_DOWN(next_phys), PAGE_TABLE);\n\t\tnextp = get_pgd_next_virt(next_phys); // pt_ops.get_p4d_virt return early_p4d\n\t\tmemset(nextp, 0, PAGE_SIZE);\n\t} else {\n\t\tnext_phys = PFN_PHYS(_pgd_pfn(pgdp[pgd_idx]));\n\t\tnextp = get_pgd_next_virt(next_phys);\n\t}\n\n\tcreate_pgd_next_mapping(nextp, va, pa, sz, prot);\n\t\tcreate_p4d_mapping(__nextp, __va, __pa, __sz, __prot)\n\t\t\tcreate_pud_mapping(nextp, va, pa, sz, prot);\n\t\t\t\tcreate_pmd_mapping(nextp, va, pa, sz, prot);\n\t\t\t\t\tcreate_pte_mapping(ptep, va, pa, sz, prot);\n\t}\n}\n\nstatic void __init create_pmd_mapping(pmd_t *pmdp,\n\t\t\t\t      uintptr_t va, phys_addr_t pa,\n\t\t\t\t      phys_addr_t sz, pgprot_t prot)\n{\n\tpte_t *ptep;\n\tphys_addr_t pte_phys;\n\tuintptr_t pmd_idx = pmd_index(va);\n\n\tif (sz == PMD_SIZE) {   //这个地方满足条件 sz=PMD_SIZE=2M\n\t\tif (pmd_none(pmdp[pmd_idx]))\n\t\t\tpmdp[pmd_idx] = pfn_pmd(PFN_DOWN(pa), prot); \"赋值大页\"\n\t\treturn;\n\t}\n    ...\n}\n```\n对于sv57 模式, pgd -> p4d -> pud -> pmd -> pte\n\n每一级页 page 4k, 每个页项 占8个字节, 所以每一级可以代表 4k/8 = 512个页项\n一个pte 项可以索引 4k \n对于pmd 可表示 4k * 512 = 2M 地址字节\n对于pud 可表示 4k * 512 * 512 = 1G 地址字节\n\n对于kernel 本身而言, 其 bin 文件大概在128M 之内, 对于bin对应的连续物理地址, pmd 前面的pgd p4d pud仅需要一个页项就可以能表示这些物理地址了, 所以前面建页表过程可以看到只有一个early_pg_dir early_p4d early_pud, 到pmd 这一级才会分多个 pmd 多个pte 出来.\n\nsv57 in RV64:\n\n- satp.PPN 给出了一级页表的基址, VA[56:48]给出了一级页号, 因此处理器会读取位于地址(satp.PPN × 4096 + VA[56:48] × 8)的页表项 pgd\n- pgd.PPN 给出了二级页表的基址, VA[47:39]给出了二级页号, 因此处理器会读取位于地址(pgd.PPN × 4096 + VA[47:39] × 8)的页表项 p4d\n- p4d.PPN 给出了三级页表的基址, VA[38:30]给出了三级页号, 因此处理器会读取位于地址(p4d.PPN × 4096 + VA[38:30] × 8)的页表项 pud\n- pud.PPN 包含四级页表的基址, VA[29:21]给出了四级页号, 因此处理器读取位于地址(pud.PPN × 4096 + VA[29:21] × 8)的页表项 pmd\n- pmd.PPN 包含了五级页表的基址, VA[20:12] 给出了五级页号, 处理器读取位于地址(pmd.PPN × 4096 + VA[20:12] × 8)的页表项 pte\n- 该页表项的PTE. PPN 就是物理地址对应的PPN * 4096 + VA[offset 11:0]得到物理地址\nsv57 上. 虚拟地址范围 57 位, 0-56 位 , 物理地址范围 56位(44位的PPN + 12位的offset), 0-55 位\n\n上述页表建立过程中用到了大页, 在pmd 一级中, 最后的prot 赋值为了 `PAGE_KERNEL_EXEC`, \n其组合为 V | R | A | W | G | X | D\n\n```c\n_PAGE_READ | _PAGE_WRITE | _PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_GLOBAL | _PAGE_EXEC\n```\n\nPTE 描述: 对应(pgd/p4d/pud/pmd/pte)项\n![image-20240416113156489](attachments/image-20240416113156489.png)\n启用大页时, 在页项 V=1, 且RWX 不为0时, 表示为叶页表项\n对于pmd 一级大页, pmd.PPN 包含了五级页表的基址, 地址(pmd.PPN × 4096 + VA[20:0]) 即是 va 对应的 物理地址.\npmd 大页可索引2M的地址字节.\n\n\n>setup_vm()在最开始就进行了kernel入口地址的对齐检查，要求入口地址2M对齐。假设内存起始地址为0x80000000，那么kernel只能放在0x80000000、0x80200000等2M对齐处。为什么会有这种对齐要求呢？  \n应该是为给opensbi预留了2M空间，因为kernel之前还有opensbi，而opensbi运行完之后，默认跳转地址就是偏移2M，kernel只是为了跟opensbi对应，所以设置了2M对齐。  \nopensbi需要占用2M这么大？实际上只需要几百KB，因此opensbi和kernel中间有一段内存是空闲的，没有人使用。\n\n上述setup_vm 操作最主要的是建立了kernel的临时页表, 页表遍历需要从early_pg_dir 的pgd 开始\n\n## relocate_enable_mmu\n\n```c\nla a0, early_pg_dir\nrelocate_enable_mmu:\n\tla a1, kernel_map       \"a1 -  0xffffffff80da0198 - 0xffffffff800000000 + 0x80200000 = 0x80fa0198\"\n\tXIP_FIXUP_OFFSET a1\n\tREG_L a1, KERNEL_MAP_VIRT_ADDR(a1) \"load a1,  \"a1 变为 0xffffffff80000000\"\"\n\tla a2, _start           \"a2 -  0x80200000\"\n\tsub a1, a1, a2          \"a1 = a1-a2, a1 为 offset 虚拟地址与物理地址 offset\"\n\tadd ra, ra, a1          \"ra = ra + offset, 这个函数返回时就会用虚拟地址了, 所以直接+上面的offset由物理地址变到物理地址\"   \n\n\t/* Point stvec to virtual address of intruction after satp write */\n\tla a2, 1f              \"a2 为 label 1 物理地址\"\n\tadd a2, a2, a1         \"a2 = a2 + offset\"\n\tcsrw CSR_TVEC, a2      \"a2 0xffffffff80001048 写入stvec\"\n\n\t/* Compute satp for kernel page tables, but don't load it yet */\n\tsrl a2, a0, PAGE_SHIFT   \"a2 = a0 >> PAGE_SHIFT 构造PPN, a0 为 early_pg_dir\"\n\tla a1, satp_mode         \"satp_mode 中保存分页模式 为sv39/sv48/sv57等\"\n\tREG_L a1, 0(a1)          \"取出satp_mode 中存的 分页模式\"\n\tor a2, a2, a1            \"分页模式 | ASID(NULL) | PPN \" \"a2 MODE(0xa0) | ASID(0) | PPN(0x80c08)\" 为sv57模式\n\n\t/*\n\t * Load trampoline page directory, which will cause us to trap to\n\t * stvec if VA != PA, or simply fall through if VA == PA.  We need a\n\t * full fence here because setup_vm() just wrote these PTEs and we need\n\t * to ensure the new translations are in use.\n\t */\n\tla a0, trampoline_pg_dir \"a0 为 trampoline_pg_dir 物理地址 0x814e9000\"\n\tXIP_FIXUP_OFFSET a0\n\tsrl a0, a0, PAGE_SHIFT   \"取出页号 PPN 为 0x814e9\"\n\tor a0, a0, a1        \"trampoline_pg_dir satp  分页模式 | ASID(NULL) | PPN\" \n\t                     \"a0 MODE(0xa0) | ASID(0) | PPN(0x814e9)\"\n\tsfence.vma\n\tcsrw CSR_SATP, a0    \"启用trampoline_pg_dir pgd 页表, 这个只映射了 kernel bin的前2M 数据\"   \n1:\n\t/* Set trap vector to spin forever to help debug */\n\tla a0, .Lsecondary_park\n\tcsrw CSR_TVEC, a0\n\t/* Reload the global pointer */\n.option push\n.option norelax\n\tla gp, __global_pointer$\n.option pop\n\n\t/*\n\t * Switch to kernel page tables.  A full fence is necessary in order to\n\t * avoid using the trampoline translations, which are only correct for\n\t * the first superpage.  Fetching the fence is guaranteed to work\n\t * because that first superpage is translated the same way.\n\t */\n\tcsrw CSR_SATP, a2  \"启用 early_pg_dir pgd 页表, 映射了完整的kernel bin\"\n\tsfence.vma\n\n\tret\n```\n\n\n## 临时页表分析\n\nMMU开启前，需要建立好kernel、dtb、trampoline等页表。以便MMU开启后，并且在内存管理模块运行之前，kernel可以正常初始化，dtb可以正常地被解析。这部分页表都是临时页表，最终的页表在setup_vm_final()建立。\n\n临时页表创建顺序：\n\n首先为fixmap创建早期的PGD、PMD，这时PGD使用`early_pg_dir`。然后对从kernel开始的前2M内存建立二级页表，此时PGD使用`trampoline_pg_dir`，为这2M建立的页表也叫作`superpage`。再然后，对整个kernel创建二级页表，此时PGD使用`early_pg_dir`。最后为dtb预留4M大小创建二级页表。\n\n内存布局:\n```shell\n[    0.000000]       fixmap : 0xff1bfffffee00000 - 0xff1bffffff000000   (2048 kB)\n[    0.000000]       pci io : 0xff1bffffff000000 - 0xff1c000000000000   (  16 MB)\n[    0.000000]      vmemmap : 0xff1c000000000000 - 0xff20000000000000   (1024 TB)\n[    0.000000]      vmalloc : 0xff20000000000000 - 0xff60000000000000   (16384 TB)\n[    0.000000]       lowmem : 0xff60000000000000 - 0xff6000007fe00000   (2046 MB)\n[    0.000000]      modules : 0xffffffff01345000 - 0xffffffff80000000   (2028 MB)\n[    0.000000]       kernel : 0xffffffff80000000 - 0xffffffffffffffff   (2047 MB)\n```\n\n\n附录: \nrelocate_enable_mmu 汇编分析\n\n```c\n   0x80201000:  auipc   a1,0xd9f\n   0x80201004:  addi    a1,a1,408   \"a1 0x80fa0198\"\n   0x80201008:  ld      a1,8(a1)    \"a1 = 0xffffffff80000000\"\n   0x8020100a:  auipc   a2,0xfffff   \n   0x8020100e:  addi    a2,a2,-10   \"a2 = 0x80200000\" \n   0x80201012:  sub     a1,a1,a2    \"a1 0xfffffffeffe00000  虚拟地址与物理地址的offset\"\n   0x80201014:  add     ra,ra,a1    \"ra 0xffffffff80001134\"\n   0x80201016:  auipc   a2,0x0\n   0x8020101a:  addi    a2,a2,50\n   0x8020101e:  add     a2,a2,a1\n   0x80201020:  csrw    stvec,a2    \"a2 0xffffffff80001048 写入stvec\"\n   0x80201024:  srli    a2,a0,0xc   \"a0 0x80c08000 a2 0x80c08\"\n   0x80201028:  auipc   a1,0xd9f    \n   0x8020102c:  addi    a1,a1,432   \"a1 0x80fa01d8 存satp_mode的地址\"\n   0x80201030:  ld      a1,0(a1)    \"satp_mode 0xa000000000000000\"\n   0x80201032:  or      a2,a2,a1    \"a2 MODE(0xa0) | ASID(0) | PPN(0x80c08)\"\n   0x80201034:  auipc   a0,0x12e8   \n   0x80201038:  addi    a0,a0,-52   \"a0 trampoline_pg_dir 0x814e9000 - 0x80200000 实际位置\"\n   0x8020103c:  srli    a0,a0,0xc   \"a0 0x814e9\"\n   0x8020103e:  or      a0,a0,a1    \"a0 MODE(0xa0) | ASID(0) | PPN(0x814e9)\"\n   0x80201040:  sfence.vma \n   0x80201044:  csrw    satp,a0     \"写页表 MODE(0xa0) | ASID(0) | PPN(0x814e9), MMU被启用，这使得访问原有物理地址时触发异常并跳转到中断向量 0xffffffff80001048\" \n   0x80201048:  auipc   a0,0x0\n   0x8020104c:  addi    a0,a0,124\n   0x80201050:  csrw    stvec,a0\n   0x80201054:  auipc   gp,0x12de\n   0x80201058:  addi    gp,gp,324\n   0x8020105c:  csrw    satp,a2\n   0x80201060:  sfence.vma\n   0x80201064:  ret\n```\n\n# kernel setup_arch\n\nLinux内核的codebase可以简单分成两个部分：架构相关部分和架构无关部分。为了支持多个架构，且最大限度地公用代码，又保留架构相关实现的灵活性，Linux内核的实现经过了精细的设计。内核底层对一些架构相关的操作进行了抽象，向内核通用代码提供了公共的接口。每一个内核支持的架构都对应一个`arch/`下的文件夹，里面存放着本架构相关的代码。\n\n内核实现多架构支持的手段：\n\n-  条件编译。这个方法主要用在一些极端特殊场合，多用于驱动对特定平台的区别操作。内核提供了一些宏，用于检测当前架构。\n-  weak函数。这个方法利用了ELF object文件中的`weak symbol`，具有这个属性的`symbol`在链接时，如果链接器可以在所有进行链接的object文件中找到同名`symbol`，则会用这个`symbol`把`weak symbol`顶替掉。内核使用`__weak`（本质就是一个GCC扩展）标记weak函数。内核可以对所有架构实现一个通用的weak函数，如果有架构需要一个自己的版本，则可以直接定义，并将其顶替。\n-  平台相关函数。这类函数为强平台相关，内核一般定义一个共同函数原型及函数语意，由各架构自行实现该函数。这里其实也包括一部分宏。\n\n```erlang\ndtb_early_va = (void *)DTB_EARLY_BASE_VA + (dtb_pa & (PMD_SIZE - 1));\n-+ setup_arch(char **cmdline_p)\n \\ -+ parse_dtb();\n    \\ -+ early_init_dt_scan(dtb_early_va) \"前面在创建临时页表时已经为 DTB_EARLY_BASE_VA - dtb_pa 建立了 4M (2个PMD_SIZE) 的大页映射\"\n       \\ -  early_init_dt_verify(params); \"检查设备树的合法性\"\n       | -+ early_init_dt_scan_nodes()\n          \\ -  early_init_dt_scan_root(); \"Initialize {size,address}-cells info\"\n          | -  early_init_dt_scan_chosen(boot_command_line); \n               \"扫描设备树的`chosen`节点，获取内核命令行，initrd等关键信息，其中内核并命令行被保存在`boot_command_line`字符数组中\"\n          | -+ early_init_dt_scan_memory();\n               \"获取设备树中关于内存的描述，并调用`early_init_dt_add_memory_arch`\"\n             \\ -+ early_init_dt_add_memory_arch() \n                 \"使用了内核默认的实现，即将内核区域添加到`memblock`中。也就是说，RISC-V架构下的启动内存管理器是memblock，memblock的实现比较独立\"               \n          | -  early_init_dt_check_for_usable_mem_range(); \n                 \"Handle linux,usable-memory-range property\"\n | -  parse_early_param(); \"用于解析`early param`。内核中的`early param`都会特殊标记起来，保存在一个特殊的section里，\n                           在内核启动初期从内核命令行解析出来。\"\n | -+ paging_init() \"初始化页表\"\n    \\ -+ setup_bootmem(); \"初始化memblock\"\n       \\ -  phys_addr_t vmlinux_start = __pa_symbol(&_start); \n                \"找到_start对应的物理地址, 这个地方因为已经启用了mmu, &_start相对寻址为虚拟地址, 需要将其转换为物理地址\"\n       | -  phys_addr_t vmlinux_end = __pa_symbol(&_end);\n       | -  phys_ram_end = memblock_end_of_DRAM();\n       | -  phys_ram_base = memblock_start_of_DRAM();\n       | -  min_low_pfn = PFN_UP(phys_ram_base); \"最小pfn 页号\"\n       | -  max_low_pfn = max_pfn = PFN_DOWN(phys_ram_end); \"最大pfn页号\"\n       | -  high_memory = (void *)(__va(PFN_PHYS(max_low_pfn)));\n       | -  dma32_phys_limit = min(4UL * SZ_1G, (unsigned long)PFN_PHYS(max_low_pfn));\n       | -  memblock_reserve(dtb_early_pa, fdt_totalsize(dtb_early_va)); \"保留early dtb 物理地址映射\"\n       | -  early_init_fdt_scan_reserved_mem(); \n             \"设备树中存在`reserved memory`的描述，通过该函数扫描fdt 中 reserved memory描述，然后将对应参数进行保留\"\n       | -  dma_contiguous_reserve(dma32_phys_limit);     \n    | -+ setup_vm_final();  \"将memblock中管理的内存添加到到`swapper_pg_dir`页表中，然后启用该页表\"                     \n       \\ -  create_pgd_mapping(swapper_pg_dir, FIXADDR_START, __pa_symbol(fixmap_p4d), PGDIR_SIZE, PAGE_TABLE);\n                 \"swapper_pg_dir pgd 中建立 FIXADDR_START -> fixmap_p4d的页目录\"\n\t   | -+ for_each_mem_range(i, &start, &end)\n\t      \\ -  map_size = best_map_size(start, end - start);\n\t      | -+ for (pa = start; pa < end; pa += map_size)\n\t         \\ -  create_pgd_mapping(swapper_pg_dir, va, pa, map_size, pgprot_from_va(va));\n\t   | -  create_kernel_page_table(swapper_pg_dir, false); \"第二次调用这个函数, 与第一次的区别early 为false, 这个地方的意思是又映射了一遍\n\t                       只不过pgd 由early_pd_dir 变成了 swapper_pg_dir, \n\t                       而early 为false, prot 由 PAGE_KERNEL_EXEC 变成pgprot_from_va(va), \n\t                       由于此时的va还是查的early_pg_dir 的prot, 落到pmd 一级仍然是 PAGE_KERNEL_EXEC, 即这个地方还是大页\"\n\t   | -  csr_write(CSR_SATP, PFN_DOWN(__pa_symbol(swapper_pg_dir)) | satp_mode); \"启用swapper_pg_dir 页表\"\n\t   | -  local_flush_tlb_all(); \"清tlb\"\n\t   | -+ pt_ops_set_late();\n\t      \\ -+ pt_ops.alloc_pte = alloc_pte_late; \"在 pt_ops_set_early 时不允许分配pte, 只能分配大页, 到这里允许分配pte了\"\n\t         \\ ---+ alloc_pte_late(va)\n\t              \\ -  vaddr = __get_free_page(GFP_KERNEL); \"调用分配内存函数分配虚拟地址\"\n\t              | -  return __pa(vaddr);                  \"返回pte的物理地址\"\n\t      | -  pt_ops.get_pmd_virt = get_pmd_virt_late;\n\t      | -  pt_ops.alloc_pmd = alloc_pmd_late;\n\t      | -  pt_ops.alloc_pud = alloc_pud_late;\n\t      | -  pt_ops.alloc_p4d = alloc_p4d_late;\n\t      | -  ...\n | -  unflatten_device_tree(); \"该函数为OF模块的代码，目的是将设备树转换成更高效的内存中表示。\"\n | -  sbi_init(); \"sbi 探测版本 extension 支持feature, 设定sbi接口用来对接opensbi\"\n | -+ setup_smp(); \"多核初始化, fdt cpu node\"\n    \\ ---+ cpu_ops[cpuid] = &cpu_ops_sbi; \"注册cpu_ops\"\n         \\ ---+ kernel_init \"主核初始化完后, 会起一个task kernel_init\"\n              \\ -+ kernel_init_freeable\n                 \\ -+ smp_init()\n                    \\ -+ bringup_nonboot_cpus(setup_max_cpus);\n                       \\ -+ for_each_present_cpu(cpu)\n                          \\ -+ cpu_up(cpu, CPUHP_ONLINE)\n                             \\ -+ cpuhp_up_callbacks\n                                \\ -+ cpuhp_invoke_callback_range\n                                   \\ -+ cpuhp_invoke_callback\n                                      \\ -+ bringup_cpu\n                                         \\ -+ start_secondary_cpu(cpuid, task)\n\t\t\t\t\t\t\t\t\t         \\ -  boot_addr = __pa_symbol(secondary_start_sbi);\n\t\t\t\t\t\t\t\t\t         | -  sbi_hsm_hart_start(hartid, boot_addr, hsm_data);\n\t\t\t\t\t\t\t\t\t    ------------------------> other cpu <----------------------\n\t\t\t\t\t\t\t\t\t         \\ -  secondary_start_sbi\n\t\t\t\t\t\t\t\t\t         | -  secondary_start_common\n\t\t\t\t\t\t\t\t\t         | -+ smp_callin\n\t\t\t\t\t\t\t\t\t            \\ -  notify_cpu_starting(curr_cpuid);\n\t\t\t\t\t\t\t\t\t            | -  set_cpu_online(curr_cpuid, 1);\n\t\t\t\t\t\t\t\t\t            | -  cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);   \"idle 状态\"\n    ------------------------> other cpu <----------------------        \n | -  riscv_fill_hwcap() \"riscv hw 指令集探测 imafdc等\"\n \n \t      \n```\n\n前面看到内核在`setup_vm`中初始化了一个`early_pg_dir`页表，仅仅映射了内核所占用内存和一个FDT的fixmap，而`paging_init`中的`setup_vm_final`则是该操作的延续。首先明确使用两级初始化的原因：\n\n- 在没有读取设备树之前，内核是不知道物理内存的大小的。如果非要缩成一步，那么只能从内核所在内存结尾处开始，猜一个大小然后进行映射。这种实现有巨大的不确定性，并不是一个好的选择\n- 紧接上一条，这么做有可能需要映射一些不存在的内存区域，使得页表占用更多空间\n\n所以`setup_vm_final`的操作本质上就是将memblock中管理的内存添加到到`swapper_pg_dir`页表中，然后启用该页表。\n\n\n# riscv smp 初始化boot\n\n首先看下riscv kernel smp_call 从核的堆栈:\n\n```erlang\n#0  sbi_hart_switch_mode (arg0=arg0@entry=0, arg1=4265325392, next_addr=2149584998, next_mode=1, next_virt=next_virt@entry=0) at /home/liguang/program/riscv-lab/opensbi/lib/sbi/sbi_hart.c:736\n#1  0x000000008000087c in init_warmboot (hartid=<optimized out>, scratch=<optimized out>) at /home/liguang/program/riscv-lab/opensbi/lib/sbi/sbi_init.c:445\n#2  sbi_init (scratch=0x80039000) at /home/liguang/program/riscv-lab/opensbi/lib/sbi/sbi_init.c:515\n#3  0x00000000800003c4 in _start_warm () at /home/liguang/program/riscv-lab/opensbi/firmware/fw_base.S:501\n```\n\n从opensbi 开始说起:\n\n其他cpu M-mode 停在了 opensbi的 sbi_hsm_hart_wait 处, 初始hsm_state 为 `SBI_HSM_STATE_STOPPED`\n```c\nstruct sbi_hsm_data *hdata = sbi_scratch_offset_ptr(scratch, hart_data_offset);\nwhile (atomic_read(&hdata->state) != SBI_HSM_STATE_START_PENDING) {\n\twfi();\n};\n```\n\n当主cpu 从kernel `sbi_hsm_hart_start` 发送 `SBI_EXT_HSM_HART_START` extension 后, 将hartid `saddr=secondary_start_sbi` 以及封装的priv 私有数据地址 发送给了opensbi.\n\n主核的 opensbi 接收后将saddr 保存到了 opensbi 为hart 预留的scratch 空间的next_addr处, 将hsm_state变为 `SBI_HSM_STATE_START_PENDING`状态, 接着调用 ipi 给hartid 发送ipi中断.\n```c\n\trscratch = sbi_hartid_to_scratch(hartid);\n\trscratch->next_arg1 = priv;\n\trscratch->next_addr = saddr;\n\trscratch->next_mode = smode;\n\thdata = sbi_scratch_offset_ptr(rscratch, hart_data_offset);\n\thstate = atomic_cmpxchg(&hdata->state, SBI_HSM_STATE_STOPPED, SBI_HSM_STATE_START_PENDING);\t\n```\n\nhartid 的从核收到ipi 后, 设置了 MIP.SSIE位\n```c\nstatic void sbi_ipi_process_smode(struct sbi_scratch *scratch)\n{\n\tcsr_set(CSR_MIP, MIP_SSIP);\n}\n```\n退出中断上下文, 返回到了 `sbi_hsm_hart_wait`继续处理, 此时hsm_state为 `SBI_HSM_STATE_START_PENDING`, 退出wait 循环\n接着执行`sbi_hsm_hart_wait` 后面的函数, 最终执行到 `sbi_hart_switch_mode`\n\n```c\nsbi_hart_switch_mode(hartid, scratch->next_arg1, scratch->next_addr,\n\t\t\t     scratch->next_mode, FALSE);\n{\n\t\tcsr_write(CSR_STVEC, next_addr);\n\t\tcsr_write(CSR_SSCRATCH, 0);\n\t\tcsr_write(CSR_SIE, 0);\n\t\tcsr_write(CSR_SATP, 0);\n\tregister unsigned long a0 asm(\"a0\") = arg0;  \"hartid\"\n\tregister unsigned long a1 asm(\"a1\") = arg1;  \"scratch->next_arg1 = priv, priv为kernel传来的私有数据地址\"\n\t__asm__ __volatile__(\"mret\" : : \"r\"(a0), \"r\"(a1)); //跳到next_addr 即 secondary_start_sbi 执行\n}\n```","tags":["riscv","linux","spl"],"categories":["linux"]},{"title":"linux mmu pte 相关","url":"/2022/09/11/hxd_new/riscv调研/linux mmu pte 相关/","content":"\n# 内存分配\nkmalloc， vmalloc malloc\n\n## kmalloc\n\n基于 slab 分配器。 slab 缓存在一个连续物理地址的大块内存上。所以其缓存对象也是物理地址连续的。\n\n## vmalloc\n\n仅能保证虚拟地址连续\n\n### vmalloc 地址范围\n\nVMALLOC_START\nVMALLOC_END\n\n```log\n[    0.000000] Virtual kernel memory layout:\n[    0.000000]       fixmap : 0xff1bfffffea00000 - 0xff1bffffff000000   (6144 kB)\n[    0.000000]       pci io : 0xff1bffffff000000 - 0xff1c000000000000   (  16 MB)\n[    0.000000]      vmemmap : 0xff1c000000000000 - 0xff20000000000000   (1024 TB)\n[    0.000000]      vmalloc : 0xff20000000000000 - 0xff60000000000000   (16384 TB)   #vmalloc_start - vmalloc_endl\n[    0.000000]      modules : 0xffffffff01576000 - 0xffffffff80000000   (2026 MB)\n[    0.000000]       lowmem : 0xff60000000000000 - 0xff600000c0000000   (3072 MB)\n[    0.000000]       kernel : 0xffffffff80000000 - 0xffffffffffffffff   (2047 MB)\n```\n\n```erlang\n-+ vmalloc(unsigned long size)\n \\ -+ __vmalloc_node(size, align:1, GFP_KERNEL)\n    \\ -+ __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,...)\n       \\ -+ area = __get_vm_area_node(real_size, align, shift, VM_ALLOC | VM_UNINITIALIZED | vm_flags, start, end, node,\n          \\ -  struct vm_struct *area = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n          | -+ struct vmap_area *va = alloc_vmap_area(size, align, start, end, node, gfp_mask, 0); \"在 vmalloc 整个空间中查找一块合适的没有使用的空间 hole\"\n                         \"查找的地址从 VMALLOC_START 开始， 首先从 vmap_area_root 红黑数上查找， 该树上存放着正在使用的 vmalloc 区块”\n                         “从 VMALOC_START 开始， 查找每个存在的vmalloc 区块的hole能够容纳目前要分配的大小。 如果找到了合适的hole， \n                         调用 __insert_vmap_area 把这个 hole 注册到该红黑树中， 如果没找到hole， 则从最后一个 vmalloc 区块的结束地址开始一个新的 vmalloc 区块\"\n          | -+ setup_vmalloc_vm(area, va, flags, caller); \"将该找到的 va 填充到 vm area 中\"  \n          | -+ __vmalloc_area_node(area, gfp_mask, prot, shift, node);\n             \\ -  area->pages = kmalloc_node(array_size, nested_gfp, node); \"分配 area->pages 二维数组指针\"\n             | -  area->nr_pages = vm_area_alloc_pages(gfp_mask | __GFP_NOWARN, node, page_order, nr_small_pages, area->pages); \n                      \"使用 alloc_page 分配物理页面， 并使用 area->pages 保存这些 page的指针\"\n             | -+ vmap_pages_range(addr, addr + size, prot, area->pages, page_shift);  \"建立页面映射\"\n                \\ -+ vmap_pages_range_noflush(addr, end, prot, pages, page_shift);\n                   \\ -+ __vmap_pages_range_noflush(addr, end, prot, pages, page_shift);\n                      \\ -+ for i in npages:\n                         \\ -+ vmap_range_noflush(addr, addr + (1UL << page_shift), \tpage_to_phys(pages[i]), prot, page_shift); \"为每个 pte 建立映射\"\n                                          \"pgd-> p4d -> pud -> pmd -> pte\"\n                            \\ -  pgd = pgd_offset_k(addr); \"从 init_mm 中获取 指向 pgd 页面目录项的基址, 然后通过addr 找到对应的pgd 表项\"             \n                | -+ flush_cache_vmap(addr, end);   \"按地址 刷新tlb\"\n                   \\ -+ flush_tlb_kernel_range(start, end)\n                      \\ -+ __flush_tlb_range(struct mm_struct *mm, unsigned long start, unsigned long size, unsigned long stride)\n                         \\ -  \"sfence.vma ...\"\n```\n\n## malloc\n\n用户态调用 malloc 分配堆内存, c 库调用 brk 向系统申请内存\n\n![](attachments/user_mem_layout.png)\n\n\n\n```erlang\n-+ SYSCALL_DEFINE1(brk, unsigned long, brk)\n \\ -  min_brk = mm->start_brk\n | -+ if (brk < min_brk) goto out \"mm_struct 中有一个存档数据段的结束地址 start_brk, 如果申请的brk 边界小于该地址, 不正常, 退出\"\n | -|+ if (brk <= mm->brk)  \"如果新边界 小于 老边界, 表示要释放内存\" \n     \\ -  do_vma_munmap(&vmi, brkvma, newbrk, oldbrk, &uf, true) \"释放 new_brk 与 old_brk 之间的空间\"\n    |+ else\n     \\ -  brkvma = vma_prev_limit(&vmi, mm->start_brk); \"查找 start_brk 所在的vma\"\n     | -+ do_brk_flags(&vmi, brkvma, oldbrk, newbrk - oldbrk, 0)\n        \\ -  vma = vm_area_alloc(mm); \"分配新的 vma, vma的地址空间为 [addr, addr+len], 基于 slab 系统分配内存\"\n        | -  vma_set_anonymous(vma); \"设置为 匿名页面\"\n        | -  vma->vm_start = addr;\n        | -  vma->vm_end = addr + len;\n        | -  ksm_add_vma(vma);\n        | -  mm->map_count++;\n        | -  mm->total_vm += len >> PAGE_SHIFT;\n    | -  mm->brk = brk;\n    | -|+ if (mm->def_flags & VM_LOCKED) \"VM_LOCKED 来自于 mlockall 系统调用, 用户程序很少使用 VM_LOCKED 分配 mask\n\t\t\t    设置了 VM_LOCKED 后, 会立即为用户态进程分配物理页面, 如果不设置, 则会将分配物理页面的工作延迟到用户进程访问这些虚拟页面时, \n\t\t\t    发生了缺页中断才会分配物理内存, 并和虚拟地址建立映射关系\"\n\t    \\ -+ mm_populate(oldbrk, newbrk - oldbrk); \n\t       \\ -+ __mm_populate(addr, len, ignore_errors:1);\n\t          \\ -+ for (nstart = start; nstart < end; nstart = nend)\n\t             \\ -+ populate_vma_page_range(vma, nstart, nend, &locked); \"为 vma 分配物理内存\"\n\t                \\ -+ __get_user_pages(mm, start, nr_pages, gup_flags, NULL, locked ? locked : &local_locked);\n\t                       \"为进程地址空间分配物理内存并建立映射关系, mm 是进程内存管理的 mm_struct 数据结构\"\n```","tags":["mmu"],"categories":["linux","mmu"]},{"title":"uboot 运行 baremental bin","url":"/2022/09/11/hxd_new/riscv调研/uboot 运行 baremental bin/","content":"\n> 注意: 下面的操作步骤, 开发板不要插 sd 卡\n\n# 配置tftpd\n\n```shell\nsudo apt install tftpd-hpa\nsudo vi /etc/default/tftpd-hpa   #编辑 /etc/default/tftpd-hpa\n# /etc/default/tftpd-hpa\n\nTFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/srv/tftp\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"-s\"\n\nsudo chmod 777 -R /srv/tftp\n```\n配置完后, tftp 使用的目录为 `/srv/tftp`\n\n下载  https://cloud.hexintek.com:10003/d/f/731200443442580601 visionfive2_fw_payload.img 拷贝到该文件夹中\n```shell\nsudo cp visionfive2_fw_payload.img /srv/tftp\n```\n\n本机测试\n```shell\ntftp localhost\n> get visionfive2_fw_payload.img\n```\n\n无错误代表没问题\n\n# 配置toolchain\n\nhttps://cloud.hexintek.com:10003/d/f/731199345990354997 下载 riscv64-elf-x86_64-20210120.tar.gz    \n```shell\nmkdir riscv64-unknown-elf-toolchain\ncd riscv64-unknown-elf-toolchain\ntar -xzvf <riscv64-elf-x86_64-20210120.tar.gz所在路径> -o . \n```\n将该路径加到环境变量\nvi ~/.bashrc\n末尾加入\n```\nexport PATH=$PATH:<riscv64-unknown-elf-toolchain的路径>\n```\n最后\n```shell\nsource ~/.bashrc\n```\n\n# 开发板 u-boot tftp 下载\n\n```shell\nStarFive # setenv ipaddr 192.168.xx.xx;setenv serverip 192.168.xx.xx\n```\n\nserverip 为 tftpd 即刚才配置好 tftpd 的pc的ip\nipaddr 为 开发板的 ip\n\n\n更新U-Boot二进制文件\n```shell\nStarFive # tftpboot 0xa0000000 ${serverip}:visionfive2_fw_payload.img\nStarFive # sf probe\nStarFive # sf update 0xa0000000 0x100000 $filesize\n```\n\n开发板断电重启\n\n# baremental demo 编译运行\n\n下载demo项目 riscv64_bamental_demo.zip  https://cloud.hexintek.com:10003/d/f/731199428230170761 解压\n将代码加入到该项目下, 编辑下Makefile\n\n```shell\nmake clean\nmake -j4\n```\n最终生成`bin/image.bin`\n\n将image.bin 拷贝到 刚才配置好tftpd的pc的 `/srv/tftp` 下\n\n开发板下载 image.bin 到 `0x44000000`地址\n\n```shell\nStarFive # tftpboot 0x44000000 ${serverip}:image.bin\n```\n\n从 `0x44000000`地址 位置运行bin\n```shell\nStarFive # bootr 0x44000000\n```\n\n正常的话应该能看到log\n用`info()` 打印的log.\n\n```shell\nTFTP from server 192.168.18.55; our IP address is 192.168.18.24\nFilename 'image.bin'.\nLoad address: 0x44000000\nLoading: #\n         2.9 MiB/s\ndone\nBytes transferred = 6016 (1780 hex)\nStarFive # bootr 0x44000000\ncall begin 0000000044000000\nHello world!\nsizeof long 8\n```\n\n","tags":["riscv"],"categories":["u-boot","visionfive2","baremental"]},{"title":"u-boot启动流程分析","url":"/2022/09/11/hxd_new/riscv调研/u-boot启动流程/","content":"\n# RISCV start.S uboot 初始化总体框架解析\n\nu-boot 运行在S-mode下\n```erlang\n+ _start:\n \\-- mv tp, a0 \"tp register save hartid\"\n |-- csrw   MODE_PREFIX(tvec), t0 \"设置中断stvec 入口为 trap_entry\"\n |-- li t0, SIE_SSIE\n |-- csrs   MODE_PREFIX(ie), t0 \"设置sie 协处理器, 打开中断, 用来处理ipi 中断\"\n |-+ call_board_init_f \"Set sp in internal/ex RAM to call board_init_f\"\n   \\ -- li t1, CONFIG_SYS_INIT_SP_ADDR \"设置初始栈基址\"\n   | -- li t0, -16\n   | -- and    sp, t1, t0   \"将堆栈16 bits对齐\"\n |-+ call_board_init_f_0 \"从堆栈开始的地方，为u-boot的global data（struct global_data）分配空间\"\n   \\ -- mv a0, sp\n   | -+ jal board_init_f_alloc_reserve\n      \\ - top -= CONFIG_VAL(SYS_MALLOC_F_LEN) \"如定义了CONFIG_SYS_MALLOC_F_LEN，需预留出early malloc所需的空间\"\n   | -- slli t0, tp, CONFIG_STACK_SIZE_SHIFT \"tp代表的是hartid, 每个hart 分配STACK_SIZE 空间\"\n   | -- sub sp, a0, t0 \"sp = a0 - t0, 地址在初始栈基址上向上增长, a0 初始栈基址 top - malloc空间\"\n   | -- bnez   tp, secondary_hart_loop \"其他hart 跳转到 secondary_hart_loop, hart 0 继续\"\n   | -+ jal board_init_f_init_reserve \"初始化uboot的global data, 置0\"\n      \\ -- \"如定义了SYS_MALLOC_F_LEN，则会初始化gd->malloc_base\"\n   | -- jal icache_enable\n   | -- jal dcache_enable\n   | -+ jalr -> board_init_f \"调用board_init_f接口，执行前置的初始化操作\" common/board_f.c\n      \\ -+ initcall_run_list(init_sequence_f) \"执行init_sequence_f\" 里的一系列初始化函数\n         \\ -+ init_sequence_f\n            \\ -- initf_malloc\n            | -- arch_cpu_init\n            | -- arch_cpu_init_dm\n            | -- timer_init\n            | -- env_init\n            | -- console_init_f\n            | -- print_cpuinfo\n            | -- dram_init\n            | -- ..\n            | -- reloc_fdt\n            | -- reloc_bootstage\n            | -- setup_reloc\n            | -+ jump_to_copy\n               \\ -+ relocate_code(gd->start_addr_sp, gd->new_gd, gd->relocaddr) \"开始进行主核relocate\"\n                  \\ -- mv s2, a0          /* save addr_sp */\n                  | -- mv s3, a1          /* save addr of gd */\n                  | -- mv s4, a2          /* save addr of destination */\n                  | -+ stack_setup\n                     \\ -- slli   t0, tp, CONFIG_STACK_SIZE_SHIFT\n                     | -- sub    sp, s2, t0 \"gd->start_addr_sp - offset(of hartid)\" \n                                 设置新的sp, 这个sp 是reloc 后的sp \"gd->start_addr_sp = gd->relocaddr;\"\n                     | -- clear_bss clbss_l  \"将__bss_start到__bss_end\" 之间reloc 到 ram上的bss 区段清0           \n                     | -- copy_loop \"reloc 将_start到_bss_start之间的代码段拷贝到 relocaddr处\"\n                  | -+ fix_rela_dyn \"Update dynamic relocations after board_init_f\"\n                  | -+ relocate_secondary_harts\n                     \\ -- la  t0, secondary_hart_relocate\n                     | -- add a0, t0, t6 \"到reloc 地址上执行secondary_hart_relocate\" \n                           a0 为 secondary_hart_relocate\n                     | -- mv a1, s2 \"s2 为 addr_sp\"\n                     | -- mv a2, s3 \"s3 为 gd 指针\"\n                     | -+ jal    smp_call_function\n                        \\ -+ send_ipi_many(&ipi); \"发送ipi中断\", 前面传的三个参数保存在 gd->arch.ipi 中\n                           \\ -+ riscv_send_ipi(reg) \"reg为从uboot fdt中查到的所有的hart\"\n                              \\ -- SBI_CALL_1(SBI_SEND_IPI, hart_mask); \n                                   \"调用opensbi的函数, 给指定的hart发送ipi中断\"\n               -----------------------------ipi中断, 跳入其他核----------------------------------------------                    \n                           | -+ secondary_hart_loop \"其他hart处在secondary_hart_loop 处调了 wfi 等待\"\n                              \\ -- csrr   t0, MODE_PREFIX(ip) \"读sip\"\n                              | -- andi   t0, t0, SIE_SSIE\n                              | -- mv a0, tp \"hartid 为第一个参数\"\n                              | -+ jal handle_ipi \"如果来了software 中断, 即会跳到 handle_ipi 处理, 否则继续 secondary_hart_loop\"\n                                 \\-+ handle_ipi(hartid) \"对应的hart 收到ipi 中断\"\n                                   \\ -- riscv_clear_ipi(hart); \"会导致 mip.SSIP = sip.SSIP 清0\"\n                                   | -- invalidate_icache_all(); \n                                   | -- smp_function = gd->arch.ipi[hart].addr;\n                                      \"此处为传递的第一个参数, secondary_hart_relocate\"\n                                   | -+ smp_function(hart, gd->arch.ipi[hart].arg0, gd->arch.ipi[hart].arg1);\n                                      \\ -+ secondary_hart_relocate   \n                                         \\ -- slli   t0, tp, CONFIG_STACK_SIZE_SHIFT \n                                         | -- sub    sp, a1, t0 \"a1 为 new_sp, new_sp - offset(of hartid)\"\n                                         | -- mv gp, a2 \"更新gd指针到gp寄存器\"\n                                         | -- secondary_hart_loop wfi \n                                             \"其他核响应完ipi后, 只更新了sp和gp, 然后继续挂起等待\"\n      ---------------------------------回主核-------------------------------------------------\n            | -+ call_board_init_r\n               \\ -- jal invalidate_icache_all\n               | -- jal flush_dcache_all\n               | -- mv  a0, s3          /* gd_t */\n               | -- mv  a1, s4          /* dest_addr */\n               | -+ jalr -> board_init_r \"跳转到reloc board_init_r执行\"\n                  \\ -+ initcall_run_list(init_sequence_r)\n                     \\ -+ init_sequence_r\n                        \\ -- initr_reloc_global_data\n                        | -- initr_barrier\n                        | -- bootstage_relocate\n                        | -- board_init\n                        | -- arch_early_init_r\n                        | -- initr_secondary_cpu\n                        | -- interrupt_init\n                        | -- board_late_init \"board 相关修改\"\n                        | -+ run_main_loop \"loop 等待接收输入的命令\"\n```\n> 上述过程中, riscv_send_ipi 发送ipi 中断给其他核, 其他核是在M-mode 的opensbi 下处理的ipi中断, 处理时会调用sbi_ipi_process_smode 函数将 MIP.SSIP 置位, 因为开启了mideleg的 MIP_SSIP 位, 会导致sip.SSIP 也会被置位. 返回给uboot后, 从核在secondary_hart_loop 中loop, 判断sip.SSIP & sie.SSIE, 这个时候都置位了, 从核跳出secondary_hart_loop, 执行后面的handle_ipi 函数\n\n\n# u-boot 设计规范\nu-boot是一个bootloader，有些情况下，它可能位于系统的只读存储器（ROM或者flash）中，并从那里开始执行。\n因此，这种情况下，在u-boot执行的前期（在将自己copy到可读写的存储器之前），它所在的存储空间，是不可写的，这会有两个问题：\n1) 堆栈无法使用，无法执行函数调用，也即C环境不可用。\n2) 没有data段（或者正确初始化的data段）可用，不同函数或者代码之间，无法通过全局变量的形式共享数据。\n对于问题1，通常的解决方案是：\nu-boot运行起来之后，在那些`不需要执行任何初始化动作`即可使用的、可读写的存储区域，开辟一段堆栈（stack）空间。\n一般来说，大部分的平台，都有自己的SRAM，可用作堆栈空间。如果实在不行，也有可借用CPU的data cache的方法（不再过多说明）。\n\n对于问题2，解决方案要稍微复杂一些：\n首先，对于开发者来说，在u-boot被拷贝到可读写的RAM（这个动作称作relocation）之前，永远不要使用全局变量。\n其次，在relocation之前，不同模块之间，确实有通过全局变量的形式传递数据的需求。怎么办？这就是global data需要解决的事情。\n\n为了在relocation前通过全局变量的形式传递数据，u-boot设计了一个巧妙的方法：\n1) 定义一个struct global_data类型的数据结构，里面保存了各色各样需要传递的数据\n2) 堆栈配置好之后，在堆栈开始的位置，为struct global_data预留空间（可参考后面的说明)，并将开始地址（就是一个struct global_data指针）保存在一个寄存器中，后续的传递，都是通过保存在寄存器中的指针实现\n\t\n\t> board_init_f_alloc_reserve 的返回值（a0）就是global data的指针\n\n# 前置的板级初始化操作\nglobal data准备好之后，u-boot会执行前置的板级初始化动作, u-boot很有可能还在只读的存储器中\n这个阶段写的代码需要follow u-boot的设计规范, 不能使用全局变量, 数据传递要使用gd 指针 \n进行各式各样的初始化动作。后面将会简单介绍一些和RISCV平台有关的、和平台的移植工作有关的、比较重要的API\n\n## arch_cpu_init\ncpu级别的初始化操作，可以在需要的时候由CPU有关的code实现。\n\n## board_early_init_f\n如果定义CONFIG_BOARD_EARLY_INIT_F，则调用board_early_init_f接口，执行板级的early初始化。平台的开发者可以根据需要，实现board_early_init_f接口，以完成特定的功能。\n\n## timer_init\n初始化系统的timer。\n该接口应该由平台或者板级的代码实现，初始化成功后，u-boot会通过其它的API获取当前的timestamp，后面用到的时候再详细介绍。\n\n## misc_init_f\n如果使能了CONFIG_MISC_INIT_F，则调用misc_init_f执行misc driver有关的初始化。\n\n## dram_init\n调用dram_init接口，初始化系统的DDR。dram_init应该由平台相关的代码实现。\n如果DDR在SPL中已经初始化过了，则不需要重新初始化，只需要把DDR信息保存在global data中即可\n\n## DRAM空间的分配\nDRAM初始化完成后，就可以着手规划u-boot需要使用的部分，如下图：\n![image-20240416113254452](attachments/image-20240416113254452.png)\n\n1) 考虑到后续的kernel是在RAM的低端位置解压缩并执行的，为了避免麻烦，u-boot将使用DRAM的顶端地址，即gd->ram_top所代表的位置。其中gd->ram_top是由setup_dest_addr函数配置的。\n2) u-boot所使用的DRAM，主要分为三类：\n\t- 各种特殊功能所需的空间，如log buffer、MMU page table、LCD fb buffer、trace buffer、等等；\n\t- u-boot的代码段、数据段、BSS段所占用的空间（就是u-boot relocate之后的执行空间），由gd->relocaddr标示；\n\t- 堆栈空间，从gd->start_addr_sp处递减。\n3) 特殊功能以及u-boot所需空间，是由reserve_xxx系列函数保留的，具体可参考source code，这里不再详细分析。\n\n## setup_reloc\n计算relocation有关的信息，主要是 gd->reloc_off，计算公式如下：\n`gd->reloc_off = gd->relocaddr - CONFIG_SYS_TEXT_BASE;`\n其中`CONFIG_SYS_TEXT_BASE`是u-boot relocation之前在（只读）memory的位置（也是编译时指定的位置），gd->relocaddr是relocation之后的位置，因此gd->reloc_off代表u-boot relocation操作之后的偏移量，后面relocation时会用到。同时，该函数顺便把global data拷贝到了上图所示的“new global data”处\n\nrelocation的时间点，可以是“系统可读写memory始化完成之后“的任何时间点。根据u-boot当前的代码逻辑，是在`board_init_f`执行完成之后，因为board_init_f中完成了很多relocation有关的准备动作\n\n# 后置的板级初始化操作\n\nrelocate完成之后，真正的C运行环境才算建立了起来，接下来会执行“后置的板级初始化操作”，即`board_init_r`函数。board_init_r和board_init_f的设计思路基本一样，也有一个很长的初始化序列----`init_sequence_r`，该序列中包含如下的初始化函数\n1) initr_trace，初始化并使能u-boot的tracing system，涉及的配置项有CONFIG_TRACE。\n2) initr_reloc，设置relocation完成的标志。\n3) initr_caches，使能dcache、icache等。\n4) initr_malloc，malloc有关的初始化。\n5) initr_dm，relocate之后，重新初始化DM，涉及的配置项有CONFIG_DM。\n6) `board_init`，具体的板级初始化，需要由board代码根据需要实现。\n7) set_cpu_clk_info，Initialize clock framework，涉及的配置项有CONFIG_CLOCKS。\n8) initr_serial，重新初始化串口（不太明白什么意思）。\n9) initr_announce，宣布已经在RAM中执行，会打印relocate后的地址。\n10) board_early_init_r，由板级代码实现，涉及的配置项有CONFIG_BOARD_EARLY_INIT_R。\n11) arch_early_init_r，由arch代码实现，涉及的配置项有CONFIG_ARCH_EARLY_INIT_R。\n12) power_init_board，板级的power init代码，由板级代码实现，例如hold住power。\n13) initr_flash、initr_nand、initr_onenand、initr_mmc、initr_dataflash，各种flash设备的初始化。\n14) initr_env，环境变量有关的初始化。\n15) initr_secondary_cpu，初始化其它的CPU core。\n16) stdio_add_devices，各种输入输出设备的初始化，如LCD driver等。\n17) interrupt_init，中断有关的初始化。\n18) initr_enable_interrupts，使能系统的中断\n19) initr_status_led，状态指示LED的初始化，涉及的配置项有CONFIG_STATUS_LED、STATUS_LED_BOOT。\n20) initr_ethaddr，Ethernet的初始化，涉及的配置项有CONFIG_CMD_NET。\n21) board_late_init，由板级代码实现，涉及的配置项有CONFIG_BOARD_LATE_INIT。\n22) 等等…\n23) run_main_loop/main_loop，执行到main_loop，开始命令行操作。\n\n## 厂商板级配置\nboard/<厂商>/\nex:  `board/thead/ice-c910/ice.c`\n通常只需要覆盖board_init, 配置时钟, 配置硬件资源\n![image-20240416113300077](attachments/image-20240416113300077.png)\n\n## arch 相关修改\n覆盖`cleanup_before_linux`, 该函数会在跳转kernel 前执行\n\n# main 函数分析\n一切就绪后进入交互状态，cli_init->cli_loop循环读取cmdline中的启动参数，将其存入console_buffer字符数组。若autoboot_command启动内核，则不会执行到cli_loop，若按键，则进入cli_loop函数，循环等待执行命令。\n\n```erlang\n+ main_loop\n\\ -+ s = bootdelay_process();\n   \\ -- s = env_get(\"bootdelay\"); \"获取等待时间, 用户可以选择menu中的启动项\"\n   | -- bootdelay = menu_show(bootdelay); \"配置了 CONFIG_AUTOBOOT_MENU_SHOW\"\n   | -- s = env_get(\"bootcmd\");\n| -+ autoboot_command(s);\n   \\ -- run_command_list(s, -1, 0); \"执行bootcmd 指令\" \"如果能跳到kernel, 后面的指令就不会再执行了\"\n| -- cli_loop(); \"autoboot_command没有跳转到kernel, 则会执行这里的, 等待用户输入指令\"\n```\n\nuboot中有一个小巧的命令解释器`hush shell`，run_command_list只是对 hush shell 中的函数 parse_string_outer 进行了一层封装。`parse_string_outer`函数调用了bush_shell的命令解释器, parse_stream_outer函数来解释bootcmd的命令，而环境变量bootcmd的启动命令用来设置linux必要的启动环境，board_run_command执行命令。然后加载和启动内核\n\n\nbootcmd 可以理解为shell 命令行, 通常bootcmd必须包含几条命令\n- 从flash的什么地方加载kernel到内存的什么位置, 与文件系统有关\n- bootm 指令, 从内存的什么位置启动kernel\n\n## bootm\n\nbootm这个命令用于启动一个操作系统镜像。它会从镜像文件的头部取得一些信息，这些信息包括：文件的基于的cpu架构、其操作系统类型、镜像类型、压缩方式、镜像文件在内存中的加载地址、镜像文件运行的入口地址、镜像文件名等。   \n紧接着bootm将镜像加载到指定的地址，如果需要的话，还会解压镜像并传递必要有参数给内核，最后跳到入口地址进入内核。\n\n```c\nU_BOOT_CMD(\n\tbootm,\tCONFIG_SYS_MAXARGS,\t1,\tdo_bootm,\n\t\"boot application image from memory\", bootm_help_text\n);\n```\n需要打开的宏\nCONFIG_BOOTM_LINUX=y  \nCONFIG_CMD_BOOTM=y\n\nuImage有两种格式\n- Legacy-uImage，我们需要另外加载ramdisk和fdt到RAM上面\n- FIT-uImage   kernel镜像、ramdisk镜像和fdt都已经打包到FIT-uImage的镜像中了。\n\n示例: 加载 kernel、ramdisk、fdt  \n`bootm 0x80008000 0x81000000 0x82000000`\n```erlang\n+ do_bootm \"示例: argv[1]=0x80008000, arv[2]=0x81000000, argv[3]=0x82000000\"\n\\ -+ do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START | BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |\n\t\tBOOTM_STATE_LOADOS | BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |\n\t\tBOOTM_STATE_OS_GO, &images, 1);\n   \\ -- bootm_start(cmdtp, flag, argc, argv);\t\"实现 verify 和 lmb\"\t\n   | -- bootm_find_os(cmdtp, flag, argc, argv); \"查 os 和 ep。填充到 images 成员\"\n   | -- bootm_find_other(cmdtp, flag, argc, argv); \"查 rd_start, rd_end，ft_addr 和 initrd_end, 填充images成员\"\n   | -+ bootm_load_os(images, 0) \"会对 kernel 镜像进行 load 到对应的位置上，并且如果 kernel 镜像是被 mkimage 压缩过的，那么会先经过解压之后再进行 load, 这里的压缩和 Image 压缩成 zImage 并不是同一个，而是 uboot 在 Image 或者 zImage 的基础上进行的压缩\"\n      \\ -- ulong load = os.load; \"kernel 最终被加载到的地址\"\n      | -- load_buf = map_sysmem(load, 0);\n      | -- ulong image_start = os.image_start; \"kernel 实际存在的位置\"\n      | -- ulong image_len = os.image_len; \"kernel 的长度\"\n      | -- image_buf = map_sysmem(os.image_start, image_len);\n      | -- image_decomp(os.comp, load, os.image_start, os.type, \"comp: 压缩类型 NONE, GZIP, LZMA\"\n\t\t\t   load_buf, image_buf, image_len,\n\t\t\t   CONFIG_SYS_BOOTM_LEN, &load_end);\n\t\t\t   \"kernel 镜像就被解压到 load 位置上了\"\n   | -- bootm_os_get_boot_func(images->os.os); \"获取对应操作系统的启动函数，存放到 boot_fn, 这里配置了 CONFIG_BOOTM_LINUX , 该函数为 do_bootm_linux\"\n   | -+ boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images)\n      \\ -+ do_bootm_linux(BOOTM_STATE_OS_PREP, argc, argv, images)\n         \\ -+ boot_prep_linux(images);\n            \\ -+ image_setup_linux(images) \"设置cmdline 和 fdt\"\n               \\ -- boot_get_cmdline(lmb, &images->cmdline_start, &images->cmdline_end)\n               | -- boot_relocate_fdt(lmb, of_flat_tree, &of_size)\n               | -- image_setup_libfdt(images, *of_flat_tree, of_size, lmb)\n   | -+ boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,images, boot_fn) \"跳转到操作系统中，且不再返回了\"\n      \\ -- arch_preboot_os() \"平台定制\"\n      | -- board_preboot_os(); \"board定制\"\n      | -+ boot_fn(state, argc, argv, images);\n         \\ -+ do_bootm_linux(BOOTM_STATE_OS_GO, argc, argv, images)\n            \\ -+ boot_jump_linux(images, flag);\n               \\ -- kernel = (void (*)(ulong, void *))images->ep;\n               | -- bootstage_mark(BOOTSTAGE_ID_RUN_OS);\n               | -+ announce_and_cleanup(fake);\n                  \\ -- bootstage_mark_name(BOOTSTAGE_ID_BOOTM_HANDOFF, \"start_kernel\");\n                  | -- cleanup_before_linux() \"arch平台定制\"\n                  | -+ ret = smp_call_function(images->ep, (ulong)images->ft_addr, 0);  \n                      \"多核情况, 给其他发送ipi中断, 本核继续往下走, 没有hang住, 走下面的kernel 函数\"\n                     \\ -+ send_ipi_many(&ipi) \"遍历fdt /cpus节点, 给其他核发送ipi中断\"\n                        \\ -- gd->arch.ipi[reg].addr = ipi->addr; \"kernel ep _start地址\"\n                        | -- gd->arch.ipi[reg].arg0 = ipi->arg0;\n                        | -- gd->arch.ipi[reg].arg1 = ipi->arg1;\n                        | -- riscv_send_ipi(reg); \"给其他hart 发送ipi中断\"\n  -----------------------------------------收到ipi中断, 其他核的处理流程--------------------------                \n                     \\ -- smp_function = (void (*)(ulong, ulong, ulong))gd->arch.ipi[hart].addr; \"kernel 的_start\"\n                     | -- smp_function(hart, gd->arch.ipi[hart].arg0, gd->arch.ipi[hart].arg1); \n                             \"其他核 跳到kernel start entry, a0 寄存器存hartid, a1 存fdt_addr, 最终会等在secondary_park处\"\n  -----------------------------------------回到本核, 跳转到kernel--------------------------------\n                  | -- kernel(gd->arch.boot_hart, images->ft_addr); \"单核跳转到kernel, a0 存boot_hartid, ft_addr 放入a1寄存器\"\n```\n\n### 状态说明\n```c\nBOOTM_STATE_START    开始执行 bootm 的一些准备动作。  \n#define BOOTM_STATE_START (0x00000001)   \n\nBOOTM_STATE_FINDOS    查找操作系统镜像  \n#define BOOTM_STATE_FINDOS (0x00000002)   \n\nBOOTM_STATE_FINDOTHER    查找操作系统镜像外的其他镜像，比如 FDT\\ramdisk 等等  \n#define BOOTM_STATE_FINDOTHER (0x00000004)   \n\nBOOTM_STATE_LOADOS   加载操作系统  \n#define BOOTM_STATE_LOADOS (0x00000008)   \n\nBOOTM_STATE_RAMDISK   操作 ramdisk  \n#define BOOTM_STATE_RAMDISK (0x00000010)   \n\nBOOTM_STATE_FDT   操作 FDT  \n#define BOOTM_STATE_FDT (0x00000020)   \n\nBOOTM_STATE_OS_CMDLINE   操作 commandline  \n#define BOOTM_STATE_OS_CMDLINE (0x00000040)   \n\nBOOTM_STATE_OS_BD_T   \n#define BOOTM_STATE_OS_BD_T (0x00000080)  \nBOOTM_STATE_OS_PREP    跳转到操作系统的前的准备动作  \n#define BOOTM_STATE_OS_PREP (0x00000100)   \n\nBOOTM_STATE_OS_FAKE_GO   伪跳转，一般都能直接跳转到 kernel 中去  \n#define BOOTM_STATE_OS_FAKE_GO (0x00000200) /* ‘Almost’ run the OS */   \n\nBOOTM_STATE_OS_GO   跳转到 kernel 中去\n#define BOOTM_STATE_OS_GO (0x00000400)   \n\n```\n在这些流程中，起传递作用的是 `bootm_headers_t images` 这个数据结构，有些流程是解析镜像，往这个结构体里写数据。   \n而跳转的时候，则需要使用到这个结构体里面的数据。\n\n```c\ntypedef struct bootm_headers {  \n    /*  \n     * Legacy os image header, if it is a multi component image  \n     * then boot_get_ramdisk() and get_fdt() will attempt to get  \n     * data from second and third component accordingly.  \n     */  \n    image_header_t  *legacy_hdr_os;     /* image header pointer */  // Legacy-uImage 的镜像头  \n    image_header_t  legacy_hdr_os_copy; /* header copy */ // Legacy-uImage 的镜像头备份  \n    ulong       legacy_hdr_valid; // Legacy-uImage 的镜像头是否存在的标记\n\n\t// ...  省略FIT 格式\n\n    image_info_t    os;     /* os image info */ // 操作系统信息的结构体  \n    ulong       ep;     /* entry point of OS */ // 操作系统的入口地址\n    ulong       rd_start, rd_end;/* ramdisk start/end */ // ramdisk 在内存上的起始地址和结束地址\n    char        *ft_addr;   /* flat dev tree address */ // fdt 在内存上的地址  \n    ulong       ft_len;     /* length of flat device tree */ // fdt 在内存上的长度\n    ulong       initrd_start; //   \n    ulong       initrd_end; //   \n    ulong       cmdline_start; //   \n    ulong       cmdline_end; //   \n    bd_t        *kbd; // \n\n    int     verify;     /* getenv(\"verify\")[0] != 'n' */ // 是否需要验证  \n    int     state; // 状态标识，用于标识对应的 bootm 需要做什么操作，具体看下面 2.\n\n#ifdef CONFIG_LMB  \n    struct lmb  lmb;        /* for memory mgmt */  \n#endif\n```\n\n>  LMB 的概念。LMB 是指 logical memory blocks，主要是用于表示内存的保留区域，主要有 fdt 的区域，ramdisk 的区域等等。   \nboot_prep_linux 主要的目的是修正 LMB，并把 LMB 填入到 fdt 中。\n\n\n# Gdb 调试\n\nu-boot 重定位后很难继续用 gdb debug\n使用\"add-symbol-file\" 命令重定位后，使用代码 offset = gd->relocaddr 重定位该符号：\n\n#uboot_reloc_debug\n\n```shell\n$ symbol-file build/u-boot                            --> only for \"gd_t\" definition\n$ set $offset = ((gd_t *)$gp)->relocaddr        --> get relocation offset\n$ symbol-file                                   --> clear previous symbol \n$ add-symbol-file build/u-boot $offset\n\n$ add-symbol-file build/u-boot 0xfff53000\n```","tags":["riscv"],"categories":["u-boot"]},{"title":"git remote 批量修改","url":"/2022/07/20/工作相关/本地git 关联remote 批量修改git 记录/","content":"\n本地仓库\ngit init\ngit add ...\ngit commit\n\ngit branch\n\n## 关联远程分支\n```shell\ngit remote add origin \"ssh://liguang.zhang@web.hexintek.com:29418/android/library/crypto-proxy\"\n```\n\n## 远程分支与本地分支合并\n\n```shell\ngit pull --rebase origin master\n```\n\n## 批量修改远程提交\n\n批量修改本地未上库的提交\n```shell\ngit rebase -i origin/master\n```\n需要将每一笔提交改为 edit 状态\n\n### 添加 hooks 自动插入commit id\n```shell\ngitdir=$(git rev-parse --git-dir); scp -p -P 29418 liguang.zhang@web.hexintek.com:hooks/commit-msg ${gitdir}/hooks/\n```\n### 修改每一笔的提交记录\n前面的命令修改了 n 笔提交, 下面的命令就需要执行n次\n```shell\ngit commit --amend; git rebase --continue\n```\n\n批量修改完后, 上库合入远程 master分支\n```shell\ngit push origin HEAD:refs/for/master\n```","tags":["git"],"categories":["git"]},{"title":"linux cryptoapi 适配","url":"/2022/07/12/TEE/linux cryptoapi 适配参考/","content":"\n主要介绍怎样将crypto hardware accelerate 移植到 linux crypto api中\n参考项主要是 stm32的实现\n\n# crypto中移植aes 引擎\n\nlinux中 hardware ip 是以驱动的方式加载到kernel中的\n先看一下驱动的定义\n\n```c\nstatic const struct of_device_id stm32_dt_ids[] = {\n\t{ .compatible = \"st,stm32f756-cryp\", .data = &f7_data},\n\t{ .compatible = \"st,stm32mp1-cryp\", .data = &mp1_data},\n\t{},\n};\nstatic struct platform_driver stm32_cryp_driver = {\n    .probe  = stm32_cryp_probe,\n    .remove = stm32_cryp_remove,\n    .driver = {\n        .name           = DRIVER_NAME,\n        .pm     = &stm32_cryp_pm_ops,\n        .of_match_table = stm32_dt_ids,\n    },\n};\n```\n\nstm32的加密引擎是作为platform driver.\n\n![](../OTA相关/加密方案整理.md#^39c29c)\n![](../OTA相关/加密方案整理.md#^a36448)\n\n```c\n13\tcrypto@50060000 {\n14\t\tcompatible = \"st,stm32f756-cryp\";\n15\t\treg = <0x50060000 0x400>;\n16\t\tinterrupts = <79>;\n17\t\tclocks = <&rcc 0 STM32F7_AHB2_CLOCK(CRYP)>;\n18\t\tresets = <&rcc STM32F7_AHB2_RESET(CRYP)>;\n19\t};\n```\n\n通过`platform_driver_register` 或者 `module_init` 注册驱动时, 会将driver 和设备绑定, 自动回调probe接口\n一个driver可以同多个设备绑定, 每次绑定都会回调probe接口.\n\n寻找设备的过程, 一般就是在device tree 中通过 of_match_table 寻找匹配的设备的过程. 匹配到后, 根据device tree中的设备信息初始化 driver中dev相关的结构体信息\n\n## probe 注册过程\n```c\nstatic int stm32_cryp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_cryp *cryp;\n\tstruct reset_control *rst;\n\tint irq, ret;\n\n\tcryp = devm_kzalloc(dev, sizeof(*cryp), GFP_KERNEL);\n\tif (!cryp)\n\t\treturn -ENOMEM;\n\n\tcryp->caps = of_device_get_match_data(dev);\n\tif (!cryp->caps)\n\t\treturn -ENODEV;\n\n\tcryp->dev = dev;\n    // 匹配到device tree中设备描述的regs\n\tcryp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cryp->regs))\n\t\treturn PTR_ERR(cryp->regs);\n\t// 匹配到device tree中设备描述的irq\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n    // 配置中断\n\tret = devm_request_threaded_irq(dev, irq, stm32_cryp_irq,\n\t\t\t\t\tstm32_cryp_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), cryp);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot grab IRQ\\n\");\n\t\treturn ret;\n\t}\n    // 匹配到device tree中设备描述的clk, 实际上是ahb clk的位偏移\n\tcryp->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cryp->clk)) {\n\t\tdev_err(dev, \"Could not get clock\\n\");\n\t\treturn PTR_ERR(cryp->clk);\n\t}\n    // 开启cryp时钟\n\tret = clk_prepare_enable(cryp->clk);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\t//... 忽略电源管理相关\n\tpm_runtime...\n\t\n    // 匹配到device tree中设备描述的 resets\n\trst = devm_reset_control_get(dev, NULL);\n    // 时钟复位, 先开再关\n\tif (!IS_ERR(rst)) {\n\t\treset_control_assert(rst);\n\t\tudelay(2);\n\t\treset_control_deassert(rst);\n\t}\n\t// 在probe()函数中动态申请设备结构体 cryp，并初始化它，然后使用platform_set_drvdata（）将其保存到platform_device\n\tplatform_set_drvdata(pdev, cryp);\n\n\tspin_lock(&cryp_list.lock);\n\t// 保存到 cryp_list的 dev_list列表中, 这个结构用来找cryp 结构体\n\tlist_add(&cryp->list, &cryp_list.dev_list);\n\tspin_unlock(&cryp_list.lock);\n\n\t/* Initialize crypto engine */\n\t// 初始化 engine, 填充相关结构, 并初始化worker线程, 这个后面详细分析下, 见 --> 1.1\n\tcryp->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!cryp->engine) {\n\t\tdev_err(dev, \"Could not init crypto engine\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_engine1;\n\t}\n    // 见 --> 1.2\n\tret = crypto_engine_start(cryp->engine);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not start crypto engine\\n\");\n\t\tgoto err_engine2;\n\t}\n    // 见 --> 1.3\n\tret = crypto_register_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register algs\\n\");\n\t\tgoto err_algs;\n\t}\n\n    // 见 --> 1.4\n\tret = crypto_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n\tif (ret)\n\t\tgoto err_aead_algs;\n\n\tdev_info(dev, \"Initialized\\n\");\n\n\treturn 0;\n...\n\n\treturn ret;\n}\n\n```\n\n### 1.1 crypto_engine_alloc_init\n--> crypto_engine_alloc_init\n```c\n/**\n * crypto_engine_alloc_init - allocate crypto hardware engine structure and\n * initialize it.\n * @dev: the device attached with one hardware engine\n * @rt: whether this queue is set to run as a realtime task\n *\n * This must be called from context that can sleep.\n * Return: the crypto engine structure on success, else NULL.\n */\nstruct crypto_engine *crypto_engine_alloc_init(struct device *dev, bool rt)\n{\n// 进程优先级\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO / 2 };\n\tstruct crypto_engine *engine;\n\n\tif (!dev)\n\t\treturn NULL;\n    // 初始化分配内存 分配的内存会和pdev->dev绑定, devm_kzalloc()是跟设备(device)有关的，当设备(device)被detached或者驱动(driver)卸载(unloaded)时，内存会被自动释放。\n\tengine = devm_kzalloc(dev, sizeof(*engine), GFP_KERNEL);\n\tif (!engine)\n\t\treturn NULL;\n\n\tengine->dev = dev;  //指向绑定的dev\n\tengine->rt = rt;    // 调度相关, 是否是实时任务, 这里是 1\n\tengine->running = false;  //the engine is on working\n\tengine->busy = false;   //request pump is busy\n\tengine->idling = false;  // the engine is entering idle state\n\tengine->cur_req_prepared = false; //current request is prepared\n\tengine->priv_data = dev; //the engine private data\n\tsnprintf(engine->name, sizeof(engine->name),\n\t\t \"%s-engine\", dev_name(dev));   // the engine name\n\n\tcrypto_init_queue(&engine->queue, CRYPTO_ENGINE_MAX_QLEN); // the crypto queue of the engine\n\tspin_lock_init(&engine->queue_lock); //queue的锁\n\t// kthread worker struct for request pump, 再cpu0上创建内核工作线程 worker.\n\t// kthread_worker_fn 循环监听是否有工作需要处理  \n\tengine->kworker = kthread_create_worker(0, \"%s\", engine->name);\n\tkthread_init_work(&engine->pump_requests, crypto_pump_work);  //work struct for scheduling work to the request pump\n\n\tif (engine->rt) {\n\t\tdev_info(dev, \"will run requests pump with realtime priority\\n\");\n\t\tsched_setscheduler(engine->kworker->task, SCHED_FIFO, &param); //修改task的优先级为实时的\n\t}\n\n\treturn engine;\n}\n```\n\n#### kthread_worker 与 kthread_work\n内核线程创建函数创建一个内核线程，它判断属于这个线程的kthread_worker中是否有要处理的kthread_work，如果有，就取出这个kthread_work，然后调用kthread_work上面指定的处理函数，如果没有这个线程就进行休眠，当有新的kthread_work添加到kthread_worker上时，会再次唤醒kthread_worker的处理线程重复上述工作。\n\nengine->pump_requests 是 kthread_work, crypto_pump_work 则是该work上的指定的处理函数\nengine->kworker 是kthread_worker\n\n上面crypto_engine_alloc_init的过程只是初始化了crypto engine相关的数据, 分配了内存, 创建了worker与work, 但worker上还没有work, worker与work并没有关联起来\n\n### 1.2 crypto_engine_start(cryp->engine)\n--> 1.2 crypto_engine_start\n```c\nint crypto_engine_start(struct crypto_engine *engine)\n{\n\tunsigned long flags;\n\t// 持锁并禁用中断\n\tspin_lock_irqsave(&engine->queue_lock, flags);\n\n\tif (engine->running || engine->busy) {\n\t\tspin_unlock_irqrestore(&engine->queue_lock, flags);\n\t\treturn -EBUSY;\n\t}\n    // 持锁的目的是为了原子性修改 running变量, 此时标记为true, 表示engine start\n\tengine->running = true;\n\tspin_unlock_irqrestore(&engine->queue_lock, flags);\n    // 将work给到worker, worker执行 crypto_pump_work 处理函数\n\tkthread_queue_work(engine->kworker, &engine->pump_requests);\n\treturn 0;\n}\n```\n#### crypto_pump_work\n```c\nstatic void crypto_pump_work(struct kthread_work *work)\n{\n    // pump_requests 是 kthread_work, 通过 pump_requests 找到 crypto_engine的首地址, 当前指针减去 pump_requests在crypto_engine结构体中的偏移量即可得到 engine的首地址\n\tstruct crypto_engine *engine =\n\t\tcontainer_of(work, struct crypto_engine, pump_requests);\n\n\tcrypto_pump_requests(engine, true);\n}\n\nstatic void crypto_pump_requests(struct crypto_engine *engine,\n\t\t\t\t bool in_kthread)\n{\n\tstruct crypto_async_request *async_req, *backlog;\n\tstruct crypto_engine_ctx *enginectx;\n\n\t// 持锁并关当前cpu的中断\n\tspin_lock_irqsave(&engine->queue_lock, flags);\n\n\t/* If another context is idling then defer */\n\t// 说明有其他线程抢先进到了idling状态, 延后执行\n\tif (engine->idling) {\n\t\tkthread_queue_work(engine->kworker, &engine->pump_requests);\n\t\tgoto out;\n\t}\n\n\t/* Check if the engine queue is idle */\n\tif (!crypto_queue_len(&engine->queue) || !engine->running) {\n\t\t// ... 检查当前状态不对, 退出, 应该queue上有request 且engine running是true才对\n\t}\n\t... // 这里先省略, 因为queue上还没有request, 后面再看这部分\n}\n```\n\n这里先知道当work被推给worker后, worker 会执行work上指定的处理函数, 该处理函数主要的作用就是处理engine->queue上的消息队列即可, 至于消息是怎样推到queue上的以及queue的结构是什么样的, 后面等到有消息处理时再分解\n\n### 1.3 crypto_register_skciphers\n\n--> 1.3 crypto_register_skciphers\n```c\nstatic struct skcipher_alg crypto_algs[] = {\n{\n\t.base.cra_name\t\t= \"ecb(aes)\",\n\t.base.cra_driver_name\t= \"stm32-ecb-aes\",\n\t.base.cra_priority\t= 200,\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t.base.cra_alignmask\t= 0xf,\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.init\t\t\t= stm32_cryp_init_tfm,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.setkey\t\t\t= stm32_cryp_aes_setkey,\n\t.encrypt\t\t= stm32_cryp_aes_ecb_encrypt,\n\t.decrypt\t\t= stm32_cryp_aes_ecb_decrypt,\n},\n\ncrypto_register_skcipher(&algs[i]);\nskcipher_prepare_alg(alg);\ncrypto_register_alg(alg->base);\n...\n```\n遍历 crypto_algs数组 注册crypto 算法, 这里用了linux crypto api的通用结构, 目的估计是向系统中注册对应的算法, kernel中的其他模块可以通过名字找到该算法, 调用其对应的init setkey encrypt等函数指针\n`crypto_skcipher_init_tfm` `crypto_alloc_skcipher` `crypto_skcipher_setkey`  `crypto_skcipher_encrypt` `crypto_skcipher_decrypt`\n\ncrypto_alloc_skcipher 通过 alg_name 查找到注册的算法, 最后会调用其init的函数指针.\n```c\nstruct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,\n\t\t\t\t\t      u32 type, u32 mask)\n{\n\treturn crypto_alloc_tfm(alg_name, &crypto_skcipher_type, type, mask);\n}\n+ --+ crypto_alloc_tfm\n    \\ -- + crypto_find_alg(alg_name, frontend, type, mask)\n         \\ -- crypto_alg_mod_lookup(alg_name, type, mask)\n    | -- + crypto_create_tfm(alg, frontend)\n         \\ -- + frontend->init_tfm(tfm) === crypto_skcipher_type--> init_tfm ===  crypto_skcipher_init_tfm\n              \\ -- alg->init(skcipher)  === stm32_cryp_init_tfm\n         | -- alg->cra_init(tfm)  // 这里stm cryp的cra_init 应该是没有定义\n```\n\n这里需要顺带看下 init 做了什么\n\n#### stm32_cryp_init_tfm\n\n```c\nstatic int stm32_cryp_init_tfm(struct crypto_skcipher *tfm)\n{\n    // operational context of the transformation\n\tstruct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct stm32_cryp_reqctx));\n    // 主要是注册 这几个op的函数指针, 这几个函数指针在后面处理request会用到\n\tctx->enginectx.op.do_one_request = stm32_cryp_cipher_one_req;\n\tctx->enginectx.op.prepare_request = stm32_cryp_prepare_cipher_req;\n\tctx->enginectx.op.unprepare_request = NULL;\n\treturn 0;\n}\n```\n\n### 1.4 crypto_register_aeads\n--> 1.4 crypto_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n注册aead_algs(带关联认证的加密算法), 这里不展开了, 同 crypto_register_skciphers 过程差不多, 只是要注意为什么区分成了 aeads, type由 `crypto_skcipher_type` 变成了`crypto_aead_type` \n有需要再看, 这里CCM GCM 需要通过这个接口实现\n\n## request 处理\n\n### crypto_skcipher_encrypt\n跟一下这个过程, 看下request 路由\n\n```c\nstruct skcipher_request {\n\tunsigned int cryptlen;\n\tu8 *iv;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\tstruct crypto_async_request base;\n\tvoid *__ctx[] CRYPTO_MINALIGN_ATTR;\n};\n```\nskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\nrequest 封装包含 len ,src dst,iv 等. key并不在里面\n```erlang\n--+ skcipher_request_set_crypt\n  \\--+ crypto_skcipher_alg(tfm)->encrypt(req);\n     \\--+ stm32_cryp_aes_ecb_encrypt(req)\n        \\--+ stm32_cryp_crypt(req, FLG_AES | FLG_ECB | FLG_ENCRYPT);\n           \\ -- 找到 之前注册的 stm32_cryp_ctx, 并从 cryp_list 中找到probe时添加的cryp结构体指针, 最终赋值给 stm32_cryp_ctx 的ctx->cryp\n           |--+ crypto_transfer_skcipher_request_to_engine(cryp->engine, req)\n              \\--+ crypto_transfer_request_to_engine(engine, &req->base)\n                 \\--+ crypto_transfer_request(engine, req, true)\n                    \\-- crypto_enqueue_request(&engine->queue, req) #\"入队\" 见 --> 2.1 入队分析\n                    |-- kthread_queue_work(engine->kworker, &engine->pump_requests); #\"work 推给worker\"\n```\n\n### crypto_enqueue_request\n--> 2.1 入队分析\n```c\nint crypto_enqueue_request(struct crypto_queue *queue,\n\t\t\t   struct crypto_async_request *request)\n{\n\tint err = -EINPROGRESS;\n    // queue 满了, 如果带了 CRYPTO_TFM_REQ_MAY_BACKLOG , 会接着入队\n\tif (unlikely(queue->qlen >= queue->max_qlen)) {\n\t\tif (!(request->flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t\terr = -EBUSY;\n\t\t// backlog 如果指向queue 首, 且queue满了, 则将其指向req的list 首 \n\t\tif (queue->backlog == &queue->list)\n\t\t\tqueue->backlog = &request->list;\n\t}\n\n\tqueue->qlen++;\n\t// 将request 队首指针加入到queue list中, 队尾入队\n\tlist_add_tail(&request->list, &queue->list);\nout:\n\treturn err;\n}\n```\n\n此时因为work推给了worker, worker会运行 work的处理函数 crypto_pump_work\n接着分析crypto_pump_work的后半部分\n### crypto_pump_work 后半部分\n```c\n\t/* Get the fist request from the engine queue to handle */\n\t// 这个地方应该只有 queue->backlog = &request->list; 时backlog才不为空, 否则应该为空\n\t// 也就是可以理解为只有queue满时才会执行 backlog->complete, 而complete是发送request时设置的回调\n\tbacklog = crypto_get_backlog(&engine->queue);\n\tasync_req = crypto_dequeue_request(&engine->queue);\n\tif (!async_req)\n\t\tgoto out;\n    // 队首出队, 获得request\n\tengine->cur_req = async_req;\n\tif (backlog)\n\t\tbacklog->complete(backlog, -EINPROGRESS);\n\n\tif (engine->busy)\n\t\twas_busy = true;\n\telse\n\t\tengine->busy = true;\n\n\tspin_unlock_irqrestore(&engine->queue_lock, flags);\n\n\t/* Until here we get the request need to be encrypted successfully */\n\t// 这个地方 engine 应该是没有 prepare_crypt_hardware , 所以先省略\n\tif (!was_busy && engine->prepare_crypt_hardware) {\n\t    // 不为busy时, 调用 prepare_crypt_hardware, 此处未注册\n\t\tret = engine->prepare_crypt_hardware(engine);\n\t}\n\n\tenginectx = crypto_tfm_ctx(async_req->tfm);\n    // 调用 prepare_request --> stm32_cryp_prepare_cipher_req\n\tif (enginectx->op.prepare_request) {\n\t\tret = enginectx->op.prepare_request(engine, async_req);\n        ...\n\t\tengine->cur_req_prepared = true;\n\t}\n\t// 调用  op.do_one_request --> stm32_cryp_cipher_one_req\n\tret = enginectx->op.do_one_request(engine, async_req);\n    ...// 省略错误处理\n\treturn;\n\nreq_err:\n\tcrypto_finalize_request(engine, async_req, ret);\n\treturn;\n\nout:\n\tspin_unlock_irqrestore(&engine->queue_lock, flags);\n```\n### stm32_cryp_prepare_cipher_req\n```c\nstatic int stm32_cryp_prepare_req(struct skcipher_request *req,\n\t\t\t\t  struct aead_request *areq)\n{\n\trctx->mode &= FLG_MODE_MASK;\n\tctx->cryp = cryp;\n\tcryp->flags = (cryp->flags & ~FLG_MODE_MASK) | rctx->mode;\n\tcryp->hw_blocksize = is_aes(cryp) ? AES_BLOCK_SIZE : DES_BLOCK_SIZE;\n\tcryp->ctx = ctx;\n\n\tif (req) {\n\t\tcryp->req = req;\n\t\tcryp->areq = NULL;\n\t\tcryp->total_in = req->cryptlen;\n\t\tcryp->total_out = cryp->total_in;\n\t}\n// ... 填充 cryp 结构\n\tcryp->in_sg = req ? req->src : areq->src;\n\tcryp->out_sg = req ? req->dst : areq->dst;\n\tcryp->out_sg_save = cryp->out_sg;\n// 最终调用硬件相关, 设置寄存器, 初始化 cryp->regs 的相关寄存器\n\tret = stm32_cryp_hw_init(cryp);\n}\n```\n### stm32_cryp_cipher_one_req\n```c\nstatic int stm32_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct skcipher_request *req = container_of(areq,\n\t\t\t\t\t\t      struct skcipher_request,\n\t\t\t\t\t\t      base);\n\tstruct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct stm32_cryp *cryp = ctx->cryp;\n\t// 调用硬件相关, 启动cryp, 开启中断, 由中断接收处理数据\n\treturn stm32_cryp_cpu_start(cryp);\n}\n```\n### 中断处理\n接下来需要看下中断怎么处理 cryp 硬件的执行流的\n在probe 时设置了中断处理函数为 stm32_cryp_irq\n\n```c\n\tret = devm_request_threaded_irq(dev, irq, stm32_cryp_irq,\n\t\t\t\t\tstm32_cryp_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), cryp);\n```\n\nirq_handler 为  `stm32_cryp_irq`, thread_fn为`stm32_cryp_irq_thread`\n\n这里分中断上半部, 下半部, 中断到来后由irq_handler -> `stm32_cryp_irq` 处理中断, 设置`cryp->irq_status = stm32_cryp_read(cryp, CRYP_MISR)`返回 `IRQ_WAKE_THREAD`, \n唤醒中断处理线程,  到下半部, 由thread_fn -> `stm32_cryp_irq_thread` 处理后续的工作\n\n\n#### stm32_cryp_irq_thread\n```c\nstatic irqreturn_t stm32_cryp_irq_thread(int irq, void *arg)\n{\n\tstruct stm32_cryp *cryp = arg;\n\tu32 ph;\n    // 由irq_status状态判断中断类型, 驱动是要入数据还是出数据, 出数据即fifo满了, 算出的数据输出, 入数据即fifo空了, 要往里填数据了\n\tif (cryp->irq_status & MISR_OUT)\n\t\t/* Output FIFO IRQ: read data */\n\t\tif (unlikely(stm32_cryp_irq_read_data(cryp))) {\n\t\t\t/* All bytes processed, finish */\n\t\t\tstm32_cryp_write(cryp, CRYP_IMSCR, 0);\n\t\t\tstm32_cryp_finish_req(cryp, 0);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\tif (cryp->irq_status & MISR_IN) {\n\t\t...// 省略ccm 与 gcm处理\n\t\t} else {\n\t\t\t/* Input FIFO IRQ: write data */\n\t\t\tstm32_cryp_irq_write_data(cryp);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n```\n可见这里并没有用dma的方式\n\n## 使用dma的例子\nux500\n这里只提一点, dma的callback 并不是用的当前硬件ip的中断,\ndma每个通道都绑定了一个中断处理函数, 应该是这个处理函数 处理的callback\n\n```c\n\t\tdesc = dmaengine_prep_slave_sg(channel,\n\t\t\t\tctx->device->dma.sg_dst,\n\t\t\t\tctx->device->dma.sg_dst_len,\n\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\tDMA_CTRL_ACK |\n\t\t\t\tDMA_PREP_INTERRUPT);\n\n\t\tdesc->callback = cryp_dma_out_callback;\n```\n\ncallback调用 complete 函数, 唤醒之前因调用`wait_for_completion` 而阻塞的线程\n```c\nstatic void cryp_dma_out_callback(void *data)\n{\n\tstruct cryp_ctx *ctx = (struct cryp_ctx *) data;\n\tdev_dbg(ctx->device->dev, \"[%s]: \", __func__);\n\n\tcomplete(&ctx->device->dma.cryp_dma_complete);\n}\n```\n\n在 `ablk_dma_crypt` 函数中, 设置完dma 传输后, 最终设置了`wait_for_completion(&ctx->device->dma.cryp_dma_complete);` 阻塞了当前线程, 在dma完成传输后会调用对应channel的中断处理函数, 调用callback 中的 complete 唤醒当前线程. 当然callback需要自己设置.\n\n### 君正x2000的aes 驱动\n\n使用dma 时要注意物理地址与虚拟地址之间的转换, 因为DMA只认识物理地址.\n\n看下x2000 的aes驱动的实现全是dma方案.\n\n#### ecb 加密\n\n```c\nstatic int ingenic_aes_start(struct ingenic_aes_dev *aes,\n\tstruct ablkcipher_request *req)\n{\n    spin_lock_irqsave(&aes->lock, flags);\n    ret = ablkcipher_enqueue_request(&aes->queue, req);\n    // 如果时busy状态, 只将request 推入 aes的queue, 待pump_work来处理\n    if (aes->flags & FLAGS_BUSY) {\n\t\tspin_unlock_irqrestore(&aes->lock, flags);\n\t\treturn ret;\n\t}\n    // 处理同步请求\n   \tasync_req = crypto_dequeue_request(&aes->queue);\n    if (async_req)\n        // 设置驱动为阻塞状态\n\t\taes->flags |= FLAGS_BUSY;\n    // 放锁恢复中断\n    sin_unlock_irqrestore(&aes->lock, flags);\n    req = ablkcipher_request_cast(async_req);\n    aes->req = req;\n\taes->total = req->nbytes;\n\taes->in_offset = 0;\n    // in_sg 是跟request 绑定的\n\taes->in_sg = req->src;\n\taes->out_offset = 0;\n    // out_sg 是跟request 绑定的\n\taes->out_sg = req->dst;\n    ctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));\n    aes->ctx = ctx;\n\tctx->aes = aes;\n    // aes写控制寄存器, 这个过程跟在裸机中是差不多的\n    err = ingenic_aes_write_ctrl(aes);\n    // 操作dma 这里是重点 1.1 -->\n    err = ingenic_aes_crypt_dma_start(aes);\n    ingenic_aes_stop(aes);\n    ingenic_aes_finish_req(aes, err);\n}\n1.1 --> ingenic_aes_crypt_dma_start(aes);\nstatic int ingenic_aes_crypt_dma_start(struct ingenic_aes_dev *aes)\n{\n    // ...\n\tstruct scatterlist *in_sg, *out_sg;\n\tint len32;\n    // 如果 in_sg 和 out_sg 都是最后一帧数据, 小于4k\n\tif (sg_is_last(aes->in_sg) && sg_is_last(aes->out_sg)) {\n\t\t// 判断in_sg 和 out_sg 的对齐是不是一致的\n\t\tin = IS_ALIGNED((unsigned long)aes->in_sg->offset, sizeof(unsigned long));\n\t\tout = IS_ALIGNED((unsigned long)aes->out_sg->offset, sizeof(unsigned long));\n\t\tfast = in && out;\n\t}\n\tif (fast)  {\n\t\tcount = min(aes->total, sg_dma_len(aes->in_sg));\n\t\tcount = min(count, sg_dma_len(aes->out_sg));\n\t\t// 初始化 scatterlist\n\t\tprep_sgdata(aes->in_sg);\n         // 参考 https://blog.csdn.net/Wang20122013/article/details/112802013\n        // 调用cache的flush invalidate等方法, 同时会设置scatterlist链表中每个entry的dma_address, 参考dma_direct_map_sg 函数\n        // DMA_TO_DEVICE: 内存到外设 CPU 会做cache的flush 动作. 将cache中的数据 刷写到内存\n\t\terr = dma_map_sg(aes->dev, aes->in_sg, 1, DMA_TO_DEVICE);\n        // DMA_FROM_DEVICE: 外设到内存 cpu将cache置为无效, 这样dma做完后, cpu cache不命中, 会重新加载内存中的内容\n\t\terr = dma_map_sg(aes->dev, aes->out_sg, 1, DMA_FROM_DEVICE);\n         // 获取in_sg的总线地址, dma可以直接访问\n\t\taddr_in = sg_dma_address(aes->in_sg);\n        // 获取out_sg的总线地址, dma可以直接访问\n\t\taddr_out = sg_dma_address(aes->out_sg);\n\t\tin_sg = aes->in_sg;\n\t\tout_sg = aes->out_sg;\n\t\taes->flags |= FLAGS_FAST;\n\t} else {\n\t\t/* use cache buffers */\n        // 不支持fast 时\n        // 将request in_sg 拷贝到 遍历scatterlist 链表拷贝内容到buf_in中, 注意这里会更新in_sg 为下一个scatterlist 数据帧\n\t\tcount = sg_copy(&aes->in_sg, &aes->in_offset, aes->buf_in,\n\t\t\taes->buflen, aes->total, 0);\n\n\t\tlen32 = DIV_ROUND_UP(count, DMA_MIN) * DMA_MIN;\n\t\t// 绑定 buf_in 给 in_sgl, 这里中转了以下, 新建了buf_in buf_out的localbuffer, 并绑定到了in_sgl out_sgl上\n\t\tsg_init_one(&aes->in_sgl,aes->buf_in,len32);\n\t\tsg_dma_len(&aes->in_sgl) = len32;\n        // dma_addr_in 是buf_in的总线地址, dma 可以直接访问该地址, 将它给到 in_sgl的dma_address 成员. dma_addr_out 同理\n\t\tsg_dma_address(&aes->in_sgl) = aes->dma_addr_in;\n\t\tsg_init_one(&aes->out_sgl,aes->buf_out,len32);\n\t\tsg_dma_len(&aes->out_sgl) = len32;\n\t\tsg_dma_address(&aes->out_sgl) = aes->dma_addr_out;\n\n\t\tin_sg = &aes->in_sgl;\n\t\tout_sg = &aes->out_sgl;\n\n\t\taddr_in = aes->dma_addr_in;\n\t\taddr_out = aes->dma_addr_out;\n\t\tprep_sgdata(in_sg);\n\t\taes->flags &= ~FLAGS_FAST;\n        // 同dma_map_sg 刷cache \n\t\tdma_cache_sync(aes->dev, sg_virt(in_sg), len32,DMA_TO_DEVICE);\n\t\tdma_cache_sync(aes->dev, sg_virt(out_sg),len32,DMA_FROM_DEVICE);\n\t}\n\n\taes->total -= count;\n    //主要是操作aes的dma 相关寄存器, 如 engress outgress 地址, 这两个地址即前面的 dma_addr_in dma_addr_out, 如果是fast模式, 这两个地址是跟着in_sg out_sg 走的, 并没有开辟localbuffer\n\terr = ingenic_aes_crypt_dma(tfm, in_sg, out_sg);\n\tif (err) {\n\t\tdma_unmap_sg(aes->dev, aes->in_sg, 1, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(aes->dev, aes->out_sg, 1, DMA_TO_DEVICE);\n\t}\n\treturn err;\n}\n```\n\n这个地方有疑问的一点, aes->in_sgl aes->buf_in aes->out_sgl aes->buf_out, 这几个实际上只映射了一个page, 那传的数据量很大怎么办呢?\n其实这个处理是在中断中做的, 在aes 处理完毕后, 会发送中断, 在中断服务程序中, 就必须处理接下来的数据请求\n这里也很好的体现了流式数据的处理策略\n\n接着看一下中断的处理:\n\n#### 处理dma 中断\n\n```c\nstatic irqreturn_t ingenic_aec_irqthread(int irq, void *data)\n{\n    val = aes_read(aes,AES_ASSR);\n\tmask = aes_read(aes,AES_ASINTM);\n    val = val & mask;   //读aes的中断, 查数据手册即可, aes status 与 interrupt mask register\n    // 查询得知 4 是 dma done的中断\n    if(val & 4){\n        // 将buf_out dma 喂到的数据传给out_sg, 即 request  2.1 --> \n\t\terr = ingenic_aes_crypt_dma_stop(aes);\n        // 清除aes status 的中断位, 表示已经处理完该中断, 可以来下一个中断了\n\t\taes_write(aes,AES_ASSR,4);\n         // 如果请求的total 未完成, 因为这里的策略主要是流式处理的, 对于一次请求(不是只有一帧 request page的情况下), 每次最多只能处理一个page, 而total 是每次会减去一次的处理量\n\t\tif (aes->total && !err) {\n             // 进行下一次的dma 处理. \n\t\t\terr = ingenic_aes_crypt_dma_start(aes);\n\t\t\tif (!err)\n                  // 这里会直接退出, 因为数据还没处理完, 在一个request 数据量很大时, 传入的request 的in_sg 会是一个链表, 包含了很多数据帧, 这里会继续处理后面的帧\n\t\t\t\treturn IRQ_HANDLED; /* DMA started. Not fininishing. */\n\t\t}\n         // 如果这个request结束了, 才会走到这里\n\t\tingenic_aes_finish_req(aes, err);\n         // 控制aes 从aes->queue中取出下一个request 进行处理\n\t\tingenic_aes_start(aes,NULL);\n\t}\n}\n// 这里主要看一下 ingenic_aes_crypt_dma_stop 函数\n2.1 --> static int ingenic_aes_crypt_dma_stop(struct ingenic_aes_dev *aes)\n{\n     // 如果只有一帧 request 请求的话, 已经结束了, 没有下一次了, total 应该判断可以终止了, 这里就unmap调scatterlist entry 就行了\n\tif (aes->flags & FLAGS_FAST)\n\t{\n\t\tdma_unmap_sg(aes->dev, aes->out_sg, 1, DMA_FROM_DEVICE);\n\t\tprep_sgdata(aes->out_sg);\n\t\tdma_unmap_sg(aes->dev, aes->in_sg, 1, DMA_TO_DEVICE);\n\t} else {\n        // total很大的情况, 此处处于中间处理的状态, 刚结束上一帧数据, 需要处理缓存, 需要将dma 喂到物理内存的数据刷到 cache中, 这里其实什么也没做, 因为前面已经invalidate了, 此处buf_out cache 应该是空的, cpu访问会刷新cache的\n\t\tdma_sync_single_for_device(aes->dev, aes->dma_addr_out,\n\t\t\taes->dma_size, DMA_FROM_DEVICE);\n\n\t\tprep_sgdata(&aes->out_sgl);\n\t\t//dump_sgdata(&aes->out_sgl);\n\n\t\t/* copy data */\n         // 将这次aes 处理完的数据buf_out dma 喂到的数据传给out_sg, 注意sg_copy 这个函数会更新out_sg为下一帧的地址\n\t\tcount = sg_copy(&aes->out_sg, &aes->out_offset, aes->buf_out,\n\t\t\taes->buflen, aes->dma_size, 1);\n\t}    \n}\n```\n\n\n\n# 用户空间使用\n\n## AF_ALG socket\nhttps://www.kernel.org/doc/html/v4.19/crypto/userspace-if.html\n\nThe kernel crypto API is accessible from user space. Currently, the following ciphers are accessible:\n\n-   Message digest including keyed message digest (HMAC, CMAC)\n-   Symmetric ciphers\n-   AEAD ciphers\n-   Random Number Generators\n\n使用对称加密算法的例子:\n```c\nstruct sockaddr_alg sa = {\n    .salg_family = AF_ALG,\n    .salg_type = \"skcipher\", /* this selects the symmetric cipher */\n    .salg_name = \"cbc(aes)\" /* this is the cipher name */\n};\n```\n\n# cryptodev-linux\n\ncryptodev-linux 是kernel 原生CryptoApi 提供给用户空间使用的可扩展基座.\nopenssl 编译时通过 加入 `-DHAVE_CRYPTODEV` 和 `-DUSE_CRYPTODEV_DIGESTS` 编译选项支持通过cryptodev访问kernel cryptoapi 来进行 hash 加密等, 注意这种方式也不支持非对称加密\n\n## openssl\n\n参考[ openssl 使用afalg引擎 ](https://blog.csdn.net/wq897387/article/details/120988091)\n`openssl speed -evp aes-128-cbc -engine afalg -elapsed`\n\n### 代码分析\nafalg 作为插件使用, 其实现是在engines/e_afalg.c 中, 编译成 afalg.so 放在/usr/lib/engines-1.1/下\n\n调用setup_engine, 对engine 进行初始化, load 该engine的库\n\n使用时, 需要调用 `EVP_CipherInit_ex` 获得engine 对应的ciper\n```c\nimpl = ENGINE_get_cipher_engine(cipher->nid);\nconst EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);\nctx->cipher = cipher = c;\n\n>>> p *cipher\n$7 = {\n  nid = 419,\n  block_size = 16,\n  key_len = 16,\n  iv_len = 16,\n  flags = 4098,\n  init = 0xffffb53bd804 <afalg_cipher_init>,\n  do_cipher = 0xffffb53bd9a4 <afalg_do_cipher>,\n  cleanup = 0xffffb53bdb2c <afalg_cipher_cleanup>,\n  ctx_size = 128,\n  set_asn1_parameters = 0x0,\n  get_asn1_parameters = 0x0,\n  ctrl = 0x0,\n  app_data = 0x0\n}\n\n// 以aes 为例子, fn 为 afalg_ciphers\nconst EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid)\n{\n    const EVP_CIPHER *ret;\n    ENGINE_CIPHERS_PTR fn = ENGINE_get_ciphers(e);\n    if (!fn || !fn(e, &ret, NULL, nid)) {\n        ENGINEerr(ENGINE_F_ENGINE_GET_CIPHER, ENGINE_R_UNIMPLEMENTED_CIPHER);\n        return NULL;\n    }\n    return ret;\n}\n```\n\n`afalg_ciphers`  是在 setup_engine 阶段bind的\n\n```c\n#0  bind_afalg (e=0x19209700) at engines/e_afalg.c:715\n#1  0x0000ffffa5b72fd4 in bind_helper (e=0x19209700, id=0x19209860 \"afalg\") at engines/e_afalg.c:755\n#2  0x0000ffffa5b73080 in bind_engine (e=0x19209700, id=0x19209860 \"afalg\", fns=0xffffe9357908) at engines/e_afalg.c:761\n#3  0x0000ffffa5eef3bc in dynamic_load (e=0x19209700, ctx=0x1920c000) at crypto/engine/eng_dyn.c:480\n#4  0x0000ffffa5eeee80 in dynamic_ctrl (e=0x19209700, cmd=206, i=0, p=0x0, f=0x0) at crypto/engine/eng_dyn.c:336\n#5  0x0000ffffa5eee154 in ENGINE_ctrl (e=0x19209700, cmd=206, i=0, p=0x0, f=0x0) at crypto/engine/eng_ctrl.c:174\n#6  0x0000ffffa5eee4ac in ENGINE_ctrl_cmd_string (e=0x19209700, cmd_name=0xffffa5ff7010 \"LOAD\", arg=0x0, cmd_optional=0) at crypto/engine/eng_ctrl.c:289\n#7  0x0000ffffa5ef1290 in ENGINE_by_id (id=0xffffe9359f32 \"afalg\") at crypto/engine/eng_list.c:328\n#8  0x0000000000470a54 in setup_engine (engine=0xffffe9359f32 \"afalg\", debug=0) at apps/apps.c:1300\n#9  0x000000000045c978 in speed_main (argc=0, argv=0xffffe9359b40) at apps/speed.c:1814\n#10 0x00000000004380a0 in do_cmd (prog=0x19207940, argc=6, argv=0xffffe9359b10) at apps/openssl.c:570\n#11 0x0000000000437278 in main (argc=6, argv=0xffffe9359b10) at apps/openssl.c:189\n```\n后面所有的运算, 都需要传递ctx, 从ctx 中解出ciper来, ciper 封装了具体的操作, 对应了engine的能力.\n同linux crypto api的对接, 是engine的主要工作.\n\n其中ciper中的`init` 指向 `afalg_cipher_init`, 这个里面`afalg_create_sk`会建立同kernel crypto api的socket\n\n```ad-warning\n从目前实现的代码来看, 这个afalg只支持aes-cbc-128 aes-cbc-192 aes-cbc-256\n```\n\n```c\n    ciphertype = EVP_CIPHER_CTX_nid(ctx);\n    switch (ciphertype) {\n    case NID_aes_128_cbc:\n    case NID_aes_192_cbc:\n    case NID_aes_256_cbc:\n        ciphername = \"cbc(aes)\";\n        break;\n    default:\n        ALG_WARN(\"%s(%d): Unsupported Cipher type %d\\n\", __FILE__, __LINE__,\n                 ciphertype);\n        return 0;\n    }\n```\n\n支持能力是在load 阶段会调用`ENGINE_set_default_ciphers`\n查询engine 支持的算法\n\n```c\n\nint ENGINE_set_default_ciphers(ENGINE *e)\n{\n    if (e->ciphers) {\n        const int *nids;\n        // 算法的标识为 nid, 查询engine 支持的算法列表, 返回值放到nids 数组中\n        // ciphers 为 afalg_ciphers 方法\n        int num_nids = e->ciphers(e, NULL, &nids, 0);\n        if (num_nids > 0)\n            return engine_table_register(&cipher_table,\n                                         engine_unregister_all_ciphers, e,\n                                         nids, num_nids, 1);\n    }\n    return 1;\n}\n\n#0  ENGINE_set_default_ciphers (e=0x36e4d700) at crypto/engine/tb_cipher.c:50\n#1  0x0000ffffb687a4ec in ENGINE_set_default (e=0x36e4d700, flags=65535) at crypto/engine/eng_fat.c:16\n#2  0x0000000000470b1c in setup_engine (engine=0xffffe3d3df32 \"afalg\", debug=0) at apps/apps.c:1310\n#3  0x000000000045c978 in speed_main (argc=0, argv=0xffffe3d3d840) at apps/speed.c:1814\n#4  0x00000000004380a0 in do_cmd (prog=0x36e4b940, argc=6, argv=0xffffe3d3d810) at apps/openssl.c:570\n#5  0x0000000000437278 in main (argc=6, argv=0xffffe3d3d810) at apps/openssl.c:189\n```\n\n如果不支持某个算法, 则通过`impl = ENGINE_get_cipher_engine(cipher->nid);` 查询会返回空\n所有支持的算法会注册到全局的链表中, ENGINE_get_cipher_engine 就是通过查询这个全局的链表得到的哪个engine支持这个nid标识的算法.\n\n\n\n\n![kernel_crypto.drawio](attachments/kernel_crypto.drawio.svg)\n\n","tags":["crypto"],"categories":["安全","linux"]},{"title":"riscv sifive world guard","url":"/2022/04/25/TEE/sifive shield/","content":"\n# The SiFive WorldGuard WhitePaper\n\n\n\nSiFive® Shield是一个开放的安全平台架构，包括一个安全启动、加密引擎和一个名为`SiFive WorldGuard`的硬件隔离多域解决方案。它为硬件提供了保证在同一单核或多核平台上运行并访问共享资源（如内存和外设）的不同软件应用程序之间进行隔离的手段。 该解决方案适用于任何SiFive Core IP产品和任何软件架构。它与RISC-V ISA完全兼容，不需要对其进行任何修改。\n\n\n\nSiFive WorldGuard提供了核心驱动和进程驱动的模式以实现多域安全性，从而为内核、缓存、互连、外围设备和内存提供数据保护\n\n在SoC内部，WID标记从内核扩展到了高速缓存、互连、外围设备、总线主控器、DMA区域和存储器, 在高性能多核系统中，应用程序或OS环境都可以被隔离和保护。对于更为普遍的单核嵌入式系统，例如，使用PID驱动的运算WID来保护和隔离用户模式和机器模式之间的执行。\n\n\n\nSiFive Shield解决方案创建 \"world\"，聚集运行在内核和其他主控资源（如DMA通道）以及从属资源（如存储器和外设）上的应用程序。\"world\"的数量是硬件可配置的，取决于内核和主控器的数量、内存配置和软件架构。\n\n\n\n这个解决方案并没有取代RISC-V内核的PMP机制（适用于单一内核的内存），而是将其扩展到多内核、多软件系统与其他主控器。\n\n具体SiFive Shield 架构的介绍可参考 [SiFive Shield开放安全平台架构](https://www.bilibili.com/video/BV1D7411A7rr/), 下面主要介绍的是sifive world guard 方案.\n\n\n\n## pmp 方案\n\n由于有了特权模式管理和PMP，在RISC-V内核上可以很容易地开发出安全软件隔离的产品。基于这些硬件机制和SiFive提供的附加机制，可以为各种平台开发解决方案。\n\n<img src=\"images/image-20211202104658906.png\" alt=\"image-20211202104658906\" style=\"zoom:150%;\" />\n\n这种方法基于一个管理程序，也被称为 \"安全监控器\"，工作在M层. 能够管理不同的独立软件容器。其想法是只有安全监控器管理特权模式，因为它是唯一能够访问这一功能的软件。容器的资源（内存、外围设备）和容器之间的通信也是由管理程序动态控制和分配的.\n\n一个非常常见的软件架构是让安全监控器以机器模式（M-mode）运行，控制容器。每个容器可以由两部分组成：以监督者模式（S-模式）运行的操作系统和以用户模式（U-模式）运行的应用任务。\n\n<img src=\"images/image-20211124204149789.png\" alt=\"image-20211124204149789\" style=\"zoom: 150%;\" />\n\n地址寄存器名为 `pmpaddr0` 到 `pmpaddrN`, PMP配置寄存器为 `pmpcfgn`, 包含`PMP0`-`PMPN`.\n\n每一组PMP寄存器可以用于表示某一块连续的物理内存的起始地址和大小，以及当前CPU对这块连续物理内存的访问权限(读/写/执行)。当CPU(运行在非Machine mode权限时)对内存发起访问时，硬件会按顺序查看各组PMP寄存器，当发现某组PMP寄存器所表示的物理内存区间包含了CPU将要访问的内存的物理地址时，中止对PMP寄存器的遍历，并根据这组PMP寄存器所表示的访问权限来决定当前内存访问操作是否合法，然后进行正常访存或抛出异常信息\n\n\n\n## sPmp 方案\n\n<img src=\"images/image-20211207173012006.png\" alt=\"image-20211207173012006\" style=\"zoom:150%;\" />\n\n<img src=\"images/image-20211207173044010.png\" alt=\"image-20211207173044010\" style=\"zoom:150%;\" />\n\n<img src=\"images/image-20211207173157838.png\" alt=\"image-20211207173157838\" style=\"zoom:150%;\" />\n\n芯来方案上扩展了pmp方案, 增加了一组与pmp相关寄存器类似的spmpcfg 寄存器与其对应的地址寄存器, 支持更一步细粒度的物理内存隔离机制.\n\nS = 0 时, 只支持U 模式访问, S = 1 时, 同时支持S/U 模式访问, 该方案用来进一步的隔离U模式的应用之间的物理内存隔离.\n\n<img src=\"images/image-20211207173506859.png\" alt=\"image-20211207173506859\" style=\"zoom: 200%;\" />\n\n## world guard 方案\n\n对于更复杂的平台来说，PMP和特权模式有很大限制。由于特权模式和PMP的范围被限制在其内核和软件上，它们只能控制单个内核的内存映射区域。pmp相关的寄存器属于那个单一的内核，所以它们的值和由此产生的控制不与其他内核共享，也不和其他核约定。此外，其他主控器，如DMA，是独立于内核及其应用的；它们能够间接地、不安全地访问那些被限制在一个内核内的资源，因为这些访问限制并不适用于其他主控器。\n\n\n\nWorldGuard将系统分成两部分：master和slave。master发出的任何请求都被标记为一个值，一个world ID. 这个被标记的请求被发送到slave，发送到slave后, world id 被检查。只有当请求的目标资源与master的world id相同时，访问才会被批准。当然，给定或修改master或slave的world id的权限被严格控制。这种方法为运行在不同内核和主控器上的软件所使用的资源（内存、外围设备）提供了强有力的隔离。这种软件控制是基于硬件机制的。这种解决方案适用于任何RISC-V内核。\n\n\n\n![image-20211202111612665](images/image-20211202111612665.png)\n\n### 核心驱动策略\n\n每个core被分配一个world id. 核心驱动策略的原则是将master、内存区域和外围设备聚集在\"world\"的资源集合中。在这个策略中，软件没有特定的属性，自动\"属于\"它所运行的master所属的\"world\"。这些\"world\"是相互分离的，这意味着在属于\"world 1\" core1 的核心上运行的软件不能访问属于\"world 2\" core 2的资源（内存部分、外设）. 当然，对于\"world\"间的通信，一些内存部分可以属于一个以上的\"world\"，表现为共享内存。\n\n因此，一个唯一的world ID值被分配给一个world，而在这个world中，每个master都被分配了相同的 world ID值。这种分配通常是针对每个master的，就像一个core，但对于强化的IP块，可以有更精细的划分。例如，它可以为多通道DMA的每个通道分配，用world ID标记每个离开主控的请求。\n\n\n\n在slave侧，每个存储器或外设都有一个访问控制列表（ACL），包含每个world ID的访问权限。通过通信总线，每个来自master的标记请求被发送到slave，并根据其访问控制列表进行分析。这些ACL检查IP块的功能与PMP的功能非常相似，world ID字段作为一个额外的字段被检查。发送过来的请求的world id不匹配或者没有world id 会导致请求被立即拒绝。所支持的world id 数量没有理论上的限制.\n\n\n\n核心驱动的方案对于大型系统是有吸引力的，这个方案对两个或更多的核心有意义。一个双核系统由一个双world架构组成，有一个安全世界和一个非安全世界。核心驱动模式不需要对运行在应用核心上的应用软件进行修改。事实上，这个软件不知道它甚至在WorldGuard系统的一个世界中运行。\n\n\n\n核心驱动的方案是最简单的，需要的修改也最少。任何在特定内核上运行的代码都与一个world联系在一起，无论它运行到何种特权模式，该内核都属于这个world。因此，任何在M-、S-或U-模式下运行的代码都属于同一个world。由于这个原因，core内的L1缓存不需要任何修改，因为每个l1 cache line是core间隔离的。一个附属于core的WID寄存器指定了world ID，用于标记从物理core出来的任何请求。这个world ID是由运行在可信内核上的可信软件使用可信配置world ID。\n\n### 进程驱动策略\n\n现在，world的区别也可以取决于特权模式；也就是说，同一核上的特权模式（M-模式、S-模式、U-模式），拥有不同的world ID。这种进程驱动策略的一个明显场景是应用管理程序/安全监控器，如上文所述，在多核、multi-master的SoC上。最简单的例子是让一个内核 \"托管 \"两个world：world 1用于访问最敏感的资产（如key）和一些特定的外围设备（如指纹外设），world 2用于运行通用的应用软件。\n\n\n\n适用于当不同的软件容器需要在同一个核心上共存时，这些容器有不同的安全级别，当软件容器要能够独立运行时，它们之间需要隔离. 一个双容器的单核系统由双世界架构组成，包括一个安全世界和一个非安全世界。对于这个方案，内核支持M-、S-和U-模式（有或没有satp寄存器）的能力是最佳选择。在进程驱动的方案中，S-PMP的使用被选择性地考虑为更好的隔离。\n\n\n\n除受信任的软件外，其他代码也可以改变核心WID寄存器中的WID。每个task可以属于不同的world.\n\n\n\n首先有一个secure monitor，以M模式运行，属于一个特殊的world 1。然后，这个安全监视器管理一个实时操作系统，以S模式运行，属于world2。最后，这个操作系统管理的任务，都是以U模式运行的，每个任务都可能有一个不同的WID。安全监控器，甚至是操作系统，都有能力根据操作系统的要求来改变任务的WID。这种软件架构与通用的软件隔离架构相匹配。\n\n\n\n\n\n![image-20211202115141605](images/image-20211202115141605.png)\n\n\n\n### 配置\n\nWorldGuard的配置，包括master的分配和ACL 访问控制列表的定义，必须以可信的方式进行，因此需要成为平台信任链的一部分，从平台的信任根开始，安全启动。此外，配置应在平台启动时设置，在应用程序启动前进行。这是一个通常在安全启动操作之后进行的操作，WorldGuard配置固件是第一个被安全启动检查和运行的应用程序。只有在这个配置完成后，应用软件才能启动。\n\n\n\n在启动时，安全启动通过数字签名来检查配置固件的完整性和来源。只有当这个检查成功时，它才能在一个特定的内核上执行，这个内核被命名为受信任的内核。下面是启动时的备选方案:\n\n- 整个平台是完全可访问的，没有进行控制（WorldGuard right senforcement尚未启用），因此允许配置固件轻松配置和访问平台。\n\n- 整个平台是不可访问的，受信任的内核被分配了一个高特权的world ID，它只允许这个core访问配置。这是首选方案.\n\n这些world ID和ACL的整体配置被保留给受信核心，因为它被分配了受信WID。如果平台上有其他核心，在WorldGuard配置完成之前为idle状态。从安全的角度来看，它们不能配置任何东西，因为它们没有被分配到可信配置的world ID。\n\n\n\n可以是将配置存储在嵌入式nvm存储器中，通过数字签名防止修改，也可以通过加密防止未经授权的访问。这个配置文件由配置固件读取，并确定平台上的世界拓扑结构：有多少个world，哪些master属于哪些world，以及存储器如何分割/共享。\n\n\n\n配置寄存器有两种主要类型。在master端，这些寄存器被用来包含world ID（WID），在slave端，这些寄存器用于定义ACL 访问控制列表。\n\n受信任的核心根据配置定义，在每个master的\"`WID寄存器`\"中设置WID。这个寄存器被用来标记从master到slave的请求。可信核心还设置了ACL寄存器(访问控制列表)，该寄存器对应于资源的定义和它们从属于哪些world。\n\n\n\n配置完成后, 可以有下面两种方案:\n\n- 所有与配置有关的寄存器都被锁定，将来没有办法修改配置，即使是使用可信配置world ID的可信内核也是如此。这种配置非常安全，但没有提供任何灵活性。它被限制在资源被分配一次，并且内存资源大小正确的用例中。对于没有动态内存分配（malloc）的用例更有意义\n- 与配置有关的寄存器没有被锁定，可以在应用执行期间被配置。只有拥有可信配置world ID的可信内核可以修改设置，但可以根据应用程序的要求进行修改（例如，内存动态分配或外设分配变化）。它适应于外设被交替分配到不同world的使用情况。在这种情况下，受信核心分配给受信配置WID，它用来处理来自其他世界的改变配置的请求。由于受信任的核心被用于高级别的安全配置，一个常见的情况是，这个受信任的核心被用于以安全为中心的应用，如加密计算、密钥处理或随机数生成。\n\n在配置设置之后，应用软件可以在其他内核上启动，从睡眠或等待中断状态中唤醒。\n\n### 框图\n\n![image-20211202115916799](images/image-20211202115916799.png)\n\n​                                  该图提供了SiFive WorldGuard解决方案在具有DMA、存储器和外设的多核芯片上的概况\n\n<img src=\"images/image-20211203111852283.png\" alt=\"image-20211203111852283\" style=\"zoom:150%;\" />\n\n### 通用设计方案\n\n在复位时，除了受信任的核心，slave的配置寄存器没有被设置。来自这些master的请求永远不会被授权。同样地，slave的配置寄存器也没有被设置，这意味着没有任何访问请求可以被批准。\n\n受信任的核心被分配了受信任的配置WID，使运行在该核心上的软件能够配置master和slave的寄存器。这个阶段使受信任的核心能够在系统上设置WorldGuard配置。\n\n在核心驱动的方案中，WID值存储在master的寄存器中，只能由受信任的核心来设置和改变，这意味着配置是非常稳定的。进程驱动的方案非常相似；注册的WID值取决于特权模式，对于S-和U-模式，取决于可能的WID值列表，由受信任的核心定义。\n\n\n\nThe `trusted configuration WID` value is the only WID to access the WID-filters, the WG-PMPs, the WG-markers, and for the cores in process-driven mode, the WG-Mmode, WG-Smode, and WID-listed registers\n\n\n\n属于某个world的每个master会被分配一个相同的、唯一的world id.\n\nWID从master到slave，与master出的请求一起，通过总线传输。\n\n每个master有一个WID-marker寄存器, 存储wid。这个寄存器被用来标记每个从master发出的请求。该寄存器可以被锁定, 该寄存器可以被锁定，锁定后不再支持修改, 直到下一次复位。\n\nWID的值在wid-range 范围内, 但某些值是固定的:\n\n- 没有权限的值 no-access\n- 受信核心的wid值\n- 可以分配给master任意的wid值, 除了受信WID之外.\n\n复位阶段, 受信核心的wid被自动分配给受信核心, 这个world 是安全世界\n\n#### 对于master而言(除了core之外):\n\n- WID-marker寄存器只能由受信核心secure monitor 初始化和修改, 基于nvm 中的配置. wid的值在非锁定的情况下可以被修改.\n\n#### 对于core:\n\n- WID-marker寄存器只能由受信核心secure monitor 初始化和修改, wid的值在非锁定的情况下可以被修改.\n- 在进程驱动策略中, WID-Marker 寄存器从WID-[mode] 寄存器中load 而来, [mode]指的是M/H/S/U 模式\n  - WID-[mode] 寄存器由受信核心secure monitor 设置, 在WID-[mode]-list 寄存器定义的范围内.\n- 每个master有一个WID-Marker寄存器, 对于多主控的器件, 如DMA的多个通道, 每个通道视作一个主控.每个通道都有一个WID-Marker 寄存器\n\n#### 对于slave 侧:\n\n- 每个slave有一个\"filtering\" 过滤配置的接口, 对应于前面介绍的 ACL(访问控制列表). \n  - 对于外设而言, 称作WG-filters寄存器\n  - 对于内存, WG-PMP, 类比RISVC核心的PMP, 和PMP使用相同的策略.\n  - 决定哪些wid可以访问该slave\n    - WG-PMP 配置和PMP相似,有一个WID的字段和其对应的访问属性的字段(RWX)\n  - filtering 接口由受信核心的软件(secure monitor或S模式下的操作系统, 它们拥有受信的wid)配置.\n- 在slave侧收到请求时, 总线上的请求一并携带了wid\n  - 通过filtering接口判定wid是否在允许的wid范围内, 如不在允许wid范围内, slave发送异常.\n\n#### 对于cache(片内缓存):\n\n- 缓存是一种特殊的器件,即是master, 又是slave.\n- 每个cache line 被扩展了一个wid字段, cache line中缓存多的内存地址附加了wid 段.\n- 离开cpu core的请求附带了wid, 来自于core的WID-Marker寄存器\n- 如果cache line的wid字段与请求的wid 一致, 则cache 命中, 如不一致, 即使cache line的tag一样, 也会cache miss.\n- 对于只使用了核心驱动策略,L1-cache 不用进行额外的修改, 不用附加wid字段, 因为L1-cache本来就是core间隔离的, 只需要配置L2-cache和L3 的即可.\n\n####  对于bus 总线:\n\n- 需要传递master的wid, 所以需要额外定义一个字段携带wid\n\n\n\n### 核心驱动策略的实现\n\n这种策略是比较简单的, 不需要关注cpu运行的特权模式, 只对core进行配置\n\n1. 在没有被受信核心上受信代码配置wid前, 该core上的WID-Marker寄存器的初始值是no-acess 值.\n2. WID-Marker寄存器通过内存地址映射, 该地址只能由受信wid的代码修改. 这个filter 限制的wid范围是被硬编码,其他wid无权访问.\n3. WID-Marker寄存器可以被受信的wid 读写, 可选的, 可以被其他wid读.\n4. 不论其运行的模式是什么, core的wid都是同一个.\n5. 每次只能分配一个wid, 即同一时刻每个core只可能有一个wid值, 不同的core可以有相同的wid值, 离开该core的请求携带的wid值来自于WID-Marker寄存器, 这个是硬件自己实现的.\n6. L2 cache 和 L3 cache cache line上附带了wid 字段, 访问地址的请求携带了wid, cache line的wid和tag同时匹配, 才会cache命中. L1 cache 不用关注.\n\n\n\n### 进程驱动策略的实现\n\n到目前为止，这种方案是最灵活的，并为内核内的world管理提供了细颗粒度。在这个方案中，核心上的WorldGuard实现取决于特权模式，这意味着在不同特权模式下运行的代码可以有不同的WID。\n\n在进程驱动的方案中，内核的WID-Marker寄存器可以由M模式或S模式的固件(secure monitor或S模式上的操作系统)配置，但要在S和U模式的定义范围内。\n\n简单地说，S模式或U模式的当前WID值（WID_Smode或WID_Umode）是本地控制的，由上层权限级别的固件定义，但在受信核心定义的范围内(（WID_S-list寄存器定义的范围或WID_U-list 寄存器定义的范围）。\n\n此外，M模式的固件、S模式和U模式的软件可以运行在不同的world里，由不同的WID来识别。例如，U模式的任务切换通常由在S模式下运行的操作系统管理，而与任务切换相对应的WID切换则由M模式的安全监控器代表S模式的操作系统管理。\n\n同样，S模式下的软件（即容器）切换通常由运行在M模式下的M模式固件（即管理程序）管理，因为WID切换与容器切换相对应。这意味着M模式的固件作为受信任的软件，有改变WID-标记寄存器的权限。\n\n\n\n#### 相关的寄存器\n\n#### WID-marker寄存器\n\n在进程驱动模式下, 从WID-[mode]寄存器(WID-Mmode/WID-Smode/WID-Umode)load 而来\n\n#### M-mode registers\n\n- WID-Mmode register:\n  - 定义了每个core的M模式下的软件所属的wid\n  - 该寄存器可以被M模式的固件修改, 但是要在WID_M-list registers 中规定的范围内.\n- WID_M-list register:\n  - 定义了M模式的wid 的允许的范围\n  - 只能由受信固件(受信wid的M层固件)根据受信配置修改.\n  - 这个寄存器通常应该只包含一个值，即每个core M模式的 \"functional\" 值。特殊的, 如果是受信core, 该值为受信WID.\n  - 这个寄存器可以被锁定, 锁定后不能再被修改, 直到复位.\n  - 这个寄存器限制了wid的范围, 因为每个core的M层可以修改WID-Mmode寄存器以修改其core上M层的wid值, 但是该wid值必须在这个WID_M-list register定义的范围内. 保证了非受信核心不能把自己改成受信wid值.\n\n#### S-mode registers\n\n- WID_Smode register\n\n  定义了每个core上S模式下的软件所属的wid\n\n  - 可以被在trusted configuration WID里的wid的软件修改.\n  - 该寄存器可以被M模式的固件修改, 但是要在WID_S-list registers定义的范围内\n\n- WID_S-list register\n\n  该寄存器用于存储S模式下的允许的WIDs列表。该寄存器定义了S模式任务在进程驱动模式下的core的授权WID值范围。\n\n  - 这个寄存器不包含M模式的wid范围\n  - 只能由受信固件(受信核心M层固件)根据受信配置修改.\n  - 这个寄存器通常包含一个单一的WID值，对应于操作系统。然而，它可能包含两个值。一个用于 \"常规 \"操作系统，一个用于TEEOS。\n  - 这个寄存器可以被锁定, 锁定后不能再被修改, 直到复位.\n  - 这个寄存器可以防止在内核上运行的任何固件设置非法的WID值，如对应于其他世界、其他内核的WID。\n\n#### U-mode registers\n\n​\tU 模式运行时的wid值\n\n- WID_Umode register\n\n  - 可以被在trusted configuration WID里的wid的软件修改.\n  - 也可以被M层固件修改, 但是要在WID_U-list范围内\n\n- WID_U-list register\n\n  该寄存器用于存储U模式下的允许的WIDs列表。该寄存器定义了U模式任务在进程驱动模式下的core的授权WID值范围。\n\n  - 有多少个WID_U-list register，就有多少个S模式的WID值。例如，\"单核可信世界 \"用例有两个值(可信世界和normal世界)，因此有两个WID_U-list寄存器.\n  - 这些寄存器定义的WID范围不应该包含M 模式下和S模式下的WID范围\n  - 只有受信核心M层固件可以修改该寄存器\n  - 这个寄存器可以被锁定, 锁定后不能再被修改, 直到复位.\n  - 这些寄存器可以防止在核心上运行的任何固件（无论是S模式还是M模式）设置非法的WID值，例如，与其他世界、其他核心相对应的WID\n\n\n\n#### 小结\n\nWID-[mode] 寄存器可以被M层固件修改, 但是要在Wid_[mode]-list register 规定的范围内, 超出了范围会发生异常. 同一时刻, 每个core只能有一个wid值. 每个core 或每个task可以有相同的wid值. 作用到WID-Marker上, 离开cpu的请求会被标记上wid. 标记是被硬件自动触发的. L1/L2/L3 cache 缓存也有wid的字段标记. trusted configuration WID 是被硬编码的, 记录了受信WID.其他核心的wid值模式是no-access值, 需要被配置.\n\n\n\n### DMA 配置\n\nDMA的每个通道都有一个wid, 由拥有受信wid的受信核心配置, 不同的通道可以配置相同的wid值, 离开dma的请求会携带对应的wid标记.\n\n- 推荐做法是分配一个受信wid专用的通道\n- 其他通道的资源将受到应用WID的限制\n\n### WorldGuard CLINT\n\nThe SiFive Core-Local Interruptor (CLINT), 包含一个timecmp寄存器，用于与基于时间的中断进行比较，触发时钟中断(通常作为tick使用)。 安全问题是，一个hart的timecmp register可以被另一个hart配置，这可能对第一个hart运行的软件产生严重影响。\n\nWorldGuard通过添加一个配置前端来确保CLINT的安全，根据与hart相对应的WID值过滤它们的timecmp寄存器。这些WID值是由受信核心设定的。\n\n\n\n### 中断管理\n\nWorldGuard解决方案实现了中断管理，中断处理程序可以将world 它的wid联系起来。尤其适用于进程驱动模式，在这种模式下，不同的WID可以在同一个内核上使用。 FULL isr in U mode.\n\n- 一些中断是通过CSR授权给一个特定的core。\n- Platform-Level Interrupt Controller (PLIC), 在M 模式下绑定一个特定的中断处理 PLIC handler.\n- M层的secure monitor, 记为WIDi, 来自于WID-Mmode register, RTOS 或 kernel 运行在S模式上, 记为WIDj. 来自于WID-Smode register. 应用task wid记为 WIDn, 来自WID-Umode register.\n- S模式的中断处理程序是在中断源被完全识别后管理中断的，名为 \"源处理程序\"。这些源处理程序的地址表是由S模式在初始化时配置的；一旦完成，这个表就被M模式的安全监视器锁定在PMP中。这个表以后将被M模式的PLIC处理程序访问。\n- 正在U模式下运行task时, 如果这些中断(各S模式注册的中断)之一被触发，PLIC会向内核发送一个中断信号，进而触发以M模式运行的PLIC handler。自动把WID切换到WIDi。\n- M模式的PLIC处理程序将应用task的WID值添加到堆栈，并执行上下文备份。\n- M模式的PLIC处理程序精确地确定了中断源，然后确定了这个源的中断处理程序的地址。\n- M模式的PLIC处理程序切换到S模式，自动将WID切换到WIDj，然后跳转到这个源处理程序。\n- S 模式上的中断处理函数处理中断, 设置WID_Umode 寄存器\n- 中断结束, 回到M模式, wid 自动切换为WIDi, M层 ecall 的handler 恢复应用task的上下文, 恢复task wid, 继续运行zhi前被中断了的U task.\n\n### slave 实现\n\n存储器，如RAM，可能没有任何寄存器用于访问或甚至配置它们。filtering interface用于过滤请求的WID值。例如，filtering将带有WID标记的数据访问请求与授权的内存范围和访问模式（R/W）进行比较。如果它在范围内并且是被批准的访问模式，则请求被批准。否则，就会触发一个异常/中断。过滤接口可由具有可信配置WID的受信核心读写，可选的,允许其他核对其WID分配的资源进行只读访问。\n\n\n\n#### memory 实现\n\nWG-PMP 定义了开始和结束地址，读/写访问模式。这种内存配置重用了PMP寄存器的规范。\n\nWG-PMP 寄存器的数目可以被定制\n\n不同的WID 可以访问同一个内存区域\n\nWG-PMP 用于过滤合法的wid 数据请求. 不合法即不在其范围内, 会发生异常\n\n可选的, 受信核心的wid 总是被允许, 而不用管WG-PMP的配置\n\n可选的, WG-PMP 配置可以被锁定, 不能再被修改直到重启.\n\n\n\n#### 外设的实现\n\n WG-filters 用于管理外设的访问权限. 由受信wid 受信固件配置. 可选的, 拥有受信wid的受信固件总是可以使用该外设, 不论WG-filters配置是什么. 可选的, WG-filters寄存器可以被冻结,直到重启.\n\n- 方案1: 可信wid 只能对WG-filters 进行配置, 不能使用这个外设. 意味着有两组wid, 一组用于配置, 一组用于使用.\n- 方案2: 可信wid的软件即可以对其进行配置, 也能使用. 只有一组wid\n\n外设配置与外设特性相适应。例如，可能有与使用寄存器不同的内存配置寄存器，允许在内存视图中进行分割，从而在可信配置WID和其他WID之间进行过滤。\n\n\n\n![image-20211202155908826](images/image-20211202155908826.png)\n\n\n\n### L-cache (缓存)的实现\n\n在cache line tag基础上添加了wid字段, 每次访问cache时, 需要额外检查wid 是否匹配\n\n- 该缓存WID字段与核心WID值进行比较，以进行读取访问。如果它不一样，就有一个缓存错误--即使tag相同。\n- 如发生了cache 替换(cache line满了), tag标记相同, 也会发生替换, wid 被修改为本次访问请求对应的wid\n- 每次cache line的update, wid 会同步update.\n- 发生cache miss时,wid标记的请求会发到下一级的cache, 如都不命中, 最终发送给memory\n- 访问请求来自于core或其他master(如DMA), 访问请求会被其wid标记.\n\n### TileLink\n\n由于TileLink是SiFive Core Complex内使用的总线，其技术主要用于传输WID信息。WID是通过WID字段来传输的。\n\n- WID通过TileLink总线传输到相关的slave。\n- WID 标记来自于发出请求的master(包括core)\n- 从slave 发送到master的请求, wid 仍是master的.\n- 从TileLink 传输到AXI, 需要WID的桥器件.\n\nWorldGuard解决方案可用于包括RISC-V和非RISC-V内核（如Arm内核）的异构平台，通过使用其他总线技术（如AXI或AMBA）处理其他特权和安全权利。转换桥必须设计在不同的端口上（前端口、系统端口、外围端口、内存端口），这取决于信号的来源/去向。例如，前端口执行从AXI信号到WG WID（WG_AXI-TL_MARKER）值的转换，而内存端口将WG-WID值转换为AxPROT位（WG_AXI_MARKER）。\n\n\n\n### 迁移方案\n\narm trust zone based TEE 方案迁移, \n\n• One world in M-mode, the trusted-WID\n• Two worlds in S-mode: kernel-WID and rich-OS-WID\n• multi worlds in secure U-mode: TA#1-WID TA#2-WID ...\n• multi worlds in normal U-mode: UA#1-WID UA#2-WID ...\n\n\n\nM 层受信固件可以配置WID-[mode] register 以及 WID_[mode]-list register, 启动rich os 和 teeos. 如果发生了中断，M层固件会以M模式管理它。根据中断的情况，对寄存器和WID进行相应的配置，并执行正确的处理程序。事实上，WorldGuard解决方案远远超出了TEE和REE之间的分割，因为它还提供了不受信任的任务之间的隔离和受信任任务之间的隔离。\n\n\n\n![image-20211202162337213](images/image-20211202162337213.png)\n\n\n\n### WorldGuard Modules\n\n需要的硬件module:\n\n\n\n![image-20211202162524636](images/image-20211202162524636.png)\n\n![image-20211202162610803](images/image-20211202162610803.png)\n\n![image-20211202162711482](images/image-20211202162711482.png)\n\n![image-20211202162730130](images/image-20211202162730130.png)\n\n为了使复杂或传统的IP块适应World-Guard，可能需要额外的模块。除了DMA的例子之外，加密IP也是为WorldGuard定制的重要IP块，因为它可以从通过世界管理的受控访问中受益。密钥的值和使用通常是不能在不同world之间共享的资源。因此，必须提供类似于DMA多个独立通道的密钥上下文。\n\n\n\n### WorldGuard Configuration Code\n\n一旦安全启动执行完成，由于其硬编码值，受信任的核心将检查并执行WorldGuard配置代码。这段代码设置了整个系统的配置，即核心WID-[mode] register WID_[mode]-list register、WG-PMPs和WG-filters。\n\n其他core的WID寄存器值将被分配到由受信任的内核管理的配置文件中提供的值。该配置文件存储在一个非易失性存储器（NVM）中，通常是一个闪存或OTP存储器。\n\n受信核心是第一个启动的，其WID-Mmode register 会被自动分配受信wid。\n\n- 受信核心WG配置代码用受信WID值来配置它需要的任何内部RAM区域的访问。\n- 受信核心WG配置代码用受信WID值来配置访问存储了wid配置的NVM区域。\n- 通过nvm的wid配置配置其他核的相关的wid 寄存器或其他master的WID寄存器还有WG-PMPs WG-filters.\n- 受信core启动其他core\n- 受信core 继续运行M层 S层代码 U层代码\n- 其他core 运行其M层 S层代码 U层代码\n\n\n\n","tags":["riscv"],"categories":["安全"]},{"title":"HSM 相关","url":"/2022/04/20/hxd_new/汽车安全相关/HSM 相关探讨/","content":"\n# HSM 作用\n\n![full hsm](https://pic4.zhimg.com/v2-cc6c609c713dab25d187489a6a436cdf_r.jpg)\n\n包含两个部分:\n1.  Security building blocks负责加密/解密的硬件操作；\n2.  Logical building blocks负责与Application ECU交互数据以及软件的加密/解密操作；\n\nHSM 最重要的作用是安全边界, 和trustzone的机制类似, 提供安全的物理隔离能力, 安全rom和安全ram 无法被外部cpu 访问, 即使外部cpu 环境被破解, 也能保证hsm 运行的内容无法被探知. 当前的hsm产品中大多是过了FIPS 140-2 level3 标准的.\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170646.png)\n\n密钥存储/派生/权限管控/交换机制处于hsm内部(授信环境), 密钥存于安全rom或安全ram中, 无法被外部拿到.\n\n# 与 只有硬件安全ip 加 otp 方案的对比\n\n1. 该方案密钥即使可以通过otp 管控密钥无法被外界拿到, 但也存在无法灵活配置, 很难做到密钥派生/密钥交换类似的需求,  在main域或其他域上的密钥更换是非常频繁的, 频繁的更换密钥能够保证前向安全(即如果密钥被泄露, 那hack 监听到的以往的数据都会变得不再安全)和重放攻击等.  比如https中使用的ssl/tls 加密机制, 每次建立连接后都是使用的新的密钥\n2. 芯片的安全ip采用的算法往往是对外公开的, 没有秘密可言. 相当于说是这种方案其实只有硬解加速的作用, 一旦密钥被探知, 那整个安全链路系统是非常脆弱的.\n3. hsm上执行的程序, 中间过程会锁在安全rom 安全ram内, 这种hsm 上跑的软件上层的机制其实也是安全的. 而只有安全ip的方案, 无论是做驱动还是什么都可以被探知破解.\n\n# HSM在智能汽车中应用的场景\n\n1. 烧写固件/ota 升级时对固件的加密及认证, 即secureboot 安全链路; 加密保证了固件的知识产权, 而认证的作用是防篡改。 尤其是对控制网中网关等固件的防护尤为重要。hsm的加入使破解及篡改secureboot防护的安全链路下的固件变得异常困难。\n\n2. 现在智能汽车开始向多域集成式发展,  发往核心控制网(汽车控制相关的, 如发动机 踏板 转向)等的消息应该被安全加密认证, 如核心控制网与智能座舱域, 与娱乐系统域等的连接, 而网关作为消息中枢系统, 其上面的消息处理转发重打包的机制更是应该被进行安全的控制, 在这一层上hsm的作用是非常明显的。\n  \n3. hsm 的存在也使多个域都可以使用, 如果只是嵌入到一个域上, 如main域可能有类似trustzone的机制, 那其他域是无法利用的。\n\n## CAN FD 消息的防护\n当前传统CAN消息因为只有crc 的校验, 一个消息只有8个字节, 传统的can 安全是非常脆弱的\n**博世在AutoSAR中补充了全称为Secure Onboard Communication（SecOC）的组件，为传统的CAN总线引入了一套通信认证的方法**。**SecOC的核心思想在于通信认证**，但是不涉及报文加密。这一套通信认证的方案, 保证了报文不能被hack 伪造 重放, 这套方案其实是为CAN FD 准备的, 认证信息的强度和信息长度强相关，可传统CAN报文的负载8个字节，真要搭载SecOC，可以说是既得不到预想的信息安全强度，又牺牲了相当大的CAN通信能力。\n\n使用hsm 来实现secoc, 保证认证MAC 所需的密钥, 新鲜度值(单调计数器) 在hsm内部, 黑产无法拿到, 加强了防护能力, 进一步保证了hack 即使破解了车厂自定义的 can fd报文, 也无法伪造重放注入can fd消息\n\n如果不能使用canfd, 或者未实现secoc, 那核心控制网的安全防护会变得更加重要, 如果没有防护好, 一旦通过其他域或控制网本身的漏洞攻入控制系统, 在只有传统can网络下, 控制网会是不设防的状态.\n\n\n\n# 附录: 车载CAN总线网络安全问题\n\n车载CAN总线安全漏洞主要可归纳为以下几个方面:\n\n(1)缺乏足够的安全保护。目前CAN总线缺乏必要的安全保护, 以确保信息的保密性、完整性、可用性、真实性和不可抵赖性。CAN总线上的消息可以被总线上任意节点读取, 并且没有任何消息认证码(MAC)或数字签名保护。\n\n(2)弱认证。对ECU进行固件修改时使用口令(Password)等弱认证技术。\n\n(3)CAN协议滥用。拒绝服务攻击(DoS)可以通过总线仲裁机制进行, 如果攻击者使用最高优先级发送数据, 那么其他ECU将无法使用总线。还有形成恶意的错误帧消息, 也可以使ECU从总线上断开。\n\n(4)消息泄露。通过常规诊断接口, 如OBDⅡ 、K线或L线即可掌握车辆运行时的信息。随意使用OBD软件也存在潜在的安全隐患, OBD模块通常会存储访问控制ECU的指令。\n\n目前OBD应用的安全风险尤其值得关注。OBDⅡ 的标准诊断接口中, CAN总线引脚定义非常明确, 黑客很容易找到切入车载CAN总线网络的入口。通常汽车制造商会通过登陆密钥、隐瞒接口、请求验证等方式严格限制OBD口写入命令, 但这些手段仍属于弱认证, 并不能保证网络信息的安全性。国内OBD应用和车联网方案近年来的发展超出预期, OBD应用的安全性也受到质疑。这些OBD应用的功能从可以实现自动升窗、落锁的简单功能, 到可以实时监测车辆信息, 分析后通过手机APP以图形化的形式展示给驾驶员, 甚至直接将车辆信息实时同步到云端存储。而OBD应用这种类型的第三方改装设备的安全性不能得到保障, 很容易出现软硬件漏洞。\n\n## 攻击方式\n\n针对车载CAN总线网络, 攻击者可以丢弃、修改和读取发送至总线上的信息, 在源节点和目标节点间进行欺骗攻击, 此外还可以进行洪泛、重放攻击。\n\n(1)丢弃(Drop):可用性攻击。例如一个控制了车载总线中某个网关的入侵者可以删除或不转发某些消息, 致使ECU一些功能失效。\n\n(2)修改(Modify):通过入侵或截断总线中某个网关, 可以修改从该网关转发的消息。\n\n(3)读取(Read):任何连接到总线的节点都可以读取总线消息, 可以是一个独立的监听装置, 也可能是一个被入侵的节点。一旦有密钥或私人信息在总线上发出, 就会被入侵者读取。\n\n(4)欺骗(Spoof):任何被入侵的节点都可以发送错误消息、诊断信息, 使总线上ECU对事件进行响应, 消耗ECU的处理器资源。\n\n(5)洪泛(Flood):入侵者控制任意ECU即可向其所在网络发送高速率洪泛消息报文。\n\n(6)重放(Replay):入侵者控制任意ECU, 任何被记录的消息和消息发起的事件, 均可以在任意时间重放到网络中。\n\n## 应用困难\n\n尽管研究人员在努力尝试保护汽车信息安全, 但是其中绝大多数方法并不能立刻应用到实际的车辆当中, 主要的障碍有以下几方面:\n\n(1)认证机制推广阻力大。认证协议对CAN协议包格式进行了重新定义, 这意味着对几乎所有车辆底层系统进行修改, 而OEM对这种改变十分谨慎。并且大部分的研究显示, 对CAN总线通信进行加密后会产生延时, 从而无法满足原有总线的实时需求。\n\n(2)使用CAN-FD(CAN with flexible data rate)协议进行安全认证的方法, CAN-FD比传统CAN协议拥有更高的传输速率, 更小的控制位开销, 并且每个数据帧可以携带最多64个字节的数据。虽然CAN-FD优势明显, 但是在OEM看来离实际商用的距离还远。\n\n(3)认证协议适用的网络节点数量不能达到实际车辆应用要求。即使使用16位处理芯片、轻量32位MAC的加密协议, 其在CAN总线上实施的开销仍然巨大, 而实际车载CAN总线网络不论是节点的数量还是网络复杂度都远远超过实验场景。\n\n(4)新协议在旧车型上的应用问题。由于汽车是一种耐用商品, 通常一辆汽车的寿命可以达到几十年, 这些车辆在出厂时可能没有信息安全方面的防护装置, 而在使用过程中, 新的总线协议也许无法应用于这些车辆。\n\n\n\n# 附录 hsm 芯片抗物理攻击能力\n\n针对芯片的安全攻击测试技术，主要包括主动与被动两类：\n\n- 主动攻击测试：测试者对芯片的输入或运行环境进行控制，使安全芯片运行行为出现异常，在这种情况下，通过分析芯片工作的异常行为，获得芯片内的密钥等关键敏感信息。主动攻击常用故障注入的方式，包括电磁、激光、红外、高电压注入等测试方法。\n\n- 被动攻击测试：测试者令芯片等密码设备大多数情况下按照其规范运行，甚至完全按照其规范运行。在这种情况下，通过观测芯片的物理特性（如执行时间、能量消耗等），测试者可能获得密钥等关键敏感信息。被动测试常用方式为侧信道攻击，包括分析芯片的时序、功率、电磁辐射等信号特征。\n\n芯片的安全测试需要专业设备与专业人员，测试执行方式主要包括非侵入式、半侵入式和侵入式三类，详细情况见表格4：\n\n| 分类     | 描述                                                         | 特点                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 非侵入式 | 使用通用型设备或者工具（如JTAG工具、存储芯片读取工具和逻辑分析仪等），设备价格低廉。需要人员遵照规范性流程测试，并具备基础芯片和电路知识。 | 测试对芯片不造成破坏，确保芯片防范非侵入式攻击，现实中受此类安全威胁概率最大。 |\n| 半侵入式 | 使用专业设备（如研磨器、激光器等），设备价格中等，需要人员具备一定专业芯片设计知识。 | 测试可对芯片造成破坏，确保芯片防范半侵入式攻击，现实中受此类安全威胁概率较大。 |\n| 侵入式   | 使用非常专业的芯片分析工具（如FIB、电镜等），设备价格高昂，对测试人员专业性要求最高 | 测试可对芯片造成不可逆转的破坏，确保芯片防范侵入式攻击，现实中受侵入式攻击的安全威胁概率较小。 |\n\n​                                             表格4安全芯片安全测试方式\n\n","tags":["hsm","汽车"],"categories":["安全"]},{"title":"stm32 系列时钟相关.md","url":"/2022/04/19/hxd_new/时钟管理/stm32 系列时钟相关/","content":"\n# stm32WB55\n## 规格\nSTM32WB无线微控制器基于运行于64 MHz的Arm® Cortex®‐M4核心（应用处理器）和运行于32 MHz的Arm Cortex‐M0+核心（网络处理器）\n\n![](../../images/Pasted%20image%2020220607165730.png)\n\n时钟树 [195](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=194&x=312&y=97&id=1)\n\n1. HSE 时钟\n高速外部时钟信号(HSE)有2个时钟源 [196](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=195&x=211&y=119&id=3)\n- HSE 外部晶振\n- HSE 用户外部时钟\n\n2. 外部晶振（HSE晶振） [001](外部晶振（HSE 晶振）)\n32 MHz 外部振荡器的优点是主时钟精度非常高\n\n3. 外部源（HSE旁路） [196](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=195&x=175&y=572&id=5)\n由于生产工艺和所使用的晶振不同，不同芯片的HSE振荡器频率也不同。用户可以通过写入RCC时钟HSE寄存器(RCC_HSECR)中的HSETUNE位来调整应用中的HSE频率。 [197](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=196&x=326&y=123&id=6)\n\n4. HSI16时钟 [197](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=196&x=154&y=196&id=7)\nHSI16 时钟信号是从 16 MHz 内部振荡器生成的。\nHSI16 振荡器的优点是成本较低（无需使用外部元件）。此外，其启动速度也要比 HSE 晶振快，但即使校准后，其精度也不及外部晶振或陶瓷谐振器。\n\nHSI16时钟还可作为备份时钟源（辅助时钟）使用，以防HSE晶振发生故障 [197](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=196&x=326&y=283&id=8)\n\n5. MSI时钟 [197](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=196&x=148&y=550&id=9)\n\nMSI时钟信号是从内部RC振荡器生成的。频率范围可通过软件使用RCC时钟控制寄存器(RCC_CR)中的MSIRANGE[3:0]位进行选择。有12个频率范围可用：100kHz、200kHz、400kHz、800kHz、1MHz、2MHz、4MHz（默认值）、8MHz、16MHz、24MHz、32MHz和48MHz。 [197](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=196&x=327&y=590&id=10)\n\n在从复位重启、从关断低功耗模式唤醒后，MSI时钟被用作系统时钟。从复位重启后，MSI频率被置为其默认值4MHz。 [001](在从复位重启、从关断低功耗模式唤醒后，MSI 时钟被用作系统时钟。从复位重启后，MSI频率被置为其默认值 4 MHz。)\nMSIRC振荡器的优势在于可提供一个低成本（无外部元件）低功耗的时钟源 [198](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=197&x=296&y=139&id=12)\n此外，当和LSE一起用于PLL模式时，它可提供一个非常精确的时钟源 [198](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=197&x=326&y=145&id=13)\n\n6.  HSI48时钟 [198](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=197&x=154&y=412&id=14)\n\n\nHSI48时钟信号由内部48MHzRC振荡器生成，可直接用于USB和随机数发生器（真RNG） [198](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=197&x=326&y=440&id=15)\n\n内部48MHzRC振荡器主要用于通过特殊的时钟恢复系统(CRS)电路向USB外设提供高精度时钟 [198](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=197&x=326&y=469&id=16)\n\n7.  PLL [199](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=198&x=135&y=98&id=17)\n器件嵌入了以下PLL：PLL和PLLSAI1。每个PLL提供了多达3个独立输出。内部PLL可用来倍频HSI、HSE或MSI输出时钟频率 [199](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=198&x=326&y=125&id=18)\n\n8.  LSE时钟 [199](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=198&x=149&y=413&id=19)\nLSE晶振是32.768kHz低速外部晶振或陶瓷谐振器，可作为实时时钟(RTC)的时钟源来提供时钟/日历或其他定时功能，具有功耗低且精度高的优点 [199](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=198&x=326&y=441&id=20)\n\n9.  外部源（LSE旁路） [200](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=199&x=175&y=489&id=21)\n10.  LSI1时钟 [200](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=199&x=150&y=572&id=22)\nLSI1RC可作为低功耗时钟源在停止模式和待机模式下保持运行，供独立看门狗(IWDG)、RTC、LCD和RF唤醒使用。时钟频率为32kHz [200](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=199&x=326&y=599&id=23)\n\n11.  LSI2时钟 [201](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=200&x=150&y=98&id=24)\nLSI2RC可作为`低漂移`低功耗时钟源在停止模式和待机模式下保持运行，供独立看门狗(IWDG)、RTC、LCD和RF唤醒使用。时钟频率在32kHz左右。 [201](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=200&x=326&y=125&id=25)\n\n\n12. 系统时钟(SYSCLK)选择 [201](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=200&x=192&y=401&id=26)\n\n可以使用四种不同的时钟源来驱动系统时钟 (SYSCLK)：\n- MSI 振荡器\n- HSI16 振荡器\n- HSE 振荡器\n- PLLRCLK\n\n系统复位后，选择 MSI 振荡器（为 4 MHz）作为系统时钟。 在直接使用 HSI 或者通过 PLL 使用时钟源来作为系统时钟时，该时钟源无法\n停止。 只有在目标时钟源已就绪时（时钟在启动延迟或 PLL 锁相后稳定时），才可从一个时钟源切换到另一个。\n\n从待机模式唤醒时，HSI16被选为系统时钟。 [201](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=200&x=224&y=597&id=27)\n\n# 低功耗模式\n\n## 低功耗模式介绍\n默认情况下，系统复位或电源复位后，微控制器处于运行模式，并且至少有一个CPU处于执行代码的CRun模式。系统提供了多个低功耗模式，可在CPU不需要运行时（例如等待外部事件时）节省功耗。 [142](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=141&x=326&y=132&id=34)\n\n### 各CPU具有两种低功耗模式\n可在执行WFI、WFE或在使能SLEEPONEXIT时从异常处理程序返回时通过CPU进入。 [142](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=141&x=326&y=180&id=35)\n- CSleep 模式：当 CPU 进入低功耗模式且 SLEEPDEEP 禁止时，Arm®“睡眠模式”\n- CStop 模式：当 CPU 进入低功耗模式且 SLEEPDEEP 使能时，Arm®“深度睡眠模式”\n\n### 器件有多种低功耗模式：\n[142](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=141&x=179&y=234&id=36)\n1. 睡眠模式：CPU 时钟关闭，包括 CPU 内核外设（例如 NVIC、SysTick 等）在内的所有外设都可以运行，并在发生中断或事件时唤醒 CPU。\n2. 低功耗运行模式（LP 运行）：当系统时钟频率减少到 2 MHz 以下时实现此模式。从 SRAM 或 Flash 执行代码。稳压器处于低功耗模式以最大程度降低工作电流。\n3. 低功耗睡眠模式（LP 睡眠）：从低功耗运行模式进入此模式：CPU 关闭\n4. 停止 0 模式、停止 1 模式 和 停止 2 模式：保留 SRAM1、SRAM2 和所有寄存器的内容。VCORE 域中的所有时钟都停止，并禁止 PLL、MSI、HSI16 和 HSE。   LSI 和 LSE 可以保持运行。RTC 可以保持有效（带 RTC 的停止模式，不带 RTC 的停止模式）。\n\n\t在停止2模式下，大多数VCORE域处于低泄漏模式。停止1提供最大数量的有效外设和唤醒源，相比停止2，其唤醒时间较短，但功耗较高。在停止0模式下，主稳压器保持开启，可实现最快的唤醒，但功耗高很多。有效外设和唤醒源与停止1模式下相同。当从停止0、停止1或停止2模式退出时，系统时钟为最高48MHz的MSI或HSI16，具体取决于软件配置。 [142](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=141&x=337&y=420&id=37)\n\n5.  待机模式\n   VCORE 域断电。但是，可以保留 SRAM2a 内容\n   VCORE 域中的所有时钟都停止，并禁止 PLL、MSI、HSI16 和 HSE。LSI 和 LSE 可以保持运行。\n  RTC 可以保持有效（带 RTC 的待机模式，不带 RTC 的待机模式）。\n  当退出待机模式时，系统时钟为 HSI16。\n   待机模式下可以使用BOR达到最低功耗。待机模式基于CPU深度睡眠模式，其中稳压器被禁止（保留SRAM2内容时除外）。PLL、HSI16、MSI和HSE振荡器也会关闭。 [158](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=157&x=326&y=124&id=38)\n   除备份域和待机电路中的寄存器外，SRAM1 和寄存器内容都将丢失（请参见图 7）。当PWR 控制寄存器 3 (PWR_CR3) 中的 RRS 位置 1 时，SRAM2 内容保留。在这种情况下，低功耗稳压器开启并仅为 SRAM2 供电。\n6. 关断模式\n\tVCORE 域断电。VCORE 域中的所有时钟都停止，并禁止 PLL、MSI、HSI16、LSI 和 HSE。LSE 可以保持运行。当退出关断模式时，系统时钟为 4 MHz 的 MSI。在该模式下，会禁止电源电压监测，并且电源电压下降时不能保证产品特性。\n```ad-warning\n仅当两个 CPU 均处于 CStop 模式时，才会进入停止、待机和关断模式。\n```\n\n可以通过减慢系统时钟和/或在APB和AHB外设未使用时对其进行时钟门控来降低运行模式下的功耗 [143](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=142&x=326&y=103&id=41)\n系统复位后，CPU1处于CRUN模式。仅在由CPU1通过C2BOOT寄存器位使能时，CPU2才会启动。只要CPU1不启动CPU2，系统就会作为单CPU系统运行。`CPU1可自行进入系统低功耗模式`，也可从系统低功耗模式唤醒。当CPU2启动时，CPU1、CPU2和无线电子系统可以自行进入系统低功耗模式以及从该模式唤醒。表23详细介绍了不同子系统的不同唤醒源。 [143](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=142&x=326&y=184&id=42)\n\n\n\n\n## 低功耗模式时钟 \n[209](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=208&x=159&y=99&id=28)\n\n可通过软件禁止 AHB 和 APB 外设时钟，包括 DMA 时钟。\n在睡眠和低功耗睡眠模式下，CPU 时钟停止工作。在睡眠模式下，可通过软件停止存储器接口时钟（Flash、SRAM1 和 SRAM2 接口）。当连接到 AHB-APB 总线桥时钟的所有外设时钟均被禁止时，睡眠模式期间将通过`硬件禁止 AHB-APB 总线桥时钟`。\n在停止模式（停止0、停止1和停止2）下，将停止VCORE域中的大多数时钟，并禁止PLL、MSI和HSE振荡器。当允许从停止模式唤醒的IP（USART1、LPUART1、I2C1和I2C3）发出请求时，HSI16可以保持运行。 [209](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=208&x=337&y=186&id=29)\n\n即使 MCU 处于停止模式（如果选择 HSI16 作为该外设的时钟源），所有 U(S)ART、LPUART 和 I2C 也均可使能 HSI16 振荡器\n\n在待机和关断模式下，将停止VCORE域中的所有时钟，并禁止PLL、HSI、MSI和HSE振荡器。 [209](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=208&x=337&y=312&id=31)\n\n通过将DBGMCU_CR寄存器中的DBG_SLEEP、DBG_STOP或DBG_STANDBY位置1，可以覆盖低功耗模式以进行`调试` [209](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=208&x=326&y=342&id=32)\n\n当退出停止模式时, 系统时钟为 MSI 或 HSI,  MSI 振荡器的频率（范围和用户微调）是进入停止模式之前配置的频率。\nHSI16 的用户微调将保留。 \n\n退出待机模式时，系统时钟为 HSI。\n退出关断模式时，系统时钟为 MSI。从关断模式唤醒时的 MSI 频率为 4 MHz。用户微调将丢失。\n\n如果正在执行Flash编程操作，则将延迟到Flash接口访问结束后再进入停止、待机和关断模式。如果正在访问APB域，则将延迟到APB访问结束后再进入停止、待机和关断模式。 [209](bookxnotepro://opennote/?nb={34cf70b6-6ce4-49b0-bba3-72f42203f190}&book=ea8590e4b931844be7d58e94dbae4280&page=208&x=326&y=711&id=33)\n\n","tags":["stm32"],"categories":["时钟"]},{"title":"HSM 在智能汽车安全中的作用.md","url":"/2022/04/19/hxd_new/汽车安全相关/HSM 在智能汽车安全中的作用/","content":"\n# HSM 作用\n![full hsm](https://pic4.zhimg.com/v2-cc6c609c713dab25d187489a6a436cdf_r.jpg)\n\n包含两个部分:\n1.  Security building blocks负责加密/解密的硬件操作；\n2.  Logical building blocks负责与Application ECU交互数据以及软件的加密/解密操作；\n\nHSM 最重要的作用是安全边界, 和trustzone的机制类似, 提供安全的物理隔离能力, 安全rom和安全ram 无法被外部cpu 访问, 即使外部cpu 环境被破解, 也能保证hsm 运行的内容无法被探知. 当前的hsm产品中大多是过了FIPS 140-2 level3 标准的.\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170646.png)\n\n密钥存储/派生/权限管控/交换机制处于hsm内部(授信环境), 密钥存于安全rom或安全ram中, 无法被外部拿到.\n\n# 与 只有硬件安全ip 加 otp 方案的对比\n\n1. 该方案密钥即使可以通过otp 管控密钥无法被外界拿到, 但也存在无法灵活配置, 很难做到密钥派生/密钥交换类似的需求,  在main域或其他域上的密钥更换是非常频繁的, 频繁的更换密钥能够保证前向安全(即如果密钥被泄露, 那hack 监听到的以往的数据都会变得不再安全)和重放攻击等.  比如https中使用的ssl/tls 加密机制, 每次建立连接后都是使用的新的密钥\n2. 芯片的安全ip采用的算法往往是对外公开的, 没有秘密可言. 相当于说是这种方案其实只有硬解加速的作用, 一旦密钥被探知, 那整个安全链路系统是非常脆弱的.\n3. hsm上执行的程序, 中间过程会锁在安全rom 安全ram内, 这种hsm 上跑的软件上层的机制其实也是安全的. 而只有安全ip的方案, 无论是做驱动还是什么都可以被探知破解.\n\n# HSM在智能汽车中应用的场景\n\n1. 烧写固件/ota 升级时对固件的加密及认证, 即secureboot 安全链路; 加密保证了固件的知识产权, 而认证的作用是防篡改。 尤其是对控制网中网关等固件的防护尤为重要。hsm的加入使破解及篡改secureboot防护的安全链路下的固件变得异常困难。\n\n2. 现在智能汽车开始向多域集成式发展,  发往核心控制网(汽车控制相关的, 如发动机 踏板 转向)等的消息应该被安全加密认证, 如核心控制网与智能座舱域, 与娱乐系统域等的连接, 而网关作为消息中枢系统, 其上面的消息处理转发重打包的机制更是应该被进行安全的控制, 在这一层上hsm的作用是非常明显的。\n  \n3. hsm 的存在也使多个域都可以使用, 如果只是嵌入到一个域上, 如main域可能有类似trustzone的机制, 那其他域是无法利用的。\n\n## CAN FD 消息的防护\n当前传统CAN消息因为只有crc 的校验, 一个消息只有8个字节, 传统的can 安全是非常脆弱的\n**博世在AutoSAR中补充了全称为Secure Onboard Communication（SecOC）的组件，为传统的CAN总线引入了一套通信认证的方法**。**SecOC的核心思想在于通信认证**，但是不涉及报文加密。这一套通信认证的方案, 保证了报文不能被hack 伪造 重放, 这套方案其实是为CAN FD 准备的, 认证信息的强度和信息长度强相关，可传统CAN报文的负载8个字节，真要搭载SecOC，可以说是既得不到预想的信息安全强度，又牺牲了相当大的CAN通信能力。\n\n使用hsm 来实现secoc, 保证认证MAC 所需的密钥, 新鲜度值(单调计数器) 在hsm内部, 黑产无法拿到, 加强了防护能力, 进一步保证了hack 即使破解了车厂自定义的 can fd报文, 也无法伪造重放注入can fd消息\n\n如果不能使用canfd, 或者未实现secoc, 那核心控制网的安全防护会变得更加重要, 如果没有防护好, 一旦通过其他域或控制网本身的漏洞攻入控制系统, 在只有传统can网络下, 控制网会是不设防的状态.\n\n\n\n# 附录: 车载CAN总线网络安全问题\n\n车载CAN总线安全漏洞主要可归纳为以下几个方面:\n\n(1)缺乏足够的安全保护。目前CAN总线缺乏必要的安全保护, 以确保信息的保密性、完整性、可用性、真实性和不可抵赖性。CAN总线上的消息可以被总线上任意节点读取, 并且没有任何消息认证码(MAC)或数字签名保护。\n\n(2)弱认证。对ECU进行固件修改时使用口令(Password)等弱认证技术。\n\n(3)CAN协议滥用。拒绝服务攻击(DoS)可以通过总线仲裁机制进行, 如果攻击者使用最高优先级发送数据, 那么其他ECU将无法使用总线。还有形成恶意的错误帧消息, 也可以使ECU从总线上断开。\n\n(4)消息泄露。通过常规诊断接口, 如OBDⅡ 、K线或L线即可掌握车辆运行时的信息。随意使用OBD软件也存在潜在的安全隐患, OBD模块通常会存储访问控制ECU的指令。\n\n目前OBD应用的安全风险尤其值得关注。OBDⅡ 的标准诊断接口中, CAN总线引脚定义非常明确, 黑客很容易找到切入车载CAN总线网络的入口。通常汽车制造商会通过登陆密钥、隐瞒接口、请求验证等方式严格限制OBD口写入命令, 但这些手段仍属于弱认证, 并不能保证网络信息的安全性。国内OBD应用和车联网方案近年来的发展超出预期, OBD应用的安全性也受到质疑。这些OBD应用的功能从可以实现自动升窗、落锁的简单功能, 到可以实时监测车辆信息, 分析后通过手机APP以图形化的形式展示给驾驶员, 甚至直接将车辆信息实时同步到云端存储。而OBD应用这种类型的第三方改装设备的安全性不能得到保障, 很容易出现软硬件漏洞。\n\n## 攻击方式\n\n针对车载CAN总线网络, 攻击者可以丢弃、修改和读取发送至总线上的信息, 在源节点和目标节点间进行欺骗攻击, 此外还可以进行洪泛、重放攻击。\n\n(1)丢弃(Drop):可用性攻击。例如一个控制了车载总线中某个网关的入侵者可以删除或不转发某些消息, 致使ECU一些功能失效。\n\n(2)修改(Modify):通过入侵或截断总线中某个网关, 可以修改从该网关转发的消息。\n\n(3)读取(Read):任何连接到总线的节点都可以读取总线消息, 可以是一个独立的监听装置, 也可能是一个被入侵的节点。一旦有密钥或私人信息在总线上发出, 就会被入侵者读取。\n\n(4)欺骗(Spoof):任何被入侵的节点都可以发送错误消息、诊断信息, 使总线上ECU对事件进行响应, 消耗ECU的处理器资源。\n\n(5)洪泛(Flood):入侵者控制任意ECU即可向其所在网络发送高速率洪泛消息报文。\n\n(6)重放(Replay):入侵者控制任意ECU, 任何被记录的消息和消息发起的事件, 均可以在任意时间重放到网络中。\n\n## 应用困难\n\n尽管研究人员在努力尝试保护汽车信息安全, 但是其中绝大多数方法并不能立刻应用到实际的车辆当中, 主要的障碍有以下几方面:\n\n(1)认证机制推广阻力大。认证协议对CAN协议包格式进行了重新定义, 这意味着对几乎所有车辆底层系统进行修改, 而OEM对这种改变十分谨慎。并且大部分的研究显示, 对CAN总线通信进行加密后会产生延时, 从而无法满足原有总线的实时需求。\n\n(2)使用CAN-FD(CAN with flexible data rate)协议进行安全认证的方法, CAN-FD比传统CAN协议拥有更高的传输速率, 更小的控制位开销, 并且每个数据帧可以携带最多64个字节的数据。虽然CAN-FD优势明显, 但是在OEM看来离实际商用的距离还远。\n\n(3)认证协议适用的网络节点数量不能达到实际车辆应用要求。即使使用16位处理芯片、轻量32位MAC的加密协议, 其在CAN总线上实施的开销仍然巨大, 而实际车载CAN总线网络不论是节点的数量还是网络复杂度都远远超过实验场景。\n\n(4)新协议在旧车型上的应用问题。由于汽车是一种耐用商品, 通常一辆汽车的寿命可以达到几十年, 这些车辆在出厂时可能没有信息安全方面的防护装置, 而在使用过程中, 新的总线协议也许无法应用于这些车辆。\n\n\n\n# 附录 hsm 芯片抗物理攻击能力\n\n针对芯片的安全攻击测试技术，主要包括主动与被动两类：\n\n- 主动攻击测试：测试者对芯片的输入或运行环境进行控制，使安全芯片运行行为出现异常，在这种情况下，通过分析芯片工作的异常行为，获得芯片内的密钥等关键敏感信息。主动攻击常用故障注入的方式，包括电磁、激光、红外、高电压注入等测试方法。\n\n- 被动攻击测试：测试者令芯片等密码设备大多数情况下按照其规范运行，甚至完全按照其规范运行。在这种情况下，通过观测芯片的物理特性（如执行时间、能量消耗等），测试者可能获得密钥等关键敏感信息。被动测试常用方式为侧信道攻击，包括分析芯片的时序、功率、电磁辐射等信号特征。\n\n芯片的安全测试需要专业设备与专业人员，测试执行方式主要包括非侵入式、半侵入式和侵入式三类，详细情况见表格4：\n\n| 分类     | 描述                                                         | 特点                                                         |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 非侵入式 | 使用通用型设备或者工具（如JTAG工具、存储芯片读取工具和逻辑分析仪等），设备价格低廉。需要人员遵照规范性流程测试，并具备基础芯片和电路知识。 | 测试对芯片不造成破坏，确保芯片防范非侵入式攻击，现实中受此类安全威胁概率最大。 |\n| 半侵入式 | 使用专业设备（如研磨器、激光器等），设备价格中等，需要人员具备一定专业芯片设计知识。 | 测试可对芯片造成破坏，确保芯片防范半侵入式攻击，现实中受此类安全威胁概率较大。 |\n| 侵入式   | 使用非常专业的芯片分析工具（如FIB、电镜等），设备价格高昂，对测试人员专业性要求最高 | 测试可对芯片造成不可逆转的破坏，确保芯片防范侵入式攻击，现实中受侵入式攻击的安全威胁概率较小。 |\n\n​                                             表格4安全芯片安全测试方式\n\n# 附录 ADAS 系统功能\n一般，汽车高级辅助驾驶系统通常包括：**车道偏离预警系统LDWS、车道保持系统LKS、自适应巡航系统ACC、前碰撞预防系统FCW 、自动泊车系统APA、盲点监测系统BSD、驾驶员疲劳预警系统DFM、自适应灯光控制ALC、自动紧急制动AEB、夜视系统NVD等常见的十大功能系统。\n\n除此之外，还包括行人保护系统、电子警察系统ISA、导航与实时交通系统TMC、交通标志识别、下坡控制系统、电动汽车报警系统等等。\n\n**本文主要给大家重点介绍一下ADAS的十大功能系统。**\n\n## 1、车道偏离预警系统LDWS‍‍‍‍‍\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909124505320.jpg)\n\n车道偏离预警系统LDWS（ Lane departure warning system）是指行车中未打转向灯突然大幅度偏离车道，不正常偏移时，行车记录仪一旦判定行驶路线有异，便会以行车记录仪的显示屏幕提醒驾驶人，并发出声响警告对司机进行警示。这将使司机可以马上采取行动，回到原行车道上。\n\n车道偏离预警系统主要由HUD抬头显示器、摄像头、控制器以及传感器组成。当车道偏离预警系统开启时，摄像头（一般安置在车身侧面或后视镜位置）会时刻采集行驶车道的标识线，通过图像处理获得汽车在当前车道中的位置参数。\n\n当检测到汽车偏离车道时，传感器会及时收集车辆数据和驾驶员的操作状态，之后由控制器发出警报信号，整个过程大约在0.5秒完成，为驾驶者提供更多的反应时间。而如果驾驶者打开转向灯，正常进行变线行驶，那么车道偏离预警系统不会做出任何提示。\n\n## 2、车道保持系统LKS (Lane Keeping System)\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909125908389.jpg)\n\n车道保持辅助系统属于智能驾驶辅助系统中的一种。它可以在车道偏离预警系统（LDWS）的基础上对刹车的控制协调装置进行控制。对车辆行驶时借助一个摄像头识别行驶车道的标识线将车辆保持在车道上提供支持。可检测本车在车道内的位置，并可自动调整转向，使本车保持在车道内行驶。\n\n如果车辆接近识别到的标记线并可能脱离行驶车道，那么会通过方向盘的振动，或者是声音来提请驾驶员注意，并轻微转动方向盘修正行驶方向，使车辆处于正确的车道上，若方向盘长时间检测到无人主动干预，则发出报警，用来提醒驾驶人员。\n\n如果车道保持辅助系统识别到本车道两侧的标记线，那么系统处于待命状态。这通过组合仪表盘中的绿色指示灯显示。当系统处于待命状态下，如果在Y过标记线前打了转向灯，警告信号就会被屏蔽，认定驾驶员为有意识地换道。\n\n该系统主要应用于结构化的道路上，如高速公路和路面条件较好（车道线清晰）的公路上行驶。当车速达到65km/h或以上才开始运行。\n\n## 3、自适应巡航系统ACC\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909131504644.jpg)\n\n自适应巡航系统ACC（Adaptive Cruise Control）是一项舒适性的辅助驾驶功能。如果车辆前方畅通，自适应巡航（ACC）将保持设定的最大巡航速度向前行驶。如果检测到前方有车辆，自适应巡航（ACC） 将根据需要降低车速，与前车保持基于选定时间的距离，直到达到合适的巡航速度。\n\n自适应巡航也可称为主动巡航，类似于传统的定速巡航控制，该系统包括雷达传感器、数字信号处理器和控制模块。在自适应巡航系统中，系统利用低功率雷达或红外线光束得到前车的确切位置，如果发现前车减速或监测到新目标，系统就会发送执行信号给发动机或制动系统来降低车速，从而使车辆和前车保持一个安全的行驶距离。\n\n当前方道路障碍清除后又会加速恢复到设定的车速，雷达系统会自动监测下一个目标。主动巡航控制系统代替司机控制车速，避免了频繁取消和设定巡航控制。当与前车之间的距离过小时，ACC控制单元可以通过与制动防抱死系统、发动机控制系统协调动作，使车轮适当制动，并使发动机的输出功率下降，以使车辆与前方车辆始终保持安全距离。自适应巡航系统适合于多种路况，为驾驶者提供了一种更轻松的驾驶方式。\n\n## 4、前碰撞预防系统FCW\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909132903589.jpg)\n\n前碰撞预防系统FCW (Forward Collision Warning)是通过雷达系统来时刻监测前方车辆，判断本车与前车之间的距离、方位及相对速度，当存在潜在碰撞危险时对驾驶者进行警告。FCW系统本身不会采取任何制动措施去避免碰撞或控制车辆。\n\n通过分析传感器获取的前方道路信息对前方车辆进行识别和跟踪，如果有车辆被识别出来，则对前方车距进行测量。同时利用车速估计，根据安全车距预警模型判断追尾可能，一旦存在追尾危险，便根据预警规则及时给予驾驶人主动预警。\n\n## 5、自动泊车系统APA\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909134408792.jpg)\n\n自动泊车系统APA（Automatic Parking Assist）是利用车载传感器（一般为超声波雷达或摄像头）识别有效的泊车空间，并通过控制单元控制车辆进行泊车。相比于传统的倒车辅助功能，如倒车影像以及倒车雷达，自动泊车的功能智能化程度更高，有效的减轻了驾驶员的倒车困难。\n\n全自动泊车辅助系统APA，通过控制车辆的加减速度和转向角度自动停放车辆。该系统通过AVM（环视）和USS（超声波雷达）感知泊车环境，使用IMU和车轮传感器估计车辆姿态（位置和行驶方向），并根据驾驶员的选择自动或手动设置目标泊车位。然后系统进行自动泊车轨迹计算，并通过精确的车辆定位与车辆控制系统使车辆沿定义的泊车轨迹进行全自动泊车，直至到达最终目标泊车位。\n\n## 6、盲点监测系统BSD\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909135905693.jpg)\n\n由于汽车后视镜存在视觉盲区，变道之前就看不到盲区的车辆，如果盲区内有超车车辆，此时变道就会发生碰撞事故。在大雨天气、大雾天气、夜间光线昏暗，更加难以看清后方车辆，此时变道就面临更大的危险，盲点监测系统就是为了解决后视镜的盲区而产生的。\n\n盲点监测系统BSD（ Blind Spot Detection)，是汽车上的一款安全类的高科技配置，主要功能是扫除后视镜盲区，依赖于车辆尾部两个雷达时刻监测车辆的侧后面和侧面状态，如果车辆位于该区域内，驾驶员将通过后视镜上盲点警告指示灯和组合仪表获得相关警告提示，避免在车道变换过程中由于后视镜盲区而发生事故。\n\n## 7、驾驶员疲劳预警系统DFM\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909141209134.jpg)\n\n驾驶员疲劳预警系统DFM（Driver Fatigue Monitor System）主要是通过摄像头获取的图像，通过视觉跟踪、目标检测、动作识别等技术对驾驶员的驾驶行为及生理状态进行检测，当驾驶员发生疲劳、分心、打电话、抽烟等危险情况时在系统设定时间内报警以避免事故发生。DFM系统能有效规范驾驶员的驾驶行为、大大降低交通事故发生的几率。\n\n通过分析驾驶员的疲劳特征（如打哈欠、闭眼等），对疲劳行为及时发出疲劳驾驶预警。高精准度的算法甚至能做到不受时间段、光照情况、是否戴墨镜等外界条件影响，始终对驾驶员的疲劳状态进行有效管理。当驾驶人员产生生理疲劳状态时，立即发出预警警告，及时唤醒驾驶员，避免严重事故发生。\n\n## 8、自适应灯光控制ALC\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909142605883.jpg)\n\n自适应灯光控制ALC（Adaptive Light Control）是一种智能灯光调节系统。通过感知驾驶员操作、车辆行驶状态、路面变化以及天气环境等信息，AFS 自动控制前照灯实时进行上下、左右照明角度的调整，为驾驶员提供最佳道路照明效果。\n\n自适应前照灯系统共由四部分组成：传感器、ecu、车灯控制系统和前照灯。汽车车速传感器和方向盘转角传感器不断地把检测到的信号传递给ecu，ecu根据传感器检测到的信号进行处理，把处理完后的数据进行判断，输出前照灯转角指令，使前照灯转过相应的角度。\n\n汽车在转弯时，重点是要提前看到所转方向的障碍物，根据现实驾驶的经验，车灯一般只需转过o～15°即可，只需要所转方向侧的那只前照灯实现智能转向就可，另一侧前照灯还是保持原来的方向。虽简化了控制，仍然能够达到预期的效果。它可以通过控制系统能够显著改善各种路况下的照明效果，提高行车安全。\n\n## 9、自动紧急制动AEB\n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909144007067.jpg)\n\n自动紧急制动AEB（Autonomous Emergency Braking）是一种汽车主动安全技术，主要由 3 大模块构成，其中测距模块的核心包括微波雷达、激光雷达和视频系统等，它可以提供前方道路安全、准确、实时的图像和路况信息。\n\nAEB 系统采用雷达测出与前车或者障碍物的距离，然后利用数据分析模块将测出的距离与警报距离、安全距离进行比较，小于警报距离时就进行警报提示，而小于安全距离时即使在驾驶员没有来得及踩制动踏板的情况下，AEB 系统也会启动，使汽车自动制动，从而为安全出行保驾护航。\n\n## 10、夜视系统NVD \n\n![](http://www.evinchina.com/uploadfile/image/20220209/2022020909145402796.jpg)\n\n夜视系统NVD（Night Vision Device）是一种源自军事用途的汽车驾驶辅助系统。在这个辅助系统的帮助下，驾驶者在夜间或弱光线的驾驶过程中将获得更高的预见能力，它能够针对潜在危险向驾驶者提供更加全面准确的信息或发出早期警告。\n\n夜视系统NVD由安置于车前保险杠的（UFPA）侦测传感器和液晶抬头显示器（HUD）组成，主要是通过主动式红外照射、微光夜视技术以及红外热成像技术，来帮助驾驶者看见以汽车远光灯无法清楚辨识的物体，驾驶者可将虚拟影像当作前方视野的一部分，提升了视线不佳时的行车安全性。\n\n目前ADAS系统的主要功能并非是完全控制汽车，而是为驾驶人提供车辆的工作情形，与车外环境变化等相关信息进行分析，且预先警告可能发生的危险状况，让驾驶人提早采取因应措施，避免交通意外发生。\n\n至于成为无人驾驶，当然也是ADAS系统目前积极追求的方向，不过这需在不断累积使用经验与盲点克服后，同时加入更多主动侦测系统，甚至是物联网功能后，才有机会进一步实现的目的，毕竟自动驾驶所需具备的汽车技术层面更高、更复杂。","tags":["hsm","汽车"],"categories":["安全"]},{"title":"智能汽车安全攻防.md","url":"/2022/04/18/hxd_new/汽车安全相关/智能汽车安全攻防/","content":"\n# 基础概念\n## V2X\nV2X（Vehicle to X）通信：表示车与X通信，X可以是车（Vehicle）、路（Road）或者其他相关基础设施，相应地也就有了**V2V**（Vehicle to Vehicle，车与车通信）、**V2I**（Vehicle to Infrastructure，车与基础设施如道路、服务器等通信）、**V2P**（Vehicle to Pedestrian，汽车与行人通信）等概念。V2X的典型应用有**左转辅助、紧急刹车提示、闯红灯警告、过弯速度警告、施工路段提醒、实时天气信息提醒**等。\n\n## 高级辅助驾驶系统\n高级辅助驾驶系统（ADAS，Advanced Driver Assistance System）：**ADAS**是在驾驶过程中辅助驾驶员的系统，它的功能包括**安全告警功能、自适应控制功能、信息提示功能**等，可在通过传感器检测到可能的危险时对驾驶员**发出告警或者接管汽车某些控制功能（比如紧急刹车功能）**，以及**根据环境自动对汽车的某些功能进行控制，比如根据环境亮度自动调节车灯亮度、自适应巡航控制、盲点警告、自动变道**等。ADAS 技术通常依赖于各种传感器和通信技术，例如依赖雷达或者摄像头检测与前车的距离，依赖V2V获取附近车辆信息，依赖摄像头检测车道等。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173824.png)\n## 自动驾驶级别\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173825.png)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173826.png)\n# 汽车网络安全\n## 攻击向量 \n\n即攻击面: \n\n- 间接物理访问\n- 短距离无线访问\n- 远距离无线访问\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173827.png)\n## 间接物理访问\n通过这些攻击面发起攻击通常涉及对与这些攻击面进行交互的设备、媒介进行攻击，例如要通过OBD或者播放器进行攻击就要对诊断设备、多媒体光盘等进行恶意修改。\n\n### obd 在线诊断接口\nOBD是在线诊断接口（On Board Diagnostic interface），是汽车上最重要的一个物理接口，汽车维修人员可以使用专用诊断设备通过这个接口读取汽车的运行状态数据、进行主动测试（例如控制喷油器或者点火器）等功能, 但是攻击者也可以通过这个接口直接访问汽车内网关键的CAN总线进而完全控制汽车的物理功能，造成威胁。\n\n现在有很多远程诊断系统通过OBD盒子（一种插在OBD接口上的硬件设备，作用是将数据无线传输到手机或者服务器，然后对数据进行可视化或分析）远程或近程无线访问汽车数据或者控制汽车，如图2-6所示。这种OBD盒子通常利用蜂窝网与服务器通信，或者利用蓝牙或Wi-Fi与手机通信，再由手机将数据传给服务器。这些通信链路如果被攻击就会使攻击者获得OBD接口的访问权，进而对汽车发起攻击。\n\nOBD是一个潜在的攻击入口，原因是通过OBD可以对汽车进行控制。例如，利用汽车自带的诊断测试功能可以控制一些执行器执行某些操作（如控制喷油器喷油）。通过OBD还可以对ECU的固件进行篡改（如加入恶意代码）等。\n\n### 娱乐系统\n现代汽车的娱乐系统不是孤立的模块，很多娱乐系统都与CAN总线相连（比如需要根据汽车的速度调节音量，通过多媒体显示汽车参数，或者通过多媒体系统的USB接口升级汽车ECU的固件等），所以通过多媒体系统是可能攻入汽车内网的\n\n攻击者可能通过在光盘或者其他可移动设备中植入恶意程序，然后通过社会工程学的方式说服用户播放恶意光盘、插入恶意 U 盘等。攻击者还可能通过攻击用户的手机来安装恶意程序\n\n## 短距离无线攻击面\n间接物理访问有一系列缺点，如操作复杂、无法控制攻击时间（例如CD什么时候播放取决于用户）等，而短距离无线攻击要灵活得多。汽车的短距离攻击向量包括蓝牙、Wi-Fi、无钥匙进入、RFID、胎压管理系统，以及DSRC[专用短距离通信（Dedicated Short Range Communication），专为汽车安全应用通信而制定]等，对于这些攻击向量我们假设攻击者可以获取到对应的收发设备在汽车附近的收发数据。\n\n### 蓝牙\n传输距离一般为10米，但是有研究表明可以使用定向天线及信号放大器等增加距离。蓝牙系统的漏洞研究在无线安全领域是一个非常热门的研究课题。\n\n### 无钥匙进入系统\n无钥匙进入系统又分为遥控无钥匙进入系统（RKE，Remote Keyless Entry，如图2-8所示）和被动无钥匙进入系统（PKE，Passive Keyless Entry）。\n\nRKE 就是我们常见的遥控器，可以遥控开门或者遥控点火启动（RKI，Remote Keyless Ignition），当用户按下遥控器的按钮后，遥控器发射出一串射频信号，汽车接收到信号后判断信号的有效性，再执行相应动作。这串射频信号是加密的，俗称滚动码。\n\n当驾驶员通过按钮或者触摸感应器触发系统后，汽车会通过天线发送挑战信号（比如一个随机数），钥匙接收到后根据这个挑战信号利用密钥生成一个挑战结果（例如利用和汽车共享的密钥对这个挑战信号进行加密）并发送给汽车，汽车接收并验证信号是否正确合法\n\nPKE 又被称为智能钥匙，驾驶员可以将钥匙放在衣服口袋或者背包里不用拿出来，然后走到汽车附近直接触发车门把手（按钮或者触摸感应器）就可以打开汽车。进入汽车后只要钥匙在检测范围内就可以按启动按钮启动汽车，如图2-9所示。\n\n### RFID＆Hitag\n钥匙里嵌入一个RIFD，在钥匙孔附近安装RFID天线，当驾驶员插入钥匙后RFID会和ECU进行相互认证，认证通不过将不能启动，这就防止了通过硬搭线盗取汽车。\n\n### 胎压管理系统TPMS\n在汽车的轮胎上安装胎压传感器将采集到的胎压数据通过短距离无线通信传递给管理模块，管理模块会在胎压过低时发出告警信息，TPMS的工作频率在315MHz左右。这些信号很多没有采取加密等安全措施，可以被伪造\n\n### wifi\n很多新款汽车提供了Wi-Fi热点功能，手机或笔记本电脑可以通过这个热点上网, 关于Wi-Fi的破解攻击方法有很多，在部署和配置时稍不注意就会出现安全问题，例如弱密码算法、弱密码、密码泄露、伪造热点等一系列问题\n\n### 专用短距离无线通信DSRC或V2X\nDSRC由汽车专用的通信信道和一系列标准构成，典型应用是ETC收费和V2V通信\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173828.png)\n如何保证驾驶员得到的告警信息是准确的而不是被恶意伪造的？如何保证驾驶员的位置等隐私信息不在通信过程中被暴露？\n\n```ad-warning\n问题通常都出在通信的保密性、通信密钥的管理、数据解析程序漏洞等几个方面。攻击者利用这些漏洞可以造成不同程度的影响。\n```\n\n## 远距离无线攻击面\n汽车上的远距离攻击向量包括 GPS、卫星接收机、数字广播接收机等公用的通信链路，还包括蜂窝网、远程协助系统（如OnStar）、远程控制系统（如Jeep Uconnect和宝马ConnectedDrive）等专用的通信链路。 这些远距离攻击向量是最大的威胁，因为黑客可以在任何地方发起攻击，\n\n# 汽车安全指导标准\n## 五星汽车网络安全计划\n1．设计安全\n· 尽量采用经过行业测试的标准。\n· 严格的供应链控制。\n· 减少攻击入口。\n· 独立的、从攻击者角度进行的安全测试。\n2．三方合作\n· 与第三方专业的安全研究人员合作，与安全公司合作。\n· 建立漏洞奖励机制，例如很多厂商已经推出了漏洞悬赏计划（Bug Bounty Program）。\n· 与独立的漏洞平台合作。\n3．证据采集\n· 在汽车上部署类似黑匣子的装置对汽车的数据进行记录，方便发生攻击后的取证调查。\n· 在记录数据的同时注意保护车主的隐私。\n4．安全的软件升级机制\n· 当车辆出现安全漏洞时要能够通过可靠、安全的软件升级渠道打补丁，例如后面章节我们会看到克莱斯勒和特斯拉汽车的升级方式有很大区别。\n· 对漏洞的快速响应。\n· 健壮的漏洞报告机制，在出现漏洞时能够可靠快速地通知车主或相关方面。\n5．功能模块划分及隔离\n物理隔离是防止被攻击的次要模块（如多媒体系统）影响到主要功能模块（如转向及刹车模块等安全相关的模块）的唯一办法，很多厂家正在或者计划采用逻辑隔离，但是事实（例如后面会讲到的 Jeep 攻击案例中的 SPI）说明逻辑隔离总能有方法绕过。\n· 功能模块物理隔离。\n· 系统完整性检查及系统恢复。\n· 抗破坏保证。\n\n# 汽车内部网络\n汽车是由许多子系统组成的一个大系统\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173829.png)\n自动驾驶或者自主驾驶汽车还会配备各种感知道路和环境的传感器，如雷达、摄像头等。上面提到的每个子系统都由单独的或共享 ECU 进行控制，这些 ECU 相互之间又经过汽车内部网络（如CAN)相互连接，共同实现对汽车的整体控制\n\n现代汽车几乎每个功能模块（如刹车系统、发动机系统、变速器系统等）都有对应的电子控制单元，也叫电子控制模块ECM（Electronic Control Module）。通常我们所说的ECU指的不是某一个具体模块，而是指一类模块，是一个统称，比如控制发动机的ECU叫ECU（Engine Control Unit）或者EMU、控制变速器的ECU叫ETC（Electronic Transmission Control）等，这些都称为ECU\n\n常用汽车的ECU模块示意图:\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173830.png)\n\n传感器对车辆内部及外部的状态进行感知，就像人的眼耳口鼻一样，对传感器的欺骗攻击也是常见的攻击方式，例如，已经有研究结果表明自动驾驶汽车采用的Lidar和摄像头可以被欺骗\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173831.png)\n\n## 控制器局域网\nCAN（Controller Area Network）是控制器局域网, CAN的诞生只是为了实现更大范围的协同功能和全局控制\n随着汽车技术的发展，单纯地对汽车的某些功能模块进行电子控制无法满足越来越多的功能要求和控制需求，比如前面提到的自适应巡航控制功能就需要发动机、变速器、刹车等功能模块相互协作，相互协作就意味着需要进行通信交流, 在汽车里，各个功能模块或者各个ECU也是通过专有的通信网络交流沟通的，这就是控制器局域网\n\n网关是一种充当转换重任的计算机系统或设备，使用在不同的通信协议、数据格式、语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。\n\n汽车内部采用了多种网络协议和多种网络拓扑结构，采用的协议有CAN、MOST和LIN，有的汽车（例如特斯拉）还采用以太网（Ethernet）和 CAN 总线\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173832.png)\n## 车联网\n车联网（`IoV`，Internet of Vehicle）是移动互联网和物联网相融合的技术，它囊括了所有通过后装或者原厂配置无线通信模块而具有无线网络连接能力的新老车型，它涉及的技术有通信、环保、节能及安全等。IoV是一个动态的移动通信系统，涉及车与车通信V2V，车与路通信V2R（Vehicle to Road）、车与人通信V2H（Vehicle to Human）、车与传感器通信V2S（Vehicle to Sensor）等。\n\n已经有攻击案例表明黑客可以通过V2V 通信跟踪到车辆的位置，攻击者甚至可以通过车载多媒体系统远程窃听驾驶员的谈话。行车记录仪等设备在记录视频和音频数据时，如果这些数据在传输和保存的过程中处理不当，势必导致隐私的泄露。\n\n### V2X是如何提高驾驶安全性的\n#### 碰撞预警\n因为没有交通信号灯而且两辆车的驾驶员都看不到对方，但是如果这两辆车都配备有V2V功能，那么在它们驶向十字路口时会收到警告信息，这样就可以提前采取措施避免碰撞。\n\n#### 左转辅助\n左转辅助（LTA，Left Turn Assist）：LTA在车辆左转弯且可能发生碰撞时会提醒驾驶员。\n\n#### 紧急刹车提示\n紧急刹车提示（Emergency Electronic Brake Light）：当前方的某一辆配备了V2X功能的汽车急刹时，后车会收到提示，这在大雾、大雨天气或者前面有车辆阻挡视线时非常有用。\n\n#### 过弯速度警告\n#### 施工路段提醒\n\n施工路段提醒（Reduced Speed Zone Warning）：这个功能会提醒驾驶员减速、变道或者准备停车\n\n#### 实时天气信息提醒\n这个功能会通过 V2I 下载实时天气信息和位置，必要时向驾驶员发出告警。\n\n值得注意的是，这些功能都要依赖车辆广播的信息实现，这些信息的来源是否可信、传输是否可靠等都是需要解决的安全问题。与传统的安全功能（如 ABS、安全气囊等）不同，V2V 功能的实现需要车辆之间的配合，即车辆需要实时地采集、处理、传输并分析数据，这些数据的传输和处理是提示信息的基础。\nV2V 网络需要数据交换，数据交换的车参与主体必须要能够信任对方，这就要求接收数据的V2V设备能够实时地对收到的数据进行验证。另外，V2V系统还要能够抵御来自内部和外部的攻击，以下是三个需要保护的部分。\n（1）通信[传输媒介、传输车辆消息或数据，证书（后面讲解），以及其他数据交换所依赖的模块]，例如前面提到的V2V安全应用，如果攻击者可以伪造这些告警数据，将会导致安全隐患。\n（2）设备（车载设备、路基设备等）。要保证通信安全，势必会涉及前面介绍的加密、证书等安全机制，设备中存储着证书、密码等敏感信息，因此需要保护好。\n（3）运营组织（如管理后台、V2I 基础设施等），通过管理后台来攻击可能造成很大的影响，就像已经出现过的针对国内某品牌汽车的管理后台进行攻击的案例表明的那样，攻击者可以通过管理后台打开车门，获取车辆信息、车主信息等。\n\n# CAN 总线\n高速CAN总线（High Speed CAN，CAN-C）：CAN-C的标准是ISO11898-2，速率是 **125bit/s 到 1Mbit/s**，因此这个速率可以满足驱动系统的实时性数据传输要求。CAN-C经常被用于连接以下子系统：\n· 发动机控制单元\n· 变速器控制单元\n· 车身稳定控制\n· 仪表系统\n\n低速CAN总线（Low Speed CAN，CAN-B）：CAN-B的标准是ISO11898-3，速率是 **5～125kbit/s**，对汽车舒适系统和车身控制系统（如天窗、车门等）的一些应用来说这个速率是足够的，CAN-B应用的例子如下：\n· 空调系统（AC）\n· 座椅调节\n· 电动车窗\n· 天窗控制\n· 后视镜调节\n· 灯光系统\n· 导航系统控制\n\nCAN总线还被应用于车辆诊断系统，汽车的各个ECU通过CAN总线连接，诊断设备可以直接接收诊断所需要的数据\nCAN数据包是广播到网络上每个ECU的，而且CAN数据包没有源地址和目的地址，只有一个消息ID，收到数据的ECU根据这个ID判断是否对这个数据感兴趣，从而传输到应用层进行处理。因此，如果攻击者取得了CAN总线的访问权，他很容易就可以监听网络上的数据或者伪造数据。同时，也提高了逆向分析的门槛，因为很难直接判断到底是网络上哪一个ECU发出了某个ID的数据，即溯源难。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173833.png)\n\n由于CAN总线经常被用于传输控制信号，伪造这些信号就非常简单。ECU连接了各种传感器和执行器，在一些情况下，一个ECU会发送CAN消息指示其他ECU执行某个动作（例如，刹车或加速），或者其他 ECU 根据某些信号自行判断是否需要执行某些动作。\n\n汽车里通常采用双绞线来做传输介质, 这两条线一条作为CAN-H，另一条作为CAN-L。这两条线通过差分信号传输数据以达到抑制共模干扰的目的\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173834.png)\n距离限制：由于数据在导线上传输会发生延时，为了使接收节点能够正确地接收数据，对数据的传输速率和导线长度有限制。\n· 1 Mbit/s，导线长度在40米以内（标准）\n· 500 kbit/s，导线长度在100米以内（建议)\n· 250 kbit/s，导线长度在250米以内\n· 125 kbit/s，导线长度在500米以内\n· 40 kbit/s，导线长度在1000米以内\n\n## CAN协议的特点\n### 去中心\n\nCAN协议不需要中央控制节点来协调通信，也就是说，网络上的节点都是平等的，每个节点都可以随时发送数据，一个或者多个节点损坏不会影响其他节点的通信。由于没有中央控制节点来协调数据传输，所有节点可能在任意时刻尝试发送数据，而这个尝试是否成功取决于当前总线是否空闲，以及是否通过总线仲裁（及多个节点同时访问总线时允许谁发送数据）。\n\n### 基于消息的寻址\nCAN不对网络中的节点进行寻址而对消息进行寻址，每个消息都有一个消息ID，根据ID判断是什么数据（例如速度消息、车窗控制消息等），但是各ID的消息里也可以有多个信号，所以每个节点发送消息时都是广播的，接收节点只接收那些感兴趣的ID的消息\n\n消息ID分为标准的11比特（CAN2.0A）和扩展的29比特（CAN2.0B）两种。11比特长的ID可以编码2048个不同的CAN消息，而29比特长的ID能编码的不同的CAN消息非常多。汽车中常用11比特CAN ID。\n基于消息寻址的一大优势就是网络中的节点不需要知道网络的配置，只需要接收和发送数据就可以，这样系统就非常灵活，例如一个ECU需要新的信息，它可以直接将这个信息对应的ID加入接收消息的表中。当有新节点加入网络时，也可以直接接到网络上，不需对网络上的其他节点进行修改。\n\n### 总线仲裁\n如果总线空闲（即隐态），那么任意节点都可以发送。CAN消息以一个显态作为帧开始（start of frame），接着就是消息ID。当有多个节点同时发送时，ID最小的消息优先发送且不会有数据丢失，这种仲裁方式允许显态重写隐态（即某一个或几个节点发送的是隐态，另外一个或几个节点发送的是显态，则总线上的电平是显态）。每个节点将消息ID一个比特一个比特地发送到总线上，MSB先发送。在这个仲裁过程中，每个参与仲裁的节点都将总线上的电平与自己发送的电平做比较。当某节点发送的是隐态而总线是显态时，就知道自己仲裁失败，而一个高优先级的消息（ID小的）则可以继续发送不被打断，因为 ID小且MSB先发送而逻辑0（显态）可以重写1（隐态）。\n\n当两个相同ID的消息被同时发送时会出现错误，所以CAN总线上不允许不同节点发送相同ID的消息。值得注意的是，当攻击者取得总线的访问权后，`不停地发送优先级最高的消息（即ID=0），这时 其他消息都得避让，造成拒绝服务攻击。`\n\n## CAN消息协议\nCAN总线上传输的有以下4种帧。\n数据帧：消息中包含发送节点的数据（如发动机转速）。\n远程帧：一个节点向其他节点请求数据。\n错误帧：当一个节点检测到错误时，将发送错误帧通知其他节点。\n超载帧：当一个节点无法及时处理数据时，即正在处理之前发送的数据，发送这种帧来告诉其他节点延迟发送下一个数据。\n\n很多时候，我们在利用工具读取或发送CAN数据时都只关心数据帧，所以接下来介绍数据帧。数据帧的结构:\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173835.png)\n很多工具可以用于抓取CAN数据，图6-10所示为用一款名为BusMater的免费软件，结合Kvaser的硬件，通过OBD接口上的CAN总线抓取到的数据帧。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173836.png)\n\n### ISO-TP\n虽然CAN协议标准里规定了数据最长为8个字节，但是有标准的基于CAN的上层协议用于发送大于8个字节的数据，比如ISO-TP或者ISO15765-2，根据这个标准可以通过CAN总线发送任意长度的数据\n\n## 统一诊断服务\n统一诊断服务 `UDS`（Unified Diagnostic Services）对应的标准是 ISO14229, 它定义了一系列诊断服务（service），这些诊断服务允许诊断仪（client 客户端）控制ECU（server服务器）的诊断功能，这些功能包括电子燃油喷射、自动变速箱和ABS系统，而这些控制单元都是通过车上的串行数据链路（如CAN总线）连接起来的。说它是独立于数据链路层的也就是说它可以基于各种数据传输协议实现，如基于CAN、Wi-Fi、FlexRay等。基于CAN的UDS的具体实现标准是ISO15765-3\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173837.png)\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173838.png)\n### 诊断会话控制\n10 这个服务和ECU建立一个诊断会话，在其他命令发送前这是必需的\n\n### 安全访问\n27 为了完成许多敏感诊断行为，有必要对ECU进行鉴别，这是由安全访问服务完成的。有多种级别的访问可能。**首次请求是向ECU请求一个密码种子，ECU和发送者共享一个密码函数和密钥，给出种子后才会发出响应消息。然后，发送者发送根据密码种子计算的结果给 ECU，以证明其拥有密钥**。用这种方式，**实际的密钥不会在CAN网络中传输**，但反过来进行非重复的复杂响应就值得商榷了\n\n### 输入/输出控制\n从安全研究者的角度看，其中一个有趣的功能是输入/输出控制。这个测试功能允许经授权的工具控制或者监视 ECU 的外部输入。例如，可以让 ECU 假装正在接收某个传感器的值以让汽修工判断传感器是否出了问题。\n\n### 基于局部识别码的输入/输出控制\n这个服务很像输入/输出控制，是丰田汽车针对诊断测试所特有的服务。这些类型的诊断测试对于安全研究人员来说很有用，因为它们可以验证汽车的某个功能。\n\n### 程序控制\n这个服务像是ECU里的RPC服务，它允许用户让ECU执行一些预编码的程序。\n第一个字节01告诉ECU我们想做什么，01的意思是开始程序。接下来的两个字节是程序识别码，在这个例子中是FF 00。剩余的字节是子程序的参数。ECU可能有一些程序控制服务或者根本没有。\n\n### 请求下载\n最根本的服务是请求上传和请求下载服务，这些服务可以导出或上传ECU的数据\n\n## CAN分析工具及逆向分析方法\n对汽车进行安全测试需要模拟攻击者对汽车发起攻击。攻击者要通过CAN总线使汽车执行刹车、转向等危险操作前了解CAN总线上的控制数据，这就需要对CAN数据进行逆向分析，破解控制协议。\nCAN 协议的分析可以使用汽车行业所采用的标准工具。例如，VehicleSpy、BusMaster、CANSpy等，还有一些安全研究人员使用的开源工具如CANToolz，本节就来介绍这些分析CAN总线的硬件工具及配套软件。\n\n### python CANToolz\n\n示例:\nCAN开关过滤器扫描检测哪个CAN帧可以通过诊断接口到HU并返回。\n中间人与防火墙（ECU ID检测）检测哪些包对应选定的“行为”。\n重放可以用于发现哪些包对应产生哪些“行为”，即逆向分析用。\nPing发现（支持ISO TP和UDS）、检测UDS等。\n\n## CAN协议逆向分析举例\nCAN 数据库是描述 CAN 消息含义的数据，一般是一个文本文件，属于厂家的保密信息。因为很多CAN消息的具体含义由厂家定义，所以CAN数据库可能会随着汽车型号的不同而不同。常见的CAN数据库格式为．dbc文件，VehicleSpy等专业的分析软件都支持这个格式，而BusMaster支持的CAN数据库文件为DBF\n\n确认简单的开关信号可以在打开或关闭开关的同时查看数据流是否有对应变化；速度消息可以通过寻找随着车速变化而变化的CAN消息确定。\n找到如速度或者转速这样的消息后可能还需要进行修正（加减修正量、乘以修正系数等）才能得到正确的物理值。\n\n## LIN总线\n在汽车内，还有许多ECU的控制并不需要CAN这样高速率和高安全的通信，本地互联网 LIN 就是为适应这类应用而设计的低成本解决方案。LIN 是一个公开的协议，它基于（UART）串行通信的格式\n几乎所有的 IC 都带有 SCI（UART）接口，LIN很快就在车内低端控制器领域取得领先地位。典型的LIN应用有车门、后视镜、导向轮、马达、照明及其他智能传感器。\n\n## MOST 总线\nMOST总线几乎只用于影音娱乐系统的连接\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173839.png)\nMOST25的速率是24.8Mbit/s，MOST50的速率是50Mbit/s，MOST150的速率是150Mbit/s。\nMOST 总线系统中一个节点坏掉就会瘫痪整个网络，所以可以采用直接旁路某节点的方式检查故障\n\n## FlexRay\nFlexRay是高速总线，在汽车上主要用于开环或闭环控制系统，主要特点是可靠性高、容错性好、实时性好。主要用于对可靠性和实时性要求比较高的应用场景，如`电控转向、电控刹车、电控驱动`等系统、电控油门，以及其他主动安全系统。这些系统可能没有机械备用系统，也就是说，如果电子系统故障将无法补救，所以对可靠性要求较高，\n\n# 攻击案例\n\n## jeep Uconnect漏洞分析\n### 总线上的模块\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173840.png)\n### 潜在攻击点\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173841.png)\n\n\n本案例主要是找的远程攻击点, 而对攻击面很窄的近距离攻击都略过了\n\n#### 胎压管理系统\n\n汽车上每个轮胎都有一个胎压传感器，会时刻测量胎压并把数据通过无线传输给对应的ECU，如图7-6所示。在Jeep上，接收传感器信号的ECU连接到了RFHM上。TPMS采用的无线数据协议或者格式往往是私有的，但几乎可以确定的是，通过采取一些操作是可以攻击TPMS系统的，欺骗车辆让其以为轮胎或TPMS系统出现了问题。另外，已有研究表明可以远程造成TPMS的ECU崩溃。从远程代码执行这个方面看，这个攻击面很窄。但是，既然ECU会崩溃说明其数据处理方式不够安全，所以这类攻击还是可能的。\n\n如今许多汽车都配备了蜂窝网功能（如GPRS、3G、4G等），一般叫作车载通信系统，用于将车辆连接到数据网络，例如通用安吉星系统。蜂窝连接也可以用于接收交通或天气信息等数据。\n这套系统是最重要的攻击入口，因为攻击距离很广，广到只要目标汽车上有蜂窝通信就可进行。即使车载通信系统没有被直接连接到CAN总线上，这个通信单元仍然可以用来传输如数据、声音等数据。有的研究人员此前就在没有涉及用户交互的情况下，远程利用过汽车上的通信单元。在Jeep上，所有这些功能都是由无线电控制的，而这个无线电广播又接在了CAN-IHS总线和CAN-C总线这两者之上。\n\n在2014年款的Jeep上，其通信系统、网络、无线电广播和APP都集成到哈曼卡顿的Uconnect系统上, 2014年款的Jeep使用了由哈曼卡顿生产的Uconnect 8.4AN/RA4无线电广播系统，全权负责提供Wi-Fi连接、导航、APP和蜂窝通信. \n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173842.png)\n\nIFS用于放置系统二进制及Uconnect车机运行QNX操作系统所需要的配置文件。他们通过观察从克莱斯勒汽车上获取的 ISO 文件中的文件判断哪些文件会在更新过程中受到影响\n\n### Wi-Fi密钥生成机制漏洞\n车载wifi 热点\n默认的Wi-Fi加密方法是WPA2，使用的密码是随机生成的8位字母数字组合。就目前 WPA2 的强度和可能的密码数量来看，这是一种非常安全的设置，所以问题是攻击者怎样才能入侵这样的网络呢？如果用户选用了`WEP`加密方法，或没有使用加密（虽然可能性比较小），攻击者都能轻易破解这种无线访问点。\n\n但是，即使用户使用了默认的 WPA2 设置，攻击者还是可以利用 Wi-Fi 密码生成算法的漏洞来破解 Wi-Fi 密码，而且方法很简单。通过反汇编 OMAP 芯片上的‘WifiSvc’二进制文件就可以找到用于生成 Wi-Fi 密码的算法\n\n#### 开放端口\n\n连接上车载wifi 热点后,  通常会扫描默认的网关确定是否有开放的端口来判断是否易于攻击\n\n研究者发现 uconnect 系统上存在开放端口 6667 , 运行dbus 服务, 可以用于跨进程通信\nD-Bus本可以要求认证，但是在uconnect车机上却允许匿名登录：\n可以使用DFeet工具与Jeep上的D-Bus服务交互: D-bus 服务可以列出车机娱乐系统上的服务, 类似于ServiceManager, 通过wifi 连接后 通过dbus 服务就可以控制车机的娱乐系统\n\n但wifi 热点这种还是属于近距离通信的场景, 攻击面比较窄\n\n### 蜂窝网连接\n2014年款Jeep的哈曼Uconnect系统还能够通过Sprint蜂窝网进行通信, 通过伪基站的方式可以联通 Dbus 进而控制车机娱乐系统\n\n### can总线连接情况\nUconnect系统除了可以通过Wi-Fi、蜂窝网和蓝牙等方式与外界通信外，还可以与CAN总线通信。虽然在德州仪器OMAP-DM3730系统上运行的ARM处理器无法直接访问CAN总线，但是主板上另一个Renesas V850处理器芯片有与CAN-IHS和CAN-C通信的能力\n\n### Dbus 服务\n在网络上暴露像 D-Bus 这样强大和全面的服务会造成几个安全问题，例如功能滥用、代码注入，甚至内存崩溃等。\n尤其是如果这样的服务有exec 权限和这样的接口, 那就可以进行命令注入, 非常危险\n\n### 车机娱乐系统\n\n#### GPS\n娱乐系统往往能够获取车机的定位, 这对于隐私追踪行为的风险是非常高的, 如果娱乐系统没有对这样的数据进行保护, 一旦娱乐系统被攻破(如 root提权等), 那类似这样的数据会被肆意利用\n\n#### HVAC\n车机空调系统\n\n#### 音量\n#### 低音\n#### 电台\n#### 显示屏\n#### 旋钮\n发现在关闭某项服务后能够使车机的旋钮控制失效，比如音量和调音器控制钮。通过关闭主要的 D-Bus 服务可以使所有的车机控制失去响应。如果关闭服务之前先执行几项其他的操作，这种攻击会变得非常烦人，比如把低音和音量调到最高后再关闭对应服务，就无法手动调低回去了\n\n### IOC\nUconnect系统能够与两条CAN总线通信，CAN通信是由Renesas V850ES/FJ3芯片负责处理的。漏洞利用了D-Bus后虽然取得了 OMAP 芯片的代码执行权限，但这块芯片并不能直接发送 CAN 信息。虽然这样，OMAP芯片可以与V850芯片通信，而V850芯片可以发送CAN信息。\n\n车机（OMAP芯片）可以对IOC（V850芯片）进行固件升级，通常是通过U盘完成\n\n#### 逆向IOC\n这项研究的主要目的不仅仅是证明汽车的通信系统是可以入侵的，还证明了在成功远程入侵通信系统后可以通过CAN总线控制汽车的物理功能，威胁到驾驶人员的安全。\nJeep 上的IOC(V 850) 固件并没有加密, 可以对其固件进行反汇编来确定CAN 指令是如何发送的\n\n另外对照芯片手册能加快反汇编的速度, 芯片手册上还记录了CAN模块所使用的寄存器和消息缓冲区, 针对这些寄存器可以进一步的快速定位.\n其次使用芯片的官方demo 示例编写代码然后查看其反汇编代码, 对照需要进行逆向的代码可进一步加速逆向的速度. 诸如此类的, 有官方demo的, 按官方demo 例程来开发的都给逆向工作带来了隐患.\n\n通过逆向, 发现代码的函数中有一个发送CAN 命令的函数,  通过向RAM中的几个位置填充想要的值，他们可以发送含有任意数据、消息 ID 和长度的 CAN消息, 类似这样可以发送任意原生CAN 指令数据的函数是非常危险的\n\n至此，他们遇到的最大问题是虽然有能力编辑任意CAN消息，但是他们实际上`没有办法远程直接调用发送函数来发送`，即他们只能间接地通过篡改V850的固件来调用函数发送CAN信息。虽然Uconnect系统确实执行了一些CAN功能，但是他们无法直接通过车机调用这些功能，所以他们需要另外想办法往CAN总线上发消息。他们想将V850作为一个代理，然后从OMAP芯片上通过V850发送CAN消息。\n\n研究人员进一步利用SPI 总线和修改过的v850 固件, 使得uconnect 系统可以通过omap spi 总线联通 ioc 系统, 使得uconnect 可以接入修改固件的ioc 的 can接口来发送任意can 消息\n\n### 破解烧写链路\n\nioc 基于v850 芯片, 能直接访问CAN 总线, v850的固件没有签名, 且可以通过omap 板子更新. 但是该系统设计为只能通过usb 进行更新.\n该芯片也分下载模式和启动模式, 只有在下载模式下才能更新烧写固件. 即芯片处于启动模式下, 是不能进行烧写的\n\n要让V850进入下载模式的唯一办法是复位V850，但是复位也会同时复位OMAP芯片，这样攻击者就会因为断线而失去控制。当OMAP进入“更新模式”时（要想让IOC进入下载模式的前提），OMAP处理器会尝试从USB设备更新。这种更新方式是硬编码的无法更改。\n\n现在的主要目标是让V850在没有USB设备参与的情况下进入“更新模式”，这样他们就可以利用远程上传到文件系统中的固件来更新V850。\n第一步是运行代码来重启V850并使其进入引导程序模式，同时还使OMAP进入更新模式。\n\n发现OMAP 进入更新模式时会调用文件系统上的一个可执行文件, 这个可执行文件居然是可写的, 这个可执行文件可以通过前面说的dbus的漏洞修改,  因为那个漏洞可以exec 进程, 将sh 植入进去就能修改文件系统了, 进一步为破解人员提供了便利. \n\n### 整个攻击链路\n\n下面总结漏洞利用链及利用链是如何工作的。\n\n1．目标识别\n首先攻击者需要车辆的IP地址。他可以随便选择一个IP进行攻击或写一个蠕虫来攻击所有的车辆。如果知道汽车的VIN或GPS，可以对所了解的车辆所在的IP段进行扫描直到发现对应的VIN或GPS。由于Sprint网络上设备速度很慢，要采用这种方法可能需要很多台设备（可能上百台）同时进行并行扫描才能现实。\n\n2．利用车机中的OMAP芯片\n一旦攻击者得到了车辆的IP地址，就可以使用相应的D-Bus服务的execute方法执行任意代码。最简单的方法就是上传一个SSH公钥和配置文件，然后启动SSH服务。这样就可以通过SSH接入目标车辆并在远程终端上运行命令。\n\n3．控制Uconnect系统\n如果攻击者只是想进行如控制无线电广播、空调、获取GPS信息或者其他不涉及CAN的攻击 其实调用D-Bus服务就可以实现大部分的控制功能，不需要通过代码来控制\n\n4．在V850中刷入篡改过的固件\n准备好一个篡改过的V850固件，按照前文中提到的要求就可以轻易地把篡改后的固件刷入V850。这个过程需要自动重启系统，这可能会让驾驶员产生警觉。如果这一步搞砸了车机就会变砖，需要更换。\n\n5．通过网络执行物理操作\n利用篡改过的固件，从OMAP芯片通过SPI向V850芯片（运行的是修改过的固件）发送消息，从而向CAN总线发送适当的CAN消息实现物理控制车辆，这一过程需要用到类似他们2013年发表的文章中的知识，即CAN总线攻击。\n\n### 逆向CAN 消息\n在实现远程发送CAN消息后要开始想办法发送CAN消息来物理控制汽车。为了弄明白要发送哪些CAN消息才能控制汽车，他们需要弄明白Jeep的CAN私有控制协议（除了诊断数据以外的 CAN 数据大多都是厂家自定义的）。这一过程需要不断地尝试，逆向汽车维修设备、逆向ECU固件、分析数据流等\n\n和所有的安全研究一样，拥有合适的工具就能省很多事儿。所以他们搞了一套适用于Jeep车的维修诊断工具。诊断工具可以在底层通过CAN与ECU交互。在这些工具中包含攻击者感兴趣的安全访问密钥和诊断测试功能等\n\n虽然某些研究可以在不使用诊断设备的情况下进行，但是很多主动测试和 ECU解锁都需要分析这些诊断工具获得密钥、校验算法、协议等\n\nJeep 适配的诊断系统为 wiTECH, 是Java写的, 逆向更加容易, 因为可以把字节码反编译为源码.\n该系统经过了 Java Allatori混淆器生成, 但是可以导入到Java 应用中, 也就是换了一个应用容器来让这些代码有环境执行,  使得代码能正常运行起来, 然后应用中调用库函数解密混淆的字符串.\n\n虽然他们没有解锁算法，但是他们很清楚整个解锁流程。首先 wiTECH 会向ECU请求获取密码种子，在获得密码种子后再判断ECU的类型，并解密对应的解锁文件，而他们认为密钥的生成算法就在这些解锁文件中。 通过观察源码中的函数名称以及代码实现, 研究人员找到了生成密钥的算法, 尽管这些算法被加密了, \n\n### ECU 逆向\n利用 wiTECH 工具他们能够执行主动功能测试，并嗅探测试结果。他们破解了安全解锁算法和密钥，这样就可以执行需要权限才能执行的操作。但问题是wiTECH工具发送的消息是固定的而且没有使用校验和，而ECU之间的通信经常会使用校验和，如果他们**想要自己生成CAN消息（或者伪造CAN消息），而不是仅重放嗅探到的消息，他们就必须要能够自己生成校验和**。\n研究人员通过逆向 PAM(自动泊车系统)的固件(这个固件可以通过wiTECH升级, 从wiTECH下载的升级固件中可以找到这个ECU的固件),  找到了生成CAN消息校验和的函数算法. \n\n至此研究人员掌握整个攻击链路, 通过娱乐系统攻入控制系统, 往控制系统中注入伪造的CAN消息达到控制车辆的目的\n\n### 漏洞总结\n对于上述的攻击链路, 防御的链路需要重点注意下面几个方面:\n\n1. 娱乐系统的对外通信一定要做到是安全的链路, 不能有开放的端口, 类似ServiceManager Dbus这样的服务一定要做好安全的管控.\n2. ecu的固件最好是保密且认证的, 密钥和证书或者公钥或公钥的hash是存在hsm内部的, 防止被篡改\n3. can消息的校验和函数最好保证是自主硬件实现, 且不对外公布. 如果CAN消息能做到是加密的则更好, 这个比较难.\n4. 配套的obd 维修套件尽量不要用java来写, java的安全性相对于c/c++来说还是太弱了.  obd 维修套件最好做好加密措施, 保证不能被轻易破解\n5. 娱乐系统和控制系统之间做好逻辑及物理隔离, 确需娱乐系统发送控制命令的, 尽量使用接入api的方式, 且需要鉴权机制.\n\n## 宝马攻击案例\nConnectedDrive是宝马汽车配备的典型系统。为了研究这类系统是否存在侵犯用户隐私等问题，ADAC邀请研究员Dieter Spaar对宝马ConnectedDrive系统进行了研究，尽管这项研究不是以漏洞挖掘为目的，但在研究过程中还是发现了一些严重的漏洞。 该系统可以通过手机远程控制车的一些功能, 如解锁上锁等\n\n分析Combox 控制器\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173843.png)\n\n\nV850与通信模块之间采用串行通信接口SPI相连接，经过分析发现，在串行通信线上抓取到的数据与通信模块发送出去并被基站捕获到的数据不同，因此判断数据在通信模块中被加密了\n由于通信模块没有提供标准的调试接口（如jtag）用于读取固件，所以要得到固件就需要将通信模块的Flash芯片拆下来，然后用一个转接器读取固件, 为了读取Flash里的内容，将Flash芯片与一块STM32单片机开发板相连，然后利用单片机通过串口将数据发送到计算机。\n\n它通过IDA Pro很快便在固件中发现了几种加密算法和摘要算法，这是因为一些常见的加密算法采用了常量表（`如AES的S盒、DES的置换表等`），通过搜索这些常量表可以分辨出采用的是哪些算法。\n知道了加密算法后下一步就要找到密钥，一个乐观的假设是通信模块所采用的密钥是为每一辆车单独生成的，然后保存在V850ES里，再由V850ES发送给通信模块。如果真是这样的话，寻找密钥就非常费事了\n\n先对紧急电话的协议进行分析，通过固件的一些关键字符串很快发现通信模块采用了下一代通信与信息系统协议, 该协议可以更新密钥, 所以推断出密钥一定保存在某个地方，最后发现固件里包含了一些比较可疑的数据，尝试使用这些数据解密通过基站监听到的紧急短信，经过一些尝试后成功解密了数据。\n\n经过进一步分析发现，通信模块采用了56位的DES、128位AES对数据进行加密。对数据签名采用的是 DES CBC-MAC、HMAC-SHA1，以及HMAC-SHA256。数据加密或者签名所采用的密钥是在由16对64位密钥组成的密钥池里选取的，数据采用的加密或者签名算法及所采用的密钥编号在消息的头部会有声明，从而让接收方采用对应的算法进行解密或者认证。\n\n要使用远程开锁功能需要车主在宝马的网站上注册一个账号，然后开通远程控制功能就可以使用宝马推出的iOS版本或者安卓版本的名叫“My BMW Remote”的手机应用程序开车门了。首先要分析服务器与汽车之间的通信数据, 监听通信数据最简单的办法就是在V850SE与通信模块之间的串行通信上进行数据记录和监听。当通过手机应用发送开门命令后，在所记录的数据里找到短消息，消息包含调试字符，因为这些消息是给通信模块进行处理的。由于之前已经获得了密钥池和加密算法，能轻松地解密这些消息。为了验证汽车的反应，通过基站测试环境给汽车发送监听到的消息（即重放攻击）。汽车收到信息后需要一分钟左右启动主系统，然后Combox会向宝马后台服务器发起数据连接来获取数据（经过后续分析发现获取的数据其实就是要执行的命令）, 攻击者可以通过便携式基站发送激活短信并伪造服务返回开门命令数据，而这整个过程车主都不知情。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173844.png)\n\n比较令人惊讶的是汽车与后台的通信数据可以轻易地通过搭建的测试基站环境获取，没有任何问题。这辆车发送了一个简单的 HTTP 请求，传输中并不存在SSL或TLS加密。\n为了弄清楚Combox需要从服务器获得什么信息才能打开车门，首先通过手机应用发送开门指令，这样服务器就会将汽车需要的开锁指令数据准备好以便汽车收到短信后去请求，然后进行短信的重放攻击。经过测试这样可以打开车门, 只需要通过一台笔记本和一个基站就可以伪造短信和服务器开门，即通过基站发送短信，然后使用笔记本伪造成宝马后台服务器在汽车请求开锁数据时将数据发给汽车\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173845.png)\n### 激活远程控制功能\n激活远程控制功能的流程和前面开门的流程类似，开通 ConnectedDrive 远程控制功能的流程如图所示\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173846.png)\n由于XML格式的配置文件没有加密或者签名，可以通过像之前伪造开门命令一样的方式伪造。所以，针对没有开通ConnectedDrive远程控制的汽车可以先通过这种方式开通远程控制功能，然后打开车门\n伪造基站网络来解锁所需设备只需要一个背包能装入。伪造的基站（即 IMSI Catcher)的覆盖范围可达到100米以上，即使在市中心也是如此。IMSI Catcher在这个区域中会提供比实际移动网络更强的信号，导致手机会优先选择接入伪造网络。\n\n伪基站可以通过入网认证许可号(IMEI) 来识别设备, IMEI的前八个字符标识了设备型号\n\n### 漏洞总结\n总结整个研究过程，ConnectedDrive一共出现了6个漏洞。\n（1）宝马在所有车型中使用了相同的对称密钥。可以为每辆汽车设置不同密钥来预防。\n（2）有些服务没有对车辆与宝马后端服务器之间传输的信息进行加密。https 加密防御\n（3）ConnectedDrive配置数据没有采用防篡改机制。 对配置文件进行签名\n（4）Combox通过NGTP错误信息暴露了正确VIN。不要对错误请求进行响应\n（5）通过短信发送的NGTP数据采用了不安全的DES算法进行加密。升级加密算法，采用安全的加密算法。\n（6）Combox没有针对重放攻击采取防护措施。对数据加入序列号并签名。或者加入单调计数器\n\n## 特斯拉model S 攻击案例\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173847.png)\n\n这种将汽车的控制器网络与娱乐信息系统进行隔离的网络架构是非常优秀的设计，因为娱乐信息系统有丰富的网络连接，当黑客入侵娱乐系统后还需要通过网关才能控制汽车的关键部件[例如，行驶安全相关的部件（如电动转向、电子刹车等）]。\n\nWi-Fi：将Model S连入Wi-Fi后并没有发现开放的端口，但是当Model S连上Wi-Fi后首先会通过向一些服务器发起http请求确定网络连通性，在确定网络连通性后尝试通过 OpenVPN 连接特斯拉服务器（地址是 vpn.vn.teslamotors.com）。由于OpenVPN配置正确，不能进行中间人攻击。\n\n特斯拉的OpenVPN使用UDP协议，并启用了tls-auth，这就是CarKey.tar中包含的那个静态密钥的用处，即用于对数据包加入HMAC（Keyed-Hashing for Message Authentication）用于消息认证、用于防止DoS攻击、端口扫描、未授权的SSL/TLS握手和初始化等。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173848.png)\n\n特斯拉在配置OpenVPN 服务时, 客户端与服务器进行通信, 服务器需要返回服务器证书, 由客户端进行校验, 而服务器端需要校验客户端的证书, 客户端证书和服务器证书并不是一个, 杜绝了中间人攻击. 即假的服务器是无法通过客户端的校验的.\n如果能找到一个由Issuing CA签发的证书而且这个证书的EKU指定用途为服务端认证，就可以伪造一个VPN服务器进行中间人攻击。\n\n通过扫描以太网接口, 发现了一些开放的端口和服务\n最后，他们还找到了分别运行于IC(仪表盘)和CID(中央信息显示模块)上的两个程序ic-updater和cid-updater，从字面意思理解这两个程序分别为IC和CID的升级程序，功能是获取诊断信息、上传文件或者固件，这两个程序的大部分命令都有认证保护，但是其中也有些没有，例如‘status’，这两个程序在输入‘status’状态命令时会打印出许多信息娱乐系统的关键信息，属于信息泄露漏洞\n\nstatus 显示信息中泄露了固件升级的下载地址, 由于之前已经找到了客户端的证书, 可以伪造客户端请求来申请更新固件, 即可以下载到固件.\n下载到ic和cid(中央信息显示模块后)的固件后, 该固件没有加密, 所以可以直接挂载到pc上, 该固件运行的系统是ubuntu的, 通过查找linux的私钥和shadow 文件(Linux 系统里存储用户名和密码哈希等相关信息的文件), 找到了ic的shadow文件, 下一步就是破解shadow 文件获得密码(如彩虹表 字典 暴力破解等). 特斯拉设置的密码是弱密码, 很容易破解. 有了 密码和账号后, 由于前面扫描出的端口中居然有ssh的开放端口, 可以直接登录到系统中, 而且账号是有sudo权限的.\n\nIC的root权限已经搞定了，下一步要搞定CID的root权限，由于没有CID的shadow文件，所以只有继续分析固件，通过分析固件发现CID每隔24小时就会从一个名为mothership的服务器获取一个安全令牌（Security Token），然后将一个名为tesla1 的账号的密码设为这个安全令牌。CID 还会将安全令牌发给IC，IC 则将安全令牌明文存储。通过在IC的文件系统中找到这个安全令牌可以登录CID上的tesla1账号，而且这个tesla1账号也是一个sudoer，就这样，IC和CID的root权限都被搞定了。\n\n获得了IC和CID的root权限后，下一步再来看看如何控制汽车，Model S的内网数据传输率较高，每秒约 500～1000 个 UDP 报文包，搞清楚哪些数据包包含的是控制数据比较困难，所以通过分析程序判断哪些数据是通过手机应用或者 CID 上面的按钮进行操作才出现的数据可以快速弄清楚哪些数据控制哪些功能。在弄清楚控制某些功能的数据后还要弄清楚是哪个服务发送了这些数据，由于是通过 CID 的触摸屏来控制的，所以在CID 上使用strace 系统调用监控命令来分析是哪个服务发送了这些数据，结果发现是一个名为QtCarVehicle的服务发送了那些控制数据包。\n\nQtCarVehicle包含一个叫Gateway Message Sender的类，用于通过网关发送消息的类，然后就是执行这个类的各种功能的方法。\n\n值得注意的是，经过逆向分析还发现Model S并不会直接通过信息娱乐系统发送CAN原始数据包控制汽车，而是采用了API调用的方式，即CID通过功能调用接口请求网关执行某个功能的操作，这些功能操作都是预先定义好的允许执行的操作。\n\n娱乐系统通过功能接口请求网关执行特定操作的设计非常重要（这里指 CID 通过 API 请求网关），这种设计可以保障在信息娱乐系统被黑客攻陷后，不能直接往CAN 总线发送原始 CAN 数据，只能执行预先设置好的“允许”的功能。当然，这是在网关没有被攻破（例如，Jeep案例中，攻击者将被修改后的固件刷入V850后）的前提下。\n\n接入CID后调用QtCarVehicle服务提供的功能可以控制汽车的一些功能，例如关闭电源\n还可以控制如下功能。\n（1）关闭汽车。\n（2）启动汽车。\n（3）开关门。\n（4）开关天窗。\n（5）开关前后行李箱。\n（6）控制大灯。\n（7）控制减震器。\n（8）控制空调。\n（9）鸣笛。\n\n### 漏洞防御总结\n\n汽车的娱乐系统安全性都是比较差的, 特斯拉做的比较好的一点就是将控制网络与娱乐信息系统进行隔离, 只能通过网关的api 做一些预设的功能.\n\n对固件来说, 系统要进行分区, 系统分区对应的固件要进行加密, 由secureboot 链路保证即使下载到了固件, 也不能读上面的内容, 一方面保证了知识产权, 另一方面对linux root 相关的文件做了二次保护.\n\n不能有开放的端口, 尤其是不能开放ssh . \n服务器与车之间的通信要做到强安全链路, 如特斯拉的openvpn配置是比较好的一种策略.\n\n信息娱乐系统网络上的节点间通信没有加密，并且有些还没有认证：网络上的节点间通信没有加密，所以攻击者可以分析网络上的所有流量。另外，只有少部分服务采用了认证机制。如果要实现节点级别的安全，那么网络上所有的节点绝对不能对网络有任何信任，任何节点间的通信都应该经过加密和认证。\n\n##  OTA 升级\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220705173849.png)\n\n（1）ConnectedDrive的漏洞中没有对服务器进行认证，导致可以进行中间人攻击，而且汽车采用相同的密钥，导致通信密钥一旦泄露就会影响到所有采用相同密钥的车型。\n（2）Jeep车的V850在更新固件时由于没有采用固件签名和加密，导致黑客可以得到固件进行逆向分析后对固件进行篡改（加入发送 CAN 数据的代码），再用篡改后的固件对V850进行升级从而控制汽车。\n（3）在Tesla Model S的案例分析中，由于固件下载地址及客户端向服务器认证的信息泄露，导致600多兆的固件可以被下载。\n\n典型的固件升级过程如下:\n（1）开发人员开发出新版本的固件。\n（2）厂家对新版本的固件进行加密并用私钥进行签名。\n（3）签名后的新版固件被上传到厂家的升级服务器。\n（4）汽车同服务器建立安全的通信链路（例如，通过验证服务器证书来防止服务器被伪造）。\n（5）汽车通过安全通信链路下载固件。\n（6）汽车对固件进行解密。\n（7）汽车验证固件签名。\n（8）汽车利用固件进行升级。\n\n在上面的过程中，由于固件是加密的，所以就算攻击者破坏了传输过程的安全获得的也只是加密的固件，防止了IP（知识产权，Intellectual Property）泄漏。汽车和服务器相互验证了彼此的证书，防止了中间人攻击。固件使用签名防止了被串改。\n\n另外，还有一些问题需要解决。\n（1）密钥和证书的安全保存和管理问题，在特斯拉和宝马的案例中黑客通过物理方法获取密钥和证书，像这类重要信息最好引入防破解的硬件安全模块 HSM（Hardware Security Module）来安全保存和处理。为了防止一辆汽车被破解而影响其他车辆的情况出现，每辆汽车需要有自己的密钥，密钥的管理问题也需要解决。\n（2）回滚需要用到的固件需要备份并加密保存，当更新出现问题时能够保证回滚到可以运行的老版本固件，防止由于升级失败而使汽车变砖。\n（3）固件更新程序（例如bootloader）控制远程更新，而其本身一般无法更新，所以代码的安全只能通过安全开发及测试保证。","tags":["汽车"],"categories":["安全"]},{"title":"PCI 调研","url":"/2022/04/11/hxd_new/riscv调研/PCI 调研/","content":"\n# PCI 设备驱动\n\nPCI(Periheral Component Interconnect)有三种地址空间：PCI I/O空间、PCI内存地址空间和PCI配置空间\n\n- PCI I/O空间和PCI内存地址空间由设备驱动程序(设备本身驱动)使用\n- PCI配置空间由Linux PCI初始化代码使用，这些代码用于配置PCI设备，比如中断号以及I/O或内存基地址\n\nPCI设备驱动就是要大致描述对于PCI设备驱动\n\n- Linux内核都帮我们做了什么(主)\n- 我们应该完成什么(次)。\n\n## Linux内核做了什么\n\nLinux内核主要就做了对PCI设备的**枚举**和**配置**；这些工作都是在Linux内核初始化时完成的。\n\nPCI桥主要包括以下三种：\n\n1. Host/PCI桥\n\n   用于连接CPU与PCI根总线，第1个根总线的编号为0。在PC中，内存控制器也通常被集成到Host/PCI桥设备芯片中，因此Host/PCI桥通常也被称为“`北桥芯片组`(North Bridge Chipset)”。\n\n2. PCI/ISA桥\n\n   用于连接旧的ISA总线。通常，PCI中类似i8359A中断控制器这样的设备也会被集成到PCI/ISA桥设备中。因此，PCI/ISA桥通常也被称为“`南桥芯片组`(South Bridge Chipset)”\n\n 3. PCI-to-PCI桥(以下称为PCI-PCI桥):\n\n    用于连接PCI主总线(Primary Bus)和次总线(Secondary Bus)。PCI-PCI桥所处的PCI总线称为**主总线**，即次总线的父总线；PCI-PCI桥所连接的PCI总线称为**次总线**，即主总线的子总线。\n\n![image-20240416112936826](attachments/image-20240416112936826.png)\n\nCPU通过Host/PCI桥与一条PCI总线相连，处在这种位置上的PCI总线称为根总线。PC机中通常只有一个Host/PCI桥，在一条PCI总线的基础上，可以再通过PCI桥连接到其他次一层的总线，例如通过PCI-PCI桥可以连接到另一条PCI总线，通过PCI-ISA桥可以连接到一条ISA总线。\n\n通过使用PCI-PCI桥，就构筑起了一个层次的、树状的PCI系统结构。对于上层的总线而言，连接在这条总线上的PCI桥也是一个设备。但是这是一种特殊的设备，它既是上层总线上的一个设备，实际上又是上层总线的延伸。\n\n### 枚举\n\n就是从Host/PCI桥开始进行探测和扫描，逐个“枚举”连接在第一条PCI总线上的所有设备并记录在案。如果其中的某个设备是PCI-PCI桥，则又进一步再探测和扫描连在这个桥上的次级PCI总线。就这样递归下去，直到穷尽系统中的所有PCI设备。\n\n其结果，是在内存中建立起一棵代表着这些PCI总线和设备的PCI树。每个PCI设备（包括PCI桥设备）都由一个`pci_dev`结构体来表示，而每条PCI总线则由pci_bus结构来表示。\n\n![image-20240416112940709](attachments/image-20240416112940709.png)\n\n### 配置\n\nPCI设备中一般都带有一些RAM和ROM 空间, 通常的`控制`/`状态`寄存器和`数据`寄存器也往往以RAM区间的形式出现，而这些区间的地址在设备内部一般都是从0开始编址的，那么当总线上挂接了多个设备时，对这些空间的访问就会产生冲突。所以，这些地址都要先映射到**系统总线**上，再进一步映射到**内核的虚拟地址空间**。\n\n配置就是通过对PCI配置空间的寄存器进行操作从而完成地址的映射\n\nlinux 内核只完成**内部编址**映射到**总线地址**的工作，而映射到内核的虚拟地址空间是由**设备本身的驱动**要做的工作\n\n## Linux内核怎么做的\n\n对于PCI的设备初始化(即上面提到的枚举和配置工作)，PC机的BIOS和Linux内核都可以做, 一般而言，只要是采用PCI总线的PC机，其BIOS就必须提供对PCI总线操作的支持，因而称为PCI BIOS。而且最早Linux内核也是通过这种BIOS调用的方式来获取系统中的PCI设备信息的，但是不是所有的平台都有BIOS(如某些嵌入式系统)，并且在实践中也发现有些母板上的PCI BIOS存在这样那样的问题，所以后来就改由Linux内核自己动手了.\n\nLinux内核还是很体贴的在make menuconfig的选项里为我们提供了自己选择的权利，即**PCI access mode**，里面提供了四个选项分别是**BIOS、MMconfig、Direct和Any**。`Direct`方式就是抛开BIOS而由内核自己完成初始化工作的意思。\n\n当PCI设备上电时，硬件保持`未激活`状态。即该设备只会对`配置事务`做出响应。上电时，**设备上不会有内存和I/O端口映射到计算机的地址空间；其他设备相关的功能，例如中断报告，也被禁止。**\n\n每个设备的配置寄存器组最多可以有256字节的连续空间，其中开头的64字节的用途和格式是标准的，称为`配置寄存器`的头部。\n\n系统中提供一些与硬件有关的机制，使得PCI配置代码可以检测在一个给定的PCI总线上所有可能的PCI配置寄存器头部，从而知道哪个PCI插槽上目前有设备，哪个插槽上暂无设备。这是通过读PCI配置寄存器头部上的某个域完成的(一般是“Vendor ID\" 域)。如果一个插槽上为空，上述操作会返回一些错误返回值，如0xFFFFFFFF。这种头部(指64字节头部)又有三种\n\n```c\n#define PCI_HEADER_TYPE_NORMAL 0\n#define PCI_HEADER_TYPE_BRIDGE 1\n#define PCI_HEADER_TYPE_CARDBUS 2\n```\n\n- “0型”(type 0)头部用于一般的PCI设备\n- “1型”头部用于各种PCI-PCI桥\n- “2型”头部是用于PCI-CardBus桥的，CardBus是笔记本电脑中使用的总线，\n\n64字节头部中的16个字节中又包含着有关头部的类型、设备的种类、设备的一些性质、由谁制造等等信息。根据这16个字节中提供的信息，来确定应该怎样进一步解释和处理剩余头部中的48个字节\n\n在Linux系统上，可以通过`cat /proc/pci `等命令查看系统中所有PCI设备的类别、型号以及厂商等等信息，**那就是从这些寄存器来的**。下面是在虚拟机中用`lspci -x`命令的信息截取(lspci命令也是使用/proc文件作为其信息来源)\n\n配置寄存器可以让我们来进行配置以便完成PCI设备上的存储空间的访问，**但这些配置寄存器本身也位于PCI设备地址空间中**，如何访问这部分空间也就成了我们整个初始化工作的一个入口点\n\nPCI采用的办法是让所有设备的配置寄存器组**都采用相同的地址**，由所在总线的PCI桥在访问时***附加上其他条件***来区分。\n\n对于i386结构的处理器，PCI总线的设计者在I/O地址空间保留了8个字节用于这个目的，那就是`0xCF8~0xCFF`。这8个字节构成了两个32位的寄存器，第一个是“地址寄存器”0xCF8，第二个是“数据寄存器”0xCFC。要访问某个设备中的某个配置寄存器时，CPU先往地址寄存器中写入目标地址，然后通过数据寄存器读写数据。不过，写入地址寄存器的目标地址是一种总线号、设备号、功能号以及设备寄存器地址在内的综合地址。\n\n![image-20240416112944585](attachments/image-20240416112944585.png)\n\n这里的总线号、设备号和功能号是对配置寄存器地址的扩充，就是上面提到的***附加的其他条件***。\n\n首先每个PCI总线都有个总线号，主总线的总线号为0，其余的则由CPU在枚举阶段每当探测到一个PCI桥时便为其指定一个，依次递增。设备号一般代表着一块PCI接口卡(更确切的说是PCI总线接口芯片)，通常取决于插槽的位置。每块PCI接口卡上可以有若干个功能模块，这些功能模块共用一个PCI总线接口芯片.\n\n所以设备号和功能号合在一起又可以称作“逻辑设备号”，而每块卡上最多可以容纳8个设备。显然，这些字段(指整个32bit)结合在一起就惟一确定了系统中的一项PCI逻辑设备。开始时，只有0号总线可以访问，在扫描0号总线时如果发现上面某个设备是PCI桥，就为之指定一个新的总线号，例如1，这样1号总线就可以访问了，这就是枚举阶段的任务之一。\n\n>  当我们拿到一块PCI网卡，我们把它插到PC的主板上，打算写个这个网卡的驱动。那么第一步该干什么呢？\n>\n> 把网卡插上了，现在Linux内核有没有识别出这块设备呢？ 注意识别出设备跟能正常使用设备是不同的概念，当设备的驱动没有安装时，我们在设备管理器中是可以看到这个设备的，不过上面是一个黄色的大问号。而在Linux系统中，我们可以通过lspci命令来查看。\n>\n> lspci 的输出( pciutils 的一部分, 在大部分发布中都有)和在 /proc/pci 和 /porc/bus/pci 中的信息排布. PCI 设备的 sysfs 表示也显示了这种寻址方案, 还有 PCI 域信息. 当显示硬件地址时它可被显示为   所有的值常常用 16 进制显示.\n>\n> - 2 个值( 一个 8-位**总线号**和一个 8-位 **设备和功能号**),\n> - 3 个值( bus, device, 和 function),\n> - 4 个值(domain, bus, device, 和 function);\n>\n> lspci 使用 /proc 文件作为它的信息源.\n>\n> `/sys/bus/pci/devices/`\n>\n> ` cat /proc/bus/pci/devices | cut -f1`\n>\n>  拿 VGA 视频控制器作一个例子, 0x00a0 意思是 0000:00:14.0 当划分为域(16位), 总线(8位), 设备(5位)和功能(3位).为什么0x00a0对应的是0000:00:14.0呢\n>\n> 0000000010100000，很容易看出高8位是总线号也就是0, 设备号为0b10100 即0x14 , 功能号为0\n\n### pci设备 pci桥扫描与配置\n\nLinux PCI 设备驱动代码必须扫描系统中所有的 PCI 总线，寻找系统中所有的 PCI 设备 (包括 PCI-PCI 桥设备)。系统中的每条 PCI 总线都有个编号 number，根 PCI 总线的编号为 0。系统当前存在的所有根总线 (因为可能存在不止一个 Host/PCI 桥，那么就可能存在多条根总线) 都通过其 `pci_bus` 结构体中的 node 成员链接成一个**全局的根总线链表**，而根总线下面的所有下级总线则都通过其 `pci_bus` 结构体中的 node 成员链接到其**父总线**的 children 链表中。这样，通过这两种 PCI 总线链表，**Linux 内核就将所有的 pci_bus 结构体以一种倒置树的方式组织起来**。\n\n每个 PCI 设备都由一个 `pci_dev` 结构体表示, 每个 pci_dev 结构体都同时连入两个队列\n\n- 通过其成员 `global_list` 挂入一个总的 pci_dev 结构队列 (队列头是 `pci_devices`)\n- 又通过成员 `bus_list` 挂入其所在总线的 pci_dev 结构队列 devices(队列头是 pci_bus.devices, 即**该 pci 设备所在的 pci 总线的 devices 队列**)，并且使指针 bus(指 pci_dev 结构体里的 bus 成员) 指向代表着其所在总线的 pci_bus 结构。\n\n如果具体的设备是 PCI-PCI 桥，则还要使其指针 subordinate 指向代表着另一条 PCI 总线的 pci_bus 结构\n\n![image-20240416112948290](attachments/image-20240416112948290.png)\n\nLinux PCI 初始化代码从 PCI 总线 0 开始扫描，它通过读取 `Vendor ID` 和 `Device ID` 来试图发现每一个插槽上的设备。如果发现了一个 PCI-PCI 桥，则创建一个 pci_bus 数据结构并且连入到由 pci_root_buses 指向的 pci_bus 和 pci_dev 数据结构组成的树中。PCI 初始化代码通过设备类代码 0x060400 来判断一个 PCI 设备是否是 PCI-PCI 桥。\n\n在枚举阶段做的是`深度优先扫描`，所以子树中的总线号总是连续递增的。当 CPU 往 I/O 寄存器 0xCF8 中写入一个综合地址以后，从 0 号总线开始，每个 PCI-PCI 桥会把综合地址中的总线号与自身的总线号相比，如果相符就用逻辑设备号在本总线上寻访目标设备, 否则就进一步把这个总线号与`PCI_SUBORDINATE_BUS` 中的内容相比，如果目标总线号落在当前子树范围中，就把综合地址传递给其下的各个次层 PCI-PCI 桥，要不然就不予理睬。\n\nPCI-PCI 桥要想正确传递对 PCI I/O，PCI Memory 或 PCI Configuration 地址空间的读和写请求，必须知道下列信息：\n\n1. **Primary Bus Number(主总线号)**\n\n​\t\t该 PCI-PCI 桥所处的 PCI 总线称为主总线。\n\n2. **Secondary Bus Number(子总线号)**\n\n   \t该 PCI-PCI 桥所连接的 PCI 总线称为子总线 / 次总线号。\n\n3. **Subordinate Bus Number**\n\n​\t\tPCI 总线的下属 PCI 总线的总线编号最大值。\n\nPCI 桥的配置寄存器与一般的 PCI 设备不同。一般 PCI 设备可以有 6 个地址区间，外加一个 ROM 区间，代表着设备上实际存在的存储器或寄存器区间。而 PCI 桥，则本身并不一定有存储器或寄存器区间，但是却有三个**用于地址过滤的区间**。每个地址过滤区间决定了一个地址窗口，从 CPU 一侧发出的地址，如果落在 PCI 桥的某个窗口内，就可以**穿过 PCI 桥而到达其所连接的总线上**。\n\n每个 PCI-PCI 桥必须正确地被设置好它所负责的 PCI I/O 或 PCI memory 的起始地址和大小。当一个读或写请求地址落在其负责的范围之内，这个请求将被映射到次级的 PCI 总线上。系统中的 PCI-PCI 桥一旦设置完毕，如果 Linux 中的设备驱动程序存取的 PCI I/O 和 PCI memory 地址落在在这些窗口之内，那么这些 PCI-PCI 桥就是透明的。这是个很重要的特性，使得 Linux PCI 设备驱动程序开发者的工作容易些。\n\n![image-20240416112951715](attachments/image-20240416112951715.png)","tags":["驱动"],"categories":["PCI"]},{"title":"hsm 参考","url":"/2022/03/25/TEE/HSM 参考/","content":"\n# HSM 规范\n\nHSM是一种自主的硬件，可以用于车辆安全信息（比如密钥）的生成，存贮以及处理，且隔离外部恶意软件的攻击。\n\nHSM可以用于构建，验证可靠的软件，以保护在软件加载并初次访问之前的安全启动。HSM包含有加密/解密硬件加速功能，和软件解决方案相比（Cry）,能够有效降低CPU负载。\n\n包含两个部分:\n1.  Security building blocks负责加密/解密的硬件操作；\n2.  Logical building blocks负责与Application ECU交互数据以及软件的加密/解密操作；\n\n## hsm 等级\n### full hsm\n\n![full hsm](https://pic4.zhimg.com/v2-cc6c609c713dab25d187489a6a436cdf_r.jpg)\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170642.png)\n\n-   ECC-256：256位高速ECC椭圆加密算法引擎；\n-   Whirlpool: AES Hash算法；\n-   AES-128：标准AES加密/解密算法；\n-   PRNG with TRNG seed：真伪随机数生成器；\n\n### Medium hsm\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170643.png)\n无ECC和Hash引擎；和EVITA full一样，medium的安全区域，完全是和应用程序ECU隔离开的；\n\n### light hsm\n\n只有aes 对称加密的加速器\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170644.png)\n## HSM的功能\n\n-   对称密钥加密/解密\n-   非对称密钥加密/解密\n-   哈希值计算\n-   非对称签名的生成和验证\n-   对称验证\n-   随机数生成\n-   安全密钥存贮\n-   单调计数器\n\n## HSM的应用场景\n\n-   启动保护\n-   安全的板级通信\n-   安全的诊断锁\n-   安全的软件更新\n-   访问控制\n\n# autosar CSM 调用链的要求\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170645.png)\n\n1. 密钥存储, 密钥派生, 密钥权限管控\n2. autosar 调用链存在同步任务/异步任务, 异步任务的实现需要hsm 硬件支持中断\n\n# 防物理攻击(可选)\n### FIPS-140 2 标准安全等级\n[NIST.FIPS.140-2.pdf](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170646.png)\n### 国密标准安全等级\n[GMT 0008-2012 安全芯片密码检测准则.pdf](https://raw.githubusercontent.com/guanzhi/GM-Standards/master/GMT%E6%AD%A3%E5%BC%8F%E6%A0%87%E5%87%86/GMT%200008-2012%20%E5%AE%89%E5%85%A8%E8%8A%AF%E7%89%87%E5%AF%86%E7%A0%81%E6%A3%80%E6%B5%8B%E5%87%86%E5%88%99.pdf)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220630170647.png)\n\n# 场景示例\n\nADS控制器状态采用类似机可以采用介于FIP140-2中2或3等级的加密模块HSM保证安全性，在AutoSAR中涉及到的资源及网络安全链路concept如下：\n\n![image-20220701152832558](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220701152834.png)\n\n![image-20220701152730165](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220701152744.png)\n\n> ASIL 来自于 ISO26262 标准, ASIL D 为最高的安全等级 https://zh.wikipedia.org/zh-hans/ISO_26262\n>\n> CAL 安全等级来自于 ISO/SAE 21434 标准, 网络安全保证级别（CAL） Cybersecurity Assurance Level  ，类似于 ISO 26262 中的 ASIL，用来控制网路安全措施的工作。和 ISO 26262 的ASIL不同，ISO/SAE 21434不建议针对CAL有对应措施。CAL主要是产品开发人员评估用的定性分类  https://zh.wikipedia.org/zh-hans/ISO/SAE_21434\n\nApp1，App2及App3是ASILD的，同时均需要被网络安全机制保护。\n\n因制动踏板相关信号及HWP功能状态速度通常是10ms一次，因而用AES算法计算比较快，但ADS状态机可以是80ms FHTI，此时可以用保密性更强的RSA模型。\n\n因CSM/CryIf/Crypto Hardware称为Crypto Stack，此时从CSM的工作图，可以简要推导出如下与HSM相关的AutoSAR需求ASIL级别及CAL级别，并由此更加明确HSM的ASIL级别和等级：\n\n\n\n|                       | Context                                                      | ASIL                                                  | CAL  | HSM functionality                                            |\n| --------------------- | ------------------------------------------------------------ | ----------------------------------------------------- | ---- | ------------------------------------------------------------ |\n| RS_CRYPTO_02001       | The  Crypto Stack shall conceal symmetric keys from the users | D（旧方案，如果新方案考虑座舱对人的监控则可降低到 B） | CAL2 | D (Safety  functional)Key store  in HSM                      |\n| RS_CRYPTO_02002       | The  Crypto Stack shall conceal asymmetric private keys from the users | D（旧方案，如果新方案考虑座舱对人的监控则可降低到 B） | CAL2 | D (Safety  functional)                                       |\n| RS_CRYPTO_02109       | The  Crypto Stack shall support interfaces for a unified Machine-wide storage and  retrieval of different crypto objects | D                                                     | CAL2 | D secure  storage and retrieval of different crypto objects (e.g. keys, certificates,  digests, etc.) |\n| RS_CRYPTO_02401       | The  Crypto Stack should support a joint usage ofmultiple  back-end cryptography providers including ones with non-extractable keys | D                                                     | CAL2 | D concept  of non-extractable keys (**HSMs**/TPMs).          |\n| SRS_CryptoStack_00101 | Asynchronous Job Processing                                  | Not D，normally                                       | CAL2 | B Different time countering **Counter is must**               |\n| SRS_CryptoStack_00008 | The Crypto Stack shall allow static  configuration of keys used for cryptographic jobs | QM(D)                                                 | CAL2 | Configuration FLASH/RAM is requested                         |\n| SRS_CryptoStack_00010 | The Crypto Stack shall conceal symmetric  keys from the users of crypto services | D                                                     | CAL2 | D Keys residing in  the HSM                                  |\n| SRS_CryptoStack_00011 | The Crypto Stack shall conceal asymmetric  private keys from the users of Crypto services | D                                                     | CAL2 | D Due to keys residing in the HSM                            |\n| SRS_CryptoStack_00098 | The Crypto Driver shall provide access to  all cryptographic algorithms supported by the hardware | D                                                     | CAL2 | D Primitives which  are supported by the HSM should be accessible through the Crypto Driver. |\n\n由上述需求的要求，我们得到了该ADS控制器对HSM的特性要求：\n\n| Item              | 完整HSM | CAL  | ASIL        |                                                              |\n| ----------------- | ------- | ---- | ----------- | ------------------------------------------------------------ |\n| RAM               | x       | 2    | B(粗略估计) | SRS_CryptoStack_00008 SRS_CRYPTO_02109 SRS_CRYPTO_02001      |\n| NVM               | x       | 2    | D           | SRS_CryptoStack_00008 SRS_CryptoStack_00011 SRS_CryptoStack_00010 SRS_CRYPTO_02401 SRS_CRYPTO_02109 SRS_CRYPTO_02001 |\n| 对称加密引擎      | x       | 2    | D           | RS_CRYPTO_02002                                              |\n| 非对称加密引擎    | x       | 2    | D           | RS_CRYPTO_02002                                              |\n| 哈希引擎(生成MAC) | x       | 2    | D           | SRS_CryptoStack_00011 SRS_CryptoStack_00010                  |\n| 计数              | x       | 2    | B           | SRS_CryptoStack_00101                                        |\n| 随机数发生器      | x       | 2    | D           | RS_CRYPTO_02401                                              |\n| CPU安全防护       | x       | 2    | D           | RS_CRYPTO_02002                                              |\n| IO部件            | x       | 2    | D           | SRS_CryptoStack_00098                                        |\n\n如下是关于全套HSM上，每个子模块的ASIL级别\n\n![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-6ea78751bdfd456cb790c01af5c1ae61.png)\n","tags":["hsm"],"categories":["安全"]},{"title":"三级证书","url":"/2022/03/25/TEE/三级证书/","content":"\n## 证书和签名制作过程\n真正的签名image hash的key是最底层的⼀把key，这个key在每次签名的时候都会随机⽣成，即使是同⼀个机型不同⽇期编出来的包，这把key都不会⼀样，取⽽代之的是，这对keypair的公钥会在服务器上被attestation key签发⼀个证书，⽽attestation privatekey⼜是被rootkey签发的，形成⼀套证书链校验，这样的好处是OEM和⾼通可以灵活的控制签名的流程，⽐如ODM就不能和OEM拥有同⼀个key，但是每个机型都重新⽣成fuse⼜显得⼗分冗余和难以维护，这样的解决⽅案会显得更加灵活可以在不变更fuse的情况下，允许secureboot有多位参与者 [001](bookxnotepro://opennote/?nb={f0d472c4-48cb-46a1-b142-de6e7beec9f3}&book=209b00fe1ba72a6a1472e7231a9fce0c&page=0&x=364&y=594&id=1)\n\n服务器会调⽤openssl进⾏签名,具体的流程是,服务器上已经有了固定的rootkey和attestation key以及相应的证书,签名过程中会随机⽣成⼀把attesst key,并且使⽤attestationkey进⾏签名颁发证书,最后使⽤这把随机⽣成的attestkey对⽂件的hash进⾏签名,最后把签名以及三份证书已经签名传回客户端 [001](bookxnotepro://opennote/?nb={9d8886df-b728-405b-abe2-f5995a755697}&book=77ec177cb4de2c84885767ccb705f23c&page=0&x=367&y=898&id=1)\n\n三份证书和签名返回客户端并按照既定格式组装到未签名的⽂件中,形成签名⽂件.最后覆盖源⽂件 [001](bookxnotepro://opennote/?nb={9d8886df-b728-405b-abe2-f5995a755697}&book=77ec177cb4de2c84885767ccb705f23c&page=0&x=343&y=908&id=2)\n\n## 签名流程图\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420121123.svg)\n\n\n\n","tags":["签名"],"categories":["安全"]},{"title":"arm trustzone","url":"/2022/03/25/TEE/arm硬件安全/","content":"\n## Software virtualization\n\n\n\n​\t\t虚拟化是一种软件安全机制，其中一个高度可信的管理层，称为虚拟机管理程序，以通用处理器的特权模式运行。 管理程序将在其顶部的多个独立软件平台分开使用内存管理单元（MMU），将每个内存置于由管理程序软件控制的虚拟机内部。\n\n### 弊端\n\n​\t\t虚拟化技术提供的隔离仅限于实现管理程序的处理器。系统中的任何其他总线上主控，如DMA引擎和GPU，都可以绕过hypervisor提供的保护，因此也必须由hypervisor管理，以执行所需的安全策略。这很难在不损害系统性能的情况下实现; 在不降低图形性能的情况下验证可编程GPU的复杂输入超出了大多数虚拟化解决方案的范围。\n\n​\t\t虚拟化忽略与硬件攻击相关的安全问题，例如使用调试或测试基础设施的威胁。为了保护虚拟系统免受这种攻击，需要完全禁用调试和测试可见性，这使得软件开发和缺陷诊断非常困难。\n\n## TrustZone技术对资源隔离的实现\n\n\n\n​\t\tARM处理器核的虚拟化和资源隔离是TrustZone实现安全需求的根本。支持TrustZone的处理器核具有虚拟化，也即将一个物理核分成安全状态和非安全状态。当处理器处于非安全状态时，只能访问属于非安全的外设和内存，而不能访问安全的资源；当处理器处于安全态时，处理器既可以访问安全资源，也可以访问非安全的资源，只有当处理器核为安全世界状态时才可能发出PROT的安全访问信号。\n\n\n\n### 中断源的隔离\n\n​\t\t在原来的ARM芯片中，使用VIC来对外部中断源进行控制和管理，支持TrustZone后，ARM提出了`TZIC`组件，在芯片设计时，该组件作为一级中断源控制器，控制所有的外部中断源，通过编程TZIC组件的相关寄存器来设定哪个中断源为安全中断源`FIQ`，而未被设定的中断源将会被传递给VIC进行处理。一般情况下VIC会将接收到的中断源设定成普通中断请求（Interrupt Request，IRQ），如果在VIC中将接收到的中断源设定成FIQ，则该中断源会被反馈给TZIC组件，TZIC组件会将安全中断源送到安全世界状态中进行处理。\n\n\n\n### 片上RAM和片上ROM的隔离\n\n​\t\t芯片内部存在小容量的RAM或者ROM，以供芯片上电时运行芯片ROM或者存放芯片自身相关的数据。TrustZone架构对该部分也进行了隔离操作。隔离操作通过使用TZMA和TZPC组件来实现。\n​\t\tTZMA用来将片上RAM或者ROM划分成安全区域和非安全区域，安全区域的大小则由接入的TZPCR0SIZE信号来决定。而TZPCR0SIZE的值可以通过编程TZPC组件中的TZPCR0SIZE寄存器来实现。\n​\t\t当处理器核访问片上RAM或者ROM时，TZMA会判定访问请求的PROT信号是安全操作还是非安全操作，如果处理器发出的请求为非安全请求而该请求又尝试去访问安全区域时，TZMA就会认为该请求为非法请求。这样就能实现片上RAM和ROM的隔离，达到非安全态的处理器核无法访问片上安全区域的RAM和ROM。\n\n\n\n### 片外DRAM的隔离\n\n​\t\t一个完整的系统必然会有片外RAM，对片外RAM的隔离是通过TZASC组件实现的，ARM本身的DMC可以将DRAM分割成不同的区域，这些区域是没有安全和非安全分类。将DMC与TZASC相连后再挂到总线上，通过对TZASC组件进行编程可以将DRAM划分成安全区域和非安全区域。当主设备访问DRAM时，除需要提供物理地址之外，还会发送PROT信号。TZASC组件首先会判定主设备需要访问的DARM地址是属于安全区域还是非安全区域，然后再结合接收到的PROT信号来判定该次访问是否有效。如果PROT信号为非安全访问操作，且访问的DRAM地址属于安全区域，则TZASC就不会响应这次访问操作，这样就能实现DRAM中安全区域和非安全区域的隔离。\n\n\n\n### 外围设备的隔离\n\n​\t\t其他外围设备都会挂载到APB总线上，然后通过AXI-to-APB桥连接到AXI总线上，AXI-to-APB结合TZPC组件的TZPCDECROT的值及访问请求的PROT信号来判定该访问是否有效。当处理器需要访问外围设备时，会将地址和PROT信号发送到AXI总线上。\n​\t\tAXI-to-APB桥会对接收到的请求进行解析，获取需要访问的所需外围设备，然后通过查询TZPCDECROT的值来判断外设的安全类型，再根据PROT信号就能判定该请求的安全类型。如果该请求是非安全请求，但需要访问的外围设备属于安全设备，则AXI-to-APB会判定该访问无效。\n通过对TZPC中的TZPCDECROT寄存器进行编程能够设置外设的安全类型，从而做到外设在硬件层面的隔离。\n\n\n\n### 小结\n\n​\t\tTrustZone对系统实现了硬件隔离，将系统资源划分成安全和非安全两种类型，同时在系统总线上增加安全读写信号位，通过读取安全读写信号位电平来确定当前处理器的工作状态，从而判断是否具有该资源的访问权限。因此，TrustZone从硬件级别实现了对系统资源的保护。\n\n\n\n## ARM安全扩展组件\n\n\n\n​\t\tTrustZone技术之所以能提高系统的安全性，是因为对外部资源和内存资源的硬件隔离。这些硬件隔离包括中断隔离、片上RAM和ROM的隔离、片外RAM和ROM的隔离、外围设备的硬件隔离、外部RAM和ROM的隔离等。实现硬件层面的各种隔离，需要对整个系统的硬件和处理器核做出相应的扩展。这些扩展包括：\n\n- 对处理器核的虚拟化，也就是将AMR处理器的运行状态分为安全态和非安全态。\n- 对总线的扩展，增加安全位读写信号线。\n- 对内存管理单元（Memory Management Unit，`MMU`）的扩展，增加页表的安全位。\n- 对缓存（`Cache`）的扩展，增加安全位。\n- 对其他外围组件进行了相应的扩展，提供安全操作权限控制和安全操作信号。\n\n\n\n### AXI总线上安全状态位的扩展\n\n​\t\t为了支持TrustZone技术，控制处理器在不同状态下对硬件资源访问的权限，ARM对先进可扩展接口（Advanced eXtensible Interface，`AXI`）系统总线进行了扩展。在原有AXI总线基础上对每一个读写信道增加了一个额外的控制信号位，用来表示当前的读写操作是安全操作还是非安全操作，该信号位称为安全状态位（NS bit）或者非安全状态位（Non-Secure bit）。\n·`AWPROT`[1]：总线写事务——低位表示安全写事务操作，高位表示非安全写事务操作。\n·`ARPROT`[1]：总线读事务——低位表示安全读事务操作，高位表示非安全读事务操作。\n​\t\t当主设备通过总线发起读写操作时，从设备或者外围资源同时也需要将对应的PROT控制信号发送到总线上。总线或者从设备的解码逻辑必须能够解析该PROT控制信号，以便保证安全设备在非安全态下不被非法访问。所有的非安全主设备必须将安全状态位置成高位，这样就能够保证非安全主设备无法访问到安全从设备。如果一个非安全主设备试图访问一个安全从设备，将会在总线或者从设备上触发一个错误操作，至于该错误如何处理就依赖于从设备的处理逻辑和总线的配置。通常这种非法操作最终将产生一个SLVERR（slave error）或者DECERR（decode error）\n\n\n\n### AXI-to-APB桥的作用\n\n​\t\tTrustZone同样能够保护外围设备的安全，例如中断控制、时钟、I/O设备，因此Trust-Zone架构还能用来解决更加广泛的安全问题。比如一个安全中断控制器和安全时钟允许一个非中断的安全任务来监控系统，能够为DRM提供可靠的时钟，能够为用户提供一个安全的输入设备从而保证用户密码数据不会被恶意软件窃取。\nAMBA3规范包含了一个低门数、低带宽的外设总线，被称作外设总线（Advanced Peripheral Bus，`APB`），APB通过AXI-to-APB桥连接到系统总线上。而APB总线并不具有安全状态位，为实现APB外设与TrustZone技术相兼容，APB-to-AXI桥将负责管理APB总线上设备的安全。APB-to-AXI桥会拒绝不匹配的安全事务设置，并且不会将该事务请求发送给外设。\n\n\n\n### TrustZone地址空间控制组件\n\n​\t\tTrustZone地址空间控制组件（TrustZone Address Space Controller，`TZASC`）是AXI总线上的一个主设备，TZASC能够将从设备全部的地址空间分割成一系列的不同地址范围。在安全状态下，通过编程TZASC能够将这一系列分割后的地址区域设定成安全空间或者是非安全空间。被配置成安全属性的区域将会拒绝非安全的访问请求。\n​\t\t使用TZASC主要是将一个AXI从设备分割成几个安全设备，如dram。ARM的动态内存控制器（Dynamic Memory Controller，`DMC`）并不支持安全和非安全分区的功能。如果将DMC接到TZASC上，就能实现DRAM支持安全区域和非安全区域访问的功能。\n\n> 需要注意的是，TZASC组件只支持存储映射设备对安全和非安全区域的划分与扩展，但不支持对块设备（如EMMC、NAND flash等）的安全和非安全区域的划分与扩展\n\n\n\n![image-20211118203616634](images/image-20211118203616634.png)\n\n\n\n### TrustZone内存适配器组件\n\n​\t\tTrustZone内存适配器组件（TrustZone Memory Adapter，`TZMA`）允许对片上静态内存（on-SoC Static Memory）或者片上ROM进行安全区域和非安全区域的划分。TZMA支持最大2MB空间的片上静态RAM的划分，可以将2MB空间划分成两个部分，高地址部分为非安全区域，低地址部分为安全区域，两个区域必须按照4KB进行对齐。分区的具体大小通过TZMA的输入信号R0SIZE来控制，该信号来自TZPC的输出信号`TZPCR0SIZE`。即通过编程TZPC可以动态地配置片上静态RAM或者ROM的大小\n\n\n\n![image-20211118203714898](images/image-20211118203714898.png)\n\n### TrustZone保护控制器组件\n\n​\t\tTrustZone保护控制器组件（TrustZone Protection Controller，`TZPC`）是用来设定TZPCDECPORT信号和TZPCR0SIZE等相关控制信号的。\n\n- `TZPCDECPORT`信号用来告知APB-to-AXI对应的外设是安全设备还是非安全设备, TZPC包含三组通用寄存器TZPCDECPROT[2：0]，每组通用寄存器可以产生8种TZPCDECPROT信号，也就是TZPC最多可以将24个外设设定成安全外设。\n- `TZPCR0SIZE`信号用来控制TZMA对片上RAM或片上ROM安全区域大小的划分。\n\n\n![image-20211118203823912](images/image-20211118203823912.png)\n\n​\t\t通过修改TZPC的寄存器配置的值可实现用户对资源的特定配置。\n\n![image-20211118203843493](images/image-20211118203843493.png)\n\n\n\n### TrustZone中断控制器组件\n\n​\t\t在支持TrustZone的SoC上，ARM添加了TrustZone中断控制器（TrustZone Interrupt Controller，TZIC）. TZIC的作用是让处理器处于非安全态时无法捕获到安全中断。TZIC是第一级中断控制器，所有的中断源都需要接到`TZIC`上。TZIC根据配置来判定产生的中断类型，然后决定是将该中断信号先发送到非安全的向量中断控制器（Vector Interrupt Controller，VIC）后以nIRQ信号发送到处理器，还是以nTZICFIQ信号直接发送到处理器。\n\n​\t\t通过对`TZIC`的相关寄存器进行编程，可对TZIC进行配置并设定每个接入到TZIC的中断源的中断类型。TZIC具有众多寄存器，细节说明可以参考相关ARM的文档。在TZIC中用来设置中断源类型的寄存器为TZICIntSelect，如果TZICIntSelect中的某一位被设置成1，则该相应的中断源请求会被设置成快速中断请求（Fast Interrupt Request，`FIQ`）。如果某一位被设置成0，则该中断源的中断请求会被交给VIC进行处理。如果VIC的IntSelect将获取到的中断源设置成FIQ，那么该中断源会被再次反馈给TZIC进行处理。\n\n### Cache和MMU的扩展\n\n​\t\t在支持TrustZone的SoC上，会对MMU进行虚拟化，使得寄存器TTBR0、TTBR1、TTBCR在安全状态和非安全状态下是相互隔离的，因此两种状态下的虚拟地址转换表是独立的。\n​\t\t存放在MMU中的每一条页表描述符都会包含一个安全状态位，用以表示被映射的内存是属于安全内存还是非安全内存。虚拟化的MMU共享转换监测缓冲区（Translation Lookaside Buffer，`TLB`），同样TLB中的每一项也会打上安全状态位标记，只不过该标记是用来表示该条转换是正常世界状态转化的还是安全世界状态转化的。\n​\t\tCache也同样进行了扩展，Cache中的每一项都会按照安全状态和非安全状态打上对应的标签，在不同的状态下，处理器只能使用对应状态下的Cache。\n\n\n\n### DMA 扩展\n\n​\t\tPrimeCell DMA Controller是一个多通道的AXI引擎，通过微编码的工作描述来实现复杂结构的传输。DMA支持并发的安全通道和非安全通道，每个通道都有独立的中断事件，并由专用的APB接口控制。一个非安全事务试图编写一个到安全内存的DMA传输或者从安全内存传入数据的请求，都将导致DMA传输失败。\n\n\n\n## 案例 - 指纹解锁\n\n​\t\t指纹的一切操作，包括指纹录入，存储，对比验证，都在TEE那个黑盒子中完成. 指纹的驱动也是在TEE中, CPU与指纹芯片的数据通信也在TEE中完成.\n\n​\t\tAndroid(REE) 只能下发command 给TEE, 如采集指纹/存储指纹/验证指纹的命令. TEE会告诉Android(REE) 命令执行的结果.\n\n​\t\tTEE下的指纹模板是采用一种叫SFS(Secure File System)的方式经过加密后存储在Android的/data/目录，TA可以访问，Android下的app也可以访问，只不过数据文件加密了而已。指纹模板采用AES256对称加密存储的，就算指纹模板遗失或者窃取，没有密钥也无法破解。密钥是大致是结合每台机器的CPU_ID + 每个TA的uuid + CPU efuse里的HUK经过一系列密钥分散算法生成。HUK就是hardware unique key，这个key在手机生产时烧入CPU的efuse中熔断，无法再更改，且只能在TEE下读取，非安全世界读取不到这个值。这样一来保证了一机一密，而且密钥无法被猜出。\n\n\n\n![image-20211119173944821](images/image-20211119173944821.png)\n\n![image-20211122113308570](images/image-20211122113308570.png)\n\n\n\n![1.png](images/1574916576_5ddf51e01bbe6.png)\n\n![image-20211123161017793](images/image-20211123161017793.png)\n\n\n\n![image-20211119174215691](images/image-20211119174215691.jpg)\n\n## 安全引导\n\n​\t\t安全引导可用于保证系统的完整性，防止系统中重要镜像文件被破坏或替换。一般情况下，安全引导需要保护系统的BootLoader镜像文件、TEE镜像文件、Linux内核镜像文件、Recovery镜像文件以及在ARMv8中使用的ATF镜像文件。将TEE镜像文件的加载操作加入安全引导功能中可阻止黑客通过替换TEE镜像文件的方式来窃取被TEE保护的重要资料。\n\n​\t\t当前使用ARM芯片的系统中大部分使能了安全引导功能，该功能对于用户的最直接感受就是，当用户非法刷入其他厂商的ROM后手机无法正常启动，这是因为非法刷机将导致系统中的重要镜像文件被替换，系统在启动过程中对镜像文件的电子验签失败，如果BootLoader验证失败，则系统在进入BootLoader阶段之前就会挂死。\n\n​\t\t安全引导功能的原理就是采用链式验签的方式启动系统，也就是在系统启动过程中，在加载下一个阶段的镜像之前都会对需要被加载的镜像文件进行电子验签，只有验签操作通过后，该镜像才能被加载到内存中，然后系统才会跳转到下一个阶段继续执行，整个验签链中的任何一环验签失败都会导致系统挂死，系统启动过程中的第一级验签操作是由ChipRom来完成的。只要芯片一出厂，用户就无法修改固化在芯片中的这部分代码，因此无法通过修改第一级验签结果来关闭安全引导功能。而且验签操作使用的RSA公钥或者哈希值将会被保存在OTP/efuse中，该区域中的数据一般只有ChipRom和TEE能够读取且无法被修改。root RSA公钥或其哈希值将会在产品出厂之前被写入到OTP/efuse中，而且不同厂商使用的密钥会不一样。\n​\t\t大多数芯片厂商是将签名信息与需要被验签的镜像文件打包在一起，而RSA公钥则会被打包到执行验证操作的镜像文件中。\n​\t\t不同厂商可能会对镜像文件进行加密操作，使保存在设备中的镜像文件都是以密文的形式存在。在启动过程中，首先会验证密文镜像文件的合法性然后再进行解密镜像文件的操作，这些都完成后才会将明文的镜像文件加载到内存中然后再执行跳转操作。\n\n\n\n![image-20211122113549821](images/image-20211122113549821.png)","tags":["arm"],"categories":["安全"]},{"title":"linux 中断相关","url":"/2022/03/25/hxd_new/kernel中断相关/","content":"\n> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [kernel.meizu.com](http://kernel.meizu.com/linux-interrupt.html)\n\n> 在面试的时候我们常常被问及一个问题：几种中断下半部机制 softirq、tasklet、workqueue 有什么区别？Linux 为什么要设计这几种机制？真正能够回答清楚的人还是少数的。\n\n在面试的时候我们常常被问及一个问题：几种中断下半部机制 softirq、tasklet、workqueue 有什么区别？Linux 为什么要设计这几种机制？真正能够回答清楚的人还是少数的。下面我们就详细分析一下这其中的区别。\n\n> 本文的代码分析基于 Linux kernel 3.18.22 和 arm64 架构，最好的学习方法还是 “RTFSC”\n\n1. Linux 中断\n-----------\n\narm64 和其他所有 CPU 架构的中断处理流程都是一样：正常执行流程被打断进入中断服务程序，保护现场、处理中断、恢复现场：\n\n![](http://kernel.meizu.com/images/posts/2016/09/int_handler.png)     中断处理 [1](#fn:ARMPG)\n\n在整个中断处理过程中，arm64 的 CPU 全局中断是自动 disable 的 (PSTATE 寄存器中的 interrupt bit 被 masks)。如果用户想支持 interrupt nested，需要自己在中断服务程序中使能中断。Linux 现在是不使用中断嵌套的。\n\n![](http://kernel.meizu.com/images/posts/2016/09/int_nested_handler.png) \" 中断嵌套处理 \" 中断嵌套处理 [1](#fn:ARMPG)\n\n### 1.1 CPU 中断打开 / 关闭\n\narm64 关闭和打开本地 CPU 的全局中断的方法，是操作 SPSR(Saved Process Status Register) 寄存器 IRQ mask bit。\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_arm64_spsr.png)](http://kernel.meizu.com/images/posts/2016/09/int_arm64_spsr.png \"Arm64 SPSR\")Arm64 SPSR[1](#fn:ARMPG)\n\nLinux 中 arm64 关闭和打开本地 CPU 中断的函数实现。\n\n*   arch/arm64/include/asm/irqflags.h:\n*   `local_irq_disable()` -> `raw_local_irq_disable()` -> `arch_local_irq_disable()`\n*   `local_irq_enable()` -> `raw_local_irq_enable()` -> `arch_local_irq_enable()`\n\n```c\nstatic inline void arch_local_irq_enable(void)\n{\n\tasm volatile(\n\t\t// (1) 清除 DAIF 中的 bit2 I 标志位，打开中断\n\t\t\"msr\tdaifclr, #2\t\t// arch_local_irq_enable\"\n\t\t:\n\t\t:\n\t\t: \"memory\");\n}\n\nstatic inline void arch_local_irq_disable(void)\n{\n\tasm volatile(\n\t\t// (2) 设置 DAIF 中的 bit2 I 标志位，关闭中断\n\t\t\"msr\tdaifset, #2\t\t// arch_local_irq_disable\"\n\t\t:\n\t\t:\n\t\t: \"memory\");\n}\n\nstatic inline unsigned long arch_local_irq_save(void)\n{\n\tunsigned long flags;\n\tasm volatile(\n\t\t// (3) 备份 DAIF 标志\n\t\t\"mrs\t%0, daif\t\t// arch_local_irq_save\\n\"\n\t\t\"msr\tdaifset, #2\"\n\t\t: \"=r\" (flags)\n\t\t:\n\t\t: \"memory\");\n\treturn flags;\n}\n\nstatic inline unsigned long arch_local_save_flags(void)\n{\n\tunsigned long flags;\n\tasm volatile(\n\t\t// (4) 恢复 DAIF 标志\n\t\t\"mrs\t%0, daif\t\t// arch_local_save_flags\"\n\t\t: \"=r\" (flags)\n\t\t:\n\t\t: \"memory\");\n\treturn flags;\n}\n```\n\n### 1.2 中断控制器 GIC\n\n上面描述了 CPU 对全局中断的处理，但是还有一个工作需要有人去做：就是把外部中断、内部中断、CPU 间中断等各种中断按照优先级、亲和力、私有性等发送给多个 CPU。负责这个工作的就是中断控制器 GIC(Generic Interrupt Controller)。\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_gic400.gif)](http://kernel.meizu.com/images/posts/2016/09/int_gic400.gif \"GIC400\")GIC400[2](#fn:GICANALY)\n\n从软件角度上看，GIC 可以分成两个功能模块：[1](#fn:ARMPG)\n\n*   Distributor。负责连接系统中所有的中断源，通过寄存器可以独立的配置每个中断的属性：priority、state、security、outing information、enable status。定义哪些中断可以转发到 CPU core。\n*   CPU Interface。CPU core 用来接收中断，寄存器主要提供的功能：mask、 identify 、control states of interrupts forwarded to that core。每个 CPU core 拥有自己的 CPU interface。\n\n对 GIC 来说，中断可以分成以下几种类型：[1](#fn:ARMPG)\n\n*   SGI(Software Generated Interrupt)，Interrupt IDs 0-15。系统一般用其来实现 IPI 中断。\n*   PPI(Private Peripheral Interrupt)，Interrupt IDs16-31。私有中断，这种中断对每个 CPU 都是独立一份的，比如 per-core timer 中断。\n*   SPI(Shared Peripheral Interrupt)，Interrupt numbers 32-1020。最常用的外设中断，中断可以发给一个或者多个 CPU。\n*   LPI(Locality-specific Peripheral Interrupt)。基于 message 的中断，GICv2 和 GICv1 中不支持。\n\nGIC 从原理上理解并不难，但是如果涉及到级联等技术细节，整个初始化过程还是比较复杂。大家可以自行下载 GIC 手册：[GIC-400](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0471b/index.html)、[GIC-500](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0516e/index.html) 学习，[GIC 代码分析](http://www.wowotech.net/irq_subsystem/gic_driver.html) 也是一篇很不错的分析文章。\n\n一款 GIC 相关的操作函数都会集中到 irq_chip 数据结构中，以 GIC-400 为例，它的相关操作函数如下：\n\n*   drivers/irqchip/irq-gic.c:\n\n```c\nstatic struct irq_chip gic_chip = {\n\t.name\t\t\t= \"GIC\",\n\t.irq_mask\t\t= gic_mask_irq,\n\t.irq_unmask\t\t= gic_unmask_irq,\n\t.irq_eoi\t\t= gic_eoi_irq,\n\t.irq_set_type\t\t= gic_set_type,\n\t.irq_retrigger\t\t= gic_retrigger,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity\t= gic_set_affinity,\n#endif\n\t.irq_set_wake\t\t= gic_set_wake,\n};\n```\n\n### 1.3 Linux 中断处理流程\n\n从代码上看 Linux 中断的处理流程大概是这样的：\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_handle_flow.png)](http://kernel.meizu.com/images/posts/2016/09/int_handle_flow.png \"Linux 中断处理基本流程 \")Linux 中断处理基本流程\n\n从处理流程上看，对于 gic 的每个中断源，Linux 系统分配一个 irq_desc 数据结构与之对应。irq_desc 结构中有两个中断处理函数 `desc->handle_irq()` 和 `desc->action->handler()`，这两个函数代表中断处理的两个层级：\n\n*   `desc->handle_irq()`。第一层次的中断处理函数，这个是系统在初始化时根据中断源的特征统一分配的，不同类型的中断源的 gic 操作是不一样的，把这些通用 gic 操作提取出来就是第一层次的操作函数。具体实现包括：\n  \n    *   `handle_fasteoi_irq()`\n    *   `handle_simple_irq()`\n    *   `handle_edge_irq()`\n    *   `handle_level_irq()`\n    *   `handle_percpu_irq()`\n    *   `handle_percpu_devid_irq()`\n*   `desc->action->handler()` 第二层次的中断处理函数，由用户注册实现具体设备的驱动服务程序，都是和 GIC 操作无关的代码。同时一个中断源可以多个设备共享，所以一个 desc 可以挂载多个 action，由链表结构组织起来。\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_handler_action.png)](http://kernel.meizu.com/images/posts/2016/09/int_handler_action.png \"Linux 中断处理层级 \")Linux 中断处理层级\n\n### 1.4 中断服务注册\n\n从上一节的中断二层结构中可以看到第二层的中断处理函数 desc->action->handler 是由用户来注册的，下面我们来分析具体注册过程：\n\n*   kernel/irq/manage.c:\n*   `request_irq()` -> `request_threaded_irq()` -> `__setup_irq()`\n\n```c\nstatic inline int __must_check\nrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,\n\t    const char *name, void *dev)\n{\n\treturn request_threaded_irq(irq, handler, NULL, flags, name, dev);\n}\n| →\nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\n\t\t\t irq_handler_t thread_fn, unsigned long irqflags,\n\t\t\t const char *devname, void *dev_id)\n{\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\tint retval;\n\n\t/*\n\t * Sanity-check: shared interrupts must pass in a real dev-ID,\n\t * otherwise we'll have trouble later trying to figure out\n\t * which interrupt is which (messes up the interrupt freeing\n\t * logic etc).\n\t */\n\tif ((irqflags & IRQF_SHARED) && !dev_id)\n\t\treturn -EINVAL;\n\n\t// (1) 根据中断号找到对应的 desc 结构\n\tdesc = irq_to_desc(irq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!irq_settings_can_request(desc) ||\n\t    WARN_ON(irq_settings_is_per_cpu_devid(desc)))\n\t\treturn -EINVAL;\n\n\t// (2) 如果 action->handler 为空，那么用户是想创建一个线程化中断\n\t// 将线程化中断的 action->handler 初始化为 irq_default_primary_handler()\n\t// irq_default_primary_handler() 非常简单，只是返回一个 IRQ_WAKE_THREAD 值\n\tif (!handler) {\n\t\tif (!thread_fn)\n\t\t\treturn -EINVAL;\n\t\thandler = irq_default_primary_handler;\n\t}\n\n\t// (3) 分配新的 action 数据结构\n\taction = kzalloc(sizeof(struct irqaction), GFP_KERNEL);\n\tif (!action)\n\t\treturn -ENOMEM;\n\n\taction->handler = handler;\n\taction->thread_fn = thread_fn;\n\taction->flags = irqflags;\n\taction->name = devname;\n\taction->dev_id = dev_id;\n\n\tchip_bus_lock(desc);\n\t// (4) 将新的 action 结构安装到 desc 中\n\tretval = __setup_irq(irq, desc, action);\n\tchip_bus_sync_unlock(desc);\n\n\tif (retval)\n\t\tkfree(action);\n\n#ifdef CONFIG_DEBUG_SHIRQ_FIXME\n\tif (!retval && (irqflags & IRQF_SHARED)) {\n\t\t/*\n\t\t * It's a shared IRQ -- the driver ought to be prepared for it\n\t\t * to happen immediately, so let's make sure....\n\t\t * We disable the irq to make sure that a 'real' IRQ doesn't\n\t\t * run in parallel with our fake.\n\t\t */\n\t\tunsigned long flags;\n\n\t\tdisable_irq(irq);\n\t\tlocal_irq_save(flags);\n\n\t\thandler(irq, dev_id);\n\n\t\tlocal_irq_restore(flags);\n\t\tenable_irq(irq);\n\t}\n#endif\n\treturn retval;\n}\n|| →\nstatic int\n__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)\n{\n\tstruct irqaction *old, **old_ptr;\n\tunsigned long flags, thread_mask = 0;\n\tint ret, nested, shared = 0;\n\tcpumask_var_t mask;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->irq_data.chip == &no_irq_chip)\n\t\treturn -ENOSYS;\n\tif (!try_module_get(desc->owner))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check whether the interrupt nests into another interrupt\n\t * thread.\n\t */\n\tnested = irq_settings_is_nested_thread(desc);\n\t// (4.1) 判断中断是否是支持嵌套\n\tif (nested) {\n\t\tif (!new->thread_fn) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_mput;\n\t\t}\n\t\t/*\n\t\t * Replace the primary handler which was provided from\n\t\t * the driver for non nested interrupt handling by the\n\t\t * dummy function which warns when called.\n\t\t */\n\t\tnew->handler = irq_nested_primary_handler;\n\t} else {\n\t\t// (4.2) 判断中断是否可以被线程化\n\t\t// 如果中断没有设置 _IRQ_NOTHREAD 标志 & 强制中断线程化标志被设置 (force_irqthreads=1)\n\t\t// 强制把中断线程化：\n\t\t// new->thread_fn = new->handler;new->handler = irq_default_primary_handler;\n\t\tif (irq_settings_can_thread(desc))\n\t\t\tirq_setup_forced_threading(new);\n\t}\n\n\t/*\n\t * Create a handler thread when a thread function is supplied\n\t * and the interrupt does not nest into another interrupt\n\t * thread.\n\t */\n\t// (4.3) 如果是线程化中断，创建线程化中断对应的线程\n\tif (new->thread_fn && !nested) {\n\t\tstruct task_struct *t;\n\t\tstatic const struct sched_param param = {\n\t\t\t.sched_priority = MAX_USER_RT_PRIO/2,\n\t\t};\n\n\t\t// 创建线程\n\t\tt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq,\n\t\t\t\t   new->name);\n\t\tif (IS_ERR(t)) {\n\t\t\tret = PTR_ERR(t);\n\t\t\tgoto out_mput;\n\t\t}\n\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, ¶m);\n\n\t\t/*\n\t\t * We keep the reference to the task struct even if\n\t\t * the thread dies to avoid that the interrupt code\n\t\t * references an already freed task_struct.\n\t\t */\n\t\tget_task_struct(t);\n\t\t// 赋值给 ->thread 成员\n\t\tnew->thread = t;\n\t\t/*\n\t\t * Tell the thread to set its affinity. This is\n\t\t * important for shared interrupt handlers as we do\n\t\t * not invoke setup_affinity() for the secondary\n\t\t * handlers as everything is already set up. Even for\n\t\t * interrupts marked with IRQF_NO_BALANCE this is\n\t\t * correct as we want the thread to move to the cpu(s)\n\t\t * on which the requesting code placed the interrupt.\n\t\t */\n\t\tset_bit(IRQTF_AFFINITY, &new->thread_flags);\n\t}\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_thread;\n\t}\n\n\t/*\n\t * Drivers are often written to work w/o knowledge about the\n\t * underlying irq chip implementation, so a request for a\n\t * threaded irq without a primary hard irq context handler\n\t * requires the ONESHOT flag to be set. Some irq chips like\n\t * MSI based interrupts are per se one shot safe. Check the\n\t * chip flags, so we can avoid the unmask dance at the end of\n\t * the threaded handler for those.\n\t */\n\tif (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)\n\t\tnew->flags &= ~IRQF_ONESHOT;\n\n\t/*\n\t * The following block of code has to be executed atomically\n\t */\n\t// (4.4) 找到最后一个 action 结构\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_ptr = &desc->action;\n\told = *old_ptr;\n\tif (old) {\n\t\t/*\n\t\t * Can't share interrupts unless both agree to and are\n\t\t * the same type (level, edge, polarity). So both flag\n\t\t * fields must have IRQF_SHARED set and the bits which\n\t\t * set the trigger type must match. Also all must\n\t\t * agree on ONESHOT.\n\t\t */\n\t\tif (!((old->flags & new->flags) & IRQF_SHARED) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_TRIGGER_MASK) ||\n\t\t    ((old->flags ^ new->flags) & IRQF_ONESHOT))\n\t\t\tgoto mismatch;\n\n\t\t/* All handlers must agree on per-cpuness */\n\t\tif ((old->flags & IRQF_PERCPU) !=\n\t\t    (new->flags & IRQF_PERCPU))\n\t\t\tgoto mismatch;\n\n\t\t/* add new interrupt at end of irq queue */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Or all existing action->thread_mask bits,\n\t\t\t * so we can find the next zero bit for this\n\t\t\t * new action.\n\t\t\t */\n\t\t\tthread_mask |= old->thread_mask;\n\t\t\told_ptr = &old->next;\n\t\t\told = *old_ptr;\n\t\t} while (old);\n\t\t// 如果有多个 action，共享标志设为 1\n\t\tshared = 1;\n\t}\n\n\t/*\n\t * Setup the thread mask for this irqaction for ONESHOT. For\n\t * !ONESHOT irqs the thread mask is 0 so we can avoid a\n\t * conditional in irq_wake_thread().\n\t */\n\tif (new->flags & IRQF_ONESHOT) {\n\t\t/*\n\t\t * Unlikely to have 32 resp 64 irqs sharing one line,\n\t\t * but who knows.\n\t\t */\n\t\tif (thread_mask == ~0UL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_mask;\n\t\t}\n\t\t/*\n\t\t * The thread_mask for the action is or'ed to\n\t\t * desc->thread_active to indicate that the\n\t\t * IRQF_ONESHOT thread handler has been woken, but not\n\t\t * yet finished. The bit is cleared when a thread\n\t\t * completes. When all threads of a shared interrupt\n\t\t * line have completed desc->threads_active becomes\n\t\t * zero and the interrupt line is unmasked. See\n\t\t * handle.c:irq_wake_thread() for further information.\n\t\t *\n\t\t * If no thread is woken by primary (hard irq context)\n\t\t * interrupt handlers, then desc->threads_active is\n\t\t * also checked for zero to unmask the irq line in the\n\t\t * affected hard irq flow handlers\n\t\t * (handle_[fasteoi|level]_irq).\n\t\t *\n\t\t * The new action gets the first zero bit of\n\t\t * thread_mask assigned. See the loop above which or's\n\t\t * all existing action->thread_mask bits.\n\t\t */\n\t\tnew->thread_mask = 1 << ffz(thread_mask);\n\n\t} else if (new->handler == irq_default_primary_handler &&\n\t\t   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {\n\t\t/*\n\t\t * The interrupt was requested with handler = NULL, so\n\t\t * we use the default primary handler for it. But it\n\t\t * does not have the oneshot flag set. In combination\n\t\t * with level interrupts this is deadly, because the\n\t\t * default primary handler just wakes the thread, then\n\t\t * the irq lines is reenabled, but the device still\n\t\t * has the level irq asserted. Rinse and repeat....\n\t\t *\n\t\t * While this works for edge type interrupts, we play\n\t\t * it safe and reject unconditionally because we can't\n\t\t * say for sure which type this interrupt really\n\t\t * has. The type flags are unreliable as the\n\t\t * underlying chip implementation can override them.\n\t\t */\n\t\tpr_err(\"Threaded irq requested with handler=NULL and !ONESHOT for irq %d\\n\",\n\t\t       irq);\n\t\tret = -EINVAL;\n\t\tgoto out_mask;\n\t}\n\n\t// (4.5) 如果是第一个 action，做一些初始化工作\n\tif (!shared) {\n\t\tret = irq_request_resources(desc);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to request resources for %s (irq %d) on irqchip %s\\n\",\n\t\t\t       new->name, irq, desc->irq_data.chip->name);\n\t\t\tgoto out_mask;\n\t\t}\n\n\t\tinit_waitqueue_head(&desc->wait_for_threads);\n\n\t\t/* Setup the type (level, edge polarity) if configured: */\n\t\tif (new->flags & IRQF_TRIGGER_MASK) {\n\t\t\tret = __irq_set_trigger(desc, irq,\n\t\t\t\t\tnew->flags & IRQF_TRIGGER_MASK);\n\n\t\t\tif (ret)\n\t\t\t\tgoto out_mask;\n\t\t}\n\n\t\tdesc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \\\n\t\t\t\t  IRQS_ONESHOT | IRQS_WAITING);\n\t\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\n\t\tif (new->flags & IRQF_PERCPU) {\n\t\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\t\t\tirq_settings_set_per_cpu(desc);\n\t\t}\n\n\t\tif (new->flags & IRQF_ONESHOT)\n\t\t\tdesc->istate |= IRQS_ONESHOT;\n\n\t\tif (irq_settings_can_autoenable(desc))\n\t\t\tirq_startup(desc, true);\n\t\telse\n\t\t\t/* Undo nested disables: */\n\t\t\tdesc->depth = 1;\n\n\t\t/* Exclude IRQ from balancing if requested */\n\t\tif (new->flags & IRQF_NOBALANCING) {\n\t\t\tirq_settings_set_no_balancing(desc);\n\t\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\t\t}\n\n\t\t// 设置中断亲和力\n\t\t/* Set default affinity mask once everything is setup */\n\t\tsetup_affinity(irq, desc, mask);\n\t} else if (new->flags & IRQF_TRIGGER_MASK) {\n\t\tunsigned int nmsk = new->flags & IRQF_TRIGGER_MASK;\n\t\tunsigned int omsk = irq_settings_get_trigger_mask(desc);\n\n\t\tif (nmsk != omsk)\n\t\t\t/* hope the handler works with current  trigger mode */\n\t\t\tpr_warning(\"irq %d uses trigger mode %u; requested %u\\n\",\n\t\t\t\t   irq, nmsk, omsk);\n\t}\n\n\t// (4.6) 将新的 action 插入到 desc 链表中\n\tnew->irq = irq;\n\t*old_ptr = new;\n\n\tirq_pm_install_action(desc, new);\n\n\t/* Reset broken irq detection when installing new handler */\n\tdesc->irq_count = 0;\n\tdesc->irqs_unhandled = 0;\n\n\t/*\n\t * Check whether we disabled the irq via the spurious handler\n\t * before. Reenable it and give it another chance.\n\t */\n\t// (4.7) 如果中断之前被虚假 disable 了，重新 enable 中断\n\tif (shared && (desc->istate & IRQS_SPURIOUS_DISABLED)) {\n\t\tdesc->istate &= ~IRQS_SPURIOUS_DISABLED;\n\t\t__enable_irq(desc, irq);\n\t}\n\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t/*\n\t * Strictly no need to wake it up, but hung_task complains\n\t * when no hard interrupt wakes the thread up.\n\t */\n\t// (4.8) 唤醒线程化中断对应的线程\n\tif (new->thread)\n\t\twake_up_process(new->thread);\n\n\tregister_irq_proc(irq, desc);\n\tnew->dir = NULL;\n\tregister_handler_proc(irq, new);\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n\nmismatch:\n\tif (!(new->flags & IRQF_PROBE_SHARED)) {\n\t\tpr_err(\"Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\",\n\t\t       irq, new->flags, new->name, old->flags, old->name);\n#ifdef CONFIG_DEBUG_SHIRQ\n\t\tdump_stack();\n#endif\n\t}\n\tret = -EBUSY;\n\nout_mask:\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\tfree_cpumask_var(mask);\n\nout_thread:\n\tif (new->thread) {\n\t\tstruct task_struct *t = new->thread;\n\n\t\tnew->thread = NULL;\n\t\tkthread_stop(t);\n\t\tput_task_struct(t);\n\t}\nout_mput:\n\tmodule_put(desc->owner);\n\treturn ret;\n}\n```\n\n### 1.5 中断线程化\n\n从上一节可以看到，使用 `request_irq()` 注册的是传统中断，而直接使用 `request_threaded_irq()` 注册的是线程化中断。线程化中断的主要目的是把中断上下文的任务迁移到线程中，减少系统关中断的时间，增强系统的实时性。\n\n中断对应的线程命名规则为：\n\n```c\nt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq, new->name);\n```\n\n我们通过 ps 命令查看系统中的中断线程，注意这些线程是实时线程 SCHED_FIFO：\n\n```shell\nroot@:/ # ps | grep \"irq/\"\nroot      171   2     0      0     irq_thread 0000000000 S irq/389-charger\nroot      239   2     0      0     irq_thread 0000000000 S irq/296-PS_int-\nroot      247   2     0      0     irq_thread 0000000000 S irq/297-1124000\nroot      1415  2     0      0     irq_thread 0000000000 S irq/293-goodix_\nroot@a0255:/ #\n```\n\n线程化中断的创建和处理任务流程如下：\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_thread_irq.png)](http://kernel.meizu.com/images/posts/2016/09/int_thread_irq.png \"Linux 线程化中断 \")Linux 线程化中断\n\n线程和 action 是一一对应的，即用户注册一个中断处理程序对应一个中断线程。\n\n### 1.6 外设中断打开 / 关闭\n\n前面的章节讲述了本地 CPU 全局中断的 enable/disable。如果要操作单个中断源的 enable/disable，使用 `enable_irq()`/`disable_irq()` 函数。最后调用主要是 GIC chip 相关的函数：\n\n*   kernel/irq/manage.c:\n*   `enable_irq()` -> `__enable_irq()` -> `irq_enable()`\n\n```c\nvoid enable_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\tif (WARN(!desc->irq_data.chip,\n\t\t KERN_ERR \"enable_irq before setup/request_irq: irq %u\\n\", irq))\n\t\tgoto out;\n\n\t__enable_irq(desc, irq);\nout:\n\tirq_put_desc_busunlock(desc, flags);\n}\n| →\nvoid __enable_irq(struct irq_desc *desc, unsigned int irq)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\", irq);\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_enable(desc);\n\t\tcheck_irq_resend(desc, irq);\n\t\t/* fall-through */\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}\n|| →\nvoid irq_enable(struct irq_desc *desc)\n{\n\t// 操作 GIC chip 对应的函数\n\tirq_state_clr_disabled(desc);\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tirq_state_clr_masked(desc);\n}\n```\n\n*   kernel/irq/manage.c:\n*   `enable_irq()` -> `__enable_irq()` -> `irq_enable()`\n\n```c\nvoid disable_irq(unsigned int irq)\n{\n\tif (!__disable_irq_nosync(irq))\n\t\tsynchronize_irq(irq);\n}\n| →\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc, irq);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}\n|| →\nvoid __disable_irq(struct irq_desc *desc, unsigned int irq)\n{\n\tif (!desc->depth++)\n\t\tirq_disable(desc);\n}\n||| →\nvoid irq_disable(struct irq_desc *desc)\n{\n\t// 操作 GIC chip 对应的函数\n\tirq_state_set_disabled(desc);\n\tif (desc->irq_data.chip->irq_disable) {\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t}\n}\n\n| →\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\t// 如果是线程化中断，需要等到线程执行完成\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}\n```\n\n### 1.7 中断亲和力\n\n同样基于 GIC chip 提供的能力，我们能配置中断源对 CPU 的亲和力。\n\n*   kernel/irq/manage.c:\n*   `enable_irq()` -> `__enable_irq()` -> `irq_enable()`\n\n```c\nstatic inline int\nirq_set_affinity(unsigned int irq, const struct cpumask *cpumask)\n{\n\treturn __irq_set_affinity(irq, cpumask, false);\n}\n| →\nint __irq_set_affinity(unsigned int irq, const struct cpumask *mask, bool force)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}\n|| →\nint irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,\n\t\t\t    bool force)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tint ret = 0;\n\n\tif (!chip || !chip->irq_set_affinity)\n\t\treturn -EINVAL;\n\n\tif (irq_can_move_pcntxt(data)) {\n\t\tret = irq_do_set_affinity(data, mask, force);\n\t} else {\n\t\tirqd_set_move_pending(data);\n\t\tirq_copy_pending(desc, mask);\n\t}\n\n\tif (desc->affinity_notify) {\n\t\tkref_get(&desc->affinity_notify->kref);\n\t\tschedule_work(&desc->affinity_notify->work);\n\t}\n\tirqd_set(data, IRQD_AFFINITY_SET);\n\n\treturn ret;\n}\n||| →\nint irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t\tbool force)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tint ret;\n\n\t// 操作 GIC chip 对应的函数\n\tret = chip->irq_set_affinity(data, mask, force);\n\tswitch (ret) {\n\tcase IRQ_SET_MASK_OK:\n\tcase IRQ_SET_MASK_OK_DONE:\n#ifdef CONFIG_MTK_IRQ_NEW_DESIGN\n\t\tupdate_affinity_settings(desc, mask, true);\n#else\n\t\tcpumask_copy(data->affinity, mask);\n#endif\n\tcase IRQ_SET_MASK_OK_NOCOPY:\n\t\tirq_set_thread_affinity(desc);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n```\n\n2. Linux 中断下半部\n--------------\n\n接下来就是大名鼎鼎的中断下半部了，包括：softirq、tasklet、workqueue。中断下半部的主要目的就是减少系统关中断的时间，把关键代码放在中断中做，大部分处理代码放到不用关中断的空间去做。\n\n上面有最激进的方法中断线程化，但是大部分时候还是需要用到中断上、下半部的方法。\n\nworkqueue 在另外文章中已经有详细解析，本处只解析 softirq、tasklet。\n\n### 2.1 preempt_count\n\n```c\nstatic __always_inline int preempt_count(void)\n{\n\treturn current_thread_info()->preempt_count;\t/* 0 => preemptable, <0 => bug */\n}\n```\n\n开始之前先了解一下 preempt_count 这个背景知识，preempt_count 是 thread_info 结构中的一个字段，用来表示当前进程能否被抢占。\n\n所谓的抢占：是指在进程在内核空间运行，如果主动不释放 CPU，在时间片用完或者高优先级任务就绪的情况下，会被强行剥夺掉 CPU 的使用权。\n\n但是进程可能在做一些关键操作，不能被抢占，被抢占后系统会出错。所以 Linux 设计了 preempt_count 字段，=0 可以被抢占，>0 不能被抢占。\n\n进程在中断返回内核态时，做是否可抢占的检查：\n\n*   arch/arm64/kernel/entry.s:\n*   `el1_irq()` -> `__enable_irq()` -> `irq_enable()`\n\n```c\n\t.align\t6\nel1_irq:\n\tkernel_entry 1\n\tenable_dbg\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tbl\ttrace_hardirqs_off\n#endif\n#ifdef CONFIG_MTPROF\n\tbl  MT_trace_hardirqs_off\n#endif\n\tirq_handler\n\n#ifdef CONFIG_PREEMPT\n\tget_thread_info tsk\n\tldr\tw24, [tsk, #TI_PREEMPT]\t\t// get preempt count\n\t// (1) 如果 preempt_count!=0，不进行可抢占判断\n\tcbnz\tw24, 1f\t\t\t\t// preempt count != 0\n\tldr\tx0, [tsk, #TI_FLAGS]\t\t// get flags\n\t// (2) 如果 preempt_count==0 & TIF_NEED_RESCHED 被置位\n\t// 进行调度\n\ttbz\tx0, #TIF_NEED_RESCHED, 1f\t// needs rescheduling?\n\tbl\tel1_preempt\n1:\n#endif\n#ifdef CONFIG_MTPROF\n\tbl  MT_trace_hardirqs_on\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tbl\ttrace_hardirqs_on\n#endif\n\tkernel_exit 1\nENDPROC(el1_irq)\n\n#ifdef CONFIG_PREEMPT\nel1_preempt:\n\tmov\tx24, lr\n\t// (3) 抢占调度\n1:\tbl\tpreempt_schedule_irq\t\t// irq en/disable is done inside\n\tldr\tx0, [tsk, #TI_FLAGS]\t\t// get new tasks TI_FLAGS\n\ttbnz\tx0, #TIF_NEED_RESCHED, 1b\t// needs rescheduling?\n\tret\tx24\n#endif\n\n| →\n\nasmlinkage __visible void __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\t__preempt_count_add(PREEMPT_ACTIVE);\n\t\tlocal_irq_enable();\n\t\t__schedule();\n\t\tlocal_irq_disable();\n\t\t__preempt_count_sub(PREEMPT_ACTIVE);\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t\tbarrier();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}\n```\n\n虽然 preempt_count>0 就是禁止抢占，Linux 进一步按照各种场景对 preempt_count bit 进行了资源划分：\n\n<table><thead><tr><th>reserved bits</th><th>bit21</th><th>bit20</th><th>bit19-bit16</th><th>bit15-bit8</th><th>bit7-bit0</th></tr></thead><tbody><tr><td>&nbsp;</td><td>PREEMPT_ACTIVE</td><td>NMI</td><td>HARDIRQ</td><td>SOFTIRQ</td><td>PREEMPT</td></tr></tbody></table>\n\n```c\n/*\n * PREEMPT_MASK:\t0x000000ff\n * SOFTIRQ_MASK:\t0x0000ff00\n * HARDIRQ_MASK:\t0x000f0000\n *     NMI_MASK:\t0x00100000\n * PREEMPT_ACTIVE:\t0x00200000\n */\n#define PREEMPT_BITS\t8\n#define SOFTIRQ_BITS\t8\n#define HARDIRQ_BITS\t4\n#define NMI_BITS\t1\n\n\n```\n\n各场景分别利用各自的 bit 来 disable/enable 抢占：\n\n*   普通场景 (PREEMPT_MASK)。对应函数 `preempt_disable()`、`preempt_enable()`。\n*   软中断场景 (SOFTIRQ_MASK)。对应函数 `local_bh_disable()`、`local_bh_enable()`。\n*   普通中断场景 (HARDIRQ_MASK)。对应函数 `__irq_enter()`、`__irq_exit()`。\n*   NMI 中断场景 (NMI_MASK)。对应函数 `nmi_enter()`、`nmi_exit()`。\n\n所以反过来，我们也可以通过 preempt_count 的值来判断当前在什么场景：\n\n```c\n#define in_irq()\t\t(hardirq_count())\n#define in_softirq()\t\t(softirq_count())\n#define in_interrupt()\t\t(irq_count())\n#define in_serving_softirq()\t(softirq_count() & SOFTIRQ_OFFSET)\n#define in_nmi()\t(preempt_count() & NMI_MASK)\n\n#define hardirq_count()\t(preempt_count() & HARDIRQ_MASK)\n#define softirq_count()\t(preempt_count() & SOFTIRQ_MASK)\n#define irq_count()\t(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK \\\n\t\t\t\t | NMI_MASK))\n```\n\n### 2.2 softirq\n\n回到中断上下半部的架构，linux 系统虽然将大部分工作移出了中断上下文，不关闭中断。但是它也希望移出的工作能够很快的得到执行，软中断为了保证自己能很快执行，使用 `__local_bh_disable_ip()` 禁止抢占。\n\nsoftirq 的具体实现机制如下：\n\n*   系统支持固定的几种软中断，softirq_vec 数组用来记录这些软中断执行函数：\n\n```c\nenum\n{\n\tHI_SOFTIRQ=0,\n\tTIMER_SOFTIRQ,\n\tNET_TX_SOFTIRQ,\n\tNET_RX_SOFTIRQ,\n\tBLOCK_SOFTIRQ,\n\tBLOCK_IOPOLL_SOFTIRQ,\n\tTASKLET_SOFTIRQ,\n\tSCHED_SOFTIRQ,\n\tHRTIMER_SOFTIRQ,\n\tRCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */\n\n\tNR_SOFTIRQS\n};\n\n// 注册软中断的服务程序\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}\n\n//TASKLET_SOFTIRQ、HI_SOFTIRQ 两个软中断用来给 tasklet 服务。\n\topen_softirq(TASKLET_SOFTIRQ, tasklet_action);\n\topen_softirq(HI_SOFTIRQ, tasklet_hi_action);\n```\n\n*   使用 irq_stat[cpu].__softirq_pending 来记录每个 cpu 上所有 softirq 的 pending 状态，`raise_softirq()` 用来置位一个 softirq pending：\n\n```c\nvoid raise_softirq(unsigned int nr)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\traise_softirq_irqoff(nr);\n\tlocal_irq_restore(flags);\n}\n| →\ninline void raise_softirq_irqoff(unsigned int nr)\n{\n\t__raise_softirq_irqoff(nr);\n\n\tif (!in_interrupt())\n\t\twakeup_softirqd();\n}\n|| →\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}\n||| →\n#define or_softirq_pending(x)  (local_softirq_pending() |= (x))\n\n#ifndef __ARCH_IRQ_STAT\nextern irq_cpustat_t irq_stat[];\t\t/* defined in asm/hardirq.h */\n#define __IRQ_STAT(cpu, member)\t(irq_stat[cpu].member)\n#endif\n\n  /* arch independent irq_stat fields */\n#define local_softirq_pending() \\\n\t__IRQ_STAT(smp_processor_id(), __softirq_pending)\n```\n\n*   softirq 的执行有两个时刻：在退出中断 `irq_exit()` 时或者在 softirqd 线程当中：\n\n[![](http://kernel.meizu.com/images/posts/2016/09/int_softirq_flow.png)](http://kernel.meizu.com/images/posts/2016/09/int_softirq_flow.png \"linux 软中断流程 \")linux 软中断流程\n\n软中断使用 `smpboot_register_percpu_thread()` 函数，给每个 cpu 上创建了对应的 softirqd 线程：\n\n```shell\nroot@:/ # ps | grep softirq\nroot      3     2     0      0     smpboot_th 0000000000 S ksoftirqd/0\nroot      12    2     0      0     __kthread_ 0000000000 R ksoftirqd/1\nroot      16    2     0      0     __kthread_ 0000000000 R ksoftirqd/2\nroot      20    2     0      0     __kthread_ 0000000000 R ksoftirqd/3\nroot      24    2     0      0     __kthread_ 0000000000 R ksoftirqd/4\nroot      28    2     0      0     __kthread_ 0000000000 R ksoftirqd/5\nroot      32    2     0      0     __kthread_ 0000000000 R ksoftirqd/6\nroot      36    2     0      0     __kthread_ 0000000000 R ksoftirqd/7\n```\n\n软中断优先在 `irq_exit()` 中执行，如果超过时间等条件转为 softirqd 线程中执行。满足以下任一条件软中断在 softirqd 线程中执行：\n\n*   在 `irq_exit()`->`__do_softirq()` 中运行，时间超过 2ms。\n*   在 `irq_exit()`->`__do_softirq()` 中运行，轮询软中断超过 10 次。\n*   在 `irq_exit()`->`__do_softirq()` 中运行，本线程需要被调度。\n*   调用 `raise_softirq()` 唤醒软中断时，不在中断环境中。\n\n我们也看到，软中断处理是按照优先级逐个调用 softirq_vec[] 数组中的软中断处理函数，所以前面的软中断是可以阻塞后面的软中断的。这个在我们写程序的时候需要注意。\n\n### 2.3 tasklet\n\nLinux 已经有了 softirq 机制，为什么还需要 tasklet 机制？最主要的原因是 softirq 是多 cpu 执行的，可能碰到很多重入的问题，而 tasklet 同一时刻只能在一个 cpu 上执行，不需要处理重入互斥问题。另外 Linux 也不建议用户去添加新的软中断。\n\n下面我们来具体分析一下 tasklet 的实现机制：\n\n*   per-cpu 变量 tasklet_vec/tasklet_hi_vec 以链表的形式记录了当前 cpu 需要处理的 tasklet 任务：\n\n```c\nvoid __init softirq_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\t// (1)tasklet_vec 为低优先级的 tasklet 链表\n\t\tper_cpu(tasklet_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_vec, cpu).head;\n\t\t// (2)tasklet_hi_vec 为高优先级的 tasklet 链表\n\t\tper_cpu(tasklet_hi_vec, cpu).tail =\n\t\t\t&per_cpu(tasklet_hi_vec, cpu).head;\n\t}\n}\n```\n\n*   push 一个 tasklet 任务：\n\n```c\nstatic inline void tasklet_schedule(struct tasklet_struct *t)\n{\n\tif (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))\n\t\t__tasklet_schedule(t);\n}\n| →\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t// (1) 将新的 tasklet 插入到本 cpu 链表尾部\n\tt->next = NULL;\n\t*__this_cpu_read(tasklet_vec.tail) = t;\n\t__this_cpu_write(tasklet_vec.tail, &(t->next));\n\t// (2)raise 软中断来处理 tasklet\n\traise_softirq_irqoff(TASKLET_SOFTIRQ);\n\tlocal_irq_restore(flags);\n}\n```\n\n*   处理一个 tasklet 任务：\n\n```c\nstatic void tasklet_action(struct softirq_action *a)\n{\n\tstruct tasklet_struct *list;\n\n\tlocal_irq_disable();\n\t// (1)list 取出当前链表中所有已有的 tasklet\n\tlist = __this_cpu_read(tasklet_vec.head);\n\t// (2)tasklet_vec.head 和 tasklet_vec.tail 返回初始化状态，继续接收新的 tasklet\n\t__this_cpu_write(tasklet_vec.head, NULL);\n\t__this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&tasklet_vec.head));\n\tlocal_irq_enable();\n\n\t// (3) 逐个处理取出的 list 链表中的 tasklet\n\twhile (list) {\n\t\tstruct tasklet_struct *t = list;\n\n\t\tlist = list->next;\n\n\t\t// (4)tasklet 互斥锁，保证 tasklet 同时只能在一个 cpu 上执行\n\t\tif (tasklet_trylock(t)) {\n\t\t\tif (!atomic_read(&t->count)) {\n\n\t\t\t\t// (6) 在 tasklet 运行前清除 TASKLET_STATE_SCHED 标志\n\t\t\t\t// 这个时候 tasklet 可以重新加入新的队列了，但是还不能执行\n\t\t\t\tif (!test_and_clear_bit(TASKLET_STATE_SCHED,\n\t\t\t\t\t\t\t&t->state))\n\t\t\t\t\tBUG();\n\n\t\t\t\t// (7) 执行实际的 tasklet 处理函数\n\t\t\t\tt->func(t->data);\n\n\t\t\t\t// (8) 释放 tasklet 锁，其他 cpu 可以运行这个 tasklet 了\n\t\t\t\ttasklet_unlock(t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttasklet_unlock(t);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\t// (5) 如果获取 tasklet 互斥锁失败，先加入到 cpu tasklet_vec 链表中\n\t\t// 下次执行\n\t\tt->next = NULL;\n\t\t*__this_cpu_read(tasklet_vec.tail) = t;\n\t\t__this_cpu_write(tasklet_vec.tail, &(t->next));\n\t\t__raise_softirq_irqoff(TASKLET_SOFTIRQ);\n\t\tlocal_irq_enable();\n\t}\n}\n```\n\n参考资料\n----","tags":["linux"],"categories":["中断","linux"]},{"title":"多root key 管理","url":"/2022/02/12/TEE/多root key管理/","content":"\n多个信任根：允许具有不同访问权限的多个实体共享芯片，同时每个实体都有自己的 \"虚拟 \"安全核心和私有安全域。\n\n分层安全：加强对加密模块和其他安全资源的访问。确保关键密钥只能通过硬件获得，不能通过软件访问。\n\n隔离操作：在远离通用处理的专用安全执行域中执行广泛的安全功能\n\n目的性强：从根本上为安全而设计。具有最先进的防篡改和安全技术，包括抵抗侧信道和故障注入攻击。\n\n### Sharing a Root of Trust is Potentially Risky\n\n一旦进入安全域，一个应用程序被认为是安全的。但如果一个应用程序实际上是恶意的呢？- 该应用程序可能会感染其他人，窃取信息，并将敏感信息暴露给恶意的一方 \n在一个单一的信任根内，一方的恶意程序可以访问另一方的敏感信息\n\n\n## multi roots of trust \nMultiple Roots of Trust [041](bookxnotepro://opennote/?nb={af27f419-aaf4-494d-b2a4-9f05f129b37d}&book=3f4f03b2bf8e973c33f1d9a004beb8bb&page=40&x=200&y=48&id=4)\n\n相比之下，多个root key可允许不同的实体，如芯片供应商、OEM和服务提供商在同一芯片中拥有自己的 \"虚拟 \"安全核心，但每个都有一个私有安全域。\n每个实体都拥有其签名的应用程序集。当处理器切换应用程序时，所有的上下文都会从处理器中刷新。默认情况下，没有数据、密钥或其他信息持续存在，确保实体之间不共享上下文\n密钥被分配给每个根，允许应用程序在每个根中以不同的方式进行签名。\n\n\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220511145341.png)\n\n\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220511145342.png)\n\n- 一个主根设置每个（子）信任根的权限和特权 \n- 每个实体及其安全进程/应用程序都被分配到自己的专用信任根 \n- 当一个应用程序被加载到安全处理器时，根被识别，硬件被配置为该根\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220511145343.png)\n\n初始时, 芯片制造方被分配了master root, 拥有完全的权限\nmaster root 可以授权其他实体创建其他的master root, 也可以限制只有一个master root\n为什么允许创建其他的master root ?  通常芯片由芯片方给到oem后, oem 也想拿到所有设备的所有权限.\nmaster root 也可以授权其他的master root 有擦除它的权限, 所以芯片给到oem后, oem可以创建master root, 然后把芯片的master root禁用\n\n- 硬件信任根可以设计成只有授权的软件才能在信任根上运行。\n- 在一个有多个根的信任根中，每个根都可以与用于签名（授权）软件的密钥相关联。\n- 当一个签名的应用程序运行时，它继承了它所关联的根的权限和密钥\n- 由一个根签署的软件不能访问与另一个根相关的数据和密钥\n- 尽管应用程序是软件，但对硬件、权限和钥匙的访问权的执行都可以在硬件中执行。\n\n\n与一个根相关的基础钥匙可以用一个钥匙派生函数来派生新的钥匙。这意味着一个钥匙可以变成许多钥匙, 这些钥匙可以用于非常多的不同的安全操作 \n- 每一组钥匙对每个根来说都是唯一的\n- 一个根没有办法访问另一个根的钥匙，这是硬件强制执行的 \n- 钥匙是即时派生的，所以它们只在使用时存在，在不使用时清空\n\n## 例子 汽车芯片\n\n-  芯片制造商需要主根用于制造、测试和调试 \n-  一级供应商为OEM（汽车制造商）创建模块。一级供应商需要编写软件，测试和调试芯片和模块；在大多数情况下，将抹去芯片主根，并为OEM创建新的主根\n-  OEM需要使用信任根的所有功能，以及为服务中心和其他方创建新的根。OEM在许多情况下会抹去1级主根，以便OEM可以控制信任根的所有使用\n-  服务中心获得有限的权限；例如，没有OEM的授权，不能安装新固件\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220511151943.jpg)\n\nThe Personalization Root key pair may be owned by \n- the SoC designer or \n- the manufacturing personalization provider\n\n每层的公钥私钥被每个实体持有, 每个实体的安全应用应当被其持有的私钥签名\n每一个根都可以被抹去（禁用） \n- Personalization Root key 可以通过OTP中的一个位来禁用\n- Personalization Root key 在某个量产的阶段后会被禁用\n- 禁用某个 root key 的安全应用需要有禁用这个key的权限\n- 每个实体的安全应用也能禁用自己的root key(被授予了相应权限时). \n\n\n### 例子\nSecure Application Management & the Secure Boot Use Case [051](bookxnotepro://opennote/?nb={af27f419-aaf4-494d-b2a4-9f05f129b37d}&book=3f4f03b2bf8e973c33f1d9a004beb8bb&page=50&x=486&y=48&id=5)\n\nFor the secure boot use case Secure Application Dev1:\n- Dev1 Root 可以被用作secure boot流程, secureboot 流程可以视作 dev1 root的安全应用\n- Dev1 Root 有一组资源, secureboot 流程中需要访问这些资源, 且有权限访问这些资源.  \n- Dev1 Root 下的安全应用不能访问 Dev2 root1 或 root2 的资源, 除非被授予了相应的权限.\n\nsecure boot 流程做完后, Dev1 root 的安全应用就不再需要了\n\nDev2 root1 可以为boot 起来的系统(OS)提供后续的密码学的服务\nDev2 root2 的安全应用 可以访问独立或共享的资源:\n- root2 后可能会有很多并列的服务, 通过权限授权可以访问一组共享的资源\n\n\n\n","tags":["efuse"],"categories":["安全"]},{"title":"安全算法介绍","url":"/2022/01/12/TEE/安全算法介绍/","content":"\n# md5\n\n**MD5消息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的[密码散列函数](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8 \"密码散列函数\")，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value）\n\n1996年后被证实存在弱点，可以被加以[破解](https://zh.wikipedia.org/wiki/%E7%A0%B4%E8%A7%A3 \"破解\")，对于需要高度安全性的资料，专家一般建议改用其他算法，如[SHA-2](https://zh.wikipedia.org/wiki/SHA-2 \"SHA-2\")。2004年，证实MD5算法无法防止[碰撞攻击](https://zh.wikipedia.org/w/index.php?title=%E7%A2%B0%E6%92%9E%E6%94%BB%E5%87%BB&action=edit&redlink=1)，因此不适用于安全性认证，如[SSL](https://zh.wikipedia.org/wiki/SSL \"SSL\")[公开密钥认证](https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89 \"公开密钥认证\")或是[数字签名](https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0 \"数字签名\")等用途。\n\n## 缺陷\n2009年，[中国科学院](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E7%A7%91%E5%AD%B8%E9%99%A2 \"中国科学院\")的谢涛和冯登国仅用了220.96的碰撞算法复杂度，破解了MD5的碰撞抵抗，该攻击在普通计算机上运行只需要数秒钟[[3]](https://zh.wikipedia.org/wiki/MD5#cite_note-3)。2011年，[RFC 6151](https://tools.ietf.org/html/rfc6151) 禁止MD5用作[密钥散列消息认证码](https://zh.wikipedia.org/wiki/%E9%87%91%E9%91%B0%E9%9B%9C%E6%B9%8A%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC \"密钥散列消息认证码\")。\n\n# sha\n-   **[SHA-0](https://zh.wikipedia.org/wiki/SHA-0 \"SHA-0\")**：1993年发布，当时称做安全散列标准（Secure Hash Standard），发布之后很快就被NSA撤回，是SHA-1的前身。\n\n-   **[SHA-1](https://zh.wikipedia.org/wiki/SHA-1 \"SHA-1\")**：1995年发布，SHA-1在许多安全协议中广为使用，包括[TLS](https://zh.wikipedia.org/wiki/TLS \"TLS\")、[GnuPG](https://zh.wikipedia.org/wiki/GnuPG \"GnuPG\")、[SSH](https://zh.wikipedia.org/wiki/Secure_Shell \"Secure Shell\")、[S/MIME](https://zh.wikipedia.org/wiki/S/MIME \"S/MIME\")和[IPsec](https://zh.wikipedia.org/wiki/IPsec \"IPsec\")，是[MD5](https://zh.wikipedia.org/wiki/MD5 \"MD5\")的后继者。但SHA-1的安全性在2010年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1[[1]](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F#cite_note-1)。\n\n-   **[SHA-2](https://zh.wikipedia.org/wiki/SHA-2 \"SHA-2\")**：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。SHA-2目前没有出现明显的弱点。虽然至今尚未出现对SHA-2有效的攻击，但它的算法跟SHA-1基本上仍然相似。\n\n-   **[SHA-3](https://zh.wikipedia.org/wiki/SHA-3 \"SHA-3\")**：2015年正式发布，由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，[NIST](https://zh.wikipedia.org/wiki/%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E6%9A%A8%E6%8A%80%E8%A1%93%E7%A0%94%E7%A9%B6%E9%99%A2 \"国家标准暨技术研究院\")感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。\n\n\n## sha 家族函数对比\n\n<table class=\"wikitable\" style=\"margin-top: 0px; width:100%\">\n<caption>SHA函数对比\n</caption>\n<tbody><tr style=\"vertical-align:bottom;\">\n<th colspan=\"2\">算法和变体\n</th>\n<th>输出散列值长度<br>（bits）\n</th>\n<th>中继散列值长度<br>（bits）\n</th>\n<th>资料区块长度<br>（bits）\n</th>\n<th>最大输入消息长度<br>（bits）\n</th>\n<th>循环次数\n</th>\n<th>使用到的运算符\n</th>\n<th>碰撞攻击<br>（bits）\n</th>\n<th>性能示例<sup id=\"cite_ref-3\" class=\"reference\"><a href=\"#cite_note-3\">[3]</a></sup><br>(<a href=\"/wiki/Mebibyte\" title=\"Mebibyte\">MiB</a>/s)\n</th></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td colspan=\"2\"><b><a href=\"/wiki/MD5\" title=\"MD5\">MD5</a></b>（作为参考）</td>\n<td>128</td>\n<td>128<br><span class=\"nowrap\">(4 × 32)</span></td>\n<td>512</td>\n<td>无限<sup id=\"cite_ref-4\" class=\"reference\"><a href=\"#cite_note-4\">[4]</a></sup></td>\n<td>64</td>\n<td>And, Xor, Rot, <span class=\"nowrap\">Add (mod&nbsp;2<sup>32</sup>),</span> Or</td>\n<td class=\"table-no\" style=\"text-align: center; background: rgb(255, 144, 144); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#760000;\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\">≤18<br>（发现碰撞）</td>\n<td>335\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td colspan=\"2\"><b><span class=\"nowrap\"><a href=\"/wiki/SHA-0\" class=\"mw-redirect\" title=\"SHA-0\">SHA-0</a></span></b></td>\n<td>160</td>\n<td>160<br><span class=\"nowrap\">(5 × 32)</span></td>\n<td>512</td>\n<td>2<sup>64</sup> − 1</td>\n<td>80</td>\n<td rowspan=\"2\">And, Xor, Rot, <span class=\"nowrap\">Add (mod&nbsp;2<sup>32</sup>),</span> Or</td>\n<td class=\"table-no\" style=\"text-align: center; background: rgb(255, 144, 144); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#760000;\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\">&lt;34<br>（发现碰撞）</td>\n<td>-\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td colspan=\"2\"><b><span class=\"nowrap\"><a href=\"/wiki/SHA-1\" title=\"SHA-1\">SHA-1</a></span></b></td>\n<td>160</td>\n<td>160<br><span class=\"nowrap\">(5 × 32)</span></td>\n<td>512</td>\n<td>2<sup>64</sup> − 1</td>\n<td>80</td>\n<td class=\"table-no\" style=\"text-align: center; background: rgb(255, 144, 144); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#760000;\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\">&lt;63<sup id=\"cite_ref-5\" class=\"reference\"><a href=\"#cite_note-5\">[5]</a></sup><br>（发现碰撞<sup id=\"cite_ref-6\" class=\"reference\"><a href=\"#cite_note-6\">[6]</a></sup>）</td>\n<td>192\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td rowspan=\"2\"><b><span class=\"nowrap\"><a href=\"/wiki/SHA-2\" title=\"SHA-2\">SHA-2</a></span></b></td>\n<td><i>SHA-224</i><br><i>SHA-256</i></td>\n<td>224<br>256</td>\n<td>256<br><span class=\"nowrap\">(8 × 32)</span></td>\n<td>512</td>\n<td>2<sup>64</sup> − 1</td>\n<td>64</td>\n<td>And, Xor, Rot, <span class=\"nowrap\">Add (mod&nbsp;2<sup>32</sup>),</span> Or, Shr</td>\n<td style=\"background: rgb(153, 255, 153); color: black; vertical-align: middle; text-align: center; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#1c7000; --darkreader-inline-color:#e8e6e3;\" class=\"yes table-yes2\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-color=\"\">112 <br> 128</td>\n<td>139\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td><i>SHA-384</i><br><i>SHA-512</i><br><i><span class=\"nowrap\">SHA-512/224</span></i><br><i><span class=\"nowrap\">SHA-512/256</span></i></td>\n<td>384<br>512<br>224 <br>256</td>\n<td>512<br><span class=\"nowrap\">(8 × 64)</span></td>\n<td>1024</td>\n<td>2<sup>128</sup> − 1</td>\n<td>80</td>\n<td>And, Xor, Rot, <span class=\"nowrap\">Add (mod&nbsp;2<sup>64</sup>),</span> Or, Shr</td>\n<td style=\"background: rgb(153, 255, 153); color: black; vertical-align: middle; text-align: center; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#1c7000; --darkreader-inline-color:#e8e6e3;\" class=\"yes table-yes2\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-color=\"\">192<br>256<br>112<br>128</td>\n<td>154\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td rowspan=\"2\"><b><span class=\"nowrap\"><a href=\"/wiki/SHA-3\" title=\"SHA-3\">SHA-3</a></span></b></td>\n<td><i>SHA3-224</i><br><i>SHA3-256</i><br><i>SHA3-384</i><br><i>SHA3-512</i></td>\n<td>224<br>256<br>384<br>512</td>\n<td rowspan=\"2\">1600<br><span class=\"nowrap\">(5 × 5 × 64)</span></td>\n<td>1152<br>1088<br>832<br>576</td>\n<td rowspan=\"2\">无限<sup id=\"cite_ref-7\" class=\"reference\"><a href=\"#cite_note-7\">[7]</a></sup></td>\n<td rowspan=\"2\">24<sup id=\"cite_ref-8\" class=\"reference\"><a href=\"#cite_note-8\">[8]</a></sup></td>\n<td rowspan=\"2\">And, Xor, Rot, Not</td>\n<td style=\"background: rgb(153, 255, 153); color: black; vertical-align: middle; text-align: center; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#1c7000; --darkreader-inline-color:#e8e6e3;\" class=\"yes table-yes2\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-color=\"\">112<br>128<br>192<br>256</td>\n<td>-\n</td></tr>\n<tr style=\"text-align:center;vertical-align:top;\">\n<td><i>SHAKE128</i><br><i>SHAKE256</i></td>\n<td><span class=\"nowrap\"><i>d</i> (arbitrary)</span><br><span class=\"nowrap\"><i>d</i> (arbitrary)</span></td>\n<td>1344<br>1088</td>\n<td style=\"background: rgb(153, 255, 153); color: black; vertical-align: middle; text-align: center; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor:#1c7000; --darkreader-inline-color:#e8e6e3;\" class=\"yes table-yes2\" data-darkreader-inline-bgimage=\"\" data-darkreader-inline-bgcolor=\"\" data-darkreader-inline-color=\"\">min(<i>d</i>/2, 128)<br>min(<i>d</i>/2, 256)</td>\n<td>-\n</td></tr></tbody></table>\n\n# CRC\n**循环冗余校验**（英语：**Cyclic redundancy check**，通称“**CRC**”）是一种根据网络数据包或[电脑文件](https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%AA%94%E6%A1%88 \"电脑文件\")等数据产生简短固定位数校验码的一种[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)，主要用来检测或校验数据传输或者保存后可能出现的错误。\n\n## 常用CRC（按照ITU-IEEE规范）\n\n<table class=\"wikitable\">\n<tbody><tr>\n<th>名称</th>\n<th>多项式</th>\n<th>表示法：正常或者翻转\n</th></tr>\n<tr>\n<td>CRC-1</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/16df430ed7a23df9b160a5bbd957f306a0c3baa7\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:5.333ex; height:2.343ex;\" alt=\"x+1\"></span><br>（用途：硬件，也称为<a href=\"/wiki/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D\" title=\"奇偶校验位\">奇偶校验位</a>）</td>\n<td>0x1 or 0x1 (0x1)\n</td></tr>\n<tr>\n<td>CRC-5-CCITT</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{5}+x^{3}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{5}+x^{3}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a3bf477e7d06894ce882770e495df9105e9770e4\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:15.781ex; height:2.843ex;\" alt=\"x^{5}+x^{3}+x+1\"></span>（<a href=\"/wiki/ITU\" class=\"mw-redirect\" title=\"ITU\">ITU</a> G.704标准）</td>\n<td>0xB（0x??）\n</td></tr>\n<tr>\n<td>CRC-5-USB</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{5}+x^{2}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{5}+x^{2}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/5ee197df10962cfbefa8b3b7bf0bf63115b2036d\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:11.611ex; height:2.843ex;\" alt=\"x^{5}+x^{2}+1\"></span>（用途：<a href=\"/wiki/USB\" title=\"USB\">USB</a>信令包）</td>\n<td>0x5 or 0x14 (0x9)\n</td></tr>\n<tr>\n<td>CRC-7</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{7}+x^{3}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>7</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{7}+x^{3}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/6b28d7978cdde1a847d051b7c0eafacda0057ee2\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:11.611ex; height:2.843ex;\" alt=\"x^{7}+x^{3}+1\"></span>（用途：通信系统）</td>\n<td>0x9 or 0x48 (0x11)\n</td></tr>\n<tr>\n<td>CRC-8-ATM</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{8}+x^{2}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{8}+x^{2}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/9aeac5149ba7d39c70a5adf775f3ccf3c458c285\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:15.781ex; height:2.843ex;\" alt=\"x^{8}+x^{2}+x+1\"></span>（用途：ATM HEC, PMBUS （参见SMBUS org<a rel=\"nofollow\" class=\"external autonumber\" href=\"http://smbus.org/faq/crc8Applet.htm\">[1]</a>））</td>\n<td>0x7或0xE0 (0xC1)\n</td></tr>\n<tr>\n<td>CRC-8-<a href=\"/wiki/CCITT\" class=\"mw-redirect\" title=\"CCITT\">CCITT</a></td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{8}+x^{7}+x^{3}+x^{2}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>7</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{8}+x^{7}+x^{3}+x^{2}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/64d70a16d4bcc603931b3057902b2ca269793ce4\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:22.06ex; height:2.843ex;\" alt=\"x^{8}+x^{7}+x^{3}+x^{2}+1\"></span>（用途：<a href=\"/wiki/1-Wire\" title=\"1-Wire\">1-Wire</a> <a href=\"/wiki/%E7%B8%BD%E7%B7%9A\" class=\"mw-redirect\" title=\"总线\">总线</a>）</td>\n<td>0x8D\n</td></tr>\n<tr>\n<td>CRC-8-<a href=\"/w/index.php?title=Dallas_Semiconductor&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Dallas Semiconductor（页面不存在）\">Dallas</a>/<a href=\"/w/index.php?title=Maxim_IC&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Maxim IC（页面不存在）\">Maxim</a></td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{8}+x^{5}+x^{4}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{8}+x^{5}+x^{4}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/de3b0d4157865c219b2b6dd548b58d3d97aadf47\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:16.835ex; height:2.843ex;\" alt=\"x^{8}+x^{5}+x^{4}+1\"></span>（用途：<a href=\"/wiki/1-Wire\" title=\"1-Wire\">1-Wire</a> <a href=\"/wiki/Bus\" class=\"mw-disambig\" title=\"Bus\">bus</a>）</td>\n<td>0x31或0x8C\n</td></tr>\n<tr>\n<td>CRC-8</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>7</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>6</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/7c1c3912f0ad9cbfb4d13c9ada78ed6dab733c06\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:27.284ex; height:2.843ex;\" alt=\"x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1\"></span></td>\n<td>0xD5（0x??）\n</td></tr>\n<tr>\n<td>CRC-10</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{10}+x^{9}+x^{5}+x^{4}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>10</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>9</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{10}+x^{9}+x^{5}+x^{4}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a3d2fbda9053b3a8d1b1f1f1c4e4c0d5f81b663e\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:27.052ex; height:2.843ex;\" alt=\"{\\displaystyle x^{10}+x^{9}+x^{5}+x^{4}+x+1}\"></span></td>\n<td>0x233（0x????）\n</td></tr>\n<tr>\n<td>CRC-12</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{12}+x^{11}+x^{3}+x^{2}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>12</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>11</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{12}+x^{11}+x^{3}+x^{2}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/c5f1dc362baad71ca8749f815c9f3a51f810d054\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:27.874ex; height:2.843ex;\" alt=\"x^{12}+x^{11}+x^{3}+x^{2}+x+1\"></span>（用途：通信系统）</td>\n<td>0x80F或0xF01 (0xE03)\n</td></tr>\n<tr>\n<td>CRC-16-Fletcher</td>\n<td>参见<a href=\"/w/index.php?title=Fletcher%27s_checksum&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"Fletcher's checksum（页面不存在）\">Fletcher's checksum</a></td>\n<td>用于<a href=\"/wiki/Adler-32\" title=\"Adler-32\">Adler-32</a> A &amp; B CRC\n</td></tr>\n<tr>\n<td>CRC-16-CCITT</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{16}+x^{12}+x^{5}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>16</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>12</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{16}+x^{12}+x^{5}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/661d89787e958d98fb6da5c0c2185fc92a176514\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:18.479ex; height:2.843ex;\" alt=\"{\\displaystyle x^{16}+x^{12}+x^{5}+1}\"></span>（<a href=\"/w/index.php?title=X25&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"X25（页面不存在）\">X25</a>, <a href=\"/w/index.php?title=V.41&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"V.41（页面不存在）\">V.41</a>, <a href=\"/wiki/Bluetooth\" class=\"mw-redirect\" title=\"Bluetooth\">Bluetooth</a>, <a href=\"/wiki/PPP\" class=\"mw-disambig\" title=\"PPP\">PPP</a>, <a href=\"/w/index.php?title=IrDA&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"IrDA（页面不存在）\">IrDA</a>）</td>\n<td>0x1021或0x8408 (0x0811)\n</td></tr>\n<tr>\n<td>CRC-16-<a href=\"/wiki/IBM\" title=\"IBM\">IBM</a></td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{16}+x^{15}+x^{2}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>16</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>15</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{16}+x^{15}+x^{2}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/bd8dba2898cd0de4ef69e454d9c8f45efdfcedb2\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:18.479ex; height:2.843ex;\" alt=\"{\\displaystyle x^{16}+x^{15}+x^{2}+1}\"></span>（用途：<a href=\"/wiki/Modbus\" title=\"Modbus\">Modbus）</a></td>\n<td>0x8005或0xA001 (0x4003)\n</td></tr>\n<tr>\n<td>CRC-16-<a href=\"/wiki/BBS\" title=\"BBS\">BBS</a></td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{16}+x^{15}+x^{10}+x^{3}}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>16</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>15</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>10</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{16}+x^{15}+x^{10}+x^{3}}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/72b35fb643d7e3e0d7ec5e9bc9536e6a1fe141df\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:20.523ex; height:2.843ex;\" alt=\"{\\displaystyle x^{16}+x^{15}+x^{10}+x^{3}}\"></span>（用途：<a href=\"/w/index.php?title=XMODEM&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"XMODEM（页面不存在）\">XMODEM</a>协议）</td>\n<td>0x8408（0x????）\n</td></tr>\n<tr>\n<td>CRC-32-Adler</td>\n<td>参见<a href=\"/wiki/Adler-32\" title=\"Adler-32\">Adler-32</a></td>\n<td>参见<a href=\"/wiki/Adler-32\" title=\"Adler-32\">Adler-32</a>\n</td></tr>\n<tr>\n<td>CRC-32-MPEG2</td>\n<td>参见<a href=\"/wiki/IEEE_802.3\" class=\"mw-redirect\" title=\"IEEE 802.3\">IEEE 802.3</a></td>\n<td>参见<a href=\"/wiki/IEEE_802.3\" class=\"mw-redirect\" title=\"IEEE 802.3\">IEEE 802.3</a>\n</td></tr>\n<tr>\n<td>CRC-32-<a href=\"/wiki/IEEE_802.3\" class=\"mw-redirect\" title=\"IEEE 802.3\">IEEE 802.3</a></td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>32</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>26</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>23</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>22</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>16</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>12</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>11</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>10</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>7</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>5</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>2</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/08ec731bacb2c8c8e8f8c2c8d71c33bddf97e7d5\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:79.825ex; height:2.843ex;\" alt=\"x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1\"></span></td>\n<td>0x04C11DB7或0xEDB88320 (0xDB710641)\n</td></tr>\n<tr>\n<td>CRC-32C(Castagnoli)</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>32</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>28</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>27</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>26</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>25</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>23</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>22</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>20</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>19</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>18</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>14</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>13</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>11</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>10</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>9</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>8</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>6</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/495f98eb0abe80037a8bfb0b3dfb943df9e04495\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:101.484ex; height:2.843ex;\" alt=\"x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1\"></span></td>\n<td>0x1EDC6F41或0x82F63B78 (0x05EC76F1)\n</td></tr>\n<tr>\n<td>CRC-64-ISO</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{64}+x^{4}+x^{3}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>64</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>3</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{64}+x^{4}+x^{3}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/a2e1edbd34bac4a025bb68adac8f20f58adb3fcf\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:21.827ex; height:2.843ex;\" alt=\"x^{64}+x^{4}+x^{3}+x+1\"></span><br>（用途: ISO 3309）</td>\n<td>0x000000000000001B或0xD800000000000000 (0xB000000000000001)\n</td></tr>\n<tr>\n<td>CRC-64-<a href=\"/wiki/Ecma_International\" class=\"mw-redirect\" title=\"Ecma International\">ECMA</a>-182</td>\n<td><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle x^{64}+x^{62}+x^{57}+x^{55}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{33}+x^{32}}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>64</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>62</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>57</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>55</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>54</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>53</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>52</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>47</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>46</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>45</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>40</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>39</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>38</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>37</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>35</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>33</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>32</mn>\n          </mrow>\n        </msup>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle x^{64}+x^{62}+x^{57}+x^{55}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{33}+x^{32}}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/2cb5588781e0cca1a9d48ea9b11a8ad7f31069fb\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:99.947ex; height:2.843ex;\" alt=\"x^{64}+x^{62}+x^{57}+x^{55}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{33}+x^{32}\"></span><br><span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"{\\displaystyle +x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{22}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1}\">\n  <semantics>\n    <mrow class=\"MJX-TeXAtom-ORD\">\n      <mstyle displaystyle=\"true\" scriptlevel=\"0\">\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>31</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>29</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>27</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>24</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>23</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>22</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>21</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>19</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>17</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>13</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>12</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>10</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>9</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>7</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <msup>\n          <mi>x</mi>\n          <mrow class=\"MJX-TeXAtom-ORD\">\n            <mn>4</mn>\n          </mrow>\n        </msup>\n        <mo>+</mo>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n      </mstyle>\n    </mrow>\n    <annotation encoding=\"application/x-tex\">{\\displaystyle +x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{22}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1}</annotation>\n  </semantics>\n</math></span><img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/7923dab3807e2710107ed224fe788f2b7da70277\" class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"vertical-align: -0.505ex; width:95.369ex; height:2.843ex;\" alt=\"+x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{22}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1\"></span><br>（参见<a rel=\"nofollow\" class=\"external text\" href=\"http://www.ecma-international.org/publications/standards/Ecma-182.htm\">ECMA-182</a> p.63）</td>\n<td>0x42F0E1EBA9EA3693或0xC96C5795D7870F42 (0x92D8AF2BAF0E1E85)\n</td></tr>\n<tr>\n<td>CRC-128</td>\n<td>IEEE-ITU标准。被<a href=\"/wiki/MD5\" title=\"MD5\">MD5</a> &amp; <a href=\"/wiki/SHA-1\" title=\"SHA-1\">SHA-1</a>取代</td>\n<td>\n</td></tr>\n<tr>\n<td>CRC-160</td>\n<td>IEEE-ITU标准。被<a href=\"/wiki/MD5\" title=\"MD5\">MD5</a> &amp; <a href=\"/wiki/SHA-1\" title=\"SHA-1\">SHA-1</a>取代</td>\n<td>\n</td></tr>\n</tbody></table>\n\n常用的 CRC-16-IBM(crc16_sdlc), CRC-16-CCITT CRC-32-[IEEE 802.3](app://obsidian.md/wiki/IEEE_802.3 \"IEEE 802.3\")  CRC-32C(Castagnoli) \n\n```c\n#define CRC_MODE_16_CCITT   (0x0 << CRCCTL_MODE_SHIFT)   //0x1021\n#define CRC_MODE_8_0x31     (0x1 << CRCCTL_MODE_SHIFT)   //0x0131\n#define CRC_MODE_8_0x07     (0x2 << CRCCTL_MODE_SHIFT)   //0x0107\n#define CRC_MODE_8_0x5D     (0x3 << CRCCTL_MODE_SHIFT)   //0x015D\n#define CRC_MODE_16_SDLC    (0x4 << CRCCTL_MODE_SHIFT)   //0x8005\n#define CRC_MODE_32         (0x5 << CRCCTL_MODE_SHIFT)   //0x04c11db7\n#define CRC_MODE_32C        (0x6 << CRCCTL_MODE_SHIFT)   //0x1EDC6F41\n```\n\n# DES\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114834.png)\n图  __4__ . __5__  表明了  __DES__  加密的整个机制。对于任意加密方案，总有两个输入：明文和密钥。  __DES__  的明文长为  __64__  位，密钥长为  __56__  位。从图中左半部分，可见明文的处理经过了三个阶段。首先，  __64__  位的明文经过初始置换  __P__  而被重新排列。然后进行  __16__  轮相同函数的作用，每轮作用都有置换和代替。最后一轮迭代的输出有  __64__  位，它是输入明文和密钥的函数。其左半部分和右半部分互换产生预输出。最后预输出再被与初始置换  __P__  互逆的置换  __IP-1__  作用产生  __64__  位的密文。除了初始和末尾的置换，  __DES__  的结构与图4.__3__  所示的Feistel 密码结构完全相同。图  __4__.__5__  的右半部分给出了使用  __56__  位密钥的过程。首先，密钥经过一个置换后，再经过循环左移和一个置换分别得到各轮的子密钥用于各轮的迭代。每轮的置换函数都一样，但是由于密钥的循环移位使得各轮子密钥互不相同。 [097](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=96&x=246&y=145&id=14)\n\n__DES__  在穷举攻击之下相对比较脆弱，一台  PC可以破坏  DES  的时间大约为一年，如果多台  __PC__  并行工作，时间将大大缩短。今天的超级计算机应该可以在一个小时内找到密钥。增大密钥大小是防止使用简单蛮力攻击的有效方法，  __128__  位或更大的位是有效的。即使设法加快了  __1__  万亿的攻击系统，使用  __128__  位密钥破解代码仍然需要  __10__  万年以上的时间才能攻破。 [100](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=99&x=250&y=281&id=36)\n\n因此很多人在想办法用某种算法替代它。一种方案是设计全新的算法，如  __AES__  。还有一种方案，能够保护已有软件和硬件的投资，那就是用  __DES__  进行多次加密，且使用多个密钥。我们以这种替代方案的一个简单例子开始，再讨论已被广泛接受的三重DES(3DES)  算法。 [154](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=153&x=264&y=418&id=13)\n\n\n## 3DES\n使用三个密钥的三重  DES [158](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=157&x=152&y=109&id=15)\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114830.png)\n3DES 加密就是进行 3 次 DES 加密。DES 密钥长度为 56 位，所以 3DES 密钥长度为 56 * 3 = 168 位。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420135413.png)\n3DES 有一个“奇怪”的地方，并不是用 DES 加密 3 次，而是加密-解密-加密，中间有一次解密的过程。IBM 公司之所以这么设计，目的是为了让三重 DES 能兼容普通的 DES。如果三重加密中密钥都完全相同，那么就退化成了普通的 DES 了。(加密一次解密一次就抵消了)所以也就具备了向下兼容性。\n-   如果 3 次都用相同的密钥，则退化成了 DES。\n-   如果第一次和第三次用相同的密钥，第二次用不同的密钥，这种三重 DES 称为 DES-EDE2 。EDE 是加密(Encryption) -> 解密(Decryption) -> 加密(Encryption) 的缩写。\n-   如果 3 次都用不同的密钥，则称 DES-EDE3。\n\n3DES 解密的过程和加密的过程正好相反，按照密钥的逆序解密。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420135540.png)\n### 缺点:\n3DES 由于处理速度不高，除了兼容之前的 DES 以外，目前基本不再使用它了。\n# AES\nAES (Advanced Encrytion Standard) 是取代前任标准 DES 而成为新标准的一种对称密码算法。\n[漫游对称加密算法 (halfrost.com)](https://halfrost.com/symmetric_encryption/#toc-10)\n\nAES128, AES192，AES256\n\n## 模式\n\nCBC ECB CFB OFB CTR CTS XTS CCM GCM\n\n### ECB\n\nECB 模式是分组模式里面最简单的，也是最没有安全性的。所以使用的人很少\nECB 模式全称“Electronic CodeBook”模式，在 ECB 模式中，将明文分组加密之后的结果直接就是密文分组，中间不做任何的变换。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420134942.png)\n\n### CBC\nCBC 模式的全称是 Cipher Block Chaining 模式，密文分组链接模式。名字中也展示它的实质，像链条一样相互链接在一起。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420134859.png)\n\n### CTS\nCTS 模式(Cipher Text Stealing 模式)\n在分组密码中，当明文长度不能被分组长度整除的时候，最后一个分组就需要进行填充，CTS 模式是使用最后一个分组的前一个密文分组数据来进行填充的，它通常和 ECB 模式以及 CBC 模式配合使用。根据最后一个分组的发送顺序不同，CTS 模式有几种不同的变体(CBC-CS1、CBC-CS2、CBC-CS3)，下面举一个 CBC-CS3 的例子\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420134813.png)\n### CFB\nCFB 模式的全程是 Cipher FeedBack 模式(密文反馈模式)。在 CFB 模式中，前一个密文分组会被送到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420140055.png)\n如果把 CBC 单个分组加密抽出来和 CFB 分组对比，如下：\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420140114.png)\n从上图中我们可以看到，在 ECB 和 CBC 模式中，明文分组都是要通过加密算法处理的，但是 CFB 模式明文分组是没有经过加密算法直接加密的。CFB 模式中，明文和一串比特序列 XOR 以后就变成了密文分组。\n\n#### CFB 与流密码\nCFB 整个过程很像一次性密码本，如果把明文分组前的加密部分全部都看成一个随机比特序列，那么就和一次性密码本的流程一样了。这个由算法生成的比特序列称为**密钥流**。在 CFB 模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，初始化向量相当于是伪随机数生成器的种子。也因为它是伪随机数，所以 CFB 是不具备一次性密码本绝对无法被破译的性质的。所以说，**CFB 是一种使用分组密码来实现流密码的方式之一**。\n\n### OFB\nOFB 模式的全程是 Output-FeedBack 模式(输出反馈模式)。在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中。这里可以类比 CFB 模式。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420140311.png)\nOFB 也不直接对明文进行加密，也是通过利用明文和`一串比特序列`进行异或运算来得到密文。\n\n#### OFB 与 CFB 对比\nOFB 模式和 CFB 模式的区别仅仅在于密码算法的输入。OFB 模式是密码算法的输入是前一个密码算法的输出，所以称为输出反馈模式。CFB 模式是把前一个，密文分组输入到密码算法中，所以称为输入反馈模式。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420140524.png)\n从上图中我们可以看到，CFB 模式加密的过程是无法跳过某个分组对后面的分组加密的。因为它需要按照顺序进行加密。密文分组会重新输入到加密算法中。\n\n而 OFB 模式就不同，加密算法和密文分组完全是分开的，也就是说只要生成好每次 XOR 运算所需的密钥流，就可以“跳跃”加密任意分组了。这个看来，生成密钥流的操作和进行 XOR 运算的操作是可以并行的。\n\n### CTR\nCTR 模式的全程是 CounTeR 模式(计数器模式)。CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。\n计数器每次都会生成不同的 nonce 来作为计数器的初始值。这样保证每次的值都不同。这种方法就是用分组密码来模拟生成随机的比特序列。\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220424095043.png)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220424095026.png)\n#### OFB 与 CTR 对比\nCTR 模式和 OFB 模式都属于流密码。我们单独看两个加密过程，差异在输入到加密算法中的值不一样。CTR 模式输入的值是计数器累加的值，而 OFB 模式输入的值是上一次输出的值。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420140807.png)\nCTR 模式加密和解密都用了完全相同的结构，这样对程序实现来说，方便很多。更进一步，由于 CTR 模式每个密钥有累加的关系，所以可以通过这个关系，对任意一个分组进行加密和解密。因为只要初始的密钥确定以后，后面的每个密钥都确定了。这样看来，CTR 也是支持并行计算的。\n\n### XTS\nandroid文件加密的实现中使用了aes-256-xts模式:\n![](../OTA相关/加密方案整理.md#^61db89)\n\n用于面向分组的存储设备的  __XTS-AES__  模式 [167](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=166&x=186&y=71&id=28)\n\n基于扇区的设备上的数据进行加密的方法 [167](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=166&x=129&y=136&id=29)\n\n可以发现，如同  __CTR__  模式一样，  __XTS-AES__  模式适合并行执行。因为没有链接，多个分组可以同时加密或解密。与  __CTR__  不同的是，  __XTS-AES__  模式包含一个时变值（参数）以及一个计数器（参数  __j)__  。 [171](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=170&x=236&y=72&id=30)\n\n本质上，参数  j  的功能类似  __CTR__  模式里的计数器，以保证一个数据单元内**不同位置的相同明文分组加密为不同的密文分组**。参数从数据单元的层面上说相当于时变值，以保证两个不同的数据 [168](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=167&x=260&y=669&id=31)单元内相同位置相同明文分组加密为不同的密文分组。更一般地，它可以保证**位于不同位置的相同数据单元加密为不同的密文数据单元**。 [169](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=168&x=233&y=64&id=32)\n\n##### XTS 与CBC\nXTS 相比 ECB CBC解决的两个问题是:\n1. 相同的数据块得到的密文不可以相同\n2. 不同数据块可以独立加密和解密\n\n### CCM 和 GCM\n\n分组密码链-消息认证码  __(CCM)__  工作模式 [296](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=295&x=160&y=311&id=33)\nGalois/计数器  __(GCM)__  工作模式由  __NIST__  作为  __NIST SP800-38D__  标准提出，基于并行化设计，因此可以提供高效的吞吐率和低成本、低延迟。其本质是消息在变型的  __CTR__  模式下加密，密文结果与密钥以及消息长度信息在  __GF(2<sup>128</sup>)__  域上相乘。该标准同时还制定了仅支持  __MAC__  的工作模式，即GMAC  。 [298](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=297&x=251&y=153&id=35)\n\n认证加密：  __CCM__  和  GCM\n\n\n认证加密  __(AE)__  是指在通信中同时提供保密性和认证（完整性）的加密系统。许多应用和协议中都同时需要这两种形式的安全性保证，但这两类安全系统一直都分开设计，直到近几年才合并在一起考虑。 [295](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=294&x=240&y=603&id=3)\n\n组成  __CCM__  的关键算法是  __AES__  加密算法  __(参见第  6 章)、CTR  工作模式  (参见第  7  章)  和  CMAC认证算法  (参见  12__  .  __6__  节)  ，在加密和  __MAC__  算法中共用一个密钥  __K__  .  __CCM__  加密过程的输入包括三部分：\n(1)将要被认证和加密的数据，即明文消息  __P__  数据块。\n(2)将要被认证但不需加密的相关数据  __A__  ,例如在协议进行时，协议头必须以明文传递，但需要认证保护。\n(3)临时量  __N__  作为负载和相关数据的补充，对于每条消息在协议生命期内，  __N__  的取值唯一，这以防止重放攻击或其他相应的攻击。 [296](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=295&x=268&y=411&id=1)\n\nCCM （counter with CBC-MAC)定义在分组长度为128位的加密算法中，如，AES 的分组长度为128。组成AES-CCM算法的关键组成是CTR工作模式以及CMAC认证算法。Wifi 的WPE协议中使用了AES-CCM。在HMAC中我们介绍CCM是属于一种E&M（认证并且加密）\n\nGCM基于并行化设计，因此可以提供高效的吞吐率和低成本、低时延。本质是消息在变形的CTR模式下加密，密文结果与密钥以及消息长度在GF（2^128）域上相乘，计算流程如下所示。其输入输出和CCM基本一致。\n\nandroid 用户密码(锁屏密码) 导出为(data_ce)密码的过程使用了GCM模式\n![](../OTA相关/fbe与用户安全密码.md#^a300bf)\n\n## 小结\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420141006.png)\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>名称</th>\n<th>特点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ECB 模式</td>\n<td>Electronic Codebook</td>\n<td>运算快速，支持并行运算，需要填充</td>\n<td>不推荐使用</td>\n</tr>\n<tr>\n<td>CBC 模式</td>\n<td>Cipher Block Chaining</td>\n<td>支持并行运算，需要填充</td>\n<td>推荐使用</td>\n</tr>\n<tr>\n<td>CFB 模式</td>\n<td>Cipher Feedback</td>\n<td>支持并行运算，不需要填充</td>\n<td>不推荐使用</td>\n</tr>\n<tr>\n<td>OFB 模式</td>\n<td>Output Feedback</td>\n<td>迭代运算使用流密码模式，不需要填充</td>\n<td>不推荐使用</td>\n</tr>\n<tr>\n<td>CTR 模式</td>\n<td>Counter</td>\n<td>迭代运算使用流密码模式，支持并行运算，不需要填充</td>\n<td>推荐使用</td>\n</tr>\n<tr>\n<td>XTS 模式</td>\n<td>XEX-based tweaked-codebook</td>\n<td>不需要填充</td>\n<td>用于本地硬盘存储解决方案中</td>\n</tr>\n</tbody>\n</table>\n\n# RC4 (PRNG)\n\n流密码 (PRNG)\n\nRC4是  __Ron Rivest__  为  __RSA__  公司在  __1987__  年设计的一种流密码。它是一个可变密钥长度、面向字节操作的流密码。该算法以随机置换作为基础。每输出一字节的结果仅需要  __8~16__  条机器操作指令，软件实现的该密码运行很快。  __RC4__  应用很广，例如，它用于作为  __EEE802__  .  __11__  无线局域网标准一部分的  __WEP(Wired Equivalent Privacy)__  协议和新的WiFi 受保护访问协议  __(WPA)__  中。作为可选，它也被用于  __Secure Shell(SSH)__  和  __Kerberos__  中。 [198](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=197&x=252&y=455&id=9)\n\n\nRC4算法非常简单，易于描述：用  __1~256__  个字节  __(8~2048__  位)的可变长度密钥初始化一个256个字节的状态向量  __S__  ,  __S__  的元素记为  __S[0]__  ,  __S[1]__  ,…,  __S[255]__  ,从始至终置换后的  __S__  包含从  __0~255__  所有的  __8__  位数。对于加密和解密，字节  __k__  是从  __S__  的  __255__  个元素中按一种系统化的方式选出的一个元素生成的。每生成一个  __k__  值，S中的元素个体就被重新置换一次。 [198](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=197&x=261&y=559&id=8)\n\n\n# TRNG\n\n真随机数发生器 [200](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=199&x=129&y=391&id=10)\n\n真随机数发生器  __(TRNG)__  使用不可预测源来产生随机数。大多数是通过测量不可预测的自然过程来实现的，如电离辐射的脉冲检测、气体放电管、漏电电容等。  __Intel__  开发出一种芯片通过放大无驱动电阻的电压对热噪声进行采样。  __LavaRnd__  是一项开放的项目，目标是通过廉价的相机、开源的代码和廉价的硬件来产生真随机数。该系统使用密封的饱和式  __CCD__  作为混沌源来产生种子，然后用软件将种子加工成各种形式的真随机数。RFC4086__  列出了如下可能的随机源，这些都很容易用于计算机来产生真随机序列。\n - 声音/图像输入许多计算机具有对现实世界模拟信号进行数据化的输入设备，这些信号有来自麦克风的声音或来自照相机的声像输入。如果声音数字化设备没有音源插入或者照相机没打开镜头盖那么来自这些设备的输入本质上是热噪声。如果系统具有足够的增益来检测任何信号，这种输入可以提供高质量的随机位。\n - 磁盘驱动由于紊乱的空气波动，磁盘驱动在转动时有很小的随机波动 。加上一个底层磁盘时间寻找仪器就能产生一系列包含随机性的度量值。这样的数据通常都是高度相关的，所以需要有效的处理过程。然而，十年前的实验就表明，做过处理后，即使是当时低速计算机上的低速磁盘驱动器也能容易地每分钟产生  __100__  位或更多优质的随机数据。 [200](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=199&x=268&y=557&id=11)\n\n## PRNG 与 TRNG 比较\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114738.png)\n\n表  __8__.__5__  总结了  __PRNG__  和  __TRNG__  的主要差异。  __PRNG__  很有效，意味着它们能在短时间内生成许多数字：  __PRNG__  是确定性的，意味着对于一个给定的数字序列若序列的开始点已知，一段时间后会再生。若你的应用程序需要很多数字，有效性是一个很好的特性：若你在后面的阶段会重复相同的数字序列，确定性是很易实现的。  __PRNG__  通常是周期性的，这意味着序列最终会复制它自己。\nTRNG需要相当长时间生成数字，通常没有  __PRNG__  效率高。这在许多应用中会遇到困难。例如，银行或国家安全部门的密码系统每秒需要产生数百万的随机位。  __TRNG__  也没有确定性，意味着即使相同的序列出现若干次，一个给定的数字序列也不能复制。  __TRNG__  没有周期性。 [201](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=200&x=236&y=128&id=12)\n\n# HMAC\nHMAC 算法除了需要信息摘要算法外，还需要一个密钥\n目前主要集合了 MD 和 SHA 两大系列消息摘要算法。其中 MD 系列的算法有 HmacMD2、HmacMD4、HmacMD5 三种算法；SHA 系列的算法有 HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA512 五种算法。\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114747.png)\nHMAC  算法 [291](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=290&x=101&y=350&id=4)\nM为  __HMAC__  的消息输入 [291](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=290&x=98&y=417&id=6)\nK为密钥 [291](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=290&x=57&y=510&id=7)\n\n## 普通散列算法和 HMAC 算法的区别\n- 普通散列算法就是通过 hash 对要输出的数据进行摘要，接收到数据时，再同样对源数据进行散列，与给定的散列值比较，看收到的数据与计算的 hash 值是否一致就可以了。\n- HMAC 算法就可以用一把发送方和接收方都有的密钥 key 进行计算，而没有这个密钥 key 的第三方是无法计算出正确的散列值的，这样就可以防止数据的来源方被篡改。\n\n# RSA\n\n\n-   _p,q_：我们随机挑选的两个大质数； \n-   _N_：是由两个大质数_p_和_q_相乘得到的。_N = p * q_；\n-   _r_：由欧拉函数得到的_n_的值，_n = φ(N) = φ(p)φ(q) = (p-1)(q-1)_。\n-   _e_：随机选择和和r互质的数字，实际中通常选择 65537；\n-   _d_： d 是以欧拉定理为基础求得的 e 关于 n 的模反元素，_ed = 1 (mod r)_；\n\n此时我们的 *(N , e)* 是公钥，*(N, d)* 为私钥，A会把公钥 *(N, e)* 传给B，然后将 *(N, d)* 自己藏起来。一对公钥和私钥就产生了\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114749.png)\n\n## 加密\n*(N , e)* 是公钥，*(N, d)* 为私钥\nB 持有公钥\nB 对消息进行加密\nC = M<sup>e</sup> mod N       (M的e次方 mod N)\n\n## 解密\nA 持有私钥 *(N, d)* , 对消息进行解密\nM = C<sup>d</sup> mod N      (C的d次方 mod N)\n\n\n![RSA 算法举例](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114752.png)\n\n图  __9__.__6 RSA__  算法举例 [219](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=218&x=231&y=596&id=25)\n\nRSA算法使用乘方运算，明文以分组为单位进行加密，每个分组的二进制值均小于  N [218](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=217&x=240&y=164&id=21)\n\n采用分组的方法对消息分成块, 挨个进行加密解密\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114754.png)\n\n图  __9__.__7 RSA__  的加解密过程示例 [220](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=219&x=264&y=538&id=22)\n\n模算术里的求幂运算在  __RSA__  中，加密和解密都需要计算某整数的模  __n__  整数次幂，如果先求出整数的幂，再对取模，那么中间结果会非常大。幸运的是，正如前面的例子所示，我们可利用模算术的下列性质来计算模幂运算： [220](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=219&x=252&y=636&id=26)\n## 签名\n1. A计算消息m的消息摘要,记为 *h(m)*\n2. A使用私钥 *(n,d)* 对 *h(m)* 加密,生成签名s, s满足:*s=(h(m))<sup>d</sup> mod n*;\n   由于A是用自己的私钥对消息摘要加密,所以只用使用s的公钥才能解密该消息摘要,这样A就不可否认自己发送了该消息给B\n3. A发送消息和签名 *(m,s)* 给B\n\n## 验签\n1. B计算消息m的消息摘要(计算方式和A相同),记为 *h(m)*\n2. B使用A的公钥 *(n,e)* 解密*s*,得到 *H(m)*, *H(m) = s<sup>e </sup>mod n*\n3. B比较*H(m)* 与 *h(m)*,相同才能证明验签成功\n\n# ECDSA 椭圆曲线\n[ECC相关算法解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/103665076)\n\nq             一个素数\na  ,  b      Z<sub>q</sub>上的整数，通过等式  y2=x<sup>3</sup>+ax+b  定义椭圆曲线\nG            满足椭圆曲线等式的基点，表示为  G=(x<sub>g</sub>  ,  y<sub>g</sub>)\nn            点  __G__  的阶，即  __n__  是满足  nG=0  的最小正整数。这也等于曲线上点的个数 [316](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=315&x=246&y=355&id=19)\n\n## 生成公钥 私钥\n构造一条椭圆曲线*E*，在曲线上选择一点*G*作为生成元，并求*G*的阶为*n*，要求*n*必须为质数。\nA选择一个`私钥`*k* (*k* < n),生成`公钥` *Q = kG*\n公钥组(双方协同信息)  E Q G\n\n## 加密 (公钥加密)\n明文编码为*M*，*M*为曲线上一点，并选择一个随机数*r*（*r < n*, *n*为*G*的阶）\nB计算点*C<sub>1</sub>* 与 *C<sub>2</sub>* 即两段密文\n-   C<sub>1</sub> = M + rQ\n-   C<sub>2</sub> = rG\nB 把 *C<sub>1</sub>  C<sub>2</sub>* 发给 A\n## 私钥解密\n为获得明文*M*, 只需 *C<sub>1</sub>-kC<sub>2</sub>*\n\nC<sub>1</sub> - k*C<sub>2</sub> = M + rQ - krG = M + rkG - krG = M\n\n## 签名\n1.  选择一条椭圆曲线 Ep(a,b)，和基点 G；\n2.  选择私有密钥 k（k<n，n 为 G 的阶），利用基点 G 计算公开密钥 `Q=kG`；\n3.  产生一个随机整数 r（r<n），计算点 `R=rG`；\n4.  密文为 message，计算 SHA1(message) 做为 hash；\n5.  计算 `S≡r^-1  *(Hash + k * R.x)(mod n)`; 这里的 R.x 为 R 的横坐标\n6.  (R.x, S) 做为签名值\n\n## 验签\n1.  接收方在收到消息 m 和签名值 (R.x, S) 后，进行以下运算\n2.  计算明文 hash：`hash = SHA(m)`\n3.  计算 P 点：`P = S^-1 *(hash*G + R.x*Q)`\n4.  若 P 点的横坐标 P.x == R.x, 则说明校验成功。\n\n# ECC VS  RSA\n## 优点：\n-   安全性能更高\n-   160位ECC与1024位RSA、DSA有相同的安全强度\n-   处理速度更快\n    -   在私钥的处理速度上，ECC远 比RSA、DSA快得多\n\n-   带宽要求更低, 存储空间更小\n    -   ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多\n\n\n# 证书\n\nCA  用自己的私钥签署证书，如果用户知道相应的公钥，则用户就可以验证证书是  __CA__  签署的。 [339](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=338&x=243&y=244&id=16)\n\n![](https://cdn.jsdelivr.net/gh/LiguangZhang/tuchuang1@main/images/20220420114802.png)\n\n获得一个用户证书  __CA__  生成的用户证书具有以下特点：\n- 任何可以访问  __CA__  公钥的用户均可获得证书中的用户公钥。\n- 只有  __CA__  可以修改证书。 [339](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=338&x=192&y=556&id=17)\n\n如果所有用户都属于同一个  __CA__  ,则说明用户普遍信任  __CA__  ,所有用户的证书均被存放于同一个目录中，所有用户都可以进行存取。另外，用户也可以直接将其证书传给其他用户。一旦拥有了A的证书，  __B__  即可确信用  __A__  的公钥加密的消息是安全的、不可能被窃取，同时，用  __A__  的私钥签名的消息也不可能仿造。 [339](bookxnotepro://opennote/?nb={865a2b49-4feb-44ff-93ee-307e2e2938f8}&book=ec3eb5ad87ae108342f6c41f336e5752&page=338&x=244&y=637&id=18)\n","tags":["安全"],"categories":["安全","加密"]},{"title":"安全需求","url":"/2021/10/11/hxd_new/安全需求/","content":"\necu 固件恶意修改防护, 固件加密防护防止恶意破解访问或数字签名防护恶意篡改, 固件安全升级防护\n\nECU上网络服务器的使用应仅限于其必要的功能，服务端口应加以保护以防止未经授权的使用\n\n使用分段和隔离技术：特权分离与边界控制能够提升系统安全性。逻辑和物理隔离技术应用于将处理器、车辆网络和外部连接分开，以限制和控制外部威胁到车辆内部的路径。\n\n边界控制技术，如严格的基于白名单的段间消息过滤机制，应被用于保障接口访问安全\n\ndebug调试机制限制, 诊断操作需要尽可能施加较多的限制措施，例如限制某个诊断操作的影响范围或时间\n\n车辆内部通讯控制: **安全关键的消息尽量通过硬件隔离的安全总线传输**\n\n证书管理:  后台服务器访问控制：加密措施应用于任何基于IP的外部服务器和车辆之间的业务通信过程中。此类网络连接不应接受无效证书\n\n","tags":["汽车"],"categories":["安全"]},{"title":"bl 加密手册","url":"/2021/09/12/hxd_new/bl_guide/","content":"\n# 打开或者关闭加密\n\n```cmake\nexamples/usb/usb_mic/CMakeLists.txt\n# 打开加密\nset(BL_ENCRYPTING yes)\n# 关闭加密\nset(BL_ENCRYPTING no)\n```\n\n# 打开加密时的依赖项\n\n## 烧入efuse key\n\n![image-20211022162941641](image-20211022162941641.png)\n\nBouffaloLabDevCube -> View-> MCU -> Efuse Key\n\n三个需要改的地方, AES MODE 选 `None` !!!\n\n- ef_key_slot2(hex)     ce043c3e22ad711d4033c548970b0a7b  Write Lock Read Lock 打勾  \n\n- ef_key_slot3(hex)     0710340a96e1f0d3bbc355b2261b4c2b  Write Lock Read Lock 打勾  \n\n改完后, 点击软件上的`Create`按钮, 生成efuse数据文件\n\n板子和pc 使用typec 连接, 先按boot 按键0.5s, `boot`按键不要松开, 再接着另一个手指按`reset`按键, 两个按键一起按3s后, 两个按键同时松开, 此时按软件上的Refresh按钮, COM Port 中出现COM3, 选择COM3.\n\n> 此处COM3 端口和烧bin的端口是同一个\n\n点击软件上`Program` 按钮, 烧入生成的efuse数据文件.\n\n### 注意事项\n\n> !!! efuse key只能烧写一次, 千万不能写错\n\n> key信息 ce043c3e22ad711d4033c548970b0a7b 0710340a96e1f0d3bbc355b2261b4c2b  **!!! 一定要保密, 不能泄露**\n\n## 为不同的客户定制不同key\n\n产品可能会卖给多家客户,最好是为每一家客户定制一个key.\n\n在代码根目录下:\n\n```bash\ncd tools/bflb_flash_tool/packing\n# 重新生成一组aes_priv_key\n./pack -g -a aes_priv_key -d\n# 查看key的内容, 定制输出内容,一行16个字节,共输出两行,正好对应ef_key_slot的格式\nhexdump -e '16/1 \"%02x\" \"\\n\" ' -v aes_priv_key\nefecc505370c9fa7f4867a3236229246 #第一行填入上面efuse key烧录界面中的 ef_key_slot2\nfc3a6a3a593c934527268522c949ec04 #第二行填入上面efuse key烧录界面中的 ef_key_slot3\n# 返回代码根目录\ncd ../../../\n# 重新加壳, 用新生成的key重新生成.pack.bin\npython2 tools/bflb_flash_tool/packing/pack.py out/examples/usb/usb_mic/usb_mic.elf out/examples/usb/usb_mic/usb_mic.bin out/examples/usb/usb_mic/usb_mic.pack.bin\n```\n\n>最终生成产物名字不叫usb_mic.elf, 如为$target_name.elf, 则命令变为\n>\n>python2 tools/bflb_flash_tool/packing/pack.py out/examples/usb/usb_mic/$target_name.elf out/examples/usb/usb_mic/$target_name.bin out/examples/usb/usb_mic/$target_name.pack.bin\n\n最终生成的aes_priv_key和$target_name.pack.bin就是为该客户定制的.\n\n其中产线需要为该家客户烧录新生成的aes_priv_key和使用这个key重新加壳的$target_name.pack.bin \n\n## 产出\n\nmake 生成的文件,在打开加密时, 需要使用\n\n```bash\nout/examples/usb/usb_mic\nusb_mic.pack.bin\n```\n\n关闭加密时, 使用`usb_mic.bin`\n\n> 如果需要发布给客户, 请加密并提供`usb_mic.pack.bin`, 最好在给到客户前把`usb_mic.pack.bin`改下名字, 不要带pack字样\n>\n> 不要给客户elf文件, elf文件没有保护关键的算法代码, 会造成泄露\n\n# 加密后如何判断烧入板子后解密是否正常\n\n打开加密后make生成的log, 最后有crc的信息\n\n```bash\n[ 97%] Building C object examples/usb/usb_mic/CMakeFiles/usb_mic.elf.dir/__/__/__/bsp/bsp_common/platform/syscalls.c.obj\n[ 98%] Building C object examples/usb/usb_mic/CMakeFiles/usb_mic.elf.dir/__/__/__/bsp/board/bl702/board.c.obj\n[100%] Linking C executable ../../../out/examples/usb/usb_mic/usb_mic.elf\nGenerate /home/liguang/work_space/bl_mcu_sdk/out/examples/usb/usb_mic/usb_mic.bin\nCopy /home/liguang/work_space/bl_mcu_sdk/out/examples/usb/usb_mic/usb_mic.bin into download path\nsrc CRC result: 47324\n```\n\nbin烧入板子后, 运行的log有\n\n```bash\n  ____               __  __      _       _       _     \n |  _ \\             / _|/ _|    | |     | |     | |    \n | |_) | ___  _   _| |_| |_ __ _| | ___ | | __ _| |__  \n |  _ < / _ \\| | | |  _|  _/ _` | |/ _ \\| |/ _` | '_ \\ \n | |_) | (_) | |_| | | | || (_| | | (_) | | (_| | |_) |\n |____/ \\___/ \\__,_|_| |_| \\__,_|_|\\___/|_|\\__,_|_.__/ \n\nBuild:14:03:25,Oct 22 2021\nCopyright (c) 2021 Bouffalolab team\ndynamic memory init success,heap size = 35 Kbyte \nsrc crc result : 47324\n```\n\n两处的crc result 值相等, 证明解密正常\n\n","tags":["efuse"],"categories":["博流"]},{"title":"君正linux ota升级方案调研","url":"/2021/09/12/OTA相关/君正linux ota/君正linux ota升级方案调研/","content":"\n# 分区\n\n^b2c15f\n\n## nand\n\n```ini\n[storageinfo]\nmediumtype=nand\ncapacity=256MB\n[partition]\n# 分区名 偏移量 大小 设备名\nitem1=uboot,0x0,0x100000,mtdblock0\nitem2=nv,0x100000,0x100000,mtdblock1\nitem3=kernel,0x200000,0x800000,mtdblock2\nitem4=recovery,0xa00000,0x1000000,mtdblock3\nitem5=system,0x1a00000,0x5000000,mtdblock4\nitem6=userdata,0x6a00000,0x9300000,mtdblock5\n```\n\n# 升级主程序\n\n也叫recovery\n\n## 全局配置文件\n\n```c\nstruct global_data g_data = {\n    .public_key_path = \"/usr/data/ota_res/key/key.pub\",\n    .configure_file_path = \"/usr/data/ota_res/recovery.conf\",\n    .font_path = \"/usr/data/ota_res/image/font.png\",\n    .audio_path = \"/usr/data/ota_res/tips\",\n    .has_fb = 1,\n};\n```\n\n配置文件示例:\nrecovery.conf\n```c\n{\n  \"server\":{\n    \"ip\":\"192.168.1.105\",\n    \"url\":\"https://192.168.1.105\",\n    \"rpt_url\":\"\"\n  }\n}\n```\n\n## 类解析\n### configure_file 解析json 配置文件\n```c\nstruct configure_file {\n    void (*construct)(struct configure_file* this);\n    void (*destruct)(struct configure_file* this);\n    int (*parse)(struct configure_file* this, const char* path);\n    int (*parse_current_version)(struct configure_file* this);\n    void (*dump)(struct configure_file* this);\n    char *version;\n    char *server_ip;\n    char *server_url;\n};\n```\n调用`_new` 方法调用了`construct_configure_file` 函数进行初始化, 安装了 parse dump parse_current_version的指针, 最终调用 `parse_ota_configure` 方法解析了 recovery.conf的内容, 关注的字段就是 ip url rpt_url 这三个, 最后把ip url 传递到了 configure_file 类的成员变量 server_ip, `server_url` 中\n\n### signal_handler 类管理注册捕捉信号\n```c\nstruct signal_handler {\n    void (*construct)(struct signal_handler *this);\n    void (*destruct)(struct signal_handler *this);\n    void (*set_signal_handler) (struct signal_handler* this,\n            int signal, signal_handler_t handler);\n\n    struct sigaction action;\n};\n```\n调用`_new` 方法调用了`construt_signal_handler` 安装了 set_signal_handler 的函数指针\n捕捉 `SIGINT`, `SIGQUIT`, `SIGTERM` 信号, 设置为  SIG_IGN, 忽略这些信号的处理\n\n### update_file 类\n调用`_new` 方法调用了 `construct_update_file` 对其进行初始化,  安装了 `create_sha1_table` `get_device_info_by_devtype` 等的函数指针\n```c\nstruct update_file {\n\tvoid (*construct)(struct update_file* this);\n\tvoid (*destruct)(struct update_file* this);\n\n\tint (*parse_device_xml)(struct update_file* this, const char* path,\n\t\t\t\t\t\t\tstruct device_info* device_info);\n\tint (*parse_update_xml)(struct update_file* this, const char* path,\n\t\t\t\t\t\t\tstruct update_info* update_info);\n\tint (*parse_global_xml)(struct update_file* this, const char* path);\n\tint (*create_sha1_table)(struct update_file* this, const char* path);\n\n\tvoid (*dump_update_info)(struct update_file* this,\n\t\t\t\t\t\t\t struct update_info* update_info);\n\tvoid (*dump_device_info)(struct update_file* this,\n\t\t\t\t\t\t\t struct device_info* device_info);\n\n\tstruct update_info* (*get_update_info_by_devtype)(struct update_file* this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const char* devtype);\n\tstruct device_info* (*get_device_info_by_devtype)(struct update_file* this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const char* devtype);\n\n\tconst char** (*get_device_type_list)(struct update_file* this);\n\tvoid (*dump_device_type_list)(struct update_file* this);\n\n\tstruct list_head device_list;\n\tstruct list_head update_list;\n\tchar** sha1_table;\n\tint sha1_count;\n};\n```\n\n### net_interface 类 网络接口相关\n```c\nstruct net_interface {\n    void (*construct)(struct net_interface* this, const char* if_name);\n    void (*destruct)(struct net_interface* this);\n    int (*icmp_echo)(struct net_interface* this, const char* server_addr, int timeout);\n    int (*get_hwaddr)(struct net_interface* this, unsigned char *hwaddr);\n    int (*set_hwaddr)(struct net_interface* this, const unsigned char* hwaddr);\n    int (*get_addr)(struct net_interface* this, in_addr_t* addr);\n    int (*set_addr)(struct net_interface* this, in_addr_t addr);\n    int (*init_socket)(struct net_interface* this);\n    void (*close_socket)(struct net_interface* this);\n    int (*up)(struct net_interface* this);\n    int (*down)(struct net_interface* this);\n    cable_state_t (*get_cable_state)(struct net_interface* this);\n    int (*start_cable_detector)(struct net_interface* this, detect_listener_t listener, void* param);\n    void (*stop_cable_detector)(struct net_interface* this);\n    int(*ping)(const char *addr);\n\n    int socket;\n    int icmp_socket;\n    char* if_name;\n    detect_listener_t detect_listener;\n    void* detect_param;\n\n    cable_state_t cable_status;\n    int detect_pid;\n    bool detect_stopped;\n    bool detect_exit;\n    pthread_mutex_t detect_lock;\n    pthread_cond_t detect_cond;\n};\n```\n调用 construct_net_interface 进行初始化, 安装函数指针, 这个函数主要是网络收发相关的\n\n### block manager 类解析\n```c\nstruct block_manager {\n    void (*construct)(struct block_manager* this, const char *blockname,\n                      bm_event_listener_t listener, void* param);\n    void (*destruct)(struct block_manager* this);\n\n    void (*dump_event)(struct block_manager* this, struct bm_event* event);\n    void (*get_supported)(struct block_manager* this, char *buf);\n    void (*get_supported_filetype)(struct block_manager* this, char *buf);\n\n    int (*set_operation_option)(struct block_manager* this, struct bm_operation_option* opion,\n                                int method, char *filetype);\n    struct bm_operate_prepare_info* (*prepare)(struct block_manager* this,\n            int64_t offset, int64_t length, struct bm_operation_option *option);\n    int (*chip_erase)(struct block_manager* this);\n    int64_t (*erase)(struct block_manager* this, int64_t offset,\n                     int64_t length);\n    int64_t (*write)(struct block_manager* this, int64_t offset,\n                     char* buf, int64_t length);\n    int64_t (*read)(struct block_manager* this, int64_t offset, char* buf,\n                    int64_t length);\n    int (*format)(struct block_manager* this);\n\n    uint32_t (*get_prepare_io_size)(struct block_manager* this);\n    uint32_t (*get_prepare_leb_size)(struct block_manager* this);\n    int64_t (*get_prepare_write_start)(struct block_manager* this);\n    int64_t (*get_prepare_max_mapped_size)(struct block_manager* this);\n    int64_t (*finish)(struct block_manager* this);\n\n    int64_t (*get_partition_size_by_offset)(struct block_manager* this,\n                                            int64_t offset);\n    int64_t (*get_partition_size_by_name)(struct block_manager* this,\n                                          char *name);\n    int64_t (*get_partition_start_by_offset)(struct block_manager* this,\n            int64_t offset);\n    int64_t (*get_partition_start_by_name)(struct block_manager* this,\n                                           char *name);\n    int (*get_partition_count)(struct block_manager* this);\n    int64_t (*get_capacity)(struct block_manager* this);\n    int (*get_blocksize)(struct block_manager* this, int64_t offset);\n    int (*get_iosize)(struct block_manager* this, int64_t offset);\n    char* (*get_block_type)(struct block_manager* this, int64_t offset);\n    struct bm_operation_option operate_option;\n    struct bm_operate_prepare_info *prepared;\n    union bm_info desc;\n    struct bm_part_info *part_info;\n#ifdef BM_SYSINFO_SUPPORT\n    struct sysinfo_manager *sysinfo;\n#endif\n    char *name;\n    struct list_head  list_cell;\n    struct list_head  list_fs_head;\n    void* param;\n};\n\n```\n调用了 `construct_block_manager` 方法对其初始化, 安装函数指针, 注册 `bm_event_listener` 回调,\n设备层管理类, 是mtd类型的block.\n\n这里需要重点看下 `mtd_manager_init` 的实现\n\n#### mtd_block_init\n这个函数主要是从/sys/class/mtd 下读取各个mtd_block 设备的信息, 填充到`mtd_dev_info`中\n```c\nstruct mtd_dev_info\n{\n\tint mtd_num; //MTD device number\n\tint major; // major number of corresponding character device\n\tint minor; // minor number of corresponding character device\n\tint type; //flash type (constants like %MTD_NANDFLASH defined in mtd-abi.h)\n\tconst char type_str[MTD_TYPE_MAX + 1]; // static R/O flash type string\n\tconst char name[MTD_NAME_MAX + 1]; // device name\n\tlong long size; // device size in bytes\n\tint eb_cnt; // count of eraseblocks\n\tint eb_size; // eraseblock size\n\tint min_io_size; // minimum input/output unit size\n\tint subpage_size; //sub-page size\n\tint oob_size; // OOB size (zero if the device does not have OOB area)\n\tint region_cnt; // count of additional erase regions\n\tunsigned int writable:1; //zero if the device is read-only\n\tunsigned int bb_allowed:1; // non-zero if the MTD device may have bad eraseblocks\n};\n```\n```erlang\n+ mtd_block_init(struct block_manager* this)\n \\ - libmtd_open() \"组装/sys/class/mtd/mtd%d 作为前缀的路径, 填充给mtd_desc\"\n | -+ mtd_get_info(*mtd_desc, mtd_info) \"扫描出block_num 范围, 由highest_mtd_num lowest_mtd_num 界定\"\n    \\ - opendir(lib->sysfs_mtd) \"/sys/class/mtd\"\n    | -+ while\n       \\ - readdir(sysfs_mtd) \"/sys/class/mtd\"\n       | - sscanf(dirent->d_name, \"mtd%d\"\"%s\", &mtd_num, tmp_buf); \"扫描出block_num\"\n       | - info->mtd_dev_cnt += 1; \"扫描一共多少个block设备\"\n       | - info->highest_mtd_num = mtd_num; \"扫描出block_num\" 范围, 赋值给 highest_mtd_num\n       | - info->lowest_mtd_num = mtd_num; \"扫描出block_num\" 范围, 赋值给 lowest_mtd_num\n | -+ for (i = 0; i < mtd_info->mtd_dev_cnt; i++) \"遍历block 设备\"\n    \\ -+ mtd_get_dev_info1(*mtd_desc, i, mtd_dev_info)\n       \\ - dev_get_major(lib, mtd_num, &mtd->major, &mtd->minor) \"sprintf num填充libmtd_open函数组装好的%d占位代表了block_num的前缀, 获得dev的真实路径, /sys/class/mtd/mtd0/dev, 读取该路径, 获得major minor 号\"\n       | - dev_read_data(lib->mtd_name, mtd_num, &mtd->name, MTD_NAME_MAX + 1); \"跟上面过程一样, 获得name文件的内容, 填充到 mtd->name\"\n       | - dev_read_data(lib->mtd_type, mtd_num, &mtd->type_str, MTD_TYPE_MAX + 1);\n       | - dev_read_pos_int(lib->mtd_eb_size, mtd_num, &mtd->eb_size)\n       | - dev_read_pos_ll(lib->mtd_size, mtd_num, &mtd->size) 从\"/sys/class/mtd 下读取各个mtd_block 设备的信息, 填充到`mtd_dev_info ` bm->part_info[i].part.mtd_dev_info 中\"\n    | - int* fd = BM_GET_PARTINFO_FD(this, i); \"bm->part_info[i].fd\"\n    | - path = BM_GET_PARTINFO_PATH(this, i); \"(bm->part_info[i].path)\"\n    | - sprintf(path, \"%s%d\", MTD_CHAR_HEAD, mtd_dev_info->mtd_num); \"赋值 /dev/mtd/<block_num>\"\n    | - *fd = open(path, O_RDWR); \"打开 设备. 描述符保存到 bm->part_info[i].fd\"\n    | - BM_GET_PARTINFO_START(this, i) = size; \"保存该分区的起始位置 偏移量\"\n```\n\n这一节的内容与 [分区](#^b2c15f)那一节是能对应上的\n\n#### register_block_manager\n将该block_manager的实例挂到 block_manager_list链表中,  通过block_manager的成员在链表中匹配查找\n```c\nlist_add_tail(&this->list_cell, &block_manager_list);\n```\n\n#### mtd_install_filesystem\n\n注册文件系统, 注册了这几个文件系统, 将这几个文件系统的实例的 list_cell 挂到了 block_manager的 list_fs_head 成员的链表下. 并安装好了对应的函数指针\n\n```c\nstruct filesystem {\n    char *name;\n    struct list_head  list_cell;   // 挂入block_manager的 list_fs_head 的链表下\n    int (*init)(struct filesystem *fs);\n    int (*alloc_params)(struct filesystem *fs);\n    int (*free_params)(struct filesystem *fs);\n    void (*set_params)(struct filesystem* fs, char *buf, int64_t offset,\n                       int64_t length, int op_method, void *p,  void *fs_priv);\n    int (*format)(struct filesystem *fs);\n    int64_t (*erase)(struct filesystem *fs);\n    int64_t (*read)(struct filesystem *fs);\n    int64_t (*write)(struct filesystem *fs);\n    int64_t (*done)(struct filesystem *fs);\n    int64_t (*get_operate_start_address)(struct filesystem *fs);\n    unsigned long (*get_leb_size)(struct filesystem *fs);\n    int64_t (*get_max_mapped_size_in_partition)(struct filesystem *fs);\n    int tagsize;\n    unsigned int flag;\n    struct fs_operation_params *params;\n    void *priv;\n};\n```\n\n```c\nstatic struct filesystem* fs_supported_list[] = {\n    &fs_normal,\n    &fs_jffs2,\n    &fs_ubifs,\n    &fs_yaffs2,\n    &fs_cramfs,\n};\n```\n\n### 主升级管理类\nota_manager\n调用 `_new` 方法调用了 ota_manget的 construct_ota_manager 方法进行初始化, 安装了 start stop load_configure 等的函数指针, 初始化了 net_interface 类, 调用了其构造方法, 初始化了 block_manager类, 调用了其构造方法\n\n```c\nstruct ota_manager {\n    void (*construct)(struct ota_manager* this);\n    void (*destruct)(struct ota_manager* this);\n    int (*start)(struct ota_manager* this);\n    int (*stop)(struct ota_manager* this);\n    void (*load_configure)(struct ota_manager* this, struct configure_file* cf);\n    void (*load_signal_handler)(struct ota_manager* this, struct signal_handler* sh);\n    struct block_manager* mtd_bm; // 保存了block_manager类的实例\n    struct configure_file* cf; //保存了configure_file 类的实例, 前面解析的参数都在该实例中\n    struct signal_handler* sh; //保存了 signal_hander 类的实例\n    struct update_file* uf; // 保存了 update_file 类的实例\n    struct net_interface* ni; //保存了net_interface类的实例\n};\n```\n\n执行了 `start` 方法开启了 ota_manager, 这里是开了一个新线程, 用来执行升级任务\n线程执行入口是`main_task`\n\n### 升级线程\n\nmain_task\n主要函数是 update_devices, 这个函数比较长, 这里拆成两个部分, 分为预升级部分和升级部分,\n预升级部分主要是校验升级包, 解析设备中的分区信息, 解析升级包中的升级文件,  分析哪些分区以怎样的方式进行升级, 并将解析到的配置写到一个个记录升级相关的数据结构中\n\n#### 预升级部分\n```erlang\n+ void *main_task(void* param)\n\\ -- struct ota_manager* this = (struct ota_manager*) param; \"保存ota_manager的实例\"\n| -- this->sh->set_signal_handler(this->sh, SIGALRM, signal_handler); \"设置了 `SIGALRM` 的信号处理函数为 ota_manager的 `signal_handler` 函数, 处理超时消息\"\n| -- alarm(ALARM_TIME_OUT); \"设置超时线\" 30*60 s, 如果升级时长超过30 min, alarm的signal_handler 会进行处理\n| -- update_stages(UPDATE_START, NULL); \"打印log 开始升级\"\n| -- this->uf = _new(struct update_file, update_file); \"调用update_file构造函数, 安装对应的函数指针\"\n| -- ping_ota_server_success = try_ping_server(this, this->cf->server_ip); \"ping 升级服务器. 是否能ping 通, 否则停止\"\n| -- this->ni->icmp_echo(this->ni, this->cf->server_ip, 30000) \"发包, 检查服务器是否有回包, 无回包, 停止\"\n| -- this->cf->parse_current_version(this->cf); \"解析 server ip url\"\n| -+ update_devices(this)\n   \\ - creat_unzip_dir() \"创建解压路径 /tmp/update\"\n   | -+ download_and_create_sha1_table(this) \n      \\ - download_file(path, prefix_local_update_path) \"下载 server_url/sha1Tab 到 /tmp/update/ 下\"\n      | - this->uf->create_sha1_table(this->uf, path) \"update_file 类从sha1Tab 文件读出 sha_count个sha result entry, 保存到update_file 类的 sha1_table 数组中\"\n   | -+ download_and_parse_global_conf(this) \"global.xml 示例 <global><device type=\"opaque\">nor</device></global>\"\n      \\ - download_file(path, prefix_local_update_path) \"下载 server_url/global.xml 到 /tmp/update/ 下\"\n      | -+ this->uf->parse_global_xml(this->uf, path) \"解析global.xml 文件, 这一步主要是解析出block_device的flash 类型, 是nor nand mmc\"\n         \\ -+ for (node = mxmlFindElement(node, tree, \"device\")...\n            \\ - const char* devtype = mxmlGetOpaque(node);\n            | - device_type_list[i++] = devtype;\n            | - strcpy(device_info->type, devtype); \n            | - list_add_tail(&device_info->head, &this->device_list); \"挂入update_file的 device_list链表\"\n            | - strcpy(update_info->devtype, devtype);\n            | - list_add_tail(&update_info->head, &this->update_list); \"挂入update_file的 update_list链表\"\n   | - const char** device_type_list = this->uf->get_device_type_list(this->uf);\n   | -+ for (int i = 0; device_type_list[i]; i++) \"获取 parse_global_xml阶段挂入的device_list链表的数据\"\n      \\ - struct device_info* device_info = this->uf->get_device_info_by_devtype(this->uf, devtype);\n      | - struct update_info* update_info = this->uf->get_update_info_by_devtype(this->uf, devtype);\n      | -+ download_and_parse_update_conf(this, device_info, update_info, devtype)\n         \\ - download_file(path, prefix_local_update_path) \"下载server_url/<dev_type>/update000.zip 到/tmp/update/下\"\n         | -+ check_device_update_info(this, path, device_info, update_info) \"检查校验/tmp/update/update000.zip\"\n            \\ -+ check_pkg_sha1(this, path, 0)\n               \\ - buff = \"sha1sum path\"\n               | - strncmp(buff, this->uf->sha1_table[index], 40) \"与前面从sha1Tab 读出的count个entry的 第一个entry 比较是否一致, 一致表明 sha1 校验通过\"\n            | -+ verify_update_pkg(this, path)\n               \\ - load_keys(g_data.public_key_path, &nkeys) \"加载rsa公钥 /usr/data/ota_res/key/key.pub, 公钥有nkeys个, 挨个试, 有一个能验签通过即可\"\n               | -+ verify_file(path, keys, nkeys)\n                  \\ - fseek(f, -FOOTER_SIZE, SEEK_END) \"读文件尾\"\n                  | - fread(footer, 1, FOOTER_SIZE, f) != FOOTER_SIZE) \"读update000.zip的最后6个字节\"\n                  | - footer[2] != 0xff || footer[3] != 0xff) \"校验 footer 第3 和 第4 字节\" 如果不全为1, 校验失败\n                  | - comment_size = footer[4] + (footer[5] << 8); \"comment_size 第6个字节 high, 第5个字节low, 即16 字节\"\n                  | - eocd_size = comment_size + EOCD_HEADER_SIZE;\n                  | - signature_start = footer[0] + (footer[1] << 8); \"sinature_start 的位置\"\n                  | - fseek(f, -eocd_size, SEEK_END) \"EOCD recorder 块\"\n                  | - signed_len = ftell(f) + EOCD_HEADER_SIZE - 2; \"获取一共多少字节被签名了\"\n                  | - sha(f, 0, signed_len) \"获取该文件的被签名保护的文件块的 hash\"\n                  | -+ for (i = 0; i < numKeys; ++i) \"挨个pubkey 校验\"\n                     \\ - RSA_verify(pKeys+i, eocd + eocd_size - 6 - RSANUMBYTES, RSANUMBYTES, sha1) \"signature 存放的位置: eocd + eocd_size - 6 - RSANUMBYTES\"\n         \n            | -- unzip(path, prefix_local_update_path, NULL, 1) \"zlib 的minizip 方案解压 update000.zip 到 /tmp/update/下\"\n            | - sprintf(local_path, \"%s/%s\", prefix_local_update_path, prefix_device_xml); \"/tmp/update/device.xml\"\n            | -+ this->uf->parse_device_xml(this->uf, local_path, device_info) \"解析device.xml\", 查看示例 device.xml\n               \\ -+ for (node = mxmlFindElement(node, tree, \"item\") ...\n                  \\ - struct part_info* partition = calloc(1, sizeof(struct part_info));\n                  | - memcpy(partition->name, name, strlen(name));\n                  | - partition->offset = strtoull(offset_str, NULL, 0);\n                  | - partition->size = strtoull(size_str, NULL, 0);\n                  | - memcpy(partition->block_name, block_name, strlen(block_name));\n                  | - list_add_tail(&partition->head, &device_info->list); \"partion的信息挂到 device_info->list下\"\n            | -+ check_device_info(this, device_info) \"仅支持nor 和 nand 类型的rom\"\n               \\ -+ list_for_each(pos, &device_info->list) \"遍历device_info.xml中的 partition信息\"\n                  \\ - offset = this->mtd_bm->get_partition_start_by_name(this->mtd_bm, blkname);\n                  | - size = this->mtd_bm->get_partition_size_by_name(this->mtd_bm, blkname);\n                  | - (offset != info->offset) || (size != info->size) \"device_info.xml中的partition的信息与前面/sys/class/mtd下扫描出的各block_device即partition的信息进行比对, offset 和 size 一致才可以\"\n            | -- sprintf(local_path, \"%s/%s\", prefix_local_update_path, prefix_update_xml); \"/tmp/update/update.xml\"\n            | -+ this->uf->parse_update_xml(this->uf, local_path, update_info) \"解析升级包中的update.xml  查看示例 update.xml\"\n               \\ -+ for (node = mxmlFindElement(node, tree, \"image\")...)\n                  \\ - memcpy(image->name, name, strlen(name));\n                  | - memcpy(image->fs_type, fs_type, strlen(fs_type));\n                  | - image->offset = strtoull(offset_str, NULL, 0);\n                  | - image->size = strtoull(size_str, NULL, 0);\n                  | - image->update_mode = mxmlGetInteger(sub_node);\n                  | - image->chunksize = mxmlGetInteger(sub_node);\n                  | - image->chunkcount = mxmlGetInteger(sub_node);\n                  | - list_add_tail(&image->head, &update_info->list); \"解析各字段信息后以image为单位, 将升级信息挂入到update_info->list 链表\"\n            | -+ merge_imginfo_into_partinfo(this, device_info, update_info)\n               \\ -+ list_for_each(pos_devinfo, &device_info->list)\n                  \\ - part_info *part_info = list_entry(pos_devinfo, struct part_info, head); \"在 parse_device_xml 阶段扫描出的各device下的所有的partition分区信息, 遍历\"\n                  | -+ list_for_each(pos_update, &update_info->list) \"遍历所有待升级的分区镜像\"\n                     \\ - image_info* image_info = list_entry(pos_update, struct image_info, head);\n                     | - image_info->offset > part_info_left_boundary && image_info->offset <= part_info_right_boundary\n                         \"image_info的offset 落在 partition的 size 范围内, 说明该镜像是属于该分区的\"\n                     | - list_add_tail(&image_info->head_part, &part_info->list); \"镜像挂入分区的链表\"\n                     | - part_info->image_count++; \"一个分区有多个镜像, 这里的镜像可以理解为镜像的分片, 并不一定说明分区可以有多个镜像, 这里的image 概念是针对升级来说的\"\n                     | - part_info->total_chunks += image_info->chunkcount; \"待升级的总chunk\"\n    \n```\n\n#### 升级部分\n```erlang\n+ update_devices(struct ota_manager* this)\n\\ -+ for (int i = 0; device_type_list[i]; i++)\n   \\ - nv_read(sysinfo_flag_nv); sysinfo_flag_nv->start = SYSINFO_FLAG_NV_UPDATE_START; nv_write(sysinfo_flag_nv) \"标记升级start信息, 写到nv 文件中\"\n   | -+ update_images(this, device_info, update_info) \"通过之前的预升级部分的解析, 已经将待升级的存储设备信息和升级信息填充到了device_info 和 update_info下\"\n      \\ - list_for_each(sub_pos, &update_info->list) chunk_count += info->chunkcount; \"记录该存储设备的总的待升级的chunk数\"\n      | -+ list_for_each(pos_devinfo, &device_info->list)\n         \\ - struct part_info* part_info = list_entry(pos_devinfo, struct part_info, head); \"遍历该存储设备上所有的分区\"\n         | -+ if (part_info->image_count > 0) \"如果该分区需要升级\"\n            \\ - struct image_info* image_info = list_entry(pos_imageinfo, struct image_info, head_part); \"遍历该分区上所有待升级的镜像分片\"\n            | - nv_read(sysinfo_flag_nv); index = sysinfo_flag_nv->step + 1; \"nv文件记录升级index, 是待升级chunk的下标\"\n            | -+ for (int j = 1; j <= image_info->chunkcount; j++)\n               \\ - (path, \"%s/%s/%s%03d.zip\", this->cf->server_url, device_info->type, \"update\", chunk标记); \"下载升级包\"\n               | - download_file(path, prefix_local_update_path) \"下载到/tmp/update/下\"\n               | - check_pkg_sha1(this, path, index) \"校验zip的sha1\"\n               | - verify_update_pkg(this, path) \"校验zip的签名, 预升级中已经介绍过该流程, 不赘述\"\n               | - unzip(path, prefix_local_update_path, NULL, 1) \"解压pakage\"\n               | -+ update_package(this, update_info, part_info, image_info, path, j) \"只支持nand 或nor\"\n                  \\ - fd = open(path, O_RDWR); \"打开升级包的package\"\n                  | - first_image = list_entry(part_info->list.next, struct image_info, head_part);\n                  | - last_image = list_entry(part_info->list.prev, struct image_info, head_part);\n                  | - bm->set_operation_option(bm, &option, BM_OPERATION_METHOD_PARTITION, image_info->fs_type) \"chunk_index 为 1时 初始化\"\n                  | -+ bm_operate_prepare_info* prepare_info = bm->prepare(bm, image_info->offset, image_info->size, &option) \"mtd_block_prepare\"\n                     \\ - default_filetype = option->filetype;\n                     | - fs = fs_get_registered_by_name(&this->list_fs_head, default_filetype) \"根据待升级的镜像的文件系统类型得到对应的文件系统的实例指针\"\n                     | -+ prepare_convert_params(this, fs, offset, length, option);\n                        \\ - fs->set_params(fs, NULL, offset, length, op_method, mtd, this); \"对应文件系统的实例设置升级参数\"\n                     | - mtd_get_prepare_info(this, fs, fs->get_operate_start_address(fs),\n                                mtd_get_blocksize_by_offset(this, offset),\n                                fs->get_leb_size(fs),\n                                fs->get_max_mapped_size_in_partition(fs)); \"填充 prepare_info 及 fs->params 相关结构\"          \n                  | - write_buffer_size = bm->get_prepare_leb_size(bm); \"获取前面填充的prepare_info信息\"\n                  | - write_media_leap = bm->get_blocksize(bm, image_info->offset);\n                  | - write_buffer = malloc(write_buffer_size);\n                  | - bm->erase(bm, image_info->offset, bm->get_partition_size_by_offset(bm, image_info->offset))\n                     \"擦除待升级镜像分片所在的[offset, offset+size] 区域\"\n                  | - cur_write_offset = bm->get_prepare_write_start(bm); \"从prepare_info 中获取 fs->params->offset转化后的write_start 偏移\"\n                  | - char *buffer = write_buffer;\n                  | -+ while(filesize)\n                     \\ - readsize = MIN(filesize, write_buffer_size);\n                     | - read(fd, buffer + already_read, readsize - already_read) \"读取升级包package的内容\"\n                     | -+ next_write_offset = bm->write(bm, cur_write_offset, write_buffer, readsize); \"写入对应分区\"\n                        \\ -+ fs = data_transfer_params_set(this, offset, buf, length)\n                           \\ - fs = bm->prepared->context_handle; \"从prepare_info 信息找到 fs的实例\"\n                           | - fs->params->offset = offset; ... \"设置fs write 相关的参数\"\n                        | - fs->write(fs);\n                     | - filesize -= readsize;\n                     | - cur_write_offset = next_write_offset;\n                 | -+ !strcmp(last_image->name, image_info->name)  && (chunk_index == image_info->chunkcount)) \"判断实际完当前partition的条件\"\n                    \\ -+ bm->finish(bm);\n                       \\ -+ mtd_block_finish(struct block_manager* this)\n                          \\ 文件系统 *fs = BM_GET_PREPARE_INFO_CONTEXT(this);\n                          | - fs->done(fs);\n               | - sysinfo_flag_nv->step = index; nv_write(sysinfo_flag_nv) \"持久化升级step\"\n               | - set_process_info(this, BM_OPERATION_WRITE, index, chunk_count); \"通知升级进度\"\n   | - sysinfo_flag_nv->finish = SYSINFO_FLAG_NV_UPDATE_DONE; nv_write(sysinfo_flag_nv) \"标记该存储设备已经升级结束, 写到nv文件中记录\"\n```\n调用具体文件系统的方法进行更新\n\n## 附录 \n### device.xml\n```xml\n<?xml version='1.0' encoding='utf-8'?>\n<device capacity=\"0x10000000\" type=\"nand\">\n<partition count=\"6\">\n\n<item>\n<name type=\"opaque\">uboot</name>\n<offset>0x0</offset>\n<size>0x100000</size>\n<blockname type=\"opaque\">mtdblock0</blockname>\n</item>\n\n<item>\n<name type=\"opaque\">nv</name>\n<offset>0x100000</offset>\n<size>0x100000</size>\n<blockname type=\"opaque\">mtdblock1</blockname>\n</item>\n\n<item>\n<name type=\"opaque\">kernel</name>\n<offset>0x200000</offset>\n<size>0x800000</size>\n<blockname type=\"opaque\">mtdblock2</blockname>\n</item>\n\n<item>\n<name type=\"opaque\">recovery</name>\n<offset>0xa00000</offset>\n<size>0x1000000</size>\n<blockname type=\"opaque\">mtdblock3</blockname>\n</item>\n\n<item>\n<name type=\"opaque\">system</name>\n<offset>0x1a00000</offset>\n<size>0x7600000</size>\n<blockname type=\"opaque\">mtdblock4</blockname>\n</item>\n\n<item>\n<name type=\"opaque\">userdata</name>\n<offset>0x9000000</offset>\n<size>0x6d00000</size>\n<blockname type=\"opaque\">mtdblock5</blockname>\n</item>\n\n</partition>\n</device>\n```\n\n### update.xml\n```xml\n<?xml version='1.0' encoding='utf-8'?>\n<update devcontrol=\"0x0\" devtype=\"nand\">\n<imagelist count=\"3\">\n<image><name type=\"opaque\">kernel_recovery</name>\n<type type=\"opaque\">normal</type>\n<offset>0xa00000</offset>\n<size>10571840</size>\n<pkgidx>1</pkgidx>\n<bootmode><type type=\"integer\">0x0</type></bootmode>\n<updatemode>\n<pkgtype type=\"opaque\">fullpkg</pkgtype>\n<type type=\"integer\">0x201</type>\n<chunksize type=\"integer\">1048576</chunksize>\n<chunkcount type=\"integer\">11</chunkcount>\n</updatemode>\n</image>\n\n<image>\n<name type=\"opaque\">kernel</name>\n<type type=\"opaque\">normal</type>\n<offset>0x200000</offset>\n<size>4725200</size>\n<pkgidx>12</pkgidx>\n<bootmode><type type=\"integer\">0xcc</type></bootmode>\n<updatemode>\n<pkgtype type=\"opaque\">fullpkg</pkgtype>\n<type type=\"integer\">0x201</type>\n<chunksize type=\"integer\">1048576</chunksize>\n<chunkcount type=\"integer\">5</chunkcount>\n</updatemode>\n</image>\n\n<image>\n<name type=\"opaque\">system.ubifs</name>\n<type type=\"opaque\">ubifs</type>\n<offset>0x1a00000</offset>\n<size>90025984</size>\n<pkgidx>17</pkgidx>\n<bootmode><type type=\"integer\">0xcc</type></bootmode>\n<updatemode><pkgtype type=\"opaque\">fullpkg</pkgtype>\n<type type=\"integer\">0x201</type>\n<chunksize type=\"integer\">1015808</chunksize>\n<chunkcount type=\"integer\">89</chunkcount>\n</updatemode>\n</image>\n</imagelist>\n</update>\n```\n\n### update 数据包结构\n\n待升级三个分区, kernel recovery 和 system\n每个分区对应的镜像分片信息记录在了 `update.xml` 中, 其中:\n- recovery的镜像名为 `kernel_recovery` 一共11个镜像分片\n- kernel 的镜像名为`kernel`, 一共5个镜像分片\n- system分区的镜像名为 `system.ubifs`, 一共89个镜像分片\n\n> update.xml中的 image->name  镜像名与分区的对应关系是以 image->offset 偏移与device.xml中part->offset 的值来映射的, image->offset落在[part->offset,  part->offset+part->size ]范围内, 说明该镜像是属于这个part.\n\n\n一共`11+5+89` 个update.zip 镜像分包, 加上update000.zip, 一共116个子包\n```bash\nupdate000/update000/\n├── device.xml\n└── update.xml\nupdate001/update001/\n└── kernel_recovery_001\n...\nupdate011/update011/\n└── kernel_recovery_011\nupdate012/update012/\n└── kernel_001\n...\nupdate016/update016/\n└── kernel_005\nupdate017/update017/\n└── system.ubifs_001\n...\nupdate105/update105/\n└── system.ubifs_089\n```","tags":["OTA"],"categories":["OTA","linux","君正"]},{"title":"bl efuse 操作 api","url":"/2021/09/11/hxd_new/博流efuse/","content":"\n```c\n/****************************************************************************/ /**\n * @brief  Efuse lock reading for aes key\n *\n * @param  index: index of key slot\n * @param  program: program to efuse entity or not\n *\n * @return None\n *\n*******************************************************************************/\nvoid EF_Ctrl_Readlock_AES_Key(uint8_t index, uint8_t program)\n{\n    uint32_t tmpVal;\n\n    if (index > 5) {\n        return;\n    }\n\n    /* Switch to AHB clock */\n    EF_Ctrl_Sw_AHB_Clk_0();\n\n    tmpVal = BL_RD_REG(EF_DATA_BASE, EF_DATA_0_LOCK);\n    tmpVal |= (1 << (index + 26));\n    BL_WR_REG(EF_DATA_BASE, EF_DATA_0_LOCK, tmpVal);\n\n    if (program) {\n        EF_Ctrl_Program_Efuse_0();\n    }\n}\n\n/****************************************************************************/ /**\n * @brief  Efuse write AES key\n *\n * @param  index: index of key slot\n * @param  keyData: key data buffer\n * @param  len: key data length in words\n * @param  program: program to efuse entity or not\n *\n * @return None\n *\n*******************************************************************************/\nvoid EF_Ctrl_Write_AES_Key(uint8_t index, uint32_t *keyData, uint32_t len, uint8_t program)\n{\n    uint32_t *pAESKeyStart0 = (uint32_t *)(EF_DATA_BASE + 0x1C);\n\n    if (index > 5) {\n        return;\n    }\n\n    /* Switch to AHB clock */\n    EF_Ctrl_Sw_AHB_Clk_0();\n\n    /* Every key is 4 words len*/\n    BL702_MemCpy4(pAESKeyStart0 + index * 4, keyData, len);\n\n    if (program) {\n        EF_Ctrl_Program_Efuse_0();\n    }\n}\n```\n\n代码示例:\n\n假设key为\n\n```c\nuint32_t *keyData = {\n    0x41cb3b9a,\n    0x7cf9f7cf,\n    0xdc0dd12f,\n    0x6c3ed53a,\n    0x00a0c824,\n    0xc737923e,\n    0xe2f055f1,\n    0x34afa0f7,\n}\n// 写入key_slot2 key_slot3\nEF_Ctrl_Write_AES_Key(2, keyData, 8, 1);\n```\n\n先做实验, 验证key_slot2, key_slot3 是否正常写入\n\n```c\n/****************************************************************************/ /**\n * @brief  Efuse read AES key from specified region and index\n *\n * @param  index: index of key slot\n * @param  keyData: key data buffer\n * @param  len: key data length in words\n *\n * @return None\n *\n*******************************************************************************/\nvoid EF_Ctrl_Read_AES_Key(uint8_t index, uint32_t *keyData, uint32_t len)\n{\n    uint32_t *pAESKeyStart0 = (uint32_t *)(EF_DATA_BASE + 0x1C);\n\n    if (index > 5) {\n        return;\n    }\n\n    /* Trigger read data from efuse*/\n    EF_CTRL_LOAD_BEFORE_READ_R0;\n\n    /* Every key is 4 words len*/\n    BL702_MemCpy4(keyData, pAESKeyStart0 + index * 4, len);\n}\n```\n\n示例代码, 读取key_slot2, key_slot3的key数据\n\n```c\nuint32_t keyRead[8] = {0};\nEF_Ctrl_Read_AES_Key(2, keyRead, 8);\n```\n\n判断keyRead 与 keyData 是否一致\n\n\n\n如果前面写入正常, 最后需要对key_slot2, key_slot3 做读保护\n\n```c\n// 写read lock, 读保护key_slot2\nEF_Ctrl_Readlock_AES_Key(2, 1);\n// 读保护key_slot3\nEF_Ctrl_Readlock_AES_Key(3, 1);\n```\n\n","tags":["efuse"],"categories":["博流"]},{"title":"MIPS 杂项","url":"/2021/09/11/hxd_new/安全手册相关/","content":"\n# MIPS 相关理解\n\n\n## 协处理器\n\n在MIPS体系结构中，最多支持4个协处理器(Co-Processor)。其中，协处理器`CP0`是体系结构中必须实现的。它起到控制CPU的作用。MMU、异常处理、乘除法等功能，都依赖于协处理器CP0来实现。它是MIPS的精髓之一，也是打开MIPS特权级模式的大门。\n\n       - Register 0: Index，作为MMU的索引用。将来讨论MMU和TLB时会详解之。\n       - Register 2, EntryLo0，访问TLB Entry偶数页中的地址低32Bit用。同上，在MMU和TLB的相关章节中详解。\n       - Register 3, EntryLo1，访问TLB Entry奇数页中的地址低32Bit用。\n       - Register 4, Context，用以加速TLB Miss异常的处理。\n       - Register 5, PageMask，用以在MMU中分配可变大小的内存页。\n       - Register 8, BadVAddr，在系统捕获到TLB Miss或Address Error这两种Exception时，发生错误的虚拟地址会储存在该寄存器中。对于引发Exception的Bug的定位来说，这个寄存器非常重要。\n       - `Register 9`, Count，这个寄存器是R4000以后的MIPS系统引入的。它是一个计数器，`计数频率是系统主频的1/2`。BCM1125/1250，RMI XLR系列以及Octeon的Cavium处理器均支持该寄存器。对于操作系统来说，`可以通过读取该寄存器的值来获取tick的时基`。`在系统性能测试中，利用该寄存器也可以实现打点计数`。\n       - Register 10，EntryHi，这个寄存器同EntryLo0/1一样，用于MMU中。以后会详述。\n       - Register 11，Compare，配合Count使用。当Compare和Count的值相等的时候，会触发一个硬件中断(Hardware Interrupt)，并且总是使用Cause寄存器的IP7位。　　\n       - Register 12，Status，用于处理器状态的控制。\n       - Register 13，Cause，这个寄存器体现了处理器异常发生的原因。\n       - 　　Register 14，EPC，这个寄存器存放异常发生时，系统正在执行的指令的地址。\n       - 　　Register 15，PRID，这个寄存器是只读的，标识处理器的版本信息。向其中写入无意义。\n   - 　　Register 18/19，WatchLo/WatchHi，这对寄存器用于设置硬件数据断点(Hardware Data Breakpoint)。该断点一旦设定，当CPU存取这个地址时，系统就会发生一个异常。这个功能广泛应用于调试定位内存写坏的错误。\n          　　Register 28/29，TagLo和TagHi，用于高速缓存(Cache)管理。\n\n相关链接 [协处理器CP0](https://blog.csdn.net/jiura/article/details/6645277)\n\n### 常用汇编指令\n\nMFC0、MTC0、DMFC0、DMTC0可以完成通用寄存器和CP0寄存器之间的数据传送。比如我们可以通过下面指令来获取epc寄存器的值。\n\n                 mfc0 t1,$14           # 从CP0 取epc寄存器（$14）数据，存到通用寄存器t0\n\nmfc0完成从cp0寄存器获取一个32位数据（如果cp0寄存器是64位数据则只取其低32位。）到通用寄存器，如果要获取的是64位数据则需要使用dmfc0指令。\n\n注意：和CP0相关的指令执行都需要特权模式，比如上面的mfc0指令的运行需要root权限或者sudo才可以运行。所以在一般用户程序中很少见到这些CP0相关的控制指令。\n\n## ldscripts link.ld 语法相关\n\n相关理解总结在 [**linux 中链接脚本 ld 文件详解**](https://www.yuque.com/huakaibanxia-loogp/simpread/1617787139204)\n\n这里总结下用到的大概率用到的知识点：\n\n### LMA VMA\n\n目标文件的每个 `section` 至少包含两个信息: 名字和大小. 大部分 section 还包含与它相关联的一块数据, 称为 section contents(section 内容). 一个 section 可被标记为 “loadable(可加载的)” 或“allocatable(可分配的)”.\n\n\n\n- loadable section: 在输出文件运行时, 相应的 section 内容将被载入进程地址空间中.\n\n- allocatable section: 内容为空的 section 可被标记为 “可分配的”. 在输出文件运行时, 在进程地址空间中空出大小同 section 指定大小的部分. 某些情况下, 这块内存必须被置零.\n\n> 如果一个 section 不是 “可加载的” 或“可分配的”, 那么该 section 通常包含了调试信息. 可用 objdump -h 命令查看相关信息.\n\n每个 “可加载的” 或“可分配的”输出 section 通常包含两个地址: `VMA`(virtual memory address 虚拟内存地址或程序地址空间地址)和 `LMA`(load memory address 加载内存地址或进程地址空间地址). 通常 VMA 和 LMA 是相同的.\n\n> 在嵌入式系统中, 经常存在加载地址和执行地址不同的情况: 比如将输出文件加载到开发板的 flash 中 (由 LMA 指定), 而在运行时将位于 flash 中的输出文件复制到 SDRAM 中 (由 VMA 指定).\n\nLMA是加载地址(镜像执行之前位于存储器中的地址, 称为加载时地址), 需要将该地址的数据拷贝到对应的VMA段下. VMA是实际映射到内存中的地址, 可以通过map文件查看\n\n> -M 或者 -Map 指令指定输出到map文件, map 应该类似于进程执行时 map 内存映射 (刨除基地址)\n\n### 定位符号 .\n\n. 是一个特殊的符号，它是定位器，一个位置指针,  指向程序地址空间内的某位置 (如果它在 SECTIONS 命令内的某 section 描述内, 指的是在该section 内的偏移)\n\n> 该符号只能在 SECTIONS 命令内使用   `.`始终指的是运行时的地址 VMA, 与LMA无关\n\n### SECTIONS 命令\n\nSECTIONS 命令告诉 ld 如何把输入文件的 sections 映射到输出文件的各个 section: 如何将输入 section 合为输出 section; 如何把输出 section 放入程序地址空间 (VMA) 和进程地址空间(LMA). 该命令格式如下:\n\n```\nSECTIONS\n{\nSECTIONS-COMMAND\nSECTIONS-COMMAND\n…\n}\n```\n\nSECTION-COMMAND 有四种:\n\n- (1) ENTRY 命令\n\n- (2) 符号赋值语句\n\n- (3) 一个输出 section 的描述 (output section description)\n\n- (4) 一个 section 叠加描述 (overlay description)\n\n> 如果整个连接脚本内没有 SECTIONS 命令, 那么 ld 将所有同名输入 section 合成为一个输出 section 内, `各输入 section 的顺序为它们被连接器发现的顺序`.\n>\n> 如果某输入 section 没有在 SECTIONS 命令中提到, 那么该 section 将被直接拷贝成输出 section。\n\n#### 输出 section 描述\n\n输出 section 描述具有如下格式:\n\n```c\nSECTION [ADDRESS] [(TYPE)] : [AT(LMA)]\n{\nOUTPUT-SECTION-COMMAND\nOUTPUT-SECTION-COMMAND\n…\n} [>REGION] [AT>LMA_REGION] [:PHDR  HDR ...] [=FILLEXP]\n```\n\n> [ ] 内的内容为可选选项, 一般不需要.\n\n每个` OUTPUT-SECTION-COMMAND `为以下四种之一，\n\n- 符号赋值语句\n- 一个输入 section 描述\n- 直接包含的数据值\n- 一个特殊的输出 section 关键字\n\n##### 前面部分 SECTION [ADDRESS] [(TYPE)] : [AT(LMA)]\n\n###### 输出 section 名字 (SECTION)\n\n输出 section 名字必须符合输出文件格式要求，比如：a.out 格式的文件只允许存在. text、.data 和. bss section 名。而有的格式只允许存在数字名字，那么此时应该用引号将所有名字内的数字组合在一起；另外，还有一些格式允许任何序列的字符存在于 section 名字内，此时如果名字内包含特殊字符 (比如空格、逗号等)，那么需要用引号将其组合在一起。\n\n###### 输出 section 地址 (ADDRESS)\n\nADDRESS 是一个表达式，它的值用于设置 `VMA`。\n\n> - 如果没有该选项且有 `REGION` 选项，那么连接器将根据 REGION 设置 VMA；\n>\n> - 如果也没有 REGION 选项，那么连接器将根据定位符号 `.` 的值设置该 section 的 VMA，将定位符号的值调整到满足输出 section 对齐要求后的值，\n\n输出 section 的对齐要求为：该输出 section 描述内用到的所有输入 section 的对齐要求中最严格的。\n\n例子：\n\n```\n1   .text . : {*(.text) }\n2   .text : {*(.text) }\n```\n\n第一个 `.` 定义了输出VMA的地址，说明是根据当前的定位指针的偏移设置 VMA的\n\n第二个 没有定义 输出DMA，也没有REGION， 则根据定位符号 `.`　对齐后的值　输出 VMA\n\n>ADDRESS 可以是一个任意表达式，比如 ALIGN(0×10) 这将把该 section 的 VMA 设置成定位符号的修调值，满足 16 字节对齐后的。\n\n> 注意：`设置 ADDRESS 值，将更改定位符号的值。`\n\n###### TYPE \n\n每个输出 section 都有一个类型，如果没有指定 TYPE 类型，那么连接器根据输出 section 引用的输入 section 的类型设置该输出 section 的类型。\n\n它可以为以下五种值，\n\n1. NOLOAD ：该 section 在程序运行时，不被载入内存。\n2. DSECT\n3. COPY\n4. INFO\n5. OVERLAY 支持这些类型名称以实现向后兼容，并且很少使用。 它们都具有相同的效果：该段应标记为不可分配，以便在程序运行时不为该段分配内存\n\n###### [AT(LMA)]\n\n默认情况下，LMA 等于 VMA，但可以通过关键字 AT() 指定 LMA。\n\n用关键字 AT() 指定，括号内包含表达式，表达式的值用于设置 LMA。如果不用 AT() 关键字，那么可用 `AT>LMA_REGION` 表达式设置指定该 section 加载地址的范围。   这个属性主要用于构件 ROM 境象。\n\n```\nSECTIONS\n{\n.text 0×1000 : \n {\n *(.text);\n _etext = . ;  \n }\n.mdata 0×2000 : AT (ADDR (.text) + SIZEOF (.text) )\n  {\n  _data = . ; \n  *(.data);\n  _edata = . ; \n  }\n.bss 0×3000 :\n  {\n  bstart = . ;\n  *(.bss) *(COMMON) ;\n  _bend = . ;\n  }\n}\n```\n\n```c\nextern char etext, data, edata, bstart, _bend;\nchar *src = &_etext; \nchar *dst = &_data;  \nwhile (dst < &_edata) {\n  dst++ = src++;\n}\nfor (dst = &bstart; dst< &_bend; dst++)\n  *dst = 0;\n```\n\n此程序将处于 ROM内的已初始化数据拷贝到 mdata段的相应区域，并将未初始化数据置零\n\n##### 中间部分 `` OUTPUT-SECTION-COMMAND ``\n\n每个` OUTPUT-SECTION-COMMAND `为以下四种之一，\n\n- 符号赋值语句\n\n- 一个输入 section 描述\n\n- 直接包含的数据值\n\n- ###### 一个特殊的输出 section 关键字\n\n###### 输入 section 描述\n\n最常见的输出 section 描述命令是输入 section 描述。\n\n输入 section 描述是最基本的连接脚本描述。\n\n语法 `FILENAME([EXCLUDE_FILE (FILENAME1 FILENAME2 ...) SECTION1 SECTION2 ...)`\n\n- FILENAME 文件名，可以是一个特定的文件的名字，也可以是一个字符串模式。\n\n- SECTION 名字，可以是一个特定的 section 名字，也可以是一个字符串模式\n\n  例子:\n\n  - *(.text) ：表示所有输入文件的. text section\n\n  - (*(EXCLUDE_FILE ( *crtend.o *otherfile.o) .ctors)) ：表示除 crtend.o、otherfile.o 文件外的所有输入文件的. ctors section。\n\n  - data.o(.data) ：表示 data.o 文件的. data section\n\n  - data.o ：表示 data.o 文件的所有 section\n\n  - *(.text .data) ：表示所有文件的. text section 和. data section，顺序是：第一个文件的. text section，第一个文件的. data section，   第二个文件的. text section，第二个文件的. data section，...\n\n  - *(.text)   * (.data) ：表示所有文件的. text section 和. data section，顺序是：第一个文件的. text section，第二个文件的. text section，...，最后一个文件的. text section，第一个文件的. data section，第二个文件的. data section，...，最后一个文件的. data section\n\n##### 前面部分 SECTION [ADDRESS] [(TYPE)] : [AT(LMA)]\n\n##### 后半部分 [>REGION] [AT>LMA_REGION] [:PHDR  :FILEHDR ...] [=FILLEXP]\n\n###### [>REGION]\n\n可以将输出 section 放入预先定义的内存区域内\n\n```\nMEMORY { rom : ORIGIN = 0×1000, LENGTH = 0×1000 }\nSECTIONS {ROM : { *(.text) } >rom }\n```\n\n> 这个地方应该是放在VMA中, 注意这里输出到 预定的内存区域后, 连带会把` .` 改为 预定内存区域的地址(第一次出现), 然后执行section 内的语句\n>\n> ld脚本section 是按顺序解析的, 第一次出现时 会将 `.`定界, 后面的section 如果都放在和该section相同的内存区域时, `.` 会累加 section的size.\n\n###### [:PHDR  :FILEHDR ... ] 这里显示的是段名 \n\n> 不需要深究, 详细见https://sourceware.org/binutils/docs/ld/PHDRS.html\n\nlinker脚本中的PHDRS命令需要与SECTIONS命令结合起来看,否则不容易理解.\n\n```cPHDRS\nPHDRS\n{\n text PT_LOAD FILEHDR PHDRS ;\n data PT_LOAD ;\n}\nSECTIONS\n{\n .text : { *(.text) } :text   // :text 是 PHDRS 里定义的段名\n .data : { *(.data) } :data   // :data 是 PHDRS 里定义的段名\n}\n```\n\n> ld以该脚本对输入文件进行链接,输出文件中将会包含两个section:.text和.data\n> 以SECTIONS命令中的第一行为例:  .text : { *(.text) } :text\n> 这句话是说将输入文件中所有的.text section (中间的 *(.text)) 都链接到输出文件的.text section中.\n> 并将输出文件中的.text section`分配到PHDRS命令中定义的名为text的segment中`.\n\nPHDRS命令中,\n text PT_LOAD `FILEHDR` `PHDRS` ;\n该语句定义了名为text的一个segment\n它的属性为`PT_LOAD`, 表示它是一个可以被加载的segment\n`FILEHDR`和`PHDRS`是它的追加属性,分别表示在这个segment中`必须包含ELF文件头`和`必须包含ELF程序文件头`\n\n> You may use the `FILEHDR` and `PHDRS` keywords after the program header type to further describe the contents of the segment. The `FILEHDR` keyword means that the segment should include the ELF file header. The `PHDRS` keyword means that the segment should include the ELF program headers themselves. If applied to a loadable segment (`PT_LOAD`), all prior loadable segments must have one of these keywords.\n\nThe ELF object file format uses *program headers*, also knows as *segments*. The program headers describe how the program should be loaded into memory. You can print them out by using the `objdump -p`\n\nThe linker will create reasonable program headers by default. However, in some cases, you may need to specify the program headers more precisely. You may use the `PHDRS` command for this purpose. When the linker sees the `PHDRS` command in the linker script, it will not create any program headers other than the ones specified.\n\n###### [=FILLEXP] 这里显示的是段名\n\n= FILLEXP 属性作用于整个输出 section 区域\n\n在当前输出 section 内可能存在未描述的存储区域 (比如由于对齐造成的空隙)，可以用 FILL(EXPRESSION) 命令决定这些存储区域的内容\n\n> 它的作用如同 FILL()命令，但是 FILL 命令只作用于该 FILL 指令之后的 section 区域，而 = FILLEXP 属性作用于整个输出 section 区域，且 FILL 命令的优先级更高！！！\n\n```c\nSECTIONS { .text : { *(.text) } =0x90909090 } // 此处=0x90909090 为 [=FILLEXP]\n```\n\n(for example, gaps left due to the required alignment of input sections) will be filled with the value, repeated as necessary. If the fill expression is a simple hex number, ie. a string of hex digit starting with ‘0x’ and without a trailing ‘k’ or ‘M’, then an arbitrarily long sequence of hex digits can be used to specify the fill pattern; Leading zeros become part of the pattern too. For all other cases, including extra parentheses or a unary `+`, the fill pattern is the four least significant bytes of the value of the expression.\n\n> In all cases, the number is big-endian. 见 https://sourceware.org/binutils/docs/ld/Output-Section-Fill.html\n\n### 输入 section 和垃圾回收：\n\n在连接命令行内使用了选项`–gc-sections` 后，连接器可能将某些它认为没用的 section 过滤掉，此时就有必要强制连接器保留一些特定的 section，可用 `KEEP()` 关键字达此目的。如 KEEP(*(.text)) 或 KEEP(SORT(*)(.text))\n\n## 硬件寄存器\n\n即使有tlb mmu的情况下, 硬件寄存器地址所在的地址段 就是真实的物理地址, 是一一映射的\n\n这里注意的一点是 地址的快速运算, 看代码时, 利用gdb 将地址寄存器的内容快速打出, 不需要频繁加log.\n\n# DMA\n\n## 流控制器\n\n决定DMA块传输长度并终止它的设备被称为流控制器(DW_ahb_dmac或源/目标外围设备)\n\n- 如果在发起传输前就知道传输长度，则dma自己是作为流控制器\n- 传送长度未知时，源外设或目标外设是流控制器模式。外设需要在流程中主动发起结束请求， 这种情况下只能选择软件握手。\n- 内存不可能是流控制器， 仅限能够发出传输结束信号的外设支持此功能\n\n## 源、目标和传输模式\n\n###　存储器到外设模式\n\n#### **FIFO 模式**\n\n这种模式，只要使能数据流（DMA_SxCR 寄存器中的位 EN 置 1），存储器数据就会传输到 `FIFO` 中，发生外设请求，FIFO 数据会移出并存储到目标地址。\n\n当 FIFO 小于阈值，存储器的数据会重新装载 `FIFO`。\n\n> 提高带宽的特殊模式。当启用时，通道会等到目标设备的FIFO小于半满时才从源外设获取数据，等到源设备的FIFO大于或等于半满时才会向目的外设发送数据。正因为如此，通道可以使用突发方式传输数据，这样就不需要在每一次AHB传输中对AHB主接口进行仲裁。当不启用该模式时，通道只等待FIFO可以传输或接受单次AHB传输后才会请求主总线接口。\n\n#### **直连模式**\n\n使能数据流时，DMA 传输存储器的第一个数据到内部 FIFO，发生外设请求时，DMA 把预装在值发送的目标地址，然后进行下一个数据的传输。预装载的数据大小为 DMA_SxCR 寄存器中 PSIZE 位字段的值\n\n\n\n传输停止条件，下列满足一条即可:\n\n- DMA_SxNDTR  block_ts 寄存器达到零\n- 外设请求传输终止\n- DMA_SxCR 寄存器中的 EN `chen` 位由软件清零\n\n存储器到外设模式和外设到存储器模式一样，同样需要对应数据流赢得仲裁，才会启动传输\n\n## 握手接口\n\n### DEST_PER\n\nHS_SEL_DST字段为0时(即配置的硬件仲裁), 分配一个硬件握手接口(0 - 15)到通道n的目的地。如配置为1(软件仲裁), 该字段将被忽略。\n\n然后，通道可以通过指定的硬件握手接口与连接到该接口的目标外围设备通信。\n\n>  为了正确的DMA操作，只有一个外围设备(源或目标)应该被分配到同一个握手接口。\n\n### SRC_PER\n\n同上, 与`HS_SEL_SRC`字段配合\n\n> ? 对于外设来说, 握手接口的类型取决与其是否是流控制器, 如果是流控制器, 是软件握手接口; 不是流控制器, 即在发起dma的传输之前, 已经知道了传输大小, 需要将大小配置给dma 控制器, 此时外设只能选择硬件握手接口. ? XXXXXX 理解错误\n\n参考dma 设计pdf 3.8 章节 3.8.1 3.8.2\n\n这个地方有疑问， 如果外设不是流控制器，又配置的软件握手， 需要另外的软件逻辑同步外设的状态与dma的传输状态是一致的， 即额外的软件握手通信的流程。否则只配置软件握手， 是无法正常work的。","tags":["ldscript"],"categories":["linux","MIPS"]},{"title":"Android lib库加密","url":"/2021/07/18/hxd_new/安全/Android lib库加密/","content":"# 方案\n\n![](attachments/jiami.png)\n\n# 代码混淆\n\nllvm 平台混淆器\n>代理脱壳的主体代码经过了代码混淆\n\n## 字符串加密\n\n```c\n-mllvm -sobf\n```\n\n对字符串常量进行加密, 用以屏蔽通过打印的相关log 反追踪到代码的位置\n\n![](attachments/lib_crypt.png)\n\n## 控制流扁平化\n\n这个模式主要是把一些if-else语句，嵌套成do-while语句\n\n```c\n-mllvm -fla\n```\n\n## 指令替换\n这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , & , | 和 ^)\n\n```c\n-mllvm -sub\n```\n\n## 虚假控制流程\n\n这个模式主要嵌套几层判断逻辑，一个简单的运算都会在外面包几层if-else，所以这个模式加上编译速度会慢很多因为要做几层假的逻辑包裹真正有用的代码。\n\n```c\n-mllvm -bcf\n```\n\n# 加壳保护\n\n算法方提供静态库, 静态库是未加密未加混淆带完整符号信息\n\n加密侧需要将算法的关键函数进行加壳保护, 该加壳层可以称为代理\n既需要对算法的关键函数进行加壳脱壳, 也需要将算法的对外api 进行重封装.\n外部调用的是代理后的api.\n\n## lib 库脱壳\n\nmaps 信息\n```shell\n1|grus:/ $ cat /proc/self/maps\n61f3191000-61f31bb000 r--p 00000000 fd:00 1379                           /system/bin/toybox\n61f31bb000-61f31fe000 --xp 0002a000 fd:00 1379                           /system/bin/toybox\n61f31fe000-61f3202000 rw-p 0006d000 fd:00 1379                           /system/bin/toybox\n61f3202000-61f3206000 r--p 00071000 fd:00 1379                           /system/bin/toybox\n61f3206000-61f320b000 rw-p 00000000 00:00 0\n7b1e7d7000-7b1e7d9000 r--p 00000000 fd:00 4159                           /system/lib64/libnetd_client.so\n7b1e7d9000-7b1e7db000 --xp 00002000 fd:00 4159                           /system/lib64/libnetd_client.so\n7b1e7db000-7b1e7dc000 rw-p 00004000 fd:00 4159                           /system/lib64/libnetd_client.so\n7b1e7dc000-7b1e7dd000 r--p 00005000 fd:00 4159                           /system/lib64/libnetd_client.so\n7b1e7dd000-7b1e7de000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1e800000-7b1f000000 rw-p 00000000 00:00 0                              [anon:libc_malloc]\n7b1f02a000-7b1f08e000 rw-p 00000000 00:00 0                              [anon:linker_alloc]\n7b1f08e000-7b1f096000 r--p 00000000 fd:00 4353                           /system/lib64/libz.so\n7b1f096000-7b1f0a6000 --xp 00008000 fd:00 4353                           /system/lib64/libz.so\n7b1f0a6000-7b1f0a7000 rw-p 00018000 fd:00 4353                           /system/lib64/libz.so\n7b1f0a7000-7b1f0a8000 r--p 00019000 fd:00 4353                           /system/lib64/libz.so\n7b1f0e1000-7b1f0e2000 r--p 00000000 fd:00 4180                           /system/lib64/libpackagelistparser.so\n7b1f0e2000-7b1f0e3000 --xp 00001000 fd:00 4180                           /system/lib64/libpackagelistparser.so\n7b1f0e3000-7b1f0e4000 rw-p 00002000 fd:00 4180                           /system/lib64/libpackagelistparser.so\n7b1f0e4000-7b1f0e5000 r--p 00003000 fd:00 4180                           /system/lib64/libpackagelistparser.so\n7b1f131000-7b1f172000 r--p 00000000 fd:00 308                            /apex/com.android.runtime/lib64/bionic/libc.so\n7b1f172000-7b1f21e000 --xp 00041000 fd:00 308                            /apex/com.android.runtime/lib64/bionic/libc.so\n7b1f21e000-7b1f221000 rw-p 000ed000 fd:00 308                            /apex/com.android.runtime/lib64/bionic/libc.so\n7b1f221000-7b1f228000 r--p 000f0000 fd:00 308                            /apex/com.android.runtime/lib64/bionic/libc.so\n7b1f228000-7b1f22c000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f22c000-7b1f22d000 r--p 00000000 00:00 0                              [anon:.bss]\n7b1f22d000-7b1f43f000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f451000-7b1f459000 r--p 00000000 fd:00 3872                           /system/lib64/libbase.so\n7b1f459000-7b1f462000 --xp 00008000 fd:00 3872                           /system/lib64/libbase.so\n7b1f462000-7b1f463000 rw-p 00011000 fd:00 3872                           /system/lib64/libbase.so\n7b1f463000-7b1f464000 r--p 00012000 fd:00 3872                           /system/lib64/libbase.so\n7b1f464000-7b1f465000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f4aa000-7b1f4fa000 r--p 00000000 fd:00 3894                           /system/lib64/libc++.so\n7b1f4fa000-7b1f56f000 --xp 00050000 fd:00 3894                           /system/lib64/libc++.so\n7b1f56f000-7b1f570000 rw-p 000c5000 fd:00 3894                           /system/lib64/libc++.so\n7b1f570000-7b1f578000 r--p 000c6000 fd:00 3894                           /system/lib64/libc++.so\n7b1f578000-7b1f57c000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f5a4000-7b1f5a6000 r--p 00000000 fd:00 3914                           /system/lib64/libcgrouprc.so\n7b1f5a6000-7b1f5a7000 --xp 00002000 fd:00 3914                           /system/lib64/libcgrouprc.so\n7b1f5a7000-7b1f5a8000 rw-p 00003000 fd:00 3914                           /system/lib64/libcgrouprc.so\n7b1f5a8000-7b1f5a9000 r--p 00004000 fd:00 3914                           /system/lib64/libcgrouprc.so\n7b1f5a9000-7b1f5aa000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f5fd000-7b1f613000 r--p 00000000 fd:00 4197                           /system/lib64/libprocessgroup.so\n7b1f613000-7b1f63a000 --xp 00016000 fd:00 4197                           /system/lib64/libprocessgroup.so\n7b1f63a000-7b1f63b000 rw-p 0003d000 fd:00 4197                           /system/lib64/libprocessgroup.so\n7b1f63b000-7b1f63d000 r--p 0003e000 fd:00 4197                           /system/lib64/libprocessgroup.so\n7b1f63d000-7b1f63e000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f647000-7b1f64e000 r--p 00000000 fd:00 3969                           /system/lib64/libcutils.so\n7b1f64e000-7b1f656000 --xp 00007000 fd:00 3969                           /system/lib64/libcutils.so\n7b1f656000-7b1f657000 rw-p 0000f000 fd:00 3969                           /system/lib64/libcutils.so\n7b1f657000-7b1f659000 r--p 00010000 fd:00 3969                           /system/lib64/libcutils.so\n7b1f659000-7b1f65a000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f6a0000-7b1f716000 r--p 00000000 fd:00 3965                           /system/lib64/libcrypto.so\n7b1f716000-7b1f7cd000 --xp 00076000 fd:00 3965                           /system/lib64/libcrypto.so\n7b1f7cd000-7b1f7ce000 rw-p 0012d000 fd:00 3965                           /system/lib64/libcrypto.so\n7b1f7ce000-7b1f7df000 r--p 0012e000 fd:00 3965                           /system/lib64/libcrypto.so\n7b1f7df000-7b1f7e1000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f800000-7b1f806000 r--p 00000000 fd:00 4091                           /system/lib64/liblog.so\n7b1f806000-7b1f815000 --xp 00006000 fd:00 4091                           /system/lib64/liblog.so\n7b1f815000-7b1f816000 rw-p 00015000 fd:00 4091                           /system/lib64/liblog.so\n7b1f816000-7b1f817000 r--p 00016000 fd:00 4091                           /system/lib64/liblog.so\n7b1f817000-7b1f818000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f848000-7b1f84f000 r--p 00000000 fd:00 4230                           /system/lib64/libselinux.so\n7b1f84f000-7b1f85f000 --xp 00007000 fd:00 4230                           /system/lib64/libselinux.so\n7b1f85f000-7b1f860000 rw-p 00017000 fd:00 4230                           /system/lib64/libselinux.so\n7b1f860000-7b1f861000 r--p 00018000 fd:00 4230                           /system/lib64/libselinux.so\n7b1f861000-7b1f863000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f8a3000-7b1f8a4000 r--p 00000000 fd:00 309                            /apex/com.android.runtime/lib64/bionic/libdl.so\n7b1f8a4000-7b1f8a5000 --xp 00001000 fd:00 309                            /apex/com.android.runtime/lib64/bionic/libdl.so\n7b1f8a5000-7b1f8a6000 r--p 00002000 fd:00 309                            /apex/com.android.runtime/lib64/bionic/libdl.so\n7b1f8a6000-7b1f8a7000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f8c4000-7b1f8d6000 r--p 00000000 fd:00 310                            /apex/com.android.runtime/lib64/bionic/libm.so\n7b1f8d6000-7b1f8fa000 --xp 00012000 fd:00 310                            /apex/com.android.runtime/lib64/bionic/libm.so\n7b1f8fa000-7b1f8fb000 rw-p 00036000 fd:00 310                            /apex/com.android.runtime/lib64/bionic/libm.so\n7b1f8fb000-7b1f8fc000 r--p 00037000 fd:00 310                            /apex/com.android.runtime/lib64/bionic/libm.so\n7b1f8fc000-7b1f8fd000 rw-p 00000000 00:00 0                              [anon:.bss]\n7b1f927000-7b1f947000 r--p 00000000 fd:00 4182                           /system/lib64/libpcre2.so\n7b1f947000-7b1f973000 --xp 00020000 fd:00 4182                           /system/lib64/libpcre2.so\n7b1f973000-7b1f974000 rw-p 0004c000 fd:00 4182                           /system/lib64/libpcre2.so\n7b1f974000-7b1f975000 r--p 0004d000 fd:00 4182                           /system/lib64/libpcre2.so\n7b1f98b000-7b1f9ab000 r--s 00000000 00:10 14093                          /dev/__properties__/u:object_r:heapprofd_prop:s0\n7b1f9ab000-7b1f9cb000 r--s 00000000 00:10 14061                          /dev/__properties__/u:object_r:exported2_default_prop:s0\n7b1f9cb000-7b1f9eb000 r--s 00000000 00:10 14044                          /dev/__properties__/u:object_r:debug_prop:s0\n7b1f9eb000-7b1f9ec000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1f9f4000-7b1fa14000 r--s 00000000 00:10 14211                          /dev/__properties__/properties_serial\n7b1fa14000-7b1fa22000 r--s 00000000 00:10 13997                          /dev/__properties__/property_info\n7b1fa22000-7b1fa23000 ---p 00000000 00:00 0\n7b1fa23000-7b1fa26000 rw-p 00000000 00:00 0\n7b1fa26000-7b1fa27000 ---p 00000000 00:00 0\n7b1fa8b000-7b1fb53000 r--p 00000000 00:00 0                              [anon:linker_alloc]\n7b1fb53000-7b1fb57000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1fb58000-7b1fb5a000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1fb5a000-7b1fb5d000 rw-p 00000000 00:00 0                              [anon:System property context nodes]\n7b1fb5d000-7b1fb5f000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1fb60000-7b1fb66000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1fb66000-7b1fb86000 r--s 00000000 00:10 14072                          /dev/__properties__/u:object_r:exported_default_prop:s0\n7b1fb86000-7b1fb88000 rw-p 00000000 00:00 0                              [anon:bionic_alloc_small_objects]\n7b1fb88000-7b1fbec000 r--p 00000000 00:00 0                              [anon:linker_alloc]\n7b1fbec000-7b1fc0c000 r--s 00000000 00:10 14044                          /dev/__properties__/u:object_r:debug_prop:s0\n...\n```\n\n供外部调用的算法 api 函数名 加密保护, 避免通过api 函数名找到函数入口.\n不是原地解密, 而是新开辟一块匿名内存, 将原程序的文本段等拷贝到新的匿名内存上, 拷贝的起始位置并不是0, 而是从某个offset处开始拷贝, 即使反追踪到该匿名内存位置, 也不知道offset 是多少, 无法直接搬回lib库通过pc工具进行解析lib库.\n\n# 其他加密杂项\n\n- lib 中加入ptrace 调用, 限制动态调试\n- 主代理代码经过混淆+加密调用算法api调用关系来保护算法入口, 通过加壳保护算法.\n- 脱壳算法代码内实现, 不调用其他加密库, 防止通过反追踪加密库api调用猜测脱壳算法.\n- 脱壳算法关键特征信息隐藏, 防止通过查看加密算法特征猜测脱壳算法.\n- 对语音算法中的非api 的关键函数, 主题代理代码中会加入部分类同名伪代码进行干扰.\n- 语音算法api 函数加密更名, 防止通过dump 猜测到函数主体.\n- 对语音算法关键函数进行加壳, 而不是整体加壳, 多个函数之间形成链式加密, 同时其在内存上的排布也是一个一个空洞, 而非连续的整体, 进一步加大破解难度\n- 识别手机root debuggable信息, 在debuggable手机上直接退出, 不进行脱壳.\n- 识别手机串号, 只有授权的才会脱壳运行.","tags":["Android","lib"],"categories":["加密"]},{"title":"ARM核安全态和非安全态的切换","url":"/2021/07/18/hxd_new/安全/ARM核安全态和非安全态的切换/","content":"\nARMv8 有 el0-el3 四个异常等级, 有 NS 和 S 两个状态, ARMv8 对 TZ 技术有先天性的优势.\n\n# ARMv7 基础\n\n在 armv7 上首次添加了 trustzone, 在 arm 原有七种运行模式的基础上扩展出了 monitor 模式\nnormal world 和 sec world 的切换是由 monitor 模式下的程序来完成.\n\n## arm 原有的其中运行模式\n- usr 模式(用户模式): 正常程序运行时的模式\n- fiq 模式(快速中断模式): 当配置有快速中断时, 如果产生 fiq 事件, arm 会切换到该模式\n- irq 模式(用户模式): 中断模式, 用于通用中断处理, 被 ROS 使用\n- svc 模式(管理模式): 操作系统使用的保护模式\n- abt 模式(数据访问终止模式): 当数据或者指令取值时终止则会进入该模式\n- und 模式(未定义指令模式): 当未定义指令执行会进入该模式\n- sys 模式(系统模式): 运行具有特权的操作系统任务\n\n\n![](attachments/qizhongmoshi.png)\n\n这些模式都是一种硬件反应态，AXI 总线强烈依赖访问时的模式。\n支持 TZ 后, ARM 增加了 monitor 模式. monitor 模式是共享的, 在 monitor 模式下, 每种状态具有独立的七种模式\n\n## armv7 安全位扩展\n\n在支持 TZ 后, ARM 在 axi 总线上增加了一个 NS 位(安全状态位), 用来标识当前的数据\\指令是属于安全世界还是非安全世界, NS bit 保存在 scr 寄存器的 0 bit, NS=1, normal world, NS=0, sec world\n\n除了对总线进行扩展之外，ARM 对 MMU 和 Cache 也同样进行了安全状态位的扩展，用于标记 MMU 中存放的物理内存映射后的地址是属于安全内存地址还是非安全地址，而对于 Cache 该位会被用来标记当前的 Cache 是属于安全态的 Cache 还是非安全态的 Cache。当 ARM 核访问物理地址时，会对该虚拟地址的安全状态位进行检查，而在访问物理内存时安全扩展组件会对地址进行权限检查，该权限检查操作属于硬件级别的检查，不受软件的控制。关于安全地址的配置则是在 IC 设计时通过配置安全组件的参数来设定的\n\n\n## armv7 vs armv8 特权等级(运行模式)\n![](attachments/armv7-v8.png)\n\n![](attachments/vector_table.png)\n\n```c\n\nLOCAL_FUNC sm_vect_table , :, align=32\nUNWIND(\t.cantunwind)\n\tb\t.\t\t/* Reset\t\t\t*/\n\tb\t.\t\t/* Undefined instruction\t*/\n\tb\tsm_smc_entry\t/* Secure monitor call\t\t*/\n\tb\t.\t\t/* Prefetch abort\t\t*/\n\tb\t.\t\t/* Data abort\t\t\t*/\n\tb\t.\t\t/* Reserved\t\t\t*/\n\tb\t.\t\t/* IRQ\t\t\t\t*/\n\tb\tsm_fiq_entry\t/* FIQ\t\t\t\t*/\nEND_FUNC sm_vect_table\n\n| ------------------ | -------------- | ---------------------- |\n| `VBAR_ELn + 0x000` | Synchronous    | Current EL with SP0    |\n| `+ 0x080`          | IRQ/vIRQ       | Current EL with SP0    |\n| `+ 0x100`          | FIQ/vFIQ       | Current EL with SP0    |\n| `+ 0x180`          | SError/vSError | Current EL with SP0    |\n| ------------------ | -------------- | ---------------------- |\n| `+ 0x200`          | Synchronous    | Current EL with SPx    |\n| `+ 0x280`          | IRQ/vIRQ       | Current EL with SPx    |\n| `+ 0x300`          | FIQ/vFIQ       | Current EL with SPx    |\n| `+ 0x380`          | SError/vSError | Current EL with SPx    |\n| ------------------ | -------------- | ---------------------- |\n| `+ 0x400`          | Synchronous    | Lower EL using AArch64 |\n| `+ 0x480`          | IRQ/vIRQ       | Lower EL using AArch64 |\n| `+ 0x500`          | FIQ/vFIQ       | Lower EL using AArch64 |\n| `+ 0x580`          | SError/vSError | Lower EL using AArch64 |\n| ------------------ | -------------- | ---------------------- |\n| `+ 0x600`          | Synchronous    | Lower EL using AArch32 |\n| `+ 0x680`          | IRQ/vIRQ       | Lower EL using AArch32 |\n| `+ 0x700`          | FIQ/vFIQ       | Lower EL using AArch32 |\n| `+ 0x780`          | SError/vSError | Lower EL using AArch32 |\n| ------------------ | -------------- | ---------------------- |\n```\n\n## armv7 进入 monitor 模式的处理流程\n\n> monitor 模式的 vec 入口 放在了 optee_os 中, armv7 没有 ATF, armv8 上才有 ATF. \n\n```c\nLOCAL_FUNC sm_smc_entry , :      // 进入 monitor 模式\nUNWIND(\t.cantunwind)\n\tsrsdb\tsp!, #CPSR_MODE_MON  //将当前模式的lr和spsr寄存器中的值分别存储在monitor模式的sp中\n\tpush\t{r0-r7}   //将r0到r7中的值压入栈(sp)\n\n\tclrex\t\t/* Clear the exclusive monitor */ //独占清除,可以将关系紧密的独占访问监控器返回为开放模式\n\n\t/* Find out if we're doing an secure or non-secure entry */\n\tread_scr r1  //获取当前scr寄存器中的值,并将值保存在r1寄存器中\n\ttst\tr1, #SCR_NS //读SCR 的 NS bit\n\tbne\t.smc_from_nsec //如果NS=0, 表明来自于非安全世界, NS=1, 来自于 sec world. 来自于非安全世界时, 进入 smc_from_nsec 函数处理, 就不回来了\n\n\n============================== 来自于安全世界时的处理流==============================\n// 当前处于安全世界中\n\t/*\n\t * As we're coming from secure world (NS bit cleared) the stack\n\t * pointer points to sm_ctx.sec.r0 at this stage. After the\n\t * instruction below the stack pointer points to sm_ctx.\n\t */\n\tsub\tsp, sp, #(SM_CTX_SEC + SM_SEC_CTX_R0)   //当前sp的值减去offset就可以得到Secure World的运行栈地址\n\n\t/* Save secure context */\n\tadd\tr0, sp, #SM_CTX_SEC   //将sp的值加上secure world context的长度保存在r0寄存器中     r0 存放sec world context\n\tbl\tsm_save_unbanked_regs   //从r0 寄存器的地址的位置开始 保存sec world 中八种模式的主要寄存器的值\n\n\t/*\n\t * On FIQ exit we're restoring the non-secure context unchanged, on\n\t * all other exits we're shifting r1-r4 from secure context into\n\t * r0-r3 in non-secure context.\n\t */\n\tadd\tr8, sp, #(SM_CTX_SEC + SM_SEC_CTX_R0)   // r8 保存 secure world 运行栈\n\tldm\tr8, {r0-r4}       // r0-r4 读到 r8\n\tmov_imm\tr9, TEESMC_OPTEED_RETURN_FIQ_DONE  //r9 赋值为 TEESMC_OPTEED_RETURN_FIQ_DONE\n\tcmp\tr0, r9     // r0 是否等于 r9\n\taddne\tr8, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R0) // 如果 r0 != r9, r8 = sp + non_sec context + non_sec_r0  (保存八种主要模式寄存器的地方)\n\tstmne\tr8, {r1-r4}   // 如果 r0 != r9, r1-r4 一次加载到 sp + non_sec context + non_sec_r0\n\n\t/* Restore non-secure context */\n\tadd\tr0, sp, #SM_CTX_NSEC   // r0 = sp + non_sec context\n\tbl\tsm_restore_unbanked_regs   // 恢复 non sec context 到 r0 位置\n\n.sm_ret_to_nsec:\n\t/*\n\t * Return to non-secure world\n\t */\n\tadd     r0, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R8)   // r0 = sp + non_sec_context + non_sec_context_r8 \n\tldm\tr0, {r8-r12}     // 依次读 r8-r12 到 non_sec_context 中保存r8-r12 的位置\n\n\t/* Update SCR */\n\tread_scr r0\n\torr\tr0, r0, #(SCR_NS | SCR_FIQ) /* Set NS and FIQ bit in SCR */    // NS 置1 , FIQ 置1\n\twrite_scr r0     // 更新 SCR.NS 和 SCR.FIQ , 表明进入 non sec world\n\t/*\n\t * isb not needed since we're doing an exception return below\n\t * without dependency to the changes in SCR before that.\n\t */\n\n\tadd\tsp, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R0)\n\tb\t.sm_exit\n\n================================ 来自于 非安全世界时的处理 ==========================\n.smc_from_nsec:\n\t/*\n\t * As we're coming from non-secure world (NS bit set) the stack\n\t * pointer points to sm_ctx.nsec.r0 at this stage. After the\n\t * instruction below the stack pointer points to sm_ctx.\n\t */\n\tsub\tsp, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R0)\n\n\tbic\tr1, r1, #(SCR_NS | SCR_FIQ) /* Clear NS and FIQ bit in SCR */ //清除 SCR.NS 和 SCR.FIQ , 表明接下来的操作要在 sec world下进行\n\twrite_scr r1\n\tisb\n\n\tadd\tr0, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R8)\n\tstm\tr0, {r8-r12}\n\n\tmov\tr0, sp\n\tbl\tsm_from_nsec\n\tcmp\tr0, #SM_EXIT_TO_NON_SECURE\n\tbeq\t.sm_ret_to_nsec      // 同上, 更新SCR.NS 和 SCR.FIQ\n\n\t/*\n\t * Continue into secure world\n\t */\n\tadd\tsp, sp, #(SM_CTX_SEC + SM_SEC_CTX_R0)\n\n.sm_exit:\n\tpop\t{r0-r7}\n\trfefd\tsp!    // 从异常帧中恢复并递减堆栈指针    //进到非安全世界上下文\nEND_FUNC sm_smc_entry\n```\n\n> 在 sec world 中为什么要将 SCR.FIQ 置 0?\n\n而 armv8 中使用 ATF 来处理切换安全世界和非安全世界\n\nARMv8调用 smc 指令产生安全监控模式调用后，ARM 核会切换到 EL3中，然后读取 MVBAR 寄存器中的异常向量表的基地址来获取异常向量表的内容，并命中安全监控模式调用请求处理函数。\n\n进入 handle_sync_exception 后对触发 sec monitor 调用的世界进行判定, 并设定需要切换到的那个世界的状态并恢复对应的 cpu 上下文.\n根据调用 id 进入具体分支, 将 arm 运行模式切换为 EL1 或 EL0, 待 sec monitor 调用处理完毕后,重新进入 el3 继续剩下流程\n\n![](attachments/ATF_optee.png)\n![](attachments/ATF_handlesync.png)\n## 触发 monitor 调用过程\n\n调用 smc , arm 核进入 el3 中, 从 MVBAR 获取 vec table, 找到 smc 的处理函数.\n最后进入到 handle_sync_exception 中, 调用 opteed_smc_handler 函数对该 smc 调用进行处理\n判定该 smc 调用是 scr.NS 是来自于安全世界还是非安全世界, 再根据 smc id 决定是否恢复 normal world 的 context\n\n![](attachments/ATF_SMC.png)\n\n在安全世界状态下触发 smc 后, 处理完请求后, 会再次触发 smc 重新进入 el3, 进入到 TEESMC_OPTEED_RETURN_CALL_DONE 的分支，在该分支中会保存安全世界状态的运行上下文并恢复正常世界状态的运行上下文，然后调用 SMC_RET4返回到正常世界状态中继续运行。\n\n而在非安全世界状态下触发 smc 后, 在 opteed_smc_handler 函数中会调用 is_caller_non_secure 来判定当前安全监控模式调用是来自正常世界状态还是安全世界状态, 如果是来自于非安全世界, 则会保存非安全世界上下文, 恢复安全世界状态下的上下文, 处理调用请求结束后, 恢复非安全世界的上下文, 最后调用 SMC_RET4 返回到非安全世界继续运行.\n\n# 总结\n\narmv7 对 smc 的处理是在 monitor 状态下完成, 该处理代码集成在了 optee 中.\narmv8 对 smc 的处理则是在 ATF 的 bl31阶段(类似 riscv M-mode 的 opensbi), 在 ATF 中 ARM 为兼容不同的 TEE 方案, 提供了集成接口, 各 TEE 方案按照规范完成世界切换.\n\n# 中断与异常的处理\n\nARM 核处于安全世界状态（SWS）和正常世界状态（NWS）都具有独立的 VBAR 寄存器和中断向量表。而当 ARM 核处于 Monitor 模式或者 EL3时，ARM 核将具有独立的中断向量表和 MVBAR 寄存器。想实现各种中断在三种状态下被处理的统一性和正确性，就需要确保各种状态下中断向量表以及 GIC 的正确配置。**ARM 的指导手册中建议在 TEE 中使用 FIQ，在 ROS 中使用 IRQ，即 TEE 侧会处理由中断引起的 FIQ 事件，而 Linux 内核端将会处理中断引起的 IRQ 事件**。而由于 ATF 的使用，Monitor 状态或者 EL3下中断的处理代码将会在 ATF 中实现。(ATF 来处理更高级及跟敏感的中断)\n\n对于 armv7 核, 中断与 arm 核每种状态的关系图:\n\n![](attachments/armv7_interr.png)\n\n中断分本地中断和外部中断, FIQ 被 TEE 侧处理, IRQ 被 REE 处理\n如果在 monitor (armv7) 或 EL3 (armv8) 阶段产生了中断, 则处于 monitor 或 el3 阶段的软件使用 MVBAR 寄存器 vec table 中处理函数对 FIQ 和 IRQ 进行处理\n\n## GIC 寄存器\n\nGIC 模块的寄存器分为中断分发寄存器(GICD) 和 cpu 接口寄存器 (GICC)\nGICD 接收所有的中断源, 根据中断优先级判定是否响应中断, 及将该中断信号转发给相应的 cpu\nGICC 同各个核连接, 当收到 GICD 的中断信号后, 由 GICC 决定是否将中断请求发给 arm 核\n\n支持安全扩展的 GIC 模块将终端分为两组: group0 和 group1 中断.\n- armv7 上, g0为安全中断, g1 为非安全中断\n- armv8, g0 为安全中断且优先级最高, g1 分安全中断和非安全中断\n\nGIC 根据中断所在 group 安全类型及当前 arm 核运行模式决定发送 FIQ 还是 IRQ. \n\n```c\n#define INTR_TYPE_S_EL1      0        // 该中断应该由Secure EL1处理\n#define INTR_TYPE_EL3        1        // 该中断应该由EL3处理\n#define INTR_TYPE_NS         2        // 该中断应该由Normal World 处理\n```\n\n不同版本 GIC 对于上面的三种类型的中断产生不同的 FIQ 或 IRQ 事件. 再根据 SCR.FIQ 和 SCR.IRQ 位来决定该中断是否会触发进入 EL3 阶段\n\n对于 armv7\n![](attachments/SCR.FIQ_IRQ.png)\n\n前面提出的 armv7 下 sec world 下为什么将 FIQ 置 0, 置 0后, FIQ 中断会直接进入 FIQ 中断入口, 由 optee_os 进行处理, 而不会再进 monitor 的 vec table\n\narmv8的 SCR.FIQ SCR.IRQ\n![](attachments/armv8_scr.png)\n\n```c\n * NS:   Non Secure Mode\n * 0:    Routing Model 0\n * 1:    Routing Model 1\n * 值对应SCR寄存器中的bit[2:0],定义如下\n * bit[0]: SCR.NS (0: Secure, 1: Non Secure)\n * bit[1]: SCR.IRQ (0: enter IRQ mode 1: enter EL3 monitor)\n * bit[2]: SCR.FIQ (0: enter FIQ mode 1: enter EL3 monitor)\n```\n\nGICv2设定**Group0为安全中断，Group1为非安全中断**。中断号属于哪个 Group 是由其在 `GICD_IGROUPRn` 寄存器中的值来决定的。当 GIC 接收到中断信号后，如果中断属于 Group0则发送 IRQ 信号到目标 CPU，中断属于 Group1则发送 FIQ 信号到目标 CPU。\n\n与 GICv2相比 GICv3的主要改进有以下几点：\n- 在软件中断 (SGI) 方面新增中断路由模式(affinity rounting), 能支持更大范围的 cpu id\n- GICv3 对 Group1 的中断类型进一步细分. Group0 还是为安全中断且有最高优先级, 而 Group1 中断分为非安全中断 (GINS) 和安全中断 (GIS)\n- 在 FIQ/IRQ 都使能时, 属于 Group0的中断始终触发 FIQ, 属于 Group1的中断根据当前 cpu 工作模式和中断类型分别触发 FIQ 或 IRQ\n\n|当前处理器模式|Group0|Group1|Group1|\n|---|---|---|---|\n|||G1S|G1NS|\n|Secure EL1/EL0|FIQ|**IRQ**|FIQ|\n|Non Secure EL1/EL0|FIQ|FIQ|**IRQ**|\n|Secure EL3|FIQ|FIQ|FIQ|\n\n## 异常向量\n\nREE/TEE/monitor (v7) 或 EL3 (v8) 都可以接收中断, 存在两个 VBAR 和一个 MVBAR\n- REE VBAR 存放 linux 内核的异常 vec table\n- TEE VBAR 存放 tee 的异常 vec table\n- monitor 或 EL3 MVBAR 存放其自己的 vec table\n\n### ARMv7中 Monitor 模式的异常向量表\n\nMonitor模式属于安全世界状态，用于实现ARM核安全世界状态与正常世界状态之间的切换，且**该模式具有独立的中断向量表**。使用MVBAR寄存器来保存该运行模式的中断向量表的基地址。在OPTEE初始化过程中会调用sm_init函数来初始化Monitor模式的配置，并将Monitor模式的中断向量基地址写入到MVBAR寄存器中\n\n```c\nFUNC sm_init , :\nUNWIND( .fnstart)\n    mrs r1, cpsr //设置Monitor模式使用的栈\n    cps #CPSR_MODE_MON\n    sub sp, r0, #(SM_CTX_SIZE - SM_CTX_NSEC)\n    msr cpsr, r1\n    //将Monitor模式的异常向量表地址保存到r0寄存器\n    ldr r0, =sm_vect_table     \n    //将Monitor模式的异常向量表基地址写入MVBAR寄存器中\n    write_mvbar r0\n    bx  lr // 返回\nEND_FUNC sm_init\n\nUNWIND( .fnstart)\nUNWIND( .cantunwind)\n    b   .\t\t/* 重启操作 */\n    b   .\t\t/* 未定义指令操作 */\n    b   sm_smc_entry\t/* smc异常处理函数 */\n    b   .\t/* 执行时的abort操作 */\n    b   .\t/* 数据abort操作 */\n    b   .\t/* 预留 */\n    b   .\t/* IRQ事件 */\n    b   sm_fiq_entry /* FIQ中断处理入口函数 */\nUNWIND( .fnend)\nEND_FUNC sm_vect_table        \n```\n\n当在 Monitor 模式下接收到 FIQ 中断时，系统将会调用 sm_fiq_entry 函数对该 FIQ 中断进行处理\n\n### ARMv8中 EL3阶段的异常向量表\n\nARMv8使用 ATF 中的 bl31作为 EL3阶段的代码，其作用与 ARMv7中 Monitor 模式下运行的代码作用一致。在 ATF 的启动过程中，bl31通过调用 el3_entrypoint_common 函数来进行 EL3运行环境的初始化，在初始化过程中会执行 EL3阶段异常向量表的初始化，EL3的异常向量表的基地址为 runtime_exception_vectors。EL3异常向量表的内容如下：\n\n从异常向量表来看，ARMv8架构中不管是 AArch32还是 AArch64，当在 EL3阶段产生了 FIQ 事件或者 IRQ 事件后，bl31将会调用 handle_interrupt_exception 宏来处理，该宏使用的参数就是产生的异常的标签。\n\n### OP-TEE 异常向量的配置\n\nOP-TEE 异常向量的加载和配置会通过执行 `thread_init_vbar` 函数来实现\n\n```c\n// aarch32\nFUNC thread_init_vbar , :\n\t/* Set vector (VBAR) */\n\twrite_vbar r0\n\tbx\tlr\nEND_FUNC thread_init_vbar\nDECLARE_KEEP_PAGER thread_init_vbar\n\n// aarch64\nFUNC thread_init_vbar , :\n\tmsr\tvbar_el1, x0\n\tret\nEND_FUNC thread_init_vbar\nDECLARE_KEEP_PAGER thread_init_vbar\n```\n\n系统会到 VBAR 寄存器中获取 OP-TEE 的异常向量表基地址，然后根据异常类型获取到 FIQ 或 IRQ 事件的处理函数，并对不同的事件进行处理。针对不同的事件会调用线程向量表 thread_vector_table 变量中对应的处理函数来完成对该异常事件的处理。\n\n#### thread_vector_table\n\noptee 中会定义一个用于保存各种事件处理函数的线程向量表, 对 fast_smc std_smc FIQ cpu 关闭打开及系统关机和重启事件的处理\n\n```c\nFUNC thread_vector_table , : , .identity_map\nUNWIND(\t.cantunwind)\n\tb\tvector_std_smc_entry\n\tb\tvector_fast_smc_entry\n\tb\tvector_cpu_on_entry\n\tb\tvector_cpu_off_entry\n\tb\tvector_cpu_resume_entry\n\tb\tvector_cpu_suspend_entry\n\tb\tvector_fiq_entry\n\tb\tvector_system_off_entry\n\tb\tvector_system_reset_entry\nEND_FUNC thread_vector_table\nDECLARE_KEEP_PAGER thread_vector_table\n#endif /*if defined(CFG_WITH_ARM_TRUSTED_FW)*/\n```\n\narmv8 下, 该线程向量表的地址会返回给 bl31, 当 EL3 阶段收到 smc 调用或者 FIQ 事件时可转到该 vec table 中对应的处理函数进行处理\narmv7 下, 该变量被 monitor 模式下的程序(还是 optee)使用, 进而跳转到 vec table 对应的函数中处理\n\n## FIQ 处理\n\n## armv7\n\n![](attachments/armv7_fiq_p.png)\narmv8\n\n![](attachments/armv8_ATF.fiq_p.png)\n\n![](attachments/armv8_fiq_p.png)\n\n## OP-TEE 对 FIQ 事件的处理\n\nOP-TEE 启动时会调用 thread_init_vbar 函数来完成安全世界状态（SWS）的中断向量表的初始化，且在 GIC 中配置 FIQ 在安全世界状态时才有效。所以在安全世界状态中产生了 FIQ 事件时，CPU 将直接通过 VBAR 寄存器查找到中断向量表的基地址，并命中 FIQ 的处理函数。整个处理过程如图所示。\n\n![](attachments/tee_fiq.png)\n\n## OP-TEE 对 IRQ 事件的处理\n\nIRQ 事件一般由 REE 处理. 但当处于安全世界时, 系统产生的 IRQ 事件又不能丢弃. OPTEE 还是需要将 irq 转出来发给 REE\n\n![](attachments/TEE_irq_P.png)\n\n当系统在 ARM 核处于安全世界状态中产生 IRQ 事件时，系统通过 VBAR 寄存器获取到中断向量表的基地址，然后查找到 IRQ 对应的中断处理函数—— thread_irq_handler，使用该函数处理 IRQ 事件，整个处理过程的流程如图所示。\n\n![](attachments/tee_irq_p1.png)\n\noptee 收到 irq 后, armv7 中通过切换到 monitor 模式将该 irq 事件发送到 ree 侧进行处理\narmv8 架构中 irq 中断会切换到 EL3 将该事件交给 REE 进行处理\n\n完成了 IRQ 事件处理后, 会通过 smc 重新切回 monitor/EL3, 恢复安全世界状态被中断的线程\n\n\n## 总结\n\narmv7 安全世界状态包含 monitor 和 optee, 其中 monitor 的代码是包含在 optee_os 下的. 而在 armv8下安全世界包括 el3阶段的代码和 optee, el3阶段的代码在 ATF 的 bl31 中.\narmv7 monitor 模式下运行的代码用来处理 fiq, armv8 在 el3阶段收到的 fiq 由 bl31 阶段的代码进行处理.\n在安全世界中收到的 fiq 都是由 optee 的线程向量表中的 thread_fiq_handler 处理的\n在安全世界中收到的 irq 都是由 optee 的线程向量表中的 thread_irq_handler 处理的, 转给 monitor/el3 进行转发, 最终转发给 REE 处理, 处理完成后, REE 需要发 smc 返回到 monitor/el3, 再进入到 optee 中恢复被 irq 打断的任务状态.\n\n","tags":["armv7","armv8","optee_os"],"categories":["TEE","optee_os"]},{"title":"mips microAptiv 测试","url":"/2021/03/25/hxd_new/ipsram测试/","content":"\n## 芯片上\n\n```\n   0xbfc01000:  move    a2,t2\n=> 0xbfc01004:  lw      a0,0(s0)\n   0xbfc01008:  move    a2,t2\n   0xbfc0100c:  jal     0xbfc00a64\n   0xbfc01010:  move    a1,t3\n   0xbfc01014:  bnez    v0,0xbfc010a8\n   0xbfc01018:  li      a2,100\n   0xbfc0101c:  li      a1,4\n   \n   0xbfc01000:  jal     0xbfc00a64\n   0xbfc01004:  lw      a0,0(s0)\n=> 0xbfc01008:  move    a2,t2\n   0xbfc0100c:  jal     0xbfc00a64\n   0xbfc01010:  move    a1,t3\n   0xbfc01014:  bnez    v0,0xbfc010a8\n   0xbfc01018:  li      a2,100\n   0xbfc0101c:  li      a1,4\n  \n\n   0xbfc01000:  move    a1,t3\n   0xbfc01004:  lw      a0,0(s0)\n   0xbfc01008:  move    a2,t2\n=> 0xbfc0100c:  jal     0xbfc00a64\n   0xbfc01010:  move    a1,t3\n   0xbfc01014:  bnez    v0,0xbfc010a8\n   0xbfc01018:  li      a2,100\n   0xbfc0101c:  li      a1,4\n   \n```\n\n### 下载模式下调试\n\n```assembly\n\tla a2,\t\tchange_k0_cca\n\tli      \ta1, 0xf\n\tins     \ta2, a1, 29, 1 // changed to KSEG1 address by setting bit 29\n    jalr a2\n    \n    \n    LEAF(change_k0_cca)\n\t// NOTE! This code must be executed in KSEG1 (not KSGE0 uncached)\n    // Set CCA for kseg0 to cacheable\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tmfc0\tTEMP1, C0_CONFIG\t// read C0_Config\n\tli\t    TEMP2, 2\t\t\t// CCA for all others\n\nset_kseg0_cca:\n    ins\t    TEMP1, TEMP2, 0, 3\t// insert K0\n\tmtc0\tTEMP1, C0_CONFIG\t// write C0_Config\n\tehb\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tjalr.hb   zero, ra\n\nEND(change_k0_cca)\n```\n\n\n\n```shell\nRemote debugging using 192.168.66.149:3333\nwarning: No executable has been specified and target does not support\ndetermining executable automatically.  Try using the \"file\" command.\n0x82c0ee7c in ?? ()\nUndefined command: \"dashboard\".  Try \"help\".\nLoading section .text_init, size 0x2540 lma 0x84104000\nLoading section .text_ram, size 0x4628 lma 0x84106540\nLoading section .rodata, size 0xa10 lma 0x8410ab68\nLoading section .data, size 0x28 lma 0x8410b578\nStart address 0x84104000, load size 30112\nTransfer rate: 21 KB/sec, 6022 bytes/write.\nExecution start_address = 0x84104000\nFastdata access Failed\nFalling back to non-bulk write\n46496 bytes written at address 0x84100000\ndownloaded 46496 bytes in 3.464504s (13.106 KiB/s)\ntarget was already halted\nBreakpoint 1 at 0x84104000: file src/asm/start.S, line 46.\nContinuing.\n\nProgram stopped.\n__reset_vector () at src/asm/start.S:46\n46              la a2,  check_nmi\n(gdb) disassemble change_k0_cca \nDump of assembler code for function change_k0_cca:\n   0x84104804 <+0>:     nop\n   0x84104808 <+4>:     nop\n   0x8410480c <+8>:     nop\n   0x84104810 <+12>:    nop\n   0x84104814 <+16>:    nop\n   0x84104818 <+20>:    nop\n   0x8410481c <+24>:    nop\n   0x84104820 <+28>:    nop\n   0x84104824 <+32>:    nop\n   0x84104828 <+36>:    nop\n   0x8410482c <+40>:    nop\n   0x84104830 <+44>:    nop\n   0x84104834 <+48>:    nop\n   0x84104838 <+52>:    nop\n   0x8410483c <+56>:    nop\n   0x84104840 <+60>:    nop\n   0x84104844 <+64>:    nop\n   0x84104848 <+68>:    nop\n   0x8410484c <+72>:    nop\n   0x84104850 <+76>:    nop\n   0x84104854 <+80>:    mfc0    t6,c0_config\n   0x84104858 <+84>:    li      t7,2\n   0x8410485c <+88>:    ins     t6,t7,0x0,0x3\n   0x84104860 <+92>:    mtc0    t6,c0_config\n   0x84104864 <+96>:    ehb\n   0x84104868 <+100>:   nop\n   0x8410486c <+104>:   nop\n   0x84104870 <+108>:   nop\n   0x84104874 <+112>:   nop\n   0x84104878 <+116>:   nop\n   0x8410487c <+120>:   nop\n   0x84104880 <+124>:   nop\n   0x84104884 <+128>:   nop\n   0x84104888 <+132>:   nop\n   0x8410488c <+136>:   nop\n   0x84104890 <+140>:   nop\n   0x84104894 <+144>:   nop\n   0x84104898 <+148>:   nop\n   0x8410489c <+152>:   nop\n   0x841048a0 <+156>:   nop\n   0x841048a4 <+160>:   nop\n   0x841048a8 <+164>:   nop\n   0x841048ac <+168>:   nop\n   0x841048b0 <+172>:   nop\n   0x841048b4 <+176>:   nop\n   0x841048b8 <+180>:   jalr.hb zero,ra\n   0x841048bc <+184>:   nop\nEnd of assembler dump.\n(gdb) b *0xa410486c\nBreakpoint 2 at 0xa410486c\n(gdb) c\nContinuing.\n\nProgram stopped.\n0xa410486c in ?? ()\n(gdb) mon mips32 cp0 config\n0xa4310582\n(gdb) mon mww 0x82d030b4 0x80000080\n(gdb) x/12i 0xbfc00100\n   0xbfc00100:  sdc2    $16,147(k1)\n   0xbfc00104:  ldc1    $f7,16913(ra)\n   0xbfc00108:  sw      gp,-16950(a0)\n   0xbfc0010c:  0x7f9f292a\n   0xbfc00110:  jalx    0xb02f4ffd\n   0xbfc00114:  0x720b0904\n   0xbfc00118:  0x6082ee6e\n   0xbfc0011c:  lwc2    $15,4232(t7)\n   0xbfc00120:  lwc1    $f1,-17410(a2)\n   0xbfc00124:  ldc2    $13,-24540(t7)\n   0xbfc00128:  ll      t7,-9333(t0)\n   0xbfc0012c:  0x1feb0088\n(gdb) restore ~/work_space/benji/splfdl/text_init.bin binary 0xbfc00100\nRestoring binary file /home/liguang/work_space/benji/splfdl/text_init.bin into memory (0xffffffffbfc00100 to 0xffffffffbfc03e40)\n(gdb) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0x82a0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(gdb) mon mww 0x82d030b4 0x80\n(gdb) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0x82a0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(gdb) b *0xbfc00100\nwarning: GDB can't find the start of the function at 0xa410486c.\n\n    GDB is unable to find the start of the function at 0xa410486c\nand thus can't determine the size of that function's stack frame.\nThis means that GDB may be unable to access that stack frame, or\nthe frames below it.\n    This problem is most likely caused by an invalid program counter or\nstack pointer.\n    However, if you think GDB should simply search farther back\nfrom 0xa410486c for code which looks like the beginning of a\nfunction, you can increase the range of the search using the `set\nheuristic-fence-post' command.\nBreakpoint 3 at 0xbfc00100\n(gdb) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0x82a0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(gdb) j *0xbfc00100\nContinuing at 0xbfc00100.\n\nProgram stopped.\n0xbfc00100 in ?? ()\n(gdb) x/12i 0xbfc00100\n=> 0xbfc00100:  0xf06275ff\n   0xbfc00104:  0xf06275ff\n   0xbfc00108:  0xf06275ff\n   0xbfc0010c:  0xf06275ff\n   0xbfc00110:  0xf06275ff\n   0xbfc00114:  0xf06275ff\n   0xbfc00118:  0xf06275ff\n   0xbfc0011c:  0xf06275ff\n   0xbfc00120:  0xf06275ff\n   0xbfc00124:  0xf06275ff\n   0xbfc00128:  0xf06275ff\n   0xbfc0012c:  0xf06275ff\n```\n\n\n\n## fpga验证\n\n```shell\n❯ mgdb.microAptiv 8888\nGNU gdb (GDB) 9.2\nCopyright (C) 2020 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"--host=x86_64-pc-linux-gnu --target=mips-mti-elf\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\nRemote debugging using localhost:7777\nwarning: No executable has been specified and target does not support\ndetermining executable automatically.  Try using the \"file\" command.\n0x00000000 in ?? ()\nThe target is assumed to be little endian\ntarget state: halted\ntarget halted in MIPS32 mode due to debug-request, pc: 0x82c476d8\n\"on\" or \"off\" expected.\n(microAptiv) mon mips32 cp0 config\n0xa4310582\n(microAptiv) x/i $pc\n=> 0x0: nop\n(microAptiv) x/i $pc\n=> 0x0: nop\n(microAptiv) mon mww 0xa2a00008 0x7ca41004\n(microAptiv) mon mww 0xa2a00000 0x40048000\n(microAptiv) mon mww 0xa2a00004 0x24050003\n(microAptiv) mon mww 0xa2a0000c 0x40848000\n(microAptiv) x/8i 0xa2a00000\n   0xa2a00000:  mfc0    t6,$16\n   0xa2a00004:  li      t7,3\n   0xa2a00008:  0x7dee1004\n   0xa2a0000c:  mtc0    t6,$16\n   0xa2a00010:  nop\n   0xa2a00014:  nop\n   0xa2a00018:  nop\n   0xa2a0001c:  nop\n=> (microAptiv) b *0xa2a00000\nBreakpoint 1 at 0xa2a00000\n==> (microAptiv) j *0xa2a00000\nContinuing at 0xa2a00000.\n\nProgram stopped.\n0xa2a00000 in ?? ()\n(microAptiv) disassemble 0xa2a00000,+0x20\nDump of assembler code from 0xa2a00000 to 0xa2a00020:\n=> 0xa2a00000:  mfc0    a0,$16\n   0xa2a00004:  li      a1,3\n   0xa2a00008:  0x7ca41004\n   0xa2a0000c:  mtc0    a0,$16\n   0xa2a00010:  nop\n   0xa2a00014:  nop\n   0xa2a00018:  nop\n   0xa2a0001c:  nop\nEnd of assembler dump.\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xa2a00000.\n\n    GDB is unable to find the start of the function at 0xa2a00000\nand thus can't determine the size of that function's stack frame.\nThis means that GDB may be unable to access that stack frame, or\nthe frames below it.\n    This problem is most likely caused by an invalid program counter or\nstack pointer.\n    However, if you think GDB should simply search farther back\nfrom 0xa2a00000 for code which looks like the beginning of a\nfunction, you can increase the range of the search using the `set\nheuristic-fence-post' command.\nwarning: GDB can't find the start of the function at 0xa2a00004.\n0xa2a00004 in ?? ()\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xa2a00008.\n0xa2a00008 in ?? ()\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xa2a0000c.\n0xa2a0000c in ?? ()\n(microAptiv) i r a0\na0: 0xa4310583\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xa2a00010.\n0xa2a00010 in ?? ()\n(microAptiv) mon mips32 cp0 config\n0xa4310583\n(microAptiv) disassemble 0xa2a00000,+0x20\nDump of assembler code from 0xa2a00000 to 0xa2a00020:\n   0xa2a00000:  mfc0    a0,$16\n   0xa2a00004:  li      a1,3\n   0xa2a00008:  0x7ca41004\n   0xa2a0000c:  mtc0    a0,$16\n=> 0xa2a00010:  nop\n   0xa2a00014:  nop\n   0xa2a00018:  nop\n   0xa2a0001c:  nop\nEnd of assembler dump.\n(microAptiv) mon mww 0x82d030b4 0x80000080\n(microAptiv) restore ~/work_space/benji/splfdl/text_init.bin binary 0xbfc00100\nRestoring binary file /home/liguang/work_space/benji/splfdl/text_init.bin into memory (0xffffffffbfc00100 to 0xffffffffbfc03cb0)\n(microAptiv) x/8i 0xbfc00100\n   0xbfc00100:  lui     a2,0xbfc0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,$9\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n(microAptiv) mon mww 0x82d030b4 0x80\n(microAptiv) b *0xbfc00100\nBreakpoint 2 at 0xbfc00100\n(microAptiv) j *0xbfc00100\nContinuing at 0xbfc00100.\n\nProgram stopped.\n0xbfc00100 in ?? ()\n(microAptiv) mon mips32 cp0 config\n0xa4310583\n(microAptiv) x/12i $pc\n=> 0xbfc00100:  lui     a2,0xbfc0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,$9\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv) x/12i 0xbfc00100\n=> 0xbfc00100:  lui     a2,0xbfc0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,$9\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xbfc00100.\nwarning: GDB can't find the start of the function at 0xbfc00104.\n0xbfc00104 in ?? ()\n(microAptiv) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0xbfc0\n=> 0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,$9\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv) file ~/u\nuA_baremetal.elf      uAptiv_Baremetal.elf  ua.bin\n(microAptiv) file ~/uA_baremetal.elf\nReading symbols from ~/uA_baremetal.elf...\nwarning: GDB can't find the start of the function at 0xbfc00104.\n(microAptiv) restore ~/u\nuA_baremetal.elf      uAptiv_Baremetal.elf  ua.bin\n(microAptiv) restore ~/work_space/benji/xy-bootrom/objs_release/uA_baremetal.bin binary 0x82c00000\nRestoring binary file /home/liguang/work_space/benji/xy-bootrom/objs_release/uA_baremetal.bin into memory (0xffffffff82c00000 to 0xffffffff82c1147f)\n(microAptiv) x/8i 0x82c00000\n   0x82c00000 <__reset_vector at src/startup/start.S:41>:       lui     a2,0x82c0\n   0x82c00004 <__reset_vector+4 at src/startup/start.S:41>:     addiu   a2,a2,1280\n   0x82c00008 <__reset_vector+8 at src/startup/start.S:43>:     jr      a2\n   0x82c0000c <__reset_vector+12 at src/startup/start.S:43>:    mtc0    zero,c0_count\n   0x82c00010 <_boot_rom+16 at src/startup/start.S:43>: nop\n   0x82c00014 <_boot_rom+20 at src/startup/start.S:43>: nop\n   0x82c00018 <_boot_rom+24 at src/startup/start.S:43>: nop\n   0x82c0001c <_boot_rom+28 at src/startup/start.S:43>: nop\n(microAptiv) b *0x82c00000\nBreakpoint 3 at 0x82c00000: file src/startup/start.S, line 41.\n(microAptiv) j *0x82c00000\nContinuing at 0x82c00000.\n\nProgram stopped.\n__reset_vector () at src/startup/start.S:41\n41              la a2,  check_nmi\n(microAptiv) ni\n0x82c00004      41              la a2,  check_nmi\n(microAptiv) x/12i 0xbfc00000\n   0xbfc00000:  lui     a2,0x82c0\n   0xbfc00004:  addiu   a2,a2,0\n   0xbfc00008:  jr      a2\n   0xbfc0000c:  nop\n   0xbfc00010:  nop\n   0xbfc00014:  nop\n   0xbfc00018:  nop\n   0xbfc0001c:  nop\n   0xbfc00020:  nop\n   0xbfc00024:  nop\n   0xbfc00028:  nop\n   0xbfc0002c:  nop\n(microAptiv) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0xbfc0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv) ni\n43              jr a2\n(microAptiv) x/8i $pc\n=> 0x82c00008 <__reset_vector+8 at src/startup/start.S:43>:     jr      a2\n   0x82c0000c <__reset_vector+12 at src/startup/start.S:43>:    mtc0    zero,c0_count\n   0x82c00010 <_boot_rom+16 at src/startup/start.S:43>: nop\n   0x82c00014 <_boot_rom+20 at src/startup/start.S:43>: nop\n   0x82c00018 <_boot_rom+24 at src/startup/start.S:43>: nop\n   0x82c0001c <_boot_rom+28 at src/startup/start.S:43>: nop\n   0x82c00020 <_boot_rom+32 at src/startup/start.S:43>: nop\n   0x82c00024 <_boot_rom+36 at src/startup/start.S:43>: nop\n(microAptiv) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0xbfc0\n   0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv) b *0xbfc00100\nNote: breakpoint 2 also set at pc 0xbfc00100.\nBreakpoint 4 at 0xbfc00100\n(microAptiv) j *0xbfc00100\nContinuing at 0xbfc00100.\n\nProgram stopped.\n0xbfc00100 in ?? ()\n(microAptiv) ni\nwarning: GDB can't find the start of the function at 0xbfc00100.\nwarning: GDB can't find the start of the function at 0xbfc00104.\n0xbfc00104 in ?? ()\n(microAptiv) x/12i 0xbfc00100\n   0xbfc00100:  lui     a2,0xbfc0\n=> 0xbfc00104:  addiu   a2,a2,1172\n   0xbfc00108:  jr      a2\n   0xbfc0010c:  mtc0    zero,c0_count\n   0xbfc00110:  nop\n   0xbfc00114:  nop\n   0xbfc00118:  nop\n   0xbfc0011c:  nop\n   0xbfc00120:  nop\n   0xbfc00124:  nop\n   0xbfc00128:  nop\n   0xbfc0012c:  nop\n(microAptiv)\n```\n\n```\ntest 按下\nThe CRU Status regs are: 0x5801 0x3347\nThe CRU Status regs are: 0x1 0x3347\n```\n\n","tags":["ipsram"],"categories":["MIPS"]},{"title":"Qcow2 qemu 打包日记","url":"/2021/03/25/hxd_new/riscv调研/镜像打包笔记/","content":"\n# Qcow2 qemu 打包日记\n\n```shell\nmodprobe nbd\nqemu-img create -f qcow2 image.qcow2 1G\nsudo qemu-nbd --connect=/dev/nbd0 image.qcow2\nsudo sgdisk -g --clear -a 1 \\\n\t--new=1:34:2081         --change-name=1:spl --typecode=1:5B193300-FC78-40CD-8002-E86C45580B47 \\\n\t--new=2:2082:10273      --change-name=2:uboot  --typecode=2:2E54B353-1271-4842-806F-E436D6AF6985 \\\n\t--new=3:16384:282623    --change-name=3:boot --typecode=3:0x8300 \\\n\t   /dev/nbd0\nsudo dd if=<u-boot_root_path/build/u-boot.itb> of=/dev/nbd0p2   \"将u-boot.itb 拷贝到sd卡的第二个分区\"\nsudo mkfs.ext4 /dev/nbd0p3\nsudo mount /dev/nbd0p3 <mnt_dir>\ncp Image wave,boston-kingv.dtb <mnt_dir> \"Image 为 kernel 编译出的 <build>/arch/riscv/boot/Image, dtb 为kernel 用的dtb\"\nsudo umount <mnt_dir> sudo qemu-nbd --disconnect /dev/nbd0\n```\n# 制作分区\n```shell\nsudo sgdisk -g --clear -a 1 \\\n  --new=1:34:2081         --change-name=1:spl --typecode=1:5B193300-FC78-40CD-8002-E86C45580B47 \\\n  --new=2:2082:10273      --change-name=2:uboot  --typecode=2:2E54B353-1271-4842-806F-E436D6AF6985 \\\n  --new=3:16384:282623    --change-name=3:boot --typecode=3:0x0700 \\\n  --new=4:286720:2018207 --change-name=4:root --typecode=4:0x8300 \\\n  test.img\n```\n\n# 挂载\n\n```shell\nsudo fdisk -l test.img\nsudo losetup -f --show -P test.img\nsudo mount /dev/loopXpX mnt\n```\n\n# 无卡启动\n\n## 配置tftpd\n\n```shell\nsudo apt install tftpd-hpa\nsudo vi /etc/default/tftpd-hpa   #编辑 /etc/default/tftpd-hpa\n# /etc/default/tftpd-hpa\n\nTFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/srv/tftp\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"-s\"\n\nsudo chmod 777 -R /srv/tftp\n```\n配置完后, tftp 使用的目录为 `/srv/tftp`\n\n将编出的 work/image.fit 拷贝到该文件夹中\n\n本机测试\n```shell\ntftp localhost\n> get image.fit\n```\n\n无错误代表没问题\n\n# 开发板 u-boot tftp 下载\n\n```shell\nStarFive # setenv ipaddr 192.168.xx.xx;setenv serverip 192.168.xx.xx\n```\n\nserverip 为 tftpd 即刚才配置好 tftpd 的ip\nipaddr 为 开发版的 ip\n\n开发板 u-boot 配置环境变量\n\n1. set enviroment parameter:\n```shell\nsetenv bootfile vmlinuz; setenv fileaddr a0000000; setenv fdtcontroladdr 0xffffffffffffffff;\n```\n2. upload image file to ddr:\n```shell\ntftpboot ${fileaddr} ${serverip}:image.fit;\n```\n> 如果下载不了, 执行下 `run bootcmd_dhcp` 再执行下  `tftpboot ${fileaddr} ${serverip}:image.fit`\n\n3. load and excute:\n```shell\nbootm start ${fileaddr};bootm loados ${fileaddr};run chipa_set_linux;booti 0x40200000 0x46100000:${filesize} 0x46000000\n```\n4. login\n```shell\nbuildroot login:root\nPassword: starfive\n```\n\n# 更新spl uboot\n更新SPL二进制文件\n```shell\ntftpboot 0xa0000000 ${serverip}:u-boot-spl.bin.normal.out\nsf update 0xa0000000 0x0 $filesize\n```\n\n更新U-Boot二进制文件\n```shell\ntftpboot 0xa0000000 ${serverip}:visionfive2_fw_payload.img\nsf update 0xa0000000 0x100000 $filesize\n```","tags":["qemu","pack"],"categories":["qemu","visionfive2"]},{"title":"ecc windows api 使用","url":"/2021/03/24/hxd_new/ecc384 verify lib windows api 使用文档/","content":"\n# 签名\n\n## 签名文件\n\n```cmd\n.\\sign_file.exe -d -r .\\driver_test_key\\ecc_priv_key -b <待签文件路径> -e <签名后的文件路径> -s\n```\n\n## 验证是否验签正常\n\n```cmd\n.\\sign_file.exe -d -u .\\driver_test_key\\ecc_pub_key  -e <签名后的文件路径> -v\n```\n\n\n\n# 验签\n\n## 验签接口 verifyFile\n\n```c\n#pragma once\n/*\n* ecc verify file to check if sign by specific priv key\n* input:\n* fp: input file pointer by fopen\n* fileSize: file size by stat.st_size\n* out:\n* return 0: verify success, -1: verify fail\n*/\nint verifyFile(FILE* fp, int fileSize);\n```\n\n> 上面的实现代码就是VerifyLibApi.h的内容\n\n## 使用示例\n\n``` c\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include \"VerifyLibApi.h\"\n\nint main()\n{\n    struct stat dat_stat;\n    const char* dat_path = \"C:\\\\Users\\\\1\\\\Documents\\\\test.dat\";\n\n    if (stat(dat_path, &dat_stat) != 0) {\n        printf(\"stat %s failed:%s\\n\", dat_path, strerror(errno));\n        return -1;\n    }\n\n    FILE* fp = fopen(dat_path, \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't read_file_bytes\\n\");\n        return -1;\n    }\n    if (0 != verifyFile(fp, dat_stat.st_size))\n    {\n        printf(\"verifyFile failed!\\n\");\n        if (fp != NULL) fclose(fp);\n        return -1;\n    }\n    if (fp != NULL) fclose(fp);\n    return 0;\n}\n```\n\n## VisualStudio 使用示例\n\n上面使用的接口输出的库是静态库`VerifyLib.lib`\n\n在VisualStudio 开发时, 可以按下面的示例配置使用该库\n\n首先lib库给出的有两个版本, 分别是debug版本和release版本用的\n\ndebug和release都需要配置\n\n\n\n### debug配置示例\n\nVC++目录 -> 库目录 中添加debug版本的库所在的文件夹的路径\n\n![image-20220314103457471](C:\\Users\\1\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220314103457471.png)\n\n链接器->输入->附加依赖项 中添加对应的VerifyLib库的文件名\n\n![image-20220314103547303](C:\\Users\\1\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220314103547303.png)\n\n\n\nrelease 版本的配置过程跟debug版本一样, 不再赘述","tags":["ecc"],"categories":["加密"]},{"title":"ecc 蒙哥马利","url":"/2021/03/23/hxd_new/ecc 蒙哥马利/","content":"\n# 蒙哥马利算法(Montgomery Algorithm)|蒙哥马利约简、模乘\n\n模乘是为了计算`ab(mod M)`。普通算法中，在计算模M时，利用的是带余除法，除法运算需要太多次乘法，计算复杂度较高\n\n蒙哥马利算法的思想就是利用进制表示简化除法运算，转化成位运算。\n\n\n\n给定大数 a, b. 素数模 m\n\n目的是求 Z = ab(mod m)\n\n\n\n转化为蒙哥马利域算式:\n\n\n\n先计算 aR(mod m), bR(mod m), 其中R=2^k, k=log2(m)\n\n第一次蒙哥马利约简:\n\nZ'= aR * bR * R^-1 (mod m) = abR(mod m)                   (1)\n\n第二次蒙哥马利约简:\n\nZ = Z' * R^-1(mod m) = abR * R^-1 (mod m) = ab (mod m)     (2)\n\n\n\n第二次约简后即可求出最终的结果.\n\n\n\n## 蒙哥马利约简\n\n> 核心思想是利用进制移位简化除法运算\n\n\n\nMontgomery reduction(X,R,m):\n\n### 参数:\n\n1.  X    ----------- 输入操作数, 比如对应第一次蒙哥马利约简, aR*bR(mod m)即为X\n2.  R    ----------- 根据模m选定的数R, 即上面的R\n3.  m    ----------- 模 m\n\n### 步骤:\n\n1. 计算m'=m^-1 (mod R), (m' 也被称为mp), n = Xm'(mod R)\n2. 计算y=(X+nm)/R (mod m) --- 将X+nm 右移k位得到最终结果y ( R=2^k, k=log2(m) )        \n\n\n\n### 分析:\n\n1. (X+nm)/R (mod m) ===  X * R^-1 (mod m) ?\n\n​\t同余运算, 因为 nm/R (mod m) === 0, 所以相等\n\n\n\n2. n 是怎么得来的 ?\n\n​\t这里n要满足算式:\n\n​\tX+nm === 0 (mod R) 只有这样, (X+nm)/R 才能将除法转化为进制移位计算\n\n\n\n​\t根据R的定义, R要满足 gcd(R, m)=1, 即 R和m之间最大公约数是1, 即R和m 互质. 这里因为 m 一般为素数, 而R=2^k所以这个条件是满足的,\n\n​\t根据扩展的欧几里得算法:\n\n​\tRR′−mm′=1 即 mm'=RR'-1\n\n​\t\n\n​\tX+nm === 0 (mod R)\n\n​    Xm' + nmm' === 0 (mod R)\n\n​    Xm' + n(RR'-1) === 0 (mod R)\n\n​    Xm' - n === 0 (mod R)\n\n​    n === Xm' (mod R)\n\n## 蒙哥马利预计算\n\n从上面的约简过程看, 预计算最重要的参数是m'(mp), 同时 R   R^-1 (mod m)  R^2 (mod m) 也是需要预计算的\n\n即一次ab(mod m)需要两次蒙哥马利约简, 且输入其实不是ab 而是 a'b' = ab * R^2, 所以需要提前计算 abR^2的值.\n\n> 注意一个数的逆只有在取模时才有意义, 没有模哪来的逆, 逆也是对某个模而言的, 换了模,这个数的逆就变成另一个值了","tags":["ecc"],"categories":["加密"]},{"title":"dm-verity 移植","url":"/2021/03/22/hxd_new/dm-verity移植/","content":"\n# buildroot 编译 cryptsetup\n\n需要编译依赖包: libdevmapper libpopt libuuid libjson-c libcrypto (openssl包)\n嵌入式平台编译比较麻烦, 交叉工具链会报很多头文件 库文件的错误,  建议直接由buildroot编译交叉工具链, 这样后续生成的库文件  头文件才能正常找到, 还有cmake 用到的.cmake 包,  pkgconfig的路径等.\n\n最终生成文件  cryptsetup veritysetup dmsetup libcryptsetup.so\n\n# 测试\n\n```bash\nmkfs.ext4 -b 4096 fs.img 4096\nveritysetup format fs.img hashtree.img\n#as: Root hash:              d004843ab1abc42dbdcf320b7189d871536cdf6e5e6e2c03c2c0fd20dfc2fe9a\n记下$root_hash\nveritysetup create vroot fs.img hashtree.img $root_hash\nmount /dev/mapper/vroot mount_point\n```\n\n# 编译kernel 支持dm-verity\n\n```bash\nmake menuconfig\n# Find the following options in the menuconfig and change them as described:\n# Device Drivers → Multiple devices driver support (RAID and LVM) → Device mapper support → change to * (YES)\n# Device Drivers → Multiple devices driver support (RAID and LVM) → Device mapper support → DM \"dm-mod.create=\" parameter support → change to * (YES)\n# Device Drivers → Multiple devices driver support (RAID and LVM) → Device mapper support → Verity target support → change to * (YES)\n```\n\n# kernel 调试\n\n## 去掉优化\n子模块中的Makefile可以通过`CFLAGS_xxx.o += -O0` 去掉某个源文件的编译优化\n但还是有很多文件不支持 -O0 编译, 可以再细分, 按函数就行 -O0 编译\n`__attribute__((optimize(\"O0\")))`\n","tags":["dm-verity"],"categories":["加密"]},{"title":"stm32 crypto 性能数据","url":"/2021/03/12/hxd_new/crypto 性能数据/","content":"\n## stm32_750\n中断耗时 29264\n\n\n| 算法               | 数据量 | 耗时                       | 数据量 | 耗时                           |\n| ------------------ | ------ | -------------------------- | ------ | ------------------------------ |\n| aes-cbc-128        | 40k    | 199368                     | 64k    | (342000+291048)/2-29264=287260 |\n| aes-cbc-192        | 40k    | 178104                     | 64k    | (323104+291408)/2-29264=277992 |\n| aes-cbc-256        | 40k    | 161520                     | 64k    | (294192+271480)/2-29264=253572 |\n| sha2-224           | 40k    | 190392-28120+5904 = 168176 | 64k    | 287528-28120+5904 = 265312     |\n| sha2-256           | 40k    | 189904-28102+5776 = 167578 | 64k    | 286184-28102+5776 = 263858     |\n| crc32 (0x04C11DB7) | 40k    | 140136                     | 64k    | 223754                         |\n| crc16-ccitt        | 40k    | 142600                     | 64k    | 223853                         |\n| crc8-ccitt         | 40k    | 139858                     | 64k    | 223461                         |\n| TRNG               | 40k    | 1130608                    | 64k    | 1793120                        | \n\n\nsha2-256 4k `43504+21264-28120=`  36648\n\n```\nc \"1/(480*1000*1000) * 36648\" = 0.00007 s //for hash-256 4k\nc \"1/(480*1000*1000) * 167578 / 40 * 1024\" = 0.009s\n```\n### 1M 数据时间\n```\nc \"1/(480*1000*1000)*(199368)/40*1024\" = 0.01s   //aes-128 750\nc \"1/(400*1000*1000)*(626550)/40*1024\" = 0.04s   // aes-256 cip\nc \"1/(400*1000*1000)*(1002480/64)*1024\" = 0.04s  // aes-256 cip\n```\n\n```\nc \"64*1024*8/1793120\" = 0.3 bit/cycle    //trng\nc \"1/(480*1000*1000) * 167578\" = 0.00035s    //sha-256 40k \n```\n## CIP_1901\n\n| 算法               | 数据量 | 耗时     | 数据量 | 耗时    |      |         |\n| ------------------ | ------ | -------- | ------ | ------- | ---- | ------- |\n| aes-cbc-128        | 40k    | 462550   | 64k    | 740032  |      |         |\n| aes-cbc-256        | 40k    | 626550   | 64k    | 1002480 |      |         |\n| sha2-256           | 40k    | 174700   | 64k    | 279268  | 512k | 2237620 |\n| sha2-384           | 40k    | 113784   | 64k    | 181788  | 512k | 1518852 | \n| crc32 (0x04C11DB7) | 40k    | 128204   | 64k    | 204158  |      |         |\n| crc16-ccitt        | 40k    | 129834   | 64k    | 205702  |      |         |\n| crc8-ccitt         | 40k    | 128184   | 64k    | 204164  |      |         |\n| ecc-192-sign       | 16     | 609418   |        |         |      |         |\n| ECC-224-sign       | 16     | 745262   |        |         |      |         |\n| ECC-256-sign       | 16     | 870176   |        |         |      |         |\n| ECC-384-sign       | 16     | 1571708  |        |         |      |         |\n| ECC-192-verify     | 16     | 6753310  |        |         |      |         |\n| ECC-224-verify     | 16     | 8529408  |        |         |      |         |\n| ECC-256-verify     | 16     | 11227626 |        |         |      |         |\n| ECC-384-verify     | 16     | 25775968 |        |         |      |         |\n| ECC-256-sign       | 32     | 870134   |        |         |      |         |\n| ECC-384-sign       | 32     | 1571634  |        |         |      |         |\n| ECC-256-verify     | 32     | 11489984 |        |         |      |         |\n| ECC-384-verify     | 32     | 26295924 |        |         |      |         |\n| Ecc-384-sign       | 48     | 1571480  |        |         |      |         |\n| ECC-384-verify     | 48     | 25897978 |        |         |      |         |\n\n```\nc \"1/(400*1000*1000)*25897978\" = 0.0647s\nc \"1/(400*1000*1000)*11489984\" = 0.028 s  //for ecc-256 verify\n```\n\n## security-boot\n| 分区       | 大小 | 校验方式                  | 硬件时间                            |\n| ---------- | ---- | ------------------------- | ----------------------------------- |\n| spl        | 1M   | aes256 + hash256 + ecc256 | 0.01 + 0.009 + 0.028 =  0.047       |\n| bootloader | 2M   | aes256 + hash256 + ecc256 | `(0.01 + 0.009 )*2 + 0.028` = 0.066 |\n| tz         | 4M   | aes256 + hash256 + ecc256 | `(0.01 + 0.009)*4 + 0.028` = 0.104 |\n| dtbo       | 16M  | aes256 + hash256 + ecc256 | `(0.01 + 0.009)*16 + 0.028` = 0.332 |\n| boot       | 32M  | aes256 + hash256 + ecc256 | `(0.01 + 0.009)*32+ 0.028` = 0.636  |\n| system     | 40G  | ecc256 + dm-verity        | 0.028 + ...                         | \n\n校验链:\n\nbootrom -> spl -> tz -> bootloader -> dtbo -> boot->  ...  system\n\n\n### dm-verity hash-tree\n\n[verity-40G](../Excalidraw/verity-40G.svg)\n\n![verity-40G](images/dm_verify.svg)\n\n\n\n\n根据 hashtree 的生成方式，以 40G 的镜像为例：\n\n1）按照 4K 大小划分，将40G 大小的镜像依顺序划分可得到 10485760 个 4k 大小的块\n\n2）对这 10485760 块数据块进行第一层(Level 0) hash 计算，由于 SHA256(具体的hash算法可配置，此例以SHA256为参考) 计算出来的hash值占 256 个字节，一个 4K 的块可以存储 128 个hash值，所以存储这 10485760 块数据块的hash值需要花费 81920 块\n\n3）对第一层存储 hash 值的数据块进行第二层(Level 1) 的 hash 计算，同理，计算这 81920 块hash数据块需要花费 640 块\n\n4)  对第二层存储 hash 值的数据块进行第二层(Level 2) 的 hash 计算，同理，计算这 640 块hash数据块需要花费 5 块\n\n5）对第三层存储 hash 值的数据块进行第三层(Level 3) 的 hash 计算，由于第二层的hash数据块小于128块，所以第三层是最后一层，直接计算得到 root hash 数据块(不够4K大小补齐0)。\n\n校验:\n\n1. 假设目前正需要读取第 200000 块的数据块，通过前面哈希树的构造，可以比较快速的计算出在 Level 0 层，也就是直接对应这个数据块的hash值存储位置，通过对 128 相除以及求余的方式就可以分别计算出该 hash 值存储在具体某一块(块A)以及这一块上的偏移(偏移A)。\n2. 确定了 Level 0 层的具体块A后，利用相同的方式可以得到 Level 0 块A在 Level 1 层存储其 hash 值的块B位置以及块B上的偏移(偏移B)\n3. 同上可以定位到 Level 1 层块 B 在 Level 2 上的数据块上偏移(偏移C)\n4. 最终定位level2 层 在 level 3 数据块上的偏移 (偏移 D)\n\n计算:\n\n1. 计算level3 块(只有一块)的hash 256值, 即 root hash, root hash与verity table的hash 比较, 如果不一致则说明被非法修改了\n2. 计算level2 层 (偏移C) 所在块的 hash,  与level3 层偏移D处的 32bytes 的hash 比较, 如不一致则说明 level2 层偏移 C 所在块被非法修改了\n3. 计算level1 层(偏移B) 所在块的 hash , 与level2 层偏移 C 处的 32bytes的hash值比较, 如不一致则说明level 1 层偏移 B 所在块被非法修改了\n4. 计算 level 0 层(偏移A) 所在块的 hash, 与 level 1层偏移 B 处的 32bytes的hash值比较, 如不一致则说明 level 0 层的偏移 A 处的所在块被非法修改了\n5. 计算 raw data 层(被访问的原始数据) 所在块的 hash , 与level 0 层偏移 A 处的 32 bytes 的hash 值比较, 如不一致则说明 raw data层现在正在访问的数据被非法修改了\n\n因此 read  40G分区上的一个4k 块额外需要    hash256(4k)  5次 (0.00007s *5) 时间.\n\n\n\n\n\n","tags":["stm32"],"categories":["加密"]},{"title":"mips 打包烧写工具","url":"/2020/10/25/hxd_new/pack/","content":"\n# 生成从flash启动的文件\n\n  \n\nboot模式启动后自动运行\n\n  \n\n## 烧写规范\n\n  \n\n目前仅支持烧写spl fdl 和 大核的bin, ua-validation的bin 只能先伪装成spl来测试boot流程.\n\nromcode 固化的代码中将spl下载到了ahbsram区域, 因此ua的bin也会下载到ahbsram上, 最大只能到128k\n\n  \n\n<a name=\"ua\">\n\n  \n\n## 小核镜像打包\n\n  \n  \n\n当前只能做普通非加密模式的bin, ua-validation生成的产物\n\n- `validation/uAptiv_Baremetal.elf`  \n\n- `validation/uAptiv_Baremetal.bin` 未做header包裹的bin, 不能直接用\n\n- `validation/spl_non_sec.bin` 生成了header, 可以作为spl烧写到flash 中, 给到烧机工具, 填到spl槽位\n\n  \n\n<a name=\"ua_pack\">\n\n  \n\n### 单独打包小核镜像\n\n  \n\n> 本节没有特殊需求, 可以不用看\n\n  \n  \n\n如果需要根据`uAptiv_Baremetal.elf`文件重新打包出能烧写到flash中的符合规范的bin, 请参考下面的步骤:\n\n  \n\n在代码根目录下:\n\n  \n\n```shell\n\ncd validation;\n\nmips-mti-elf-objcopy -O binary uAptiv_Baremetal.elf uAptiv_Baremetal.bin\n\n../tools/sign_tool.py -n --ua --source . --out .\n\n```\n\n生成的文件spl_non_sec.bin 给到烧机工具即可\n\n  \n\n> 如果没有单独打包小核镜像的需求, [单独打包小核镜像](#ua_pack) 小节直接忽略就行, 默认编译结果已经包含\n\n  \n\n## 大核镜像打包\n\n  \n\n当前只能做普通非加密模式的bin, ia-validation生成的产物\n\n  \n\n- `ia-validation/iAptiv_Baremetal.elf`\n\n- `ia-validation/iAptiv_Baremetal.bin`  未做header包裹的bin, 不能直接用\n\n- `ia-validation/ia_non_sec.bin`        生成了header, 可以作为ia烧写到flash 中, 给到烧机工具, 填到ia槽位\n\n  \n\n<a name=\"ia_pack\">\n\n  \n\n### 单独打包大核镜像\n\n  \n  \n\n> 本节没有特殊需求, 可以不用看\n\n  \n\n如果需要根据`iAptiv_Baremetal.elf`文件重新打包出能烧写到flash中的符合规范的bin, 请参考下面的步骤:\n\n  \n\n在代码根目录下:\n\n  \n\n```bash\n\ncd ia-validation;\n\nmips-mti-elf-objcopy -R .text_init -O binary iAptiv_Baremetal.elf iAptiv_Baremetal_App.bin\n\nmips-mti-elf-objcopy -j .text_init -O binary iAptiv_Baremetal.elf iAptiv_Baremetal_Boot.bin\n\ncat iAptiv_Baremetal_Boot.bin iAptiv_Baremetal_App.bin > iAptiv_Baremetal.bin\n\n../tools/sign_tool.py -n --ia --source . --out .\n\n```\n\n  \n\n生成的文件ia_non_sec.bin 给到烧机工具即可\n\n  \n\n> 如果没有单独打包大核镜像的需求,  [单独打包大核镜像小节](#ia_pack) 直接忽略就行, 默认编译结果已经包含\n\n  \n\n### 烧写大核启动镜像\n\n  \n\n启动到大核需要spl转接, 不是上面 [ua-validation](#ua), 下载这里的[spl_non_sec_real.bin](http://172.16.10.114/tool/hxd1901/spl_non_sec_real.bin)\n\n  \n\n烧写大核时需要同时把 fdl spl (spl_non_sec_real.bin) 和 当前编出的大核的bin(ia_non_sec.bin) 烧入对应槽\n\n  \n\n![2230995-20210517010440573-253963743](../gdb/image/2230995-20210517010440573-253963743.png)","tags":["pack 工具"],"categories":["MIPS"]},{"title":"pll 相关","url":"/2020/10/25/hxd_new/pll相关/","content":"\n## 性能指标\n\n相位噪声、杂散以及瞬态响应\n\n### 相位噪声\n\n在频域中，这通常被认为是噪声功率相对于载波功率的密度\n\n频谱分析仪测试相位噪声的一个示例。\n\n![img](https://pic1.zhimg.com/v2-96dbe248455431a21b34b8b8ed7e66dc_b.jpg)\n\n\n### 杂散\n\n**杂散可以被认为是集中在与载波的特定偏移处的噪声。**\n\n杂散有很多种，它们可能有多种原因，但其中大多数发生在非常可预测的偏移处。 杂散倾向于出现在鉴频鉴相器频率、输入参考频率、通道间隔和几分之一通道间隔的倍数处。\n\n![img](https://pic4.zhimg.com/v2-669fbe125d44307b36b64d85fafc5087_b.jpg)\n\n### **瞬态响应和锁定时间**\n\n锁定时间通常被认为是在 N 分频器值改变后 PLL 稳定到给定频率容差所需的时间量。锁定时间定义可以扩展到包含相位扰动或容差表示为相位误差而不是频率误差的情况。\n\n**锁定时间是 PLL 改变频率所需的时间**, 当 PLL 切换频率时，无法传输数据，因此 PLL 的锁定时间必须锁定足够快，以免降低数据速率。 锁定时间也可能与功耗有关。\n\n\n\n### 软件改动\n\n修改pll分频系数, 测试响应时间\n\n## CRU/Power 测试 case\n\n| CRU/Power | 测试关闭uart0 时钟     | SOC相关 | 可选 | 不测 | 不测 | test_disable_uart0    | 测试关闭uart0 时钟, 观察uart0 是否打印log, 示波器看uart0 时钟是否关闭, 测试空载电流 |\n| --------- | ---------------------- | ------- | ---- | ---- | ---- | --------------------- | ------------------------------------------------------------ |\n| CRU/Power | 测试开启uart0 时钟     | SOC相关 | 可选 | 不测 | 不测 | test_enable_uart0     | 测试开启uart0 时钟,观察uart0 是否打印log, 示波器看uart0 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试关闭uart1 时钟     | SOC相关 | 可选 | 不测 | 不测 | test_disable_uart1    | 测试关闭uart1 时钟,观察uart1 是否打印log, 示波器看uart1 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试开启uart1 时钟     | SOC相关 | 可选 | 不测 | 不测 | test_enable_uart1     | 测试开启uart1 时钟,观察uart1 是否打印log, 示波器看uart1 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试关闭uart2时钟      | SOC相关 | 可选 | 不测 | 不测 | test_disable_uart2    | 测试关闭uart2时钟,观察uart2 是否打印log, 示波器看uart2 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试开启uart2 时钟     | SOC相关 | 可选 | 不测 | 不测 | test_enable_uart2     | 测试开启uart2 时钟,观察uart2 是否打印log, 示波器看uart2 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试关闭ao qspi0 时钟  | SOC相关 | 可选 | 不测 | 不测 | test_ao_qspi_disable  | 测试关闭ao qspi0 时钟, 测试qspi0 是否正常工作, 示波器看qspi0 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试打开ao qspi0 时钟  | SOC相关 | 可选 | 不测 | 不测 | test_ao_qspi_enable   | 测试打开ao qspi0 时钟, 测试qspi0 是否正常工作, 示波器看qspi0 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试关闭pd1 qspi1时钟  | SOC相关 | 可选 | 不测 | 不测 | test_pd1_qspi_disable | 测试关闭pd1 qspi1时钟, 测试qspi1 是否正常工作,,示波器看qspi1 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试打开pd1 qspi1 时钟 | SOC相关 | 可选 | 不测 | 不测 | test_pd1_qspi_enable  | 测试打开pd1 qspi1 时钟, 测试qspi1 是否正常工作, 示波器看qspi1 时钟是否关闭,测试空载电流 |\n| CRU/Power | 测试关闭ao 外设时钟    | SOC相关 | 可选 | 不测 | 不测 | test_ao_peri_disable  | 测试关闭ao 外设时钟, 测试ao 外设是否可以工作, 测试空载电流   |\n| CRU/Power | 测试关闭pd1 外设时钟   | SOC相关 | 可选 | 不测 | 不测 | test_pd1_peri_disable | 测试关闭pd1 外设时钟, 测试pd1 外设是否可以工作, 测试空载电流 |\n\n### 外设相关的疑问\n\n![image-20220208140926281](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20220208140926281.png)\n\n\n\n例如pd1上 qspi 有两个时钟的enable mask\n\npd1_hclk_qspi 和 pd1_refclk_qspi, 很多外设都有两个enable mask, 如果要关闭该外设的时钟,需要设置哪个\n\n1. Power_domain_1_bus_clock_enable (offset = 0xc)\n\n\n\n![image-20220208141234617](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/1111.png)\n\n\n\n2. Power_domain_1_peripheral_clock_enable (offset = 0x18)\n\n![image-20220208141343394](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20220208141343394.png)\n\n\n\n![image-20220208141428930](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20220208141428930.png)\n\n### 低功耗模式\n\nao low power mode\n\nvad 在ao 域上, 可以关闭pd1? ao 需要从active mode 切换到 low power mode上.\n\nao 切换到 low power mode 后, ao_root_clk 就变成 12.288MHZ了? 在这个频率下vad ip是否可以正常工作? 是用的ao_i2s_clk的频率吗? dma2 是用的ahb_clk吗, 在12.288MHz下是否可以正常工作\n\nao 从 active mode 切换到 low power mode 除了设置 power_control.bit[0] 外需要哪些前置步骤和后置步骤\n\n通过中断唤醒ao 域时, 是否需要重新走ao 和 pd1 状态机的流程?\n\nao_active ao_lp 模式怎么相互切换?\n\nldo怎样enable?\n\n\n\nlow_power_mode 到 active 状态切换以及开启所有需要工作的时钟 的响应时间\n\nlp->active 状态时的功耗测试\n\n\n\n## 默认时钟频率\n\n\n```\nCLOCK_FREQ_1M                             1000k\nMAIN_CLOCK_REF                            12288k\nPLL_CLOCK_OUT                             400000k\nCPU_ROOT_CLOCK                            400000k\nIAPTIV_CORE_CLOCK                         400000k\nUAPTIV_CORE_CLOCK                         200000k\nRTC_CLK_REF                               32k\nMIPS_PLL_CLK                              400000k\nMIPS_ROOT_CLK                             400000k\nMIPS_IAPTIV_MIPS_CLK                      400000k\nMIPS_IAPTIV_AXI_CLK                       200000k\nMIPS_IAPTIV_AHB_CLK                       100000k\nMIPS_IAPTIV_APB_CLK                       50000k\nMIPS_IAPTIV_PERI_CLK                      200000k\nMIPS_IAPTIV_QSPI_CLK                      400000k\nMIPS_IAPTIV_UART_CLK                      36864k\nMIPS_IAPTIV_I2C_CLK                       50000k\nMIPS_IAPTIV_USBPHY_CLK                    25000k\nMIPS_UAPTIV_AHB_CLK                       200000k\nMIPS_UAPTIV_APB_CLK                       100000k\nMIPS_UAPTIV_QSPI_CLK                      400000k\nMIPS_UAPTIV_UART_CLK                      36864k\nMIPS_UAPTIV_I2S_CLK                       12288k\nMIPS_UAPTIV_GPIO_CLK                      1024k\nMIPS_UAPTIV_RTC_CLK                       32k\nPD1_BUS_CLK_AXI_DEFAULT                   200000k\nPD1_BUS_CLK_AHB_DEFAULT                   100000k\nPD1_BUS_CLK_APB_DEFAULT                   50000k\nPD1_BUS_CLK_PERI_DEFAULT                  200000k\nPD1_PERI_CLK_QSPI_REF_DEFAULT             400000k\nPD1_PERI_CLK_UART_DEFAULT                 36864k\nPD1_PERI_CLK_I2C_DEFAULT                  50000k\nPD1_PERI_CLK_SPI_DEFAULT                  50000k\nPD1_PERI_CLK_USBPHY_DEFAULT               25000k\nPD1_UART1_CLK                             36864k\nPD1_UART2_CLK                             36864k\nAO_QSPI_PCLK                              400000k\nAO_AHB_CLK                                200000k\nAO_APB_CLK                                100000k\nAO_WDT_PCLK                               100000k\nAO_GPIO_PCLK                              1024k\nAO_TIMER_PCLK                             100000k\nAO_UART0_CLK                              36864k\nAO_BUS_CLK_AHB_DEFAULT                    200000k\nAO_BUS_CLK_APB_DEFAULT                    100000k\nAO_PERI_CLK_QSPI_REF_DEFAULT              400000k\nAO_PERI_CLK_UART_DEFAULT                  36864k\nAO_PERI_CLK_I2S_DEFAULT                   12288k\nAO_PERI_CLK_PDM_DEFAULT                   12288k\nAO_PERI_CLK_VAD_DEFAULT                   12288k\nAO_PERI_CLK_GPIO_DEFAULT                  1024k\n```\n\n\n\n","tags":["pll"],"categories":["时钟"]},{"title":"mips cp0","url":"/2020/09/25/hxd_new/mips协处理器/","content":"\n# MIPS 的协处理器 CP0 (Section 1)\n\n在 MIPS 体系结构中，最多支持 4 个协处理器 (Co-Processor)。其中，协处理器 CP0 是体系结构中必须实现的。它起到控制 CPU 的作用。MMU、异常处理、乘除法等功能，都依赖于协处理器 CP0 来实现。它是 MIPS 的精髓之一，也是打开 MIPS 特权级模式的大门。\n　　MIPS 的 CP0 包含 32 个寄存器。关于它们的资料可以参照 MIPS 官方的资料 MIPS32(R) Architecture For Programmers Volume III: The MIPS32(R) Privileged Resource Architecture 的 Chap7 和 Chap8。本文中，仅讨论常见的一些寄存器。\n\n- Register 0: Index，作为 MMU 的索引用。将来讨论 MMU 和 TLB 时会详解之\n- Register 2, EntryLo0，访问 TLB Entry 偶数页中的地址低 32Bit 用。同上，在 MMU 和 TLB 的相关章节中详解。\n- Register 3, EntryLo1，访问 TLB Entry 奇数页中的地址低 32Bit 用。\n- Register 4, Context，用以加速 TLB Miss 异常的处理。\n- Register 5, PageMask，用以在 MMU 中分配可变大小的内存页。\n- Register 8, BadVAddr，在系统捕获到 TLB Miss 或 Address Error 这两种 Exception 时，发生错误地址会储存在该的虚拟寄存器中。对于引发 Exception 的 Bug 的定位来说，这个寄存器非常重要。\n- Register 9, Count，这个寄存器是 R4000 以后的 MIPS 系统引入的。它是一个计数器，计数频率是系统主频的 1/2。BCM1125/1250，RMI XLR 系列以及 Octeon 的 Cavium 处理器均支持该寄存器。对于操作系统来说，可以通过读取该寄存器的值来获取 tick 的时基。在系统性能测试中，利用该寄存器也可以实现打点计数。\n- Register 10，EntryHi，这个寄存器同 EntryLo0/1 一样，用于 MMU 中。以后会详述。\n- Register 11，Compare，配合 Count 使用。当 Compare 和 Count 的值相等的时候，会触发一个硬件中断 (Hardware Interrupt)，并且总是使用 Cause 寄存器的 IP7 位。\n- Register 12，`Status`，用于处理器状态的控制。\n- Register 13，`Cause`，这个寄存器体现了处理器异常发生的原因。\n- Register 14，`EPC，这个寄存器存放异常发生时，系统正在执行的指令的地址`。\n- Register 15，PRID，这个寄存器是只读的，标识处理器的版本信息。向其中写入无意义。\n- Register 18/19，WatchLo/WatchHi，这对寄存器用于设置硬件数据断点 (Hardware Data Breakpoint)。该断点一旦设定，当 CPU 存取这个地址时，系统就会发生一个异常。这个功能广泛应用于调试定位内存写坏的错误。\n- Register 28/29，TagLo 和 TagHi，用于高速缓存 (Cache) 管理。\n\n> `#查看cp寄存器（openocd）`\n>\n> mon mips32 cp0\n\n## CP0 常用寄存器\n\n下面，我们来详解 CP0 中常用的几个寄存器，它们是：BadVAddr，Count/Compare，Status/Cause，EPC，WatchLo/WatchHi。\n\n# MIPS 的异常与中断 (Section 2)\n![[mips 大核手册#^7a2f66]]\n其中，Exception `0-5, 8-11, 13, 23` 这几个异常类型较为常见。\n\n- Exception 0：Interrupt，外部中断。\n\n  它是唯一一个异步发生的异常。之所以说中断是异步发生的，是因为相对于其他异常来说，从时序上看，中断的发生是不可预料的，无法确定中断的发生是在流水线的哪一个阶段。MIPS 的五级流水线设计如下：\n  IF, RD, ALU, MEM, WB。\n\n  MIPS 处理器的中断控制部分有这样的设计：\n\n  在中断发生时，如果该指令已经完成了 MEM 阶段的操作，则保证该指令执行完毕。反之，则丢弃流水线对这条指令的工作。除 NMI 外，所有的内部或外部硬件中断 (Hardware Interrupt) 均共用这一个异常向量(Exception Vector)。前面提到的 CP0 中的 Counter/Compare 这一对计数寄存器，当 Counter 计数值和 Compare 门限值相等时，即触发一个硬件中断。\n\n- Exception 1：TLB Modified，内存修改异常。\n\n  如果一块内存在 TLB 映射时，其属性设定为 `Read Only`，那么，在试图修改这块内存内容时，处理器就会进入这个异常。显然，这个异常是在 Memory 阶段发生的。但是，按 “精确异常” 的原则，在异常发生时，ALU 阶段的操作均无效，也就是说，向内存地址中的写入操作，实际上是不会被真正执行的。这一判断原则，也适用于后面的内存读写相关的异常，包括 TLB Miss/Address Error/Watch 等。\n\n- Exception 2/3：TLB Miss Load/Write，\n\n  如果试图`访问没有在 MMU 的 TLB 中映射的内存地址`，会触发这个异常。在支持虚拟内存的操作系统中，这会触发内存的页面倒换，系统的 Exception Handler 会将所需要的内存页从虚拟内存中调入物理内存，并更新相应的 TLB 表项。\n\n- Exception 4/5：Address Error Load/Write\n\n  如果试图访问一个非对齐的地址，例如 lw/sw 指令的地址非 4 字节对齐，或 lh/sh 的地址非 2 字节对齐，就会触发这个异常。一般地，操作系统在 Exception Handler 中对这个异常的处理，是分开两次读取 / 写入这个地址。虽然一般的操作系统内核都处理了这个异常，最后能够完成期待的操作，但是由于会引起用户态到内核态的切换，以及异常的退出，当这样非对齐操作较多时会严重影响程序的运行效率。因此，编译器在定义局部和全局变量时，都会自动考虑到对齐的情况，而程序员在设计数据结构时，则需要对对齐做特别的斟酌。\n\n- Exception 6/7：Instruction/Data Bus Error\n\n  一般地原因是 `Cache 尚未初始化`的时候访问了 Cached 的内存空间所致。因此，要注意在系统上电后，Cache 初始化之前，只访问 Uncached 的地址空间，也就是 `0xA0000000-0xBFFFFFFF` 这一段。默认地，上电初始化的入口点 `0xBFC00000` 就位于这一段。(某些 MIPS 实现中可以通过外部硬线连接修改入口点地址，但为了不引发无法预料的问题，不要将入口点地址修改为 Uncached 段以外的地址)\n\n- Exception 8：Syscall，系统调用的正规入口，也就是在用户模式下进入内核态的正规方式。\n\n  我们可以类比 x86 下 Linux 的系统调用 0x80 来理解它。它是由一条专用指令 syscall 触发的。\n\n- Exception 9：Break Point，绝对断点指令。\n\n  和 syscall 指令类似，它也是由专用指令 break 触发的。它指示了系统的一些异常情况，编程人员可以在某些不应当出现的异常分支里面加入这个指令，便于及早发现问题和调试。我们可以用高级语言中的 assert 机制来类比理解它。最常见的 Break 异常的子类型为 0x07，它是编译器在编译除法运算时自动加入的。如果除数为 0 则执行一条 break 0x07 指令。这样，当出现被 0 除的情况时，系统就会抛出一个异常，并执行 Coredump，以便于程序员定位除 0 错误的根因。\n\n- Exception 10：RI，执行了没有定义的指令，系统就会发生这个异常。\n\n- Exception 11，Co-Processor Unaviliable，试图访问的协处理器不存在。比如，在没有实现 CP2 的处理器上执行对 CP2 的操作，就会触发这个异常。\n\n- Exception 12，Overflow，算术溢出。会引起这个异常的指令，仅限于加减法中的带符号运算，如 add/addi 这样的指令。因此，一般地，编译器总是将加减法运算编译为 addiu 这样的无符号指令。由于 MIPS 处理异常需要一定的开销，这样可以避免浪费。\n\n- Exception 13，Trap，条件断点指令。\n\n  它由 trap 系列指令引发。与 Break 指令不同的是，只有满足断点指令中的条件，才会触发这个异常。我们可以类比 x86 下的 int 3 断点异常来理解它。\n\n- Exception 14，VCEI，（不明白！谁知道是干嘛使的？）\n\n- Exceotion 15，Float Point Exception，浮点协处理器 1 的异常。它由 CP1 自行定义，与 CP1 的具体实现相关。其实就是专门为 CP1 保留的异常入口。\n\n- Exception 16，协处理器 2 的异常，和前一个异常一样，是和 CP2 的具体实现相关的。\n\n- Exception 23，Watch 异常。前面讲到 Watch 寄存器可以监控一段内存，当访问 / 修改这段内存时，就会触发这个异常。在异常处理例程中，通过异常栈可以反推出是什么地方对这段内存进行了读 / 写操作。这个异常是用来定位内存意外写坏问题的一柄利器。\n\n\n\n# MIPS 的异常与中断 (Section 3)\n\n异常发生的时候，系统会完成一个从用户态到内核态的切换。我们前面提到，对系统某些资源的访问（如 CP0 等协处理器，Kernel Segment 内存），是必须在内核态进行的。因此，如果希望使系统从用户态进入内核态，那么，就必须产生一个异常。\nMIPS 的异常处理，通常来说，和其他体系结构的异常 / 中断 / 陷阱处理，没有太多的区别，总的来说分为三段：\n\n1. 保存现场寄存器组（Register File）。在堆栈中开辟一段区域，将 32 个通用寄存器和 CP0 的相关寄存器，如 Status，BadVaddr，Cause 等，保存在这段内存中。其中尤为重要的是 EPC，EPC 指向引发异常时的指令。\n   在这个步骤中，首先保存的应该是通用寄存器组，随后是 epc/cause/status/badvaddr 这几个 epc0 中的寄存器。从 cp0 到内存的数据传输必须通过通用寄存器。一般地，编程时的约定是使用 k0 和 k1 这两个寄存器暂存。如下例：（适用于 32 位 MIPS 模式）\n\n    ```assembly\n    sw zero, 0(sp)\n    sw at, 4(sp)\n    sw v0, 8(sp)\n    ...\n    sw ra, 124(sp) / *先保存通用寄存器组* /\n    mfc k0, epc\n    nop / *mfc 太慢，要在延迟槽中加一个 nop* /\n    sw k0, 128(sp)\n    mfc k0, cause\n    nop\n    sw k0, 132(sp)\n    ...\n    ```\n\n2，异常处理部分。以 Address Error 异常为例，当异常发生时，根据保存的 `BadVaddr`，调用两次非对齐加载 / 存储指令，对内存地址进行数据的读写操作。\n3，返回。将保存在堆栈中的寄存器组内容恢复。\n\n​\t从异常状态返回的这个动作，是由硬件完成的。它必须同时完成三个操作：\n\n1. 将 SR 寄存器恢复；\n2. 返回到 EPC 寄存器所指向的地址继续执行；\n3. 恢复到用户态。\n\n如《See MIPS Run》提到的，如果这三个过程没有能够 “原子地” 执行完毕，那么将会导致一个安全漏洞，用户有可能在某种情况下僭越 CPU 内核态设定的壁垒，从而非法获得管理员权限。\n在 MIPS I 和 MIPS II 处理器中，使用 rfe 这条指令，来进行 “从异常中恢复”，也就是恢复 SR 寄存器，并且将系统从内核态恢复到用户态。但这条指令并没有将执行的指令地址返回到异常发生的指令处。这项工作应当由在此之前的一条 JR 指令来执行。这样，从异常中返回的相关汇编代码应当为：\n\n```assembly\nmfc k0, epc\njr k0\nrfe / *在上一条 jr 指令的延迟槽中执行，这样可以保证原子性* /\n```\n\n在 MIPS III 及以后的处理器中，从异常中返回不再需要这样的繁文缛节，只需要一条 `eret` 指令便万事俱备了。\n\n","tags":["cp0"],"categories":["MIPS"]},{"title":"mips 异常","url":"/2020/09/25/hxd_new/mips异常/","content":"\n\nzMIPS体系结构采用的是 `精确异常` 处理模式\n这是什么意思呢？下面来看从“See MIPS Run”一书中的摘录：\n\n> “In a precise-exception CPU, on any exception we get pointed at one instruction(the exception victim). All instructions preceding the exception victim in execution sequence are complete; any work done on the victim and on any subsequent instructions (BNN NOTE: pipeline effects) has no side effects that the software need worry about. The software that handles exceptions can ignore all the timing effects of the CPU's implementations”\n\n上面的意思其实很简单：在发生这个异常之前的一切计算行为会完整的结束并体现效果。 在发生这个异常之后的一切计算行为（包含当前这条指令）将不会产生任何效果。\n另外一种解释是：\n\n> A precise exception is one in which the EPC (CP0, Register 14, Select 0) can be used to identify the instruction that caused the exception. For imprecise exceptions, the instruction that caused the exception cannot be identified. Most exceptions are precise. Bus error exceptions may be imprecise.\n\n## 异常处理的一般过程\nWith the exception of Reset, Soft Reset, NMI, and Debug exceptions, which have their own special processing as described below, exceptions have the same basic processing flow:\n• If the EXL bit in the `Status register` is cleared, theEPC  register is loaded with the PC at which execution will be restarted and the BD bit is set appropriately in the`Cause register`.  If the instruction is not in the delay slot of a branch, the BD bit inCausewill be cleared and the value loaded into theEPCregister is the current PC. If the instruction is in the delay slot of a branch, the BD bit inCauseis set andEPCis loaded with PC-4.If the EXL bit in theStatus register is set, theEPCregister is not loaded and the BD bit is not changed in theCauseregister.\n• The `CE` and `ExcCode` fields of the Cause registers are loaded with the values appropriate to the exception. The CE field is loaded, but not defined, for any exception type other than a coprocessor unusable exception.\n• The EXL bit is set in the Status register.\n• The processor is started at the exception vector.\nThe value loaded into EPC represents the restart address for the exception and need not be modified by exception handler software in the normal case. Software need not look at the BD bit in the Cause register unless is wishes to identify the address of the instruction that actually caused the exception. Note that individual  exception types may load additional information into other registers. This is noted in the description of each exception type below.\n\n`EPC`中存放的是异常发生时执行的指令地址，或者分支延时发生异常，则存放的是分支的指令地址，不管怎么样，`异常处理函数返回都从EPC开始恢复执行`，如果在`分支延时指令发生异常`，则需要`在cause寄存器中存放相应标志`，这样就可以准确的知道发生异常的指令地址了。\n\nOperation:\n\n```shell\nifStatus EXL= 0 then\n if InstructionInBranchDelaySlot then\n  EPC <- PC - 4\n  Cause BD<- 1\n else\n  EPC <- PC\n  Cause BD<- 0\n endif\n if ExceptionType = TLBRefill then\n  vectorOffset <- 0x000\n elseif (ExceptionType = Interrupt) and\n  (Cause IV= 1) then\n  vectorOffset <- 0x200\n else\n  vectorOffset <- 0x180\n endif\nelse\n vectorOffset <- 0x180\nendif\nCause CE<- FaultingCoprocessorNumber\nCause ExcCode<- ExceptionType\nStatus EXL<- 1\nif Status BEV= 1 then\n PC <- 0xBFC0_0200 + vectorOffset\nelse\n PC <- 0x8000_0000 + vectorOffset\nendif\n```\n\nAs with any procedure, the exception handler must save any registers it may modify, and then restore them before returning control to the interrupted program. Saving registers in memory poses a problem in MIPS:\naddressing the memory requires a register (the base register) in which the address is formed. This means that  a register must be modified before any register can be saved!  The MIPS register usage convention (see Laboratory 4) reserves registers $26 and $27( `$k0`and`$k1` ) for the use of the interrupt handler. This means that the interrupt handler can use these registers without having to save them first.  `A user program that uses these registers may find them unexpectedly changed.`The CPU operates in one of the two possible modes,userandkernel.User programs run in user mode.   `The CPU enters the kernel mode when an exception happens`. Coprocessor 0 can only be used in kernel mode.\n\n说明：为何分支延时槽中的指令发生异常要从分支指令`重新`执行呢，这是因为mips的指令执行是流水线结构，分析指令的执行结果不会影响到延时槽中指令的执行，也就是说不管分支指令往哪里跳，`延时槽的指令都会执行`，如果EPC保存延时指令地址，则分析指令执行的结果将会丢失，这样异常处理结束后恢复执行的结果就不正确\n\n## 异常入口（向量）\n\nThe `Reset` ,`Soft Reset` , and`NMI exceptions` are always vectored to location `0xBFC0_0000`. Debug exceptions are vectored to location `0xBFC0_0480` or to location `0xFF20_0200` if the ProbTrap bit is 0 or 1, respectively, in the `EJTAG Control register` (ECR). \n\n> 如果在' EJTAG控制寄存器' (ECR)中`ProbTrap`位分别为0或1，则调试异常被指向位置' 0xBFC0_0480 '或位置' 0xFF20_0200 '。\n\nAddresses for`all other exceptions`are a combination of a vector offset and a base address .\n\nTable4-2  gives the base address as a function of the exception and whether the BEV bit is set in theStatus register.\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095208249.png)  \n\nTable 4-3  gives the offsets from the base address as a function of the exception.\n\n ![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309522679.png)  \n\nCauseIV:    将`CP0 CauseIV`位设置为`1`会导致中断异常使用专用的异常向量偏移量(0x200), 而不是使用一般的异常向量偏移量(0x180)。 \n\nTable 4-4combines these two tables into one that contains all possible vector addresses as a function of the state that can affect the vector selection.\n\n> 将这两个表合并为一个表，其中包含所有可能的向量地址，作为可能影响向量选择的状态函数。\n\n ![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309524297.png)  \n\nIn MIPS32® Release 2 and higher architectures, software is allowed to specify the vector base address via the  `CP0 Ebase`register for exceptions that occur when CP0 Status BEV equals 0.\n\n- StatusBEV= 1:  Exceptions vector to an uncached entry point in KSEG1: 0xBFC00xxx\n- StatusBEV= 0:  Exceptions vector to cached entry points in KSEG0:  `defined by CP0 Ebase register`, plus someoffset\n\nNote:StatusBEV = 1 at reset. IfEbaseis to be changed, it must be done with StatusBEV= 1(i.e. at system boot). The operation of the CPU isUNDEFINEDifEbaseis written whenStatusBEV= 0. TheEbasedefault is 0x8000_0000 after reset. \n\n> EBase寄存器是一个可读写寄存器，包含例外向量基地址和一个只读的CPU号。\n\n ![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095314509.png)\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095330737.png)![img](https://img-blog.csdn.net/20180313095342474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2h1em0wOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n对`Cache Error`这个特殊的异常来说，需要给他安排一个任何时候都是Uncached的基地址了。因为发生这个异常时Cache已经不可靠了，在处理它是就不能使用它了。\n\n因此这个异常的入口基地址为：  \n\nBEV = 1 : BFC0,0300 （系统启动地址空间 : kseg1）\n\nBEV = 0 :[SP]:  A000,0000 （物理内存地址 :  kseg1）\n\n[MP]:  EBASE[31.30] || 1 || EBASE[28...12] || 0x000  （物理内存地址 :  kseg1)\n\n上面的总结一下： `Reset ,Soft Reset和NMI`： 不受任何配置的影响，异常向量位置总是在`0XBFC0_0000` \n\nGeneral Exception：异常向量在`0xBFC0_0200 + 0x180`  或 `Ebase + 0x180` \n\nInterrupt： IV 表示是否使用专用的异常处理向量， IV=0，采用General Exception中断向量， IV=1，则采用int专用的中断向量 \n\nTLB refill： EXL为0时，采用TLB refill专用的异常处理向量，EXL为1时，采用General Exception中断向量  \n\n## 异常优先级\n\n所谓的优先级是指：当在某个时刻，同时多个异常或中断出现时，CPU将会按照上述的优先级来处理。\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095405537.png)\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095418835.png)\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095429595.png)\n\n前面一列为exception的编号，后面一列为改异常的描述  \n\n## 异常相关寄存器\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095440571.png)  \n\n- The BadVAddr register\n\nThis register (its name stands for Bad Virtual Address) will contain the memory address where the exception has occurred. \n\nAn unaligned memory access, for instance, will generate an exception and `the address where the access was attempted` will be stored in BadVAddr.\n\n### SR(Status Register，状态寄存器) \n\n![image-20210519193356380](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20210519193356380.png)\n\n1. **EXL Exception Level** ; set by the processor when any exception other than Reset, Soft Reset, NMI, or Cache Error exception are taken. \n\n​      0: normal 1: exception \n\n当EXL被置位时， 中断是被禁止的。 换句话说，这时SR[IE]位是不管用了，相当于`所有的中断都被屏蔽了`。 \n\n- TLB Refill异常将会使用`General Exception Vector`而不是缺省的TLB Refill Vector. \n- 如果再次发生异常，`EPC将不会被自动更新`。这一点要非常注意。如果想支持嵌套异常，要在异常处理例程中清EXL位。当然要先保存EPC的值。另外要注意的：MIPS当陷 入Exception/Interrupt时，并不改变SR[UX],SR[KX]或SR[SX]的值。SR[EXL]为1自动的将CPU mode运行在核心模式下。这一点要注意。\n\n2. **ERL Error Level** ; set by the processor when `Reset, Soft Reset, NMI, or Cache Error exception` are taken. \n\n​     0: normal 1: error \n\n   当ERL被置位时，中断被禁止. 中断返回`ERET`使用的是`ErrorEPC`而不是EPC。需要非常注意这个区别。 \n\nKuseg和xkuseg 被认为是没有映射(Mapped)的和没有缓存（Un-Cached）。\n\n可以这样理解，MIPS CPU只有在这个时刻才是一种实模式(real mode)，可以不需要TLB的映射， 就直接使用`kuseg`的地址空间。 \n\n>  The ERET instruction to return from exception is used for returning from exception level (Status.EXL) and error level (Status.ERL). If both bits are set however we should be returning from ERL first, as ERL can interrupt EXL, for example when an NMI is taken. \n\n都是通过eret返回的，如果**EXL和ERL同时设置了**，`则应该首先从ERL返回`，**PC设置为ErrorPC, 清除ERL，注意这时不会清除EXL。**\n\nERET指令用模拟器实现的代码大致如下： \n\n```c\nif (kvm_read_c0_guest_status(cop0) & ST0_ERL) {\n      kvm_clear_c0_guest_status(cop0, ST0_ERL);\n      vcpu->arch.pc = kvm_read_c0_guest_errorepc(cop0);\n  } \nelse if (kvm_read_c0_guest_status(cop0) & ST0_EXL) {\n     kvm_clear_c0_guest_status(cop0, ST0_EXL);\n     vcpu->arch.pc = kvm_read_c0_guest_epc(cop0);\n}\n```\n\n3. **IE**   Interrupt Enable 0: disable interrupts 1: enable interrupts。请记住： 当SR[EXL]或SR[ERL]被SET时，SR[`IE`]是无效的。 \n\n4. **BEV**  Normal/Bootstrap exception vectors location \n\n   BEV=1 ：非缓存异常处理入口固定定位于非缓存的、启动安全的 kseg1 内存区域\n\n   BEV=0 ：异常处理入口不固定，通过 EBase 寄存器可以编程移动，系统正常运行时为 0, 由EBASE 指定\n\n5. **SR** Soft Reset,  如果是soft reset，该位置1，表明是软件复位 \n\n6. **NMI** 如果是NMI，该位置1，表明是不可屏蔽中断 \n\n7. **IM**[7:0] Interrupt Mask\n\n8. **UM** Kernel/User Mode， UM=1用户模式，中断发生时不改变该bit的值 \n\n   UM:ERL:EXL Mode\n\n   100:              User\n\n   000:              Kernel\n\n   x10:              Kernel (exception handling)\n\n   x01:              Kernel (error handling)\n\n### Cause\n\n在处理器异常发生时， 这个寄存器标识了异常的原因。其中最重要的是2-6位，5个bit的exception code位。它们标识了引起异常的原因，具体数值代表的异常类型\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png)\n\n1. **BD**: Exception happened in a branch delay slot \n\n2. **IV**: `Use general vs special interrupt vector`  打开iv 后， interrupt 走0x200的vector offset（vector base 为0xbfc00200或者ebase）\n\n3. **IP**[7:0]: Interrupt(s) pending \n\n4. **Exc Code**: Exception code\n\n ![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095511786.png)  \n\n### EPC存放返回地址\n\n  这个寄存器的作用很简单， 就是保存异常发生时的指令地址。从这个地方可以找到异常发生的指令，再结合`BadVaddr` `sp` 等寄存器，就可以推导出异常时的程序调用关系，从而定位问题的根因\n\n### WatchLo、WatchHi\n\n这一对寄存器用来设定`内存硬件断点`，也就是对指定点的内存进行检测。当访问的内存地址和这两个寄存器地址一致时，会发生一个异常。 应该是不同于gdb的watch指令，后面可以试一下。\n\n## CP0相关\n\n### CP0 主要操作\n\nmfc0 rt,rd 将cp0的rd寄存器内容传输到rt通用寄存器\n\nmtc0 rt, rd 将rd通用寄存器的内容传输到CP0中寄存器rd\n\nmfhi/mflo rt 将CP0 的hi、lo 寄存器的内容传输到rt通用寄存器中\n\nmthi/mtlo rt 将rt通用寄存器的内容传输到CP0的hi、lo 寄存器中\n\n### CP0 冒险现象\n\nmips体系结构是一个无互锁，高度流水的五级pipeline架构，这就意味着，前一条指令如果尚未执行完，后一条指令可能已经进入了取指令、译码阶段。这样可能发生CP0 冒险（CP0 Hazard）现象。mfc和mtc的指令执行速度是比较慢的，开始执行完下一条指令时， 有可能CP0寄存器的值尚未最后传输到指定的目标通用寄存器中。此时，如果读取该通用寄存器，有可能未能得到正确的值。这就是所谓的CP0 冒险现象。\n\n为避免CP0 冒险， 我们在编程时需要在CP0 操作指令的后面加入一条与前一条指令的目的通用寄存器无关的指令，也就是所谓的延迟槽（delay slot）， 如果对性能不敏感，可以考虑用nop填充延迟槽\n\n## MIPS cpu中断机制\n\n### mips 异常\n\n在mips中，中断 陷阱trap 系统调用和任何可以中断程序正常执行流的情况都称之为异常\n\n**精确异常**： 在引发异常的指令执行时，后面一条指令已经完成了读取和译码的预备工作，当异常产生时，`这些预备工作被废弃`，CPU从异常中返回时，再重新做读取和译码的工作。\n\nMips 对异常的处理是给异常分配一些类型，然后由软件给它们定义一些优先级，然后由`同一个入口`进入异常分配程序，在分配程序中根据类型及`优先级`确定该执行哪个对应的函数\n\nCP0中的epc寄存器用于指向异常发生时指令跳转前的执行位置，一般是被中断指令地址。当异常时，是返回这个地址继续执行，但如果被中断指令是在分支延迟槽中，则会硬件自动处理使epc往回指一条指令（pc-4），即分支指令。在重新执行分支指令时，分支延迟槽中的指令会被再执行一次。\n\n### mips异常处理步骤\n\n1. 设置epc，指向返回位置\n2. 设置status寄存器，exl位迫使cpu进入内核模式，并且`禁用中断`，即exl位置1\n3. 设置cause 寄存器， 使得软件能看见异常原因， 地址异常时，也要设置`BadVAddr`寄存器，存储管理系统异常还要设置一些mmu寄存器\n4. cpu从异常入口点取指令执行\n\n### mips异常处理例子\n\n1. 保护现场：在异常处理例程入口，需要保护被中断的程序的现场，存储寄存器的状态，保证关键状态不被覆盖\n2. 处理异常： 根据cause exccode确定发生了什么类型的异常，完成想要做的任何事情\n3. 准备返回： 恢复线程，修改SR，设置成安全模式（内核态，禁止异常）exl置1，也就是异常发生后的模式\n4. 从异常返回：指令`eret`， 即清除SR：exl位， exl置0， 将控制权返回给存储在epc中的地址\n\n### 中断寄存器相关\n\ncpu核`外部`的事件，即从一些真正的`硬件连线`过来的输入信号（外中断或硬中断）\n\nCause：exccode编码为00000中断，这些中断使cpu转向某外部事件，mips cpu有8个独立终端位(在Cause: IP7-2 和 IP 1-0段), 其中6个(IP7-2)为外部中断，2个(IP 1-0)为内部中断(可用软件访问), 片上的时钟计数/定时器都会连接到一个硬件中断位上。\n\n![img](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png)\n\nmips 对中断的支持涉及到 SR 和 Cause 寄存器\n\n1. 使能全局中断(IE: interupt enable)： 要想使能中断，SR的IE位必须置1\n\n2. 中断使能屏蔽（IM： interupt mask） SR[15-8]为中断屏蔽位，对应IM[7-0]， 这8个bit决定了`哪些中断源有请求时可以触发一个异常。实际上是对中断信号的使能开关。` 8个中断源中的6个 IM[7-2]对应cause IP[7-2]， 用于外部设备硬件中断，其余2个IM[1-0]对应cause ip[1-0]， 为软件中断屏蔽位，所谓中断源就是产生硬中断信号的PIC外接设备或软中断。\n\n3. 异常级别（EXL ： exception level）：异常发生后， cpu立即设置SR EXL置1， 进入异常模式， 异常模式强制cpu进入内核特权级模式并屏蔽中断， 而不会理会SR其他位的值。 EXL位在已经设置的情况下，还没有真正准备好调用主内核的例程（中断恢复或者中断钩子的处理？）。**在这种状态下，系统不能处理其他异常**， `保持EXL 足够的时间保存现场，使软件决定cpu新的特权级别和中断屏蔽位应该如何设置`\n\n4. 异常类型（EXCcode： Exception Code） ： PIC每个输入引脚上的有效（相应的IM位 1， 未被屏蔽）， 输入每个周期都会采样， 如果使能，则引起一个异常。异常处理程序检查到Cause （exccode =0）说明发生的异常是`中断`， 此时进入通用中断程序\n\n5. 中断请求寄存器（IP： interupt pending）： Cause[15-8]位为中断挂起状态位，用于指示哪些设备发生了中断，具体来说是识别PIC的哪个接入引脚对应的设备发来了中断信号，IP[7-2]随着CPU 硬件输入引脚上的信号而变化，而IP1-0为软件中断位，可读可写并存储最后写入的值。当SR：IM[7-0]某些位使能，且硬中断或软中断触发时，cause：IP[7-2]上的pending位，确定是哪个设备发生了中断\n\n   ### 中断处理步骤：\n\n   > 注意和异常的区别, 异常很有可能是不可恢复异常，中断处理要麻烦一些，因为要恢复现场。\n\n    中断是异常的一种，所以中断处理只是异常处理的一条分流，经过上一层异常处理处理后，处理步骤如下：\n\n   1.  将cause：IP与SR：IM进行逻辑与运算，获得一个或多个使能的中断请求\n   2. 选择一个使能的中断来处理，优先处理最高优先级的中断\n   3. 存储SR： IM中的中断屏蔽位，改变SR：IM 以保证`禁止当前中断`以及所有优先级小于等于本中断的中断在处理时发生\n   4. `对于嵌套异常， 此时需要保护现场`\n   5. 修改cpu到合适的状态以适应中断处理程序的高层部分，这时通常允许一些嵌套中断或异常。设置全局中断使能SR：IE位，以允许处理高优先级的中断。还需要改变cpu特权级域（SR：`KSU`），使CPU处于内核态，清除SR：EXL离开异常模式，并把这些改动反映到状态寄存器中\n   6. 执行中断处理程序，完成要做的事情\n   7. 恢复现场，恢复相关寄存器， 返回被中断的指令（返回被中断程序） \n\n## 常见的异常处理\n\n### Reset Exception\n\nA reset exception occurs when the  *`SI_ColdReset`*  signal is asserted to the processor. This exception is not maskable. When a Reset exception occurs, the processor performs a full reset initialization , including aborting state machines, establishing critical state, and generally placing the processor in a state in which it can `execute instructions from uncached, unmapped address space`. On a Reset exception, the state of the processor in not defined, with the following exceptions:\n\n对于Reset和Soft Reset异常来说，当发生此类异常时，`ErrorEPC`是否准确记录了发生异常时执行的指令地址，这需要根据特定处理器的手册决定。它依赖于具体处理器的实现。而且，似乎在Reset时也没有必要去记录处理器正在执行的指令\n\n- The  *Random*  register is initialized to the number of TLB entries - 1 (4Kc core).\n\n- The  *Wired*  register is initialized to zero (4Kc core).\n\n- The  *Config*  register is initialized with its boot state.\n\n- The RP, BEV, TS, SR, NMI, and ERL fields of the  *Status*  register are initialized to a specified state.\n\n- The I, R, and W fields of the  *WatchLo*  register are initialized to 0.\n\n- The  *ErrorEPC*  register is loaded with `pc-4` if the state of the processor indicates that it was executing an instruction in the `delay slot of a branch.` Otherwise, the  *ErrorEPC*  register is loaded with pc.  Note that this value may or may not be predictable.\n\n- PC is loaded with `0xBFC0_0000` \n- Cause Register ExcCode Value: None\n- Additional State Saved:  None \n- Entry Vector Used:  Reset (0xBFC0_0000)\n\n**Operation**:\n\n```c\nRandom <- TLBEntries - 1\nWired <- 0\nConfig <- ConfigurationState\nStatus RP  <- 0\nStatus BEV  <- 1\nStatus TS  <- 0\nStatus SR  <- 0\nStatus NMI  <- 0\nStatus ERL  <- 1\nWatchLo I  <- 0\nWatchLo R  <- 0\nWatchLo W  <- 0\nif InstructionInBranchDelaySlot then\nErrorEPC <- PC - 4\nelse\nErrorEPC <- PC\nendif\nPC <- 0xBFC0_0000\n```\n\n### **Non-Maskable Interrupt (NMI) Exception**\n\nA  non-maskable  interrupt exception occurs when the  *`SI_NMI`*  signal is asserted to the processor.  *SI_NMI*  is an edge sensitive signal - `only one NMI exception will be taken each time it is asserted`. An NMI exception occurs only at instruction boundaries,  so it does not cause any reset or other hardware initialization. The state of the cache, memory, and other processor states are consistent and all registers are preserved , with the following exceptions:\n\n- The BEV, TS, SR, NMI, and ERL fields of the  *Status*  register are initialized to a specified state.\n\n- The  *ErrorEPC*  register is loaded with PC-4 if the state of the processor indicates that it was executing an instruction in the delay slot of a branch. Otherwise, the  *ErrorEPC*  register is loaded with PC.\n\n- PC is loaded with 0xBFC0_0000.\n\n- *Cause*  Register ExcCode Value:  None\n- Additional State Saved: None\n- Entry Vector Used: Reset (0xBFC0_0000)\n\nOperation:\n\n```shell\nStatus BEV   <- 1\nStatus TS   <- 0\nStatus SR   <- 0\nStatus NMI   <- 1\nStatus ERL   <- 1\nif InstructionInBranchDelaySlot then\nErrorEPC <- PC - 4\nelse\nErrorEPC <- PC\nendif\nPC <- 0xBFC0_0000\n```\n\n### **Machine Check Exception (4Kc core)**\n\nA machine check exception occurs when the processor detects an `internal inconsistency`. The following condition causes a machine check exception;\n\n*Cause*  Register ExcCode Value:  MCheck\n\nAdditional State Saved:  None\n\nEntry Vector Used:   `General exception vector` (offset 0x180)\n\n### **Interrupt Exception**\n\n外部中断。它是唯一一个异步发生的异常。之所以说中断是异步发生的，是因为相对于其他异常来说，从时序上看，中断的发生是不可预料的，无法确定中断的发生是在流水线的哪一个阶段。MIPS的五级流水线设计如下：\n\n> IF, RD, ALU, MEM, WB。MIPS处理器的中断控制部分有这样的设计：在中断发生时，如果该指令已经完成了MEM阶段的操作，则保证该指令执行完毕。反之，则丢弃流水线对这条指令的工作。除NMI外，所有的内部或外部硬件中断(Hardware Interrupt)均共用这一个异常向量(Exception Vector)。前面提到的CP0中的Counter/Compare这一对计数寄存器，当Counter计数值和Compare门限值相等时，即触发一个硬件中断。\n\nThe interrupt exception occurs when one or more of the eight interrupt requests is enabled by the  *Status*  register and the interrupt input is asserted. The delay from assertion of an unmasked interrupt to fetch of the first instructions at the exception vector is a minimum of 5 clock cycles. More may be needed if a committed instruction has to complete before the exception can be taken. A SYNC instruction which has already started flushing the cache and write buffers must wait until this is completed before the interrupt exception can be taken.\n\n- Register ExcCode Value: Int\n- Additional State Saved: \n- Entry Vector Used:\n\nGeneral exception vector (`offset 0x180`) if the IV bit in the  *Cause*  register is 0;  interrupt vector (`offset 0x200`) if the IV bit in the  *Cause*  register is 1.\n\n### TLB Refill Exception\n\n> **Instruction Fetch or Data Access (4Kc core)**\n\nTLB Miss Load/Write，如果试图访问`没有在MMU的TLB中映射的内存地址`，会触发这个异常。在支持虚拟内存的操作系统中，这会触发内存的页面倒换，系统的Exception Handler会将所需要的内存页从虚拟内存中调入物理内存，并更新相应的TLB表项。\n\nDuring an instruction fetch or data access, a TLB refill exception occurs when  **no TLB entry  in a TLB-based MMU matches a reference to a mapped address space and  the EXL bit is 0  in the  *Status*  register.** Note that this is distinct from the case in which an entry matches but has the valid bit off. In that case, a **TLB Invalid exception** occurs.\n\n***Cause\\***  **Register ExcCode Value:**\n\nTLBL: Reference was a load or an instruction fetch\n\nTLBS: Reference was a store\n\n**Additional State Saved:**\n\n![下载](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD.png)\n\n**Entry Vector Used:**\n\nTLB refill vector (`offset 0x000`) if Status EXL  = 0 at the time of exception; general exception vector (`offset 0x180`) if Status EXL  = 1 at the time of exception\n\n### **TLB Invalid Exception — Instruction Fetch or Data Access (4Kc core)**\n\nDuring an instruction fetch or data access, a TLB invalid exception occurs in one of the following cases:\n\n•  No TLB entry  in a TLB-based MMU matches a reference to a mapped address space;  and `the EXL bit is 1`  in the*Status*  register.\n\n• A TLB entry in a TLB-based MMU matches a reference to a mapped address space, but the matched entry has the valid bit off .\n\n***Cause*  Register ExcCode Value**:\n\nTLBL: Reference was a load or an instruction fetch\n\nTLBS: Reference was a store\n\n**Additional State Saved**:\n\n![下载 (1)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(1).png)\n\n**Entry Vector Used:** \n\nGeneral exception vector (offset 0x180)\n\n### **Bus Error Exception — Instruction Fetch or Data Access**\n\n一般地原因是Cache尚未初始化的时候访问了Cached的内存空间所致。因此，要注意在系统上电后，Cache初始化之前，只访问Uncached的地址空间，也就是`0xA0000000-0xBFFFFFFF`这一段。默认地，上电初始化的入口点`0xBFC00000`就位于这一段。(某些MIPS实现中可以通过外部硬线连接修改入口点地址，但为了不引发无法预料的问题，`不要将入口点地址修改为Uncached段以外的地址`)\n\nA bus error exception occurs when an instruction or data access makes a bus request (due to a cache miss or an uncacheable reference) and that request terminates in an error. The bus error exception can occur on either an instruction fetch or a data access. Bus error exceptions that occur on an instruction fetch have a higher priority than bus error exceptions that occur on a data access.\n\nBus errors taken on the requested (critical) word of an instruction fetch or data load are precise. Other bus errors, such as stores or non-critical words of a burst read, can be imprecise. These errors are taken when the EB_RBErr or EB_WBErr signals are asserted and may occur on an instruction that was not the source of the offending bus cycle.\n\n> 在指令获取或数据加载的请求(关键)字上接收的总线错误是精确的。 其他总线错误，如存储或突发读取的非关键字，可能是不精确的。 这些错误是在断言EB_RBErr或EB_WBErr信号时发生的，可能发生在一个指令上，而该指令不是发生故障的总线周期的来源。  \n\n***Cause*  Register ExcCode Value**:\n\nIBE: Error on an instruction reference\n\nDBE: Error on a data reference\n\n**Additional State Saved**: None\n\n**Entry Vector Used:**\n\nGeneral exception vector (offset 0x180)\n\n## 详细异常处理流程图\n\n![下载 (2)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(2).png)\n\n![下载 (3)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(3).png)\n\n![下载 (4)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(4).png)\n\n![下载 (5)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(5).png)\n\n![下载 (6)](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(6).png)\n\n\n\n## 异常的嵌套\n\n在有的情况下，希望在异常或中断中，系统可以继续处理其他的异常或中断。 这需要系统软件处理如下事情：\n\n进入处理程序后，保存Context, EPC, status, cause等寄存器的值到内存栈中，然后设置UM=0， 设置CPU模式为核心态，（异常并不会改status中UM的值，`EXL=1， ERL=1，UM=0`，任意一个条件成立都是内核态，为何要设置为内核态呢，因为只有在内核态才能访问cp0的特权资源），然后清除SR[EXL], 从而支持EPC会被更新，从而支持嵌套处理。但是当还没来得及清除SR[EXL]，另外一个异常立即就来了怎么办呢（中断不可能来，只可能是执行异常），那么所有寄存器的值都不会更新，直接跳转到异常向量处开始执行\n\n在任何情况下，reset， softreset，NMI，都会无条件响应，并且设置ERL=1，也就是说错误处理可以无条件相应，当然错误处理也是可以嵌套的。\n\n在ERL=1时，禁止任何中断和异常，除了reset， softreset，NMI\n\n*SR[IE]是一个很重要的位来处理嵌套异常。值得注意的，或容易犯错的一点是：\n\n在做恢复上下文时，要避免重入问题。比如，要用eret返回时， 要建立EPC的值。在此之 前，一定要先关闭中断`disable interrupt`. 否 则，EPC可能被冲掉。\n\n下面是一段异常中断返回的例子代码：\n\n```assembly\n/* 读取SR的当前值*/\nmfc0 t0,C0[SR]\n/*加一个delay slot指令 */\nnop\n/* 清除SR[IE]，关闭中断 */\nli t1,~SR[IE]\nand t0,t0,t1\nmtc0 t0,C0[SR]\nnop\n/* 可以安全的恢复EPC的值*/\nld t1,R_EPC(sp)\nmtc0 t1,C0[EPC]\nnop\nlhu k1, /* 恢复老的中断屏蔽码，被暂时保留在k1里*/\nor t0,t0,k1\n/*从新对SR[EXL]置位。ERET会自动将其清除。一定要理解，为什么中断例程要在前面要清除 EXL。如果不的话。就不能支持嵌套异常。为什么，希望读者能思考并回答。并且，在清EXL之前，我们一定要先把CPU模式变为核心模式。*/\nori t0,t0,SR[EXL]\n/*一切就绪，恢复中断屏蔽码和对EXL置位*/\nmtc0 t0,C0[SR]\nnop\nori t0,t0,SR[IE]\n/* 置为IE */\nori t0,t0,SR[IMASK7 ]\nmtc0 t0,C0[SR ]\nnop\n/*恢复CPU模式 */\nori t0, t0,SR[USERMODE]\nmtc0, t0, C0[SR]\neret\n/* eret将对EXL清零 。所以要注意，如果你在处理程序中改变了CPU的模式，一定要确保，在重新设置EXL位后，恢复CPU的原来模式，否则用户进程将会在核心态下运行。\n```\n\n## 代码实例分析\n\ncfe中的异常处理  fsbl部分：\n\n```assembly\nLEAF( do_chip_init )\n    move    s0, ra\n    li    t0, INITIAL_SR               //#define INITIAL_SR      ((/*CP0_STATUS_SR_MASK |*/ CP0_STATUS_CU1_MASK | CP0_STATUS_BEV_MASK | CP0_STATUS_IE_MASK) & ~( CP0_STATUS_ERL_MASK | CP0_STATUS_EXL_MASK))\n    mtc0  t0, CP0_STATUS\n    nop\n    nop\n    mtc0  zero, CP0_CAUSE           # clear software interrupts\n    nop\n    nop\n```\n\n在这里将ERL和EXL都清除掉了，并且使能了中断\n\n\\#define    CP0_STATUS_KSU_MASK              _MM_MAKEMASK(2,3)\n\n\\#define    CP0_STATUS_KSU_SHIFT            (3)\n\n复位后，处在内核态，并且cfe中一直处在内核态中，没有发生cpu模块的转换\n\n###  ssbl部分：\n\n```assembly\nvoid cfe_main(int a,int b)\n{\n    /*\n     * Set up the exception vectors\n     */\n    cfe_setup_exceptions();\n}\nvoid cfe_setup_exceptions(void)\n{\n    _exc_setvector(XTYPE_TLBFILL,  (void *)   cfe_exception );\n    _exc_setvector(XTYPE_XTLBFILL, (void *) cfe_exception);\n    _exc_setvector(XTYPE_CACHEERR, (void *) _exc_cache_crash_sim);\n    _exc_setvector(XTYPE_EXCEPTION,(void *) cfe_exception);\n    _exc_setvector(XTYPE_INTERRUPT,(void *) cfe_exception);\n    _exc_setvector(XTYPE_EJTAG,    (void *) cfe_exception);\n    exc_handler.catch_exc = 0;\n    q_init( &(exc_handler.jmpbuf_stack));\n#if (!CFG_BOOTRAM) && (CFG_RUNFROMKSEG0)\n    /*\n     * Install RAM vectors, and clear the BEV bit in the status\n     * register.  Don't do this if we're running from PromICE RAM\n     */\n    exc_install_ram_vectors();\n#endif\n}\n#define XTYPE_RESET    0\n#define XTYPE_TLBFILL    8\n#define XTYPE_XTLBFILL    16\n#define XTYPE_CACHEERR    24\n#define XTYPE_EXCEPTION    32\n#define XTYPE_INTERRUPT    40\n#define XTYPE_EJTAG    48\n\n        .globl    _exc_vectab\n_exc_vectab:    _LONG_    0        # XTYPE_RESET\n        _LONG_    0        # XTYPE_TLBFILL  (not used)        \n        _LONG_    0        # XTYPE_XTLBFILL\n        _LONG_    0        # XTYPE_CACHEERR (not used)\n        _LONG_    0        # XTYPE_EXCEPTION\n        _LONG_    0        # XTYPE_INTERRUPT\n        _LONG_    0        # XTYPE_EJTAG\nLEAF(_exc_setvector)\n\n        la    v0,_exc_vectab\n        srl    a0,3        /* convert 8-byte index to array index */\n        sll    a0,BPWSIZE    /* convert back to index appropriate for word size */\n        add    v0,a0\n        SR    a1,(v0)\n        j    ra\n\nEND(_exc_setvector)\n\nvoid cfe_exception(int code,uint64_t *info)\n{\n    int idx;\n    if(exc_handler.catch_exc == 1) {      //允许异常处理被捕获\n        /*Deal with exception without restarting CFE.*/\n        /*Clear relevant SR bits*/\n        _exc_clear_sr_exl();\n        _exc_clear_sr_erl();\n        /*Reset flag*/\n        exc_handler.catch_exc = 0;\n        exc_longjmp_handler();       \n    }\n    //仅仅打印异常引起异常的原因和信息\n    xprintf(\"**Exception %d: EPC=%08X, Cause=%08X, VAddr=%08X\\n\",\n        code,(uint32_t)info[XCP0_EPC],\n        (uint32_t)info[XCP0_CAUSE],(uint32_t)info[XCP0_VADDR]);\n    xprintf(\"RA=%08X, PRID=%08X\\n\",\n        (uint32_t)info[XGR_RA],(uint32_t)info[XCP0_PRID]);\n    xprintf(\"\\n\");\n    for (idx = 0;idx < 32; idx+= 2) {\n    xprintf(\"%2s ($%2d) = %08X %2s ($%2d) = %08X\\n\",\n        regnames+(idx*2),\n        idx,(uint32_t)info[XGR_ZERO+idx],\n        regnames+((idx+1)*2),\n        idx+1,(uint32_t)info[XGR_ZERO+idx+1]);\n    }\n    xprintf(\"\\n\");\n    xprintf(\"\\n*** Waiting for system reset ***\\n\");    //直接挂机\n    while(1);\n}\n```\n\n将异常向量保存在_exc_vectab这个表中，那么这个表由谁去调用呢？\n\n```assembly\nLEAF( _exc_entry )\n        .set noreorder\n        .set noat\n        subu    k1,sp,EXCEPTION_SIZE\n        SRL    k1,3\n        SLL    k1,3\n\n        SREG    zero,XGR_ZERO(k1)                #保存现场  #define SREG     sw\n        SREG     AT,XGR_AT(k1)\n\n        SREG    v0,XGR_V0(k1)\n        SREG    v1,XGR_V1(k1)\n\n        SREG    a0,XGR_A0(k1)\n        SREG    a1,XGR_A1(k1)\n        SREG    a2,XGR_A2(k1)\n        SREG    a3,XGR_A3(k1)\n\n        SREG    t0,XGR_T0(k1)\n        SREG    t1,XGR_T1(k1)\n        SREG    t2,XGR_T2(k1)\n        SREG    t3,XGR_T3(k1)\n        SREG    t4,XGR_T4(k1)\n        SREG    t5,XGR_T5(k1)\n        SREG    t6,XGR_T6(k1)\n        SREG    t7,XGR_T7(k1)\n\n        SREG    s0,XGR_S0(k1)\n        SREG    s1,XGR_S1(k1)\n        SREG    s2,XGR_S2(k1)\n        SREG    s3,XGR_S3(k1)\n        SREG    s4,XGR_S4(k1)\n        SREG    s5,XGR_S5(k1)\n        SREG    s6,XGR_S6(k1)\n        SREG    s7,XGR_S7(k1)\n\n        SREG    t8,XGR_T8(k1)\n        SREG    t9,XGR_T9(k1)\n\n        SREG    gp,XGR_GP(k1)\n        SREG    sp,XGR_SP(k1)\n        SREG    fp,XGR_FP(k1)\n        SREG    ra,XGR_RA(k1)\n\n        mfc0    t0,C0_CAUSE\n        mfc0    t1,C0_SR\n        mfc0    t2,C0_BADVADDR\n        mfc0    t3,C0_EPC\n        mfc0    t4,C0_PRID\n        mflo    t5\n        mfhi    t6    \n        SREG    t0,XCP0_CAUSE(k1)\n        SREG    t1,XCP0_SR(k1)\n        SREG    t2,XCP0_VADDR(k1)\n        SREG    t3,XCP0_EPC(k1)\n        SREG    t4,XCP0_PRID(k1)\n        SREG    t5,XGR_LO(k1)\n        SREG    t6,XGR_HI(k1)\n\n#if CFG_EMBEDDED_PIC\n        la        gp,PHYS_TO_K0(CFE_LOCORE_GLOBAL_GP)\n        LR        gp,0(gp)        # get our GP handle from low memory vector\n#else\n        la        gp,_gp            # Load up GP, not relocated so it's easy\n#endif\n\n        /* Exception occurred in CFE */\n        move    a0,k0            # Pass exception type\n        move    a1,k1            # Pass frame to exception handler\n        la        t0, _exc_vectab         # get base of exception vectors\n        srl        k0,3            # convert 8-byte index to array index\n        sll        k0,BPWSIZE        # convert back to index appropriate for word size\n        addu    t0,k0            # get vector address\n        LR        t0,(t0)            # to call handler\n\n        move    sp,k1            # \"C\" gets fresh stack area\n        jalr    t0            # Call exception handler\n        nop\n\n        move    k1, sp\n        LREG      AT,XGR_AT(k1)\n\n        LREG    t0,XGR_LO(k1)\n        LREG    t1,XGR_HI(k1)\n        mtlo    t0\n        mthi    t1\n\n        LREG    a0,XGR_A0(k1)\n        LREG    a1,XGR_A1(k1)\n        LREG    a2,XGR_A2(k1)\n        LREG    a3,XGR_A3(k1)\n\n        LREG    t0,XGR_T0(k1)\n        LREG    t1,XGR_T1(k1)\n        LREG    t2,XGR_T2(k1)\n        LREG    t3,XGR_T3(k1)\n        LREG    t4,XGR_T4(k1)\n        LREG    t5,XGR_T5(k1)\n        LREG    t6,XGR_T6(k1)\n        LREG    t7,XGR_T7(k1)\n\n        LREG    s0,XGR_S0(k1)\n        LREG    s1,XGR_S1(k1)\n        LREG    s2,XGR_S2(k1)\n        LREG    s3,XGR_S3(k1)\n        LREG    s4,XGR_S4(k1)\n        LREG    s5,XGR_S5(k1)\n        LREG    s6,XGR_S6(k1)\n        LREG    s7,XGR_S7(k1)\n\n        LREG    t8,XGR_T8(k1)\n        LREG    t9,XGR_T9(k1)\n\n        LREG    gp,XGR_GP(k1)\n        LREG    sp,XGR_SP(k1)\n        LREG    fp,XGR_FP(k1)\n        LREG    ra,XGR_RA(k1)\n\n/* do any CP0 cleanup here */\n\n        LREG    v0,XGR_V0(k1)\n        LREG    v1,XGR_V1(k1)\n    \n        ERET\n\n        .set at\n        .set reorder\n\nEND(_exc_entry)\n```\n\n那么 _exc_entry又是怎么调用的呢？\n\n```c\nstatic void exc_install_ram_vectors(void)\n{\n    uint32_t *ptr;\n    int idx;\n    /* Debug: blow away the vector area so we can see what we did */\n    ptr = (uint32_t *) PHYS_TO_K0(0);\n    for (idx = 0; idx < 0x1000/sizeof(uint32_t); idx++) *ptr++ = 0;\n    /*\n     * Set up the vectors.  The cache error handler is set up\n     * specially.\n     */\n    exc_setup_hw_vector(MIPS_RAM_VEC_TLBFILL,  CPUCFG_TLBHANDLER,XTYPE_TLBFILL);\n    exc_setup_hw_vector(MIPS_RAM_VEC_XTLBFILL,   _exc_entry ,XTYPE_XTLBFILL);\n    exc_setup_hw_vector(MIPS_RAM_VEC_CACHEERR, _exc_entry,XTYPE_CACHEERR);\n    exc_setup_hw_vector(MIPS_RAM_VEC_EXCEPTION,_exc_entry,XTYPE_EXCEPTION);\n    exc_setup_hw_vector(MIPS_RAM_VEC_INTERRUPT,_exc_entry,XTYPE_INTERRUPT);\n    /*\n     * Flush the D-cache and invalidate the I-cache so we can start\n     * using these vectors.\n     */\n    cfe_flushcache(CFE_CACHE_FLUSH_D | CFE_CACHE_INVAL_I,0,0);\n    /*\n     * Write the handle into our low memory space.  If we need to save\n     * other stuff down there, this is a good place to do it.\n     * This call uses uncached writes - we have not touched the\n     * memory in the handlers just yet, so they should not be\n     * in our caches.\n     */\n    _exc_setup_locore((intptr_t) CPUCFG_CERRHANDLER);  //重新设置cache 错误异常处理向量\n    /*\n     * Finally, clear BEV so we'll use the vectors in RAM.\n     */\n    _setstatus(_getstatus() & ~M_SR_BEV);\n    /*\n     * XXX There's a hazard here, but we're not going to worry about\n     * XXX it.  It is unlikely we'll use the vectors any time soon.\n     */\n}\n```\n\n清掉BEV标志，因此除了reset， soft reset，NMI外，所有其他的中断向量都在RAM中`0X8000_0000`开始处\n\n```c\n#define MIPS_ROM_VEC_RESET    0x0000\n#define MIPS_ROM_VEC_TLBFILL    0x0200\n#define MIPS_ROM_VEC_XTLBFILL    0x0280\n#define MIPS_ROM_VEC_CACHEERR    0x0300\n#define MIPS_ROM_VEC_EXCEPTION    0x0380\n#define MIPS_ROM_VEC_INTERRUPT    0x0400\n#define MIPS_ROM_VEC_EJTAG    0x0480\n\n#define MIPS_RAM_VEC_TLBFILL    0x0000                       //EXL=0时TLB异常入口\n#define MIPS_RAM_VEC_XTLBFILL    0x0080                      //EXL=1时TLB异常入口\n#define MIPS_RAM_VEC_CACHEERR    0x0100                  //cache 错误异常入口\n#define MIPS_RAM_VEC_EXCEPTION    0x0180                  //通用异常入口\n#define MIPS_RAM_VEC_INTERRUPT    0x0200                  //中断入口\n#define MIPS_RAM_VEC_END    0x0300\n#define CPUCFG_TLBHANDLER        bcmcore_tlbhandler\n```\n\nTLB异常为何要在分EXL处理呢，主要是为了处理更高效，因为EXL=0时，TLB发生异常的频率很高，所以单独搞个专用的TLB异常向量，可以极大的提升系统性能，因为通用异常处理向量要根据异常码分开处理，效率不高\n\n```assembly\n _exc_setup_locore((intptr_t) CPUCFG_CERRHANDLER);  //重新设置cache 错误异常处理向量，这个函数\n        li    t0,PHYS_TO_K1(CFE_LOCORE_GLOBAL_CERRH)\n        SR    a0,0(t0)\n#把正常的异常处理向量保存在CFE_LOCORE_GLOBAL_CERRH内存中，然后\n        li    t0,PHYS_TO_K1(MIPS_RAM_VEC_CACHEERR)\n\n        LOADREL(t1,_exc_cerr_htable)\n        LR    t2,R_EXC_CERR_TEMPLATE_END(t1)\n        LR    t1,R_EXC_CERR_TEMPLATE(t1)\n#将_exc_cerr_htable中存放的异常处理函数拷贝覆盖到    exc_setup_hw_vector(MIPS_RAM_VEC_CACHEERR, _exc_entry,XTYPE_CACHEERR);已经安装的内存中，也就是0x0100的内存中\n_exc_cerr_htable:\n        _LONG_    _exc_cerr_template\n        _LONG_    _exc_cerr_template_end\n\nLEAF(_exc_cerr_template)\n        LR    k0,CFE_LOCORE_GLOBAL_CERRH(zero)\n        jal    k0\n         nop\n#取出保存的异常向量地址\n/*\n* Temporary until all our CPU packages support a cache error handler\n*/\n#ifndef CPUCFG_CERRHANDLER\n#define CPUCFG_CERRHANDLER 0xBFC00000\n#else\nextern void CPUCFG_CERRHANDLER(void);\n#endif\n```\n\n这里实际上是没有定义 CPUCFG_CERRHANDLER的，因此在cfe中cache错误将导致直接重启\n\n```c\nstatic void exc_setup_hw_vector(uint32_t vecoffset,\n                  void *target,\n                  uint32_t k0code)\n{\n    uint32_t *vec;\n    uint32_t new;\n    uint32_t lower,upper;\n    new = (uint32_t) (intptr_t) target;    /* warning: assumes compatibility addresses! */\n    lower = new & 0xffff;\n    upper = (new >> 16) & 0xffff;\n    if ((lower & 0x8000) != 0) {\n    upper++;\n    }\n    /*\n     * Get a KSEG0 version of the vector offset.\n     */\n    vec = (uint32_t *) PHYS_TO_K0(vecoffset);\n    /*\n     * Patch in the vector.  Note that we have to flush\n     * the L1 Dcache and invalidate the L1 Icache before\n     * we can use this.  \n     */\n    vec[0] = 0x3c1b0000 | upper;   /* lui   k1, HIGH(new)     */\n    vec[1] = 0x277b0000 | lower;   /* addiu k1, k1, LOW(new)  */\n    vec[2] = 0x03600008;           /* jr    k1                */\n    vec[3] = 0x241a0000 | k0code;  /*  li   k0, code          */\n}\n```\n\nkernel中的异常处理\n\n**处理程序什么时候安装?**\n\n```c\ntraps_init(arch/mips/kernel/traps.c,setup_arch之后start_kernel调用)\n/* Copy the generic exception handler code to it's final destination. */\nmemcpy((void *)(KSEG0 + 0x80), &except_vec1_generic, 0x80);\nmemcpy((void *)(KSEG0 + 0x100), &except_vec2_generic, 0x80);\nmemcpy((void *)(KSEG0 + 0x180), &except_vec3_generic, 0x80);\nflush_icache_range(KSEG0 + 0x80, KSEG0 + 0x200);\n/*\n* Setup default vectors\n*/\nfor (i = 0; i <= 31; i++)\nset_except_vector(i, handle_reserved);\n```\n\n**装的什么?** \n\n```assembly\nexcept_vec3_generic(head.S) #(除了TLB refill例外都用这个入口): /* General exception vector R4000 version. */\nNESTED(except_vec3_r4000, 0, sp)\n.set noat\nmfc0 k1, CP_CAUSE\nandi k1, k1, 0x7c /* 从cause寄存器取出异常号 */\nli k0, 31<<2 beq k1, k0, handle_vced /* 如果是vced,处理之*/\nli k0, 14><<2 beq k1, k0, handle_vcei /* 如果是vcei,处理之*/\n/* 这两个异常是和cache相关的,cache出了问题,不能再在这个cached的位置处理啦 */\nla k0, exception_handlers /* 取出异常处理程序表 */\naddu k0, k0, k1 lw k0, (k0) /*处理函数*/\nnop jr k0 /*运行异常处理函数*/\nnop\n```\n\n**那个异常处理程序表是如何初始化的呢?**\n\n在traps_init中,大家会看到`set_exception_vector`(i,handler)这样的代码, 填的就是这张表啦.可是,如果你用souce insigh之类的东西去找那个handler,往往就落空了,??怎么没有handle_ri,handle_tlbl..._?不着急,只不过是一个小trick, 还记得x86中断处理的handler代码吗? 它们是用宏生成的:\n\n```assembly\nentry.S\n#define BUILD_HANDLER(exception,handler,clear,verbose)\n.align 5;\nNESTED(handle_##exception, PT_SIZE, sp);\n.set noat;\nSAVE_ALL; /* 保存现场,切换栈(如必要)*/\n__BUILD_clear_##clear(exception); /*关中断?*/\n.set at;\n__BUILD_##verbose(exception);\njal do_##handler; /*干活*/\nmove a0, sp;\nret_from_exception; /*回去*/\nnop;\nEND(handle_##exception) /*生成处理函数*/\nBUILD_HANDLER(adel,ade,ade,silent) /* #4 */\nBUILD_HANDLER(ades,ade,ade,silent) /* #5 */\nBUILD_HANDLER(ibe,ibe,cli,verbose) /* #6 */\nBUILD_HANDLER(dbe,dbe,cli,silent) /* #7 */\nBUILD_HANDLER(bp,bp,sti,silent) /* #9 */\n```\n\n认真追究下去,这里的一些宏是很重要的,象SAVE_ALL(include/asm/stackframe.h), 异常处理要高效,正确,这里要非常小心.这是因为硬件做的事情实在太少了.","tags":["异常"],"categories":["MIPS"]},{"title":"scudo 内存分配器调研","url":"/2020/07/20/稳定性/scudo 内存分配器调研/","content":"\n# 来源\n\nllvm项目  https://github.com/llvm/llvm-project , android aosp进行了定制\n\n```ad-info\n这是一个概念\n```\n# 概念\n\nscudo 大概分为以下几个部分：\n\n1. **前端FrontEnd：**使用Primary或Secondary后端来分配内存，还包括在初始化时根据配置（环境变量或者hook callback）来设置一些运行时参数：比如gc的时间、是否检查一些错误等。\n2. **Primary后端:** 对应aosp上用的是SizeClassAllocator64，负责小内存分配，最大支持`0x10010`大小的分配（这个大小还要包括chunk header的大小，且是对齐后的），Primary后端在初始化的时候就会为每个size class mmap 256M的VM（没有commit的）供前端使用。\n3. **Secondary后端:** 对于无法从Primary分配的大内存，这里会直接用mmap去分配。\n4. **TSDRegistrySharedT：**从名称能看出来这种tsd是多线程共享的。从下面的AndroidConfig能看到aosp上最多两个TSD(`min(2, cpus)`)，即多个线程共享一个TSD中缓存的内存block。\n5. **AndroidSizeClassMap：**简单认为size class table的配置，即多少种slab，每种slab的元素的大小。slab是针对小内存提出的概念\n\n# 配置\n\n> Android 添加了scudo的相关配置, 下面很多地方用到了这里面的配置\n\n```c\nstruct AndroidSizeClassConfig {\n#if SCUDO_WORDSIZE == 64U\n  ...\n  static constexpr u32 Classes[] = {\n      0x00020, 0x00030, 0x00040, 0x00050, 0x00060, 0x00070, 0x00090, 0x000b0,\n      0x000c0, 0x000e0, 0x00120, 0x00160, 0x001c0, 0x00250, 0x00320, 0x00450,\n      0x00670, 0x00830, 0x00a10, 0x00c30, 0x01010, 0x01210, 0x01bd0, 0x02210,\n      0x02d90, 0x03790, 0x04010, 0x04810, 0x05a10, 0x07310, 0x08210, 0x10010,\n  };\n  struct AndroidConfig {\n  using SizeClassMap = AndroidSizeClassMap;\n#if SCUDO_CAN_USE_PRIMARY64\n  // 256MB regions  2^28 = 256M 一次map 256M * NumClasses 空间 \n  typedef SizeClassAllocator64<SizeClassMap, 28U, 1000, 1000,\n                               /*MaySupportMemoryTagging=*/true>\n      Primary;\n#else\n  // 256KB regions 2^18 = 256k 一次map 256k * NumClasses  32位上\n  typedef SizeClassAllocator32<SizeClassMap, 18U, 1000, 1000> Primary;\n#endif\n  // Cache blocks up to 2MB\n  typedef MapAllocator<MapAllocatorCache<256U, 32U, 2UL << 20, 0, 1000>>\n      Secondary;\n  template <class A>\n  using TSDRegistryT = TSDRegistrySharedT<A, 8U, 2U>; // Shared, max 8 TSDs.\n  setNumberOfTSDs((NumberOfCPUs == 0) ? DefaultTSDCount\n                                        : Min(NumberOfCPUs, DefaultTSDCount))\n};\n```\n\n# ChunkHeader\n\n每个堆内存块的前面都会有一个块标头。 这有两个目的，第一个目的是存储有关块的各种信息，第二个目的是检测潜在的堆溢出。 为了实现这一点，将对报头进行校验和，包括指向区块本身的指针和全局密码。 当访问所述报头时，将检测到所述报头的任何损坏。\n\n\n\n以下信息存储在报头中：\n\n- 16位checksum；`Checksum`\n- 该块的类ID，对于Primary后端的分配，它是块“缓存池”的id；对于Secondary分配器, 该值是0；`ClassId`\n- 该区块的大小(Primary后端)或未使用的字节（Secondary后端)，这是计算区块大小所必需的； `SizeOrUnUsedBytes`\n- 数据块的状态(可用、已分配或已隔离)； `Available`/`Allocated`/`Quarantined`   `State`\n- 分配类型(`Malloc`、`New`、`NewArray`或`Memalign`)，用于检测使用的分配API中可能不匹配的情况； `Origin`\n- 在所有支持的平台上，此标头的大小均在8字节以内。\n\n\n\n把全局密码(每次程序执行时生成一把随机key) 、区块指针本身和 checksum字段清零的8字节chunkheader 计算CRC32值作为checksum存储在chunkheader中 (在硬件支持下速度更快)。\n\n\n\n# 分配流程\n\n- Primary\n\n\n\n![scudo.drawio](../images/20200915170712.svg)\n\n- Secondary\n\n![scudo.second.drawio](../images/20200922212558.svg)\n\n分配流程图\n\n![scudo_allocate.drawio](../images/20201209191745.svg)\n\nRegionInfo 对应了RegionSize classId的一整块区域,  **RegionInfo** 的*FreeList*维持了一个长的链列, 在*FreeList*取出**TransferBatch**, 填给**PerClass**, 如果取出为空, 则需要重新装填*FreeList*, mmap分配内存, 并按ClassId size 切片打包装入TransferBatch, 挂到FreeList 链队中.  是在`populateBatches`中处理的. PerClass 为容量较小的缓存, PerClass退Batch的过程可以理解成子弹出弹夹的过程, 当弹夹为空后, 需要从RegionInfoArray[classId]的FreeList 出来TransferBatch, 打包装填PerClass的Chunks, PerClass的Chunks数组容量是**两倍**的TransferBatch的大小, 一次装填只能填入一半.\n\n**PerClass Chunks** 可以理解成枪的弹夹, 只能存少量的子弹, 而FreeList可以理解成补给兵的备用弹夹, TransferBatch则是用来一次装填枪弹夹的弹药包. mmap的过程理解成兵工厂制作备用弹夹的过程, 而classId的内存单元比成子弹. 子弹分不同的口径, classId 有不同的size. 生产出子弹后, 打乱子弹的编号, 放到弹药包中, 防止利用子弹的编号规律查到一些信息. 而这里则是为了更安全, 连续 malloc相同classid的内存单元, 内存地址不会是连续的, 规避漏洞.\n\n#  释放隔离流程\n\n## 启用隔离\n\n默认没有启动隔离区,  需要在主程序中实现该方法, 配置scudo 参数. \n\n```c\n// 示例代码\nextern \"C\" __attribute__((visibility(\"default\"))) const char *\n__scudo_default_options() {\n  return \"quarantine_size_kb=256:thread_local_quarantine_size_kb=128:\"\n         \"quarantine_max_chunk_size=512:\";\n}\n```\n\n## 释放流程\n\n\n\n![scudo_deallocate.drawio](../images/20201215150309.svg)\n\n![scudo.quarantine.drawio](../images/20200915171650.svg)\n\n1. 如有需要会先对指针untag，然后加载Chunk的Header（这里会做checksum检查，以及分配类型是否匹配：malloc/free，delete/new）， 再根据入参的ptr获得用户分配的size大小（做delete size mismatch检查）。\n\n2. deallocate有两种去向，即是否需要进行**Quarantine**，如果不需要则进行步骤3释放回后端（Primary或Secondary）, 否则进行隔离(这个是为了检测UAF错误)。\n\n3. 通过chunck header得到真正的从后端拿到的block的地址，根据class id决定释放到Primary还是Secondary中。class id = 0 代表是从secondary后端分配。\n\n4. 对于Secondary后端，如果释放的block小于2M，则先尝试放到MapAllocatorCache的CacheBlock数组中，如果成功放入数组，**会将当前时间作为这个block释放的时间，还会根据配置的gc时间间隔将数组中老化时间超过gc间隔的block释放掉（madvise而不是munmap）, 调用`releaseOlderThan`。** 另外一种情况如果在放回CacheBlock数组的时候发现数组满了(累计4次)，则会unmap所有block，同时当前被释放的block也会被unmap(`store`过程中做的)。\n\n5. 对于Primary后端，首先还是拿到当前线程对应的TSD并获取TSD中的cache，如果cache不满则直接放到cache中，free到此结束。如果cache满了，则将cache中一半数量的缓存block返回给Primary对应Region的freelist中，然后再将当前被释放的block放到cache中。cache返回给primary对应region之后会判断是否需要做madvise释放free list 中的 block占用的pss(物理内存 **MADV_DONTNEED**)，依据包含：上次freelist释放pss的时间以及gc间隔判断老化时间是否足够，以及freelist中的block大小( 调用`releaseToOSMaybe(Region, ClassId)`函数 -> **FreePagesRangeTracker.finish()** -> **closeOpenedRange** -> **releasePageRangeToOS**)\n\n   ```c\n   Region->CanRelease = (I != SizeClassMap::BatchClassId) &&\n                              (getSizeByClassId(I) >= (PageSize / 32))\n   ```\n\n### 隔离区 **QuarantineBatch** 退回的过程\n\n**QuarantineBatch** 托管了要释放的指针, 而不用管具体的指针指向的内存属于哪个RegionSize类\n\n从QuarantineCache 开始看, 这个是一个用于保存延迟释放隔离内存区的类,  TSD相关的QuarantineCache类中保存了一个List, 链接该线程所有的QuarantineBatch. Size成员保存了已经放到隔离区的总的内存大小. QuarantineBatch中保存了一个Batch[MaxCount]的数组. 该数组中保存了要释放的指针(指针的ChunkHeader的状态已经变成 Chunk::State::`Quarantined`).  一个`QuarantineBatch`最大放`MaxCount`(1019)个指针.\n\n在放入隔离区时, 先往TSD的QuarantineCache中放, 当TSD的QuarantineCache的内存Size > getCacheSize 时(即配置了`thread_local_quarantine_size_kb`的值), 会将TSD的QuarantineCache整个移入Global QuarantineCache, TSD的QuarantineCache会重置. 然后再判断Global的 QuarantineCache 下的总内存是否大于MinSize(0.9*quarantine_size_kb), 则出队移入tmp, 这里采用QuarantineBatch 一个一个从全局Cache出队, 直到满足<MinSize为止.  出队的QuarantineBatch会进行回收, 同时释放QuarantineBatch 结构.\n\n# 参数配置\n\n```c\n// 示例代码\nint main() {\n    mallopt(M_CACHE_COUNT_MAX, 100);\n    mallopt(M_CACHE_SIZE_MAX, 1024 * 1024 * 2);\n    mallopt(M_TSDS_COUNT_MAX, 8);\n    ...\n}\n\n```\n\n- M_TSDS_COUNT_MAX\n\n  设置线程局部存储(TSL)相关的TSD的数目, M_TSDS_COUNT_MAX设置为8后, 如小于等于8个线程, 每个线程会绑定一个TSD.\n\n  在每个线程中 使用malloc  free时, 会根据线程状态寄存器查找到其绑定的TSD缓存池.\n\n  ​     scudo没有外部配置的情况下, 只有两个TSD缓存池, 在配置`M_TSDS_COUNT_MAX`后, 会产生最多`M_TSDS_COUNT_MAX`个缓存池, 该值会影响 small(primary) 分配器. 在TSD缓存池少的情况下, 会出现多个线程共用一个TSD缓存池的情况, 分配释放内存时需要等锁.\n\n  > Secondary 分配器没有绑定TSD(不是线程私有), 是所有线程共用同一块缓存池, 分配释放需要加锁等锁.\n  >\n  > jemalloc5 中 在sz index(36-45范围内的), 对应几十k字节的large类使用的缓存是绑定tcache的(线程私有). \n\n- M_CACHE_COUNT_MAX\n\n  option->MaxCacheEntriesCount\n\n     large(Secondary) 分配器在分配释放内存时, 所有线程共用的`缓存池的容量`, 每次free 时, 会先将该内存单元放到缓存池中, 下次malloc时, 会优先根据分配的size 在缓存池中查找是否有匹配的缓存内存单元, 如果有则直接把该内存单元的地址返回给调用方. \n\n     large(Secondary)的缓存池在满了以后, 下一次free时, 会重置清空缓存池\n\n  > 该值对应上图的 `EntriesArraySize`, 默认值为32,  最大只能设置到256, 如果超过256, 会设置失败, 用默认值.\n\n- M_CACHE_SIZE_MAX\n\n  option->MaxCacheEntrySize\n\n  在free时, large(Secondary) 分配器并不是将所有大于small分配器的内存单元全部放到缓存池中,  而是在 `0x40010`-`M_CACHE_SIZE_MAX`范围内的会在free时放到缓存池中(small的范围`0-0x40010`),  malloc时会优先从缓存池中查找. 而大于`M_CACHE_SIZE_MAX`的malloc则直接走mmap, free走`unmap`. \n\n  > 该值对应上图的 `MaxEntrySize`, 默认值是2M\n\n# 脚本使用\n\n- primary分配器perclass**中最近缓存的可用地址已用地址的分析**, map region区域中的地址单元的状态分析, 包括header state / class_size / 分配的大小等\n-  secondary分配器中的地址单元的分析, 所有使用状态和free后的地址单元的状态解析\n- 给定chunk header的地址, 打印其header的状态\n- 给定一个内存地址, 搜索其命中的内存区域(perclass/RegionInfo/secondary used/secondary cached), 如果命中, 给出其分析状态\n- 统计功能, 分析所有使用状态的内存地址单元(如果有映射虚表), 按照命中次数/分配的总大小来进行统计, 给出降序的统计结果\n- 离线功能结合tombstones 分析内存地址chunk header的状态\n- Primary分配器中分析每个线程绑定了哪个perclass.\n\n> 怎样查看tsd绑定到哪些线程?\n\n​    scudo 把tsd (Allocator)的首地址写到了 tpidr_el0 向后偏移6个指针的位置, tpidr_el0  寄存器的地址在tls区域. 线程在创建时, 会将tls的相关数据结构存储在pthread_internal_t类型的结构中, 并挂到链表中,  g_thread_list为该链表的表头. 通过解析g_thread_list, 找到bionic_tls区域,  在该区域前面为bionic_tcb区域, tpidr_el0的地址即为bionic_tcb区域的首地址. 解析该区域即可将Allocator  的地址找到. 在加载linker后, g_thread_list会变成linker bss段的符号, 解析会出错, 这个时候再想解析,  可以通过dump libc bss段, 检索g_thread_list 符号的方法.\n\n> 有些地址已经被换出perclass了, 就会丢失tsd的信息, 如果想确定这部分数据与线程的关系, 是获取不了的\n\n```shell\nclass_id   tsd_ind    count    max_count    class_size\n-------------------------------------------------------\n0           0      12       28           128       \n1           0      14       28           32        \n2           0      11       28           48        \n3           0      9        28           64        \n4           0      11       28           80        \n5           0      10       28           96        \n6           0      15       28           112       \n7           0      4        28           144       \n8           0      7        28           176       \n9           0      13       28           192       \n...   \n0           1      7        28           128       \n1           1      14       28           32        \n2           1      23       28           48        \n3           1      15       28           64        \n4           1      14       28           80        \n5           1      15       28           96        \n6           1      14       28           112       \n7           1      14       28           144       \n8           1      11       28           176       \n9           1      14       28           192       \n...\ntid     tsd_ind    tsd_addr    \n-----------------------------------\n8380    0          0x73eea5a780\n711     0          0x73eea5a780\n709     1          0x73eea5cc80\n694     0          0x73eea5a780\n652     1          0x73eea5cc80\n651     0          0x73eea5a780\n650     1          0x73eea5cc80\n628     0          0x73eea5a780\n```\n\n## 脚本使用与维护\n\n```shell\ngit clone ssh://<user>@gerrit.pt.mioffice.cn:29418/miui/bootable/recovery-tools\ngit push ssh://<user>@gerrit.pt.mioffice.cn:29418/miui/bootable/recovery-tools HEAD:refs/for/master\n```\n\n可以参考 **scudo_shadow/gdb_scripts**下的脚本定制自己的gdb 脚本(包括gdb elf/gdb remote attach elf/gdb coredump). \n\n> 目前发现有些lib库里面定义的Allocator与scudo的重了, 导致scudo脚本无法使用, 如果发现类似的库, 需要将其从lib目录下移出.\n>\n> 定位方法:  gdb中使用**ptype Allocator** 查看其数据类型, 如果不是**scudo::Allocator**, 需要看其下面的类型定义或类的相关信息, 据此查找其属于哪个lib库.\n\n# 与jemalloc 比较\n\nscudo 中与内存单元相关的数据结构包括 \n\n- small size class\n\n  Batch(或者chunk)(最基础的单位) -> Perclass::Chunks [TSD]->TransferBatch->RegionInfo->RegionInfoArray\n\n- large size class\n\n  cacheBlock -> largeBlock -> inUsedBlocks\n\njemalloc5 中与内存单元的数据结构包括\n\n- small size class\n\n  region(最基础单位) -> slab(extent) -> base -> cache_bin [TSD] ->tcache[TSD] -> extents(dirty|muzzy|retained) -> rtree -> bin -> arena\n\n- large size class\n\n  region(最基础单位) -> extent -> base -> extents -> rtree -> bin -> arena","tags":["Android","heap","scudo"],"categories":["稳定性"]},{"title":"hexdump 格式化输出","url":"/2020/07/19/hxd_new/hexdump 格式化输出/","content":"\n> 参考 [hexdump-format_Focus-CSDN博客_hexdump格式化输出](https://blog.csdn.net/charles_neil/article/details/87118497)\n\n`hexdump -e '4/1 \" 0x%02x,\"' fdl_sec.bin -n 32`\n\n-e 指定格式字符串，格式字符串由单引号包含，格式字符串形如：'a/b \"format1\" \"format2\" '    。每个格式字符串由三部分组成，每个由空格分割，如a/b表示，b表示对`每b个输入字节`应用format1格式，a表示对每个a输入字节应用format2，一般a>b，且b只能为1,2,4，另外a可以省略，省略a=1。format1和format2中可以使用类似printf的格斯字符串。\n\n```shell\n hexdump -e '16/1 \" 0x%02x,\" \"\\n\" ' keys/aes_priv_key\n 0x34, 0xf1, 0x4b, 0xd9, 0x1b, 0x32, 0x0f, 0x05, 0xb1, 0x5c, 0x6e, 0x72, 0x9d, 0xec, 0x42, 0x74,\n 0xd1, 0xae, 0x29, 0x36, 0x53, 0xe1, 0x89, 0x86, 0xd8, 0x88, 0xfe, 0xcc, 0x39, 0xbb, 0x30, 0x81,\n```\n\n-v 打印重复项\n\n如果不带-v， 遇到重复的 会以 `*` 显示， 带 `-v`会显示所有项\n\n-n 打印的字节数\n\n-s 忽略文件开头多少个字节，再开始打印数据\n\n因此最终可以使用下面命令完整打印`单字节`打印`二进制文件`的数据, 并可以无缝将数据导入到数组中\n\n```shell\n hexdump -e '16/1 \" 0x%02x,\" \"\\n\" ' -v <file> -n <字节数目> -s <字节数目>\n```\n\n","tags":["hexdump"],"categories":["稳定性"]},{"title":"scudo配置","url":"/2020/07/19/稳定性/scudo配置/","content":"\n![scudo_allocate.drawio](../images/20201222212504.svg)\n\n下面的参考数据仅是指64位程序的, 32位的配置和64位不同.\n\n- M_TSDS_COUNT_MAX\n\n  设置线程局部存储(TSL)相关的TSD的数目, M_TSDS_COUNT_MAX设置为8后, 如小于等于8个线程, 每个线程会绑定一个TSD.\n\n  在每个线程中 使用malloc  free时, 会根据线程状态寄存器查找到其绑定的TSD缓存池.\n\n  ​     scudo没有外部配置的情况下, 只有两个TSD缓存池, 在配置`M_TSDS_COUNT_MAX`后, 会产生最多`M_TSDS_COUNT_MAX`个缓存池, 该值会影响 small(primary) 分配器. 在TSD缓存池少的情况下, 会出现多个线程共用一个TSD缓存池的情况, 分配释放内存时需要等锁.\n\n  > Secondary 分配器没有绑定TSD(不是线程私有), 是所有线程共用同一块缓存池, 分配释放需要加锁等锁.\n  >\n  > jemalloc5 中 在sz index(36-45范围内的), 当前的配置字节在(14336- 65536)) 使用的缓存是绑定tcache的(线程私有). \n\n- M_CACHE_COUNT_MAX\n\n  option->MaxCacheEntriesCount\n\n     large(Secondary) 分配器在分配释放内存时, 所有线程共用的`缓存池的容量`, 每次free 时, 会先将该内存单元放到缓存池中, 下次malloc时, 会优先根据分配的size 在缓存池中查找是否有匹配的缓存内存单元, 如果有则直接把该内存单元的地址返回给调用方. \n\n     large(Secondary)的缓存池在满了以后, 下一次free时, 会重置清空缓存池\n\n  > 该值对应上图的 `EntriesArraySize`, 默认值为32,  最大只能设置到256, 如果超过256, 会设置失败, 用默认值.\n\n- M_CACHE_SIZE_MAX\n\n  option->MaxCacheEntrySize\n\n  在free时, large(Secondary) 分配器并不是将所有大于small分配器的内存单元全部放到缓存池中,  而是在 `0x40010`-`M_CACHE_SIZE_MAX`范围内的会在free时放到缓存池中(small的范围`0-0x40010`),  malloc时会优先从缓存池中查找. 而大于`M_CACHE_SIZE_MAX`的malloc则直接走mmap, free走`unmap`. \n\n  > 该值对应上图的 `MaxEntrySize`, 默认值是2M\n\n\n\n","tags":["Android","heap"],"categories":["Android","稳定性"]},{"title":"android sigev 信号追踪","url":"/2020/07/19/稳定性/sigev 追踪/","content":"\n# 以SIGSEGV为例详解信号处理(与栈回溯)\n\n信号是内核提供的向用户态进程发送信息的机制, 常见的有使用SIGUSR1唤醒用户进程执行子程序或发生段错误时使用`SIGSEGV`保存用户错误现场. 本文以SIGSEGV为例, 详细分析信号使用方法, 内核信号的发送与接收机制.\n\n## 信号处理例程\n\n以下是一个`SiGEGV`处理例程, 主程序注册一个信号量并创建一个线程, 线程中故意访问空指针, 引发段错误. 在信号回调中会回溯堆栈, 保存出错的地址.\n回溯堆栈的原理在分析完整个信号处理流程后再分析, 首先我们先来分析如何使用信号.\n\n `sigaction`()用于向内核注册一个信号(参数1), 使用参数2(如果非空)作为注册信号的回调, 内核会将之前的信号回调返回在参数3中(如果非空). 如果父进程或程序之前阻塞了该信号则需先调用`sigprocmask`()取消阻塞.\n在回调处理结束时需手动退出进程(`exit`()), 否则**内核会不断触发该信号(重新执行异常指令再次引起崩溃)**, glibc对SIGSEGV有默认的回调, 所以默认情况下也会正常退出.\n\n```c++\n#include <string.h>\n#include <signal.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#define POPCNT(data)                            do {        \\\n        data = (data & 0x55555555) + ((data >> 1) & 0x55555555);    \\\n        data = (data & 0x33333333) + ((data >> 2) & 0x33333333);    \\\n        data = (data & 0x0F0F0F0F) + ((data >> 4) & 0x0F0F0F0F);    \\\n        data = (data & 0x00FF00FF) + ((data >> 8) & 0x00FF00FF);    \\\n        data = (data & 0x0000FFFF) + ((data >> 16) & 0x0000FFFF);    \\\n    } while (0);\n/**\n * we only calculate sp decrease which is static confirm in compile time\n * that is sub immediate & push instruction(and return when we find push)\n *\n**/\nvoid backtrace_stack(unsigned int **pppc, unsigned int **ppsp)\n{\n    unsigned int *ppc_last = *pppc;\n    unsigned int *psp = *ppsp;\n    unsigned int decrease = 0;\n    int i;\n    enum\n    {\n        INS_SUB_IMM = 0,\n        INS_STM1,\n        INS_STR_LR,\n        INS_STR_FP,\n        INS_BUTT\n    };\n    //see ARM reference manual for more detail\n    struct ins_map\n    {\n        unsigned int mask;\n        unsigned int ins;\n    };\n    struct ins_map map[INS_BUTT] =\n    {\n        {0xFFEFF000, 0xE24DD000},\n        {0xFFFF4000, 0xE92D4000},\n        {0xFFFFFFFF, 0xE52DE004},\n        {0xFFFFFFFF, 0xE52DB004},\n    };\nagain:\n    ppc_last--;\n    for (i = 0; i < INS_BUTT; i++)\n    {\n        if (map[i].ins == (*ppc_last &map[i].mask))\n        {\n            break;\n        }\n    }\n    switch (i)\n    {\n    case INS_SUB_IMM:\n        //sub sp, sp, imm\n        decrease = (*ppc_last & 0xFF) << ((32 - 2 * (*ppc_last & 0xF00)) % 32);\n        psp += decrease / sizeof(unsigned int);\n        break;\n    case INS_STM1:\n        //push lr, ...\n        decrease = *ppc_last & 0xFFFF;\n        POPCNT(decrease);\n        psp += decrease;\n        *pppc = *(psp - 1);\n        *ppsp = psp;\n        return;\n    case INS_STR_LR:\n        //push lr\n        psp += 1;\n        *pppc = *(psp - 1);\n        *ppsp = psp;\n        return;\n    case INS_STR_FP:\n        //push fp\n        psp += 1;\n        *ppsp = psp;\n        return;\n    default:\n        break;\n    }\n    goto again;\n}\n/**\n * process stack when catch a sigsegv:\n * ------------   stack top\n * | ......\n * | fault addr   sp position when memory fault happen\n * | sigframe     kernel use to resotre context DO NOT MODIFY(same to data)\n * | siginfo      glibc push this struct into stack(same to siginfo)\n * | current sp   sp position when enter signal handle\n *\n**/\nvoid sighandle(int sig, siginfo_t *siginfo, void *data)\n{\n    //data point to sigframe which is not seen to user\n    //search struct ucontext in kernel for more detail\n    unsigned int *psp = ((unsigned int *)data) + 21;\n    unsigned int *plr = ((unsigned int *)data) + 22;\n    unsigned int *ppc = ((unsigned int *)data) + 23;\n    unsigned int pc_val[5] = {0};\n    unsigned int sp_val[5] = {0};\n    char **ppstr;\n    int i;\n\n    printf(\"get signal %u addr %x\\n\", siginfo->si_signo, siginfo->si_addr);\n    pc_val[0] = *ppc;\n    sp_val[0] = *psp;\n    for (i = 1; i < 4; i++)\n    {\n        pc_val[i] = pc_val[i - 1];\n        sp_val[i] = sp_val[i - 1];\n        backtrace_stack((unsigned int **)(&pc_val[i]), (unsigned int **)(&sp_val[i]));\n        /**\n         * for subroutine use push {fp} instruction, we can't get it's caller pc\n         * so we use last lr as pc and hope program won't push {fp} twice\n         *\n        **/\n        if (pc_val[i] == pc_val[i - 1])\n        {\n            pc_val[i] = *plr;\n        }\n        pc_val[i] -= 4;\n    }\n    ppstr = backtrace_symbols((void **)pc_val, 5);\n    for (i = 0; i < 5; i++)\n    {\n        printf(\"%u: pc[0x%08x] sp[0x%08x] %s\\n\", i, pc_val[i], sp_val[i], ppstr[i]);\n    }\n    exit(1);\n}\nvoid fault_func3()\n{\n    int *p = NULL;\n    *p = 1;\n}\nvoid fault_func2()\n{\n    int a = 0x5678;\n    fault_func3();\n    return;\n}\nvoid fault_func1(void *pvoid)\n{\n    int a = 0x1234;\n    fault_func2();\n    return;\n}\nint main(int argc, char *argv[])\n{\n    struct sigaction sigact;\n    int *p = NULL;\n    memset(&sigact, 0, sizeof(struct sigaction));\n    sigact.sa_sigaction = sighandle;\n    sigact.sa_flags = SA_SIGINFO | SA_RESTART;\n    sigaction(SIGSEGV, &sigact, NULL);\n    getc(stdin);\n    pthread_t thread;\n    pthread_create(&thread, NULL, fault_func1, NULL);\n    while (1)\n    {\n        ;\n    }\n    return 0;\n}\n```\n\n##  内核信号量数据结构与系统调用\n\n虽然用户调用的sig*接口都是glibc的接口, 但实际上glibc还是通过系统调用实现的.\n与信号量相关的数据结构有:\n`task_struct`(负责保存信号处理句柄, 阻塞与挂起的信号队列)\n`sighand_struct`(每个信号处理 handler句柄, 保护信号的自旋锁)\n`signal_struct`(信号量结构, 大部分参数都在该结构中)\n`sigpending`(挂起队列, 用于索引挂起的信号)\n作为一种信息传递机制, 信号量代码本身并不复杂, 即使是信号发送接口__send_signal()(分析见下).\n\n```c\nstruct task_struct {\n  ......\n\n  struct signal_struct *signal;\n  //信号处理句柄, 包括每个信号的action, 锁与等待队列\n  struct sighand_struct *sighand;\n  //该task阻塞的信号\n  sigset_t blocked, real_blocked;\n  sigset_t saved_sigmask;\n  //该task挂起信号的结构体\n  struct sigpending pending;\n  ......\n};\n\nstruct sighand_struct {\n  atomic_t count;\n  //保存信号处理句柄的数组\n  struct k_sigaction action[_NSIG];\n  //自旋锁, 不仅保护该结构同时还保护task_struct.signal\n  spinlock_t siglock;\n  wait_queue_head_t signalfd_wqh;\n};\n\n/**\n \\* signal_struct自身没有锁\n \\* 因为一个共享的signal_struct往往对饮一个共享的sighand_struct\n \\* 即使用sighand_struct的锁是signal_struct的超集\n *\n**/\nstruct signal_struct {\n  ......\n  //进程的信号挂起队列, 与task_struct.pending区别是所有线程共享\n  struct sigpending shared_pending;\n  ......\n};\n\n//描述挂起信号的结构体\n//成员list为进程所有挂起信号的双线链表的头\n//成员signal为进程挂起信号量的位图, 挂起的信号对应的位置位\nstruct sigpending {\n  //sigqueue链表头\n  struct list_head list;\n  //当前挂起的信号量位图\n  sigset_t signal;\n};\n\n//描述一个挂起信号的结构体\nstruct sigqueue {\n  //sigqueue链表节点\n  struct list_head list;\n  int flags;\n  //该挂起信号的信息\n  siginfo_t info;\n  struct user_struct *user;\n};\n\n//描述信号相关信息的结构体\ntypedef struct siginfo {\n  int si_signo;\n  int si_errno;\n  int si_code;\n  ......\n} __ARCH_SI_ATTRIBUTES siginfo_t;\n```\n\n\n\n```c\n/**\n * 定义见kernel/signal.c\n * 获取或修改拦截的信号\n * @how: 为SIG_BLOCK / SIG_UNBLOCK / SIG_SETMASK的一种\n * @nset: 如果非空为增加或移除的信号\n * @oset: 如果非空为之前的信号\n * note: sigprocmask系统调用任务很简单, 用新值修改current->blocked并将旧值传回用户态\n *       调用set_current_blocked中会先剔除SIGKILL与SIGSTOP, 用户传递这两个值是无效的\n *       之后还会判断task是否已经pending及是否有线程, 如果有还需对每个线程单独处理\n *\n**/\nSYSCALL_DEFINE3(sigprocmask, int, how, \\\n    old_sigset_t __user *, nset, \\\n    old_sigset_t __user *, oset);\n/**\n * 定义见kernel/signal.c\n * 获取或修改拦截信号的action\n * @sig: 为拦截的信号\n * @act: 如果非空为信号sig的action\n * @oact: 如果非空为返回之前信号sig的action\n * note: 如果传入未定义信号或SIGKILL与SIGSTOP会直接返回EINVAL\n *       如果act非空则将其赋值给进程task_struct.sighand->action[i]中\n *       然后检测所拦截的信号是否挂起, 如果有挂起则将其从队列中删除\n *\n**/\nSYSCALL_DEFINE3(sigaction, int, sig, \\\n    const struct old_sigaction __user *, act, \\\n    struct old_sigaction __user *, oact);\n/**\n * 定义见kernel/signal.c\n * 以下两接口为发送信号的接口, 实际调用send_signal\n * send_signal()调用__send_signal\n *\n**/\nint do_send_sig_info(int sig, struct siginfo *info, \\\n    struct task_struct *p, bool group);\nint __group_send_sig_info(int sig, \\\n    struct siginfo *info, struct task_struct *p);\n```\n\n\n\n```c\n/**\n * 定义见kernel/signal.c\n * 实际发送信号的函数, 本接口未加锁, 需外部保证锁\n *\n**/\nstatic int __send_signal(int sig, struct siginfo *info, \\\n    struct task_struct *t, int group, int from_ancestor_ns)\n{\n    //检测是否已锁, 此处使用sighand的锁是因为sighand_struct与signal_struct往往一一对应\n    assert_spin_locked(&t->sighand->siglock);\n    //调用prepare_signal判断信号是否需要发送及做其它准备情况\n    //主要是处理SIGSTOP/SIGCONT, 对于SIGCONT立即发生, 对于SIGSTOP则不是立刻停止\n    //1. 对于即将退出的进程, 除SIGKILL外都不发送信号\n    //2. 如果是停止信号, 需先将进程挂起的SIGCONT移出挂起队列\n    //3. 如果是SIGCONT信号, 需先将所有停止信号都移出挂起队列同时清除线程标记位\n    //4. 判断信号是否需要忽略, 阻塞的信号不忽略, 忽略处理句柄为空与内核认为需要忽略信号\n    if (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))\n        goto ret;\n    pending = group   &t->signal->shared_pending : &t->pending;\n    //对于已挂起信号不再处理, 确保每种信号在队列中仅存在一个\n    if (legacy_queue(pending, sig))\n        goto ret;\n    //对于内核内部信号如SIGSTOP或SIGKILL走捷径\n    if (info == SEND_SIG_FORCED)\n        goto out_set;\n    //实时信号必须通过sigqueue或其它实时机制入队列\n    //但考虑到内存不足时kill不允许失败所以保证至少一个信号可以传递\n    if (sig < SIGRTMIN)\n        override_rlimit = (is_si_special(info) || info->si_code >= 0);\n    else\n        override_rlimit = 0;\n    q = __sigqueue_alloc(sig, t, \\\n        GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);\n    if (q) {\n        list_add_tail(&q->list, &pending->list);\n        switch ((unsigned long) info) {\n        case (unsigned long) SEND_SIG_NOINFO:\n            q->info.si_signo = sig;\n            q->info.si_errno = 0;\n            q->info.si_code = SI_USER;\n            q->info.si_pid = task_tgid_nr_ns(current, task_active_pid_ns(t));\n            q->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n            break;\n        case (unsigned long) SEND_SIG_PRIV:\n            q->info.si_signo = sig;\n            q->info.si_errno = 0;\n            q->info.si_code = SI_KERNEL;\n            q->info.si_pid = 0;\n            q->info.si_uid = 0;\n            break;\n        default:\n            copy_siginfo(&q->info, info);\n            if (from_ancestor_ns)\n                q->info.si_pid = 0;\n            break;\n        }\n        userns_fixup_signal_uid(&q->info, t);\n    } else if (!is_si_special(info)) {\n        if (sig >= SIGRTMIN && info->si_code != SI_USER) {\n            //信号队列溢出, 放弃\n            result = TRACE_SIGNAL_OVERFLOW_FAIL;\n            ret = -EAGAIN;\n            goto ret;\n        } else {\n            //继续传递信号, 但info信息丢失\n            result = TRACE_SIGNAL_LOSE_INFO;\n        }\n    }\nout_set:\n    signalfd_notify(t, sig);\n    //挂起队列位图对应位置位\n    sigaddset(&pending->signal, sig);\n    complete_signal(sig, t, group);\nret:\n    //跟踪信号生成, 该接口直接搜索不存在\n    //在include/trace/events/signal.h中宏定义\n    //其中TRACE_EVENT定义见include/linux/tracepoint.h\n    trace_signal_generate(sig, info, t, group, result);\n    return ret;\n}\nstatic void complete_signal(int sig, struct task_struct *p, int group)\n{\n    //寻找可唤醒的线程\n    //如果信号阻塞, 进程处于退出状态, task处于停止或跟踪状态无需信号\n    //如果信号为SIGKILL, task必须接收该信号\n    //如果task运行在当前cpu上或task无信号挂起也接收信号\n    if (wants_signal(sig, p))\n        t = p;\n    else if (!group || thread_group_empty(p))\n        /*\n        * There is just one thread and it does not need to be woken.\n        * It will dequeue unblocked signals before it runs again.\n        */\n        //仅一个线程无需唤醒, 自动在运行前去除未阻塞信号\n        return;\n    else {\n        t = signal->curr_target;\n        while (!wants_signal(sig, t)) {\n            t = next_thread(t);\n            if (t == signal->curr_target)\n                //遍历所有线程, 没有线程需要唤醒\n                return;\n        }\n        signal->curr_target = t;\n    }\n    //寻找可杀死的线程\n    if (sig_fatal(p, sig) &&\n        !(signal->flags & (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &&\n        !sigismember(&t->real_blocked, sig) &&\n        (sig == SIGKILL || !t->ptrace)) {\n            //唤醒整个线程组\n            if (!sig_kernel_coredump(sig)) {\n            signal->flags = SIGNAL_GROUP_EXIT;\n            signal->group_exit_code = sig;\n            signal->group_stop_count = 0;\n            t = p;\n            do {\n                task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n                sigaddset(&t->pending.signal, SIGKILL);\n                signal_wake_up(t, 1);\n            } while_each_thread(p, t);\n            return;\n        }\n    }\n    //唤醒线程去队列中获取信号\n    signal_wake_up(t, sig == SIGKILL);\n} \n```\n\n## 信号处理流程\n\n信号处理涉及内核最底层代码, 需了解芯片架构在内各类知识, 相对晦涩难懂.\n一般对现代芯片而言当进程访问一个非法地址后`MMU`会修改寄存器引起内核进入异常, 在异常处理时内核会分辨非法地址产生的原因(是真的非法地址还是没有映射页表)并作出不同处理. 对于处理失败的情况内核在异常处理结束时会向引起异常的task发送`SIGSEGV`, 在异常结束后执行调度时会首先判断该task是否有挂起信号, 如果存在则执行信号处理. 信号处理的复杂之处主要在于内核需要调用用户态程序并在程序结束后恢复内核现场. 接下来我们以Hi3536(ARMv7)平台具体分析信号处理流程(使用3.10内核).\n\narm一共有7种异常处理模式, reset, und, swi, pabt, dabt, irq, fiq(reference manual A2-13).\n其中与内存访问相关的有两种prefetch abort与data abort, 前者为取指令异常, `后者为数据异常`.\n异常向量表定义在arch/arm/kernel/entry-armv.S, __stubs_start到__stubs_end即整个异常向量表.\n在内核初始化时调用early_trap_init拷贝向量表(低地址空间是用户态, 所以需搬移到0xFFFF0000).\n向量表中每类异常的起始地址都是vector_stub宏, 后面跟着不同异常向量处理函数.\n以dabt为例, 先看下该宏:\n\n```assembly\n.macro vector_stub, name, mode, correction=0\n    .align 5\n    vector_\\name:\n    .if \\correction\n    sub lr, lr, #\\correction\n    .endif\n    @\n    @ Save r0, lr_<exception> (parent PC) and spsr_<exception>\n    @ (parent CPSR)\n    @\n    stmia sp, {r0, lr}  @ save r0, lr\n    mrs lr, spsr\n    str lr, [sp, #8]    @ save spsr\n    @\n    @ Prepare for SVC32 mode.  IRQs remain disabled.\n    @\n    mrs r0, cpsr\n    eor r0, r0, #(\\mode ^ SVC_MODE | PSR_ISETSTATE)\n    msr spsr_cxsf, r0\n    @\n    @ the branch table must immediately follow this code\n    @\n    and lr, lr, #0x0f\n    THUMB(adr r0, 1f)\n    THUMB(ldr lr, [r0, lr, lsl #2])\n    mov r0, sp\n    ARM( ldr lr, [pc, lr, lsl #2])\n    movs pc, lr         @ branch to handler in SVC mode\nENDPROC(vector_\\name)\n```\n\n进入异常后第一件事是保存异常模式下寄存器(如果发生嵌套异常又不保存寄存器则无法恢复异常环境).\n即保存 `lr_exception` 与 `spsr_exception`, 由于使用 r0传递 sp 还需保存 r0, 将 cpsr 设置为 svc 模式.\n保存现场后第二件事是跳转到对应的异常处理函数, 由于未定义THUMB2_KERNEL, 内核全部使用ARM指令.\n通过读cpsr寄存器低4位得知(通过mrs读取到lr中再位与0xF)进入异常前的运行模式.\n异常向量表是连续的4字节数组, 紧跟在该代码后, 通过pc + mode * 4得到异常向量地址.\n仍以dabt为例, 用户访问空指针引起abort异常, 用户模式mode bits为0, 此时即ldr lr, [pc].\n由于arm架构三级流水线, pc领先实际执行两个指令, 即lr为__dabt_usr, 最后跳转到__dabt_usr执行.\n如果内核访问空指针引起abort异常, 内核模式mode bits为3, 即跳转到__dabt_svc\n\n```assembly\nvector_stub dabt, ABT_MODE, 8 \n.long __dabt_usr       @  0  (USR_26 / USR_32) \n.long __dabt_invalid   @  1  (FIQ_26 / FIQ_32) \n.long __dabt_invalid   @  2  (IRQ_26 / IRQ_32) \n.long __dabt_svc       @  3  (SVC_26 / SVC_32) \n```\n\n接下来进入具体异常处理函数, 我们以__dabt_usr为例具体分析.\n\n```assembly\n__dabt_usr:\n    usr_entry\n    kuser_cmpxchg_check\n    mov r2, sp\n    dabt_helper\n    b ret_from_exception\n    UNWIND(.fnend)\nENDPROC(__dabt_usr)\n```\n\n 进入异常处理函数后第一件事是保存现场, 之前已保存了部分寄存器, usr_entry用来保存全部寄存器.\n\n```assembly\n.macro usr_entry\n    UNWIND(.fnstart)\n    UNWIND(.cantunwind)             @ don't unwind the user space\n    sub sp, sp, #S_FRAME_SIZE\n    ARM( stmib sp, {r1 - r12})\n    THUMB( stmia sp, {r0 - r12})\n    ldmia r0, {r3 - r5}\n    add r0, sp, #S_PC               @ here for interlock avoidance\n    mov r6, #-1\n    str r3, [sp]                    @ save the \"real\" r0 copied\n                                    @ from the exception stack\n    @\n    @ We are now ready to fill in the remaining blanks on the stack:\n    @\n    @  r4 - lr_<exception>, already fixed up for correct return/restart\n    @  r5 - spsr_<exception>\n    @  r6 - orig_r0 (see pt_regs definition in ptrace.h)\n    @\n    @ Also, separately save sp_usr and lr_usr\n    @\n    stmia r0, {r4 - r6}\n    ARM( stmdb r0, {sp, lr}^)\n    THUMB( store_user_sp_lr r0, r1, S_SP - S_PC)\n    @\n    @ Enable the alignment trap while in kernel mode\n    @\n    alignment_trap r0\n    @\n    @ Clear FP to mark the first stack frame\n    @\n    zero_fp\n#ifdef CONFIG_IRQSOFF_TRACER\n    bl trace_hardirqs_off\n#endif\n    ct_user_exit save = 0\n.endm\n```\n\n首先将r1-r12压栈, 注意此处没有使用push而是sp先减少再使用stmib反向压栈.\n原因是这些寄存器后面将以pt_regs形式访问, 数组排列是从低到高, 与栈增长相反.\n另外r0, pc, cpsr, orig_r0是压栈传入的, 原因分别如下.\nr0需作为栈地址参数传入异常处理函数, 其原始值被修改, 所以通过栈传入.\n由于pt_regs是指用户异常现场, pc与cpsr应保存异常发生时值, 但进入异常时使用影子寄存器.\n所以使用压栈的 `lr_exception` 与 `spsr_exception` (reference manual A2-13).\n最后orig_r0是什么鬼? 想不清楚它的用处.\n\n保存完用户现场后开始真正异常处理, dabt_helper的注释是调用指定的abort handler.\n\n```assembly\n.macro dabt_helper\n    @\n    @ Call the processor-specific abort handler:\n    @\n    @  r2 - pt_regs\n    @  r4 - aborted context pc\n    @  r5 - aborted context psr\n    @\n    @ The abort handler must return the aborted address in r0, and\n    @ the fault status register in r1.  r9 must be preserved.\n    @\n#ifdef MULTI_DABORT\n    ldr ip, .LCprocfns\n    mov lr, pc\n    ldr pc, [ip, #PROCESSOR_DABT_FUNC]\n#else\n    bl CPU_DABORT_HANDLER\n#endif\n.endm\n#ifdef MULTI_DABORT\n.LCprocfns:\n    .word processor\n#endif \n```\n\n其中pt_regs保存在r2中, abort时的pc指针保存在r4中, abort时的cpsr保存在r5中.\nhandler返回时abort地址保存在r0中, 错误状态寄存器(fsr)保存在r1中, r9保留.\n宏MULTI_DABORT定义见arch/arm/include/asm/glue-df.h, 由不同架构决定, ARMv7架构定义了该宏.\n对于定义MULTI_DABORT宏的架构, ldr pc, [ip, `#PROCESSOR_DABT_FUNC`]是跳转的关键.\n.LCprocfns段存放的是全局变量processor, 其定义在arch/arm/include/asm/proc-fns.h.\nPROCESSOR_DABT_FUNC定义见arch/arm/kernel/asm-offsets.c, 即指向processor._data_abort.\n\n全局变量processor是如何初始化的? 答案见setup_processor(defined in arch/arm/kernel/setup.c).\n在setup_processor中会调用lookup_processor_type(defined in arch/arm/kernel/head-common.S):\n\n```assembly\nENTRY(lookup_processor_type)\n    stmfd sp!, {r4 - r6, r9, lr}\n    mov r9, r0\n    bl __lookup_processor_type\n    mov r0, r5\n    ldmfd sp!, {r4 - r6, r9, pc}\nENDPROC(lookup_processor_type)\n__lookup_processor_type:\n    adr r3, __lookup_processor_type_data\n    ldmia r3, {r4 - r6}\n    sub r3, r3, r4             @ get offset between virt&phys\n    add r5, r5, r3             @ convert virt addresses to\n    add r6, r6, r3             @ physical address space\n1:  ldmia r5, {r3, r4}         @ value, mask\n    and r4, r4, r9             @ mask wanted bits\n    teq r3, r4\n    beq 2f\n    add r5, r5, #PROC_INFO_SZ  @ sizeof(proc_info_list)\n    cmp r5, r6\n    blo 1b\n    mov r5, #0                 @ unknown processor\n2:  mov pc, lr\nENDPROC(__lookup_processor_type)\n```\n\n\n\n__lookup_processor_type的注释解释了代码意图: 从CP15读取处理器id并从链接时建立的数组中查找.\n由于此时未开启MMU因此无法使用绝对地址索引proc_info, 需根据偏移来计算.\nlookup_processor_type首先将cpuid保存在r9, 然后获取程序装载地址的偏移.\n__lookup_processor_type_data是数据段对象, 其包含两个数据__proc_info_begin与__proc_info_end.\n通过arch/arm/kernel/vmlinux.lds.S可以得知该地址区间保存.proc.info.init数据.\nr3是编译时的程序地址, r4是运行时的实际地址.\nr3与r4相减即无MMU时程序加载地址相对程序文件地址的偏移.\nr5与r6分别为__lookup_processor_type_data数据段的起始地址与结束地址.\n将r5地址前两个成员(cpu_val与cpu_mask)保存在r3与r4, 将其与cpuid比较, 如果符合则跳出循环.\n如果不符合则取r5下一个元素地址与r6比较, 溢出说明数组越界r5设为0, 否则重复上一步比较.\n\n在分析了processor的初始化后, 我们再来看下.proc.info.init数组是如何定义的.\n此处代码与架构强相关, 每个芯片都有差异, 仅以基于ARMv7架构为例:\n\n\n\n```assembly\n.macro __v7_proc initfunc, mm_mmuflags = 0, io_mmuflags = 0, hwcaps = 0, proc_fns = v7_processor_functions\n    ALT_SMP(.long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \\\n        PMD_SECT_AF | PMD_FLAGS_SMP | \\mm_mmuflags)\n    ALT_UP(.long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \\\n        PMD_SECT_AF | PMD_FLAGS_UP | \\mm_mmuflags)\n    .long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | \\\n        PMD_SECT_AP_READ | PMD_SECT_AF | \\io_mmuflags\n    W(b) \\initfunc\n    .long cpu_arch_nam\n    .long cpu_elf_name\n    .long HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \\\n        HWCAP_EDSP | HWCAP_TLS | \\hwcaps\n    .long cpu_v7_name\n    .long \\proc_fns\n    .long v7wbi_tlb_fns\n    .long v6_user_fns\n    .long v7_cache_fns\n.endm\n```\n\n\n\n \n\n宏__v7_proc(defined in arch/arm/mm/proc-v7.S)作用是生成一个struct proc_info_list实例.\n在arch/arm/mm/proc-v7.S中有多个用该宏定义的实例, 这些实例都放在.proc.info.init段中.\n每个实例对应一类芯片, __v7_proc_info是大部分ARMv7处理器对应的struct proc_info_list的实例.\n__v7_proc_info的processor成员是v7_processor_functions, 再来看看该成员.\n直接搜索该名字找不到定义的, 因为它是通过宏定义的生成的(烦不烦- -!).\n\n\n\n```assembly\n.macro define_processor_functions name:req, dabort:req, pabort:req, nommu=0, suspend=0\n    .type \\name\\()_processor_functions, #object\n    .align 2\nENTRY(\\name\\()_processor_functions)\n    .word \\dabort\n    .word \\pabort\n    .word cpu_\\name\\()_proc_init\n    .word cpu_\\name\\()_proc_fin\n    .word cpu_\\name\\()_reset\n    .word cpu_\\name\\()_do_idle\n    .word cpu_\\name\\()_dcache_clean_area\n    .word cpu_\\name\\()_switch_mm\n    .if \\nommu\n    .word 0\n    .else\n    .word cpu_\\name\\()_set_pte_ext\n    .endif\n    .if \\suspend\n    .word cpu_\\name\\()_suspend_size\n#ifdef CONFIG_PM_SLEEP\n    .word cpu_\\name\\()_do_suspend\n    .word cpu_\\name\\()_do_resume\n#else\n    .word 0\n    .word 0\n#endif\n    .else\n    .word 0\n    .word 0\n    .word 0\n    .endif\n    .size \\name\\()_processor_functions, . - \\name\\()_processor_functions\n.endm\ndefine_processor_functions v7, dabort=v7_early_abort, pabort=v7_pabort, suspend=1\n```\n\n\n\n \n\n宏define_processor_functions(defined in arch/arm/mm/proc-macro.S).\n该宏作用是生成一个struct processor实例, 联系对该宏的调用终于可以摸索出我们想要的回调了.\n在lookup_processor_type返回后r0保存着proc_info_list地址, 对ARMv7架构而言.\n返回的proc_info_list为__v7_proc_info(defined in arch/arm/mm/proc-v7.S).\n其processor成员为v7_processor_functions, 它是由宏展开的, 其_data_abort成员为v7_early_abort.\n\n再来看v7_early_abort(defined in arch/arm/mm/abort-ev7.S):\n\n\n\n```assembly\nENTRY(v7_early_abort)\n    /*\n     * The effect of data aborts on on the exclusive access monitor are\n     * UNPREDICTABLE. Do a CLREX to clear the state\n     */\n    clrex\n    mrc p15, 0, r1, c5, c0, 0         @ get FSR\n    mrc p15, 0, r0, c6, c0, 0         @ get FAR\n    /*\n     * V6 code adjusts the returned DFSR.\n     * New designs should not need to patch up faults.\n     */\n#if defined(CONFIG_VERIFY_PERMISSION_FAULT)\n    /*\n     * Detect erroneous permission failures and fix\n     */\n    ldr r3, =0x40d               @ On permission fault\n    and r3, r1, r3\n    cmp r3, #0x0d\n    bne do_DataAbort\n    mcr p15, 0, r0, c7, c8, 0    @ Retranslate FAR\n    isb\n    mrc p15, 0, ip, c7, c4, 0    @ Read the PAR\n    and r3, ip, #0x7b            @ On translation fault\n    cmp r3, #0x0b\n    bne do_DataAbort\n    bic r1, r1, #0xf             @ Fix up FSR FS[5:0]\n    and ip, ip, #0x7e\n    orr r1, r1, ip, LSR #1\n#endif\n    b do_DataAbort\nENDPROC(v7_early_abort)\n```\n\n\n\n \n\nv7_early_abort很简单, 先对FSR与FAR的处理(reference manual B3-18), 然后调用do_DataAbort.\n使用r0保存FAR(fault address register), 使用r1保存FSR(fault status register), 后面会用到.\n\n\n\n```c\nasmlinkage void __exception\ndo_DataAbort(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n{\n    const struct fsr_info *inf = fsr_info + fsr_fs(fsr);\n    struct siginfo info;\n    if (!inf->fn(addr, fsr & ~FSR_LNX_PF, regs))\n        return;\n    printk(KERN_ALERT \"Unhandled fault: %s (0x%03x) at 0x%08lx\\n\",\n        inf->name, fsr, addr);\n    info.si_signo = inf->sig;\n    info.si_errno = 0;\n    info.si_code  = inf->code;\n    info.si_addr  = (void __user *)addr;\n    arm_notify_die(\"\", regs, &info, fsr, 0);\n}\nstruct fsr_info {\n    int (*fn)(unsigned long addr, unsigned int fsr, struct pt_regs *regs);\n    int sig;\n    int code;\n    const char *name;\n};\n/* FSR definition */\n#ifdef CONFIG_ARM_LPAE\n#include \"fsr-3level.c\"\n#else\n#include \"fsr-2level.c\"\n#endif\n```\n\n\n\n \n\ndo_DataAbort也很简单, 调用fsr_info数组某个元素的回调, 返回后根据结果向进程发送信号.\n由于未开启ARM_LPAE(ARM large page support), 此处使用fsr-2level.c的数组(太大了不拷贝).\n.\n以page fault为例, 调用do_page_fault, 当找不到页表时会调用__do_user_fault向用户进程发送信号.\n回到__dabt_usr, 在abort handler返回后调用ret_from_exception退出异常.\n\n\n\n```assembly\nENTRY(ret_from_exception)\n    UNWIND(.fnstart)\n    UNWIND(.cantunwind)\n    get_thread_info tsk\n    mov why, #0\n    b ret_to_user\n    UNWIND(.fnend)\nENDPROC(__pabt_usr)\nENDPROC(ret_from_exception)\nENTRY(ret_to_user)\nret_slow_syscall:\n    disable_irq                   @ disable interrupts\nENTRY(ret_to_user_from_irq)\n    ldr r1, [tsk, #TI_FLAGS]\n    tst r1, #_TIF_WORK_MASK\n    bne work_pending\n    no_work_pending:\n    asm_trace_hardirqs_on\n    /* perform architecture specific actions before user return */\n    arch_ret_to_user r1, lr\n    ct_user_enter save = 0\n    restore_user_regs fast = 0, offset = 0\nENDPROC(ret_to_user_from_irq)\nENDPROC(ret_to_user)\n```\n\n\n\n \n\nret_to_user首先会关中断, 检查thread_info->flags.\n如发现需要调度的标记执行work_pending(defined in arch/arm/kernel/entry-common.S).\n\n\n\n```assembly\nwork_pending:\n    mov r0, sp    @ 'regs'\n    mov r2, why    @ 'syscall'\n    bl do_work_pending\n    cmp r0, #0\n    beq no_work_pending\n    movlt scno, #(__NR_restart_syscall - __NR_SYSCALL_BASE)\n    ldmia sp, {r0 - r6}   @ have to reload r0 - r6\n    b local_restart   @ ... and off we go\n```\n\n\n\n \n\ndo_work_pending(defined in arch/arm/kernel/signal.c)的作用是判断是否需要调度或信号处理:\n\n\n\n```c\nasmlinkage int do_work_pending(struct pt_regs *regs, \\\n    unsigned int thread_flags, int syscall);\n{\n    do {\n        /**\n         * ret_to_user_from_irq中已将r1赋值为thread_info->flags, 即此处thread_flags\n         * 同样regs值为态sp, syscall值为why\n         * thread_flags可能有多个位置位, 按顺序依次处理\n         *\n        **/\n        if (likely(thread_flags & _TIF_NEED_RESCHED)) {\n            schedule();\n        } else {\n            /**\n             * 如果CPSR模式位不在用户态, 即之前程序就工作在内核态\n             * 被高优先级的任务抢占(比如系统调用时被中断打断)\n             * 那么此时直接返回继续之前任务\n             *\n            **/\n            if (unlikely(!user_mode(regs)))\n                return 0;\n            local_irq_enable();\n            /**\n             * 判断是否有信号挂起\n             * 该标记位在signal_wake_up_state与recalc_sigpending_tsk设置\n             *\n            **/\n            if (thread_flags & _TIF_SIGPENDING) {\n                //do_signal(defined in arch/arm/kernel/signal.c)定义见下\n                int restart = do_signal(regs, syscall);\n                if (unlikely(restart)) {\n                    //处理失败直接返回, 不调用回调\n                    return restart;\n                }\n                syscall = 0;\n            } else {\n                clear_thread_flag(TIF_NOTIFY_RESUME);\n                tracehook_notify_resume(regs);\n            }\n        }\n        local_irq_disable();\n        thread_flags = current_thread_info()->flags;\n    } while (thread_flags & _TIF_WORK_MASK);\n    return 0;\n}\n```\n\n \n\ndo_signal作用是处理挂起信号, 保存内核寄存器状态, 为内核执行用户态回调做准备.\n保存数据的原因: 内核态与用户态共用一套寄存器.\n当用户回调返回时内核寄存器状态已被破坏, 因此需要在用户态保存内核寄存器状态.\n\n```c\nstatic int do_signal(struct pt_regs *regs, int syscall)\n{\n    ......\n    /**\n     * 实际调用get_signal_to_deliver(defined in kernel/signal.c)\n     * get_signal_to_deliver中调用dequeue_signal先从task_struct->pending获取信号\n     * 获取失败再从task_struct->signal->shared_pending获取信号\n     * 还有很多判断, 先忽略\n     *\n    **/\n    if (get_signal(&ksig)) {\n        /**\n         * 在执行信号回调句柄前准备工作, 在用户态栈保存内核数据\n         * handle_signal实际调用setup_frame或setup_rt_frame(如果为rt信号)\n         * 以setup_frame为例:\n         * 1. 首先调用get_sigframe获取用户态栈地址, 对齐并确认可写\n         *    注意sigframe结构体的排布, 在用户态获取lr时会用到该结构\n         * 2. 设置uc.uc_flags为0x5a3c3c5a\n         * 3. 调用setup_sigframe填充sigframe结构\n         * 4. 调用setup_return设置回调接口返回(设置pt_regs)\n         *    注意此时pt_regs仍在栈上:\n         *    pt_regs->pc设置为信号回调句柄\n         *    pt_regs->r0设置为signo\n         *    pt_regs->lr被修改为retcode\n         *    pt_regs->sp被修改为frame(frame是结构体起始地址, 与栈方向相反, 所以是栈底!)\n         * 在栈帧建立后调用signal_setup_done恢复阻塞的信号\n         *\n        **/\n        handle_signal(&ksig, regs);\n    }\n    ......\n}\n```\n\n\n\n \n\n回到work_pending, 当do_work_pending返回时会检查函数返回值(r0).\n如果返回成功则跳转到no_work_pending标签, 此时开始准备进入用户态.\n其中arch_ret_to_user宏是架构相关宏, ARM上无定义; ct_user_enter是跟踪上下文宏, 忽略.\n重点在restore_user_regs(defined in arch/arm/kernel/entry-header.S).\n\n\n\n```assembly\n.macro restore_user_regs, fast = 0, offset = 0\n    clrex                                  @ clear the exclusive monitor\n    mov r2, sp\n    load_user_sp_lr r2, r3, \\offset + S_SP @ calling sp, lr\n    ldr r1, [sp, #\\offset + S_PSR]         @ get calling cpsr\n    ldr lr, [sp, #\\offset + S_PC]          @ get pc\n    add sp, sp, #\\offset + S_SP\n    msr spsr_cxsf, r1                      @ save in spsr_svc\n    .if \\fast\n    ldmdb sp, {r1 - r12}                   @ get calling r1 - r12\n    .else\n    ldmdb sp, {r0 - r12}                   @ get calling r0 - r12\n    .endif\n    add sp, sp, #S_FRAME_SIZE - S_SP\n    movs pc, lr                            @ return & move spsr_svc into cpsr\n.endm\n.macro load_user_sp_lr, rd, rtemp, offset = 0\n    mrs \\rtemp, cpsr\n    eor \\rtemp, \\rtemp, #(SVC_MODE ^ SYSTEM_MODE)\n    msr cpsr_c, \\rtemp                     @ switch to the SYS mode\n    ldr sp, [\\rd, #\\offset]                @ load sp_usr\n    ldr lr, [\\rd, #\\offset + 4]            @ load lr_usr\n    eor \\rtemp, \\rtemp, #(SVC_MODE ^ SYSTEM_MODE)\n    msr cpsr_c, \\rtemp                     @ switch back to the SVC mode\n.endm\n```\n\n\n\n \n\nclrex用于清除本地cpu独占访问某块内存区域的标记.\nS_SP定义见arch/arm/kernel/asm-offsets.c, 是ARM_sp在pt_regs的偏移.\n对sp与lr的保存需额外切换到系统模式后处理, 是因为SVC模式下使用sp_svc与lr_svc.\n而系统模式与用户模式使用同一套寄存器, 仅权限不同.\n再根据是否为fast_path恢复用户寄存器, 同时恢复sp(此处sp为SVC模式的sp).\n最后将lr拷贝给pc, 此指令会自动恢复cpsr, 不要问我为什么reference manual就是这么写的.\n至此开始用户子程的执行.\n\n## 用户进程回溯堆栈\n\n回到第一部分, 如何在信号回调中回溯堆栈? 回顾之前的流程, 当用户进程访问非法地址时立即触发异常, 程序跳转到异常向量, 处理器模式进入异常模式使用异常模式下sp与lr, 当执行完异常处理后cpu恢复到特权模式处理, 此时使用特权模式下sp与lr, 为保证程序在执行完信号回调后能正常恢复特权模式现场, 需要在用户态保存现场, 即do_signal中的sigframe(在用户态即信号回调的参数3), 回到用户态进程还需要入栈一个siginfo结构, 因此用户进程栈结构为:\n栈顶\n...\n异常发生时栈地址\nsigframe\nsiginfo\n信号回调地址\n通过sigframe我们可以获取异常发生时寄存器列表, 即获取异常时sp, pc, lr, 进一步回溯整个堆栈.","tags":["Android","signal"],"categories":["Android","稳定性"]},{"title":"jemalloc调研","url":"/2020/07/19/稳定性/jemalloc调研/","content":"\njemalloc中提供的malloc函数叫做`je_malloc`, 释放的函数是`je_free`.\n\n## jemalloc基础知识\n\n### size_class\n\n每个 `size_class` 代表 jemalloc 分配的内存大小，共有 NSIZES（232）?个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：\n\n- `small_class`（*小内存*） : 对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, ..., 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂，比如如果没有48字节，那当申请33字节时，分配64字节显然会造成约50%的外部碎片\n- `large_class`（*大内存*）: 对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, ..., 1mb, 2mb, 4mb等\n- `size_index` : size 位于 `size_class` 中的索引号，区间为 [0，231]?，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当 size 是 `small_class` 时，`size_index` 也称作 `binind`\n\n### base\n\n```c\nstruct base_s {\n\t/* Associated arena's index within the arenas array. */\n\tunsigned\tind;\n\t/* User-configurable extent hook functions.  Points to an extent_hooks_t. */  extent分配回收等相关的函数指针\n\tatomic_p_t\textent_hooks;\n    \n\t/* Protects base_alloc() and base_stats_get() operations. */\n\tmalloc_mutex_t\tmtx;\n\n\t/* Using THP when true (metadata_thp auto mode). */\n\tbool\t\tauto_thp_switched;\n\t/*\n\t * Most recent size class in the series of increasingly large base\n\t * extents.  Logarithmic spacing between subsequent allocations ensures\n\t * that the total number of distinct mappings remains small.\n\t */\n\tpszind_t\tpind_last;\n\n\t/* Serial number generation state. */   下一个extent的sn号\n\tsize_t\t\textent_sn_next;\n\n\t/* Chain of all blocks associated with base. */ blocks链表\n\tbase_block_t\t*blocks;\n\n\t/* Heap of extents that track unused trailing space within blocks. */ extent堆的root节点[NSIZES]\n\textent_heap_t\tavail[NSIZES];\n\n\t/* Stats, only maintained if config_stats. */  统计信息相关\n\tsize_t\t\tallocated;\n\tsize_t\t\tresident;\n\tsize_t\t\tmapped;\n};\n\n/* Embedded at the beginning of every block of base-managed virtual memory. */\nstruct base_block_s base_block_t {\n\t/* Total size of block's virtual memory mapping. */ \n\tsize_t\t\tsize;\n\n\t/* Next block in list of base's blocks. */\n\tbase_block_t\t*next;\n\n\t/* Tracks unused trailing space. */  保存extent的元数据信息\n\textent_t\textent;\n};\n```\n\n用于分配 jemalloc `元数据内存`的结构\n\n- `base.blocks.extent` : 存放每个 `size_class` 的 `extent` 元数据\n- base.blocks是一个链表, 通过其next可以找到当前`ind`维护的所有的extent元数据信息\n\n### bin\n\n```c\ntypedef struct bin_s bin_t;\nstruct bin_s {\n\t/* All operations on bin_t fields require lock ownership. */\n\tmalloc_mutex_t\t\tlock;\n\t/*\n\t * Current slab being used to service allocations of this bin's size\n\t * class.  slabcur is independent of slabs_{nonfull,full}; whenever\n\t * slabcur is reassigned, the previous slab must be deallocated or\n\t * inserted into slabs_{nonfull,full}.\n\t */\n\textent_t\t\t*slabcur;\n\n\t/*\n\t * Heap of non-full slabs.  This heap is used to assure that new\n\t * allocations come from the non-full slab that is oldest/lowest in\n\t * memory.\n\t */\n\textent_heap_t\t\tslabs_nonfull;\n\n\t/* List used to track full slabs. */\n\textent_list_t\t\tslabs_full;\n\n\t/* Bin statistics. */\n\tbin_stats_t\tstats;\n};\n```\n\n管理正在使用中的 `slab`（即用于小内存分配的 `extent`） 的集合，每个 `bin` 对应一个 `size_class`\n\n- `bin.slabcur` : 当前使用中的 `slab`\n- `bin.slabs_nonfull` : 有空闲内存块的 `slab`\n\n### bin_infos[binind]\n\n```c\ntypedef struct bin_info_s bin_info_t;\nstruct bin_info_s {\n\t/* Size of regions in a slab for this bin's size class. */   region占了多少内存\n\tsize_t\t\t\treg_size;\n\t/* Total size of a slab for this bin's size class. */        slab 即 extent占了多少内存\n\tsize_t\t\t\tslab_size;\n\t/* Total number of regions in a slab for this bin's size class. */  一个slab内有多少个 region\n\tuint32_t\t\tnregs;\n/* Metadata used to manipulate bitmaps for slabs associated with this bin. */ 和extent->e_slab_data的bitmap信息配合, 查看region的使用情况\n\tbitmap_info_t\t\tbitmap_info;\n};\n```\n\n```c\ntypedef struct bitmap_info_s {\n\t/* Logical number of bits in bitmap (stored at bottom level). */\n\tsize_t nbits;\n#ifdef BITMAP_USE_TREE\n\t/* Number of levels necessary for nbits. */\n\tunsigned nlevels;\n\t/*\n\t * Only the first (nlevels+1) elements are used, and levels are ordered\n\t * bottom to top (e.g. the bottom level is stored in levels[0]).\n\t */\n\tbitmap_level_t levels[BITMAP_MAX_LEVELS+1];\n#else /* BITMAP_USE_TREE */\n\t/* Number of groups necessary for nbits. */\n\tsize_t ngroups;\n#endif /* BITMAP_USE_TREE */\n} bitmap_info_t;\n```\n\n管理相同`binind` 的所有bin的信息,  注意不是维护bin的链表, 只是存bin所属的相关`sizeclass`的相关信息,  从`bitmap_info`中获取regions组的信息(在使用TREE的情况下,  获取TREE深度信息)\n\n### extent\n\n 管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是 `N * page_size(4kb)`（N >= 1）。每个 extent 有一个序列号（serial number）。\n\n一个 `extent` 可以用来分配一次 `large_class` 的内存申请，但可以用来分配`多次 small_class` 的内存申请。\n\n- `extent.e_bits` : 8字节长，记录`多种信息`\n- `extent.e_addr` : 管理的内存块的起始地址\n- `extent.e_slab_data` : 位图bitmap，当此 `extent` 用于分配 `small_class` 内存时，用来记录这个 `extent` 的分配情况，此时每个 `extent` 内的小内存称为 `region`, 和bin_infos中的bitmap_info 配合使用,  每个region是否被使用占一个bit, 一个bitmap在64位上可以管理64个region. 查使用遍历每个bitmap, 64位上没有使用TREE结构, 即查看bitmap内从右边开始第一个非0的bit位,  在该bit位前的一个位置(未使用的), 是可以使用的region. \n\n### slab\n\n当 extent 用于分配 `small_class` 内存时，称其为 `slab`。一个 `extent` 可以被用来处理多个同一 `size_class` 的内存申请。\n\n### extents\n\n管理 `extent` 的集合。\n\n- `extents.heaps[NPSIZES+1]` : 各种 `page(4kb)` 倍数大小的 `extent`\n- `extents.lru` : 存放所有 `extent` 的双向链表\n- `extents.delay_coalesce` : 是否延迟 `extent` 的合并\n\n### arena\n\n```c\nstruct arena_s {\n\t/*\n\t *   0: Application allocation.\n\t *   1: Internal metadata allocation.\t *\n\t * Synchronization: atomic.\n\t */\n\tatomic_u_t\t\tnthreads[2];\n\n\t/*\n\t * When percpu_arena is enabled, to amortize the cost of reading /\n\t * updating the current CPU id, track the most recent thread accessing\n\t * this arena, and only read CPU if there is a mismatch.\n\t */\n\ttsdn_t\t\t*last_thd;\n\n\t/* Synchronization: internal. */\n\tarena_stats_t\t\tstats;\n\n\t/*\n\t * Lists of tcaches and cache_bin_array_descriptors for extant threads\n\t * associated with this arena.  Stats from these are merged\n\t * incrementally, and at exit if opt_stats_print is enabled.\n\t *\n\t * Synchronization: tcache_ql_mtx.\n\t */\n\tql_head(tcache_t)\t\t\ttcache_ql;\n\tql_head(cache_bin_array_descriptor_t)\tcache_bin_array_descriptor_ql;\n\tmalloc_mutex_t\t\t\t\ttcache_ql_mtx;\n\n\t/* Synchronization: internal. */\n\tprof_accum_t\t\tprof_accum;\n\tuint64_t\t\tprof_accumbytes;\n\n\t/*\n\t * Extent serial number generator state.\n\t *\n\t * Synchronization: atomic.\n\t */\n\tatomic_zu_t\t\textent_sn_next;\n\n\t/*\n\t * Extant large allocations.\n\t *\n\t * Synchronization: large_mtx.\n\t */\n\textent_list_t\t\tlarge;\n\t/* Synchronizes all large allocation/update/deallocation. */\n\tmalloc_mutex_t\t\tlarge_mtx;\n\n\t/*\n\t * Collections of extents that were previously allocated.  These are\n\t * used when allocating extents, in an attempt to re-use address space.\n\t *\n\t * Synchronization: internal.\n\t */\n\textents_t\t\textents_dirty;\n\textents_t\t\textents_muzzy;\n\textents_t\t\textents_retained;\n\n\t/*\n\t * Decay-based purging state, responsible for scheduling extent state\n\t * transitions.\n\t *\n\t * Synchronization: internal.\n\t */\n\tarena_decay_t\t\tdecay_dirty; /* dirty --> muzzy */\n\tarena_decay_t\t\tdecay_muzzy; /* muzzy --> retained */\n\n\t/*\n\t * Next extent size class in a growing series to use when satisfying a\n\t * request via the extent hooks (only if opt_retain).  This limits the\n\t * number of disjoint virtual memory ranges so that extent merging can\n\t * be effective even if multiple arenas' extent allocation requests are\n\t * highly interleaved.\n\t *\n\t * retain_grow_limit is the max allowed size ind to expand (unless the\n\t * required size is greater).  Default is no limit, and controlled\n\t * through mallctl only.\n\t *\n\t * Synchronization: extent_grow_mtx\n\t */\n\tpszind_t\t\textent_grow_next;\n\tpszind_t\t\tretain_grow_limit;\n\tmalloc_mutex_t\t\textent_grow_mtx;\n\n\t/*\n\t * Available extent structures that were allocated via\n\t * base_alloc_extent().\n\t */\n\textent_tree_t\t\textent_avail;\n\tmalloc_mutex_t\t\textent_avail_mtx;\n\n\t/*\n\t * bins is used to store heaps of free regions.\n\t * Synchronization: internal.\n\t */\n\tbin_t\t\t\tbins[NBINS];\n\n\t/*\n\t * Base allocator, from which arena metadata are allocated.\n\t */\n\tbase_t\t\t\t*base;\n\t/* Used to determine uptime.  Read-only after initialization. */\n\tnstime_t\t\tcreate_time;\n};\n```\n\n挂到arenas[ind]下,  struct arena_s\n\n用于分配&回收 `extent` 的结构，每个用户线程会被绑定到一个 `arena` 上，默认每个逻辑 CPU 会有 4 个 `arena` 来减少锁的竞争，各个 arena 所管理的内存相互独立。\n\n- `arena.extents_dirty` : 刚被释放后空闲 `extent` 位于的地方\n- `arena.extents_muzzy` : `extents_dirty` 进行 lazy purge 后位于的地方，`dirty -> muzzy`\n- `arena.extents_retained` : `extents_muzzy` 进行 decommit 或 force purge 后 `extent` 位于的地方，`muzzy -> retained`\n- `arena.large` : 存放 `large extent` 的 `extents`\n- `arena.extent_avail` : heap，存放可用的 `extent` 元数据\n- `arena.bins[NBINS]` : 所以用于分配小内存的 `bin`\n- `arena.base` : 用于分配元数据的 `base`, base中有base_blocks管理所有当前ind的blocks链表, 而arena由areans[ind] 管理\n\n![img](images/20201130111643.jpg)\n\n### rtree\n\n```c\ntypedef struct rtree_ctx_s rtree_ctx_t;\nstruct rtree_ctx_s {\n\t/* Direct mapped cache. */\n\trtree_ctx_cache_elm_t\tcache[RTREE_CTX_NCACHE];\n\t/* L2 LRU cache. */\n\trtree_ctx_cache_elm_t\tl2_cache[RTREE_CTX_NCACHE_L2];\n};\ntypedef struct rtree_ctx_cache_elm_s rtree_ctx_cache_elm_t;\nstruct rtree_ctx_cache_elm_s {\n\tuintptr_t\t\t leafkey;\n\trtree_leaf_elm_t\t*leaf;\n};\n\nstruct rtree_s {\n\tmalloc_mutex_t\t\tinit_lock;\n\trtree_leaf_elm_t\troot[1U << (RTREE_NSB/RTREE_HEIGHT)];\n};\nRTREE_HEIGHT = 2\nstatic const rtree_level_t rtree_levels[] = {\n#elif RTREE_HEIGHT == 2\n\t{RTREE_NSB/2, RTREE_NHIB + RTREE_NSB/2},                // {18, 34}\n\t{RTREE_NSB/2 + RTREE_NSB%2, RTREE_NHIB + RTREE_NSB}     // {18, 52}\n}\n// leafkey 即是取 后34 位 注意leafkey 与 全局tree的遍历无关, 不要与rtree_subkey弄混了\nJEMALLOC_ALWAYS_INLINE uintptr_t\nrtree_leafkey(uintptr_t key) {\n\tunsigned ptrbits = ZU(1) << (3+3) = 64;\n\tunsigned cumbits = (rtree_levels[1].cumbits -\n\t    rtree_levels[1].bits);\n\tunsigned maskbits = 64 - (48-18) = 34;\n\tuintptr_t mask = ~((ZU(1) << maskbits) - 1) = 1 << 34 - 1 ;\n\treturn (key & mask);  (key & 1 << 34 - 1);\n}\n\n\n// 这里tree的深度是2 level只能等于0 或 1, 在确定root数组长度时, level = 0\n-->\tif (RTREE_HEIGHT > 1) {\n\t\tRTREE_GET_CHILD(0)\n    }\n\n// subkey 即是取 中间的18位[30-47]\nJEMALLOC_ALWAYS_INLINE uintptr_t\nrtree_subkey(uintptr_t key, unsigned level) {\n\tunsigned ptrbits = ZU(1) << (LG_SIZEOF_PTR+3) = 64;\n\tunsigned cumbits = rtree_levels[level].cumbits = 34;\n\tunsigned shiftbits = ptrbits - cumbits = 30;\n\tunsigned maskbits = rtree_levels[level].bits = 18;\n\tuintptr_t mask = (ZU(1) << maskbits) - 1 = 1 << 18 -1;\n\treturn ((key >> shiftbits) & mask) = (key >> 30) & (1 << 18 -1) ;\n}\n\n// 在确定 root的子节点对应的数组长度时, level = 1\n// subkey 即是取 18位 [12-30]\nJEMALLOC_ALWAYS_INLINE uintptr_t\nrtree_subkey(uintptr_t key, unsigned level) {\n\tunsigned ptrbits = ZU(1) << (LG_SIZEOF_PTR+3) = 64;\n\tunsigned cumbits = rtree_levels[level].cumbits = 52;\n\tunsigned shiftbits = ptrbits - cumbits = 12;\n\tunsigned maskbits = rtree_levels[level].bits = 18;\n\tuintptr_t mask = (ZU(1) << maskbits) - 1 = 1 << 18 -1;\n\treturn ((key >> shiftbits) & mask) = (key >> 12) & (1 << 18 -1) ;\n}\n/\n```\n\n全局唯一的存放每个 `extent` 信息的 Radix Tree，以 **`extent->e_addr`** 即 `uintptr_t` 为 key，如uintptr_t` 为64位（8字节)`, rtree 的高度为2\n\n![jemalloc_tree.drawio](images/20201214115523.svg)\n\n### cache_bin\n\n![img](images/20201203174939.jpg)\n\n```c\ntypedef struct cache_bin_s cache_bin_t;\nstruct cache_bin_s {\n\t/* Min # cached since last GC. */\n\tcache_bin_sz_t low_water;\n\t/* # of cached objects. */\n\tcache_bin_sz_t ncached;\n\t/*\n\t * Stack of available objects.\n\t *\n\t * To make use of adjacent cacheline prefetch, the items in the avail\n\t * stack goes to higher address for newer allocations.  avail points\n\t * just above the available space, which means that\n\t * avail[-ncached, ... -1] are available items and the lowest item will\n\t * be allocated first.\n\t */\n\tvoid **avail;\n};\n```\n\n每个线程独有的用于分配小内存的缓存\n\n- `low_water` : 上一次 gc 后剩余的缓存数量\n- `cache_bin.ncached` : 当前 `cache_bin` 存放的缓存数量\n- `cache_bin.avail` : 可直接用于分配的内存，从左往右依次分配（注意这里的寻址方式）\n\n### tcache\n\n```c\nstruct tcache_s {\n\t/* Drives incremental GC. */\n\tticker_t\tgc_ticker;\n\t/*\n\t * The pointer stacks associated with bins follow as a contiguous array.\n\t * During tcache initialization, the avail pointer in each element of\n\t * tbins is initialized to point to the proper offset within this array.\n\t */\n\tcache_bin_t\tbins_small[NBINS];\n\n\t/*\n\t * This data is less hot; we can be a little less careful with our\n\t * footprint here.\n\t */\n\t/* Lets us track all the tcaches in an arena. */\n\tql_elm(tcache_t) link;\n\t/*\n\t * The descriptor lets the arena find our cache bins without seeing the\n\t * tcache definition.  This enables arenas to aggregate stats across\n\t * tcaches without having a tcache dependency.\n\t */\n\tcache_bin_array_descriptor_t cache_bin_array_descriptor;\n\n\t/* The arena this tcache is associated with. */\n\tarena_t\t\t*arena;\n\t/* Next bin to GC. */\n\tszind_t\t\tnext_gc_bin;\n\t/* For small bins, fill (ncached_max >> lg_fill_div). */\n\tuint8_t\t\tlg_fill_div[NBINS];\n\t/*\n\t * We put the cache bins for large size classes at the end of the\n\t * struct, since some of them might not get used.  This might end up\n\t * letting us avoid touching an extra page if we don't have to.\n\t */\n\tcache_bin_t\tbins_large[NSIZES-NBINS];\n};\n```\n\n每个线程独有的缓存（Thread Cache），大多数内存申请都可以在 `tcache` 中直接得到，从而避免加锁\n\n- `tcache.bins_small[NBINS]` : 小内存的 `cache_bin`\n- `tcache.bins_large[NSIZES - NBINS]`: 大内存的`cache_bin`\n\n### tsd\n\n```c\nstruct tsd_s {\n\ttsd_state_t\tstate;\n    bool ...tcache_enabled;\n    ...\n    rtree_ctx_t ...rtree_ctx;    \n    arena_t* ...arena;\n    tcache_t ...tcache;\n}    \n```\n\nThread Specific Data，每个线程独有，用于存放与这个线程相关的结构\n\n- `tsd.rtree_ctx` : 当前线程的 rtree context，用于快速访问 `extent` 信息\n- `tsd.arena` : 当前线程绑定的 `arena`\n- `tsd.tcache` : 当前线程的 `tcache`\n\n## je初始化及内存申请\n\n进行内存申请时, 需要先进行初始化\n\n### 1.1 初始化参数\n\n```c\n\t--> 1.1 初始化参数\n\tsopts.bump_empty_alloc = true;\n\tsopts.null_out_result_on_error = true;\n\tsopts.set_errno_on_error = true;\n\tsopts.oom_string = \"<jemalloc>: Error in malloc(): out of memory\\n\"; // 申请失败时返回的消息\n\tdynamic_opts->item_size = 0;\n\tdynamic_opts->alignment = 0; // 不对齐\n\tdynamic_opts->zero = false;\n\tdynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;\n\tdynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;\n\tdopts.result = &ret;\n\tdopts.num_items = 1;  // 申请的内存个数\n\tdopts.item_size = size;  // 申请的size\n```\n\n### 1.2 extent默认的处理函数\n\n```c\n--> 1.2 extent默认的处理函数, 没贴的函数就是没打开宏的\n    // eg: extent_hooks->alloc()    \nstruct extent_hooks_s {\n\textent_alloc_t\t\t*alloc;\n\textent_dalloc_t\t\t*dalloc;\n\textent_destroy_t\t*destroy;\n\textent_commit_t\t\t*commit;\n\textent_decommit_t\t*decommit;\n\textent_purge_t\t\t*purge_lazy;  // not supported\n\textent_purge_t\t\t*purge_forced;\n\textent_split_t\t\t*split;\n\textent_merge_t\t\t*merge;\n};\nconst extent_hooks_t\textent_hooks_default = {\n\textent_alloc_default,\n\textent_dalloc_default,\n\textent_destroy_default,\n\textent_commit_default,\n\textent_decommit_default\n\tNULL,\n\textent_purge_forced_default,\n\textent_split_default,\n\textent_merge_default\n};\n```\n\n### 1.3 SIZE_CLASSES定义\n\n```c\n--> 1.3 宏展开\nconst size_t sz_pind2sz_tab[NPSIZES+1] = {\n#define PSZ_yes(lg_grp, ndelta, lg_delta)\t\t\t\t\\\n\t(((ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))),\n#define PSZ_no(lg_grp, ndelta, lg_delta)\n#define SC(index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup) \\\n\tPSZ_##psz(lg_grp, ndelta, lg_delta)\n\tSIZE_CLASSES\n#undef PSZ_yes\n#undef PSZ_no\n#undef SC\n\t(LARGE_MAXCLASS + PAGE)\n};\n// arm64 走的这个分支\n#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)\n#define SIZE_CLASSES \\\n...\n#define SMALL_MAXCLASS\t\t((((size_t)1) << 13) + (((size_t)3) << 11))   //10240\n#endif\n// arm32 走的这个分支\n#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)\n#define SIZE_CLASSES \\\n...\n#define SMALL_MAXCLASS\t\t((((size_t)1) << 13) + (((size_t)3) << 11))\n#endif\n// 不同的配置设置不同的SIZE_CLASSES\n```\n\n### 1.4 arena_boot 展开\n\n```c\nvoid\narena_boot(void) {\n    ...\n#define REGIND_bin_yes(index, reg_size) \t\t\t\t\\\n\tdiv_init(&arena_binind_div_info[(index)], (reg_size));\n#define REGIND_bin_no(index, reg_size)\n#define SC(index, lg_grp, lg_delta, ndelta, psz, bin, pgs,\t\t\\\n    lg_delta_lookup)\t\t\t\t\t\t\t\\\n\tREGIND_bin_##bin(index, (1U<<lg_grp) + (ndelta << lg_delta))\n\tSIZE_CLASSES\n#undef REGIND_bin_yes\n#undef REGIND_bin_no\n#undef SC\n}\n// 粘贴到macro.c 中, \n// gcc -E -P macro.c -o result.c , kate result.c 替换 `; div_init` 为 `; \\n div_init` \nvoid arena_boot(void) {\n    ...\n div_init(&arena_binind_div_info[(0)], ((1U<<3) + (0 << 3))); \n div_init(&arena_binind_div_info[(1)], ((1U<<3) + (1 << 3))); \n div_init(&arena_binind_div_info[(2)], ((1U<<4) + (1 << 4))); \n div_init(&arena_binind_div_info[(3)], ((1U<<4) + (2 << 4))); \n div_init(&arena_binind_div_info[(4)], ((1U<<4) + (3 << 4))); \n div_init(&arena_binind_div_info[(5)], ((1U<<6) + (1 << 4))); \n div_init(&arena_binind_div_info[(6)], ((1U<<6) + (2 << 4))); \n div_init(&arena_binind_div_info[(7)], ((1U<<6) + (3 << 4))); \n div_init(&arena_binind_div_info[(8)], ((1U<<6) + (4 << 4))); \n div_init(&arena_binind_div_info[(9)], ((1U<<7) + (1 << 5))); \n div_init(&arena_binind_div_info[(10)], ((1U<<7) + (2 << 5))); \n div_init(&arena_binind_div_info[(11)], ((1U<<7) + (3 << 5))); \n div_init(&arena_binind_div_info[(12)], ((1U<<7) + (4 << 5))); \n div_init(&arena_binind_div_info[(13)], ((1U<<8) + (1 << 6))); \n div_init(&arena_binind_div_info[(14)], ((1U<<8) + (2 << 6))); \n div_init(&arena_binind_div_info[(15)], ((1U<<8) + (3 << 6))); \n div_init(&arena_binind_div_info[(16)], ((1U<<8) + (4 << 6))); \n div_init(&arena_binind_div_info[(17)], ((1U<<9) + (1 << 7))); \n div_init(&arena_binind_div_info[(18)], ((1U<<9) + (2 << 7))); \n div_init(&arena_binind_div_info[(19)], ((1U<<9) + (3 << 7))); \n div_init(&arena_binind_div_info[(20)], ((1U<<9) + (4 << 7))); \n div_init(&arena_binind_div_info[(21)], ((1U<<10) + (1 << 8))); \n div_init(&arena_binind_div_info[(22)], ((1U<<10) + (2 << 8))); \n div_init(&arena_binind_div_info[(23)], ((1U<<10) + (3 << 8))); \n div_init(&arena_binind_div_info[(24)], ((1U<<10) + (4 << 8))); \n div_init(&arena_binind_div_info[(25)], ((1U<<11) + (1 << 9))); \n div_init(&arena_binind_div_info[(26)], ((1U<<11) + (2 << 9))); \n div_init(&arena_binind_div_info[(27)], ((1U<<11) + (3 << 9))); \n div_init(&arena_binind_div_info[(28)], ((1U<<11) + (4 << 9))); \n div_init(&arena_binind_div_info[(29)], ((1U<<12) + (1 << 10))); \n div_init(&arena_binind_div_info[(30)], ((1U<<12) + (2 << 10))); \n div_init(&arena_binind_div_info[(31)], ((1U<<12) + (3 << 10))); \n div_init(&arena_binind_div_info[(32)], ((1U<<12) + (4 << 10))); \n div_init(&arena_binind_div_info[(33)], ((1U<<13) + (1 << 11))); \n div_init(&arena_binind_div_info[(34)], ((1U<<13) + (2 << 11))); \n div_init(&arena_binind_div_info[(35)], ((1U<<13) + (3 << 11)));\n}\n```\n\n### 1.5 高级宏展开\n\n####  `MALLOC_TSD` tsds 结构体\n\n```c\n/*  O(name,\t\t\ttype,\t\t\tnullable type */\n#define MALLOC_TSD\t\t\t\t\t\t\t\\\n    O(tcache_enabled,\t\tbool,\t\t\tbool)\t\t\\\n    O(arenas_tdata_bypass,\tbool,\t\t\tbool)\t\t\\\n    O(reentrancy_level,\t\tint8_t,\t\t\tint8_t)\t\t\\\n    O(narenas_tdata,\t\tuint32_t,\t\tuint32_t)\t\\\n    O(offset_state,\t\tuint64_t,\t\tuint64_t)\t\\\n    O(thread_allocated,\t\tuint64_t,\t\tuint64_t)\t\\\n    O(thread_deallocated,\tuint64_t,\t\tuint64_t)\t\\\n    O(prof_tdata,\t\tprof_tdata_t *,\t\tprof_tdata_t *)\t\\\n    O(rtree_ctx,\t\trtree_ctx_t,\t\trtree_ctx_t)\t\\\n    O(iarena,\t\t\tarena_t *,\t\tarena_t *)\t\\\n    O(arena,\t\t\tarena_t *,\t\tarena_t *)\t\\\n    O(arenas_tdata,\t\tarena_tdata_t *,\tarena_tdata_t *)\\\n    O(tcache,\t\t\ttcache_t,\t\ttcache_t)\t\\\n    O(witness_tsd,              witness_tsd_t,\t\twitness_tsdn_t)\t\\\n    MALLOC_[[存储相关/[[存储相关/test|test]]|TEST]]_TSD\n\n#define O(n, t, nt)\t\t\t\t\t\t\t\\\nJEMALLOC_ALWAYS_INLINE t *\t\t\t\t\t\t\\\ntsd_##n##p_get_unsafe(tsd_t *tsd) {\t\t\t\t\t\\\n\treturn &tsd->use_a_getter_or_setter_instead_##n;\t\t\\\n}\nMALLOC_TSD\n#undef O\n// 需要带入 n, t, nt , 根据MALLOC_TSD表确定类型 , 在n是 tcache时, t为tcache_t, nt为tcache_t\n// 解释后为\ntcache_t* tsd_tcachep_get_unsafe(tsd_t *tsd) {\t\t\t\t\t\\\n\treturn &tsd->use_a_getter_or_setter_instead_tcache;\t\t\\\n}\nstruct tsd_s {\n\t/*\n\t * The contents should be treated as totally opaque outside the tsd\n\t * module.  Access any thread-local state through the getters and\n\t * setters below.\n\t */\n\ttsd_state_t\tstate;\n#define O(n, t, nt)\t\t\t\t\t\t\t\\\n\tt use_a_getter_or_setter_instead_##n;\nMALLOC_TSD\n#undef O\n    // 展开为 \n    tcache_t use_a_getter_or_setter_instead_cache;\n    ... //省略其他成员, 实际上会将MALLOC_TSD表中的所有字段全部展开, 成员为MALLOC_TSD的所有字段\n};\n```\n\n#### 相关的函数\n\n```c\nrb_proto(, extent_avail_, extent_tree_t, extent_t)\n#define rb_proto(a_attr, a_prefix, a_rbt_type, a_type)\t\t\t\\\na_attr void\t\t\t\t\t\t\t\t\\\na_prefix##new(a_rbt_type *rbtree);\t\t\t\t\t\\\na_attr bool\t\t\t\t\t\t\t\t\\\na_prefix##empty(a_rbt_type *rbtree);\t\t\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##first(a_rbt_type *rbtree);\t\t\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##last(a_rbt_type *rbtree);\t\t\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##next(a_rbt_type *rbtree, a_type *node);\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##prev(a_rbt_type *rbtree, a_type *node);\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##search(a_rbt_type *rbtree, const a_type *key);\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##nsearch(a_rbt_type *rbtree, const a_type *key);\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##psearch(a_rbt_type *rbtree, const a_type *key);\t\t\\\na_attr void\t\t\t\t\t\t\t\t\\\na_prefix##insert(a_rbt_type *rbtree, a_type *node);\t\t\t\\\na_attr void\t\t\t\t\t\t\t\t\\\na_prefix##remove(a_rbt_type *rbtree, a_type *node);\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(\t\\\n  a_rbt_type *, a_type *, void *), void *arg);\t\t\t\t\\\na_attr a_type *\t\t\t\t\t\t\t\t\\\na_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,\t\t\\\n  a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);\t\t\\\na_attr void\t\t\t\t\t\t\t\t\\\na_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),\t\\\n  void *arg);\n // 函数声明, gcc -E 预都出来\n extent_t * extent_avail_first(extent_tree_t *rbtree); \n...\n// 函数实现 ph.h extent.c\n#define ph_gen(a_attr, a_prefix, a_ph_type, a_type, a_field, a_cmp)\t\\\na_prefix##remove_first(a_ph_type *ph) {\t\t\t\t\t\\\n\ta_type *ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ph->ph_root == NULL) {\t\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tph_merge_aux(a_type, a_field, ph, a_cmp);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = ph->ph_root;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tph_merge_children(a_type, a_field, ph->ph_root, a_cmp,\t\t\\\n\t    ph->ph_root);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\nstatic inline int\nextent_esnead_comp(const extent_t *a, const extent_t *b) {\n\tint ret;\n\n\tret = extent_esn_comp(a, b);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = extent_ead_comp(a, b);\n\treturn ret;\n}\nUNUSED extent_t * extent_avail_remove_first(extent_tree_t *ph) { \n    extent_t *ret; \n    if (ph->ph_root == ((void *)0)) {\n        return ((void *)0); \n    } \n    ph_merge_aux(extent_t, ph_link, ph, extent_esnead_comp);\n    ret = ph->ph_root;\n    ph_merge_children(extent_t, ph_link, ph->ph_root, extent_esnead_comp, ph->ph_root);\n    return ret; \n}\n```\n\n#### e_bits相关\n\n```c\nEXTENT_BITS_ARENA_WIDTH = 12 ;\nEXTENT_BITS_ARENA_SHIFT =0;\nEXTENT_BITS_ARENA_MASK =((((1 << (12)) - 1)) << (0));  //4095 111111111111    fff\nEXTENT_BITS_SLAB_WIDTH =1;\nEXTENT_BITS_SLAB_SHIFT =(12 + 0);\nEXTENT_BITS_SLAB_MASK =((((1 << (1)) - 1)) << ((12 + 0))); //4096 1000000000000     1000\nEXTENT_BITS_COMMITTED_WIDTH = 1;\nEXTENT_BITS_COMMITTED_SHIFT = (1 + (12 + 0));\nEXTENT_BITS_COMMITTED_MASK =((((1 << (1)) - 1)) << ((1 + (12 + 0)))); //8192  10000000000000   2000\nEXTENT_BITS_DUMPABLE_WIDTH = 1;\nEXTENT_BITS_DUMPABLE_SHIFT = (1 + (1 + (12 + 0))) ;\nEXTENT_BITS_DUMPABLE_MASK =((((1 << (1)) - 1)) << ((1 + (1 + (12 + 0))))); //16384 100000000000000 4000\nEXTENT_BITS_ZEROED_WIDTH =1;\nEXTENT_BITS_ZEROED_SHIFT =(1 + (1 + (1 + (12 + 0))));  //15   1111 f \nEXTENT_BITS_ZEROED_MASK = ((((1 << (1)) - 1)) << ((1 + (1 + (1 + (12 + 0)))))); //32768  1000000000000000 8000\nEXTENT_BITS_STATE_WIDTH = 2;\nEXTENT_BITS_STATE_SHIFT = (1 + (1 + (1 + (1 + (12 + 0))))); //16\nEXTENT_BITS_STATE_MASK =((((1 << (2)) - 1)) << ((1 + (1 + (1 + (1 + (12 + 0))))))); //196608  110000000000000000 30000\nEXTENT_BITS_SZIND_WIDTH =8;\nEXTENT_BITS_SZIND_SHIFT =(2 + (1 + (1 + (1 + (1 + (12 + 0))))));  // 18 10010 12 \nEXTENT_BITS_SZIND_MASK =((((1 << (8)) - 1)) << ((2 + (1 + (1 + (1 + (1 + (12 + 0)))))))); // 66846720 11111111000000000000000000 3FC0000\nEXTENT_BITS_NFREE_WIDTH =((12 - 3) + 1);    //10 1010 a \nEXTENT_BITS_NFREE_SHIFT =(8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))));    //26 11010 1a \nEXTENT_BITS_NFREE_MASK =((((1 << (((12 - 3) + 1))) - 1)) << ((8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))))));  // 68652367872 111111111100000000000000000000000000 FFC000000 \nEXTENT_BITS_SN_SHIFT =(((12 - 3) + 1) + (8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))))); // 36 100100 24\nEXTENT_BITS_SN_MASK =(18446744073709551615 << (((12 - 3) + 1) + (8 + (2 + (1 + (1 + (1 + (1 + (12 + 0))))))))); //  FFFFFFFFFFFFFFFF000000000 \n```\n\n### je_malloc 基本流程\n\n```erlang\n-> je_malloc(size_t size)\n    | - static_opts_init(&sopts)\n    | - dynamic_opts_init(&dopts)\n    \\ - imalloc(&sopts, &dopts) # \"参考1.1 初始化参数\"\n       \\ - !malloc_initialized() && !malloc_init() # \"这个地方通常不会失败, 第一次会进malloc_init()函数\"\n       |  \\ - malloc_init_state == malloc_init_initialized # \"即malloc_initialized为true时不会进入malloc_init函数\"\n       |  | - malloc_init_hard()\n          |  \\ - malloc_init_hard_needed() #判断是否有另一个线程正在初始化, 只要有一个线程进行初始化了即可\n            *| - malloc_init_hard_a0_locked() # 进行初始化的函数\n             |  \\ - config_prof -> prof_boot0()  ? 待研究 // TODO\n       |  |  |  | - malloc_conf_init() # 参数初始化 -> android 上只load case 0 1的情况, 只覆盖opts \n                                                   应该是elf 编译时通过je_malloc_conf 引入的     ?待研究 //TODO \n                | - pages_boot() -> os_overcommits = true 看起来没有做其他额外的处理\n                |  \\ - init_thp_state() -> JEMALLOC_USE_SYSCALL /sys/kernel/mm/transparent_hugepage/enabled ? not exsit\n                |  |  \\ - opt_thp = init_system_thp_mode = thp_mode_not_supported  transparent_hugepage(THP)?                 \n    |  |  |     | - base_boot(TSDN_NULL)\n                |  \\ - base_new(tsdn, 0, (extent_hooks_t *)&extent_hooks_default) #ind(index) = 0 QUANTUM(2^4对齐) //TODO\n                |  |  \\ - block = base_block_alloc(tsdn, NULL, extent_hooks, ind, &pind_last, &extent_sn_next, sizeof(base_t), QUANTUM)\n               |  |   |  \\ - alignment = ALIGNMENT_CEILING(alignment, QUANTUM) #16字节对齐\n                         | - size_t usize = ALIGNMENT_CEILING(size, alignment);    #16字节对齐\n                         | - min_block_size = HUGEPAGE_CEILING(sz_psz2u(header_size + gap_size + usize)); # header + block\n\t\t\t\t\t\t\t\t# HUGEPAGE_CEILING 按`HUGEPAGE_MASK` 对齐 64位上是 2^21\n                         | - next_block_size = HUGEPAGE_CEILING(sz_pind2sz(pind_next)) # \"pind_next是1, 这里初始化传的ind是0, next即为1,\n                         NPSIZES tab的总index->sizeClass 总的class的数目\"\n                         |  \\ - sz_pind2sz_lookup(pind) #对应table SIZE_CLASSES(需要进行宏展开) 参考1.3 SIZE_CLASSES展开 //TODO gdb查看该值\n\t\t\t\t\t\t | - block_size = (min_block_size > next_block_size) ? min_block_size : next_block_size; #最小2^21\n    |  |  |     |       *| - block = base_map(tsdn, extent_hooks, ind, block_size);\n                         |  \\ - <extent_hooks == &extent_hooks_default> - \n\t\t\t\t\t\t\t addr = extent_alloc_mmap(NULL, size, alignment, &zero, &commit) \n\t\t\t\t\t\t\t\t\t\t#\"size(block_size) alignment = 1 << 21 slow时用到\"\n                            | - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, 1<< 12), commit)\n                            |  \\ - mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0)\n                               | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ret, size, \"libc_malloc\");             \n       |        | - extent_boot() #锁相关的初始化, 先不用关注\n\t            |  \\ - rtree_new(&extents_rtree, true)\n                |  |  \\ - malloc_mutex_init(&rtree->init_lock, \"rtree\", WITNESS_RANK_RTREE, malloc_mutex_rank_exclusive)\n\t\t\t\t   | - mutex_pool_init(&extent_mutex_pool, \"extent_mutex_pool\", WITNESS_RANK_EXTENT_POOL)                   \n                | - ctl_boot()\n                |  \\ - malloc_mutex_init(&ctl_mtx, \"ctl\", WITNESS_RANK_CTL, malloc_mutex_rank_exclusive)\n\t    \t\t\t\t\t\t\t\tmalloc_mutex_rank_exclusive)                                       \n                | - config_prof -> prof_boot1()\n    |  |  |     | - arena_boot() \n                |  \\ - arena_dirty_decay_ms_default_set(opt_dirty_decay_ms)\n                   | - arena_muzzy_decay_ms_default_set(opt_muzzy_decay_ms)\n                   | - div_init(&arena_binind_div_info[(index)], (reg_size)) # 需要进行宏展开\n                                       // gcc -E -P macro.c -o result.c\n                   |  \\ - div_init(&arena_binind_div_info[(0)], ((1U<<3) + (0 << 3))); ... \"2^32/8 .. arena 表初始化\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t参考1.4 arena_boot 展开\"\n                | - tcache_boot() # \"cache_bin 用于分配小内存的缓存\"\n\t\t\t\t|  \\ - nhbins = sz_size2index(tcache_maxclass) + 1; # \"共多少bins 其中包括small [0-NBINS]和 large[NBINS+1 - nhbins]的\"\n                   | - \ttcache_bin_info = (cache_bin_info_t *)base_alloc(tsdn, b0get(), nhbins * sizeof(cache_bin_info_t), CACHELINE);\n                   |  \\ - base_alloc_impl(tsdn, base, size, alignment, NULL)\n                      |  \\ - extent = extent_heap_remove_first(&base->avail[i]); #\"从base->avail中取\"\n                         | - <extent == NULL?> - base_extent_alloc(tsdn, base, usize, alignment) # \"取不到的话, 需要分配\"\n\t                     | - base_extent_bump_alloc(base, extent, usize, alignment)\n    |  |  |     | - arena_init(TSDN_NULL, 0, (extent_hooks_t *)&extent_hooks_default)\n                |  \\ - arena = arena_init_locked(tsdn, ind, extent_hooks) #\"ind=0 Create a new arena &insert into the arenas array \n                                                                                                              at index ind\"       \n                   | - arena = arena_get(tsdn, ind, false); #\"Another thread may have already initialized arenas[ind] for auto arena\"\n                   | - arena = arena_new(tsdn, ind, extent_hooks);\n                   |  \\ - <ind == 0> base = b0get()\n                      | - <ind != 0> base = base_new(tsdn, ind, extent_hooks)\n                      | - arena = (arena_t *)base_alloc(tsdn, base, sizeof(arena_t), CACHELINE) #\"分配内存单元\"\n\t\t\t\t\t  | - extent_list_init(&arena->large) #\"large 双向链表初始化\"\n                      | - extents_init(tsdn, &arena->extents_dirty, extent_state_dirty, true) #\"extents_dirty 初始化\"\n                      | - extents_init(tsdn, &arena->extents_muzzy, extent_state_muzzy, false)\n                      | - ... # \"arena相关的数据结构初始化\"\n                      | - <i = 0; i < NBINS; i++> bin_init(&arena->bins[i]) # \"arena 管理的bin 初始化\"\n                      |  \\ - extent_heap_new(&bin->slabs_nonfull)\n                         | - extent_list_init(&bin->slabs_full); # \"管理无空闲块的双向链表初始化\"\n                      | - arena->base = base; # \"arena的元数据base 指向关系\"\n                      | - arena_set(ind, arena); # \"arenas[inx] = arena\"\n                | - a0 = arena_get(TSDN_NULL, 0, false) # 取arenas[ind] ind = 0\n          |     | - malloc_init_state = malloc_init_a0_initialized;\n          | - tsd = malloc_tsd_boot0()\n          |  \\ - tsd_boot0() #创建tsd_tsd\n             | - tsd_t *tsd = tsd = tsd_fetch()\n             | - return tsd\n          | - < malloc_init_hard_recursible() true?>\n          | Y\\ - return true\n          | - malloc_init_narenas()\n          | - background_thread_boot1(tsd_tsdn(tsd))\n          | - malloc_init_percpu() #\"配置一个cpu使用的arena总数\"\n          |  \\ - opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);\n          | - malloc_init_hard_finish()\n       |  |  \\ - malloc_init_state = malloc_init_initialized #\"根据此标记, 不会再次重新进malloc_init函数\" end malloc_init()\n          | - malloc_tsd_boot1() #创建tsd ？ 只有两个tsd吗？ boot0 boot1？//TODO\n    | *| - tsd_t *tsd = tsd_fetch(); #如果已经初始化, 直接调到这一步\n       |  \\ - tsd_fetch_impl(true, false);\n          |  \\ - *tsd = tsd_get(true)\n          |  |  \\ - wrapper = tsd_wrapper_get(init)\n                | - tsd_wrapper_t *wrapper = (tsd_wrapper_t *)pthread_getspecific(tsd_tsd) # tsd 区域\n                | - <wrapper==NULL> -wrapper = (tsd_wrapper_t *) malloc_tsd_malloc(sizeof(tsd_wrapper_t))\n\t\t\t\t| - tsd_wrapper_set(wrapper)\n                |  \\ - pthread_setspecific(tsd_tsd, (void *)wrapper) # malloc后设置成tsd\n          |  | -<tsd->state != tsd_state_nominal>- tsd_fetch_slow(tsd_t *tsd, false);\n       |  |  |  \\ - <tsd->state == tsd_state_uninitialized> - tsd->state = tsd_state_nominal\n                | - tsd_slow_update(tsd); # 设置状态为 tsd_state_nominal 或 tsd_state_nominal_slow(Initialized but on slow path)\n                | - tsd_set(tsd);\n                | - tsd_data_init(tsd);\n          |     |  \\ - tsd_tcache_data_init(tsd) #  Trigger tcache init \n          |     |  | *\\ - *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true, NULL, true, arena_get(TSDN_NULL, 0, true))\n                      |  \\ - ret = arena_palloc(tsdn, arena, usize, CACHELINE, zero, tcache); # zero = true\n       |  |     |        |if\\ - <usize <= SMALL_MAXCLASS && (alignment < PAGE ||... > # SMALL_MAXCLASS=10240 CACHELINE=64<1<<12\n\t\t\t\t\t\t\t\t- arena_malloc(tsdn, arena, usize, sz_size2index(usize), zero, tcache, true)\n                            | - <tcache == NULL> #上面调用传过来的tcache 是NULL?                                                        \n                      |    *| Y\\ - return arena_malloc_hard(tsdn, arena, size, ind, zero)\n                               |  \\ - arena = arena_choose(tsdn_tsd(tsdn), arena)\n                                  | - arena_malloc_small(tsdn, arena, ind, zero)  #直接从arena中分配\n                                  |  \\ - bin = &arena->bins[ind]\n                                     | - usize = sz_index2size(binind)\n                                     | - < slab = bin->slabcur) != NULL && extent_nfree_get(slab) > 0 ?> #bin->slabcur不为空\n                      |              | Y\\ - arena_slab_reg_alloc(slab, &bin_infos[binind])\n                                        |  \\- *slab_data = extent_slab_data_get(slab)\n                                           | - bin_info = bin_infos[binind]\n                                           | - regind = bitmap_sfu(slab_data->bitmap, &bin_info->bitmap_info)\n                                          *| - ret = (void *)((uintptr_t)extent_addr_get(slab) + (bin_info->reg_size * regind))#\"extent中的e_addr是内存单元(Region)的起始地址, regind是region的index\"\n                      |  |         <==     | - return ret\n                      |              | N\\ - ret = arena_bin_malloc_hard(tsdn, arena, bin, binind)\n                                        |  \\ - bin_info = &bin_infos[binind]\n                                           | - slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind) # 参考1.6.1\"arena_bin_nonfull_slab_get过程\"       \n                                           | - bin->slabcur = slab;\n                      |  |         <==     | - return arena_slab_reg_alloc(slab, bin_info)\n                           *| N\\ - return tcache_alloc_small(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path=true)\n                               |  \\ - tbin = tcache_small_bin_get(tcache, binind)\n                                  | *\\ - return &tcache->bins_small[binind] # bin 从tcache->bins_small[ind]中取出\n                                  | - ret = cache_bin_alloc_easy(tbin, &tcache_success);\n                                  |  \\ - ret = *(bin->avail - bin->ncached); bin->ncached--;\n                         | <==    | - <bins_small 已经初始化> return ret\n                         |        | - <bins_small 未初始化>\n                                  | - < Y > - arena = arena_choose(tsd, arena) # \"arena为NULL时, 为tcache绑定arena\"\n                                  | - ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,\n\t\t    \t\t\t\t\t\t\t\t\t\t\t\t\tbin, binind, &tcache_hard_success)\n                                  | *\\ - arena_tcache_fill_small(tsdn, arena, tcache, tbin, binind, \n\t    \t\t\t\t\t\t\t\t\tconfig_prof ? tcache->prof_accumbytes : 0) #填充bins_small[ind]\n                                     | - ret = cache_bin_alloc_easy(tbin, tcache_success) #tbin = bins_small[ind]\n                                     |  \\ - ret = *(bin->avail - bin->ncached); bin->ncached--;\n                         | <==       | - return ret\n       |  |     |     |  |if| - < usize > SMALL_MAXCLASS && alignment <= CACHELINE >  # \"large malloc\"\n                                - large_malloc(tsdn, arena, usize, zero) # zero = true\n                            |  \\ - arena = arena_choose(tsdn_tsd(tsdn), arena) #64位\n                               | - extent = arena_extent_alloc_large(tsdn, arena, usize, alignment, &is_zeroed) #is_zeroed = true\n       |  |     |              |*f\\ - extent_t *extent = extents_alloc(tsdn, arena, &extent_hooks,\n\t    \t\t\t\t\t\t\t  \t&arena->extents_dirty, NULL, usize, sz_large_pad, alignment, false, szind, zero, &commit)\n                                  | *\\ - extent_recycle(tsdn, arena, r_extent_hooks, extents,\n\t    \t\t\t\t\t\t\t\tnew_addr, size, pad, alignment, slab, szind, zero, commit, false)#\"比较复杂, 后面分析\", extents\n                                     |if\\ - <extent \"分配出来了\">\n                         |   <==        | - return extent\n       |  |                    |*f| - <extent\"没分配出来\">- extents_alloc(tsdn, arena, &extent_hooks, \n\t\t    \t\t\t\t\t\t  \t&arena->extents_muzzy, NULL, usize, sz_large_pad, alignment, false, szind, zero, &commit)\n                                  |if\\ - <extent \"分配出来了\">\n                         |   <==        | - return extent \n       |  |                    |*f| - <extent\"还没分配出来\"> - \n                                    - size = usize + sz_large_pad\n                                  \t- extent_alloc_wrapper(tsdn, arena, &extent_hooks, NULL, \n\t\t    \t\t\t\t\t\t\t\tusize, sz_large_pad, alignment, false, szind, zero, &commit);\n                                  |  \\ - *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks, new_addr, size, pad, \n                                                                         alignment, slab, szind, zero, commit) \n                                     | - <extent == NULL> # 没从\"arena->extents_retained\"分配出来\n                         |   <==     | N\\ - return extent\n                                     | Y\\ - extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks, new_addr, size, pad,\n                                                                                alignment, slab, szind, zero, commit)\n                         |   <==     \t| - return extent\n                |     | - *tcache = tsd_tcachep_get_unsafe(tsd) # returns a pointer to the thread-local instance 参考 1.5 宏展开扩展\n       |  |     |     | - tcache_init(tsd, tcache, avail_array)\n                      |  \\ - ticker_init(&tcache->gc_ticker, TCACHE_GC_INCR)\n                         | - for <; i < NBINS; i++ >\n                         |  \\ - tcache->lg_fill_div[i] = 1 #\"填充除 /2^lg_fill_div\"\n                            | - tcache_small_bin_get(tcache, i)->avail = ((uintptr_t)avail_stack + (uintptr_t)stack_offset)\n                            |  \\ - &tcache->bins_small[i] = avail_stack + stack_offset\n                         | - for <i = NBINS; i < nhbins; i++> # \n                         |  \\ - stack_offset += tcache_bin_info[i].ncached_max * sizeof(void *)\n                            | - tcache_large_bin_get(tcache, i)->avail = ((uintptr_t)avail_stack + (uintptr_t)stack_offset)\n                            |  \\ - &tcache->bins_large[i - NBINS] = avail_stack + stack_offset\n    | *| - imalloc_body(sopts, dopts, tsd) # \"开始分配, 上面主要是填充avail_stack的过程\"\n       |  \\ - compute_size_with_overflow(sopts->may_overflow, dopts, &size) #计算size\n          |  \\ - <may_overflow?>\n             | N\\ - *size = dopts->item_size # \"dopts->num_items = 1\"\n             | Y\\ - *size = dopts->item_size * dopts->num_items\n       |  | - < dopts->alignment == 0 > # \"不用对齐\"\n          | Y\\ - ind = sz_size2index(size) #不用对齐时使用ind分配\n          | N\\ - usize = sz_sa2u(size, dopts->alignment) #对齐的情况下按usize分配\n       \t  | - allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize, ind)\n          |  \\ - tcache = tcaches_get(tsd, dopts->tcache_ind)\n             |  \\ - &tcaches[ind]->tcache\n             | - arena = arena_get(tsd_tsdn(tsd), dopts->arena_ind, true)\n             |  \\ - ret = (arena_t *)atomic_load_p(&arenas[ind], ATOMIC_ACQUIRE)\n             | - iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false, arena, sopts->slow)\n                                                                        #\"sopts->slow是true的时候, tcache有可能是null\" // TODO\n          |<=|  \\ - ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path) #\"第二次调用, 这次的tcache一般不是空\"\n                |  \\ - <tcache!=NULL && size<SMALL_MAXCLASS>\n          | <==    | Y\\ - tcache_alloc_small(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path)\n                   | - <tcache!=NULL && size <= tcache_maxclass> # \"tcache不为NULL 且 size <= je_nhbins对应的class_size时\"\n          | <==    | Y\\ - tcache_alloc_large(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path)\n                      |  \\ - bin = tcache_large_bin_get(tcache, binind)\n                         |  \\ - bin = &tcache->bins_large[binind - NBINS]\n                         | - ret = cache_bin_alloc_easy(bin, &tcache_success)\n                         |  \\ - ret = *(bin->avail - bin->ncached)\n\t\t\t\t\t\t | - <tcache_success?> #\"从tcache拿到可用的内存了吗?\"\n                   | <== | Y\\- return ret\n                         | N\\- ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero)\n                   | <==    | - return ret\n          | <==    | - arena_malloc_hard(tsdn, arena, size, ind, zero) #\"> je_nhbins对应的class_size时不走tcache, 走arena的分配 \n                                                || 没有tcache的情况下, 也走arena的分配\"        \n                   |  \\ - arena = arena_choose(tsdn_tsd(tsdn), arena);\n          | <==       | - <size <= SMALL_MAXCLASS> - arena_malloc_small(tsdn, arena, ind, zero)\n                   |<=|  \\ - return ((uintptr_t)extent_addr_get(slab) + (uintptr_t)(bin_info->reg_size * regind)) # \"small 要寻bitmap\"\n          | <==       | - <size > SMALL_MAXCLASS > - large_malloc(tsdn, arena, sz_index2size(ind), zero)\n                      |  \\ - extent = arena_extent_alloc_large(tsdn, arena, usize, alignment, &is_zeroed)\n                   |<==  | - return extent_addr_get(extent) #\"large 只需要找e_addr返回即可\"\n    |     | - *dopts->result = allocation;                  \n```\n\nSmall类型内存分配分为两类，一类是`arena_malloc_hard`，另一类是`arena_malloc_small`。\n\n这两类的区别是`tcache_alloc_small`申请的内存有和线程进行绑定，即申请的内存数据会设置为线程私有数据(tsd)，而`arena_malloc_hard`申请的内存没有和线程绑定。\n\n在`imalloc_body`流程中, 会获取tcache `tcache = tcaches_get(tsd, dopts->tcache_ind)`, 而在初始化或者slow malloc时, tcache是NULL, 就需要从`arena->bins`中获取.\n\n1. tcache中获取,  先从`tcache->bins_small[binind]`取出cache_bin的信息, 通过`cache_bin_alloc_easy`函数取出`*(bin->avail - bin->ncached)` 返回出去, 这个即为对应的可用的region, 此处`bin->ncached`保存的可用的缓存数目, 如果bin->ncached为0, 则需要重新装填bins_small结构, [见1.7 tsd->tcache->bins_small 填充流程](#1.7 tsd->tcache->bins_small 填充流程), 装填完后, 再次通过`cache_bin_alloc_easy`函数取出`*(bin->avail - bin->ncached)` 返回出region\n\n2. 不从tcache中获取, 需要加锁, 因为arena是全局的变量, 不是线程特有的. 通过`arena_malloc_hard`函数, 从`arena->bins[ind]`取出bin, 此处的bin不是tcache的[cache_bin](#cache_bin)结构, 而是开篇介绍的[bin](#bin)结构, 其中`bin->slabcur`是当前bin使用的extent结构, 需要从其位图中找出可用的region. 如果`slabcur`是空的, 或者当前的slab(extent)没有可用的region, 则需要调用`arena_bin_nonfull_slab_get`函数获取, 这里和[1.6 tsd->tcache->bins_small 填充流程](#1.6 tsd->tcache->bins_small 填充流程)流程是重复的, 需要理清tache->bins_small[ind]和arena->bins[ind]之间的关系.\n\n   > 在装填过程中, 可以看出 arena->bins[ind] 维护的 [bin](#bin) 是一个全局的大缓存, 而tache的[cache_bin](#cache_bin)是一个和tsd绑定的小缓存, 当小缓存ncached变成0时, 即没有可用的region后, 需要装填cache_bin. 优先级是先从大缓存中装入(先找slabcur, slabcur满了, 再找slab_nofull出堆, 找free的region, 同时更新slabcur), 如果大缓存没有了, 就需要从extents_dirty(muzzy|retained)(heap)中回收, 回收也没有的话, 就需要mmap然后新建slab, 再分给小缓存(也包括更新大缓存, 和把extent注册到rtree中) \n\n![jemalloc.drawio](images/20201204103839.svg)\n\n###  1.6 tsd->tcache->bins_small 填充流程\n\n>\"`lg_fill_div`用作tcache refill时作为除数. 当tcache耗尽时, 会请求arena bins_small进行refill. 但refill不会一次性灌满tcache, 而是依照其最大容量缩小2^lg_fill_div的倍数. 该数值同low_water一样是动态的, 两者互相配合确保tcache处于一个合理的充满度\"\n\n```erlang\n--> arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache, cache_bin_t *tbin, szind_t binind, uint64_t prof_accumbytes)\n  | - bin = &arena->bins[binind];\n  |for <i = 0, nfill = (tcache_bin_info[binind].ncached_max >> tcache->lg_fill_div[binind]); i < nfill; i+> -\n     |if\\ - < slab = bin->slabcur) != NULL && extent_nfree_get(slab) > 0> - #\"当前使用中的 slab 通过 bin->slabcur 分配\"\n        |  \\ - (bin->slabcur->e_bits & EXTENT_BITS_NFREE_MASK)>>EXTENT_BITS_NFREE_SHIFT > 0                                            \n        | - ptr = arena_slab_reg_alloc(slab, &bin_infos[binind])\n        |  \\ - arena_slab_data_t *slab_data = ent_slab_data_get(slab)\n           | - regind = bitmap_sfu(slab_data->bitmap, &bin_info->bitmap_info) #\"计算可用region的在slab_data bitmap中的index\"\n           | - ret = (void *)((uintptr_t)extent_addr_get(slab) + (uintptr_t)(bin_info->reg_size * regind)); #\"返回可用region的地址\"\n           | - extent_nfree_dec(slab) #\"extent中可用的region数减去EXTENT_BITS_NFREE_SHIFT 数目, 表示这些region装填给了 tcache\"         \n           | - return ret\n     |el| - < slab = bin->slabcur) != NULL && extent_nfree_get(slab) > 0> #\"即bin->slabcur为NULL && bin->slabcur->e_bits标识NFREE时\"\n        |  \\ - ptr = arena_bin_malloc_hard(tsdn, arena, bin, binind)   # Re-fill bin->slabcur, then call arena_slab_reg_alloc()\n           |  \\ - <!arena_is_auto(arena) && bin->slabcur != NULL> -\n              | Y\\ - arena_bin_slabs_full_insert(arena, bin, bin->slabcur);  \n                 | - bin->slabcur = NULL;\n           |  | - slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)  # 1.6.1 arena_bin_nonfull_slab_get过程  \n              |  \\ - slab = arena_bin_slabs_nonfull_tryget(bin)  #\"Look for a usable slab.\"\n                 |  \\ - extent_t *slab = extent_heap_remove_first(&bin->slabs_nonfull) #nonfull 出堆 \"从slabs_nonfull中获取\"\n                 | - <slab != NULL>\n     |        |<-| Y\\ - return slab\n                 | N\\ - bin_info = &bin_infos[binind]\n           |  |  | - slab = arena_slab_alloc(tsdn, arena, binind, bin_info) #Allocate a new slab\n                 |  \\ - szind = sz_size2index(bin_info->reg_size)\n           |        | - *slab = extents_alloc(tsdn, arena, &extent_hooks, #从\"extents_dirty\"中分配\n                                              &arena->extents_dirty, NULL, bin_info->slab_size, 0, PAGE, true, binind, &zero, &commit)\n                    |  \\ - extent_recycle(tsdn, arena, r_extent_hooks, extents, new_addr, size, \n                                          pad, alignment, slab, szind, zero, commit, false) # \"后面进行分析\"\n                       | - <extent \"分配出来了\">\n                       | Y\\ - extent_dumpable_get(extent) #\n           |  |     |  <--| - return extent #end \"arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)\"\n                    | - < slab == NULL > \n           |        | Y\\ - slab = extents_alloc(tsdn, arena, &extent_hooks, ##\" extents_dirty 中 没分配出来, 从extents_muzzy\" 中分配\n\t\t    \t\t\t\t\t              &arena->extents_muzzy, NULL, bin_info->slab_size, 0, PAGE, true, binind, &zero, &commit)\n                    | - < slab == NULL > - \n                    | N\\ - extent_dumpable_get(extent)\n     |     |  |  \t|<-| - return extent #end \"arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)\"\n  |  |     |  |     | Y\\ - slab = arena_slab_alloc_hard(tsdn, arena, &extent_hooks, bin_info, szind);  #\" extents_muzzy 中 没分配出来\"\n                       | - slab = extent_alloc_wrapper(tsdn, arena, r_extent_hooks, NULL,\n\t    \t\t\t\t\t\t         \t\t\t  bin_info->slab_size, 0, PAGE, true, szind, &zero, &commit)\n                       |  \\ - *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks,\n\t    \t\t\t\t\t\tnew_addr, size, pad, alignment, slab, szind, zero, commit)\n                          |  \\ - *extent = extent_recycle(tsdn, arena, r_extent_hooks, #从\"extents_retained\" 中分配\n\t    \t\t\t\t\t\t&arena->extents_retained, new_addr, size, pad, alignment, slab, szind, zero, commit, true)\n                          | - < slab == NULL > - #\"extent_alloc_retained 没分配出来\"\n                          | N\\ - extent_dumpable_get(extent)\n     |     |   |    |  <==   | - return extent #end \"arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)\"\n  |  |     |   |          | Y\\ - extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,\n\t\t    \t\t\t\t\t\t\t\t\t\t\t   new_addr, size, pad, alignment, slab, szind, zero, commit)\n\t |\t   |\t\t\t     | - *extent = extent_alloc(tsdn, arena) # \"参考 1.7 extent_alloc流程, 这里只是新建extent base的元数据\"\n                             | - <*r_extent_hooks == &extent_hooks_default> -\n                             | Y\\ - addr = extent_alloc_default_impl(tsdn, arena, new_addr,\n                                                              esize, alignment, zero, commit)  #\"Call directly to propagate tsdn\"\n                                | - addr = extent_alloc_default_impl(tsdn, arena, NULL, alloc_size, PAGE, &zeroed, &committed)\n                          |  \\ - extent_alloc_core(tsdn, arena, new_addr, size, alignment, zero, #(new_addr=NULL)\n\t    \t\t\t\t\t\t\t\t\t\t\tcommit, (dss_prec_t)atomic_load_u(&arena->dss_prec, ATOMIC_RELAXED))\n                             | - addr = extent_alloc_mmap(new_addr, size, alignment, zero, commit)\n                                |  \\ - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, PAGE), commit)\n                             | \\ - os_pages_map(addr, size, os_page, commit)\n                                   | - addr = mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0) \n                                                          #\"addr 0 系统自动分配地址, 分配实际的地址, 挂到extent base元数据的e_addr下\"\n                                   | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, \"libc_malloc\")\n                             |  |  | - return addr\n                             | - extent_init(extent, arena, addr, esize, slab, szind, arena_extent_sn_next(arena), \n                                                extent_state_active, *zero, *commit, true);\n                             |  \\ - extent_addr_set(extent, addr); #\"这里应该是真正给extent设置region内存地址的地方\"\n                                | - extent_sn_set(extent, sn);\n                                | - ...\n     |     |                 | - extent_register(tsdn, extent)\n                             |  \\ - *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback)\n                                |  \\ - *rtree_ctx = &tsdn->tsd->use_a_getter_or_setter_instead_rtree_ctx\n                             |  \\ - < extent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, extent, false, true, &elm_a, &elm_b) ?>\n                                | Y\\ - # \"rtree中找到了这个extent\"\n                                   | - return true# 不用再注册, 因为已经在rtree中了\n                                | N\\ - # \"rtree中没找到, 需要注册\"\n                                   | - extent_rtree_write_acquired(tsdn, elm_a, elm_b, extent, szind, slab)\n                                   |  \\ - rtree_leaf_elm_write(tsdn, &extents_rtree, elm_a, extent, szind, slab)\n                                      | - rtree_leaf_elm_write(tsdn, &extents_rtree, elm_b, extent, szind, slab)                         \n                                   | - bool slab = extent_slab_get(extent) \n                                   | - <slab?>\n                                   | Y\\ - #小内存 small_class\n                                      | - extent_interior_register(tsdn, rtree_ctx, extent, szind) \n                                      |  \\ - for (size_t i = 1; i < (extent_size_get(extent) >> LG_PAGE) - 1; i++)\n                                                        # \"key\" = (uintptr_t)extent_base_get(extent) + (uintptr_t)(i << LG_PAGE)\n                                         |  \\ - <\"elm\" = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx, \"key\", false, true) FOUND?>\n                                            | Y\\ - rtree_leaf_elm_write(tsdn, rtree, elm, extent, szind, slab);\n                             | - return extent\n  |  |     |        | - *slab_data = extent_slab_data_get(slab);\n                    | - extent_nfree_set(slab, bin_info->nregs);\n                    |  \\ - extent->e_bits = (extent->e_bits & ~EXTENT_BITS_NFREE_MASK) | (nfree << EXTENT_BITS_NFREE_SHIFT)\n                    | - bitmap_init(slab_data->bitmap, &bin_info->bitmap_info, false)                                  \n           |  | <-- | - return slab; # end \" slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)\"\n              | - #end \"slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)\"\n              | - bin->slabcur = slab; #\"更新大缓存\"\n     | - *(tbin->avail - nfill + i) = ptr;\n  | - tbin->ncached = i;  #\"for end\"\n```\n\n首先从 `tsd->tcache->bins_small[binind]` 中获取对应 `size_class` 的内存，有的话将内存直接返回给用户，如果 `bins_small[binind]` 中没有的话，需要通过 `slab(extent)` 对 `tsd->tcache->bins_small[binind]` 进行填充，一次填充多个以备后续分配，填充方式如下（当前步骤无法成功则进行下一步）：\n\n1. 通过 `bin->slabcur` 分配\n2. 从 `bin->slabs_nonfull` 中获取可使用的 `extent`\n3. 从 `arena->extents_dirty` 中回收 `extent`，回收方式为 ***first-fit\\***，即满足大小要求且**序列号最小地址最低（最旧）**的 `extent`，在 `arena->extents_dirty->bitmap` 中找到满足大小要求并且第一个非空 heap 的索引 `i`，然后从 `extents->heaps[i]` 中获取第一个 `extent`。由于 `extent` 可能较大，为了防止产生内存碎片，需要对 `extent` 进行分裂（伙伴算法），然后将分裂后不使用的 `extent` 放回`extents_dirty`中\n4. 从 `arena->extents_muzzy` 中回收 `extent`，回收方式为 ***first-fit\\***，即满足大小要求且**序列号最小地址最低（最旧）**的 `extent`，遍历每个满足大小要求并且非空的 `arena->extents_dirty->bitmap`，获取其对应 `extents->heaps` 中第一个 `extent`，然后进行比较，找到最旧的 `extent`，之后仍然需要分裂\n5. 从 `arena->extents_retained` 中回收 `extent`，回收方式与 `extents_muzzy` 相同\n6. 尝试通过 `mmap` 向内核获取所需的 `extent` 内存，并且在 `rtree` 中注册新 `extent` 的信息\n7. 再次尝试从 `bin->slabs_nonfull` 中获取可使用的 `extent`\n\n简单来说，这个流程是这样的，`cache_bin -> slab -> slabs_nonfull -> extents_dirty -> extents_muzzy -> extents_retained -> kernel`\n\n### 1.7 extent_alloc流程\n\n```erlang\n--> extent_t * extent_alloc(tsdn_t *tsdn, arena_t *arena)\n|  \\ - *extent = extent_avail_first(&arena->extent_avail) #\"参考1.5 宏展开\"\n   | - < extent == NULL >\n   | N\\ - extent_avail_remove(&arena->extent_avail, extent) # \"先从extent_avail 中获取\"\n   | Y\\ - return base_alloc_extent(tsdn, arena->base)\n      | - *extent = base_alloc_impl(tsdn, arena->base, sizeof(extent_t)\n      |  \\ - usize = ALIGNMENT_CEILING(size, alignment)\n         | - asize = usize + alignment - QUANTUM;\n         | - for (szind_t i = sz_size2index(asize); i < NSIZES; i++)\n         |  \\ - extent = extent_heap_remove_first(&base->avail[i])\n            | - < extent != NULL >\n        <==*|  \\ - break;\n      |  | - < extent == NULL > # \"上面遍历完, 仍没找到有效的extent\"\n         | Y\\ - extent = base_extent_alloc(tsdn, base, usize, alignment)\n            |  \\ - *block = base_block_alloc(tsdn, base, extent_hooks, base_ind_get(base), \n                                             &base->pind_last, &base->extent_sn_next, size, alignment)\n               |  \\ - *block = base_map(tsdn, extent_hooks, ind, block_size)\n                  |  \\ - addr = extent_alloc_mmap(NULL, size, alignment, &zero, &commit) \n                     | - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, 1<< 12), commit)\n                     |  \\ - mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0)\n                        | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ret, size, \"libc_malloc\");\n                     |  | - return addr\n               |  | - base_extent_init(extent_sn_next, &block->extent, *(block + header_size), block_size - header_size)\n                  |  \\ - sn = *extent_sn_next; #\"extent 还有sn号\"\n                     | - extent_binit(extent, addr, size, sn)\n                     |  \\ - extent_arena_set(extent, NULL)\n                        | - extent_addr_set(extent, addr);\n                        | - extent_bsize_set(extent, bsize);\n                        | - ... \"设置extent e_bits 保存相关的数据结构关系\"\n               | - block->next = base->blocks; base->blocks = block; # \"挂入arena->base->blocks链表\"\n```\n\n在small和large分配的函数中, 牵扯到的比较重要的函数就是这个`extent_recycle`了\n\n下面对其重点分析一下\n\n#### `extent_recycle` 回收函数分析\n\n>Tries to satisfy the given allocation request by reusing one of the extents  in the given extents_t.\n\n```c\nstatic extent_t *\nextent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,\n    extents_t *extents, void *new_addr, size_t size, size_t pad,\n    size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit,\n    bool growing_retained) {\n\n        rtree_ctx_t rtree_ctx_fallback;\n        // 取tsd结构体的 use_a_getter_or_setter_instead_rtree_ctx成员\n        tsd_rtree_ctx(tsd_t *tsd) {\n            return tsd_rtree_ctxp_get(tsd);\n        }\n        rtree_ctx_t *\n        tsdn_rtree_ctx(tsdn_t *tsdn, rtree_ctx_t *fallback) {\n        ...\n            return tsd_rtree_ctx(tsdn_tsd(tsdn));\n        }\n\n\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n    // 从extents中回收extent extents是从上面传入的 arena->extents_dirty | extents_muzzy | extents_retained\n\textent_t *extent = extent_recycle_extract(tsdn, arena, r_extent_hooks,\n\t    rtree_ctx, extents, new_addr, size, pad, alignment, slab,\n\t    growing_retained);\n\tif (extent == NULL) {\n\t\treturn NULL;\n\t}\n\t// 分裂, 把多余的放回到extents中\n\textent = extent_recycle_split(tsdn, arena, r_extent_hooks, rtree_ctx,\n\t    extents, new_addr, size, pad, alignment, slab, szind, extent,\n\t    growing_retained);\n\tif (extent == NULL) {\n\t\treturn NULL;\n\t}\n // 正常的话, 如果能回收到extent, 其状态应该是e_bits中commited应该是置位的, 如果没置位, 则表示需要重新通过mmap分配内存, 这里os_overcommits比较迷惑\n\tif (*commit && !extent_committed_get(extent)) {\n\t\tif (extent_commit_impl(tsdn, arena, r_extent_hooks, extent,\n\t\t    0, extent_size_get(extent), growing_retained)) {\n\t\t\textent_record(tsdn, arena, r_extent_hooks, extents,\n\t\t\t    extent, growing_retained);\n\t\t\treturn NULL;\n\t\t}\n\t\textent_zeroed_set(extent, true);\n\t}\n\n\tif (extent_committed_get(extent)) {\n\t\t*commit = true;\n\t}\n\tif (extent_zeroed_get(extent)) {\n\t\t*zero = true;\n\t}\n\n\tif (pad != 0) {\n\t\textent_addr_randomize(tsdn, extent, alignment);\n\t}\n\tassert(extent_state_get(extent) == extent_state_active);\n\tif (slab) {\n\t\textent_slab_set(extent, slab);\n\t\textent_interior_register(tsdn, rtree_ctx, extent, szind);\n\t}\n\tif (*zero) {\n\t\tvoid *addr = extent_base_get(extent);\n\t\tsize_t size = extent_size_get(extent);\n        // 如果不是0, 一般情况下, 上面肯定设置0了, 不是0, 会进行force purge过程, 告诉kernel 可以回收这块物理页, 虚拟内存不被mmu映射的话, 就是摆设\n\t\tif (!extent_zeroed_get(extent)) {\n\t\t\tif (pages_purge_forced(addr, size)) {\n\t\t\t\tmemset(addr, 0, size);\n\t\t\t}\n\t\t} else if (config_debug) {\n\t\t\tsize_t *p = (size_t *)(uintptr_t)addr;\n\t\t\tfor (size_t i = 0; i < size / sizeof(size_t); i++) {\n\t\t\t\tassert(p[i] == 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn extent;\n}\n```\n\n```erlang\n--> extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,\n    \textents_t *extents, void *new_addr, size_t size, size_t pad,\n    \tsize_t alignment, bool slab, szind_t szind, bool *zero, bool *commit,\n    \tbool growing_retained) # \"new_addr = NULL\"\n |  \\ - *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback)\n    |  \\ - *rtree_ctx = &tsdn->tsd->use_a_getter_or_setter_instead_rtree_ctx\n    | - *extent = extent_recycle_extract(tsdn, arena, r_extent_hooks, #\"to find & remove an extent from extents that can be used...\"\n\t    \t\t\t\t\t\t\t\trtree_ctx, extents, new_addr, size, pad, alignment, slab, growing_retained)\n    |  \\ - <new_addr == NULL> - (new_addr = NULL)\n       | Y\\ - extents_fit_locked(tsdn, arena, extents, esize, alignment)\n          |  \\ - max_size = esize + PAGE_CEILING(alignment) - PAGE;\n             | - *extent = extents_first_fit_locked(tsdn, arena, extents, max_size) #\" Do first-fit extent selection, \n               \t\t\ti.e. select the oldest/lowest extent that is large enough.\"\n             | - <alignment > PAGE && extent == NULL> - #\"没分配成功\"\n             | Y\\ - extent = extents_fit_alignment(extents, esize, max_size, alignment); #\"再fit 一遍alignment \n               \t\tFind an extent with size [min_size, max_size) to satisfy the alignment requirement. \n               \t\tFor each size, try only the first extent in the heap.\"\n             | - return extent\n    | - extent = extent_recycle_split(tsdn, arena, r_extent_hooks, rtree_ctx, \n\t    \t\t\t\t\t\t\t\textents, new_addr, size, pad, alignment, slab, szind, extent, growing_retained)     \n\t\t\t\t\t#\"extent_recycle_extract 后如果有多的未用的空间, 再split放回到extents中?\"\n    |  \\ - extent_split_interior(tsdn, arena, r_extent_hooks, rtree_ctx, &extent,\n                                 &lead, &trail, &to_leak, &to_salvage, new_addr, size, pad, alignment, slab, szind, growing_retained)\n       | - < result == extent_split_interior_ok > #是否split成功了\n       | Y\\ - < lead != NULL > #切到头部了\n       \t  | Y\\ - extent_deactivate(tsdn, arena, extents, lead) #设置成不活跃的\n    | <-- | - return extent\n\t   | N\\ - # split失败 \"should have picked an extent that was large enough to fulfill our allocation request\" ...\n |\t| <-- | - return NULL\n    | - < *commit && !extent_committed_get(extent) >\n    | Y\\ - extent_commit_impl(tsdn, arena, r_extent_hooks, extent, 0, extent_size_get(extent), growing_retained))\n       |  \\ - (*r_extent_hooks)->commit(*r_extent_hooks, extent_base_get(extent), extent_size_get(extent), \n                                        offset, length, arena_ind_get(arena)))\n          |  \\ - extent_commit_default(...)\n       | - <extent_commit_impl return true?> \n | <-- | Y\\ - return NULL  (os_overcommits = true时返回NULL /proc/sys/vm/overcommit_memory 值为0或1时)                                 \n    | - < *zero == true > \n    | Y\\ - < extent_zeroed_get(extent) == false > # \"extent->e_bits zero位非0时\"\n       | Y\\ - pages_purge_forced(addr, size)\n          |  \\ - return (madvise(addr, size, MADV_DONTNEED) != 0) # \"一般走不到这个地方\"\n```\n\n## je_free 流程\n\n上面大概只分析了small 分配的流程， 还需要深入调研下，留待后续进行研究。\n\n先来看下 free的流程， 加深对`extent_recycle`过程的理解\n\n```erlang\n--> je_free(void *ptr)\n  |  \\ - tsd_t *tsd = tsd_fetch_min();    \n     | - return tsd_fetch_impl(true, true) <bool init, bool minimal)>;\n     |  \\ - tsd_t *tsd = tsd_get(true) #从前面的分析中，怀疑只有两个tsd\n        |  \\ - wrapper = tsd_wrapper_get(init) #wrapper结构体封装了 tsd的初始化的状态 和 tsd结构体实例\n           |  \\ - tsd_wrapper_t *wrapper = (tsd_wrapper_t *)pthread_getspecific(tsd_tsd)\n     |  <==| return &wrapper->val; \n  |  | - tcache = tsd_tcachep_get(tsd) #取出tsd结构体实例的tcache成员 参考 tsd的结构\n  | *| - ifree(tsd, ptr, tcache, false) #slow_path(false) 现在只关注fast的场景\n     |  \\ - rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd)\n        | - rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,\n\t    \t\t\t(uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab)\n        |  \\ - rtree_leaf_elm_t *elm = rtree_read(tsdn, rtree, rtree_ctx, key, dependent) #key为ptr rtree遍历查找ptr，确定其位于哪个叶子节点\n           | - uintptr_t bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm, dependent); # elm->le_bits\n           | - *r_szind = rtree_leaf_elm_bits_szind_get(bits); #(bits >> LG_VADDR)（64位为48）可以查出index\n           | - *r_slab = rtree_leaf_elm_bits_slab_get(bits) #bits & (uintptr_t)0x1 得到其是否是slab（small_class）\n           | - #查询的结果放到alloc_ctx中（*r_szind *r_slab ）\n  |     | - idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false, false) \n        |  \\ - arena_dalloc(tsdn, ptr, tcache, alloc_ctx, slow_path)\n           | - < tcache==NULL? >\n  |        | Y\\ - return arena_dalloc_no_tcache(tsdn, ptr) #\"没有tcache的情况，一般走不到这\"\n  |        | N\\ - szind = alloc_ctx->szind;\n              | - slab = alloc_ctx->slab;\n              | - < slab ?>\n  |  | <==    | Y\\ - return arena_dalloc_small(tsdn, ptr) #\"走small的释放\"\n                 |  \\ - extent_t *extent = iealloc(tsdn, ptr)\n                    |  \\ - rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback)\n                       | - return rtree_extent_read(tsdn, &extents_rtree, rtree_ctx, (uintptr_t)ptr, true)\n                       |  \\ - rtree_leaf_elm_t *elm = rtree_read(tsdn, rtree, rtree_ctx, key, dependent) #ptr为key, 找出叶子节点\n                          | - return rtree_leaf_elm_extent_read(tsdn, rtree, elm, dependent)   #通过叶子节点找到对应的extent指针\n                          |  \\ - bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm, dependent)\n                       | <== | - return rtree_leaf_elm_bits_extent_get(bits)  # 通过elm->le_bits 移位和位运算获得extent的指针               \n                    | - arena_t *arena = extent_arena_get(extent)\n                    |  \\ - arena_ind = (unsigned)((extent->e_bits & EXTENT_BITS_ARENA_MASK) >> EXTENT_BITS_ARENA_SHIFT) \n                                           #\"entent->e_bits 移位+位运算 得到arena ind\"\n                       | - return &arenas[arena_ind] #arenas ind 取出arena\n                   *| - arena_dalloc_bin(tsdn, arena, extent, ptr)\n                    |  \\ - binind = extent_szind_get(extent)\n                       |  \\ - szind = (szind_t)((extent->e_bits & EXTENT_BITS_SZIND_MASK) >> EXTENT_BITS_SZIND_SHIFT)\n                       | - bin_t *bin = &arena->bins[binind]; #\"arena->bins[ind]取出bin\"\n                      *| - arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, false)\n                       |  \\ - *slab_data = extent_slab_data_get(slab)\n                          | - binind = extent_szind_get(slab)\n                          | - *bin_info = &bin_infos[binind]\n                          | - arena_slab_reg_dalloc(slab, slab_data, ptr)\n                          |  \\ - regind = arena_slab_regind(slab, binind, ptr) #\"计算ptr的region id\"\n                             | - bitmap_unset(slab_data->bitmap, &bin_info->bitmap_info, regind) #重设该region在slab_data bitmap的使用标记\n                             | - extent_nfree_inc(slab) #\"entent 记录free的region数+1\"\n                          | - nfree = extent_nfree_get(slab) #\"获得free的region数\"\n                         *| - < nfree == bin_info->nregs > #\"该extent 变成了所有 region全是未使用的状态?\"\n                         *| Y\\ - arena_dissociate_bin_slab(arena, slab, bin)\n                             | - < slab == bin->slabcur >\n                             | Y\\ - bin->slabcur = NULL #该slab = slabcur时, 将slabcur 设成NULL结束\n                             | N\\ - bin_info = &bin_infos[binind]\n                                | - < bin_info->nregs == 1 ?> #\"判断该slab是处在full列中还是nonfull堆中\"\n                                | Y\\ - arena_bin_slabs_full_remove(arena, bin, slab) #full中删除\n                                | N\\ - arena_bin_slabs_nonfull_remove(bin, slab); #从nonfull中删除                   \n                          |  | - arena_dalloc_bin_slab(tsdn, arena, slab, bin)                          \n                             |  \\ - arena_slab_dalloc(tsdn, arena, slab)\n                                |  \\ - arena_nactive_sub(arena, extent_size_get(slab) >> LG_PAGE)\n                                   |  \\ - &arena->nactive - (extent_size_get(slab) >> LG_PAGE) #\"arena active page (就是使用活跃状态的\t\t\t\n                                   总page数 - extent占用的page数\")\n                          |  |  | *| - arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, slab) \n                                                         #\"这个地方的生效条件是 该extent变成了所有 region全是未使用的状态\"\n                                      |  \\ - extents_dalloc(tsdn, arena, r_extent_hooks, &arena->extents_dirty, extent); #//TODO         \n                          | N\\ - < nfree == 1 && slab != bin->slabcur ?> #\"extent nfree释放后恰好变成了1, 即从full状态变成了nonfull状态\"\n                             | Y\\ - arena_bin_slabs_full_remove(arena, bin, slab) #\"将该slab从slab_full队中删除\"\n                                |  \\ - extent_list_remove(&bin->slabs_full, slab)\n                                | - arena_bin_lower_slab(tsdn, arena, slab, bin)\n                                   | - < bin->slabcur != NULL && extent_snad_comp(bin->slabcur, slab) > 0 > #这个应该是比较哪个slab比较旧\n                                   | Y\\ - < extent_nfree_get(bin->slabcur) > 0 > #slabcur nfree>0? \n                                       | Y\\ - arena_bin_slabs_nonfull_insert(bin, bin->slabcur) \n                                                  ##当前slab旧, 轮转slab和slabcur, 即slabcur总是用最旧的, slabcur 入nonfull堆\n                                       | N\\ - arena_bin_slabs_full_insert(arena, bin, bin->slabcur) # slabcur 入full堆, 因为nfree没了\n                                       | - bin->slabcur = slab #切换slabcur为当前的slab\n                                   | N\\ - arena_bin_slabs_nonfull_insert(bin, slab) #slabcur旧, 不轮转, 将该slab其入nonfull堆, 从full列删除\n              | N\\ - extent_t *extent = iealloc(tsdn, ptr)  \n  |  | <==       | - return large_dalloc(tsdn, extent)   #\"走large的释放\"\n```\n\n上述流程中涉及到了 `arena_extents_dirty_dalloc`方法是内存被释放后, 与dirty extents堆的交互过程, 重点看下这部分, 其他都是相关bin 数据结构的关系整理.\n\n### `arena_extents_dirty_dalloc` extent变成了所有 region全是未使用的状态时的处理\n\n```erlang\n# \"输入为extent, 即上面传下来的slab, 还有arena, 触发条件是extent变成了所有 region全是未使用的状态\" 函数执行前后需要加锁, 略过\n-->void arena_extents_dirty_dalloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks, extent_t *extent) \n|  \\ - extents_dalloc(tsdn, arena, r_extent_hooks, &arena->extents_dirty, extent);\n   |  \\ - extent_addr_set(extent, extent_base_get(extent)) #\"设置成addr page对齐的地址\"\n      | - extent_zeroed_set(extent, false) # 是否是重置的, 传入的是false\n      | - extent_record(tsdn, arena, r_extent_hooks, extents, extent, false) # 这里用到了 extents, 上文是 dirty的heap \n      |  \\ - extent_szind_set(extent, NSIZES);\n         | - < extent_slab_get(extent) ?> \"传入的entent是否是small class的slab \" 上文传下来是的\n        *| Y\\ - extent_interior_deregister(tsdn, rtree_ctx, extent); #\"反注册, 从全局rtree中删除记录\" //TODO\n            | - extent_slab_set(extent, false) # \"消除slab标记, 变成普通的extent\"\n         | - < !extents->delay_coalesce? > # 是否指定了延迟合并, 未指定则立即合并\n         | Y\\ - extent = extent_try_coalesce(tsdn, arena, r_extent_hooks, rtree_ctx, extents, extent, NULL, growing_retained); \n         | N\\ - < extent_size_get(extent) >= LARGE_MINCLASS > # \"extent size >= (1<<14) Always coalesce large extents eagerly  \"\n            | Y\\ - <for ; coalesced && extent_size_get(extent) >= prev_size + LARGE_MINCLASS; >\n                     #\"如果返回的coalesced为true && extent的size >= (合并前的size + 1<<14), 就会一直触发合并, 直到合并不下去\"\n               |  \\ - prev_size = extent_size_get(extent) #\"记住合并前的大小\"\n                  | - extent = extent_try_coalesce(tsdn, arena, r_extent_hooks, rtree_ctx, extents, extent, &coalesced, \n                                                   growing_retained) #\"进行合并, 返回是否合并成功了\"\n        *| - extent_deactivate_locked(tsdn, arena, extents, extent)\n         |  \\ - extent_state_set(extent, extents_state_get(extents) #上文传入的是dirty堆, 所以这里将extent标记为了dirty\n            | - extents_insert_locked(tsdn, extents, extent) #将extent插入到 dirty堆中                        \n```\n\n#### 小内存释放小结\n\n总结上述小内存释放的流程, 当前仅关注fast场景\n\n1. 根据调用上下文执行流程, 找到其绑定的tsd\n\n2. 根据tsd找到其tcache成员\n\n3. fast场景, 根据全局rtree, ptr地址为key, 检索出其size ind, 以及是否是 slab (地址是否是小内存的)\n\n4. 如果没有tcache, 走`arena_dalloc_no_tcache(tsdn, ptr)`流程, 一般情况下都是有tcache的, 走`arena_dalloc_small(tsdn, ptr)`流程\n\n5. 由`iealloc(tsdn, ptr)` 根据全局rtree, ptr地址为key, 检索出其 extent 结构, 由extent `extent_arena_get(extent)`获取extent对应的arena, 由extent `extent_szind_get(extent)`获取binind, 进而`&arena->bins[binind]`获得bin结构, `arena_slab_regind(slab, binind, ptr) `获得ptr在extent中对应的region id.  清除该regionid 在extent中的使用标记, `extent_nfree_inc(slab)` extent 元信息中记录其 free region数+1\n\n6. 如果释放后, 该extent变成了全free 状态(即所有region 都是free的), arena active page数 - 该extent所占的page数, 最后将该extent或者合并后的extent挂入`dirty`堆中, 这时, 如果支持合并的话(have_dss对应的宏打开), 查extent前后的extent, 循环合并, 直到合并不了为止\n\n   6.1 ptr所在的slab是 bin->slabcur, 将slabcur 设成NULL\n\n   6.2 ptr所在slab不是slabcur的情况下, 如果其bin_info->nregs == 1,  即释放前bin中的nregs(总region数)是1, 释放后, 该bin就变成未使用的状态了, 需要将其从slabfull 列中删除, 如果不是1(肯定也不是0, 就是>1的情况), 将其从nonfull堆中删除\n\n   > bin nregs 是所有ind extent的region的总数\n\n7. 如果释放后, nfree释放后恰好变成了1, 即从full状态变成了nonfull状态. 将 `arena->bins[binind]->slabcur` 切换为这个 `extent`，前提是这个 `extent` “更旧”（序列号更小地址更低），并且将替换后的 `extent` 移入 `arena->bins[binind]->slabs_nonfull`, 并从slab_full队中删除.\n\n#### extent_try_coalesce 合并extent\n\n```c\nstatic extent_t *\nextent_try_coalesce(tsdn_t *tsdn, arena_t *arena,\n    extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,\n    extent_t *extent, bool *coalesced, bool growing_retained) {\n\t/*\n\t * Continue attempting to coalesce until failure, to protect against\n\t * races with other threads that are thwarted by this one.\n\t */ \n    // 这里的again 是多线程防止竞争用的, 如果有别的线程再操作, 这里会直接退出while 循环\n\tbool again;\n\tdo {\n\t\tagain = false;\n\n\t\t/* Try to coalesce forward. 前向合并*/  \n\t\textent_t *next = extent_lock_from_addr(tsdn, rtree_ctx,\n\t\t    extent_past_get(extent));\n\t\tif (next != NULL) {\n\t\t\t/*\n\t\t\t * extents->mtx only protects against races for\n\t\t\t * like-state extents, so call extent_can_coalesce()\n\t\t\t * before releasing next's pool lock.\n\t\t\t */\n\t\t\tbool can_coalesce = extent_can_coalesce(arena, extents,\n\t\t\t    extent, next);\n\n\t\t\textent_unlock(tsdn, next);\n\n\t\t\tif (can_coalesce && !extent_coalesce(tsdn, arena,\n\t\t\t    r_extent_hooks, extents, extent, next, true,\n\t\t\t    growing_retained)) {\n\t\t\t\tif (extents->delay_coalesce) {\n\t\t\t\t\t/* Do minimal coalescing. */\n\t\t\t\t\t*coalesced = true;\n\t\t\t\t\treturn extent;\n\t\t\t\t}\n\t\t\t\tagain = true;\n\t\t\t}\n\t\t}\n\n\t\t/* Try to coalesce backward. 后向合并*/\n\t\textent_t *prev = extent_lock_from_addr(tsdn, rtree_ctx,\n\t\t    extent_before_get(extent));\n\t\tif (prev != NULL) {\n\t\t\tbool can_coalesce = extent_can_coalesce(arena, extents,\n\t\t\t    extent, prev);\n\t\t\textent_unlock(tsdn, prev);\n\n\t\t\tif (can_coalesce && !extent_coalesce(tsdn, arena,\n\t\t\t    r_extent_hooks, extents, extent, prev, false,\n\t\t\t    growing_retained)) {\n\t\t\t\textent = prev;\n\t\t\t\tif (extents->delay_coalesce) {\n\t\t\t\t\t/* Do minimal coalescing. */\n\t\t\t\t\t*coalesced = true;\n\t\t\t\t\treturn extent;\n\t\t\t\t}\n\t\t\t\tagain = true;\n\t\t\t}\n\t\t}\n\t} while (again);\n\n\tif (extents->delay_coalesce) {\n\t\t*coalesced = false;\n\t}\n\treturn extent;\n}\n```\n\n去除多线程的逻辑外, 大致的流程是\n\n```erlang\n-->extent_t * extent_try_coalesce(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, \n                                  extents_t *extents, extent_t *extent, bool *coalesced, bool growing_retained)\n|  \\ - while(again)\n   |  \\ - extent_t *next = extent_lock_from_addr(tsdn, rtree_ctx, extent_past_get(extent)) #\"查找后一个extent\"\n      | - bool can_coalesce = extent_can_coalesce(arena, extents, extent, next) #\"查看是否可以合并\"\n      | - < can_coalesce? && !extent_coalesce(tsdn, arena, r_extent_hooks, extents, extent, next, true, growing_retained) >\n   |<-| N\\ - again = false\n      | - extent_lock_from_addr(tsdn, rtree_ctx, extent_before_get(extent)) #\"查找前一个extent\"\n      | - bool can_coalesce = extent_can_coalesce(arena, extents, extent, prev)  \n      | - < can_coalesce? && !extent_coalesce(tsdn, arena, r_extent_hooks, extents, extent, next, false, growing_retained) >\n   |<-| N\\ - again = false\n```\n\n#### extent_coalesce 合并extent\n\n> 看起来没有实现, 没有配置合并, 如果配置了, 会走`extent_dss_mergeable(extent a, extent b)`流程\n\n```erlang\n--> bool extent_coalesce(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,\n      extents_t *extents, extent_t *inner, extent_t *outer, bool forward, bool growing_retained)\n|  \\ - extent_merge_impl(tsdn, arena, r_extent_hooks, forward ? inner : outer, forward ? outer : inner, growing_retained)\n          #\"根据forward 标记倒换 inner outer次序, 根据上文看第二次后向合并的过程, forward是false, 则extent 是outer, back extent是 inner\"\n   |  \\ - < *r_extent_hooks == &extent_hooks_default? >\n      | Y\\ - err = extent_merge_default_impl(extent_base_get(a), extent_base_get(b))\n         |  \\ - err = extent_merge_default_impl(extent_base_get(a), extent_base_get(b)) #\"空实现?\" ??//TODO\n            |  \\ - <have_dss? JEMALLOC_DSS? > # \"这个宏好像没开\"\n               |  \\ - return !extent_dss_mergeable(addr_a, addr_b)\n      | N\\ - err = (*r_extent_hooks)->merge(*r_extent_hooks, extent_base_get(a), extent_size_get(a), extent_base_get(b),\n\t\t    extent_size_get(b), extent_committed_get(a), arena_ind_get(arena))\n         | - extent_merge_default(...)\n         |  \\ - extent_merge_default_impl(void *addr_a, void *addr_b)\n```\n\n\n\n","tags":["Android","heap","jemalloc"],"categories":["Android","稳定性"]},{"title":"jemalloc5 脚本实现.md","url":"/2020/07/18/稳定性/jemalloc5 脚本实现/","content":"\n# 实现思路\n\n沿着内存dump的步骤\n\n### small slab\n\n先忽略tcache的话, 需要关注的结构 `je_arenas`, `arena`, `bins` , `bin->slabcur`  `bin->slabs_nofull`, `bin->slabs_full`, `je_bin_infos` `extent_s`\n\n```shell\np je_arenas\np (*(struct arena_s*)je_arenas[0])\np (*(struct arena_s*)je_arenas[0]).bins\np (*(struct arena_s*)je_arenas[0]).bins[0]  0-NSIZES\np je_bin_infos\np (*(struct arena_s*)je_arenas[0]).bins[0].slabcur\np *(struct extent_s*)  [p (*(struct arena_s*)je_arenas[0]).bins[0].slabcur] #取slabcur 的slab\np (*(struct arena_s*)je_arenas[0]).extents_dirty\n```\n\n> extent 元信息中关于ind的信息?\n>\n> extent_szind_get\n>\n> (extent->e_bits & EXTENT_BITS_SZIND_MASK) >> EXTENT_BITS_SZIND_SHIFT\n\n\n\n```c\nEXTENT_BITS_ARENA_WIDTH = 12 ;\nEXTENT_BITS_ARENA_SHIFT =0;\nEXTENT_BITS_ARENA_MASK =((((1 << (12)) - 1)) << (0));  //4095 111111111111    fff\nEXTENT_BITS_SLAB_WIDTH =1;\nEXTENT_BITS_SLAB_SHIFT =(12 + 0);\nEXTENT_BITS_SLAB_MASK =((((1 << (1)) - 1)) << ((12 + 0))); //4096 1000000000000     1000\nEXTENT_BITS_COMMITTED_WIDTH = 1;\nEXTENT_BITS_COMMITTED_SHIFT = (1 + (12 + 0));\nEXTENT_BITS_COMMITTED_MASK =((((1 << (1)) - 1)) << ((1 + (12 + 0)))); //8192  10000000000000   2000\nEXTENT_BITS_DUMPABLE_WIDTH = 1;\nEXTENT_BITS_DUMPABLE_SHIFT = (1 + (1 + (12 + 0))) ;\nEXTENT_BITS_DUMPABLE_MASK =((((1 << (1)) - 1)) << ((1 + (1 + (12 + 0))))); //16384 100000000000000 4000\nEXTENT_BITS_ZEROED_WIDTH =1;\nEXTENT_BITS_ZEROED_SHIFT =(1 + (1 + (1 + (12 + 0))));  //15   1111 f \nEXTENT_BITS_ZEROED_MASK = ((((1 << (1)) - 1)) << ((1 + (1 + (1 + (12 + 0)))))); //32768  1000000000000000 8000\nEXTENT_BITS_STATE_WIDTH = 2;\nEXTENT_BITS_STATE_SHIFT = (1 + (1 + (1 + (1 + (12 + 0))))); //16\nEXTENT_BITS_STATE_MASK =((((1 << (2)) - 1)) << ((1 + (1 + (1 + (1 + (12 + 0))))))); //196608  110000000000000000 30000\nEXTENT_BITS_SZIND_WIDTH =8;\nEXTENT_BITS_SZIND_SHIFT =(2 + (1 + (1 + (1 + (1 + (12 + 0))))));  // 18 10010 12 \nEXTENT_BITS_SZIND_MASK =((((1 << (8)) - 1)) << ((2 + (1 + (1 + (1 + (1 + (12 + 0)))))))); // 66846720 11111111000000000000000000 3FC0000\nEXTENT_BITS_NFREE_WIDTH =((12 - 3) + 1);    //10 1010 a \nEXTENT_BITS_NFREE_SHIFT =(8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))));    //26 11010 1a \nEXTENT_BITS_NFREE_MASK =((((1 << (((12 - 3) + 1))) - 1)) << ((8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))))));  // 68652367872 111111111100000000000000000000000000 FFC000000 \nEXTENT_BITS_SN_SHIFT =(((12 - 3) + 1) + (8 + (2 + (1 + (1 + (1 + (1 + (12 + 0)))))))); // 36 100100 24\nEXTENT_BITS_SN_MASK =(18446744073709551615 << (((12 - 3) + 1) + (8 + (2 + (1 + (1 + (1 + (1 + (12 + 0))))))))); //  FFFFFFFFFFFFFFFF000000000 \n```\n\n```c\ne_bits = 29863505920\n11011110100000000001111000000000000\n```\n\n通过rtree 信息直接检索所有的extent\n\n```shell\np je_extents_rtree.root #遍历R树 是一个1<<18 容量的数组, root是头指针\np je_extents_rtree.root[x].child # 每一个都是1个 1<<18容量的数组, child是头指针, 需要遍历非0x0的有效数\n#最后找出有效的叶子节点\n```\n\n```c\nstruct rtree_leaf_elm_s {\n\t/*\n\t * Single pointer-width field containing all three leaf element fields.\n\t * For example, on a 64-bit x64 system with 48 significant virtual\n\t * memory address bits, the index, extent, and slab fields are packed as\n\t * such:\n\t *\n\t * x: index\n\t * e: extent\n\t * b: slab\n\t *\n\t *   00000000 xxxxxxxx eeeeeeee [...] eeeeeeee eeee000b\n\t */\n\tatomic_p_t\tle_bits;\n};\nJEMALLOC_ALWAYS_INLINE extent_t *\nrtree_leaf_elm_bits_extent_get(uintptr_t bits) {\n\t/*\n\t * aarch64 doesn't sign extend the highest virtual address bit to set\n\t * the higher ones.  Instead, the high bits gets zeroed.\n\t */\n\tuintptr_t high_bit_mask = ((uintptr_t)1 << LG_VADDR) - 1  = (1 << 48) - 1;\n\t/* Mask off the slab bit. */\n\tuintptr_t low_bit_mask = ~(uintptr_t)1;\n\tuintptr_t mask = high_bit_mask & low_bit_mask; // mask是48位的, 最后一位是0, 其余全1\n\treturn (extent_t *)(bits & mask);\n}\n```\n\n![img](/home/mi/Pictures/flow/jemalloc_tree.drawio.svg)\n\n```c\neg:\nslab对应的base地址是  0x7a45207040\n# 查看e_addr的地址为extent分配块的地址, 其中存放了各个region\n(gdb) p *(struct extent_s*)0x7a45207040\n$7 = {\n  e_bits = 29863505920, \n  e_addr = 0x7a45009000, \n  {\n    e_size_esn = 4096, \n    e_bsize = 4096\n  }, \n  ql_link = {\n    qre_next = 0x7a45207040, \n    qre_prev = 0x7a45207040\n  }, \n  ph_link = {\n    phn_prev = 0x0, \n    phn_next = 0x0, \n    phn_lchild = 0x0\n  }, \n  {\n    e_slab_data = {\n      bitmap = {2814749767106560, 18446744073709551404, 18446744073709551615, 18446744073709551615, 18446744073709551615, 18446744073709551615, 18446744073709551615, 18446744073709551615}\n    }, \n    e_prof_tctx = {\n      repr = 0xa000000000000\n    }\n  }\n}\n\n# rtree 第一级节点\n  0x7a45009000>>30                                                                                                               \nOut[60]: 489\n (gdb) p je_extents_rtree.root[489].child\n$23 = {\n  repr = 0x7a44c000c0\n}\n# rtree 第二级节点    \nIn [62]: 0x7a45009000>>12 & ((1<<18)-1)                                                                                                 \nOut[62]: 20489\n# 算相对 0x7a44c000c0 的偏移量    \n20489*8 + 0x7a44c000c0 = 0x7a44c28108   \n# 查看 0x7a44c28108 的内容\n(gdb) x/a 0x7a44c28108\n0x7a44c28108:\t0x7a45207041\n# 其index是0\n0x7a45207041 >> 48 = 0    \n```\n\n","tags":["arm","heap","jemalloc"],"categories":["稳定性"]},{"title":"搭建gdb python 脚本开发环境","url":"/2020/07/18/稳定性/搭建gdb python 脚本开发环境/","content":"\n厂商或者系统继承的交叉工具链中的 gdb 一般不支持 python.\n或者即使支持python, 由于路径问题, 很难与当前系统中使用的python 配合. 如\n\n- 出现python 第三方库不兼容问题等\n- 缺少第三方库, 使用系统下载的第三方库不能嵌入到 gdb 中使用等问题.\n\n因此, 我们在需要定制gdb脚本时往往需要自己动手编译交叉工具链的gdb.  \n\n# 下载编译gdb源码\n\n[https://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz](https://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz)\n\n```bash\ntar gdb-9.2.tar.xz\ncd gdb-9.2\nmkdir build\n../configure --target=mips-mti-elf --prefix=/home/mi/program/mips-gdb \\\n--enable-unicode=ucs4 \\\n--with-python=/usr \\\n--with-auto-load-dir=$debugdir:$datadir/auto-load \\\n--with-auto-load-safe-path=$debugdir:$datadir/auto-load \\\n--with-expat --without-libunwind-ia64 --without-lzma --without-babeltrace --without-intel-pt --disable-libmcheck --without-mpfr --without-guile\nmake\nmake install\n```\n\n这里注意的地方, `target` `prefix` 参数需要自己填\n\n1. target 这个该怎么填, 可以用这个简单方法, 用系统继承或厂商提供的gdb, 执行下, 在gdb环境下执行`show configuration`, 看`target`是什么, 这里就填什么\n2. prefix, 填编译gdb完成后安装到的位置, 添加到环境变量中\n3. `with-python` 选项是查找 `python` 的库的位置, 简单来说就是你想定制的 gdb 用的 python 环境是哪个 python 环境, 这里就填哪个目录, ubuntu 等这类 linux 一般会在/usr 下默认配置好 python2, 你如果想使用自己定制的 python, 如使用 `pyenv` 或 `conda``virtualenv` 等定制的 python, 则需要填响应的 python 所在的目录. 后面在 gdb 环境下使用 python 报缺少三方库, 则需要用对应环境的 `pip` 安装对应的库/组件.\n\n# 使用 gdb 定制 python 脚本\n\n使用上述步骤编译安装的gdb即可, 再进行gdb 环境下定制脚本的开发","tags":["arm"],"categories":["稳定性"]},{"title":"signal 相关整理","url":"/2020/07/18/稳定性/signal 相关/","content":"\n> android r base\n\n# 信号相关流程梳理\n\n程序分为两种：\n **1.`静态链接`:** 由链接器在链接时将库的内容添加到可执行程序中的做法，最大缺点是生成的可执行文件太大，需要更多的系统资源，在装入内存也会消耗更多的时间。\n **2.`动态链接`:** 将独立的模块先编译成动态库，程序运行有需要它们时才加载，最大缺点是可执行程序依赖分别存储的库文件才能正确执行。\n 在Android中，大部分都是动态链接，而只有init等少部分是静态链接，因此native程序也是动态链接程序，动态链接程序是需要链接器才能跑起来，<span style=\"color: green\">liner</span>就是Android的链接器。\n liner也是在程序的进程空间内，当内核将应用程序加载起来后，并不是先跑应用程序代码，而是先跑liner。`linker`负责将应用程序所需的库加载到进程空间内，之后才跑应用程序代码。\n\n绝大多数的native app都是以linker为入口(<span style=\"color: red\">动态连接的程序</span>),在启动时先由汇编跳转到__link_init函数.\n\n[-> arch/arm64/begin.S]\n\n```assembly\nENTRY(_start)\n  // Force unwinds to end in this function.\n  .cfi_undefined x30\n\n  mov x0, sp\n  bl __linker_init\n\n  /* linker init returns the _entry address in the main image */\n  br x0\nEND(_start)\n```\n\n## 到debuggerd_init的调用链\n\n```erlang\n -- bl __linker_init\n\t| - extern \"C\" ElfW(Addr) __linker_init(void* raw_args) % bionic/linker/linker_main.cpp\n\t   \\ - __linker_init_post_relocation(KernelArgumentBlock& args, soinfo& tmp_linker_so)\n          \\ - return start_address = linker_main(args, exe_to_load); \n\t\t\t \\ - ElfW(Addr) linker_main(KernelArgumentBlock& args, const char* exe_to_load)\n\t\t\t\t\\ - linker_debuggerd_init(); % Register the debuggerd signal handler. [ linker_debuggerd_android.cpp ]\n\t\t\t\t\t\\ - debuggerd_init(debuggerd_callbacks_t* callbacks) %  [debuggerd/handler/debuggerd_handler.cpp ]\n```\n\n```c++\nvoid linker_debuggerd_init() {\n  debuggerd_callbacks_t callbacks = {\n    .get_abort_message = []() {\n      return __libc_shared_globals()->abort_msg;\n    },\n    .post_dump = &notify_gdb_of_libraries,\n    .get_gwp_asan_state = []() {\n      return __libc_shared_globals()->gwp_asan_state;\n    },\n    .get_gwp_asan_metadata = []() {\n      return __libc_shared_globals()->gwp_asan_metadata;\n    },\n  };\n  debuggerd_init(&callbacks);\n}\n```\n\n## debuggerd_init\n\n所在库 /home/mi/work_space/miui-r-umi-dev/system/core/debuggerd/handler/debuggerd_handler.cpp `libdebuggerd_handler_core`\n\n```c++\nvoid debuggerd_init(debuggerd_callbacks_t* callbacks) {\n  if (callbacks) {\n    g_callbacks = *callbacks;\n  } \n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  sigfillset(&action.sa_mask);\n  2. action.sa_sigaction = debuggerd_signal_handler;\n  action.sa_flags = SA_RESTART | SA_SIGINFO;\n\n  // Use the alternate signal stack if available so we can catch stack overflows.\n  action.sa_flags |= SA_ONSTACK;\n1.   debuggerd_register_handlers(&action);\n}\n\n1.-> static void __attribute__((__unused__)) debuggerd_register_handlers(struct sigaction* action) {\n  char value[PROP_VALUE_MAX] = \"\";\n    // 注意属性控制 signal的转发 (ro.debuggable=1 && debug.debuggerd.disable=1) 时关掉, 不由linker进行监控 其他情况下开启监控\n  bool enabled =\n      !(__system_property_get(\"ro.debuggable\", value) > 0 && !strcmp(value, \"1\") &&\n        __system_property_get(\"debug.debuggerd.disable\", value) > 0 && !strcmp(value, \"1\"));\n  if (enabled) {\n    sigaction(SIGABRT, action, nullptr);\n    sigaction(SIGBUS, action, nullptr);\n    sigaction(SIGFPE, action, nullptr);\n    sigaction(SIGILL, action, nullptr);\n    sigaction(SIGSEGV, action, nullptr);\n    sigaction(SIGSTKFLT, action, nullptr);\n    sigaction(SIGSYS, action, nullptr);\n    sigaction(SIGTRAP, action, nullptr);\n  }\n  // DEBUGGER_ACTION_DUMP_TOMBSTONE and DEBUGGER_ACTION_DUMP_BACKTRACE are both\n  // triggered via BIONIC_SIGNAL_DEBUGGER\n  sigaction(BIONIC_SIGNAL_DEBUGGER, action, nullptr);\n}\n\n```\n\n信号的处理函数为 `debuggerd_signal_handler`\n\n### debuggerd_signal_handler\n\n连接到bionic上的native程序(C/C++)出现异常时，kernel会发送相应的signal； 当进程捕获致命的signal，通知debuggerd调用ptrace来获取有价值的信息(发生crash之前)。\n\n```c++\nstatic void debuggerd_signal_handler(int signal_number, siginfo_t* info, void* context) {\n  if (signal_number == BIONIC_SIGNAL_DEBUGGER) {\n    if (info->si_code == SI_QUEUE && info->si_pid == __getpid()) {\n      // Allow for the abort message to be explicitly specified via the sigqueue value.\n      // Keep the bottom bit intact for representing whether we want a backtrace or a tombstone.\n      if (si_val != kDebuggerdFallbackSivalUintptrRequestDump) {\n        abort_message = reinterpret_cast<void*>(si_val & ~1);\n        info->si_ptr = reinterpret_cast<void*>(si_val & 1);\n      }\n    }\n  } else {\n      //传入形参的callback的定义的字段\n    if (g_callbacks.get_abort_message) {\n      abort_message = g_callbacks.get_abort_message();\n    }\n    if (g_callbacks.get_gwp_asan_state) {\n      gwp_asan_state = g_callbacks.get_gwp_asan_state();\n    }\n    if (g_callbacks.get_gwp_asan_metadata) {\n      gwp_asan_metadata = g_callbacks.get_gwp_asan_metadata();\n    }\n  }\n    \n  if (si_val == kDebuggerdFallbackSivalUintptrRequestDump ||\n      prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) == 1) {\n    //   prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) == 1 条件生效\n    //  A value of 1 indicates execve(2) will operate in the privilege-restricting mode described above\n    debuggerd_fallback_handler(info, static_cast<ucontext_t*>(context), abort_message);      \n    resend_signal(info);\n    return;\n  }\n    /*\n * Writes a summary of the signal to the log file.  We do this so that, if\n * for some reason we're not able to contact debuggerd, there is still some\n * indication of the failure in the log.\n */\n    // 防止无法连接debuggerd 时, 仍可以输出部分crash信息.\n  log_signal_summary(info);\n    {\n          async_safe_format_log(ANDROID_LOG_FATAL, \"libc\",\n                        \"Fatal signal %d (%s), code %d (%s%s)%s in tid %d (%s), pid %d (%s)\",\n                        info->si_signo, get_signame(info), info->si_code, get_sigcode(info),\n                        sender_desc, addr_desc, __gettid(), thread_name, self_pid, main_thread_name);\n    }\n    debugger_thread_info thread_info = {\n        .crashing_tid = __gettid(),\n        .pseudothread_tid = -1,\n        .siginfo = info,\n        .ucontext = context,\n        .abort_msg = reinterpret_cast<uintptr_t>(abort_message),\n        .fdsan_table = reinterpret_cast<uintptr_t>(android_fdsan_get_fd_table()),\n        .gwp_asan_state = reinterpret_cast<uintptr_t>(gwp_asan_state),\n        .gwp_asan_metadata = reinterpret_cast<uintptr_t>(gwp_asan_metadata),\n  };\n  // Set PR_SET_DUMPABLE to 1, so that crash_dump can ptrace us.\n    // Set  the  state  of the \"dumpable\" flag, which determines whether core dumps are produced for the calling process upon\n         //     delivery of a signal whose default behavior is to produce a core dump.\n  if (prctl(PR_SET_DUMPABLE, 1) != 0) {\n     fatal_errno(\"failed to set dumpable\");\n  }\n    // PR_SET_PTRACER_ANY，对于调用进程将有效禁用Yama引入的ptrace限制。\n  if (prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY) != 0) {...}\n  // fork crash_dump 进程, 传入的是线程的信息\n  pid_t child_pid =\n->    clone(debuggerd_dispatch_pseudothread, pseudothread_stack,\n          CLONE_THREAD | CLONE_SIGHAND | CLONE_VM | CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID,\n          &thread_info, nullptr, nullptr, &thread_info.pseudothread_tid);\n  // 重置为默认信号处理函数\n  if (signal_number != DEBUGGER_SIGNAL) {\n    signal(signal_number, SIG_DFL);\n  }\n  if (info->si_signo == BIONIC_SIGNAL_DEBUGGER) {\n    // If the signal is fatal, don't unlock the mutex to prevent other crashing threads from\n    // starting to dump right before our death.\n    pthread_mutex_unlock(&crash_mutex);\n  } else {\n    // Resend the signal, so that either gdb or the parent's waitpid sees it.\n    // 重发信号, 可以让gdb strace等处理信号\n    resend_signal(info);\n  }\n    \n}\n```\n\n### debuggerd_dispatch_pseudothread\n\n```c++\nstatic int debuggerd_dispatch_pseudothread(void* arg) { \n  // 创建管道, 用于父子进程通信\n  unique_fd input_read, input_write;\n  unique_fd output_read, output_write;\n  if (!Pipe(&input_read, &input_write) != 0 || !Pipe(&output_read, &output_write)) {\n    fatal_errno(\"failed to create pipe\");\n  }\n  struct iovec iovs[] = {\n      {.iov_base = &version, .iov_len = sizeof(version)},\n      {.iov_base = thread_info->siginfo, .iov_len = sizeof(siginfo_t)},\n      {.iov_base = thread_info->ucontext, .iov_len = sizeof(ucontext_t)},\n      {.iov_base = &thread_info->abort_msg, .iov_len = sizeof(uintptr_t)},\n      {.iov_base = &thread_info->fdsan_table, .iov_len = sizeof(uintptr_t)},\n      {.iov_base = &thread_info->gwp_asan_state, .iov_len = sizeof(uintptr_t)},\n      {.iov_base = &thread_info->gwp_asan_metadata, .iov_len = sizeof(uintptr_t)},\n  };\n  ssize_t rc = TEMP_FAILURE_RETRY(writev(output_write.get(), iovs, arraysize(iovs)));\n    //  Don't use fork(2) to avoid calling pthread_atfork handlers. 没有直接使用fork, 而是用的clone函数\n  pid_t crash_dump_pid = __fork();\n    {\n        return clone(nullptr, nullptr, 0, nullptr);\n    }\n   // fork 失败\n  if (crash_dump_pid == -1) {\n    async_safe_format_log(ANDROID_LOG_FATAL, \"libc\",\n                          \"failed to fork in debuggerd signal handler: %s\", strerror(errno));\n      // It returns 0 in the child process and returns the PID of the child in the parent. 0是子进程 >0是父进程\n  } else if (crash_dump_pid == 0) {\n      // STDOUT_FILENO = input_write  STDIN_FILENO = output_read\n    TEMP_FAILURE_RETRY(dup2(input_write.get(), STDOUT_FILENO));\n    TEMP_FAILURE_RETRY(dup2(output_read.get(), STDIN_FILENO));\n      // 替换为 crash_dump 本体执行, 输入变成output_read,输出变为 input_write, 注意前面的管道, output_write 是父进程用的, 対端即为 output_read, 下面注意input_read的处理\n    execle(CRASH_DUMP_PATH, CRASH_DUMP_NAME, main_tid, pseudothread_tid, debuggerd_dump_type,\n           nullptr, nullptr);\n  }\n  // 父进程中, 读取子进程的 printf的log\n  rc = TEMP_FAILURE_RETRY(read(input_read.get(), &buf, sizeof(buf)));\n    // crash_dump is ptracing us, fork off a copy of our address space for it to use. ?\n  create_vm_process();\n  // 等待crash_dump结束\n  if (TEMP_FAILURE_RETRY(waitpid(crash_dump_pid, &status, 0)) == -1) {\n    async_safe_format_log(ANDROID_LOG_FATAL, \"libc\", \"failed to wait for crash_dump helper: %s\",\n                          strerror(errno));\n  } else if (WIFSTOPPED(status) || WIFSIGNALED(status)) {\n    async_safe_format_log(ANDROID_LOG_FATAL, \"libc\", \"crash_dump helper crashed or stopped\");\n  }  \n}\n```\n\n","tags":["Android","signal"],"categories":["Android","稳定性"]},{"title":"arm gdb 调试","url":"/2020/07/18/稳定性/arm64 指令debug/","content":"\n# 1. arm64 寄存器和指令\n\n## 1.1. 寄存器\n\narm64 有34个寄存器, 包含31个通用寄存器, SP PC CPSR\n\n> 寄存器中可以存地址, 也可以存值.\n\n| 寄存器     | 位数  | 描述                                                                        |\n| ------- | --- | ------------------------------------------------------------------------- |\n| x0-x30  | 64  | 通用寄存器, 可以作 位使用: w0-w30 (访问寄存器的低位)                                         |\n| x0-x7   | 64  | 用于子程序调用时参数传递(形参), x0 还用于返回值传递                                             |\n| FP(x29) | 64  | 当前栈帧的栈底 (android上 向上增长), 栈顶地址 < 栈底                                        |\n| LR(x30) | 64  | 程序链接寄存器, 保存子程序结束后需要执行的下一条指令. <span style=\"color: green\">即谁调用了当前函数.</span> |\n| SP      | 64  | 保存栈指针, 使用SP/WSP来进行对栈寄存器的访问                                                |\n| PC      | 64  | 程序计数器, 俗称PC指针, 总是指向即将执行的下一条指令, 在arm64中, 软件不能修改pc寄存器                       |\n| CPSR    | 64  | 状态寄存器,    NZCV是状态寄存器的条件标志位，分别代表运算过程中产生的状态                                 |\n\n> 我们可以根据FP和SP寄存器回溯函数调用过程，通过这两个值，我们可以知道函数的栈起始地址（也就是FP寄存器的值）， 以及栈顶（也就是SP寄存器的值）。得到了m函数的栈帧，就很容易从里面提取LR寄存器的值了（FP向下偏移8个字节即为LR），也就知道了谁调用了当前函数。以此类推，可以得到一个完整的函数调用链（一般回溯到 main函数或者线程入口函数就没必要继续了）。实际上，回溯过程中我们并不需要知道栈顶SP，只要FP就够了\n\nhttps://juejin.im/post/6844903923719864333\n\n### 1.1.1. arm64 约定\n\n- `x0 ~ x7` 分别会存放方法的前 8 个参数；如果参数个数超过了8个，多余的参数会存在栈上，新方法会通过栈来读取。\n- 方法的返回值一般都在 `x0` 上；如果方法返回值是一个较大的数据结构时，结果会存在 `x8` 执行的地址上。\n\n## 1.2. 虚存地址与elf 段地虚址\n\ncat /proc/pid/maps 查看用户空间的虚存映射, 栈空间自[stack] 起, 查看pc 值可确定代码当前的运行位置. 程序代码段[.text] 位于maps 的映射的 本elf 文件的映射地址\n\n![[Drawing 2022-04-11 01.04.40.excalidraw]]\n## 1.3. 小端序和大端序\n\n**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)**。\n\n字节序分为两类：Big-Endian 和 Little-Endian，引用标准的 Big-Endian 和 Little-Endian 的定义如下：\n\n- Little-Endian：就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。\n- Big-Endian：就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。\n- 网络字节序：TCP/IP各层协议将字节序定义为 Big-Endian（这与主机序相反），因此TCP/IP协议中使用的字节序通常称之为网络字节序。\n\n>  android 中是小端序, 低位字节排放在内存的低地址端，高位字节排放在内存的高地址端, 所以读字时, 字节间 `应该从右往左读`, 每个字节的读取还是`从左往右`读\n\n[常见CPU字节序](https://itimetraveler.github.io/2018/01/18/如何判断CPU是大端还是小端模式/#常见CPU的字节序)\n\n## 1.4. 寻址空间\n\nandroid上采用 39位寻址+3级页表\n\n![FA36326B-AB85-4E2E-A170-B5091504CECE](images/20200902165648.png)\n\n### 1.4.1. 查看elf 各段的地址及确认初始化段区域\n\n```shell\naarch64-linux-android-objdump -h native_test\n```\n\n- BSS段 （bss segment）通常是指用来存放程序中`未初始化的全局变量`和`初始化为0的全局变量`的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。\n- data段 该段用于存储`初始化非0的全局变量`和静态局部变量，`初始化为0的全局变量`出于编译优化的策略还是被保存在BSS段\n- rodata段     常量区，用于存放常量数据，ro就是Read Only之意。但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：\n  - 有些立即数与指令编译在一起直接放在代码段。\n  - 对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份\n  - 用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。\n  - 有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率\n- text段    text段是用于存放程序代码的，编译时确定,只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。\n- stack段   也就是栈段，常说的堆栈段之一，是由系统负责申请释放，其操作方式类似stack，用于存储参数变量及局部变量，其实函数的执行也是stack的方式，所以才有了递归\n- heap段    也就是俗称的堆，它由用户申请和释放，申请时至少分配虚存，当真正存储数据时才分配相应的实存，释放时也并非立即释放实存，而是可能被重复利用\n- dynamic 段 外部符号表区, gdb调试时可以看到一些符号表信息, 库函数外部可见时, 相关符号表会在该段中\n- sym_tab 段, 外部+内部符号表区, 内部可见(如static 定义的函数), 相关符号在该段中.\n\n#### 1.4.1.1. hexdump打印常量等段的内容\n\n找到基址和偏移 大小后 \n\n```shell\n 11 .rodata       00000134  0000000000000dc8  0000000000000dc8  00000dc8  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DAT\n hexdump native_test -s 0x00000dc8 -n 308  -C\n```\n\n>  注意一定要使用`0x`覆盖地址, 不然是打印的10进制的偏移\n\n## 1.5. arm64 指令\n\nhttps://wiki.n.miui.com/pages/viewpage.action?pageId=340834589\n\nhttps://juejin.im/post/6844903816362459144\n\n>  `[]`的意思是取地址的值, 不要跟地址弄混了\n\n### 1.5.1. stp ldp str ldr stur ldur指令\n\n压栈入栈指令, 对于一个64位地址, 将64位地址值压入栈中, 需要有8个字节来存储.<span style=\"color: red\">一个地址只能存一个字节, 与位长度没有关系</span> , stp 两个寄存器则需要16个字节. 打印寄存器的值时是按照`字`来打印的, 64位上一个`字`是8个字节\n\n`str w9, [sp, #0x8]` ; 将寄存器 w9 中的值保存到栈内存 [sp + 0x8] - [sp + 0x8 + 0x4 ] 处\n\n`stp x29, x30, [sp, #0x10]` ; 将 x29, x30 的值存入 [sp + 0x10] - [sp + 0x10 + 0x10] 字节的位置\n\nstur： 同 str 将寄存器中的值写入到内存中（一般用于 负 地址运算中），如：`stur w10, [x29, #-0x4]` ; 将寄存器 w10 中的值保存到栈内存 [x29 - 0x04] 处 \n\nldur： 同 ldr 将内存中的值读取到寄存器中（一般用于 负 地址运算中），如：`ldur w8, [x29, #-0x4]` ; 将栈内存 [x29 - 0x04] 处的值读取到 w8 寄存器中 \n\n### 1.5.2. ldrsw\n\n读取内存地址的值给寄存器。\n\nLDRSW x9 ,[x8 ,x9 ,lsl #2] 为将以x8寄存器为基地址加上x9寄存器向左偏移两个单位的值后取其地址的值给x9寄存器。\n\n### 1.5.3. adrp\n\n范围寻址, 通俗来讲，ADRP指令就是先进行PC+imm（偏移值）然后找到lable所在的一个4KB的页，然后取得label的基址，再进行偏移去寻址\n\noffset 左移12位(4K对齐), PC的低12位抹0 + offset 4k对齐的结果, 得到一个基址.\n\n```arm\n    1118:    f0ffffe8     adrp    x8, 0 <abitag-0x2c0>\n    111c:    91123108     add    x8, x8, #0x48c\n```\n\n### 1.5.4. 指令列表附录\n\n| 指令                 | 作用                                                |\n| ------------------ | ------------------------------------------------- |\n| ADC                | 带进位的位数加法                                          |\n| ADD                | 位数相加                                              |\n| SUB                | 位减法                                               |\n| AND                | 位数的逻辑与                                            |\n| B                  | 在M空间内的相对跳转指令                                      |\n| BR                 | 跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。       |\n| brk                | 可以理解为跳转指令特殊的一种                                    |\n| BKPT               | 断点指令                                              |\n| BL                 | 带链接的相对跳转指令-(1) 将下一条指令的地址放入lr(x30)寄存器，(2)转到标号出执行指令 |\n| BLX                | 带链接的切换跳转                                          |\n| BX                 | 切换跳转                                              |\n| BEQ                | 相等则跳转（Branch if EQual）                            |\n| BNE                | 不相等则跳转（Branch if Not Equal）                       |\n| BGE                | 大于或等于跳转（Branch if Greater than or Equa）           |\n| BGT                | 大于跳转（Branch if Greater Than）                      |\n| BIC                | 位数的逻辑位清零                                          |\n| RET                | 默认使用lr(x30)寄存器的值通过底层指令提示CPU此处作为下条指令地址（ARM64平台的特色指 |\n| BLE                | 小于或等于跳转（Branch if Less than or Equal）             |\n| BLEQ               | 带链接等于跳转（Branch with Link if EQual）                |\n| BLLT               | 带链接小于跳转（Branch with Link if Less Than）            |\n| BLTt               | 小于跳转（Branch if Less Than）                         |\n| CDP CDP2           | 协处理器数据处理操作                                        |\n| CLZ                | 零计数                                               |\n| CMN                | 比较两个数的相反数                                         |\n| CMP                | 位数比较                                              |\n| EOR                | 位逻辑异或                                             |\n| LDC LDC2           | 从协处理器取一个或多个位值                                     |\n| LDM                | 从内存送多个位字到ARM寄存器                                   |\n| STUR               | 把寄存器的值(位)存到一个内存的虚地址内间(一般等同str)                    |\n| STR                | 把寄存器的值(128位/64位)存到一个内存的虚地址内间                      |\n| LDP                | str的变种，可以同时操作两个寄存器                                |\n| LDR（load register） | 从内存地址取一个单个的位值加载入通用寄存器                             |\n| STD                | ldr的变种，可以同时操作两个寄存器                                |\n| DLP（load register） | 从内存地址取一个单个的64位值加载入通用寄存器                           |\n| MCR MCR2 MCRR      | 从寄存器送数据到协处理器                                      |\n| MLA                | 位乘累加                                              |\n| MOV                | 传送一个位数到寄存器                                        |\n| MRC MRC2 MRRC      | 从协处理器传送数据到寄存器                                     |\n| MRS                | 把状态寄存器的值送到通用寄存器                                   |\n| MSR                | 把通用寄存器的值传送到状态寄存器                                  |\n| MUL                | 位乘                                                |\n| MVN                | 把一个位数的逻辑“非”送到寄存器                                  |\n| ORR                | 位逻辑或                                              |\n| PLD                | 预装载提示指令                                           |\n| QADD               | 有符号位饱和加                                           |\n| QDADD              | 有符号双位饱和加                                          |\n| QSUB               | 有符号位饱和减                                           |\n| QDSUB              | 有符号双位饱和减                                          |\n| RSB                | 逆向位减法                                             |\n| RSC                | 带进位的逆向法减法                                         |\n| SBC                | 带进位的位减法                                           |\n| SMLAxy             | 有符号乘累加(16位*16位)+位=位                               |\n| SMLAL              | 64位有符号乘累加((位*位)+64位=64位)                          |\n| SMALxy             | 64位有符号乘累加((位*位)+64位=64位)                          |\n| SMLAWy             | 号乘累加((位*16位)>>16位)+位=位                            |\n| SMULL              | 64位有符号乘累加(位*位)=64位                                |\n| SMULxy             | 有符号乘(16位*16位=位)                                   |\n| SMULWy             | 有符号乘(位*16位>>16位=位)                                |\n| STC STC2           | 从协处理器中把一个或多个位值存到内存                                |\n| STM                | 把多个位的寄存器值存放到内存                                    |\n| SWI                | 软中断                                               |\n| SWP                | 把一个字或者一个字节和一个寄存器值交换                               |\n| TEQ                | 等值测试                                              |\n| TST                | 位测试                                               |\n| UMLAL              | 64位无符号乘累加((位*位)+64位=64位)                          |\n| UMULL              | 64位无符号乘累加(位*位)=64位                                |\n| B.LE               | 标号：小于等于（if判断）                                     |\n| B.LT               | 标号：小于等于（do while）                                 |\n| B.GT               | 标号：小于等于（while do）                                 |\n| B.GE               | 标号：大于等于（for）                                      |\n| B.EQ               | 标号：比较结果是等于，执行标号，否则不跳转                             |\n| B.HI               | 标号：比较结果是无符号大于，执行标号，否则不跳转                          |\n\n## 1.6. gdb调试命令表\n\n### 1.6.1. 初始化\n\n为了使 gdb 正常工作, 必须使你的程序在编译时包含调试信息，编译时尽量要加上-g参数, 关闭O2优化\n\n### 1.6.2. 暂停程序\n\n#### 1.6.2.1. 设置断点\n\nbreak命令（可以简写为b）可以用来在调试的程序中设置断点，该命令有如下四种形式： \n\n- break line-number 使程序恰好在执行给定行之前停止。\n\n- break function-name 使程序恰好在进入指定的函数之前停止。\n\n- break line-or-function if condition 如果condition（条件）是真，程序到达指定行或函数时停止。\n  \n  要想设置一个条件断点，可以利用break if命令，如下所示\n  \n  ```shell\n  break line-or-function if expr\n  例：break 46 if testsize==100\n  ```\n\n- break routine-name 在指定例程的入口处设置断点\n\n- break *address 在程序运行的内存地址处停住。\n\n如果该程序是由很多原文件构成的，你可以在各个原文件中设置断点，而不是在当前的原文件中设置断点，其方法如下：\n\n```\nbreak filename:line-number\nbreak filename:function-name\n```\n\n从断点继续运行：countinue 命令 `c`\n\n#### 1.6.2.2. 线程中断\n\nbreak [linespec] thread [threadno] [if ...]\n       linespec 断点设置所在的源代码的行号。如: test.c:12表示文件为test.c中的第12行设置一个断点。\n       threadno 线程的ID。是GDB分配的，通过输入`info threads`来查看正在运行中程序的线程信息。\n       if ...  设置中断条件。\n\n#### 1.6.2.3. 断点管理\n\n显示所有断点信息: `i b`\n\n1. 删除指定的某个断点：\n  \n   ```\n   delete breakpoint 1\n   ```\n   \n   该命令将会删除编号为1的断点，如果不带编号参数，将`删除所有的断点`\n   \n   ```\n   delete breakpoint\n   ```\n\n2. 禁止使用某个断点\n  \n   ```\n   disable breakpoint 1\n   ```\n   \n   该命令将禁止断点 1,同时断点信息的 (Enb)域将变为 n\n\n3. 允许使用某个断点\n  \n   ```\n   enable breakpoint 1\n   ```\n   \n   该命令将允许断点 1,同时断点信息的 (Enb)域将变为 y\n\n4. 清除原文件中某一代码行上的所有断点\n  \n   ```\n   clean number\n   ```\n   \n   注：number 为原文件的某个代码行的行号\n\n#### 1.6.2.4. 单步调试\n\n- step   进入的单步执行如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令`finish`\n- next  不进入的单步执行\n- *`ni` `si`* 汇编单步执行(不进入 进入)\n\n#### 1.6.2.5. 函数调用\n\n- call name 调用和执行一个函数\n\n  ```c\n  (gdb) call gen_and_sork( 1234,1,0 )\n  (gdb) call printf(“abcd”)$1=4\n  ```\n\n- finish 结束执行当前函数，显示其返回值（如果有的话） \n\n#### 1.6.2.6. 添加观察 watcher/ 设置观察点\n\n设置观察点：\n\n+ watch + [变量][表达式] 当变量或表达式值改变时即停住程序。\n+ rwatch + [变量][表达式] 当变量或表达式被`读`时，停住程序。\n+ awatch + [变量][表达式] 当变量或表达式`被读或被写`时，停住程序。\n\n#### 1.6.2.7. 设置捕捉点\n\ncatch + event 当event发生时，停住程序。event可以是下面的内容：\n\n- throw 一个C++抛出的异常。（throw为关键字）\n- catch 一个C++捕捉到的异常。（catch为关键字）\n- exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）\n- fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）\n- vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）\n- load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）\n- unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）\n\n#### 1.6.2.8. 捕捉信号\n\n`handle + [argu] + signals`\n\n+ signals：是Linux/Unix定义的信号\n  \n  - SIGINT表示中断字符信号，也就是Ctrl+C的信号，\n  - SIGBUS表示硬件故障的信号\n  - SIGCHLD表示子进程状态改变信号\n  - SIGKILL表示终止程序运行的信号，等等。\n- argu：\n  \n  - nostop  当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号\n  - stop   当被调试的程序收到信号时，GDB会停住你的程序\n  - print  当被调试的程序收到信号时，GDB会显示出一条信息\n  - noprint 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息\n  - pass or noignore  当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。\n  - nopass or ignore   当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。\n\n### 1.6.3. 查看信息\n\n#### 1.6.3.1. 查看值/查看数据\n\nprint variable    查看变量\n       print *array@len   查看数组（array是数组指针，len是需要数据长度）\n       可以通过添加参数来设置输出格式：\n\n```shell\n    /x 按十六进制格式显示变量。\n    /d 按十进制格式显示变量。\n    /u 按十六进制格式显示无符号整型。\n    /o 按八进制格式显示变量。\n    /t 按二进制格式显示变量。\n    /a 按十六进制格式显示变量。\n    /c 按字符格式显示变量。\n    /s 按字符串格式显示变量 遇到\\0 截止\n    /f 按浮点数格式显示变量。\n```\n\n#### 1.6.2.6. 查看内存地址\n\nexamine /n f u + 内存地址（指针变量）\n       n 表示显示内存长度\n       f 表示输出格式\n\n```log\n    /x 按十六进制格式显示变量。\n    /d 按十进制格式显示变量。\n    /u 按十六进制格式显示无符号整型。\n    /o 按八进制格式显示变量。\n    /t 按二进制格式显示变量。\n    /a 按十六进制格式显示变量。\n    /c 按字符格式显示变量。\n    /s 按字符串格式显示变量 遇到\\0 截止\n    /f 按浮点数格式显示变量。\n```\n\n​       u 表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节）\n​       如：\n​            x /10cw pFilePath （pFilePath为一个字符串指针，指针占4字节）\n\n> x 为examine命令的简写\n\n#### 1.6.2.7. 查看栈信息 堆栈\n\nbacktrace -n n\n\n n 表示只打印栈顶上n层的栈信息\n\n-n 表示只打印栈底上n层的栈信息。\n\n不加参数，表示打印所有栈信息。\n\n#### 1.6.2.8. 变量的检查和赋值\n\n- whatis:识别数组或变量的类型\n- ptype:比whatis的功能更强，他可以提供一个结构的定义\n- set variable:将值赋予变量\n- print 除了显示一个变量的值外，还可以用来赋值\n\n#### 1.6.2.9. info\n\n| 指令                   | 描述                                                        |\n| -------------------- | --------------------------------------------------------- |\n| info address         | Describe where symbol SYM is stored                       |\n| info all-registers   | List of all registers and their contents                  |\n| info args            | Argument variables of current stack frame                 |\n| info auxv            | Display the inferior's auxiliary vector                   |\n| info breakpoints     | Status of user-settable breakpoints                       |\n| info catch           | Exceptions that can be caught in the current stack frame  |\n| info checkpoints     | IDs of currently known forks/checkpoints                  |\n| info classes         | All Objective-C classes                                   |\n| info common          | Print out the values contained in a Fortran COMMON block  |\n| info copying         | Conditions for redistributing copies of GDB               |\n| info dcache          | Print information on the dcache performance               |\n| info display         | Expressions to display when program stops                 |\n| info extensions      | All filename extensions associated with a source language |\n| info files           | Names of targets and files being debugged                 |\n| info float           | Print the status of the floating point unit               |\n| info forks           | IDs of currently known forks/checkpoints                  |\n| info frame           | All about selected stack frame                            |\n| info functions       | All function names                                        |\n| info handle          | What debugger does when program gets various signals      |\n| `info line`          | Core addresses of the code for a source line              |\n| info linkmap         | Display the inferior's linkmap                            |\n| `info locals`        | Local variables of current stack frame                    |\n| info macro           | Show the definition of MACRO                              |\n| info mem             | Memory region attributes                                  |\n| info proc            | Show /proc process information about any running process  |\n| info program         | Execution status of the program                           |\n| `info registers`     | List of integer registers and their contents              |\n| info scope           | List the variables local to a scope                       |\n| info selectors       | All Objective-C selectors                                 |\n| info set             | Show all GDB settings                                     |\n| `info sharedlibrary` | Status of loaded shared object libraries                  |\n| info signals         | What debugger does when program gets various signals      |\n| info source          | Information about the current source file                 |\n| info sources         | Source files in the program                               |\n| `info stack`         | Backtrace of the stack                                    |\n| info symbol          | Describe what symbol is at location ADDR                  |\n| info target          | Names of targets and files being debugged                 |\n| info terminal        | Print inferior's saved terminal status                    |\n| `info threads`       | IDs of currently known threads                            |\n| info tracepoints     | Status of tracepoints                                     |\n| info types           | All type names                                            |\n| info variables       | All global and static variable names                      |\n| info vector          | Print the status of the vector unit                       |\n| info warranty        | Various kinds of warranty you do not have                 |\n| `info watchpoints`   | Synonym for `info breakpoints`                            |\n| info win             | List of all displayed windows                             |\n\n## 1.7. 基本gdb命令\n\n| 命令        | 简写  | 功能                                           |\n| --------- | --- | -------------------------------------------- |\n| file      |     | 装入想要调试的可执行文件.                                |\n| kill      | k   | 终止正在调试的程序.                                   |\n| list      | l   | 列出产生执行文件的源代码的一部分.                            |\n| next      | n   | 执行一行源代码但不进入函数内部.                             |\n| step      | s   | 执行一行源代码而且进入函数内部.                             |\n| continue  | c   | 继续执行程序，直至下一中断或者程序结束。                         |\n| run       | r   | 执行当前被调试的程序.                                  |\n| quit      | q   | 终止 gdb.                                      |\n| watch     |     | 使你能监视一个变量的值而不管它何时被改变.                        |\n| catch     |     | 设置捕捉点.                                       |\n| thread    | t   | 查看当前运行程序的线程信息.                               |\n| break     | b   | 在代码里设置断点, 这将使程序执行到这里时被挂起.                    |\n| make      |     | 使你能不退出 gdb 就可以重新产生可执行文件.                     |\n| shell     |     | 使你能不离开 gdb 就执行 UNIX shell 命令. `CTRL+D`退回到gdb |\n| print     | p   | 打印数据内容。                                      |\n| examine   | x   | 打印内存内容。                                      |\n| backtrace | bt  | 查看函数调用栈的所有信息。                                |\n","tags":["arm"],"categories":["稳定性"]},{"title":"virtual ab方案调研","url":"/2020/02/12/OTA相关/virtual ab方案调研/","content":"\n# virtual ab方案调研\n\n## 从recovery开始说起\n\n### Recovery挂载system\n\n```typescript\n- CreateSnapshotPartitions\n    | - SnapshotManager::NewForFirstStageMount #first stage mount\n       \\ - New(info) # SnapshotManager构造函数，初始化两个目录 gsid_dir_=ota metadata_dir_=/metadata/ota\n       | - ForceLocalImageManager #构造ImageManager\n         \\ - ImageManager::Open(gsid_dir_) # 初始化两个目录 metadata_dir = /metadata/gsi/ota data_dir=/data/gsi/ota\n    | - sm->NeedSnapshotsInFirstStageMount() # 调用上面SnapshotManager的实例的该函数，根据merge state确定是否进行后续步骤\n       \\ - GetCurrentSlot() != Slot::Target # 根据这个判断是不是ota后的切换slot过程，Target=2，Source=1 \n                                     # =1说明未进行ota，未进行ota就不需要挂载snapshot，return false\n       | - ReadUpdateState \n         \\ - ReadSnapshotUpdateStatus # /metadata/ota/state文件中获取ota后的merge状态\n                                      #  Unverified Merging MergeFailed 返回true\n    | - true - InitRequiredDevices({\"userdata\"}) # NeedSnapshotsInFirstStageMount 返回true时\n      \\ - InitDeviceMapper #初始化dm框架，创建uevent监听 /sys/devices/virtual/misc/device-mapper\n      | - return UeventCallback(uevent, &devices); #如果下面有userdata设备创建了，才说明required Device初始化成功了，才返回true。 而lp_metadata_partition_是FirstStageMount早期阶段初始化的/devices/virtual/block/dm-<>/dm/name文件中读出的super partition名字，赋值给/dev/block/mapper/<partition>\n      | - true - sm->CreateLogicalAndSnapshotPartitions(lp_metadata_partition_) #创建logical device和snapshot device\n        \\ - ReadMetadata(opener, super_device, slot) #读取super device对应slot的metadata描述\n        | - CreateLogicalPartitionParams (for params.partition:metadata->partitions) #挨个挂接metadata描述的partitions及其对应的\n                                                                                     #snapshot设备\n          \\ - MapPartitionWithSnapshot(std::move(params)) \n            \\ - GetSnapshotStatusFilePath(params.GetPartitionName() # /metadata/ota/snapshots/<partition_name>\n            | - ReadSnapshotStatus(lock, params.GetPartitionName(), &*live_snapshot_status)  # /metadata/ota/snapshots/<partition_name>,\n               \\ - status->ParseFromFileDescriptor(fd.get()) #解析该文件，获得live_snapshot_status状态\n            | - # MERGE_COMPLETED | NONE | cow_partition_size + cow_file_size = 0 代表no live snapshot\n            | - live_snapshot_status.has_value- # 如果有live snapshot\n               \\ - params.device_name = GetBaseDeviceName(params.GetPartitionName()); #devicename变成了<partionname>—base\n               | -  created_devices.EmplaceBack<AutoUnmapDevice>(&dm, params.GetDeviceName())\n            | - CreateLogicalPartition(params, &base_path) #映射logical device 动态分区的映射，返回的path为/dev/block/dm-<num>\n            | - live_snapshot_status.has_value- #如果有live snapshot\n               \\ - dm.GetDeviceString(params.GetDeviceName(), &base_device) #返回base_device major:minor设备号\n               | - CreateLogicalPartitionParams cow_params = params\n               | - MapCowDevices(lock, cow_params, *live_snapshot_status, &created_devices, &cow_name) #映射cow_device写时复制\n                 \\ - cow_image_name = GetCowImageDeviceName(partition_name) #<partion_name>-cow-img\n                 | - *cow_name = GetCowName(partition_name) #<partition_name>-cow\n                 | - EnsureImageManager()\n                   | - #因为前面已经执行过ForceLocalImageManager，所以image_不为空，后面的步骤不走了\n                 | - MapCowImage(partition_name, remaining_time)\n                   | - has_local_image_manager_- true # image_为之前ForceLocalImageManager时的实例，指向ImageManager\n                   \\ - images_->MapImageWithDeviceMapper(opener, cow_image_name, &cow_dev) #cow_image_name为<partion_name>-cow-img\n                     | - MapWithDmLinear(opener, cow_image_name, {}, &ignore_path)\n                       \\ - metadata = OpenMetadata(metadata_dir_) #metadata_dir_=/metadata/gsi/ota\n                          \\ - metadata_file = GetMetadataFile(metadata_dir_) # /metadata/gsi/ota/lp_metadata\n               |   |         | - metadata = ReadFromImageFile(metadata_file) #从上述文件中解析出metadata描述\n                       | - super = GetMetadataSuperBlockDevice() # 获得super封装\n                       | - block_device = GetBlockDevicePartitionName(super)\n                       | - CreateLogicalPartition(params, path) #dm-linear 跟之前的动态分区的逻辑一样，映射设备，获得path /dev/block/dm-<num>\n                       | - WriteStringToFile(status_string, status_file) #/metadata/gsi/ota/<parition_name-cow-img>.status中写入dm:<partition_name-cow-img>\n                     | - dm.GetDeviceString(name, dev) #返回major：minor号给dev\n               | - created_devices->EmplaceBack<AutoUnmapImage>(images_.get(), cow_image_name） #created_devices再push新的cow_img\n               | - CreateLogicalPartitionParams cow_partition_params = params (.partition_name=*cow_name;); \n                                                                                          #cow_name = <partition>_cow\n               | - CreateDmTable(cow_partition_params, &table) #创建映射表\n               | - cow_partition_sectors = snapshot_status.cow_partition_size() / kSectorSize #扇区\n               | - cow_image_sectors = snapshot_status.cow_file_size() / kSectorSize;\n               | - table.Emplace<DmTargetLinear>(cow_partition_sectors, cow_image_sectors, cow_image_device, 0);\n                       # 从cow-img的尾部开始算，长度为cow_image_sectors 个扇区，block_device还是用前面挂接的cow-img的device\n               | - dm.CreateDevice(*cow_name, table, &cow_path, remaining_time) #为<partition_name>-cow创建dm设备\n               | - created_devices->EmplaceBack<AutoUnmapDevice>(&dm, *cow_name); #push到created_devices中\n            | - dm.GetDeviceString(cow_name, &cow_device)  #<partion_name>-cow获取设备号major /minor\n            | - MapSnapshot(lock, params.GetPartitionName(), base_device, cow_device, remaining_time, path)\n                              #base_device 代表动态分区的base_device, cow_device代表映射partion_name-cow的设备，为这两个设备之间建立映射快照\n               \\ - ReadSnapshotStatus(name, &status) #/metadata/ota/snapshots/<partition_name>读取状态，如果是MERGE_COMPLETED|NONE就退出，不需要快照了\n               | - snapshot_sectors = status.snapshot_size() / kSectorSize #snapshot快照的扇区数\n               | - linear_sectors = (status.device_size() - status.snapshot_size()) / kSectorSize #logical本身的扇区数\n               | - ReadUpdateState()  #/metadata/ota/state中读取ota的状态 MergeCompleted| MergeNeedsReboot return false，退出\n                                       # Merging|MergeFailed mode=merge或者Persistent\n               | - snap_name = GetSnapshotExtraDeviceName(partition_name) #<parition_name>-inner\n               | - table.Emplace<DmTargetSnapshot>(0, snapshot_sectors, base_device, cow_device, mode, kSnapshotChunkSize)\n                         #创建映射表，单位是4k，即8*sector_size  DmTargetSnapshot start=0. length = snapshot_sectors,mode=merge|Persistent\n                         #DmTargetSnapshot::name() mode=merge时返回\"snapshot-merge\",其他状态下返回\"snapshot\"\n               | - dm.CreateDevice(snap_name, table, dev_path, timeout_ms) #创建dm设备\n               | - linear_sectors>0 - #动态分区里的img不为空 \n                   \\ - dm.GetDeviceString(snap_name, &snap_dev) #获取snap_dev的major/minor\n                   | - table.Emplace<DmTargetLinear>(0, snapshot_sectors, snap_dev, 0); #先是snap_device\n                   | - table.Emplace<DmTargetLinear>(snapshot_sectors, linear_sectors, base_device, snapshot_sectors); \n                              #再是linear_device追加\n                   | - dm.CreateDevice(name, table, dev_path, timeout_ms) #最终创建<partition_name>的dm设备映射\n```\n\n#### 小结\n\n对于动态分区的挂载流程，最终是按创建设备时的第一个参数device-name进行匹配查找对应的dm设备，从上述映射过程中可以发现，\n\n- 没有live.snapshot时，只进行了`CreateLogicalPartition`过程，传入的`device_name`就是`partition_name`\n- 而有live snapshot时，第一步的`CreateLogicalPartition`过程传入的`device_name`是`<partition_name>-base`，再走完了`MapSnapshot`过程后，最终创建的dm设备`device_name`才是`partition_name`。\n  \n  > 映射表，前面是base_device到cow_device的snapshot，后面是其本身的动态分区的数据。\n- 借助动态分区的实现逻辑，既然可以有metadata描述分区信息的描述块这种东西，复用见userdata上cow_device的数据描述放在了metadata分区，然后就可以通过`dm-linear` 将数据映射成dm设备。\n  当前的分析还只是在userspace，跟核心的实现应该是device-mapper的内核实现，dm-snapshot 和dm-snapshot-merge的内部是怎样实现的，才是virtual ab方案的真正的核心。\n  \n  ## snapshot理解\n  \n  android的virtual ab方案中snapshot的方案来自于lvm（Logical Volume Manager），要理解snapshot先从lvm说起\n  首先可以想通过lvm大致还原snapshot创建的过程\n\n### lvm snapshot过程理解\n\n在pc机上创建snapshot过程模拟\n\n```shell\n# 创建device的模拟设备\ndd if=/dev/zero of=sd10 bs=4M count=1000\n# 关联loop设备\nlosetup /dev/loop0 sd10\n# 为loop设备创建lvm的物理分区\nsudo pvcreate /dev/loop0\nsudo pvscan\n# 创建卷组\nsudo vgcreate -s 32M nickgroup /dev/loop0\nsudo vscan\nsudo vgdisplay\n# 创建卷\nlvcreate -L 2G --name nickgroup/nicklv00\nsudo lvscan\n# 为卷建立文件系统\nsudo mkfs.ext4 /dev/nickgroup/nicklv00\nsudo mount -t ext4 /dev/nickgroup/nicklv00 nicklv\necho \"hello world\" > test_change; echo \"i'm not change\">test_no_change\n# 为卷建立snapshot\nsudo lvcreate -L 1G --snapshot --name nicklv00_snap  nickgroup/nicklv00\nsudo mount -t ext4 /dev/nickgroup/nicklv00_snap nicklv_snap\n# 改变原始卷某文件的内容\necho \"i'm change\" >> nicklv/test_change\n```\n\n为原始卷建关联snapshot设备后，改变原始卷的某文件的内容，做一下对比\n首先，先看下未修改的文件test_no_change的内容，在原始卷和snapshot上内容都是一样的\n\n```shell\n[~/program/testlvm] - [五 4月 10, 15:33]\n[$] -> sudo istat /dev/nickgroup/nicklv00_snap 13\ninode: 13\nAllocated\nGroup: 0\nGeneration Id: 2264406482\nuid / gid: 1000 / 1000\nmode: rrw-rw-r--\nFlags: Extents,\nsize: 16\nnum of links: 1\nInode Times:\nAccessed:       2020-04-10 11:22:07.917092707 (CST)\nFile Modified:  2020-04-10 11:22:03.053131212 (CST)\nInode Modified: 2020-04-10 11:22:03.053131212 (CST)\nFile Created:   2020-04-10 11:22:03.053131212 (CST)\nDirect Blocks:\n32898\n[~/program/testlvm] - [五 4月 10, 15:33]\n[$] -> sudo istat /dev/nickgroup/nicklv00 13\ninode: 13\nAllocated\nGroup: 0\nGeneration Id: 2264406482\nuid / gid: 1000 / 1000\nmode: rrw-rw-r--\nFlags: Extents,\nsize: 16\nnum of links: 1\nInode Times:\nAccessed:       2020-04-10 11:22:07.917092707 (CST)\nFile Modified:  2020-04-10 11:22:03.053131212 (CST)\nInode Modified: 2020-04-10 11:22:03.053131212 (CST)\nFile Created:   2020-04-10 11:22:03.053131212 (CST)\nDirect Blocks:\n32898\n```\n\n而对于修改的文件 test_change\n\n```shell\n[$] -> sudo istat /dev/nickgroup/nicklv00 12\ninode: 12\nAllocated\nGroup: 0\nGeneration Id: 3262808564\nuid / gid: 1000 / 1000\nmode: rrw-rw-r--\nFlags: Extents,\nsize: 37\nnum of links: 1\n...\nDirect Blocks:\n33280\n[~/program/testlvm] - [五 4月 10, 15:34]\n[$] -> sudo istat /dev/nickgroup/nicklv00_snap 12\ninode: 12\nAllocated\nGroup: 0\nGeneration Id: 3777049701\nuid / gid: 1000 / 1000\nmode: rrw-rw-r--\nFlags: Extents,\nsize: 24\nnum of links: 1\n...\n\nDirect Blocks:\n32897\n```\n\n发现修改文件的inode指向的direct block内容发生了变化，且snapshot的direct block对应的块号比较小，说明其是原始的，也可以在改之前验证下，确实是这样的。\n说明修改原始卷后，共享的data block的内容并没有改变，而是修改了原始卷的inode的data block索引，并将修改后的内容写入到了新的data block上。\n但是又不能简单这样理解，因为lvm是逻辑卷管理，并不代表实际的物理数据也是这样的，lvm也是借助device_mapper来实现的，其extents指向关系并不能简单的从文件系统的描述data block的变化得到。不能得到原始卷中改变了的内容只是将data block块换了位置存放新内容，而snapshot的inode继续指向原始datablock的结论，因为这样是违反常识的，一旦data block被耗尽，那原始的data block的内容岂不是要被删掉，那快照还有什么意义呢。\n这里先提前将snapshot的原理说下\n创建快照，实际上就是将原始卷文件系统的元数据信息复制了一份（包括super block inode imap bmap group gdt）等，这里可以先验证下\n\n```\n sudo dumpe2fs /dev/nickgroup/nicklv00_snap|  sudo dumpe2fs /dev/nickgroup/nicklv00\n```\n\n![文件系统结构](images/20200721113638.png)\n![lvm snapshot](images/20200721113643.png)\n\n实际上snapshot的原理可以理解为下面的过程：\n左图为最初创建的快照数据卷状况，LVM 会预留一个区域 (比如左图的左侧三个 PE 区块) 作为数据存放处。 此时快照数据卷内并没有任何数据，而快照数据卷与源数据卷共享所有的 PE 数据， 因此你会看到快照数据卷的内容与源数据卷中的内容是一模一样的。 等到系统运行一阵子后，假设 A 区域的数据被更新了(上面右图所示)，则更新前系统会将该区域的数据移动到快照数据卷中， 所以在右图的快照数据卷中被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与源数据卷共享！\n由於快照区与原本的 LV 共享很多 PE 区块，因此快照区与被快照的 LV 必须要在同一个 VG 上头，下面两点非常重要：\nVG中需要预留存放快照本身的空间，不能全部被占满。\n快照所在的 VG 必须与被备份的 LV 相同，否则创建快照会失败。\n重要的一点是，snapshot会存在一个cow img，但原始数据改变后，会将原来的内容拷贝一份，放到这个cow img中，而且data block号会复用，建立快照的过程，就是数据映射的过程，快照一旦建立，数据的映射关系就确定下来了。快照从文件系统层面上讲也固定下来了\n\n可以验证上述结论的实例是：\n创建总大小为400M的loop设备，在这上面创建200M的原始卷，往其中写入198M大小的文件，对原始卷可以创建最小32M的snapshot，发现可以创建成功，也可以挂载snapshot，挂载后可以198M的文件是正常的，说明快照不是简单的备份关系。\n而在上述过程走完后，可以修改原始卷中198M大小的文件，发现无论修改了什么内容，只要该文件被改了，那备份卷就被损坏了，同时原始卷中文件写入的操作会报空间不足的错误。\n从上面snapshot的实现过程来推测，写时复制过程应该是借助device-mapper修改了物理块-逻辑块的映射关系，不然data block的复用就有问题了。\n\n下面再看下merge过程。\n合并快照的操作也需要卸载源数据卷：\n确认源数据卷和快照数据卷都没有被挂载后就可以执行合并快照的操作了\n\n```shell\nsudo lvconvert --merge nickgroup/nicklv00_snap\n```\n\nmerge过程可以看作是将snapshot的cow-img拷贝，覆盖掉改动文件的inode和data block的过程。merge之后，snapshot就变成无效的了\n这个过程中牵涉到的核心点其实还是data_block的处理，因为从snapshot快照的建立到写时复制过程，如果要保证改写前后snapshot文件系统内data block块号不变，需要重定向物理扇区的过程，这里面需要device-mapper的参与。\n\n## lvm-android上snapshot\n\n从lvm的snapshot到android上的变体，可以发现的是android上是改动了一些东西，是不是可以认为`<partition_name>-cow`是snapshot复制的原始卷的元数据区，而`<partition_name>-cow-img`是写时复制的数据区呢。这个有待拿到真机后再进一步验证。\n\n### 理解v-ab的升级过程\n\n下面还需要研究virtual ab打包过程的变化，以便更好理解virtual ab的升级过程。\n\n对于升级过程， virtual ab方案使用的升级包和ab的升级包是共用的， 从build下的打包change来看，并没有直接适配virtual ab的升级包。另一方面，从update-engine的分析来看，在virtual ab的属性打开后，额外进行了一些操作：\n\n1. 根据手机中版本的信息和升级包的信息作比对， 通过文件系统级别判断中差异量的大小，根据该大小，新建一个文件，用来存放cow 区。创建欲升级分区的dm-snap镜像，放在super的尾部，存放了欲升级分区的文件系统的元数据的复制信息，形成cow-device。\n2. 存放cow（写时复制）区的文件，通过ioctl获取其占用的block map，和lp的extent数据结构结合， 最终形成dm-linear的索引，放到metadata分区中。\n3. 升级过程中（整包升级及差分升级过程），将变动的文件存放到cow区域\n4. 升级结束后，下次重启时，将cow-device和cow-file（写时复制区）拼接，形成snapshot-img。 对系统分区进行snapshot的映射，映射后的dm设备即为新版本。如果能正常开机，挂载dm-snapshot-merge在内核空间进行merge，merge的过程即将cow-file的内容覆盖到系统img中被修改的block块的过程。merge开始前，应该会根据需要resize动态分区。merge完成后，系统分区被更新为新版本。\n\nkernel的实现：\n\n`kernel/msm-4.19/Documentation/device-mapper/snapshot.txt`\n\n- *) snapshot <origin> <COW device> <persistent?> <chunksize>\n  \n  A snapshot of the <origin> block device is created. `Changed chunks of\n  <chunksize> sectors will be stored on the <COW device>`.  ***Writes will\n  only go to the <COW device>***.  Reads will come from the <COW device> or\n  from <origin> for unchanged data.  <COW device> will often be\n  smaller than the origin and if it fills up the snapshot will become\n  useless and be disabled, returning errors.  So it is important to monitor\n  the amount of free space and expand the <COW device> before it fills up.\n  \n  <persistent?> is P (Persistent) or N (Not persistent - will not survive\n  after reboot).  O (Overflow) can be added as a persistent store option\n  to allow userspace to advertise its support for seeing \"Overflow\" in the\n  snapshot status.  So supported store types are \"P\", \"PO\" and \"N\".\n  \n  The difference between persistent and transient is with transient\n  snapshots less metadata must be saved on disk - they can be kept in\n  memory by the kernel.\n  \n  When loading or unloading the snapshot target, the corresponding\n  snapshot-origin or snapshot-merge target must be suspended. A failure to\n  suspend the origin target could result in data corruption.\n\n- snapshot-merge <origin> <COW device> <persistent> <chunksize>\n  \n  takes the same table arguments as the snapshot target except it only\n  works with persistent snapshots.  `This target assumes the role of the\n  \"snapshot-origin\" target and must not be loaded if the \"snapshot-origin\"\n  is still present for <origin>`.\n  \n  Creates a merging snapshot that takes control of the changed chunks\n  stored in the <COW device> of an existing snapshot, through a handover\n  procedure, and merges these chunks back into the <origin>.  Once merging\n  has started (in the background) the <origin> may be opened and the merge\n  will continue while I/O is flowing to it.  Changes to the <origin> are\n  deferred until the merging snapshot's corresponding chunk(s) have been\n  merged.  Once merging has started the snapshot device, associated with\n  the \"snapshot\" target, will return -EIO when accessed.\n\n从上述文档上看， 首先snapshot-origin的角色相当与传统的lvm的snapshot机制，即文件改动时，改动的内容写到了origin区域，而原始内容备份到了cow-device上。snapshot-merge的角色相当于snapshot-origin。 snapshot的角色机制与snapshot-origin机制相反： 改动的内容写到cow-device，原始内容不变。\n\n通过这两个机制能保证在ota升级过程中，挂载target为snapshot，改动的内容写到cow-device的cow-file中。 ota升级结束后，merge过程中，挂载类型为`snapshot-merge`改动的内容写到原始区域，即系统分区空间。\n\n从update_engine的升级过程看，以及对snapshot的实例分析，virtual ab的升级包应该和ab的升级包是同一个。差异化处理是在update_engine具体的升级过程。对snapshot的实例验证表明，snapshot的cow写时复制并不是以文件系统为基本单位的，而是以`block`为基本单位，block内容变更了，才会将原来的block的内容复制到cow-file中，并重用之前的block块号，再更新block写入新的修改，在lvm上是这样处理的。对于android而言，这个过程需要反过来，所以推测android上改写了snapshot的逻辑，再检测到block块号的内容变更后，由于系统分区为只读设备，新的内容是写进了cow-file中。而源分区的数据并没有进行改动。\n\n### virtual ab recovery下的挂载流程\n\n源码位于\n\n```bash\nkernel/msm-4.19/drivers/md/dm-snap*.c\n```\n\nandroid针对cow 镜像采用了*移花接木*的手段，正常recovery子系统是不能访问userdata分区的，但是cow-file又是存在于userdata分区上，而对于ab/virtual ab升级来说，虽然是在主系统升级，但是还是需要recovery子系统作为一个备胎支持ab升级的能力。所以问题是recovery子系统上如何完整的挂载snapshot呢？\n\n这里从前面的流程分析可见，\n\n对于某个系统分区的cow镜像来说，存在一个<partition_name>_cow 为分区名的分区在super分区的metadata上，而对应该分区的分区组名为cow，元数据区域也在这个super上，对于cow-file，即写时复制的区域，是存在了userdata分区上的，而其metadata的描述是存在了metadata分区身上。对于`metadata描述`是指的metadata数据结构，其中包含了分区extents数据段，cow-file是先初始化，根据当前版本和目标版本的metadata的描述的差异，先计算cow-file需要多大的空间，直接在userdata上创建了这样一个文件，然后就可以通过ioctl命令获得其block map，将block map转化成extents，再通过dm-linear 根据extents制成dm table，最终可以创建dm设备，还原cow-file，再同cow-partition的元数据信息拼接形成完成cow partition的镜像。再通过map snapshot和源分区关联起来。","tags":["vab"],"categories":["Android"]},{"title":"android r recovery适配","url":"/2019/12/12/OTA相关/android r recovery适配/","content":"\n## 遇到的问题\n\n1. 抓kernel log\n\n   fastboot oem uart-enable，重启后，会吐出kernel log， 否则只有kernel之前的log\n\n   > 提前设置好启动模式，misc不要清除\n\n2. 关掉avb校验\n\n   `fastboot flash vbmeta --disable-verification` \n\n   `export ANDROID_PRODUCT_OUT=/home/mi/work_space/miui-r-umi-dev/out/target/product/cmi`\n\n   `make vbmeta`\n\n3. ninja 编译问题\n\n   make编译完后，再使用ninja编译， 会重新完全编译， 打印下面的log。 后来发现是ninja版本的问题，ninja 需要同源码的prebuilts下的相同，就不会重新编译\n\n   > bad deps log signature or version; starting over\n\n4. hidl 出错\n\n   等待进一步调试，manifest是正常的，需要加log调试\n\n   > HidlServiceManagement: Waited one second for android.hardware.keymaster@4.0::IKeymasterDevice/default\n   \n   stop hwservicemanager后， 自动重启到recovery\n   \n   这个是vdc命令触发的，先关掉`reboot_into_recovery`\n   \n   `vdc cryptfs mountFstab /dev/block/bootdevice/by-name/userdata /data`\n   \n   ​       调试libhidlbase时， 这个so在system分区，但是动态分区的机型recovery模式下只能挂载只读的system。怎样调试是个问题，可以调换ld.config.text文件中lib库的加载顺序，先创建一个虚拟的文件夹，这个文件夹只在recovery启动后启动特别模式后，再装载需要调试的lib库。\n   \n   ```log\n   namespace.default.search.paths = /system_lib\n   namespace.default.search.paths += /system_root/system/${LIB}\n   namespace.default.search.paths += /system_root/system/${LIB}/bootstrap\n   namespace.default.search.paths += /system/${LIB}\n   ```\n   \n   不这样处理，如果直接替换recovery的， recovery会无法启动\n   \n   从log上看，manifest中定义的keymaster组件是已经找到了， 为什么启动不了呢， 原来是对应的hidl的service的rc没有在`mount_all`时加载， androidr上修改了mount_all的流程，不再主动加载挂载分区的rc。\n   \n   还有一个问题是recovery早期阶段， 创建dm设备时出现device busy问题， 这个还需要进一步分析。\n   \n5. ota适配\n\n   ```log\n   ./ota_from_target_files --no_signing -s ~/work_space/miui-r-umi-dev/vendor/qcom/opensource/recovery-ext/tools/releasetools.py --extracted_input_target_files ~/Downloads/cmi-target_files-0.0.12-11.0_e9b5e7be6c  ~/Downloads/cmi-target_files-0.0.12-11.0_e9b5e7be6c.zip ota_test.zip\n   ```\n\n6. ufs分区节点没出来\n\n   ```shell\n   #没有dev/block/platform节点, 初步判断原因为ufs_ice没找到 platform节点未生成\n   Copying target dtb/dtbo files to prebuilt\n   # 与本地dtb编译有关, 将kernel代码删除, 重新sync\n   cp: cannot stat '/home/mi/work_space/miui-r-umi-dev/out/target/product/cmi/obj/kernel/msm-4.19/arch/arm64/boot/dts/vendor/qcom/*.dtb': No such file or directory\n   \n   ```\n\n   ","tags":["Android"],"categories":["Android","recovery"]},{"title":"小米手机抓log","url":"/2019/11/12/OTA相关/log分析/","content":"\n# log分析\n抓串口log方式\n\n## 打开串口log, 通过串口线获取\n\n使用fastboot oem uart-enable 打开串口log\nminicom -c on -C <log> 抓取log.\n>注意波特率要设置正确, 可以问下相关的底层或适配组的同事. 如果波特率不对, 可能窗口没有**任何输出**或输出**乱码**\n\n## logfs获取\n会保存最近5份开机(包括recovery子系统)的串口log\n```shell\nmount /dev/block/bootdevice/by-name/logfs /data/log\n```\n\n## 获取kernel log\n\n高通sm8250平台可以通过电量下+电源键(长按3s)进入ramdump模式\n进入后, 连接qpst工具抓取即可. kernel log会优先输出\n\n## fastboot获取kernel log\n\n使用fastboot_log工具获取, 该工具在客户端加入了*lkmsg*指令, 需要手机侧的fastboot支持(较新的机型支持)\n\n```shell\n./fastboot_log oem lkmsg > last_kmesg1\n```\n\n## mtk机型开机log\n以last kmsg为例，在重启前，printk()一方面将kernel log格式化输出到ring buffer里面去，同时送到pstore console中去（console write接口将log实时写入console ram zone中）。\n一旦发生warm reset，kernel log将会停止记录到pstore console，最后一段log（即前0xd0000 bytes）就会驻留在console ram zone中。\n重启后通过cat sys/fs/pstore/console-ramoops即可获取last kmsg。\n\ndump分区\n\n## 重启进recovery log\n\n进入小米助手后, 屏幕出现三个按钮, 选择最后一项, 连接小米助手\npc 端 adb pull /cache/ .  抓取log\n其中**cache/recovery/last_log** 中保存了进recovery的trigger reason\n**cache/mqsas/null_RescuePartyLog_*** 中保存了重启前的logcat抓出的android层的log\n可以使用 `ota_log_analyze.py`工具简单分析下\n```\nota_log_analyze.py cache (cache是 adb pull /cache/ . 后在pc上拉出的目录)\n```\n\n\n","tags":["log"],"categories":["Android"]},{"title":"优化cache","url":"/2019/11/12/OTA相关/优化cache/","content":"\n# 优化cache\n## cache文件系统损坏问题\n因文件系统损坏, 可能导致可用空间信息不准确, 或cache空间变成一半.\n开机加入强制check cache, 可以解决可用空间错误的问题.\n\nhttp://gerritlvs.pt.miui.com/#/c/641165/\n\n###  原生方案\n\n没有强制check cache. 开机阶段对cache分区进行检查, 如果出现过异常关机的情况, 会对cache分区进行修复.\n\n- fstab中options配置了**check**\n- 读取文件系统超级块信息时返回的状态是**FS_STAT_UNCLEAN_SHUTDOWN**或**FS_STAT_QUOTA_ENABLED**\n\n>FS_STAT_UNCLEAN_SHUTDOWN状态可以理解完出现了异常关机\n>\n>FS_STAT_QUOTA_ENABLED状态则是分区是否启用了磁盘配额机制\n\n```cpp\n read_ext4_superblock(blk_device, &sb, &fs_stat)\n // fstab中options配置了check或者读取文件系统超级块信息时返回的状态是FS_STAT_UNCLEAN_SHUTDOWN或FS_STAT_QUOTA_ENABLED   \n     if ((rec->fs_mgr_flags & MF_CHECK) ||\n        (fs_stat & (FS_STAT_UNCLEAN_SHUTDOWN | FS_STAT_QUOTA_ENABLED))) {\n        check_fs(blk_device, rec->fs_type, rec->mount_point, &fs_stat, rec);\n    }\n```\n\n##### 因cache文件系统损坏导致的recovery无法更新成功问题\n\n解决方案: (适用于bootloader加锁的情况)\n\n> 执行“fastboot continue开机后， 长按power键+ 音量下，直接进fastboot , 然后fastboot continue开机”. \n\n目的是触发非正常关机, 再次开机时cache分区文件系统超级块检查后变为**FS_STAT_UNCLEAN_SHUTDOWN**, 触发check修复, 然后recovery更新所在的服务**flash_recovery**即可正常执行.\n\n### 改进方案\n\n我们的方案即在原生方案基础上在**fstab**中加入了check选项, 这样每次开机都会对cache进行check. 如在*ext4*上执行\n\n```cpp\n#define E2FSCK_BIN      \"/system/bin/e2fsck\"\nconst char* e2fsck_forced_argv[] = {E2FSCK_BIN, \"-f\", \"-y\", blk_device};\n```\n\n对于cache空间变成一半的问题, 因当前还没有root-cause, 也没有dump出的现场的cache.img, 问题还需要继续跟踪.\n\n> 总空间变成一半的案例:  \n>\n> https://jira.n.xiaomi.com/browse/HTH-60766\n>\n> cache损坏, 可用空间变成一半的案例  \n>\n> https://jira.n.xiaomi.com/browse/MIUI-1605226\n\n## 因ota升级重启导致的cache缓存遗留问题\n\n在applypatch的代码中, 如果差分升级某些分区, 会有cache缓存残留.\n\n### 方案\n\n1. ota升级过程中屏蔽power键功能, 保证ota升级过程中用户不能通过长按power键重启\n2. 在校验分区已经满足目标版本时, 删除对应的分区残留项.\n\n#### 方案一\n\n第一个方案正在对所有机型计划合入中, 依赖底层kernel中power节点的使能. \n\n对应高通机型, http://gerrit.pt.miui.com/#/c/648868/, 需要**kpdpwr_reset**节点使能即可.\n\nhttp://gerrit.pt.miui.com/#/c/665992/, 节点前的路径需要底层同事提供.\n\n```json\non property:vendor.kpdpwr.reset.enabled=0\n    write /sys/devices/platform/soc/c440000.qcom,spmi/spmi-0/spmi0-00/c440000.qcom,spmi\\:qcom,pm660@0\\:qcom,power-on@800/kpdpwr_reset 0\n\non property:vendor.kpdpwr.reset.enabled=1\n    write /sys/devices/platform/soc/c440000.qcom,spmi/spmi-0/spmi0-00/c440000.qcom,spmi\\:qcom,pm660@0\\:qcom,power-on@800/kpdpwr_reset 1\n```\n\n对应mtk机型, 可以参考G7的修改.\n\nhttp://gerrit.pt.miui.com/#/c/665678/\n\nhttp://gerrit.pt.miui.com/#/c/664037/\n\n#### 方案二\n\n在校验分区已经满足目标版本时, 删除对应的分区残留项.\n\n```cpp\nif (memcmp(source_file.sha1, target_sha1, SHA_DIGEST_LENGTH) == 0) {\n    // The early-exit case: the patch was already applied, this file has the desired hash, nothing\n    // for us to do.\n    // cache/saved.file\n    size_t cache_temp_source_size = GetFileSize(CacheLocation::location().cache_temp_source());\n    if(cache_temp_source_size != 0)\n        unlink(CacheLocation::location().cache_temp_source().c_str());\n    printf(\"already %s\\n\", short_sha1(target_sha1).c_str());\n    return 0;\n}\n```\n\n> 案例: https://jira.n.xiaomi.com/browse/HQ-43785\n\n## 尽可能删除cache下的文件\n\n在检查及清除cache下文件时, 尽可能删除cache下的文件.\n在尽量保留recovery log的基础上对cache下的所有文件进行排序.\n排序按照优先级, 大小的双重规则进行安排.\n对log和升级相关的文件尽可能不删除, 对ota升级过程中的stash文件不做处理, 对其他文件优先按照文件大小进行排序, 逐个删除, 直到可用空间满足要求为止.\n\n相关的修改参考:  http://gerrit.pt.miui.com/#/c/646042/1/applypatch/freecache.cpp\n\n#### 原生方案\n\nandroidP 只删除/cache根目录下的文件, 还有*/cache/recovery/otatest*目录下的文件.\n\n```\nconst char* dirs[2] = {\"/cache\", \"/cache/recovery/otatest\"};\n```\n\nandroidQ上只删除*/cache*根目录下的文件和*/cache/recovery/*下的log文件, 保留last_log和last_kmsg.\n\n```cpp\nstd::vector<std::string> dirs{ \"/cache\", Paths::Get().cache_log_directory() };\nfor (const auto& dirname : dirs) {\n    if (RemoveFilesInDirectory(bytes, dirname, FreeSpaceForFile)) {\n        return true;\n    }\n}\n```\n\n#### 改进方案\n\n遍历cache目录, 对其下所有文件进行追踪, 记录其文件名, 大小, 和优先级.\n\n优先级从高->低, 越大的越容易被删除. 同优先级的比较大小, 文件越大的越容易被删除. 同时定义了 **`CANNOT_DEL_PRI`**级别, 对应不能被删除的文件.\n\n打印log, 给出了/cache下最大的20个文件名.\n\n##### 不能被删除的文件\n\n- */cache/recovery/block.map*\n- */cache/recovery/last_log*\n- */cache/recovery/last_log.1*\n- ==*/cache/saved.file*==\n- `/cache/recovery/<dir_name>/*`\n- /cache/ 下小于**2k**的小文件, 包含了/cache/recovery下升级相关的日志文件, 升级文件等.\n\n##### 优先级排序\n\n> 从上到下越容易被删除的程度\n\n- /cache/recovery/<dir_name>/*    主要是考虑升级时stash相关的文件, 没有固定文件名\n- /cache/recovery/  保存了相关recovery的升级日志等.\n- /cache/mqsas/\n- 其他\n\n## applypatch优化\n\n在ota升级后, recovery更新时, 原生方案依赖**cache分区的可用空间**. 主要是***/cache/saved.file***的处理. 对于recovery更新的场景来说, 是使用*/dev/block/bootdevice/by-name/boot* + *system/recovery-from-boot.p* 文件, 生成recovery分区的镜像, 写入*/dev/block/bootdevice/by-name/recovery*, 这个过程中原始文件boot不会被损坏, 所以是不需要缓存文件的.\n\napplypatch可以用作使用别的分区升级当前分区, 如 boot-[recovery-from-boot.p]->new recovery \n\n```shell\n  applypatch  EMMC:/dev/block/bootdevice/by-name/boot:67108864:8c05fe713233ad8b5c85db717bfdae0cecdca5bc EMMC:/dev/block/bootdevice/by-name/recovery 870ddfcf72425a76f95899254a8df3b32ac2dad0 67108864 8c05fe713233ad8b5c85db717bfdae0cecdca5bc:/system/recovery-from-boot.p && log -t recovery \"Installing new recovery image: succeeded\" || log -t recovery \"Installing new recovery image: failed\"\n```\n\n使用当前分区内容升级当前的分区, 即**自更新**. boot-[boot.p]-> new boot\n\n```shell\npatch_partition(\"EMMC:/dev/block/bootdevice/by-name/boot:51242240:5d92bec9964000c0b11229cdc51470662feda96b\",\n                \"EMMC:/dev/block/bootdevice/by-name/boot:50926848:07700e132a84e47c26380a7a7a0fc57f8164fa60\",\n                package_extract_file(\"boot.img.p\")) ||\n    abort(\"E3008: Failed to apply patch to EMMC:/dev/block/bootdevice/by-name/boot:50926848:07700e132a84e47c26380a7a7a0fc57f8164fa60\");\n```\n\n自更新是需要缓存的, 就是怕在更新过程中意外退出了, 那原始的分区也会被破坏. 使用缓存来作备份, 保存原始分区的内容.   \n\n##### 优化方案\n\nrecovery更新时调用applypatch不再需要缓存文件. 也就去除了对`cache`分区需要有可用空间的依赖.\n\nhttp://gerrit.pt.miui.com/#/c/646042/1/applypatch/applypatch.cpp\n\n## ota打包时, 能使用的最大的cache空间\n原生行为, ota打包时,最大能够使用的cache空间为**cache partition size**的**80%.**\n\n#### 优化方案\n\n调整为**cache文件系统**总空间的**80%**. 和系统升级app端行为保持一致, (升级前先检查cache的使用量, 如果超过20%要求用户对其格式化)\n\n> 案例: https://jira.n.xiaomi.com/browse/HTH-56790\n\n相关change: http://gerrit.pt.miui.com/#/c/661519/\n\n主要原理是在调用文件系统对应的打包脚本生成cache.img时, 截取used_blocks和total_blocks.\n\n> 文件系统-> 打包脚本\n>\n> - ext:         mkuserimg_mke2fs  \n> - squash:  mksquashfsimage.sh  \n> - f2fs:        mkf2fsuserimg.sh\n\n当前cache是ext4的, 会输出下面的信息, 从中可以截取出used_blocks和total_blocks.\n\n```python\n  block_bytes_key = r'Creating journal\\s\\((\\d+)\\sblocks\\).*'\n  block_count_key = r'Created filesystem with[\\s\\/\\d]+inodes\\sand\\s(\\d+)\\/(\\d+)\\sblocks'\n```\n\n\n\n","tags":["Android"],"categories":["Android","cache 分区","recovery"]},{"title":"Q动态分区 recovey fastbootd 调研","url":"/2019/11/12/OTA相关/Q recovery fastboot调试/","content":"\n```shell\n#需要先挂载fastboot\nmkdir /config/usb_gadget/g1/functions/ffs.fastboot\nmount -t functionfs fastboot /dev/usb-ffs/fastboot\n```\n\n初步调试 清除数据wipe_data进 fastboot, 重启进adb模式\n\n使用wireshark进行调试\n\n```shell\nT:  Bus=01 Lev=01 Prnt=01 Port=08 Cnt=03 Dev#= 40 Spd=480  MxCh= 0\nD:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1\nP:  Vendor=18d1 ProdID=4ee0 Rev= 4.19\nS:  Manufacturer=Xiaomi\nS:  Product=Umi\nS:  SerialNumber=4e80ec52\nC:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=500mA\nI:* If#= 0 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=42 Prot=03 Driver=(none)\nE:  Ad=01(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms\nE:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms\n```\n\n```shell\n#打包recovery的ramdisk\nout/host/linux-x86/bin/mkbootfs -d out/target/product/umi/system out/target/product/umi/recovery/root | out/host/linux-x86/bin/minigzip > out/target/product/umi/ramdisk-recovery.img\n#打包recovery.img\nout/host/linux-x86/bin/mkbootfs -d out/target/product/umi/system out/target/product/umi/recovery/root | out/host/linux-x86/bin/minigzip > out/target/product/umi/ramdisk-recovery.img && out/host/linux-x86/bin/mkbootimg  --kernel out/target/product/umi/kernel  --ramdisk out/target/product/umi/ramdisk-recovery.img --cmdline \"console=ttyMSM0,115200n8 androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 video=vfb:640x400,bpp=32,memsize=3072000 msm_rtb.filter=0x237 service_locator.enable=1 androidboot.usbcontroller=a600000.dwc3 swiotlb=2048 loop.max_part=7 cgroup.memory=nokmem,nosocket reboot=panic_warm androidboot.selinux=permissive androidboot.usbconfigfs=true\" --base 0x00000000 --pagesize 4096 --recovery_dtbo out/target/product/umi/prebuilt_dtbo.img --dtb out/target/product/umi/dtb.img --os_version 10 --os_patch_level 2019-09-05 --header_version 2 --output  out/target/product/umi/recovery.img\n```\n\nOTA测试环境OTA地址\n\n```shell\nhttp://husky.pt.miui.com/buildFile/miui_UMI_9.9.20_f2a2d4cc2d_10.0.zip\n```\n\n## 1. 关于hidl service\n\n### 1.1. hal简介\n\nHAL 接口定义语言（简称 HIDL，发音为“hide-l”）是用于指定 HAL 和其用户之间的接口的一种接口描述语言. 用于进程间通信.分为直通式(passthrough)和绑定式(binderized)\n\n### 1.2. hidl服务的调用流程\n\n以android.hardware.fastboot为例,  具体实现在default. defalut是默认实例,  最后编译为动态库\n\n```cpp\nname: \"android.hardware.fastboot@1.0-impl-mock\",\n```\n\n在client端调用**IFastboot::getService**,  能编译通过的前提是client端引用了动态库 *android.hardware.fastboot@1.0*\n\n该库文件对应的代码是IFastboot.hal. 定义了相关IFastboot的接口.\n\n```shell\n[~/work_space/q9/hardware/interfaces/fastboot/1.0] - [日 9月 29, 14:54]\n[$] -git:(bsp-umi-q*)> tree                                                                \n.\n├── Android.bp\n├── IFastboot.hal\n└── types.hal\n```\n\n由 update-makefiles.sh脚本对hal文件进行解析, 生成在`out/soong/.intermediates/hardware/interfaces/fastboot/1.0/android.hardware.fastboot@1.0_genc++_headers/gen/android/hardware/fastboot/1.0/IFastboot.h`\n\n```cpp\nnamespace android {\nnamespace hardware {\nnamespace fastboot {\nnamespace V1_0 {\n    struct IFastboot : public ::android::hidl::base::V1_0::IBase {\n        using getPartitionType_cb = std::function<void(::android::hardware::fastboot::V1_0::FileSystemType type, const ::android::hardware::fastboot::V1_0::Result& result)>;\n        static ::android::sp<IFastboot> getService(const std::string &serviceName=\"default\", bool getStub=false);\n        virtual ::android::hardware::Return<void> getPartitionType(const ::android::hardware::hidl_string& partitionName, getPartitionType_cb _hidl_cb) = 0;\n        ...\n```\n\n*android.hardware.fastboot@1.0_genc++/gen/android/hardware/fastboot/1.0/FastbootAll.cpp*\n\n首先看下getService的相关实现:\n\n```cpp\n::android::sp<IFastboot> IFastboot::getService(const std::string &serviceName, const bool getStub) {\n    return ::android::hardware::details::getServiceInternal<BpHwFastboot>(serviceName, true, getStub);\n}\n```\n\n该函数接下来会调用到libhidlbase.so里, 具体实现在`system/libhidl/transport/include/hidl/HidlTransportSupport.h`\n\n```cpp\ntemplate <typename BpType, typename IType = typename BpType::Pure,\n          typename = std::enable_if_t<std::is_same<i_tag, typename IType::_hidl_tag>::value>,\n          typename = std::enable_if_t<std::is_same<bphw_tag, typename BpType::_hidl_tag>::value>>\nsp<IType> getServiceInternal(const std::string& instance, bool retry, bool getStub) {\n    using ::android::hidl::base::V1_0::IBase;\n    sp<IBase> base = getRawServiceInternal(IType::descriptor, instance, retry, getStub);\n...\n    if (base->isRemote()) {\n        // getRawServiceInternal guarantees we get the proper class\n        return sp<IType>(new BpType(getOrCreateCachedBinder(base.get())));\n    }\n\n    return IType::castFrom(base);\n}\n```\n\n```shell\nlibhidlbase.so  <--  (static_lib)-- libhidltransport-impl-internal\n```\n\n```cpp\n//system/libhidl/transport/ServiceManageMent.cpp\nsp<::android::hidl::base::V1_0::IBase> getRawServiceInternal(const std::string& descriptor,\n                                                             const std::string& instance,\n                                                             bool retry, bool getStub) {\n    Transport transport = Transport::EMPTY;\n    if (kIsRecovery) {\n        transport = Transport::PASSTHROUGH;\n    } else {\n        // 1. waitForHwServiceManager();   一直等待hwservicemanager.ready变为true. 1s检查一次\n        // 依赖hwservicemanager\n        sm = defaultServiceManager1_1();\n        // 2. 调用ServiceManager的getTransport函数,获取传入的hidl服务的接口类型.\n        // getTransport函数逻辑较长, 另行分析.        \n        Return<Transport> transportRet = sm->getTransport(descriptor, instance);\n        ...\n        transport = transportRet;\n    }\n    // 3. 接口类型要么是hwbinder, 要么是passthrough, 要么是legacy的\n    const bool vintfHwbinder = (transport == Transport::HWBINDER);\n    const bool vintfPassthru = (transport == Transport::PASSTHROUGH);\n    // 4. 接口类型是hwbinder或者是legacy的. getStub false\n    for (int tries = 0; !getStub && (vintfHwbinder || vintfLegacy); tries++) {\n        if (waiter == nullptr && tries > 0) {\n            waiter = new Waiter(descriptor, instance, sm);\n        }\n        if (waiter != nullptr) {\n            waiter->reset();  // don't reorder this -- see comments on reset()\n        }\n        Return<sp<IBase>> ret = sm->get(descriptor, instance);\n        sp<IBase> base = ret;\n        if (base != nullptr) {\n            Return<bool> canCastRet =\n                details::canCastInterface(base.get(), descriptor.c_str(), true /* emitError */);\n\n            if (canCastRet.isOk() && canCastRet) {\n                if (waiter != nullptr) {\n                    waiter->done();\n                }\n                return base; // still needs to be wrapped by Bp class.\n            }\n\n            if (!handleCastError(canCastRet, descriptor, instance)) break;\n        }\n\n        // In case of legacy or we were not asked to retry, don't.\n        if (vintfLegacy || !retry) break;\n\n        if (waiter != nullptr) {\n            ALOGI(\"getService: Trying again for %s/%s...\", descriptor.c_str(), instance.c_str());\n            waiter->wait(true /* timeout */);\n        }\n    }\n\n    if (waiter != nullptr) {\n        waiter->done();\n    }\n// 5. 接口类型是passthrough的,\n    if (getStub || vintfPassthru || vintfLegacy) {\n        // 5.1 创建passThroughManager\n        const sp<IServiceManager> pm = getPassthroughServiceManager();\n        if (pm != nullptr) {\n            // 5.2 getService\n            sp<IBase> base = pm->get(descriptor, instance).withDefault(nullptr);\n            if(base==nullptr) {\n                ALOGI(\"base nullptr\\n\");\n            }\n            if (!getStub || trebleTestingOverride) {\n                base = wrapPassthrough(base);\n            }\n            return base;\n        }\n    }\n\n    return nullptr;\n}\n}\n```\n\n### 1.3. recovery中hidl环境\n\n上面的代码中注意如果是recovery模式, 直接返回接口类型是passThrough的, 不再解析接口描述文件(manifest.xml), 直接创建passThroughManager.\n\n这里我们先看下passthrough方式接入的后续流程:\n\n```cpp\n// 5.2 getService\n    Return<sp<IBase>> get(const hidl_string& fqName,\n                          const hidl_string& name) override {\n        sp<IBase> ret = nullptr;\n       // 通过openLibs函数查找相关的库文件\n        \n        openLibs(fqName, [&](void* handle, const std::string &lib, const std::string &sym) {\n            IBase* (*generator)(const char* name);\n```\n\n```cpp\n static void openLibs(\n        const std::string& fqName,\n        const std::function<bool /* continue */ (void* /* handle */, const std::string& /* lib */,\n                                                 const std::string& /* sym */)>& eachLib) {\n     // /odm/lib64/hw/ /vendor/lib64/hw/ /system/lib64/vndk-sp%s/hw\n     // recovery编译中没有定义__ANDROID_VNDK__, 所以多加了 /system/lib64/hw 项\n        static std::string halLibPathVndkSp = android::base::StringPrintf(\n            HAL_LIBRARY_PATH_VNDK_SP_FOR_VERSION, details::getVndkVersionStr().c_str());\n        std::vector<std::string> paths = {\n            HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, halLibPathVndkSp,\n#ifndef __ANDROID_VNDK__\n            HAL_LIBRARY_PATH_SYSTEM,\n#endif\n        };\n    // 查找规则, 传入android.hardware.fastboot@1.0::IFastboot\n        std::string packageAndVersion = fqName.substr(0, fqName.find(\"::\"));\n        std::string ifaceName = fqName.substr(idx + strlen(\"::\"));\n        for (const std::string& path : paths) {\n     \t\tstd::vector<std::string> libs = findFiles(path, prefix, \".so\");\n            if (kIsRecovery || path == HAL_LIBRARY_PATH_SYSTEM) {\n                // recovery中 dlopen 打开lib库\n                    handle = dlopen(fullPath.c_str(), dlMode);\n                } else {\n#if !defined(__ANDROID_RECOVERY__)\n                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);#endif\n                }            \n            // 寻找HIDL_FETCH_IFastboot函数\n            *(void **)(&generator) = dlsym(handle, sym.c_str());\n            if(!generator) {\n                dlclose(handle);\n                return true;\n            }\n            // 调用HIDL_FETCH_IFastboot函数, 创建IFastboot对端的实例\n            ret = (*generator)(name.c_str());\n        }     \n```\n\nIFastboot对端的实例提供了hal中定义的接口的实现.default(instance)下的实现\n\n```shell\n[~/work_space/q9/hardware/interfaces/fastboot/1.0/default] - [日 9月 29, 15:20]\n[$] -git:(bsp-umi-q*)> tree\n.\n├── Android.bp\n├── Fastboot.cpp\n└── Fastboot.h\n```\n\n```cpp\n//Fastboot.cpp\nextern \"C\" IFastboot* HIDL_FETCH_IFastboot(const char* /* name */) {\n    return new Fastboot();\n}\n```\n\n在1217适配方案中因keymaster的改动替换了libhidlbase.so库(recovery编译–>主系统编译的, 丢失了kIsRecovery和__ANDROID_RECOVERY__ __ANDROID_VNDK__).  直接替换的方式会对recovery的运行环境产生了影响. 表现在如果未启动hwservicemanager.\n\n只要在recovery的相关进程中执行了<接口>::getService, 会一直等待**hwservicemanager.ready**属性变为true, getService一直处于阻塞状态.\n\n在调试fastbootd时, 执行`fastboot getvar all`命令无响应, 原因就是fastbootd初始化时, 加载fastboothal, 而调用了`IFastboot::getService`, 由于libhidlbase替换为主系统的, 又没执行hwservicemanager, 所以一直在等待hwservicemanager.ready=true, 从而处于阻塞状态, fastbootd服务阻塞在构造函数中, 没有回发准备好的状态, 所以fastboot 客户端无法将命令传给对端, 阻塞在发包的地方.\n\n### 1.4. hidl接口描述(getTransport)\n\n上面的流程中已大致了解了recovery下的hidl环境(主要是passthrough类型的怎么接入的), 下面主要介绍下非recovery模式下的hidl环境. 从*调用ServiceManager的getTransport函数,获取传入的hidl服务的接口类型*说起\n\n首先是函数接口, 编译通过的前提.   \n\n```cpp\n// system/libhidl/transport/manager/1.0/IServiceManager.hal   \n/**\n     * Get the transport of a service.\n     *\n     * @param fqName     Fully-qualified interface name.\n     * @param name       Instance name. Same as in IServiceManager::add\n     *\n     * @return transport Transport of service if known.\n     */\n    getTransport(string fqName, string name) generates (Transport transport);\n```\n\n实现在hwservicemanager中\n\n```cpp\n// system/hwservicemanager/ServiceManager.cpp\nReturn<ServiceManager::Transport> ServiceManager::getTransport(const hidl_string& fqName,\n                                                               const hidl_string& name) {\n    using ::android::hardware::getTransport;\n\n    if (!mAcl.canGet(fqName, getBinderCallingContext())) {\n        return Transport::EMPTY;\n    }\n    // 调用到Vintf\n    switch (getTransport(fqName, name)) {\n        case vintf::Transport::HWBINDER:\n             return Transport::HWBINDER;\n        case vintf::Transport::PASSTHROUGH:\n             return Transport::PASSTHROUGH;\n        case vintf::Transport::EMPTY:\n        default:\n             return Transport::EMPTY;\n    }\n}\n```\n\n```cpp\n// system/hwservicemanager/Vintf.cpp\nvintf::Transport getTransport(const std::string &interfaceName, const std::string &instanceName) {\n    FQName fqName;\n    // 先调用GetFrameworkHalManifest加载xml文件, 再通过getTransportFromManifest查找manifest中是否有fqName,instance的描述\n    // android.hardware.fastboot@1.0::IFastboot    default\n    vintf::Transport tr = getTransportFromManifest(fqName, instanceName,\n            vintf::VintfObject::GetFrameworkHalManifest());\n    if (tr != vintf::Transport::EMPTY) {\n        return tr;\n    }\n    tr = getTransportFromManifest(fqName, instanceName,\n            vintf::VintfObject::GetDeviceHalManifest());\n    if (tr != vintf::Transport::EMPTY) {\n        return tr;\n    }\n    return vintf::Transport::EMPTY;\n}\n```\n\n通过在framwork和device的hal manifest中查找, 主要的实现在libvintf.so库\n\n```cpp\nstd::shared_ptr<const HalManifest> VintfObject::getFrameworkHalManifest(bool skipCache) {\n    // 通过fetchedOnce 变量判断之前是否已经fetch过\n    return Get(&mFrameworkManifest, skipCache,\n               std::bind(&VintfObject::fetchFrameworkHalManifest, this, _1, _2));\n}\nstatus_t VintfObject::fetchFrameworkHalManifest(HalManifest* out, std::string* error) {\n    // /system/etc/vintf/manifest.xml\n    auto systemEtcStatus = fetchOneHalManifest(kSystemManifest, out, error);\n    if (systemEtcStatus == OK) {\n        // /system/etc/vintf/manifest/*.xml\n        auto dirStatus = addDirectoryManifests(kSystemManifestFragmentDir, out, error);\n        if (dirStatus != OK) {\n            return dirStatus;\n        }\n\n        HalManifest productManifest;\n        // /product/etc/vintf/manifest.xml\n        auto productStatus = fetchOneHalManifest(kProductManifest, &productManifest, error);\n        if (productStatus != OK && productStatus != NAME_NOT_FOUND) {\n            return productStatus;\n        }\n        if (productStatus == OK) {\n            if (!out->addAll(&productManifest, error)) {\n                if (error) {\n                    error->insert(0, \"Cannot add \" + kProductManifest + \":\");\n                }\n                return UNKNOWN_ERROR;\n            }\n        }\n        // /product/etc/vintf/manifest/*\n        return addDirectoryManifests(kProductManifestFragmentDir, out, error);\n    } else {\n        LOG(WARNING) << \"Cannot fetch \" << kSystemManifest << \": \"\n                     << (error ? *error : strerror(-systemEtcStatus));\n    }\n    // /system/manifest.xml\n    return out->fetchAllInformation(getFileSystem().get(), kSystemLegacyManifest, error);\n}\n```\n\n上述解析过程只是将相关manifest.xml的文件内容加载到内存中, 并解析. \n\n> fetch的过程中不能出错, 任何一个目录或文件的加载出错, 都会返回error\n>\n> /system/etc/vintf/manifest.xml和/system/manifest.xml文件只读取一个, 优先读etc下的, 如果etc下有, 就不会再读system/manifest.xml\n\nfetch一个(加载到内存),  解析一个. 通过 HalManifestConverter 进行后续的解析\n\n```cpp\nfetchAllInformation(fileSystem, path, gHalManifestConverter, this, error);\nstatus_t fetchAllInformation(const FileSystem* fileSystem, const std::string& path,\n                             const XmlConverter<T>& converter, T* outObject, std::string* error) \n{   \n\tstatus_t result = fileSystem->fetch(path, &info, error);\n    bool success = converter(outObject, info, error); \n}\n```\n\nfetchFrameworkHalManifest的结果为HalManifest指针, 通过其getTransport函数查找已经解析的manifest中是否有对应的hidl服务.\n\n```cpp\n//getTransportFromManifest\n    vintf::Transport tr = getTransportFromManifest(fqName, instanceName,\n            vintf::VintfObject::GetFrameworkHalManifest());\nvm->getTransport(fqName.package(), fqName.getVersion(), fqName.name(), instanceName);\nHalManifest->getTransport(fqName.package(), fqName.getVersion(), fqName.name(), instanceName);\n\n// 匹配包名, 版本, instance\nbool HalManifest::forEachInstanceOfVersion(\n    const std::string& package, const Version& expectVersion,\n    const std::function<bool(const ManifestInstance&)>& func) const {\n    for (const ManifestHal* hal : getHals(package)) {\n        bool cont = hal->forEachInstance([&](const ManifestInstance& manifestInstance) {\n            if (manifestInstance.version().minorAtLeast(expectVersion)) {\n                return func(manifestInstance);\n            }\n            return true;\n        });\n        if (!cont) return false;\n    }\n    return true;\n}\ntransport = e.transport();\n// 返回匹配hidl服务的接口类型  hwbinder/passthrough/empty\nreturn transport;\n```\n\n```xml\n    <hal format=\"hidl\">\n        // packagename\n        <name>android.hidl.manager</name>\n        <transport>hwbinder</transport>\n        <version>1.2</version>\n        <interface>\n            <name>IServiceManager</name>\n            <instance>default</instance>\n        </interface>\n        <fqname>@1.2::IServiceManager/default</fqname>\n    </hal>\n```\n\n#### 1.4.1. 小结\n\n上面主要是getTransport的流程, 解析了system/etc/vintf和product/etc/vintf下的manifest xml文件. vendor和odm的流程是一致的, 注意解析的过程中不能出现解析错误 (目录错误, 文件打开错误, 文件损坏等), 出现错误后, 所有之前的解析结果全部作废.\n\n### 1.5. hwservicemanager中查询hidl服务\n\ngetStub为false时, 通过manifest解析transport类型.  以Keymaster为例, 了解下大概的查找流程.\n\nkeymaster的接口描述在`/vendor/etc/vintf/manifest.xml`中\n\n这里通过sm->get(descriptor, instance)查询IKeymasterDevice这个hidl服务，得到IBase对象后，在通过IKeymasterDevice::castFrom转换为IKeymasterDevice对象。\n\n```cpp\nReturn<sp<IBase>> ret = sm->get(descriptor, instance);\nsp<IBase> base = ret;\nReturn<bool> canCastRet = details::canCastInterface(base.get(), descriptor.c_str(), true /* emitError */);\n```\n\nsm对象来自\n\n```cpp\n// hwservicemanager在初始化后, 会注册自己成为ContextManager   \n//     ProcessState::self()->becomeContextManager(nullptr, nullptr);\n// getContextObject(0) 就是拿的manager对象\nusing IServiceManager1_2 = android::hidl::manager::V1_2::IServiceManager;\ngDefaultServiceManager =\n                fromBinder<IServiceManager1_2, BpHwServiceManager, BnHwServiceManager>(\n                    ProcessState::self()->getContextObject(nullptr));\n```\n\nsm->get的实现在android.hidl.manager@1.2中.\n\n[system/libhidl/transport/manager/1.2/](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/system/libhidl/transport/manager/1.2/)\n\n```cpp\n//out/soong/.intermediates/system/libhidl/transport/manager/1.2/android.hidl.manager@1.2_genc++/gen/android/hidl/manager/1.2/ServiceManagerAll.cpp\n// Methods from ::android::hidl::manager::V1_0::IServiceManager follow.\n::android::hardware::Return<::android::sp<::android::hidl::base::V1_0::IBase>> BpHwServiceManager::get(const ::android::hardware::hidl_string& fqName, const ::android::hardware::hidl_string& name){\n    ::android::hardware::Return<::android::sp<::android::hidl::base::V1_0::IBase>>  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_get(this, this, fqName, name);\n    return _hidl_out;\n}\n\n```\n\n\n\n\n\n \n\n","tags":["vab","fastbootd"],"categories":["Android"]},{"title":"Q动态分区调研","url":"/2019/11/12/OTA相关/Q动态分区调研/","content":"\n# 1. Q动态分区调研\n\n## 1.1. 相关文档\n\n [Android Bootcamp 2019 - Dynamic Partitions in Q (go_android-dynamic-partitions-slides).pdf](../../../google_document/Android Bootcamp 2019 - Dynamic Partitions in Q (go_android-dynamic-partitions-slides).pdf) \n\n [06._Dynamic_Partitions_-_LPC_Android_MC_v2.pdf](../../../google_document/06._Dynamic_Partitions_-_LPC_Android_MC_v2.pdf) \n\n## 1.2. 代码路径\n\nbootable/recovery/updater/ [dynamic_partitions.cpp](../../../../work_space/q9/bootable/recovery/updater/dynamic_partitions.cpp) \n\nsystem/core/fs_mgr/ [liblp](/home/mi/work_space/q9/system/core/fs_mgr/liblp)\n\nsystem/core/fastboot/device  [fastbootd](/home/mi/work_space/q9/system/core/fastboot/device)\n\nbuild/core/Makefile\n\n## 1.3. 宏配置\n\n- PRODUCT_USE_DYNAMIC_PARTITIONS := true\n- BOARD_SUPER_PARTITION_SIZE := <size-in-bytes>\n- BOARD_SUPER_PARTITION_GROUPS := group_oem\n- BOARD_GROUP_OEM_SIZE := <size-in-bytes>\n- BOARD_GROUP_OEM_PARTITION_LIST := system vendor odm product\n- BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE\n\n>\\# BOARD_SUPER_PARTITION_GROUPS defines a list of \"updatable groups\". Each updatable group is a  group of partitions that share the same pool of free spaces.  For each group in BOARD_SUPER_PARTITION_GROUPS, a BOARD_{GROUP}_SIZE and BOARD_{GROUP}_PARTITION_PARTITION_LIST may be defined.  \n>\n>- BOARD_{GROUP}_SIZE: The maximum sum of sizes of all partitions in the group. Must not be empty.\n>\n>- BOARD_{GROUP}_PARTITION_PARTITION_LIST: the list of partitions that belongs to this group. If empty, no partitions belong to this group, and the sum of sizes is effectively 0.\n\n## 1.4. 刷机\n\n对于动态分区的特有img, 可以直接通过fastboot 烧写super.img, super.img是包含所有设定为动态的分区的镜像的总和.\n\n也可以进入用户空间的fastbootd, 烧写单独的动态的分区.\n\n- fastboot reboot fastboot\n\n### 1.4.1. fastbootd commands\n\n| Command                                         | Description                                                  | Available when device is OEM locked |\n| ----------------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |\n| getvar is-userspace                             | Return yes                                                   | Yes                                 |\n| getvar<br/>is-logical:<partition>               | Return yes if the given partition is a<br/>logical partition, no otherwise | Yes                                 |\n| getvar super-partition-name                     | MUST return super for a device<br/>launching with logical partitions | Yes                                 |\n| create-logical-partition<br/><partition> <size> | Create a logical partition with the<br/>given name and size  | No                                  |\n| delete-logical-partition<br/><partition>        | Delete the given logical partition                           | No                                  |\n| resize-logical-partition<br/><partition> <size> | Resize the logical partition to the new<br/>size without changing its contents | No                                  |\n| update-super <partition>                        | Similar to flash super, except rather<br/>than flashing raw data to the super<br/>partition, this will ensure that all<br/>partitions within the downloaded<br/>image are created | No                                  |\n| getvar max-download-size                        | Return the maximum size of an image<br/>that can be downloaded in bytes in<br/>hex | Yes                                 |\n| getvar partition-type<br/><partition-name>      | Return file system type: ext4, f2fs,<br/>raw                 | Yes                                 |\n| flash <partition name> [<br/><filename> ]       | Flash the partition through a series of<br/>download and flash fastboot<br/>protocol commands | No                                  |\n| reboot bootloader                               | Reboot into bootloader mode                                  | Yes                                 |\n| reboot fastboot                                 | Reboot back into fastbootd mode                              | Yes                                 |\n\n## 1.5. super partition 布局\n![init](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145705297_155299023.png)\n![1568031243961](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145723177_2107832549.png)\n\n### 1.5.1. 概要\n\n- 所有动态大小的分区填充到一个有固定大小的super的镜像文件中(最终烧写到super 物理分区中)\n- super的镜像中包含这些可以调整大小的子分区的内容和一些描述信息.\n- 可以调整大小的分区对应在实际的物理分区表中被super替代了\n- 非只读分区不能配置进去\n\n### 1.5.2. 实现\n\n- super镜像文件中预留1M空间给动态分区表:\n  - 动态分区名+块的索引\n  - 上述描述信息(metadata)的备份\n  - AB系统的A/B各自的描述信息\n- 描述信息(metadata)统一由liblp管理\n- liblp被集成在init/updata_engine/OTA updater/fastbootd中\n- liblp是用户空间的, kernel bootloader访问不到\n\n### 1.5.3. AB/non_ab metadata的配置\n\n- AB系统, AB各一套metadata\n  - 正在运行的系统读取另外一个未运行的系统的metadata\n  - 保证目标版本升级失败后仍能回退老的版本\n- non_AB系统, 有一个备份的metadata, 防止在metadata进行update时意外断电引起的metadata损坏.\n\n## 1.6. 开机修改\n\n- boot里又加上ramdisk了\n- boot的ramdisk里包含了first-stage阶段的init和vendor的fstab\n  - init在first-stage阶段使用liblp解析super分区的metadata描述信息, 为super中包含的每一个可调大小的子分区创建对应的dm设备\n  - 上述这些子分区在fstab中标识first_stage_mount的首先挂载上\n- system被挂载上后, boot的ramdisk被丢弃, 切换到second-stage阶段的init(system_root的ramdisk)                          \n\n## 1.7. 动态分区调整大小代码跟踪\n\n以增加分区大小为例, 跟踪下相关调用过程:\n\nupdate_script\n\nresize system <size>\n\nPerformOpResize\n\n需要先构造builder, 从builder中找到partition, 再通过builder的ResizePartition接口调整相应的分区大小.\n\n```cpp\n1. auto partition = params.builder->FindPartition(partition_name);\n// 调整分区前先要将对应的dm设备销毁\n2. UnmapPartitionOnDeviceMapper(partition_name)\n3. builder->ResizePartition(partition, size.value());\n```\n\n### 1.7.1. 构造builder(MetadataBuilder)\n\n```cpp\n// 对应super的block设备节点  \nauto super_device = GetSuperDevice();\nauto builder = MetadataBuilder::New(PartitionOpener(), super_device, 0);\n```\n\n创建MetadataBuilder的实例前先需要读出super中的metadata信息(描述super中各个子分区的布局情况)\n\n```cpp\nstd::unique_ptr<LpMetadata> metadata = ReadMetadata(opener, super_partition, slot_number);\n```\n\n#### 1.7.1.1. 解析metadata过程涉及到的相关结构体\n\n```cpp\n//metadata信息在super中的配置信息\ntypedef struct LpMetadataGeometry {\n    /*  0: Magic signature (LP_METADATA_GEOMETRY_MAGIC). */\n    uint32_t magic;\n    /*  4: Size of the LpMetadataGeometry struct. */\n    uint32_t struct_size;\n    /*  8: SHA256 checksum of this struct, with this field set to 0. */\n    uint8_t checksum[32];\n    /* 40: Maximum amount of space a single copy of the metadata can use. This\n     * must be a multiple of LP_SECTOR_SIZE.\n     */\n    uint32_t metadata_max_size;\n    /* 44: Number of copies of the metadata to keep. For A/B devices, this\n     * will be 2. For an A/B/C device, it would be 3, et cetera. For Non-A/B\n     * it will be 1. A backup copy of each slot is kept, so if this is \"2\",\n     * there will be four copies total.\n     */\n    uint32_t metadata_slot_count;\n    /* 48: Logical block size. This is the minimal alignment for partition and\n     * extent sizes, and it must be a multiple of LP_SECTOR_SIZE. Note that\n     * this must be equal across all LUNs that comprise the super partition,\n     * and thus this field is stored in the geometry, not per-device.\n     */\n    uint32_t logical_block_size;\n} __attribute__((packed)) LpMetadataGeometry;\n\n/* The logical partition metadata has a number of tables; they are described\n * in the header via the following structure\n */\n// LpMetaDataHeader中对partition/extent/group的描述信息, 用来offset偏移找到对应的数据段填充对应的结构体.\ntypedef struct LpMetadataTableDescriptor {\n    /*  0: Location of the table, relative to end of the metadata header. */\n    uint32_t offset;\n    // entry_size * num_entries = size of the table\n    /*  4: Number of entries in the table. */\n    uint32_t num_entries;\n    /*  8: Size of each entry in the table, in bytes. */\n    uint32_t entry_size;\n} __attribute__((packed)) LpMetadataTableDescriptor;\n\n//metadata位于物理分区的描述头信息\ntypedef struct LpMetadataHeader {\n    /*  0: Four bytes equal to LP_METADATA_HEADER_MAGIC. */\n    uint32_t magic;\n\n    /*  4: Version number required to read this metadata. If the version is not\n     * equal to the library version, the metadata should be considered\n     * incompatible.\n     */\n    uint16_t major_version;\n\n    /*  6: Minor version. A library supporting newer features should be able to\n     * read metadata with an older minor version. However, an older library\n     * should not support reading metadata if its minor version is higher.\n     */\n    uint16_t minor_version;\n\n    /*  8: The size of this header struct. */\n    uint32_t header_size;\n\n    /* 12: SHA256 checksum of the header, up to |header_size| bytes, computed as\n     * if this field were set to 0.\n     */\n    uint8_t header_checksum[32];\n\n    /* 44: The total size of all tables. This size is contiguous; tables may not\n     * have gaps in between, and they immediately follow the header.\n     */\n    uint32_t tables_size;\n\n    /* 48: SHA256 checksum of all table contents. */\n    uint8_t tables_checksum[32];\n\n    /* 80: Partition table descriptor. */\n    // partitions表描述信息\n    LpMetadataTableDescriptor partitions;\n    /* 92: Extent table descriptor. */\n    // partition 区间块组描述信息\n    LpMetadataTableDescriptor extents;\n    /* 104: Updateable group descriptor. */\n    // parition group表描述信息\n    LpMetadataTableDescriptor groups;\n    /* 116: Block device table. */\n    // block_devices表描述信息, 第一个必须是super, 如super中包含system/vendor等,第2个是system\n    LpMetadataTableDescriptor block_devices;\n} __attribute__((packed)) LpMetadataHeader;\n\n// 各动态分区的描述信息\ntypedef struct LpMetadataPartition {\n    char name[36];\n    /* 36: Attributes for the partition (see LP_PARTITION_ATTR_* flags above). */\n    uint32_t attributes;\n    /* 40: Index of the first extent owned by this partition. The extent will\n     * start at logical sector 0. Gaps between extents are not allowed.\n     */\n    uint32_t first_extent_index;\n    /* 44: Number of extents in the partition. Every partition must have at\n     * least one extent.\n     */\n    uint32_t num_extents;\n    /* 48: Group this partition belongs to. */\n    uint32_t group_index;\n} __attribute__((packed)) LpMetadataPartition;\n\n/* This struct defines an extent entry in the extent table block. */\n// 各动态分区的区间块的描述信息\ntypedef struct LpMetadataExtent {\n    /*  0: Length of this extent, in 512-byte sectors. */\n    uint64_t num_sectors;\n    /*  8: Target type for device-mapper (see LP_TARGET_TYPE_* values). */\n    uint32_t target_type;\n\n    /* 12: Contents depends on target_type.\n     *\n     * LINEAR: The sector on the physical partition that this extent maps onto.\n     * ZERO: This field must be 0.\n     */\n    uint64_t target_data;\n\n    /* 20: Contents depends on target_type.\n     *\n     * LINEAR: Must be an index into the block devices table.\n     * ZERO: This field must be 0.\n     */\n    uint32_t target_source;\n} __attribute__((packed)) LpMetadataExtent;\n\ntypedef struct LpMetadataPartitionGroup {\n    /*  0: Name of this group. Any unused characters must be 0. */\n    char name[36];\n\n    /* 36: Flags (see LP_GROUP_*). */\n    uint32_t flags;\n\n    /* 40: Maximum size in bytes. If 0, the group has no maximum size. */\n    uint64_t maximum_size;\n} __attribute__((packed)) LpMetadataPartitionGroup;\n\n/* This struct defines an entry in the block_devices table. There must be at\n * least one device, and the first device must represent the partition holding\n * the super metadata.\n */\ntypedef struct LpMetadataBlockDevice {\n    /* 0: First usable sector for allocating logical partitions. this will be\n     * the first sector after the initial geometry blocks, followed by the\n     * space consumed by metadata_max_size*metadata_slot_count*2.\n     */\n    uint64_t first_logical_sector;\n\n    /* 8: Alignment for defining partitions or partition extents. For example,\n     * an alignment of 1MiB will require that all partitions have a size evenly\n     * divisible by 1MiB, and that the smallest unit the partition can grow by\n     * is 1MiB.\n     *\n     * Alignment is normally determined at runtime when growing or adding\n     * partitions. If for some reason the alignment cannot be determined, then\n     * this predefined alignment in the geometry is used instead. By default\n     * it is set to 1MiB.\n     */\n    uint32_t alignment;\n\n    /* 12: Alignment offset for \"stacked\" devices. For example, if the \"super\"\n     * partition itself is not aligned within the parent block device's\n     * partition table, then we adjust for this in deciding where to place\n     * |first_logical_sector|.\n     *\n     * Similar to |alignment|, this will be derived from the operating system.\n     * If it cannot be determined, it is assumed to be 0.\n     */\n    uint32_t alignment_offset;\n\n    /* 16: Block device size, as specified when the metadata was created. This\n     * can be used to verify the geometry against a target device.\n     */\n    uint64_t size;\n\n    /* 24: Partition name in the GPT. Any unused characters must be 0. */\n    char partition_name[36];\n\n    /* 60: Flags (see LP_BLOCK_DEVICE_* flags below). */\n    uint32_t flags;\n} __attribute__((packed)) LpMetadataBlockDevice;\n\n// metadata结构体\nstruct LpMetadata {\n    LpMetadataGeometry geometry;\n    LpMetadataHeader header;\n    std::vector<LpMetadataPartition> partitions;\n    std::vector<LpMetadataExtent> extents;\n    std::vector<LpMetadataPartitionGroup> groups;\n    std::vector<LpMetadataBlockDevice> block_devices;\n};\n```\n\n#### 1.7.1.2. 读取metadata配置信息\n\n以非AB系统为例, slot_number在geometry中存储的信息为1\n\n略过super的头4k, 读取第2个4K内容(primaryGeometry), 填充**LpMetadataGeometry**结构体.\n\n```cpp\n// Read and validate geometry information from a block device that holds\n// logical partitions. If the information is corrupted, this will attempt\n// to read it from a secondary backup location.\nbool ReadLogicalPartitionGeometry(int fd, LpMetadataGeometry* geometry) {\n    if (ReadPrimaryGeometry(fd, geometry)) {\n        return true;\n    }\n    return ReadBackupGeometry(fd, geometry);\n}\nbool ReadPrimaryGeometry(int fd, LpMetadataGeometry* geometry) {\n    std::unique_ptr<uint8_t[]> buffer = std::make_unique<uint8_t[]>(LP_METADATA_GEOMETRY_SIZE);\n    if (SeekFile64(fd, GetPrimaryGeometryOffset(), SEEK_SET) < 0) {\n        return false;\n    }\n    if (!android::base::ReadFully(fd, buffer.get(), LP_METADATA_GEOMETRY_SIZE)) {\n        return false;\n    }\n    return ParseGeometry(buffer.get(), geometry);\n}\nmemcpy(geometry, buffer, sizeof(*geometry));\n```\n\n读取第3个4K内容(backup_geometry), 填充到backup_geometry\n\n从第4个4k开始, 读取geometry中配置的metadata大小, 填充到**LpMetadata**结构体, primary_metadata.\n\n…\n\n```cpp\n// Parse and validate all metadata at the current position in the given file\n// descriptor.\nstatic std::unique_ptr<LpMetadata> ParseMetadata(const LpMetadataGeometry& geometry,\n                                                 Reader* reader) {\n    // 填充LpMetadataHeader, 包含了metadata的版本等\n    std::unique_ptr<LpMetadata> metadata = std::make_unique<LpMetadata>();\n    if (!reader->ReadFully(&metadata->header, sizeof(metadata->header))) {\n        return nullptr;\n    }\n    if (!ValidateMetadataHeader(metadata->header)) {\n        return nullptr;\n    }\n    // 填充LpMetadataGeometry\n    metadata->geometry = geometry;\n    LpMetadataHeader& header = metadata->header;\n\n    // Read the metadata payload. Allocation is fallible in case the metadata is\n    // corrupt and has some huge value.\n    // 读取LpMetadata中LpMetaDataHeader外剩下的数据, 算一个checksum和header中的checksum比对, 必须是一致的\n    std::unique_ptr<uint8_t[]> buffer(new (std::nothrow) uint8_t[header.tables_size]);\n    if (!reader->ReadFully(buffer.get(), header.tables_size)) {\n        return nullptr;\n    }\n    uint8_t checksum[32];\n    SHA256(buffer.get(), header.tables_size, checksum);\n    if (memcmp(checksum, header.tables_checksum, sizeof(checksum)) != 0) {\n        LERROR << \"Logical partition metadata has invalid table checksum.\";\n        return nullptr;\n    }\n\n    // ValidateTableSize ensured that |cursor| is valid for the number of\n    // entries in the table.\n    // header中记录了partition 表的信息,包含了offset, 有几个分区,每个分区item的大小\n    uint8_t* cursor = buffer.get() + header.partitions.offset;\n    for (size_t i = 0; i < header.partitions.num_entries; i++) {\n        LpMetadataPartition partition;\n        memcpy(&partition, cursor, sizeof(partition));\n        // 一共num_entries个partition, 遍历metadata的partition table, cursor记录了每个partition的头\n        cursor += header.partitions.entry_size;\n\n        // partion校验\n        if (partition.attributes & ~LP_PARTITION_ATTRIBUTE_MASK) {\n            LERROR << \"Logical partition has invalid attribute set.\";\n            return nullptr;\n        }\n        ...\n        // 填充LpMetadata的partitions vector\n        metadata->partitions.push_back(partition);\n    }\n\n    cursor = buffer.get() + header.extents.offset;\n    for (size_t i = 0; i < header.extents.num_entries; i++) {\n        LpMetadataExtent extent;\n        memcpy(&extent, cursor, sizeof(extent));\n        cursor += header.extents.entry_size;\n\n        if (extent.target_type == LP_TARGET_TYPE_LINEAR &&\n            extent.target_source >= header.block_devices.num_entries) {\n            LERROR << \"Logical partition extent has invalid block device.\";\n            return nullptr;\n        }\n\n        metadata->extents.push_back(extent);\n    }\n\n    cursor = buffer.get() + header.groups.offset;\n    for (size_t i = 0; i < header.groups.num_entries; i++) {\n        LpMetadataPartitionGroup group = {};\n        memcpy(&group, cursor, sizeof(group));\n        cursor += header.groups.entry_size;\n\n        metadata->groups.push_back(group);\n    }\n\n    cursor = buffer.get() + header.block_devices.offset;\n    for (size_t i = 0; i < header.block_devices.num_entries; i++) {\n        LpMetadataBlockDevice device = {};\n        memcpy(&device, cursor, sizeof(device));\n        cursor += header.block_devices.entry_size;\n\n        metadata->block_devices.push_back(device);\n    }\n\n    const LpMetadataBlockDevice* super_device = GetMetadataSuperBlockDevice(*metadata.get());\n    if (!super_device) {\n        LERROR << \"Metadata does not specify a super device.\";\n        return nullptr;\n    }\n    return metadata;\n}\n```\n![1568276907369](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145634636_712779062.png)\n\n#### 1.7.1.3. builder初始化\n\n```cpp\nstd::unique_ptr<MetadataBuilder> MetadataBuilder::New(const LpMetadata& metadata,\n                                                      const IPartitionOpener* opener) {\n    //1. builder构造函数\n    std::unique_ptr<MetadataBuilder> builder(new MetadataBuilder());\n    //2. builder init函数\n    if (!builder->Init(metadata)) {\n        return nullptr;\n    }\n\t...\n    return builder;\n}\n\nMetadataBuilder::MetadataBuilder() : auto_slot_suffixing_(false), ignore_slot_suffixing_(false) {\n    // 初始化geometry和header_ \n    memset(&geometry_, 0, sizeof(geometry_));\n    geometry_.magic = LP_METADATA_GEOMETRY_MAGIC;\n    geometry_.struct_size = sizeof(geometry_);\n\n    memset(&header_, 0, sizeof(header_));\n    header_.magic = LP_METADATA_HEADER_MAGIC;\n    header_.major_version = LP_METADATA_MAJOR_VERSION;\n    header_.minor_version = LP_METADATA_MINOR_VERSION;\n    header_.header_size = sizeof(header_);\n    header_.partitions.entry_size = sizeof(LpMetadataPartition);\n    header_.extents.entry_size = sizeof(LpMetadataExtent);\n    header_.groups.entry_size = sizeof(LpMetadataPartitionGroup);\n    header_.block_devices.entry_size = sizeof(LpMetadataBlockDevice);\n}\n//从前面解析出的metadata信息中初始化builder的成员变量.\n// 执行AddGroup/AddPartition/ImportExtents函数, 初始化block_devices_ groups_ paritions_ extents_成员变量\nbool MetadataBuilder::Init(const LpMetadata& metadata) {\n    geometry_ = metadata.geometry;\n    block_devices_ = metadata.block_devices;\n\n    for (const auto& group : metadata.groups) {\n        std::string group_name = GetPartitionGroupName(group);\n        if (!AddGroup(group_name, group.maximum_size)) {\n            return false;\n        }\n    }\n\n    for (const auto& partition : metadata.partitions) {\n        std::string group_name = GetPartitionGroupName(metadata.groups[partition.group_index]);\n        Partition* builder =\n                AddPartition(GetPartitionName(partition), group_name, partition.attributes);\n        if (!builder) {\n            return false;\n        }\n        // 对某一特定的partition执行时, 会判断extent是否相邻, 如果是相邻的, 会进行合并\n        ImportExtents(builder, metadata, partition);\n    }\n    return true;\n}\n```\n\n### 1.7.2. builder->ResizePartition\n\n```cpp\nbuilder->ResizePartition(partition, size.value();\nbool MetadataBuilder::ResizePartition(Partition* partition, uint64_t requested_size) {\n    // Align the space needed up to the nearest sector.\n    // 先对新size进行对齐\n    uint64_t aligned_size = AlignTo(requested_size, geometry_.logical_block_size);\n    uint64_t old_size = partition->size();\n    // 1. 看下新size是否超出了可调整的范围\n    if (!ValidatePartitionSizeChange(partition, old_size, aligned_size, false)) {\n        return false;\n    }\n    //2. 分区增大了\n    if (aligned_size > old_size) {\n        if (!GrowPartition(partition, aligned_size)) {\n            return false;\n        }\n        //分区较小了\n    } else if (aligned_size < partition->size()) {\n        ShrinkPartition(partition, aligned_size);\n    }\n    return true;\n}\n```\n\n1. 怎么判断分区大小是否是合法的?\n\n```cpp\nbool MetadataBuilder::ValidatePartitionSizeChange(Partition* partition, uint64_t old_size,\n                                                  uint64_t new_size, bool force_check) {\n    // 查找partition所在的组\n    PartitionGroup* group = FindGroup(partition->group_name());\n    CHECK(group);\n\n    if (!force_check && new_size <= old_size) {\n        return true;\n    }\n\n    // Figure out how much we need to allocate, and whether our group has\n    // enough space remaining.\n    uint64_t space_needed = new_size - old_size;\n    if (group->maximum_size() > 0) {\n        // 分区组的已用空间\n        uint64_t group_size = TotalSizeOfGroup(group);\n        if (group_size >= group->maximum_size() ||\n            // 分区组的最大空间\n            group->maximum_size() - group_size < space_needed) {\n            LERROR << \"Partition \" << partition->name() << \" is part of group \" << group->name()\n                   << \" which does not have enough space free (\" << space_needed << \" requested, \"\n                   << group_size << \" used out of \" << group->maximum_size() << \")\";\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n能看到分区能调整的大小受分区所在组最大空间的限制.\n\n#### 1.7.2.1. 调大分区\n\n找出空闲的extent, 加到当前待调整的partition的extents_中\n\n```cpp\nbool MetadataBuilder::GrowPartition(Partition* partition, uint64_t aligned_size) {\n    uint64_t space_needed = aligned_size - partition->size();\n    uint64_t sectors_needed = space_needed / LP_SECTOR_SIZE;\n    // 根据已有的extent, 做相邻extent的gap, gap有效即为free的\n    //The new interval represents the free space starting at the end of\n        //the previous interval, and ending at the start of the next interval.\n       // free_regions->emplace_back(current.device_index, aligned, current.start);    \n    std::vector<Interval> free_regions = GetFreeRegions();\n\n    const uint64_t sectors_per_block = geometry_.logical_block_size / LP_SECTOR_SIZE;\n    std::vector<std::unique_ptr<LinearExtent>> new_extents;\n\n    // If the last extent in the partition has a size < alignment, then the\n    // difference is unallocatable due to being misaligned. We peek for that\n    // case here to avoid wasting space.\n    if (auto extent = ExtendFinalExtent(partition, free_regions, sectors_needed)) {\n        sectors_needed -= extent->num_sectors();\n        new_extents.emplace_back(std::move(extent));\n    }\n    // 从free_regions中查找可以空闲的extent, 给当前正在调整大小的partition使用\n    for (auto& region : free_regions) {\n        // 分配够了就退出\n        if (!sectors_needed) {\n            break;\n        }\n        ...\n        uint64_t sectors = std::min(sectors_needed, region.length());\n        auto extent = std::make_unique<LinearExtent>(sectors, region.device_index, region.start);\n        new_extents.push_back(std::move(extent));\n        sectors_needed -= sectors;\n    }\n    // Everything succeeded, so commit the new extents.\n    // 将新的extent加到partition对应的extents中\n    for (auto& extent : new_extents) {\n        partition->AddExtent(std::move(extent));\n    }\n    return true;\n}\n```\n\n### 1.7.3. 输出新的metadata更新到disk中\n\n有分区变动后, 需要在内存中生成一份整体的变动后的metadata信息.\n\n```cpp\nauto metadata = builder->Export();\nstd::unique_ptr<LpMetadata> MetadataBuilder::Export() {\n    // 校验group下的所有分区的空间总和小于group的最大空间\n    if (!ValidatePartitionGroups()) {\n        return nullptr;\n    }\n    // 构造一份新的metadata\n    std::unique_ptr<LpMetadata> metadata = std::make_unique<LpMetadata>();\n    metadata->header = header_;\n    metadata->geometry = geometry_;\n\n    // Assign this early so the extent table can read it.\n    for (const auto& block_device : block_devices_) {\n        metadata->block_devices.emplace_back(block_device);\n        if (auto_slot_suffixing_) {\n            metadata->block_devices.back().flags |= LP_BLOCK_DEVICE_SLOT_SUFFIXED;\n        }\n    }\n\n    std::map<std::string, size_t> group_indices;\n    for (const auto& group : groups_) {\n        LpMetadataPartitionGroup out = {};\n        strncpy(out.name, group->name().c_str(), sizeof(out.name));\n        out.maximum_size = group->maximum_size();\n\n        group_indices[group->name()] = metadata->groups.size();\n        metadata->groups.push_back(out);\n    }\n\n    // Flatten the partition and extent structures into an LpMetadata, which\n    // makes it very easy to validate, serialize, or pass on to device-mapper.\n    for (const auto& partition : partitions_) {\n        LpMetadataPartition part;\n        memset(&part, 0, sizeof(part));\n        ...\n        strncpy(part.name, partition->name().c_str(), sizeof(part.name));\n        part.first_extent_index = static_cast<uint32_t>(metadata->extents.size());\n        part.num_extents = static_cast<uint32_t>(partition->extents().size());\n        part.attributes = partition->attributes();\n        if (auto_slot_suffixing_) {\n            part.attributes |= LP_PARTITION_ATTR_SLOT_SUFFIXED;\n        }\n\n        auto iter = group_indices.find(partition->group_name());\n        part.group_index = iter->second;\n\n        for (const auto& extent : partition->extents()) {\n            // 保存到metadata的extents字段中\n            if (!extent->AddTo(metadata.get())) {\n                return nullptr;\n            }\n        }\n        metadata->partitions.push_back(part);\n    }\n\n    metadata->header.partitions.num_entries = static_cast<uint32_t>(metadata->partitions.size());\n    metadata->header.extents.num_entries = static_cast<uint32_t>(metadata->extents.size());\n    metadata->header.groups.num_entries = static_cast<uint32_t>(metadata->groups.size());\n    metadata->header.block_devices.num_entries =\n            static_cast<uint32_t>(metadata->block_devices.size());\n    return metadata;\n}\n```\n\n将新的分区信息更新到对应的super的设备节点中.\n\n```cpp\nUpdatePartitionTable(super_device, *metadata, 0) {\n    android::base::unique_fd fd = opener.Open(super_partition, O_RDWR | O_SYNC);\n    std::string blob;\n    // 校验和序列化metadata数据, 如extents/partitions/block_devices字段是否是合法的.\n    if (!ValidateAndSerializeMetadata(opener, metadata, slot_suffix, &blob)) {\n        return false;\n    }\n    // 比较新老geometry的配置是否是一致的.  metadata_max_size/ metadata_slot_count / logical_block_size\n    if (!CompareGeometry(geometry, old_geometry)) {\n        LERROR << \"Incompatible geometry in new logical partition metadata\";\n        return false;\n    }\n    ...\n    // 往磁盘中更新primary和backup的metadata\n    if (!WriteMetadata(fd, metadata, slot_number, blob, writer)) {\n        return false;\n    }    \n}\n\n```\n\n### 1.7.4. 小结\n\n主要是对涉及到的数据结构的理解\n\n对于非ab系统的(slot_count=1)的, 可以简单看下其中涉及的结构\n\n首先是geometry, 包括primary和backup的, 每个4k, 描述了metadata的配置信息.\n\n其次是metadata, 包括primary和backup的, 大小信息被配置在geometry中, 描述了分区/分区组/分区的range块的信息.\n\n## 1.8. map partition\n\n分区调整后, 如果当前修改的分区正在被使用中, 需要卸载unmap, 再重新map和挂载. 如果是系统分区卸载和unmap的操作会影响手机的运行, 因此手机需要重启才能重新map和挂载.\n\n动态分区的调整需要重新map才能生效. 这里看下map的流程.\n\n该过程与device-mapper的使用规范是紧密关联的, 只是在user space层多加了一个DeviceMapper实例对dm设备的创建查询销毁等操作进行托管.\n\n### 1.8.1. device-mapper\n\n![图1 Device Mapper的内核体系架构](/home/mi/Pictures/documents/dynamic_partition/data_analyze.zip)\n\n![“linux storage stack”的图片搜索结果](http://www.sysnote.org/2015/08/06/linux-io-stack/io-stack.png)\n\nDevice-mapper是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。\n\n当前比较流行的 Linux 下的逻辑卷管理器如 `LVM2`（Linux Volume Manager 2 version)、`EVMS`(Enterprise Volume Management System)、`dmraid`(Device Mapper Raid Tool)等都是基于该机制实现的。\n\n `Device Mapper` 工作在块级别（block），并不工作在文件级别（file）。`Device Mapper` 自 Linux 2.6.9 后编入 Linux 内核，所有基于 Linux 内核 2.6.9 以后的发行版都内置 `Device Mapper`.\n\nDevice mapper 在内核中作为一个块设备驱动被注册的，它包含三个重要的对象概念:\n\n- mapped device \n\n  Mapped device 是一个逻辑抽象(dm-*)，可以理解成为内核向外提供的逻辑设备，它通过映射表描述的映射关系和 target device (super)建立映射。\n\n- 映射表\n\n  是由用户空间创建，传递到内核空间。映射表里有映射设备逻辑的`起始地址`、`范围`、和表示在目标设备所在物理设备的`地址偏移量`以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到 128 的时候，其实表示的是 128*512=64K）。\n\n- target device\n\n​       可以是真实的物理设备, 也可以是dm的虚拟设备. Device mapper 中这三个对象和 target driver 插件一起构成了一个可迭代的设备树.\n\n![undefined](https://arkingc.github.io/img/in-post/post-linux-lvm/dm.png)\n\n\n\n映射驱动在内核空间是插件，`Device Mapper` 在内核中通过一个一个模块化的 `Target Driver` 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照、`线性映射`等，策略和机制分离.\n\nDevice mapper处理所有从`generic_make_request`和`submit_bio`接口中定向到`mapped device`的所有块读写I/O请求。I/O请求在device mapper的设备树中通过请求转发从上到下地进行处理. Device mapper本质功能就是根据映射关系和target driver描述的IO处理规则，将IO请求从逻辑设备mapped device转发相应的target device上\n\n- **向下转发**：当一个bio请求在设备树中的mapped deivce向下层转发时，一个或者多个bio的克隆被创建并发送给下层target device。然后相同的过程在设备树的每一个层次上重复，只要设备树足够大理论上这种转发过程可以无限进行下去\n- **向上返回事件**：在设备树上某个层次中，target driver结束某个bio请求后，将表示结束该bio请求的事件上报给它上层的mapped device，该过程在各个层次上进行直到该事件最终上传到根mapped device的为止，然后device mapper结束根mapped device上原始bio请求，结束整个I/O请求过程.\n\n#### 1.8.1.1. 用户空间的操作规范：\n\nDevice mapper库就是对ioctl、用户空间创建删除device mapper逻辑设备所需必要操作的封装，dmsetup是一个提供给用户直接可用的创建删除device mapper设备的命令行工具。用户空间主要负责如下工作：\n\n1. 发现每个mapped device相关的target device；\n2. 根据配置信息创建映射表；\n3. 将用户空间构建好的映射表传入内核，让内核构建该mapped device对应的dm_table结构；\n4. 保存当前的映射信息，以便未来重新构建。\n\ndm设备举例:\n\n```shell\n0    1024 linear /dev/sda 204\n1024 512  linear /dev/sdb 766\n1536 128  linear /dev/sdc 0\n```\n\n\n\n![undefined](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/example.png)\n\n\n\n#### 1.8.1.2. Q上动态分区的映射\n\n- 动态分区机制使用`dm-linear`设备驱动映射逻辑扇区到super中的system/vendor等只读分区的物理扇区上.\n- 通过修改大小, 动态分区可能变成片段化的\n\n/dev/block/by-name/super       super.img\n\n```shell\n/dev/block/by-name/dm-0 (system):\n\tdm-linear super <block range 1>\n/dev/block/by-name/dm-1 (vendor):\n\tdm-linear super <block range 2>\n```\n![resize partition](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145450363_1270541820.png)\n\n\n```shell\n/dev/block/by-name/dm-0 (system):\n\tdm-linear super <block range 1>\n\tdm-linear super <block range 3>\n/dev/block/by-name/dm-1 (vendor):\n    dm-linear super <block range 2>\n    dm-linear super <block range 4>\n```\n\n#### 1.8.1.3. DeviceMapper库创建(用户空间)\n\n```cpp\nauto state = DeviceMapper::Instance().GetState(partition_name);\nif (state == DmDeviceState::INVALID) {\n    return CreateLogicalPartition(GetSuperDevice(), 0 /* metadata slot */, partition_name,\n                                  true /* force writable */, kMapTimeout, path);\n}\nstatic bool CreateLogicalPartition(const LpMetadata& metadata, const LpMetadataPartition& partition,\n                                   bool force_writable, const std::chrono::milliseconds& timeout_ms,\n                                   const std::string& super_device, std::string* path) {\n    DeviceMapper& dm = DeviceMapper::Instance();\n\n    DmTable table;\n    // ---> 1. 创建dm映射表\n    if (!CreateDmTable(metadata, partition, super_device, &table)) {\n        return false;\n    }\n    if (force_writable) {\n        table.set_readonly(false);\n    }\n    // ---> 2. 根据映射表和target_device创建mapped_device\n    std::string name = GetPartitionName(partition);\n    if (!dm.CreateDevice(name, table)) {\n        return false;\n    }\n    if (!dm.GetDmDevicePathByName(name, path)) {\n        return false;\n    }\n    if (timeout_ms > std::chrono::milliseconds::zero()) {\n    // ---> 3. 等待mapped_device创建完成, 超时销毁\n        if (!fs_mgr_wait_for_file(*path, timeout_ms, FileWaitMode::Exists)) {\n            DestroyLogicalPartition(name, {});\n            return false;\n        }\n    }\n    return true;\n}\n// ----> 1. 创建映射表\nstatic bool CreateDmTable(const LpMetadata& metadata, const LpMetadataPartition& partition,\n                          const std::string& super_device, DmTable* table) {\n    uint64_t sector = 0;\n    // 对应于一个子分区, 其中所属的extent range块已经被编排到metadata的extents段中, 是相连的. start是partition的first_extent_index, 往后num_extents个item都是属于该子分区的. 这个编排是在builder Init时通过ImportExtents函数做的\n    for (size_t i = 0; i < partition.num_extents; i++) {\n        const auto& extent = metadata.extents[partition.first_extent_index + i];\n        std::unique_ptr<DmTarget> target;\n        switch (extent.target_type) {\n            ...\n            case LP_TARGET_TYPE_LINEAR: {\n                const auto& block_device = metadata.block_devices[extent.target_source];\n                std::string path;\n                GetPhysicalPartitionDevicePath(metadata, block_device, super_device, &path)\n                // 对应每个extent range块,构造对应的target item(开始的扇区号,多少个扇区,block_device name, 映射的物理扇区的起始扇区号)\n                target = std::make_unique<DmTargetLinear>(sector, extent.num_sectors, path,\n                                                          extent.target_data);\n                break;\n            }\n            ...\n        }\n        // 每个extent range块构造的target item串联起来,放在table的targets下. target item的target_data是从小往大排的\n        if (!table->AddTarget(std::move(target))) {\n            return false;\n        }\n        sector += extent.num_sectors;\n    }\n    if (partition.attributes & LP_PARTITION_ATTR_READONLY) {\n        table->set_readonly(true);\n    }\n    return true;\n}\n\n// ---> 2. 根据映射表和target_device创建mapped_device\ndm.CreateDevice(name, table)\n{\n    struct dm_ioctl io;\n    InitIo(&io, name);\n    // 通过ioctl创建dm设备\n    if (ioctl(fd_, DM_DEV_CREATE, &io)) {\n        return false;\n    }\n    \n    LoadTableAndActivate(name, table) {\n        std::string ioctl_buffer(sizeof(struct dm_ioctl), 0);\n        // ==========> 2.1 调用映射表的序列化函数将前面的target_序列化输出到ioctl_buffer中\n        ioctl_buffer += table.Serialize();\n\n        struct dm_ioctl* io = reinterpret_cast<struct dm_ioctl*>(&ioctl_buffer[0]);\n        InitIo(io, name);\n        io->data_size = ioctl_buffer.size();\n        io->data_start = sizeof(struct dm_ioctl);\n        io->target_count = static_cast<uint32_t>(table.num_targets());\n        if (table.readonly()) {\n            io->flags |= DM_READONLY_FLAG;\n        }\n        //Load a table into the 'inactive' slot for the device\n        if (ioctl(fd_, DM_TABLE_LOAD, io)) {\n            return false;\n        }\n\n        InitIo(io, name);\n        // 设备处于就绪状态或resume状态, 根据上面传入的io的flag决定. 没有带DM_SUSPEND_FLAG的flag, 是走resume状态\n        /*If a table is present in the 'inactive'\n \t\t * slot, it will be moved to the active slot, then the old table from the active slot will be               _destroyed_.  Finally the device is resumed.\n \t\t */\n        if (ioctl(fd_, DM_DEV_SUSPEND, io)) {\n            return false;\n        }    \n    }    \n\t// 通过ioctl获取dm设备的状态\n    if (ioctl(fd_, DM_DEV_STATUS, &io) < 0) {\n        return false;\n    }\n    uint32_t dev_num = minor(io.dev);\n    //dm-<minor> 设备对应io->name(target_device)绑定的mapped_device\n    *path = \"/dev/block/dm-\" + std::to_string(dev_num);\n}\n// ---> 3. 等待mapped_device dm-<minior>创建完成, 超时销毁\n\n```\n\n在上面创建映射表并初始化dm设备的过程中, 最重要的参数是dmtarget的序列化做的工作\n\n```cpp\n// ==========> 2.1 调用映射表的序列化函数将前面的target_序列化输出到ioctl_buffer中\nioctl_buffer += table.Serialize();\nstd::string DmTable::Serialize() const {\n    std::string table;\n    for (const auto& target : targets_) {\n        table += target->Serialize();\n    }\n    return table;\n}\nstd::string DmTarget::Serialize() const {\n    // Create a string containing a dm_target_spec, parameter data, and an\n    // explicit null terminator.\n    std::string data(sizeof(dm_target_spec), '\\0');\n    //构造头部, block_device_ + \" \" + std::to_string(physical_sector_); // target_data\n    data += GetParameterString();\n    data.push_back('\\0');\n\n    // The kernel expects each target to be 8-byte aligned.\n    size_t padding = DM_ALIGN(data.size()) - data.size();\n    for (size_t i = 0; i < padding; i++) {\n        data.push_back('\\0');\n    }\n\n    // Finally fill in the dm_target_spec.\n    struct dm_target_spec* spec = reinterpret_cast<struct dm_target_spec*>(&data[0]);\n    // 开始的扇区号\n    spec->sector_start = start();\n    // 包含多少个扇区\n    spec->length = size();\n    // 这里的name对应dm-linear的name即\"linear\", device-mapper驱动是通过target-type转到对应的插件去处理的\n    snprintf(spec->target_type, sizeof(spec->target_type), \"%s\", name().c_str());\n    // 将本段的大小偏移量作为下一段dm_target_spec的起始, 多个dm_target_spec item首尾相连\n    spec->next = (uint32_t)data.size();\n    return data;\n}\n```\n\n用户空间使用ioctl的步骤:\n\n- 先创建一个dm-ioctl和dm_target_spec对象\n\n- 配置一下他们的参数\n\n- 在`dm_target_spec`后面跟一个特定设备的特定参数(special param)\n\n  将三者结合到dm-ioctl上，通过调用一下命令就可以在device mapper中load一个dm设备了\n\n```cpp\nstruct dm_target_spec {\n\t__u64 sector_start;\n\t__u64 length;\n\t__s32 status;\t\t/* used when reading from kernel only */\n\n\t/*\n\t * Location of the next dm_target_spec.\n\t * - When specifying targets on a DM_TABLE_LOAD command, this value is\n\t *   the number of bytes from the start of the \"current\" dm_target_spec\n\t *   to the start of the \"next\" dm_target_spec.\n\t * - When retrieving targets on a DM_TABLE_STATUS command, this value\n\t *   is the number of bytes from the start of the first dm_target_spec\n\t *   (that follows the dm_ioctl struct) to the start of the \"next\"\n\t *   dm_target_spec.\n\t */\n\t__u32 next;\n\n\tchar target_type[DM_MAX_TYPE_NAME];\n};\n```\n\n相关ioctl源代码[kernel](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/)/[msm-4.19](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/)/[drivers](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/)/[md](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/md/)/[dm-ioctl.c](http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/md/dm-ioctl.c)\n\n![device_map](https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145257141_746207219.png)","tags":["vab"],"categories":["Android"]},{"title":"AB调试笔记","url":"/2019/11/12/OTA相关/AB调试笔记/","content":"\n# AB调试笔记\n\n基于androidP base.\n\n## 相关文档\n### 官方文档\n[AB官方文档](https://source.android.com/devices/tech/ota/ab)\n\n在启用了 A/B 的设备上，可以在后台对应用进行编译，以更新到新的系统映像。如需在系统映像中选择性地加入编译脚本和二进制文件，请参阅在后台编译应用。\n\n[preopt相关](https://source.android.com/devices/tech/dalvik/configure.html#other_odex)\n\n[AB 系统更新概括](https://source.android.com/devices/tech/ota/ab_updates.html#compilation)\n\n[AB配置](https://source.android.com/devices/tech/ota/ab_implement.html)https://source.android.com/devices/tech/ota/ab_implement.html)\n\n### 第三方文档\n[Android A/B System OTA分析（一）概览](https://blog.csdn.net/guyongqiangx/article/details/71334889)\n\n[Android A/B System OTA分析（二）系统image的生成](https://blog.csdn.net/guyongqiangx/article/details/71516768)\n\n[Android A/B System OTA分析（三）主系统和bootloader的通信](https://blog.csdn.net/guyongqiangx/article/details/72480154)\n\n[Android A/B System OTA分析（四）系统的启动和升级](https://blog.csdn.net/guyongqiangx/article/details/72604355)\n\n启用IBootControl服务(hidl相关配置)相关文档\n\n[hidl配置简介](http://hooltech.com/android-hidl.html#简介)https://blog.csdn.net/guyongqiangx/article/details/72604355)\n\n### 之前的项目文档\n\n[A/B系统升级功能点](https://wiki.n.miui.com/pages/viewpage.action?pageId=33933409)\n\n[A/B 系统升级（双分区系统升级）](https://wiki.n.miui.com/pages/viewpage.action?pageId=33930350)\n\n[Android One A/B OTA Updater](https://wiki.n.miui.com/pages/viewpage.action?pageId=34968890)\n\n## 配置相关\n\n### 设置编译变量\n支持 A/B 更新的引导加载程序必须满足以下编译变量条件:\n\n#### 必须针对 A/B 更新目标定义的变量 \n- AB_OTA_UPDATER := true\n- AB_OTA_PARTITIONS := \\\n  boot \\\n  system \\\n  vendor\n- 以及通过 update_engine 更新的其他分区（无线装置、引导加载程序等）。\n- BOARD_BUILD_SYSTEM_ROOT_IMAGE := true\n- TARGET_NO_RECOVERY := true\n- BOARD_USES_RECOVERY_AS_BOOT := true\n- PRODUCT_PACKAGES += \\\n  update_engine \\\n  update_verifier\n- 要查看示例，请参阅 /device/google/marlin/+/android-7.1.0_r1/device-common.mk。 您可以选择执行编译中所述的安装后（但在重新启动前）dex2oat 步骤.\n\n#### 无法针对 A/B 目标定义的变量:\n- BOARD_RECOVERYIMAGE_PARTITION_SIZE\n- BOARD_CACHEIMAGE_PARTITION_SIZE\n- BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE\n\n#### 可选 针对调试版本定义的变量\nPRODUCT_PACKAGES_DEBUG += update_engine_client\n\n### (节选) 非GMS版本需要客户端\n- GmsCore 起到什么作用？\n在 Google 的 A/B 实现中，平台 API 和 update_engine 负责提供机制，而 GmsCore 则负责提供政策。也就是说，平台知道如何应用 A/B 更新，并且所有相应代码都位于 AOSP 中（如上所述），而 GmsCore 则负责确定应用哪些内容以及何时应用。\n如果不使用 GmsCore，则可以使用`相同的平台 API` 编写自己的替代项。用于`控制 update_engine 的平台`.  Java API 是 android.os.UpdateEngine：`frameworks/base/core/java/android/os/UpdateEngine.java`。调用程序可以提供 `UpdateEngineCallback`，以便接收有关状态更新的通知：`frameworks/base/+/master/core/java/android/os/UpdateEngineCallback.java`。请参阅核心类的参考文件，了解如何使用相应接口。\n\n## 空间对比\n| abl_b         | 2048       |\n| ------------- | ---------- |\n| aop_b         | 512        |\n| bluetooth_b   | 1024       |\n| boot_b        | 131072     |\n| cmnlib64_b    | 1024       |\n| cmnlib_b      | 1024       |\n| devcfg_b      | 256        |\n| dsp_b         | 65536      |\n| dtbo_b        | 32768      |\n| hyp_b         | 8192       |\n| ifaa_b        | 65536      |\n| imagefv_b     | 2048       |\n| keymaster_b   | 1024       |\n| modem_b       | 327680     |\n| multiimgoem_b | 32         |\n| qupfw_b       | 128        |\n| system_b      | 3670016    |\n| tz_b          | 4096       |\n| uefisecapp_b  | 2048       |\n| vbmeta_b      | 128        |\n| vendor_b      | 2097152    |\n| xbl_b         | 7168       |\n| xbl_config_b  | 512        |\n| total         | 6270.53125 |\n\n## 升级包相关\n升级包结构\n\n```shell\n├── care_map.txt\n├── compatibility.zip\n├── META-INF\n│   ├── CERT.RSA\n│   ├── CERT.SF\n│   ├── com\n│   │   └── android\n│   │       ├── metadata\n│   │       └── otacert\n│   └── MANIFEST.MF\n├── payload.bin\n└── payload_properties.txt\n\n```\n\n主要文件全在payload.bin中, 没有升级脚本\n\nmetadata文件:\n\n```shell\nota-property-files=payload_metadata.bin:9649:149799,payload.bin:9649:1153246262,payload_properties.txt:1153255969:156,care_map.txt:752:239,compatibility.zip:1044:8558,metadata:69:635\nota-required-cache=0\nota-streaming-property-files=payload.bin:9649:1153246262,payload_properties.txt:1153255969:156,care_map.txt:752:239,compatibility.zip:1044:8558,metadata:69:635\nota-type=AB\npost-build=xiaomi/jasmine/jasmine_sprout:9/PKQ1.180904.001/9.7.23:user/release-keys\npost-build-incremental=9.7.23\npost-sdk-level=28\npost-security-patch-level=2019-08-05\npost-timestamp=1563835614\npre-device=jasmine_sprout\n```\n\n- 生成完整OTA\n```shell\n./build/tools/releasetools/ota_from_target_files \\\n  dist_output/tardis-target_files.zip ota_update.zip\n```\n-生成增量 OTA\n```shell\n./build/tools/releasetools/ota_from_target_files \\\n  -i PREVIOUS-tardis-target_files.zip \\\n  dist_output/tardis-target_files.zip incremental_ota_update.zip\n```\n\n## 开机服务启动代码分析\nupdate_verifier\n\n```shell\nvendor/etc/init/hw/init.target.rc\non fs\n    mount_all /vendor/etc/fstab.qcom\n\ndo_mount_all\nmount_fstab_return_code = mount_fstab(fstabfile, mount_mode);\n/* queue_fs_event will queue event based on mount_fstab return code\n * and return processed return code*/\nauto queue_fs_result = queue_fs_event(*mount_fstab_return_code);\n\nelse if (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) {\n        property_set(\"ro.crypto.state\", \"encrypted\");\n        property_set(\"ro.crypto.type\", \"block\");\n        ActionManager::GetInstance().QueueEventTrigger(\"defaultcrypto\");\n        return Success();\n    }\n\non defaultcrypto\n    exec - root -- /system/bin/vdc --wait cryptfs mountdefaultencrypted\n    # vold will set vold.decrypt to trigger_restart_framework (default\n    # encryption) or trigger_restart_min_framework (other encryption)\n\ntrigger_restart_min_framework\n\non property:vold.decrypt=trigger_post_fs_data\n    trigger post-fs-data\n    trigger zygote-start\n\non zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file\n    # A/B update verifier that marks a successful boot.\n    exec_start update_verifier_nonencrypted\n    start netd\n    start zygote\n    start zygote_secondary\n\nservice update_verifier_nonencrypted /system/bin/update_verifier nonencrypted\n\n```\n\n## AB 升级过程调试\n先制作ota升级包   make otapackage -j4\n制作完成的升级包, 解压出payload.bin和payload_properties.txt\n将升级包push到手机中, 执行命令:\n```shell\nupdate_engine_client \\\n--payload=file://stroage/emulated/0/payload.bin \\\n--update \\\n--headers=\"\\\n  FILE_HASH=kIOSRpbVFbtwlQcrTILsXvoY9kibUtgD44jsw2Xt/sU= \\\n  FILE_SIZE=1387785336 \\\n  METADATA_HASH=K+wAnG6HAjz8ogpJ6pYjyIUtS52evVp59Bwsiw5taHI= \\\n  METADATA_SIZE=104537 \\\n\"\n```\nlogcat抓取update_engine的log, 发现报错:\n```log\n07-24 09:56:00.325  1045  1045 I update_engine: [0724/095600.325928:INFO:delta_performer.cc(1549)] Verifying payload using public key: /etc/update_engine/update-payload-key.pub.pem\n07-24 09:56:00.326  1045  1045 E update_engine: [0724/095600.325993:ERROR:delta_performer.cc(1563)] VerifyPayload failure: payload_hash_calculator_.raw_hash() == update_check_response_hash\n07-24 09:56:00.326  1045  1045 E update_engine: [0724/095600.326097:ERROR:download_action.cc(397)] Download of file://stroage/emulated/0/draco-ota-eng.mi.zip failed due to payload verification error.\n07-24 09:56:00.326  1045  1045 I update_engine: [0724/095600.326166:INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kPayloadHashMismatchError\n07-24 09:56:00.326  1045  1045 I update_engine: [0724/095600.326233:INFO:action_processor.cc(121)] ActionProcessor: Aborting processing due to failure.\n```\n加log调试update_engine\n```shell\nadb root;adb disable-verity;adb reboot;adb root;adb remount;\nadb push system/bin/update_engine  /system/bin/\nadb shell;\nstop update_engine; start update_engine;\n```\n发现该处log比较奇怪:\n```log\n07-23 16:59:54.693  5879  5879 I update_engine: [0723/165954.693766:INFO:install_plan.cc(83)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file://stroage/emulated/0/payload.bin, payload: (size: 0, metadata_size: 0, metadata signature: , hash: , payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true\n```\ndump的地方在`update_attempter_android.cc`文件中`install_plan_.Dump();`\n\n最后调试下来发现是参数格式不对, 正确的应该这样写:\n```shell\nupdate_engine_client \\\n--payload=http://192.168.31.83:8000/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=HCN+qKtmcVpsRotGQCsi91Om+MqSg3NHQYJwn2yULVg=\nFILE_SIZE=2693182661\nMETADATA_HASH=CUDPVlE0kWBn6+Ryaxta8lwvi03G4G9XK1vhRGPcm6U=\nMETADATA_SIZE=165572\n\"\n```\n>注意换行符的写入方式\n\n在上面的尝试后, 发现本地地址不能解析\n需要在本地电脑上架设小型服务器, \n```shell\n#在升级包路径下执行\npython -mSimpleHTTPServer\npython -m http.server  #python3\n```\n传入的参数为:\n```shell\n--payload=http://192.168.31.83:8000/payload.bin\n```\n\n```shell\nupdate_engine_client \\\n--payload=http://127.0.0.1/storage/emulated/0/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=kIOSRpbVFbtwlQcrTILsXvoY9kibUtgD44jsw2Xt/sU=\nFILE_SIZE=1387785336\nMETADATA_HASH=K+wAnG6HAjz8ogpJ6pYjyIUtS52evVp59Bwsiw5taHI=\nMETADATA_SIZE=104537\n\"\n```\n\n最后发现本地地址也是可以解析的, 只是路径名要写对:\n```shell\n--payload=file:///storage/emulated/0/payload.bin\n```\n>注意file:后面三个'/', 前两个是file的scheme, 后一个代表的是手机的根路径\n\n```shell\nupdate_engine_client \\\n--payload=file:///data/media/0/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=sMDMFWlA/r/RvD2xmbhT10ujGbd3ZDgbIoFsguZgFk0=\nFILE_SIZE=2706624429\nMETADATA_HASH=5pBczs+nemH35uaJ6dyKEM14jLXG6yHLRHW2SA7E548=\nMETADATA_SIZE=165921\n\"\n```\n\n```shell\nupdate_engine_client \\\n--payload=file:///data/media/0/miui_VENUS_20.8.19_d6f849fa6a_11.0.zip \\\n--update \\\n--offset=1146 \\\n--size=2758439770 \\\n--headers=\"\\\nFILE_HASH=rr3A+HtaJvZR9t6fy+Jb1+H/IkbeOWKHifx27a9ZQFU=\nFILE_SIZE=2758439770\nMETADATA_HASH=eEzs5b5edkpltbmQdROP/k4t1UxfC/9XwRVIXZWvnmU=\nMETADATA_SIZE=165216\n\"\n\n\n\nupdate_engine_client \\\n--payload=file:///sdcard/miui_VENUS_20.8.19_d6f849fa6a_11.0.zip \\\n--offset=1187 \\\n--update \\\n--headers=\"\\\nFILE_HASH=rr3A+HtaJvZR9t6fy+Jb1+H/IkbeOWKHifx27a9ZQFU=\nFILE_SIZE=2758439770\nMETADATA_HASH=eEzs5b5edkpltbmQdROP/k4t1UxfC/9XwRVIXZWvnmU=\nMETADATA_SIZE=165216\n\"\n\nupdate_engine_client \\\n--payload=file:///data/ota_package/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=\nFILE_SIZE=2692532199\nMETADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=\nMETADATA_SIZE=165572\n\"\n\nupdate_engine_client \\\n--payload=file:///mnt/androidwritable/0/emulated/0/Download/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=\nFILE_SIZE=2692532199\nMETADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=\nMETADATA_SIZE=165572\n\"\n\nupdate_engine_client \\\n--payload=file:///storage/emulated/0/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=\nFILE_SIZE=2692532199\nMETADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=\nMETADATA_SIZE=165572\n\"\n\nupdate_engine_client \\\n--payload=file:///data/ota_package/miui-ota-venus-20.9.1.root-20.9.2.root-a6a89c0203-11.0.zip \\\n--update \\\n--offset=1414 \\\n--headers=\"\\\nFILE_HASH=k6xH0maRm8TA3oiSUW3XaaVK7O1OXmVHuKl36ktTGYQ=\nFILE_SIZE=76627669\nMETADATA_HASH=PsdtZ4XoOm6uBdfC9yS6PAPJ1LqPAu0dH/FMtoZcXGo=\nMETADATA_SIZE=449549\n\"\nupdate_engine_client \\\n--payload=file:///data/ota_package/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=6Rp2NEldT3Hsvo3amsrFM3cVypJW+3Zz9mSjLRpoQ68=\nFILE_SIZE=76627710\nMETADATA_HASH=/Ilv5kgPOpsDwdtG8TUBCt08LFndNHHy/UXQMmsp3Hk=\nMETADATA_SIZE=450810\n\"\n\nupdate_engine_client \\\n--payload=file:///data/ota_package/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=\nFILE_SIZE=181915047\nMETADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=\nMETADATA_SIZE=607150\n\"\nopenssl pkcs8 -in build/make/target/product/security/testkey.pk8 -inform DER -nocrypt > test/private_key\nsha256sum header.bin | xxd -r -p | tee sha256.file\ndd if=sha256.file of=sha256_32.bin bs=1 count=32\nopenssl pkeyutl -sign -inkey private_key -pkeyopt digest:sha256 -in sha256_32.bin -out header_sign.bin\n\nota_from_target_files.py cmd:  -i /tmp/tmp.miui.target_files_package.ota.l4f/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip\nbuild/tools/releasetools/ota_from_target_files  -i /tmp/tmp.miui.target_files_package.ota.l4f/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip\n\n\nbuild/tools/releasetools/ota_from_target_files  -i  /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip\n\n\nCMD: build/tools/releasetools/ota_from_target_files --block --payload_signer /home/builder/ota-tools/build/payload_signer.sh -i /tmp/tmp.miui.target_files_package.ota.Ds0/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.Ds0/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/normal/ota_diff/blockota-venus-20.9.6-20.9.9.zip\n```\n\n> 算hash值的方法\n\n```bash\nsha256sum -t  signed_venus-target_files-20.9.1.root-11.0/RADIO/abl.elf | xxd -r -p | base64\n```\n\n### 添加firmware分区\n\n先看下target_files依赖的RADIO文件:\n\n```makefile\nTARGET_RADIO_FILES := xbl.elf xbl_config.elf imagefv.elf tz.mbn \\\n                      devcfg.mbn storsec.mbn km4.mbn cmnlib.mbn \\\n                      cmnlib64.mbn uefi_sec.mbn aop.mbn NON-HLOS.bin BTFM.bin dspso.bin \\\n                      qupv3fw.elf multi_image.mbn hyp.mbn hypvm.mbn\n```\n看下非AB升级的升级脚本:\n```shell\npackage_extract_file(\"firmware-update/cmnlib64.mbn\", \"/dev/block/bootdevice/by-name/cmnlib64\");\npackage_extract_file(\"firmware-update/NON-HLOS.bin\", \"/dev/block/bootdevice/by-name/modem\");\npackage_extract_file(\"firmware-update/cmnlib.mbn\", \"/dev/block/bootdevice/by-name/cmnlib\");\npackage_extract_file(\"firmware-update/BTFM.bin\", \"/dev/block/bootdevice/by-name/bluetooth\");\npackage_extract_file(\"firmware-update/km4.mbn\", \"/dev/block/bootdevice/by-name/keymaster\");\npackage_extract_file(\"firmware-update/hypvm.mbn\", \"/dev/block/bootdevice/by-name/hypbak\");\npackage_extract_file(\"firmware-update/tz.mbn\", \"/dev/block/bootdevice/by-name/tz\");\npackage_extract_file(\"firmware-update/aop.mbn\", \"/dev/block/bootdevice/by-name/aop\");\npackage_extract_file(\"firmware-update/xbl_config.elf\", \"/dev/block/bootdevice/by-name/xbl_config\");\npackage_extract_file(\"firmware-update/storsec.mbn\", \"/dev/block/bootdevice/by-name/storsec\");\npackage_extract_file(\"firmware-update/uefi_sec.mbn\", \"/dev/block/bootdevice/by-name/uefisecapp\");\npackage_extract_file(\"firmware-update/imagefv.elf\", \"/dev/block/bootdevice/by-name/imagefv\");\npackage_extract_file(\"firmware-update/qupv3fw.elf\", \"/dev/block/bootdevice/by-name/qupfw\");\npackage_extract_file(\"firmware-update/abl.elf\", \"/dev/block/bootdevice/by-name/abl\");\npackage_extract_file(\"firmware-update/dspso.bin\", \"/dev/block/bootdevice/by-name/dsp\");\npackage_extract_file(\"firmware-update/devcfg.mbn\", \"/dev/block/bootdevice/by-name/devcfg\");\npackage_extract_file(\"firmware-update/xbl.elf\", \"/dev/block/bootdevice/by-name/xbl\");\npackage_extract_file(\"firmware-update/hyp.mbn\", \"/dev/block/bootdevice/by-name/hyp\");\npackage_extract_file(\"firmware-update/vbmeta.img\", \"/dev/block/bootdevice/by-name/vbmeta\");\n#package_extract_file(\"firmware-update/logo.img\", \"/dev/block/bootdevice/by-name/logo\");\npackage_extract_file(\"firmware-update/ifaa.img\", \"/dev/block/bootdevice/by-name/ifaa\");\npackage_extract_file(\"firmware-update/dtbo.img\", \"/dev/block/bootdevice/by-name/dtbo\");\n```\n上面的分区和有b分区的比下来, 除了logo, 其他的都要升级, 注意跟多出来的b分区的对比, 少了一个分区是`multiimgoem`, 对应的镜像`multi_image.mbn`\n\n#### 原生打包的方式\n先看下`AB_OTA_PARTITIONS`的作用范围\nMETA/ab_partitions.txt\n现有逻辑是查device/board下定义的AB_OTA_PARTITIONS, 将扫到的分区写到target-files的这个文件中\n由`/system/update_engine/scripts/brillo_update_payload`的generate生成对应的payload.bin\n该文件为shell脚本, 编译时会被拷贝到`/out/host/linux-x86/bin`下面\n原生方式只识别后缀名为`.img`的镜像文件, 在`add_img_to_target_files`制作target-files时, 会将`RADIO`目录下的后缀为`.img`的镜像文件拷贝到`IMAGES`下.\n由`brillo_update_payload`脚本根据`IMAGES`下的镜像文件和`ab_partitions.txt`文件中的升级分区生成对应的升级包\n\n#### firmware的相关修改\n将firmware加到升级序列时, 有下面几个问题要解决\n\na. firmware的大部分镜像都不是`img`后缀结尾的\n\nb. 需要按board按需添加对应的firmware, 最好不要写死\n\nc. firmware的镜像放在`RADIO`而非`IMAGES`下,  这点有正式签名的考虑.(正式包会在Makefile执行完成后, 对做出的target-files下的IMAGES目录下的文件进行删除, 重新生成并签上正式签名), 因此不宜将firmware的镜像仿照原生逻辑直接拷贝到`IMAGES`下\n\nd. firmware的镜像大部分跟其对应的分区名称名字不是对应的.\n\n综上几点, 考虑的修改方式为:\n\n1. 复用Board下的filesmap文件, 该文件定义了firmware镜像跟分区名称的对应规则, 该文件已经被打包到`target-files`下的`RADIO`目录下\n2. ab_partitions的firmware的添加规则和原生的区分, 原生的是在宏`AB_OTA_PARTITIONS`下添加的, firmware的加入时机直接在`add_img_to_target_files`中对AB的操作时触发. 因`RADIO`目录下的文件已经是按board需要添加的, 可以直接扫描`RADIO`目录的文件, 且与`filesmap`文件中对应的即为所要升级的分区. (主要排除掉没有b slot的分区), 追加到`META/ab_partitions.txt`文件中.\n3. 由于上面的**d**项, 分区名跟镜像名不对应, 这里复用`filesmap`文件, 添加分区名跟镜像名的映射map, 写入到`META/ab_partitions_map.txt`文件中\n4. `brillo_update_payload`脚本中修改, 将只从`IMAGES`中和分区名和镜像名严格匹配的规则修改, 变更为除去IMAGES中已知的分区, 其他按照`META/ab_partitions_map.txt`的对应规则从`RADIO`目录取镜像文件.\n\n相关修改:\n\nhttp://gerritlvs.pt.miui.com/#/c/656495/\n\nhttp://gerritlvs.pt.miui.com/#/c/656506/\n\n### 升级完成与切换slot\n\n查看主系统中是否已经升级完了对应的slot\n\n```log\n`#升级plan``07-26 13``:``17``:``36.537  1120  1120 I update_engine``:` `[``0726/131736``.537426:``INFO``:``install_plan.cc(83)``]` `InstallPlan``:` `new_update``,` `version``:` `,` `source_slot``:` `A``,` `target_slot``:` `B``,` `url``:` `file``:``///storage/emulated/0/payload.bin``,` `payload``:` `(size``:` `2004454082``,` `metadata_size``:` `174654``,` `metadata signature``:` `,` `hash``:` `7FE331728BDC1F3ADB6CD99DB86E9B9C49613464A0B4CEDB996B2035AF58BC82``,` `payload type``:` `unknown)``,` `hash_checks_mandatory``:` `false``,` `powerwash_required``:` `false``,` `switch_slot_on_reboot``:` `true``,` `run_post_install``:` `true``#升级顺序及hash值``07-26 13``:``17``:``36.808  1120  1120 I update_engine``:` `[``0726/131736``.808861:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new boot sha256``:` `BaT0kJm5qUoDs+ZFvbl7PsbYrJdVLEJ4AO9yRubxVxA= size``:` `134217728``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809403:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new system sha256``:` `8iUdw5zmngS2Z19bJdjhyoinOuPf+jktNpsybrg+/As= size``:` `3758096384``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809555:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new vendor sha256``:` `yoK6GkBeRI140U9nC5PeOcoTIKvX9PytKJveI9W0NZI= size``:` `2134900736``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809695:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new cmnlib sha256``:` `L8grDzXzgCj2jmkywxgvC6WOESQbzcQWzC2XKDuAXCk= size``:` `393216``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809828:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new cmnlib64 sha256``:` `2kJkRo4mMiPlSXilsbdN8jrDnWHVpy0n+C72qnjxUXI= size``:` `512000``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809953:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new xbl sha256``:` `0knDpqu+RIZDIFVQ+UfvIHdXd8itYU7kBZQjyFv3MSk= size``:` `3313664``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810078:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new tz sha256``:` `qJjCTAzUUP4QDtP5JpEIgyiucu2csyDMMqm3Sw82IJ4= size``:` `3149824``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810200:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new ifaa sha256``:` `jndrE4DvyUkcFkSlgGcdzT31y61NFbs0bK62w7RxZmc= size``:` `67108864``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810332:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new xbl_config sha256``:` `EuJt+caPn+p1pYml7BiLHwWS5qOHdsE9XWdDMTgYDn8= size``:` `126976``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810463:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new abl sha256``:` `AEWy9qn6ckS6oPuchaZTf3LLBKvu4rlVhCqjYuovjvo= size``:` `159744``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810605:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new keymaster sha256``:` `2EbjQReoWN2RJxiMTYDY0DyBhTSCj9EDMQY8nBNkrhM= size``:` `253952``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810735:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new bluetooth sha256``:` `QUIy2P5N0423Q9vfFStQ4gX7+93NNeNAP8/C1GMFRxs= size``:` `847872``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810863:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new imagefv sha256``:` `s8nZ2bO3JQ1FhpHm5xl6JM0gaXD+R+bJXx/ao5n465c= size``:` `24576``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.810994:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new vbmeta sha256``:` `DS53zciAjgUcUu9bazzGzl8WSrXsTlyDh0qQdQrSzzg= size``:` `4096``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811124:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new qupfw sha256``:` `5b7DvDYxu52A7CkzLEn17FAUi9VjC4+hP1x1EHgVwn4= size``:` `73728``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811248:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new dtbo sha256``:` `x8LJxRjY6eyLtnFpCUjx0nm7KrPk5EWmbO1RoiGgdKA= size``:` `33554432``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811380:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new hyp sha256``:` `K+Lhh6fNlCzcZGO2sSQk4oX899HivC4ZYbQ00wCHJuk= size``:` `487424``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811501:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new aop sha256``:` `pbPjmwNuZ63U/yB3x6fWwHMFaWTaO7GRsvvmgtYeZY8= size``:` `204800``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811628:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new modem sha256``:` `U8mQP9s3QEIuQC6XjTtCK2FSv37BrFmz/8yanfrSag0= size``:` `254750720``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811752:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new dsp sha256``:` `/6W7ecrFfr/L/iQIyc31iyatytPv/Zh3ihPgkKCRogg= size``:` `67108864``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811871:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new devcfg sha256``:` `op2nGXrz70xk67DA0MGvGxuPrWGEDS/zQHo8wzSSG3E= size``:` `57344``#写入分区``...``07-26 13``:``26``:``23.407  1120  1120 I update_engine``:` `[``0726/132623``.406974:``INFO``:``delta_performer.cc(386)``]` `Applying 32 operations to partition ``\"ifaa\"``07-26 13``:``26``:``25.604  1120  1120 I update_engine``:` `[``0726/132625``.604203:``INFO``:``delta_performer.cc(374)``]` `Opening /dev/block/bootdevice/by-name/xbl_config_b partition without O_DSYNC``07-26 13``:``26``:``25.609  1120  1120 I update_engine``:` `[``0726/132625``.609049:``INFO``:``delta_performer.cc(126)``]` `Caching writes.``07-26 13``:``26``:``25.609  1120  1120 I update_engine``:` `[``0726/132625``.609407:``INFO``:``delta_performer.cc(386)``]` `Applying 1 operations to partition ``\"xbl_config\"``07-26 13``:``26``:``25.638  1120  1120 I update_engine``:` `[``0726/132625``.638252:``INFO``:``delta_performer.cc(374)``]` `Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC``#分区写完后校验``07-26 13``:``27``:``40.528  1120  1120 I update_engine``:` `[``0726/132740``.528046:``INFO``:``filesystem_verifier_action.cc(108)``]` `Hashing partition 7 (ifaa) ``on` `device /dev/block/bootdevice/by-name/ifaa_b``07-26 13``:``27``:``40.870  1120  1120 I update_engine``:` `[``0726/132740``.870530:``INFO``:``filesystem_verifier_action.cc(199)``]` `Hash of ifaa``:` `jndrE4DvyUkcFkSlgGcdzT31y61NFbs0bK62w7RxZmc=``07-26 13``:``27``:``41.053  1120  1120 I update_engine``:` `[``0726/132741``.053396:``INFO``:``filesystem_verifier_action.cc(108)``]` `Hashing partition 8 (xbl_config) ``on` `device /dev/block/bootdevice/by-name/xbl_config_b``07-26 13``:``27``:``41.059  1120  1120 I update_engine``:` `[``0726/132741``.059842:``INFO``:``filesystem_verifier_action.cc(199)``]` `Hash of xbl_config``:` `EuJt+caPn+p1pYml7BiLHwWS5qOHdsE9XWdDMTgYDn8=``#升级完成``07-26 13``:``27``:``43.865  1120  1120 I update_engine``:` `[``0726/132743``.865773:``INFO``:``update_attempter_android.cc(439)``]` `Processing Done.``07-26 13``:``27``:``43.867  1120  1120 I update_engine``:` `[``0726/132743``.867692:``INFO``:``update_attempter_android.cc(447)``]` `Update successfully applied``,` `waiting to reboot.`\n```\n\n重启手机查看是否切换了slot\n\n```shell\n`fastboot getvar current-slot`\n```\n\nfastboot 手动切换slot\n\n```shell\n`fastboot set_active a|b`\n```\n\n在主系统下查看是否已经切换了slot:\n\n可以通过mount查看挂载的是否是对应slot的分区, 也可以重新执行update_engine_client查看source slot.\n\n其他的fastboot相关命令和变量:\n\n- `has-slot:<partition-base-name-without-suffix>`：如果指定分区支持插槽，则返回“yes”，否则返回“no”。\n- `current-slot`：返回接下来将从中启动的插槽后缀。\n- `slot-count`：返回一个表示可用插槽数量的整数。目前支持两个插槽，因此该值为 `2`。\n- `slot-successful:<slot-suffix>`：如果指定插槽已标记为成功启动，则返回“yes”，否则返回“no”。\n- `slot-unbootable:<slot-suffix>`：如果指定插槽被标记为不可启动，则返回“yes”，否则返回“no”。\n- `slot-retry-count`：启动指定插槽的剩余重试次数。\n\n## recovery升级X_slot\n\nrecovery借助update_engine_sideload进行AB系统的升级, 过程与主系统中的大体类似, 跳过hidl服务直连hal的静态库.\n\n适配时需要将bootctl的hal的静态库接入update_engine_sideload.\n\n```makefile\n# Enable update engine sideloading by including the static version of the\n# boot_control HAL and its dependencies.\nPRODUCT_STATIC_BOOT_CONTROL_HAL := \\\n    bootctrl.msmnile \\\n    librecovery_updater_msm \\\n    libz \\\n    libcutils\n\nPRODUCT_PACKAGES += \\\n    update_engine_sideload\n```\n\nqcom的bootctrl.msmnile库并没有静态版本, 将其改造成静态版本, 同时注意platform的binary不能访问vendor的静态库, 需要去掉vendor属性\n\n```shell\n[  137.119886] [0118/071802.275869:INFO:update_attempter_android.cc(163)] headers dump: FILE_HASH:XY0N+WNwMUsufo4R2WhiVEZZysKndtGOs2U2eHI4vWY=\n[  137.119974] [0118/071802.275959:INFO:update_attempter_android.cc(163)] headers dump: FILE_SIZE:2172949036\n[  137.120064] [0118/071802.276047:INFO:update_attempter_android.cc(163)] headers dump: METADATA_HASH:tT9n0yD1oGTFh6CHfgFJ+SFDpGVDdM3MxU2Kj6J4xHk=\n[  137.120153] [0118/071802.276137:INFO:update_attempter_android.cc(163)] headers dump: METADATA_SIZE:201361\n[  137.314970] [0118/071802.470947:INFO:multi_range_http_fetcher.cc(74)] starting transfer of range 10118+2172949036\n```\n\nsideload模式可以通过adb进行调试执行\n\n```shell\nupdate_engine_sideload  --payload=file:///tmp/<>.zip  --offset=10118 --headers=\"\\\nFILE_HASH=XY0N+WNwMUsufo4R2WhiVEZZysKndtGOs2U2eHI4vWY=\nFILE_SIZE=2172949036\nMETADATA_HASH=tT9n0yD1oGTFh6CHfgFJ+SFDpGVDdM3MxU2Kj6J4xHk=\nMETADATA_SIZE=201361\n\"\n\nupdate_engine_sideload  --payload=file:///tmp/update.zip  --offset=1418 --headers=\"\\\nFILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=\nFILE_SIZE=181915047\nMETADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=\nMETADATA_SIZE=607150\n\"\n\nupdate_engine_sideload   --payload=file:///tmp/miui_DRACO_1.1.1_3b6efde15f_9.0.zip  --offset=10137 --headers=\"\\^JFILE_HASH=2RuZP+op3uy6movkIOlNaNoo8Fev+++ndUN56eo4WtY=^JFILE_SIZE=2180626971^JMETADATA_HASH=nW8R4zd7YIn/U3ybQ4U8e104hOlJ/8LBWBAlLaV4teY=^JMETADATA_SIZE=201406^J\" \n```\n\n相关log, 注意后面的size\n\n```shell\n[0119/030730.113743:INFO:delta_performer.cc(1405)] Detected a 'full' payload.\n[0119/030730.174037:INFO:delta_performer.cc(400)] PartitionInfo new boot sha256: EpKxremioCiMOtX/ll7vdGHgyPA6hkS+aEATJ1bTmvs= size: 134217728\n[0119/030730.174087:INFO:delta_performer.cc(400)] PartitionInfo new system sha256: a3cVb5cmEwvwXp9qRV7S/FHD88SUx5SdPdBL9vdtfdA= size: 4831838208\n[0119/030730.174108:INFO:delta_performer.cc(400)] PartitionInfo new vendor sha256: Hz4lmS/Ubd04ZcY3N2Z6Tn1hKcmYPjdeeHbyRCw3n6U= size: 2134900736\n[0119/030730.174124:INFO:delta_performer.cc(400)] PartitionInfo new cmnlib sha256: jobjLrtwvwr4lomr6gMHgT07CnYt+m2n9rimaAX8gmA= size: 393216\n[0119/030730.174142:INFO:delta_performer.cc(400)] PartitionInfo new hyp sha256: GBrSZwkKGzyPmjMln6hNqCs0MMdOnVNq+0xvPg9wEIo= size: 491520\n[0119/030730.174164:INFO:delta_performer.cc(400)] PartitionInfo new xbl sha256: Srhj/31G6kvceupG54iy2ATnvTrHaGDTNrXoQ9QoBQM= size: 3313664\n[0119/030730.174185:INFO:delta_performer.cc(400)] PartitionInfo new tz sha256: 6j6yJ6VEJP/eDEfVAfBTJsPeihIw8stgYx3IZYNUTjU= size: 3166208\n[0119/030730.174207:INFO:delta_performer.cc(400)] PartitionInfo new uefisecapp sha256: SsTDYAIGR57uuERCJVW4pYo7qliFTfFC0bjkeCdhuaA= size: 126976\n[0119/030730.174228:INFO:delta_performer.cc(400)] PartitionInfo new xbl_config sha256: PXsK2uY4CZHl9HTw4MNn2V2JKjf+tL5lF3Rsrxq/DlQ= size: 126976\n[0119/030730.174248:INFO:delta_performer.cc(400)] PartitionInfo new abl sha256: pTmXXhjn578lQoU4Ms2gevuE1u9lf6fkfKkeb2wErOc= size: 159744\n[0119/030730.174269:INFO:delta_performer.cc(400)] PartitionInfo new dsp sha256: kGaIexuCECjzYboVNAQWYgSk5+2ZDAreFTT+9Lae68I= size: 67108864\n[0119/030730.174290:INFO:delta_performer.cc(400)] PartitionInfo new bluetooth sha256: +o/xD1GaNQ+dXp3dI7cHLl/ecNQveGozZ5/+3mkysI0= size: 847872\n[0119/030730.174311:INFO:delta_performer.cc(400)] PartitionInfo new imagefv sha256: YtGPa6a7hx2vAUrQBMIID6821Cagh5hM7mfWvouDZjE= size: 24576\n[0119/030730.174332:INFO:delta_performer.cc(400)] PartitionInfo new vbmeta sha256: 8SxbQYbjPUCebXdmSJg7iJhcJbdkDKRbIozhlEfIly8= size: 4096\n[0119/030730.174353:INFO:delta_performer.cc(400)] PartitionInfo new qupfw sha256: QwIM5J4OBdFm+EJmlrp+443q7M7HHzGsyWp7/6a7rks= size: 73728\n[0119/030730.174374:INFO:delta_performer.cc(400)] PartitionInfo new keymaster sha256: QxPBL7CmuMS851FLt2IyJ1viO+NlEfrcLiVCveNrUZM= size: 258048\n[0119/030730.174394:INFO:delta_performer.cc(400)] PartitionInfo new dtbo sha256: J4XfTy8iKmEDrT2g3p/IFowpezxKk5O1eaT2SIt9siY= size: 33554432\n[0119/030730.174415:INFO:delta_performer.cc(400)] PartitionInfo new aop sha256: a/+FDfEjG5fT7d43Lt2kzG+Ij3hWIo9u5anzMHTctRU= size: 204800\n[0119/030730.174436:INFO:delta_performer.cc(400)] PartitionInfo new modem sha256: es49VhO5api6iwZjDt/DWLBqXA9DnJvRccmvEL5FK/Y= size: 250458112\n[0119/030730.174458:INFO:delta_performer.cc(400)] PartitionInfo new devcfg sha256: CNmqJR7BqkQgcJNdrtCYKCQrJVEgehBfe/eCQGm7/n8= size: 57344\n[0119/030730.174480:INFO:delta_performer.cc(400)] PartitionInfo new cmnlib64 sha256: CTW5va0C8mcZN2pg46xloHvD5tq1x61mHAMGoB7siqM= size: 512000\n[0119/030730.174508:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/boot_b partition without O_DSYNC\n[0119/030730.175562:INFO:delta_performer.cc(126)] Caching writes.\n[0119/030730.175616:INFO:delta_performer.cc(386)] Applying 64 operations to partition \"boot\"\n[0119/030730.175639:INFO:delta_performer.cc(601)] Starting to apply update payload operations\n[0119/030732.554195:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/system_b partition without O_DSYNC\n[0119/030732.555151:INFO:delta_performer.cc(126)] Caching writes.\n[0119/030732.555206:INFO:delta_performer.cc(386)] Applying 2304 operations to partition \"system\"\n[0119/030753.617572:INFO:delta_performer.cc(210)] Completed 356/3571 operations (9%), 260767744/2172949036 bytes downloaded (12%), overall progress 10%\n[0119/030809.120118:INFO:delta_performer.cc(210)] Completed 589/3571 operations (16%), 521519104/2172949036 bytes downloaded (24%), overall progress 20%\n[0119/030829.133342:INFO:delta_performer.cc(210)] Completed 858/3571 operations (24%), 814350336/2172949036 bytes downloaded (37%), overall progress 30%\n[0119/030847.818425:INFO:delta_performer.cc(210)] Completed 1132/3571 operations (31%), 1086488576/2172949036 bytes downloaded (50%), overall progress 40%\n[0119/030907.012157:INFO:delta_performer.cc(210)] Completed 1429/3571 operations (40%), 1329676288/2172949036 bytes downloaded (61%), overall progress 50%\n[0119/030914.390509:INFO:delta_performer.cc(210)] Completed 2072/3571 operations (58%), 1351565312/2172949036 bytes downloaded (62%), overall progress 60%\n[0119/030928.264078:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/vendor_b partition without O_DSYNC\n[0119/030928.265006:INFO:delta_performer.cc(126)] Caching writes.\n[0119/030928.265065:INFO:delta_performer.cc(386)] Applying 1018 operations to partition \"vendor\"\n[0119/030939.404319:INFO:delta_performer.cc(210)] Completed 2548/3571 operations (71%), 1521074176/2172949036 bytes downloaded (70%), overall progress 70%\n[0119/030959.073585:INFO:delta_performer.cc(210)] Completed 2786/3571 operations (78%), 1796096000/2172949036 bytes downloaded (82%), overall progress 80%\n[0119/031021.805564:INFO:delta_performer.cc(210)] Completed 3072/3571 operations (86%), 2056355840/2172949036 bytes downloaded (94%), overall progress 90%\n[0119/031031.406053:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/cmnlib_b partition without O_DSYNC\n[0119/031031.406953:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.407007:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"cmnlib\"\n[0119/031031.431870:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/hyp_b partition without O_DSYNC\n[0119/031031.432726:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.432780:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"hyp\"\n[0119/031031.457051:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/xbl_b partition without O_DSYNC\n[0119/031031.457909:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.457962:INFO:delta_performer.cc(386)] Applying 2 operations to partition \"xbl\"\n[0119/031031.619811:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/tz_b partition without O_DSYNC\n[0119/031031.620741:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.620795:INFO:delta_performer.cc(386)] Applying 2 operations to partition \"tz\"\n[0119/031031.728560:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/uefisecapp_b partition without O_DSYNC\n[0119/031031.729560:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.729619:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"uefisecapp\"\n[0119/031031.743096:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/xbl_config_b partition without O_DSYNC\n[0119/031031.743941:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.743991:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"xbl_config\"\n[0119/031031.755388:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC\n[0119/031031.756234:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.756286:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"abl\"\n[0119/031031.772838:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/dsp_b partition without O_DSYNC\n[0119/031031.773704:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031031.773756:INFO:delta_performer.cc(386)] Applying 32 operations to partition \"dsp\"\n[0119/031033.057947:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/bluetooth_b partition without O_DSYNC\n[0119/031033.058886:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.058940:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"bluetooth\"\n[0119/031033.087545:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/imagefv_b partition without O_DSYNC\n[0119/031033.088426:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.088481:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"imagefv\"\n[0119/031033.100948:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/vbmeta_b partition without O_DSYNC\n[0119/031033.101786:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.101837:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"vbmeta\"\n[0119/031033.104208:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/qupfw_b partition without O_DSYNC\n[0119/031033.105069:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.105116:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"qupfw\"\n[0119/031033.110129:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/keymaster_b partition without O_DSYNC\n[0119/031033.111036:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.111089:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"keymaster\"\n[0119/031033.125200:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/dtbo_b partition without O_DSYNC\n[0119/031033.126050:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.126100:INFO:delta_performer.cc(386)] Applying 16 operations to partition \"dtbo\"\n[0119/031033.477645:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/aop_b partition without O_DSYNC\n[0119/031033.478592:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.478647:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"aop\"\n[0119/031033.491181:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/modem_b partition without O_DSYNC\n[0119/031033.492024:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031033.492075:INFO:delta_performer.cc(386)] Applying 120 operations to partition \"modem\"\n[0119/031041.771315:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/devcfg_b partition without O_DSYNC\n[0119/031041.772240:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031041.772293:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"devcfg\"\n[0119/031041.777995:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/cmnlib64_b partition without O_DSYNC\n[0119/031041.778853:INFO:delta_performer.cc(126)] Caching writes.\n[0119/031041.778905:INFO:delta_performer.cc(386)] Applying 1 operations to partition \"cmnlib64\"\n[0119/031041.799262:INFO:delta_performer.cc(210)] Completed 3571/3571 operations (100%), 2172949036/2172949036 bytes downloaded (100%), overall progress 100%\n[0119/031041.799333:INFO:delta_performer.cc(1370)] Extracted signature data of size 264 at 2172747147\n[0119/031041.799367:INFO:multi_range_http_fetcher.cc(112)] terminating transfer\n[0119/031041.799397:INFO:multi_range_http_fetcher.cc(173)] Received transfer terminated.\n[0119/031041.799416:INFO:multi_range_http_fetcher.cc(124)] TransferEnded w/ code 200\n[0119/031041.799438:INFO:multi_range_http_fetcher.cc(137)] bytes_received_this_range_2172949036 range.length 2172949036\n[0119/031041.799456:INFO:multi_range_http_fetcher.cc(159)] Done w/ all transfers\n[0119/031041.805089:INFO:download_action.cc(374)] VerifyPayload\n[0119/031041.805152:INFO:delta_performer.cc(1549)] Verifying payload using public key: /etc/update_engine/update-payload-key.pub.pem\n[0119/031041.805172:INFO:delta_performer.cc(1563)] payload_hash_calculator_.raw_hash() == update_check_response_hash\n[0119/031041.805196:INFO:delta_performer.cc(1593)] Payload hash matches value in payload.\n[0119/031041.805236:INFO:download_action.cc(397)] Collections of histograms for UpdateEngine.DownloadAction.\nHistogram: UpdateEngine.DownloadAction.InstallOperation::REPLACE.Duration recorded 3571 samples, mean = 46.2\n0    ------------------------------------------------------------------------O (1381 = 38.7%)\n10   ---O                                                                      (50 = 1.4%) {38.7%}\n18   ---------O                                                                (164 = 4.6%) {40.1%}\n32   -----------------------------------O                                      (667 = 18.7%) {44.7%}\n57   ------------------------------------------------O                         (923 = 25.8%) {63.3%}\n101  --------------------O                                                     (386 = 10.8%) {89.2%}\n179  ... \n\n\n[0119/031041.805296:INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kSuccess\n[0119/031041.805312:INFO:action_processor.cc(143)] ActionProcessor: starting FilesystemVerifierAction\n[0119/031041.805334:INFO:filesystem_verifier_action.cc(108)] Hashing partition 0 (boot) on device /dev/block/bootdevice/by-name/boot_b\n[0119/031042.385142:INFO:filesystem_verifier_action.cc(199)] Hash of boot: EpKxremioCiMOtX/ll7vdGHgyPA6hkS+aEATJ1bTmvs=\n[0119/031042.483456:INFO:filesystem_verifier_action.cc(108)] Hashing partition 1 (system) on device /dev/block/bootdevice/by-name/system_b\n[0119/031103.269791:INFO:filesystem_verifier_action.cc(199)] Hash of system: a3cVb5cmEwvwXp9qRV7S/FHD88SUx5SdPdBL9vdtfdA=\n[0119/031106.812035:INFO:filesystem_verifier_action.cc(108)] Hashing partition 2 (vendor) on device /dev/block/bootdevice/by-name/vendor_b\n[0119/031116.011647:INFO:filesystem_verifier_action.cc(199)] Hash of vendor: Hz4lmS/Ubd04ZcY3N2Z6Tn1hKcmYPjdeeHbyRCw3n6U=\n[0119/031117.573949:INFO:filesystem_verifier_action.cc(108)] Hashing partition 3 (cmnlib) on device /dev/block/bootdevice/by-name/cmnlib_b\n[0119/031117.581216:INFO:filesystem_verifier_action.cc(199)] Hash of cmnlib: jobjLrtwvwr4lomr6gMHgT07CnYt+m2n9rimaAX8gmA=\n[0119/031117.582299:INFO:filesystem_verifier_action.cc(108)] Hashing partition 4 (hyp) on device /dev/block/bootdevice/by-name/hyp_b\n[0119/031117.586890:INFO:filesystem_verifier_action.cc(199)] Hash of hyp: GBrSZwkKGzyPmjMln6hNqCs0MMdOnVNq+0xvPg9wEIo=\n[0119/031117.589001:INFO:filesystem_verifier_action.cc(108)] Hashing partition 5 (xbl) on device /dev/block/bootdevice/by-name/xbl_b\n[0119/031117.605620:INFO:filesystem_verifier_action.cc(199)] Hash of xbl: Srhj/31G6kvceupG54iy2ATnvTrHaGDTNrXoQ9QoBQM=\n[0119/031117.608525:INFO:filesystem_verifier_action.cc(108)] Hashing partition 6 (tz) on device /dev/block/bootdevice/by-name/tz_b\n[0119/031117.624519:INFO:filesystem_verifier_action.cc(199)] Hash of tz: 6j6yJ6VEJP/eDEfVAfBTJsPeihIw8stgYx3IZYNUTjU=\n[0119/031117.627394:INFO:filesystem_verifier_action.cc(108)] Hashing partition 7 (uefisecapp) on device /dev/block/bootdevice/by-name/uefisecapp_b\n[0119/031117.630008:INFO:filesystem_verifier_action.cc(199)] Hash of uefisecapp: SsTDYAIGR57uuERCJVW4pYo7qliFTfFC0bjkeCdhuaA=\n[0119/031117.630216:INFO:filesystem_verifier_action.cc(108)] Hashing partition 8 (xbl_config) on device /dev/block/bootdevice/by-name/xbl_config_b\n[0119/031117.632794:INFO:filesystem_verifier_action.cc(199)] Hash of xbl_config: PXsK2uY4CZHl9HTw4MNn2V2JKjf+tL5lF3Rsrxq/DlQ=\n[0119/031117.632997:INFO:filesystem_verifier_action.cc(108)] Hashing partition 9 (abl) on device /dev/block/bootdevice/by-name/abl_b\n[0119/031117.635997:INFO:filesystem_verifier_action.cc(199)] Hash of abl: pTmXXhjn578lQoU4Ms2gevuE1u9lf6fkfKkeb2wErOc=\n[0119/031117.638910:INFO:filesystem_verifier_action.cc(108)] Hashing partition 10 (dsp) on device /dev/block/bootdevice/by-name/dsp_b\n[0119/031117.929656:INFO:filesystem_verifier_action.cc(199)] Hash of dsp: kGaIexuCECjzYboVNAQWYgSk5+2ZDAreFTT+9Lae68I=\n[0119/031117.978875:INFO:filesystem_verifier_action.cc(108)] Hashing partition 11 (bluetooth) on device /dev/block/bootdevice/by-name/bluetooth_b\n[0119/031117.986127:INFO:filesystem_verifier_action.cc(199)] Hash of bluetooth: +o/xD1GaNQ+dXp3dI7cHLl/ecNQveGozZ5/+3mkysI0=\n[0119/031117.986856:INFO:filesystem_verifier_action.cc(108)] Hashing partition 12 (imagefv) on device /dev/block/bootdevice/by-name/imagefv_b\n[0119/031117.988422:INFO:filesystem_verifier_action.cc(199)] Hash of imagefv: YtGPa6a7hx2vAUrQBMIID6821Cagh5hM7mfWvouDZjE=\n[0119/031117.988506:INFO:filesystem_verifier_action.cc(108)] Hashing partition 13 (vbmeta) on device /dev/block/bootdevice/by-name/vbmeta_b\n[0119/031117.989126:INFO:filesystem_verifier_action.cc(199)] Hash of vbmeta: 8SxbQYbjPUCebXdmSJg7iJhcJbdkDKRbIozhlEfIly8=\n[0119/031117.989176:INFO:filesystem_verifier_action.cc(108)] Hashing partition 14 (qupfw) on device /dev/block/bootdevice/by-name/qupfw_b\n[0119/031117.990481:INFO:filesystem_verifier_action.cc(199)] Hash of qupfw: QwIM5J4OBdFm+EJmlrp+443q7M7HHzGsyWp7/6a7rks=\n[0119/031117.990598:INFO:filesystem_verifier_action.cc(108)] Hashing partition 15 (keymaster) on device /dev/block/bootdevice/by-name/keymaster_b\n[0119/031117.993895:INFO:filesystem_verifier_action.cc(199)] Hash of keymaster: QxPBL7CmuMS851FLt2IyJ1viO+NlEfrcLiVCveNrUZM=\n[0119/031117.996472:INFO:filesystem_verifier_action.cc(108)] Hashing partition 16 (dtbo) on device /dev/block/bootdevice/by-name/dtbo_b\n[0119/031118.143676:INFO:filesystem_verifier_action.cc(199)] Hash of dtbo: J4XfTy8iKmEDrT2g3p/IFowpezxKk5O1eaT2SIt9siY=\n[0119/031118.168441:INFO:filesystem_verifier_action.cc(108)] Hashing partition 17 (aop) on device /dev/block/bootdevice/by-name/aop_b\n[0119/031118.171454:INFO:filesystem_verifier_action.cc(199)] Hash of aop: a/+FDfEjG5fT7d43Lt2kzG+Ij3hWIo9u5anzMHTctRU=\n[0119/031118.172903:INFO:filesystem_verifier_action.cc(108)] Hashing partition 18 (modem) on device /dev/block/bootdevice/by-name/modem_b\n[0119/031119.258618:INFO:filesystem_verifier_action.cc(199)] Hash of modem: es49VhO5api6iwZjDt/DWLBqXA9DnJvRccmvEL5FK/Y=\n[0119/031119.446663:INFO:filesystem_verifier_action.cc(108)] Hashing partition 19 (devcfg) on device /dev/block/bootdevice/by-name/devcfg_b\n[0119/031119.449470:INFO:filesystem_verifier_action.cc(199)] Hash of devcfg: CNmqJR7BqkQgcJNdrtCYKCQrJVEgehBfe/eCQGm7/n8=\n[0119/031119.449603:INFO:filesystem_verifier_action.cc(108)] Hashing partition 20 (cmnlib64) on device /dev/block/bootdevice/by-name/cmnlib64_b\n[0119/031119.455933:INFO:filesystem_verifier_action.cc(199)] Hash of cmnlib64: CTW5va0C8mcZN2pg46xloHvD5tq1x61mHAMGoB7siqM=\n[0119/031119.456733:INFO:action_processor.cc(116)] ActionProcessor: finished FilesystemVerifierAction with code ErrorCode::kSuccess\n[0119/031119.456762:INFO:action_processor.cc(143)] ActionProcessor: starting PostinstallRunnerAction\ngpt_utils_set_xbl_boot_partition: setting /dev/block/bootdevice/by-name/xbl_b lun as boot lun\nget_scsi_node_from_bootdevice:scsi generic node is :/dev/sg5:\n[0119/031119.489816:INFO:postinstall_runner_action.cc(363)] All post-install commands succeeded\n[0119/031119.489859:INFO:action_processor.cc(116)] ActionProcessor: finished last action PostinstallRunnerAction with code ErrorCode::kSuccess\n[0119/031119.489883:INFO:update_attempter_android.cc(439)] Processing Done.\n[0119/031119.489968:INFO:update_attempter_android.cc(447)] Update successfully applied, waiting to reboot.\n[0119/031119.490153:ERROR:prefs.cc(85)] storage_->DeleteKey(key) failed.\n[0119/031119.490176:INFO:metrics_utils.cc(353)] Updated Marker = 1/1/1970 0:23:57 GMT\n```\n\n```diff\ndiff --git a/private/domain.te b/private/domain.te\nindex 3c1edc1..26bfd2c 100644\n--- a/private/domain.te\n+++ b/private/domain.te\n@@ -312,6 +312,7 @@ define(`dac_override_allowed', `{\n   vold\n   vold_prepare_subdirs\n   zygote\n+  update_engine\n }')\n neverallow ~dac_override_allowed self:global_capability_class_set dac_override;\n # Since the kernel checks dac_read_search before dac_override, domains that\n\n```\n\n### 差量升级ota log\n\n```shell\n08-18 19:24:51.361  1471  1471 I update_engine: [INFO:update_attempter_android.cc(280)] Using this install plan:\n08-18 19:24:51.365  1471  1471 I update_engine: [INFO:install_plan.cc(91)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file:///data/ota_package/inc_test.zip, payload: (size: 280875113, metadata_size: 668528, metadata signature: , hash: 60B62E3DD97FB3D966AE7D44B25D7150197D23C3CF28453FC39C8D3FBD94E7DA, payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true, is_rollback: false, write_verity: true\n08-18 19:24:51.369  1471  1471 I update_engine: [INFO:metrics_utils.cc(363)] Number of Reboots during current update attempt = 0\n08-18 19:24:51.371  1471  1471 I update_engine: [INFO:metrics_utils.cc(371)] Payload Attempt Number = 1\n08-18 19:24:51.374  1471  1471 I update_engine: [INFO:metrics_utils.cc(388)] Update Monotonic Timestamp Start = 1/1/1970 0:04:02 GMT\n08-18 19:24:51.376  1471  1471 I update_engine: [INFO:metrics_utils.cc(397)] Update Boot Timestamp Start = 1/1/1970 0:04:02 GMT\n08-18 19:24:51.378  1471  1471 I update_engine: [INFO:update_attempter_android.cc(648)] Scheduling an action processor start.\n08-18 19:24:51.383  1471  1471 I update_engine: [INFO:action_processor.cc(51)] ActionProcessor: starting UpdateBootFlagsAction\n08-18 19:24:51.385  1471  1471 I update_engine: [INFO:update_boot_flags_action.cc(45)] Marking booted slot as good.\n08-18 19:24:51.412  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished UpdateBootFlagsAction with code ErrorCode::kSuccess\n08-18 19:24:51.414  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting CleanupPreviousUpdateAction\n08-18 19:24:51.416  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(82)] Starting/resuming CleanupPreviousUpdateAction\n08-18 19:24:51.417  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(137)] Boot completed, waiting on markBootSuccessful()\n08-18 19:24:51.420  1471  1471 I update_engine: EnsureMetadataMounted does nothing in Android mode.\n08-18 19:24:51.422  1471  1471 I update_engine: Read merge statistics file failed: No such file or directory\n08-18 19:24:51.424  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(206)] Waiting for any previous merge request to complete. This can take up to several minutes.\n08-18 19:24:51.426  1471  1471 E update_engine: [ERROR:cleanup_previous_update_action.cc(240)] Previous update has not been completed, not cleaning up\n08-18 19:24:51.428  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(397)] Not reporting merge stats because state is Initiated\n08-18 19:24:51.429  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished CleanupPreviousUpdateAction with code ErrorCode::kSuccess\n08-18 19:24:51.431  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting InstallPlanAction\n08-18 19:24:51.433  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished InstallPlanAction with code ErrorCode::kSuccess\n08-18 19:24:51.435  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting DownloadAction\n08-18 19:24:51.437  1471  1471 I update_engine: [INFO:install_plan.cc(91)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file:///data/ota_package/inc_test.zip, payload: (size: 280875113, metadata_size: 668528, metadata signature: , hash: 60B62E3DD97FB3D966AE7D44B25D7150197D23C3CF28453FC39C8D3FBD94E7DA, payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true, is_rollback: false, write_verity: true\n08-18 19:24:51.438  1471  1471 I update_engine: [INFO:download_action.cc(199)] Marking new slot as unbootable\n08-18 19:24:51.460  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(45)] starting first transfer\n08-18 19:24:51.463  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(74)] starting transfer of range 1427+280875113\n08-18 19:24:51.468  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 0/? operations, 16384/280875113 bytes downloaded (0%), overall progress 0%\n08-18 19:24:51.500  1471  1471 I update_engine: [INFO:delta_performer.cc(520)] Manifest size in payload matches expected value from Omaha\n08-18 19:24:51.502  1471  1471 I update_engine: [INFO:delta_performer.cc(1693)] Verifying using certificates: /system/etc/security/otacerts.zip\n08-18 19:24:51.508  1471  1471 I update_engine: [INFO:payload_verifier.cc(102)] signature blob size = 267\n08-18 19:24:51.510  1471  1471 I update_engine: [INFO:payload_verifier.cc(118)] Truncating the signature to its unpadded size: 256.\n08-18 19:24:51.512  1471  1471 I update_engine: [INFO:payload_verifier.cc(129)] Verified correct signature 1 out of 1 signatures.\n08-18 19:24:51.514  1471  1471 I update_engine: [INFO:payload_metadata.cc(224)] Metadata hash signature matches value in Omaha response.\n08-18 19:24:51.551  1471  1471 I update_engine: [INFO:delta_performer.cc(1728)] Detected a 'delta' payload.\n08-18 19:24:51.575  1471  1471 I update_engine: [INFO:prefs.cc(122)] dynamic-partition-metadata-updated not present in /data/misc/update_engine/prefs\n08-18 19:24:51.580  1471  1471 I update_engine: [INFO:delta_performer.cc(985)] Preparing partitions for new update. last hash = , new hash = YLYuPdl/s9lmrn1Esl1xUBl9I8PPKEU/w5yNP72U59o=cwT0tXBzdXay7seGtMnnLLggDWo8d2VvGTwG3+iAGQA=\n08-18 19:24:51.586  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:51.590  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:51.607  1471  1471 I update_engine: type=1400 audit(0.0:1346): avc: denied { search } for name=\"/\" dev=\"sde6\" ino=1 scontext=u:r:update_engine:s0 tcontext=u:object_r:bt_firmware_file:s0 tclass=dir permissive=1\n08-18 19:24:51.611  1471  1471 I update_engine: EnsureMetadataMounted does nothing in Android mode.\n08-18 19:24:51.615  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(676)] Erasing AVB footer of system_other partition before update.\n08-18 19:24:51.619  1471  1471 E update_engine: [libfs_mgr]ReadFstabFromFile(): cannot open file: '/system/etc/fstab.postinstall': No such file or directory\n08-18 19:24:51.621  1471  1471 W update_engine: [WARNING:dynamic_partition_control_android.cc(550)] Cannot read fstab from /system/etc/fstab.postinstall: No such file or directory (2)\n08-18 19:24:51.623  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(577)] AVB is not enabled on system_other. Skip erasing.\n08-18 19:24:51.625  1471  1471 I update_engine: Update has been initiated, now canceling\n08-18 19:24:51.627  1471  1471 I update_engine: Removing all update state.\n08-18 19:24:51.629  1471  1471 W update_engine: Cannot read /metadata/ota/snapshot-boot: No such file or directory\n08-18 19:24:51.630  1471  1471 W update_engine: Failed to get flashing status\n08-18 19:24:51.632  1471  1471 W update_engine: Cannot read /metadata/ota/snapshot-boot: No such file or directory\n08-18 19:24:52.644  1471  1471 I update_engine: Successfully unmapped snapshot system_b\n08-18 19:24:52.654  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b\n08-18 19:24:52.766  1471  1471 I update_engine: Successfully unmapped snapshot product_b\n08-18 19:24:52.776  1471  1471 I update_engine: Successfully unmapped snapshot odm_b\n08-18 19:24:52.837  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:52.858  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:52.883  1471  1471 I update_engine: [liblp]Partition odm_b will resize from 1286144 bytes to 1089536 bytes\n08-18 19:24:52.885  1471  1471 I update_engine: [liblp]Partition system_b will resize from 3553296384 bytes to 3517079552 bytes\n08-18 19:24:52.886  1471  1471 I update_engine: [liblp]Partition product_b will resize from 310919168 bytes to 328949760 bytes\n08-18 19:24:52.888  1471  1471 I update_engine: [liblp]Partition vendor_b will resize from 1469992960 bytes to 1523589120 bytes\n08-18 19:24:52.889  1471  1471 I update_engine: Remaining free space for COW: 3753377792 bytes\n08-18 19:24:52.934  1471  1471 I update_engine: For partition system_b, device size = 3517079552, snapshot size = 3517079552, cow partition size = 3530821632, cow file size = 0\n08-18 19:24:52.941  1471  1471 I update_engine: [liblp]Partition system_b-cow will resize from 0 bytes to 3530821632 bytes\n08-18 19:24:52.943  1471  1471 I update_engine: Successfully created snapshot partition for system_b\n08-18 19:24:52.945  1471  1471 I update_engine: Remaining free space for COW: 222298112 bytes\n08-18 19:24:52.951  1471  1471 I update_engine: For partition product_b, device size = 328949760, snapshot size = 328949760, cow partition size = 222298112, cow file size = 107937792\n08-18 19:24:52.954  1471  1471 I update_engine: [liblp]Partition product_b-cow will resize from 0 bytes to 222298112 bytes\n08-18 19:24:52.956  1471  1471 I update_engine: Successfully created snapshot partition for product_b\n08-18 19:24:52.958  1471  1471 I update_engine: Remaining free space for COW: 0 bytes\n08-18 19:24:52.976  1471  1471 I update_engine: For partition vendor_b, device size = 1523589120, snapshot size = 1523589120, cow partition size = 0, cow file size = 1529540608\n08-18 19:24:52.982  1471  1471 I update_engine: Successfully created snapshot partition for vendor_b\n08-18 19:24:52.986  1471  1471 I update_engine: Remaining free space for COW: 0 bytes\n08-18 19:24:52.988  1471  1471 I update_engine: For partition odm_b, device size = 1089536, snapshot size = 1089536, cow partition size = 0, cow file size = 1044480\n08-18 19:24:52.990  1471  1471 I update_engine: Successfully created snapshot partition for odm_b\n08-18 19:24:52.992  1471  1471 I update_engine: Allocating CoW images.\n08-18 19:24:53.006  1471  1471 I update_engine: Successfully created snapshot for odm_b\n08-18 19:24:53.104  1471  1471 I update_engine: Successfully created snapshot for product_b\n08-18 19:24:53.126  1471  1471 I update_engine: Successfully created snapshot for system_b\n08-18 19:24:53.621  1471  1471 I update_engine: Successfully created snapshot for vendor_b\n08-18 19:24:53.625  1471  1471 I update_engine: Successfully unmapped snapshot system_b\n08-18 19:24:53.661  1471  1471 I update_engine: Mapped COW device for system_b at /dev/block/dm-9\n08-18 19:24:53.666  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9\n08-18 19:24:53.708  1471  1471 I update_engine: Successfully unmapped snapshot product_b\n08-18 19:24:53.740  1471  1471 I update_engine: Mapped product_b-cow-img to /dev/block/dm-9\n08-18 19:24:53.769  1471  1471 I update_engine: Mapped COW device for product_b at /dev/block/dm-10\n08-18 19:24:53.775  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-10\n08-18 19:24:53.835  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b\n08-18 19:24:53.862  1471  1471 I update_engine: Mapped vendor_b-cow-img to /dev/block/dm-9\n08-18 19:24:53.865  1471  1471 I update_engine: Mapped COW image for vendor_b at vendor_b-cow-img\n08-18 19:24:53.868  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9\n08-18 19:24:53.900  1471  1471 I update_engine: Successfully unmapped snapshot odm_b\n08-18 19:24:53.930  1471  1471 I update_engine: Mapped odm_b-cow-img to /dev/block/dm-9\n08-18 19:24:53.933  1471  1471 I update_engine: Mapped COW image for odm_b at odm_b-cow-img\n08-18 19:24:53.935  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9\n08-18 19:24:53.968  1471  1471 I update_engine: [liblp]Updated logical partition table at slot 1 on device super\n08-18 19:24:53.970  1471  1471 I update_engine: Successfully created all snapshots for target slot _b\n08-18 19:24:53.973  1471  1471 I update_engine: [INFO:delta_performer.cc(1002)] PreparePartitionsForUpdate done.\n08-18 19:24:53.999  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.002  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.004  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.006  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] abl_a is not in super partition metadata.\n08-18 19:24:54.008  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.011  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.013  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.016  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.018  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] abl_b is not in super partition metadata.\n08-18 19:24:54.020  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.022  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.025  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.027  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.029  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] aop_a is not in super partition metadata.\n08-18 19:24:54.031  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.033  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.035  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.038  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.039  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] aop_b is not in super partition metadata.\n08-18 19:24:54.041  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.043  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.045  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.048  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.049  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] bluetooth_a is not in super partition metadata.\n08-18 19:24:54.051  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.053  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.056  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.059  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.060  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] bluetooth_b is not in super partition metadata.\n08-18 19:24:54.062  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.064  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.067  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.069  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.071  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] boot_a is not in super partition metadata.\n08-18 19:24:54.072  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.075  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.077  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.079  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.081  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] boot_b is not in super partition metadata.\n08-18 19:24:54.083  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.085  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.088  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.090  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.091  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] cpucp_a is not in super partition metadata.\n08-18 19:24:54.094  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.096  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.098  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.100  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.102  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] cpucp_b is not in super partition metadata.\n08-18 19:24:54.104  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.107  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.109  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.111  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.113  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] devcfg_a is not in super partition metadata.\n08-18 19:24:54.115  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.117  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.119  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.121  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.122  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] devcfg_b is not in super partition metadata.\n08-18 19:24:54.125  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.127  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.129  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.131  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.133  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dsp_a is not in super partition metadata.\n08-18 19:24:54.135  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.137  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.139  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.142  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.144  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dsp_b is not in super partition metadata.\n08-18 19:24:54.146  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.148  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.150  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.152  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.154  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dtbo_a is not in super partition metadata.\n08-18 19:24:54.156  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.158  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.161  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.163  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.164  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dtbo_b is not in super partition metadata.\n08-18 19:24:54.166  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.169  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.171  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.174  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.175  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] featenabler_a is not in super partition metadata.\n08-18 19:24:54.177  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.179  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.182  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.184  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.185  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] featenabler_b is not in super partition metadata.\n08-18 19:24:54.188  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.190  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.193  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.195  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.197  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] hyp_a is not in super partition metadata.\n08-18 19:24:54.200  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.202  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.205  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.208  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.210  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] hyp_b is not in super partition metadata.\n08-18 19:24:54.212  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.214  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.217  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.220  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.221  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] imagefv_a is not in super partition metadata.\n08-18 19:24:54.224  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.226  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.229  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.231  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.233  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] imagefv_b is not in super partition metadata.\n08-18 19:24:54.235  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.238  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.241  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.243  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.244  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] keymaster_a is not in super partition metadata.\n08-18 19:24:54.246  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.249  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.251  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.253  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.255  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] keymaster_b is not in super partition metadata.\n08-18 19:24:54.257  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.259  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.262  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.264  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.265  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] modem_a is not in super partition metadata.\n08-18 19:24:54.267  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.269  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.272  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.274  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.276  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] modem_b is not in super partition metadata.\n08-18 19:24:54.278  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.280  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.282  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.285  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.286  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] odm_a is mapped on device mapper: /dev/block/dm-3\n08-18 19:24:54.288  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.291  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.293  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.295  1471  1471 I update_engine: Successfully unmapped snapshot odm_b\n08-18 19:24:54.328  1471  1471 I update_engine: [libfs_mgr]Created logical partition odm_b-base on device /dev/block/dm-9\n08-18 19:24:54.358  1471  1471 I update_engine: Mapped odm_b-cow-img to /dev/block/dm-10\n08-18 19:24:54.361  1471  1471 I update_engine: Mapped COW image for odm_b at odm_b-cow-img\n08-18 19:24:54.420  1471  1471 I update_engine: Mapped odm_b as snapshot device at /dev/block/dm-11\n08-18 19:24:54.422  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped odm_b to device mapper (force_writable = 1); device path at /dev/block/dm-11\n08-18 19:24:54.426  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.429  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.432  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.433  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] product_a is mapped on device mapper: /dev/block/dm-1\n08-18 19:24:54.435  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.438  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.440  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.441  1471  1471 I update_engine: Successfully unmapped snapshot product_b\n08-18 19:24:54.472  1471  1471 I update_engine: [libfs_mgr]Created logical partition product_b-base on device /dev/block/dm-12\n08-18 19:24:54.503  1471  1471 I update_engine: Mapped product_b-cow-img to /dev/block/dm-13\n08-18 19:24:54.536  1471  1471 I update_engine: Mapped COW device for product_b at /dev/block/dm-14\n08-18 19:24:54.557  1471  1471 I update_engine: Mapped product_b as snapshot device at /dev/block/dm-15\n08-18 19:24:54.561  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped product_b to device mapper (force_writable = 1); device path at /dev/block/dm-15\n08-18 19:24:54.564  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.567  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.569  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.571  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] qupfw_a is not in super partition metadata.\n08-18 19:24:54.573  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.576  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.579  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.582  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.584  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] qupfw_b is not in super partition metadata.\n08-18 19:24:54.586  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.588  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.591  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.593  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.595  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] shrm_a is not in super partition metadata.\n08-18 19:24:54.597  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.599  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.602  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.604  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.605  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] shrm_b is not in super partition metadata.\n08-18 19:24:54.607  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.610  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.612  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.614  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.616  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] system_a is mapped on device mapper: /dev/block/dm-0\n08-18 19:24:54.618  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.621  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.623  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.625  1471  1471 I update_engine: Successfully unmapped snapshot system_b\n08-18 19:24:54.656  1471  1471 I update_engine: [libfs_mgr]Created logical partition system_b-base on device /dev/block/dm-16\n08-18 19:24:54.691  1471  1471 I update_engine: Mapped COW device for system_b at /dev/block/dm-17\n08-18 19:24:54.712  1471  1471 I update_engine: Mapped system_b as snapshot device at /dev/block/dm-18\n08-18 19:24:54.715  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped system_b to device mapper (force_writable = 1); device path at /dev/block/dm-18\n08-18 19:24:54.718  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.721  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.724  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.726  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] tz_a is not in super partition metadata.\n08-18 19:24:54.728  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.730  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.733  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.735  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.737  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] tz_b is not in super partition metadata.\n08-18 19:24:54.739  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.742  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.744  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.746  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.748  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] uefisecapp_a is not in super partition metadata.\n08-18 19:24:54.750  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.752  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.755  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.757  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.759  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] uefisecapp_b is not in super partition metadata.\n08-18 19:24:54.761  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.764  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.767  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.769  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.771  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_a is not in super partition metadata.\n08-18 19:24:54.773  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.775  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.778  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.780  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.782  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_b is not in super partition metadata.\n08-18 19:24:54.784  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.786  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.789  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.792  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.793  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_system_a is not in super partition metadata.\n08-18 19:24:54.796  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.798  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.801  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.804  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.806  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_system_b is not in super partition metadata.\n08-18 19:24:54.808  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.811  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.814  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.817  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.819  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] vendor_a is mapped on device mapper: /dev/block/dm-2\n08-18 19:24:54.821  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.824  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.826  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.828  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b\n08-18 19:24:54.861  1471  1471 I update_engine: [libfs_mgr]Created logical partition vendor_b-base on device /dev/block/dm-19\n08-18 19:24:54.889  1471  1471 I update_engine: Mapped vendor_b-cow-img to /dev/block/dm-20\n08-18 19:24:54.893  1471  1471 I update_engine: Mapped COW image for vendor_b at vendor_b-cow-img\n08-18 19:24:54.913  1471  1471 I update_engine: Mapped vendor_b as snapshot device at /dev/block/dm-21\n08-18 19:24:54.920  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped vendor_b to device mapper (force_writable = 1); device path at /dev/block/dm-21\n08-18 19:24:54.924  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.927  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.930  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.932  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vendor_boot_a is not in super partition metadata.\n08-18 19:24:54.935  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.938  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.941  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.944  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.946  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vendor_boot_b is not in super partition metadata.\n08-18 19:24:54.948  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.950  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.953  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.955  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.957  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vm-bootsys_a is not in super partition metadata.\n08-18 19:24:54.959  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.962  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.965  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.967  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.969  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vm-bootsys_b is not in super partition metadata.\n08-18 19:24:54.972  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.974  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.977  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.979  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.981  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_a is not in super partition metadata.\n08-18 19:24:54.983  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.985  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.988  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:54.990  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.992  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_b is not in super partition metadata.\n08-18 19:24:54.994  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:54.996  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:54.999  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:55.001  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:55.003  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_config_a is not in super partition metadata.\n08-18 19:24:55.005  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:55.007  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor\n08-18 19:24:55.010  1471  1471 I update_engine: Skip mounting partition: /system_ext\n08-18 19:24:55.013  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super\n08-18 19:24:55.015  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_config_b is not in super partition metadata.\n08-18 19:24:55.017  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super\n08-18 19:24:55.019  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old abl sha256: LKUfY1q5mz+KuU4Rmg+MrNqlzBahrYzBU4kOiE8Ooj8= size: 208896\n08-18 19:24:55.021  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new abl sha256: hS8rXeEII9MtiJhBaUCxxPfQOUUPeyrxsAU4NxmRr5E= size: 208896\n08-18 19:24:55.023  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old aop sha256: +xi8aAv0b4LPhA7kt/VRZ4AqEFxl2IkVj9bOULKDU/M= size: 237568\n08-18 19:24:55.025  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new aop sha256: e9o49HW8O1Fu5AwhkPiNrF3tF3vDjG4Ae0RIyoFdXM0= size: 241664\n08-18 19:24:55.027  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old bluetooth sha256: c+6BjIunasEsCvK6Jr5m7BzCGJq3tyDHhL3pvQkqVgI= size: 880640\n08-18 19:24:55.029  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new bluetooth sha256: zgQ+DFP0LI3nyFOPLQsHE0ZiWrWhaf6+kqmXXBOtIYs= size: 880640\n08-18 19:24:55.030  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old boot sha256: i8WwddePQv4qv2Jgtu06Mc5KUAfliUZOJfuzeVROKZU= size: 201326592\n08-18 19:24:55.032  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new boot sha256: BCPYki46J+9B7L2Qw0dyqjT4tIgs32GNWP9LPXsB67c= size: 201326592\n08-18 19:24:55.034  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old cpucp sha256: Iopy3jwBtH34WvG7QE8hV1VjUptSy6ZdNcqGR0bwPLw= size: 94208\n08-18 19:24:55.035  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new cpucp sha256: uaQ7Vd67d7OZbqQijAqsMi8EUJr92PkfPWRCXRY8A3I= size: 98304\n08-18 19:24:55.037  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old devcfg sha256: R3UrDvSUGAYyk6z6AGSr6NJ1jv2m1J4ED79aXIyrlhA= size: 49152\n08-18 19:24:55.039  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new devcfg sha256: XEZTYY+qC/x3ReEZoJworSGR4/46+PrVrPwSDSslv00= size: 53248\n08-18 19:24:55.040  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old dsp sha256: suWGN67jBTosAj9AnqkLIMWJ1ltQ23+u2m907aThq6I= size: 67108864\n08-18 19:24:55.042  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new dsp sha256: suWGN67jBTosAj9AnqkLIMWJ1ltQ23+u2m907aThq6I= size: 67108864\n08-18 19:24:55.043  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old dtbo sha256: 8pO250Kv+c0lantXJRsH5nuyJIldedl4TZ3DSgjqsgs= size: 8388608\n08-18 19:24:55.045  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new dtbo sha256: z9EcMQ0GeM/EUjGJufNOyezldChHx9F9YygkgMdMbKI= size: 8388608\n08-18 19:24:55.046  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old featenabler sha256: lG3p43ZOZvarWcTxWX8EE4SFMnxpjL3GsnfjBSOxrWc= size: 86016\n08-18 19:24:55.048  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new featenabler sha256: IhmZnJ3dWkolqEJy41s5We3Cr0tQIiXZPWTKmBBirBc= size: 90112\n08-18 19:24:55.050  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old hyp sha256: 85Xh+KcpkrrqsHRsagKvIAPrsOONgz/4Dnb4bzpRZ8k= size: 3395584\n08-18 19:24:55.051  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new hyp sha256: ywlIjYFGmFdsPZwFBCZ0opfEvdERJzGPzDrGzVlWWZ8= size: 3399680\n08-18 19:24:55.053  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old imagefv sha256: Km9PNGzyje+WR5TLaZk3129bHLCuz2cJJ8g+cKe+6Qk= size: 28672\n08-18 19:24:55.055  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new imagefv sha256: /2kScNnnNSZXg4v4siLy2+Aew4Y4XzrJUaJSWzULYeA= size: 28672\n08-18 19:24:55.056  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old keymaster sha256: 4KHtQoMQb5u7nRY3HiIOk5TOcQuowNNHzIqgLIOjpzU= size: 258048\n08-18 19:24:55.058  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new keymaster sha256: MA6O6lkgd8OUfaIdudxGnfYDL2x8hzmakyZHi0Rkvag= size: 262144\n08-18 19:24:55.059  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old modem sha256: ko9BWvXMob/IoCy8A+uvq6GwVeBDwswUlqNIAhLaWZY= size: 192884736\n08-18 19:24:55.061  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new modem sha256: z9drl26xsoafKek/73PdmdczM5bJOw1X4zRVCvL9Mog= size: 193671168\n08-18 19:24:55.062  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old odm sha256: 2Y1fxITkZW1c4hFYBgC7RyAX2dAzHJtnV7ELApEMSCE= size: 1286144\n08-18 19:24:55.064  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new odm sha256: l/oIDspqyiDykR4mjk2GPh6zmheHo5f03U9XI1Dfzyg= size: 1089536\n08-18 19:24:55.065  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old product sha256: rBOR7K0r7PjpLCPkZI585l0ru8YFtd58Uia9td+7WTY= size: 310919168\n08-18 19:24:55.067  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new product sha256: 6TYZ3vLg5bXchP2xAAp3dZrK9r7pY2rbjyD6G+sjk8Y= size: 328949760\n08-18 19:24:55.069  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old qupfw sha256: tTsWZkkP/F9TZZ+uWYwLLb7frJ3H/y5XJbxvQmUjIqg= size: 53248\n08-18 19:24:55.070  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new qupfw sha256: 3jpnlnLyamrF6hrpPoJ+nOl5tIXKKqbDaOtL1+rgu3s= size: 57344\n08-18 19:24:55.072  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old shrm sha256: KrVggLqd3q6VS4C33hRMfWs9vnJX0r+LI23bKLWZ+2E= size: 40960\n08-18 19:24:55.073  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new shrm sha256: OYFDe2zcvXDWyPGIyEPOCvtFa9z9MxJ3kro2VzQLWPI= size: 45056\n08-18 19:24:55.075  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old system sha256: LhRpM2Co250bUcefZesGxf9sWsi4Iv4GmwLW+gi10EI= size: 3553296384\n08-18 19:24:55.076  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new system sha256: cd3Ps088SC1Pe+STTyQvVrK8+cmLLpoCvQlHBle7/io= size: 3517079552\n08-18 19:24:55.078  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old tz sha256: 7eBsfC6w41AYS3xI6L0IM78LWLzakupzq0pCPIKVf6s= size: 3624960\n08-18 19:24:55.080  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new tz sha256: XJ0GRq1SOmNjs+wlCaH23g6BnYsArLmtRTno9F8B3Aw= size: 3629056\n08-18 19:24:55.081  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old uefisecapp sha256: Rw22/udqIRoIpmnH8XXmXXgTIVkRBgSZ+EBf1S/vfPs= size: 122880\n08-18 19:24:55.083  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new uefisecapp sha256: Fz8/c9AKTBw0mU48AHyVN8EFPLZdBt6On5w6+giUOXU= size: 126976\n08-18 19:24:55.085  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vbmeta sha256: +1lHFFhEHNNXkoGzV+UepcA2ACn52gpr4wcZIFjK3Os= size: 8192\n08-18 19:24:55.086  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vbmeta sha256: TgLJLUIKbeSmTd5XCQnyDJKiuQCh32sV2acdW3+V8xc= size: 8192\n08-18 19:24:55.088  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vbmeta_system sha256: oCfE/MmDj/oFNutvF8323jQmMOUSZyxWZ967xwIyP/M= size: 4096\n08-18 19:24:55.090  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vbmeta_system sha256: 9iscNy39AWU0lXaikuLtSmFQtSqgudkmYhfotwiEHHQ= size: 4096\n08-18 19:24:55.091  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vendor sha256: Bnecgyti7gGs/uXInom7bpl3PUJ8bpAGJqL9OTMWUWs= size: 1469992960\n08-18 19:24:55.093  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vendor sha256: KbMKhjjPPUb6ew38BtauoenktJzeXsAyIAQo1Suj+pI= size: 1523589120\n08-18 19:24:55.094  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vendor_boot sha256: DLiSM4l+ydJE9BAY1xn5W6PD4fnAdGrNx83GwTszUVI= size: 100663296\n08-18 19:24:55.096  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vendor_boot sha256: TZ8xsevkXAMLUAoliRXRrS5V2KXwgz+12bSKqSDH8oM= size: 100663296\n08-18 19:24:55.097  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vm-bootsys sha256: eLgXQJ1Qc8shx8H2kpN7i9S7enKAPXcIyf7dB6Dnh9E= size: 229998592\n08-18 19:24:55.099  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vm-bootsys sha256: PvhkY00YGb0Pz8F/NW3NR9KCkULkaMGlv5pPd2pjAlM= size: 229998592\n08-18 19:24:55.101  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old xbl sha256: 8s3zMMejgPFQVTda+PL8/oMWZ8TuQI+iANRg/uci02c= size: 3637248\n08-18 19:24:55.102  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new xbl sha256: X6ni5/bFuI4xVs0pX4b7Nnp/76s0p6vc03t8pa1+WLc= size: 3641344\n08-18 19:24:55.104  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old xbl_config sha256: WxnRMP2xzZxmwabirIbkVhcC4Sq1V83/JwoB5kRwWsY= size: 212992\n08-18 19:24:55.105  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new xbl_config sha256: 62UgiqGTFSnz9HN2uM6fwh0vkU91uTbK3xzmHAOizt0= size: 217088\n08-18 19:24:55.107  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC\n08-18 19:24:55.112  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:55.114  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition \"abl\"\n08-18 19:24:55.116  1471  1471 I update_engine: [INFO:delta_performer.cc(657)] Starting to apply update payload operations\n08-18 19:24:55.159  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/aop_b partition without O_DSYNC\n08-18 19:24:55.164  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:55.167  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 9 operations to partition \"aop\"\n08-18 19:24:55.225  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/bluetooth_b partition without O_DSYNC\n08-18 19:24:55.230  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:55.233  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 90 operations to partition \"bluetooth\"\n08-18 19:24:55.509  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/boot_b partition without O_DSYNC\n08-18 19:24:55.514  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:55.516  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 115 operations to partition \"boot\"\n08-18 19:24:58.794  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/cpucp_b partition without O_DSYNC\n08-18 19:24:58.799  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:58.801  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"cpucp\"\n08-18 19:24:58.828  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/devcfg_b partition without O_DSYNC\n08-18 19:24:58.833  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:58.835  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition \"devcfg\"\n08-18 19:24:58.872  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/dsp_b partition without O_DSYNC\n08-18 19:24:58.877  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:58.879  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 62 operations to partition \"dsp\"\n08-18 19:24:59.368  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/dtbo_b partition without O_DSYNC\n08-18 19:24:59.374  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.376  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 4 operations to partition \"dtbo\"\n08-18 19:24:59.436  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/featenabler_b partition without O_DSYNC\n08-18 19:24:59.441  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.444  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"featenabler\"\n08-18 19:24:59.467  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/hyp_b partition without O_DSYNC\n08-18 19:24:59.471  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.473  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 7 operations to partition \"hyp\"\n08-18 19:24:59.598  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/imagefv_b partition without O_DSYNC\n08-18 19:24:59.603  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.605  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"imagefv\"\n08-18 19:24:59.631  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/keymaster_b partition without O_DSYNC\n08-18 19:24:59.636  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.639  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"keymaster\"\n08-18 19:24:59.669  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/modem_b partition without O_DSYNC\n08-18 19:24:59.673  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:24:59.675  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 2307 operations to partition \"modem\"\n08-18 19:25:00.036  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 310/10273 operations (3%), 50561024/280875113 bytes downloaded (18%), overall progress 10%\n08-18 19:25:06.425  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 2261/10273 operations (22%), 53575680/280875113 bytes downloaded (19%), overall progress 20%\n08-18 19:25:07.544  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-11 partition without O_DSYNC\n08-18 19:25:07.551  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:25:07.553  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 10 operations to partition \"odm\"\n08-18 19:25:07.654  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-15 partition without O_DSYNC\n08-18 19:25:07.659  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:25:07.662  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 280 operations to partition \"product\"\n08-18 19:25:14.019  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/qupfw_b partition without O_DSYNC\n08-18 19:25:14.025  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:25:14.028  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"qupfw\"\n08-18 19:25:14.049  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/shrm_b partition without O_DSYNC\n08-18 19:25:14.054  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:25:14.056  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition \"shrm\"\n08-18 19:25:14.099  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-18 partition without O_DSYNC\n08-18 19:25:14.103  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:25:14.106  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 4847 operations to partition \"system\"\n08-18 19:25:19.109  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 3493/10273 operations (34%), 76431360/280875113 bytes downloaded (27%), overall progress 30%\n08-18 19:25:34.556  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 4449/10273 operations (43%), 106741760/280875113 bytes downloaded (38%), overall progress 40%\n08-18 19:25:40.412  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 4490/10273 operations (43%), 162922496/280875113 bytes downloaded (58%), overall progress 50%\n08-18 19:25:52.807  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 5548/10273 operations (54%), 187367424/280875113 bytes downloaded (66%), overall progress 60%\n08-18 19:26:01.516  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 6275/10273 operations (61%), 224706560/280875113 bytes downloaded (80%), overall progress 70%\n08-18 19:26:16.267  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 7603/10273 operations (74%), 244678656/280875113 bytes downloaded (87%), overall progress 80%\n08-18 19:26:20.298  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/tz_b partition without O_DSYNC\n08-18 19:26:20.305  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:20.307  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 29 operations to partition \"tz\"\n08-18 19:26:20.444  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/uefisecapp_b partition without O_DSYNC\n08-18 19:26:20.450  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:20.452  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition \"uefisecapp\"\n08-18 19:26:20.486  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vbmeta_b partition without O_DSYNC\n08-18 19:26:20.491  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:20.493  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1 operations to partition \"vbmeta\"\n08-18 19:26:20.506  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vbmeta_system_b partition without O_DSYNC\n08-18 19:26:20.510  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:20.512  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1 operations to partition \"vbmeta_system\"\n08-18 19:26:20.527  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-21 partition without O_DSYNC\n08-18 19:26:20.531  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:20.533  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1853 operations to partition \"vendor\"\n08-18 19:26:34.562  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 9041/10273 operations (88%), 260440064/280875113 bytes downloaded (92%), overall progress 90%\n08-18 19:26:46.100  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vendor_boot_b partition without O_DSYNC\n08-18 19:26:46.106  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.\n08-18 19:26:46.108  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 51 operations to partition \"vendor_boot\"\n08-18 19:26:46.150  1471  1471 E update_engine: [ERROR:delta_performer.cc(431)] Unable to open ECC source partition vendor_boot on slot A, file /dev/block/bootdevice/by-name/vendor_boot_a: Success (0)\n08-18 19:26:46.155  1471  1471 E update_engine: [ERROR:delta_performer.cc(1158)] The hash of the source data on disk for this operation doesn't match the expected value. This could mean that the delta update payload was targeted for another version, or that the source partition was modified after it was installed, for example, by mounting a filesystem.\n08-18 19:26:46.157  1471  1471 E update_engine: [ERROR:delta_performer.cc(1163)] Expected:   sha256|hex = 84CBC3930817F59F08D6BAE4E64F40452AEEE007C8B2D74439358BD56446DF6C\n08-18 19:26:46.159  1471  1471 E update_engine: [ERROR:delta_performer.cc(1166)] Calculated: sha256|hex = CE99046C8D163FBD1490314FA7582269045D8A1B2B2DDF14EC6B3DF8961D5176\n08-18 19:26:46.161  1471  1471 E update_engine: [ERROR:delta_performer.cc(1177)] Operation source (offset:size) in blocks: 0:741,24575:1\n08-18 19:26:46.164  1471  1471 E update_engine: [ERROR:delta_performer.cc(1498)] source_fd != nullptr failed.\n08-18 19:26:46.166  1471  1471 E update_engine: [ERROR:delta_performer.cc(297)] Failed to perform BROTLI_BSDIFF operation 9648, which is the operation 0 in partition \"vendor_boot\"\n08-18 19:26:46.168  1471  1471 E update_engine: [ERROR:download_action.cc(336)] Error ErrorCode::kDownloadStateInitializationError (20) in DeltaPerformer's Write method when processing the received payload -- Terminating processing\n08-18 19:26:46.172  1471  1471 I update_engine: [INFO:delta_performer.cc(314)] Discarding 287 unused downloaded bytes\n08-18 19:26:46.174  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(177)] Received transfer terminated.\n08-18 19:26:46.176  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(129)] TransferEnded w/ code 200\n08-18 19:26:46.177  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(131)] Terminating.\n08-18 19:26:46.236  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kDownloadStateInitializationError\n08-18 19:26:46.240  1471  1471 I update_engine: [INFO:action_processor.cc(121)] ActionProcessor: Aborting processing due to failure.\n08-18 19:26:46.242  1471  1471 I update_engine: [INFO:update_attempter_android.cc(522)] Processing Done.\n08-18 19:26:46.245  1471  1471 I update_engine: [INFO:delta_performer.cc(1997)] Resetting recorded hash for prepared partitions.\n08-18 19:26:46.248  1471  1471 I update_engine: [INFO:update_attempter_android.cc(546)] Resetting update progress.\n08-18 19:26:46.250  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(263)] Destroying [odm_b, product_b, system_b, vendor_b] from device mapper\n08-18 19:26:46.278  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition odm_b\n08-18 19:26:46.354  1471  1471 I update_engine: Successfully unmapped snapshot odm_b\n08-18 19:26:46.359  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped odm_b from device mapper.\n08-18 19:26:46.386  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition product_b\n08-18 19:26:46.471  1471  1471 I update_engine: Successfully unmapped snapshot product_b\n08-18 19:26:46.477  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped product_b from device mapper.\n08-18 19:26:46.506  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition system_b\n08-18 19:26:46.587  1471  1471 I update_engine: Successfully unmapped snapshot system_b\n08-18 19:26:46.592  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped system_b from device mapper.\n08-18 19:26:46.689  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition vendor_b\n08-18 19:26:46.742  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b\n08-18 19:26:46.746  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped vendor_b from device mapper.\n08-18 19:26:46.759  1471  1471 I update_engine: [INFO:metrics_reporter_android.cc(131)] Current update attempt downloads 262 bytes data\n\n```\n\n# r 上virtual ab的适配\n\n## recovery上的修改\n\n### 升级过程调试\n\n```shell\nadb push otacerts.zip /system/etc/security/\nupdate_engine_sideload  --payload=file:///tmp/update.zip  --offset=1418 --headers=\"\\\nFILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=\nFILE_SIZE=181915047\nMETADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=\nMETADATA_SIZE=607150\n\"\nupdate_engine_sideload  --payload=file:///tmp/update.zip  --offset=1324 --headers=\"\\\nFILE_HASH=76gLVcAOp24qvgZC0iigNmi+27SwESfR003JZSzJ5C8=\nFILE_SIZE=3650338089\nMETADATA_HASH=h83AZLcrxwdYTK2kr/fajBovPRqOGcmBu1gy6IqEtUI=\nMETADATA_SIZE=210289\n\"\n```\n\n> 算offset的方法:\n\n```python\nimport zipfile\nwith zipfile.ZipFile('/home/mi/Downloads/miui-blockota-venus-20.9.24.root-20.9.27.root-f8ff8484a9-11.0.zip') as input_zip:\n  a = input_zip.getinfo('payload_properties.txt')\n  c = input_zip.getinfo('payload.bin')\n  b = a.header_offset - c.file_size\n  print(b)\n```\n\n```shell\nupdate_engine_client \\\n--payload=file:///data/ota_package/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=micJIkMGwvRYI01GT3ESWtE3O6drypDdWHrAj7mbHJE=\nFILE_SIZE=171868736\nMETADATA_HASH=AnZQNNsMgBsqA0z8asH14haURnuJ35GVvc8HqY2gRbQ=\nMETADATA_SIZE=1014574\n\"\n\nupdate_engine_client \\\n--payload=file:///data/ota_package/payload.bin \\\n--update \\\n--headers=\"\\\nFILE_HASH=GmmYrTs4n1u+a52W7cHE0MQ59sw/qrPAvsuR7JgB2B0=\nFILE_SIZE=3618079575\nMETADATA_HASH=HpGq2D4TNzkkdxlbfoMzbCvKKht4LRDD5kqlHAnbOxg=\nMETADATA_SIZE=210965\n\"\n```\n\n\n\n## 估算\n\ndata report:\n\nfullOTA:\n```shell\n # target_file size\n[$] -> ll signed_venus_global-target_files-20.10.16-11.0.zip\n-rw-rw-r-- 1 mi mi 8331428868 10月 16 12:10 signed_venus_global-target_files-20.10.16-11.0.zip\n# images in target_file\n[$] -> ll signed_venus_global-target_files-20.10.16-11.0/IMAGES\n-rw-rw-r--  1 mi mi  100663296 1月   1  2009 boot-gki.img\n-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img\n-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img\n-rw-rw-r--  1 mi mi    1065072 1月   1  2009 odm.img\n-rw-rw-r--  1 mi mi        677 1月   1  2009 odm.map\n-rw-rw-r--  1 mi mi 1048531236 1月   1  2009 product.img\n-rw-rw-r--  1 mi mi      43776 1月   1  2009 product.map\n-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img\n-rw-rw-r--  1 mi mi  403837100 1月   1  2009 system_ext.img\n-rw-rw-r--  1 mi mi      78781 1月   1  2009 system_ext.map\n-rw-rw-r--  1 mi mi 2908402304 1月   1  2009 system.img\n-rw-rw-r--  1 mi mi     302171 1月   1  2009 system.map\n-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img\n-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta.img\n-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img\n-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img\n-rw-rw-r--  1 mi mi 2033811940 1月   1  2009 vendor.img\n-rw-rw-r--  1 mi mi     303801 1月   1  2009 vendor.map\n\n# full ota size\n[$] -> ll miui_VENUSGlobal_20.10.16_aefb58d7af_11.0.zip     \n-rw-rw-r-- 1 mi mi 2925387044 10月 16 12:11 miui_VENUSGlobal_20.10.16_aefb58d7af_11.0.zip\n# estimate result\nout/host/linux-x86/bin/estimate_cow_from_nonab_ota -ota_tf /home/mi/Downloads/signed_venus_global-target_files-20.10.16-11.0\nUnsparsing IMAGES/vendor.img ...\nAnalyzing vendor ...\nUnsparsing IMAGES/product.img ...\nAnalyzing product ...\nUnsparsing IMAGES/odm.img ...\nAnalyzing odm ...\nUnsparsing IMAGES/system_ext.img ...\nAnalyzing system_ext ...\nUnsparsing IMAGES/system.img ...\nAnalyzing system ...\nEstimated COW size: 3718300499 (3546MiB)\n```\n\nincOTA:\n```shell\n\n# src target_file\n[$] -> ll signed_venus_global-target_files-20.9.24-11.0.zip\n-rw-rw-r-- 1 mi mi 7912365948 10月 16 12:09 signed_venus_global-target_files-20.9.24-11.0.zip\n\n# images in src target_file\n[$] -> ll signed_venus_global-target_files-20.9.24-11.0/IMAGES\n-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img\n-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img\n-rw-rw-r--  1 mi mi    1020016 1月   1  2009 odm.img\n-rw-rw-r--  1 mi mi        381 1月   1  2009 odm.map\n-rw-rw-r--  1 mi mi 1044939068 1月   1  2009 product.img\n-rw-rw-r--  1 mi mi      43382 1月   1  2009 product.map\n-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img\n-rw-rw-r--  1 mi mi  371994820 1月   1  2009 system_ext.img\n-rw-rw-r--  1 mi mi      79300 1月   1  2009 system_ext.map\n-rw-rw-r--  1 mi mi 2706129500 1月   1  2009 system.img\n-rw-rw-r--  1 mi mi     296543 1月   1  2009 system.map\n-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img\n-rw-rw-r--  1 mi mi       8192 1月   1  2009 vbmeta.img\n-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img\n-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img\n-rw-rw-r--  1 mi mi 1891361204 1月   1  2009 vendor.img\n-rw-rw-r--  1 mi mi     279594 1月   1  2009 vendor.map\n\n\n # target_file size\n[$] -> ll signed_venus_global-target_files-20.10.16-11.0.zip\n-rw-rw-r-- 1 mi mi 8331428868 10月 16 12:10 signed_venus_global-target_files-20.10.16-11.0.zip\n# images in target_file\n[$] -> ll signed_venus_global-target_files-20.10.16-11.0/IMAGES\n-rw-rw-r--  1 mi mi  100663296 1月   1  2009 boot-gki.img\n-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img\n-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img\n-rw-rw-r--  1 mi mi    1065072 1月   1  2009 odm.img\n-rw-rw-r--  1 mi mi        677 1月   1  2009 odm.map\n-rw-rw-r--  1 mi mi 1048531236 1月   1  2009 product.img\n-rw-rw-r--  1 mi mi      43776 1月   1  2009 product.map\n-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img\n-rw-rw-r--  1 mi mi  403837100 1月   1  2009 system_ext.img\n-rw-rw-r--  1 mi mi      78781 1月   1  2009 system_ext.map\n-rw-rw-r--  1 mi mi 2908402304 1月   1  2009 system.img\n-rw-rw-r--  1 mi mi     302171 1月   1  2009 system.map\n-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img\n-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta.img\n-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img\n-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img\n-rw-rw-r--  1 mi mi 2033811940 1月   1  2009 vendor.img\n-rw-rw-r--  1 mi mi     303801 1月   1  2009 vendor.map\n# inc ota size\n[$] -> ll miui-blockota-venus_global-20.9.24-20.10.16-958988d114-11.0.zip\n-rw-rw-r-- 1 mi mi 418387975 10月 16 12:05 miui-blockota-venus_global-20.9.24-20.10.16-958988d114-11.0.zip\n\n# estimate result\nout/host/linux-x86/bin/estimate_cow_from_nonab_ota -source_tf ~/Downloads/signed_venus_global-target_files-20.9.24-11.0/ -ota_tf /home/mi/Downloads/signed_venus_global-target_files-20.10.16-11.0\n\nUnsparsing IMAGES/vendor.img ...\nUnsparsing IMAGES/vendor.img ...\nHashing blocks for vendor...\nAnalyzing vendor ...\nUnsparsing IMAGES/product.img ...\nUnsparsing IMAGES/product.img ...\nHashing blocks for product...\nAnalyzing product ...\nUnsparsing IMAGES/odm.img ...\nUnsparsing IMAGES/odm.img ...\nHashing blocks for odm...\nAnalyzing odm ...\nUnsparsing IMAGES/system_ext.img ...\nUnsparsing IMAGES/system_ext.img ...\nHashing blocks for system_ext...\nAnalyzing system_ext ...\nUnsparsing IMAGES/system.img ...\nUnsparsing IMAGES/system.img ...\nHashing blocks for system...\nAnalyzing system ...\nEstimated COW size: 1509347450 (1439MiB)\n```\n\n","tags":["Android"],"categories":["Android","OTA"]},{"title":"设备bootloader上锁状态下1217无法工作问题分析1","url":"/2019/10/12/OTA相关/keymaster解密问题/","content":"\n# 设备bootloader上锁状态下1217无法工作问题分析\n\n## 背景\n\n前面讲到r上6月份升级基线后, 因KM TA date support的升级导致recovery下无法正常使用解密服务.\n\n当时的方案是配置recovery vbmeta区域的 prop `--prop com.android.build.boot.security_patch:2020-06-05 `\n\n从而在bootimg_hdr不支持识别date 信息的情况下, 可以在reocovery模式下bootloader能够读到天的信息, 并传给KM TA.\n\n## 新问题\n\n最近测试在复测该问题时, 发现手机bootloader上锁状态下, 无法执行1217功能. 因此需要重新分析下这个问题的原因.\n\n## locked 状态下的调试\n\n### debug abl的方法\n\n#### locked状态下的限制\n\n首先, 小米机器locked 状态有如下限制:\n\n1. 不能使用fastboot烧录新的img, 即fastboot flash <partition> <partition.img> 是不被允许的\n2. 不能使用fastboot erase 分区, 像`fastboot erase misc` 无法执行\n3. locked状态切到unlocked状态, unlocked状态切到locked状态, 都会reboot 进recovery, 清除数据.\n\n上述限制或功能必须被禁用掉, 因为调试这个问题时, 本地打的调试(带logcat 和 adb shell)功能的在locked状态肯定会报`system has destroyed`, 其次经常需要debug abl, 烧分区的限制肯定要禁用掉, 不然每次烧录新的abl 都需要使用9008模式烧机, 非常麻烦. locked 切 unlocked状态, 或反之的情况清除数据的功能肯定要拿掉, 因为1217测的就是解主系统加密过的userdata分区, 如果在切换过程中把userdata擦了, 那就破坏了测试的前提. 第二条清misc也是必须的, 因为recovery如果无法正常启动, 出现`system has destroyed`, 可以通过清misc, 启动到主系统把recovery恢复回来.\n\n#### change\n\n去除locked状态下对fastboot flash / fastboot erase 和 切换locked unlocked 对userdata数据的操作\n\nhttp://gerrit.bsp.xiaomi.srv/#/c/22341/\n\n### locked状态下让avb校验失败的recovery成功启动起来\n\n> 注意不能修改avb校验完的状态, 保持最小变量原则\n\n#### change\n\n即将导向`system has destroyed`的入口破坏掉\n\nhttp://gerrit.bsp.xiaomi.srv/22334 \n\n#### 本地recovery调试1217的方法\n\n本地编译userdebug版本的recovery即可. \n\n1. 将上述change合入后, 编译abl, make aboot或者使用ninja, 注意最后abl一定要通过secureboot签名\n2. locked上锁状态可以先使用解锁工具解锁, 再通过fastboot flash abl abl.elf 烧录locked 状态修改过的abl, 然后再使用fastboot oem lock上锁.\n3. 上锁完后, fastboot flash recovery 本地的recovery.img.\n4. fastboot reboot recovery\n5. 使用下面的命令, 查看df -h的结果中是否有userdata, vold的输出的log是什么, 如果begin操作报错, 说明keymaster 返回了错误\n\n```shell\nadb root; adb shell mv /system/bin/recovery  /tmp/; adb shell touch /system/bin/recovery; adb shell /tmp/recovery --factory_test_reset&; sleep 6; adb shell df -h; adb logcat -s vold;\n```\n\n## 问题分析\n\n通过之前修改recovery 打包写入avb prop的方法已经可以使recovery在unlocked模式下1217正常工作. 而locked状态下却不行. 变量只有一个就是locked状态和unlocked状态.\n\n先根据log定位下初步原因, 测试开始提供的log中只有recovery打出的部分信息:\n\nrecovery 重启, reason= fs_mgr_mount_all\n\n根据串口log的信息, 首先可以判定是如下情形:\n\n1. 主系统bcb (reason --factory_test_reset) ->2.  recovery启动(模式为1217)-> 3. recovery重启(模式变为fs_mgr_mount_all)\n\n在第2步1217的执行步骤中触发了 RebootRecovery(fs_mgr_mount_all)的命令, 查看代码, 最终定位到\n\n`mount_all miui_factoryreset.fstab --late`时 init 在执行`vdc mountFstab /dev/block/bootdevice/by-name/userdata /data`失败后执行了上述命令, 所以需要进一步的log判断为什么这个vdc 的操作失败了.\n\n根据前面debug locked 状态下recovery的方法, 最终可以在locked状态下启动本地带调试版本的recovery\n\n得到的log如下:\n\n```shell\n01-01 01:10:19.148   630   630 D vold    : metadata_key_dir/key: /metadata/vold/metadata_encryption/key\n01-01 01:10:19.149   630   630 I vold    : List of Keymaster HALs found:\n01-01 01:10:19.149   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.150   630   630 D vold    : Computing HMAC with params { (seed: 54483455460602eb1254138a502eea6249c665fd8feebff883464d797d9f, nonce: 3f7f4c10a7eaf94e91f869e10f3f1ca1d576596d8291933b9c5305dfd90) }\n01-01 01:10:19.150   630   630 D vold    : Computing HMAC for Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.152   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.154   630   630 D vold    : Key exists, using: /metadata/vold/metadata_encryption/key\n01-01 01:10:19.156   630   630 I vold    : List of Keymaster HALs found:\n01-01 01:10:19.156   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.156   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: Begin send cmd failed\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: ret: 0\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: resp->status: -33\n01-01 01:10:19.161   630   630 E vold    : begin failed, code -33\n01-01 01:10:19.148     0     0 D vdc     : Waited 0ms for vold\n01-01 01:10:19.161     0     0 E vdc     : Command: cryptfs mountFstab /dev/block/bootdevice/by-name/userdata /data Failed: Status(-8, EX_SERVICE_SPECIFIC): '0: '\n```\n\nkeymaster返回-33的错误导致了这样的表现.\n\n根据之前对abl的分析, 这个大概率与abl传给KM TA的参数有关.\n\n搜索代码, 最终定位到\n\n```c\n  /* Set Boot State */\n  BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;\n  BootStateReq.Version = 0;\n  BootStateReq.Size = sizeof (BootStateReq.BootState);\n  BootStateReq.Offset =\n      (UINT8 *)&BootStateReq.BootState - (UINT8 *)&BootStateReq;\n  BootStateReq.BootState.Color = BootState->Color;\n  BootStateReq.BootState.IsUnlocked = BootState->IsUnlocked;\n  BootStateReq.BootState.SystemSecurityLevel = BootState->SystemSecurityLevel;\n  BootStateReq.BootState.SystemVersion = BootState->SystemVersion;\n  CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,\n           AVB_SHA256_DIGEST_SIZE);\n\n  DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: bootstate digest: \"\n                         \"%s\\n\", BootStateDigest));\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&BootStateReq,\n      sizeof (BootStateReq), (UINT8 *)&BootStateRsp, sizeof (BootStateRsp));\n```\n\ndebug分析这一过程发现locked状态下, 只有color是orange时可以让recovery在调用keymaster begin解密经主系统加密的userdata时可以正常返回.\n\n而如果userdata没有通过主系统的加密, 即在recovery下先恢复出厂设置, 再对userdata加密时, color是green情况下, 也可以正常调用keymaster,没有返回错误, 而在recovery下加密userdata完成后, 再启动到主系统, 主系统会报fs_mgr_mount_all的错误.\n\n通过上述现象, 可以推测 加密userdata相当于上层keymaster初始化, 使用当时的环境去加密的数据, 而换了环境之后, 再去解密, 由于环境的变化, 导致keymaster无法校验成功, 所以begin返回了invalid blob(-33), 而这个`环境`是什么, 通过分析BootState的字段在recovery和主系统下的区别, 只有`BootStateDigest`是值得怀疑的.\n\n## BootStateDigest即UserData->PublicKey的分析\n\n上一步怀疑这个字段有问题后, 需要分析recovery模式和主系统下这个字段的数据来源.\n\n最终发现新基线升级后, recovery的avb校验模式变成了只校验recovery分区自己, 而主系统是校验 vbmeta boot dtbo vbmeta_system. 而主系统这个字段最终来自vbmeta分区的public key. 而recovery的这个字段并没有赋值.\n\nrecovery模式:\n\n```c\n  if ( ( (!Info->MultiSlotBoot) ||\n           IsDynamicPartitionSupport ()) &&\n           (Info->BootIntoRecovery &&\n           !IsBuildUseRecoveryAsBoot ())) {\n      // 非ab机型\n    if (!Info->MultiSlotBoot) {\n        DEBUG ((EFI_D_ERROR, \"flag AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION\\n\"));\n        VerifyFlags = VerifyFlags | AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION;\n    }\n    // 只加载recovery分区\n    AddRequestedPartition (RequestedPartitionAll, IMG_RECOVERY);\n    NumRequestedPartition += 1;\n    Result = avb_slot_verify (Ops, (CONST CHAR8 *CONST *)RequestedPartition,\n               SlotSuffix, VerifyFlags, VerityFlags, &SlotData);\n      ...\n  }\n```\n\n## 问题解决\n\n上面怀疑recovery模式和主系统下abl传给KM TA的摘要是不同的, 那可以想到将vbmeta的public key 填充到 UserData->PublicKey, 下发给KM TA 是否可以解决locked状态下recovery无法使用keymaster解密经主系统加密的数据.\n\n方案如下:\n\nhttp://gerrit.bsp.xiaomi.srv/#/c/22338/\n\n只有非ab机型进入recovery情况下, 即`AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION` flag的作用范围内, 在avb verify完recovery分区后, 再avb verify下vbmeta分区, 目的是为了让其覆盖`ops->user_data`段, 而传进`load_and_verify_vbmeta`的参数需要重新设定, 因为原先的参数很多都是全局或影响avb verify recovery结果的指针, 我们这里只能覆盖`ops->user_data`段, 不能对其他段产生影响. 同时还需要对flag 重新置位, 绕开vbmeta相关的检查, 使得可以成功load vbmeta的public key, 并将其赋给`ops->user_data`段.\n\n```c\ntypedef struct {\n    BOOLEAN IsUserKey;\n    BOOLEAN IsMultiSlot;\n    UINTN PublicKeyLen;\n    CHAR8 PublicKey[MAX_USER_KEY_SIZE];\n} AvbOpsUserData;\n```\n\n重新测试后, 上述patch有效, locked下recovery中可以正常进行1217功能.\n\n### 验证\n\n1. locked状态下, 主系统开机后, 执行1217, 正常reboot到recovery中进行清数据的操作, 重启回主系统下, /data/miui/app下内容保留\n2. locked状态下, fastboot flash 本地编的recovery, fastboot reboot recovery后, 应该报`system has destroyed`\n3. unlocked 状态下, 无论是本地编的recovery还是线刷包版本的recovery, 都可以正常进行1217功能\n\n> 验证时, unlocked状态切换到locked状态, 或反之的情况, 切换过程中都需要进recovery wipe data, 擦完重新开机进主系统, 保证数据要重新经主系统初始化加密一次.","tags":["Android","FBE","1217"],"categories":["Android","加密"]},{"title":"vab机型fastbootd使用","url":"/2019/10/12/OTA相关/动态分区机型fastbootd使用/","content":"\nvnote_backup_file_826537664 /home/mi/Documents/backup/VnoteBook/OTA相关/动态分区机型fastbootd使用.md\n# 动态分区机型fastbootd使用\n\n## fastbootd简介\n在动态分区机型上bootloader的fastboot不能烧写动态分区的镜像, 需要使用**recovery子系统**下的fastbootd来进行用户空间的烧写镜像的工作\n\nfastbootd是recovery子系统下的一个native进程, 由init fork出来. 具体实现方式类似于adbd.\n包括进程创建, 驱动通道, 与init的协作都与adbd一致, 是属于借助usb的config配置实现的功能.\n因此不能同时启用adb和fastboot模式, 因为这两个独占同一个通道.\n\n\n\n## fastbootd命令\n\n| Command                                         | Description                                                  | Available when device is OEM locked |\n| ----------------------------------------------- | ------------------------------------------------------------ | ----------------------------------- |\n| getvar is-userspace                             | Return yes                                                   | Yes                                 |\n| getvar<br/>is-logical:<partition>               | Return yes if the given partition is a<br/>logical partition, no otherwise | Yes                                 |\n| getvar super-partition-name                     | MUST return super for a device<br/>launching with logical partitions | Yes                                 |\n| create-logical-partition<br/><partition> <size> | Create a logical partition with the<br/>given name and size  | No                                  |\n| delete-logical-partition<br/><partition>        | Delete the given logical partition                           | No                                  |\n| resize-logical-partition<br/><partition> <size> | Resize the logical partition to the new<br/>size without changing its contents | No                                  |\n| update-super <partition>                        | Similar to flash super, except rather<br/>than flashing raw data to the super<br/>partition, this will ensure that all<br/>partitions within the downloaded<br/>image are created | No                                  |\n| getvar max-download-size                        | Return the maximum size of an image<br/>that can be downloaded in bytes in<br/>hex | Yes                                 |\n| getvar partition-type<br/><partition-name>      | Return file system type: ext4, f2fs,<br/>raw                 | Yes                                 |\n| flash *partition_name* filename       | Flash the partition through a series of<br/>download and flash fastboot<br/>protocol commands | No                                  |\n| reboot bootloader                               | Reboot into bootloader mode                                  | Yes                                 |\n| reboot fastboot                                 | Reboot back into fastbootd mode                              | Yes                                 |\n\n\n\n## 安装最新的fastboot工具\n\n在[platform-tools](https://developer.android.com/studio/releases/platform-tools)获取最新的fastboot和adb的工具\n- linux下替换\n解压后得到platform-tools 目录\n\n```shell\nexport $PATH=<platform-tools目录>:$PATH\n```\n- windows下替换\n打开资源管理器explorer, 右键*此电脑*  -> 属性 -> 高级系统设置 -> 环境变量 -> 用户变量 ->Path下添加解压platform-tools的目录\n注销, 重新登录生效.\n\nfastboot devices查看是否有设备号输出, 如果没有, 需要配置端口或更新驱动\n\nwin下, 通过设备管理器 -> 其他设备 (未识别的!设备)-> 右键更新驱动 -> 自动搜索驱动\n\nlinux下, lsusb 设备号, 将识别出的设备号按照adb 配置设备的方式进行配置, 这里不再赘述\n\n\n\n\n## 从super img分离出包含的动态分区\n\n### 转换super img为原始镜像\n动态分区线刷包中是super.img，格式是sparse image，要查看super.img首先需要使用simg2img进行转化。若转化后为super_ext4.\n\n#### `Android Sparse Image`\n为了缩小镜像大小，Android会以稀疏格式生成system.img，vendor.img userdata.img和cache.img。镜像被拆分为4K字节倍数的块。\n任何不包含有用数据的块都将标记为`Don't Care`\n\n![sparse](http://2net.co.uk/images/boot-sparse-image.png)\n[header](http://opengrok.pt.xiaomi.com/opengrok/xref/v10-p-tucana-dev/system/core/libsparse/sparse_format.h)\n\n```shell\nsystem/core/libsparse/simg_dump.py   -v  cache.img\ncache.img: Total of 98304 4096-byte output blocks in 10 input chunks.\n            input_bytes      output_blocks\nchunk    offset     number  offset  number\n   1         40     114688       0      28 Raw data           \n   2     114740          0      28    2047 Don't care         \n   3     114752      24576    2075       6 Raw data           \n   4     139340          0    2081   30687 Don't care         \n   5     139352       8192   32768       2 Raw data           \n   6     147556          0   32770   32766 Don't care         \n   7     147568       4096   65536       1 Raw data           \n   8     151676          0   65537    2049 Don't care         \n   9     151688       4096   67586       1 Raw data           \n  10     155796          0   67587   30717 Don't care         \n         155796              98304         End\n[$] -> ll cache.img  cache.img_ext4 \n-rw-rw-r-- 1 mi mi    155796 11月 14 08:12 cache.img\n-rw-rw-r-- 1 mi mi 402653184 11月 19 14:15 cache.img_ext4\n```\n\n\n\n\n\n```shell\nsimg2img ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img    ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4\n```\n\n\n\n\n### dump super img\n如果需要查看super.img里包含哪些img, 其格式是怎样的, 可以使用lpdump工具\n\n```shell\n[$] -> ./lpdump ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4\nMetadata version: 10.0\nMetadata size: 592 bytes\nMetadata max size: 65536 bytes\nMetadata slot count: 2\nPartition table:\n------------------------\n  Name: system\n  Group: qti_dynamic_partitions\n  Attributes: readonly\n  Extents:\n    0 .. 5716647 linear super 2048\n------------------------\n  Name: product\n  Group: qti_dynamic_partitions\n  Attributes: readonly\n  Extents:\n    0 .. 916055 linear super 5720064\n------------------------\n  Name: vendor\n  Group: qti_dynamic_partitions\n  Attributes: readonly\n  Extents:\n    0 .. 2410687 linear super 6637568\n...\n------------------------\nBlock device table:\n------------------------\n  Partition name: super\n  First sector: 2048\n  Size: 9126805504 bytes\n  Flags: none\n------------------------\nGroup table:\n------------------------\n  Name: default\n  Maximum size: 0 bytes\n  Flags: none\n------------------------\n  Name: qti_dynamic_partitions\n  Maximum size: 9126805504 bytes\n  Flags: none\n```\n\n如果需要从super.img中解出其包含的分区镜像, 可以使用lpunpack工具\n\n* lpunpack [-p partition_name] SUPER_IMAGE [OUTPPUT_DIR]， -p后面跟要取出的分区名，若不指定，都会取出*\n\n\n\n\n\n### 解出system.img\n```shell\n./lpunpack -p system ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4   unpack\n[~/work_space/v10-q-umi/out/host/linux-x86/bin/unpack] - [五 11月 15, 12:51]\n[$] -> ll\n总用量 2845812\ndrwxrwxr-x 2 mi mi       4096 11月 15 12:50 .\ndrwxrwxr-x 3 mi mi       4096 11月 15 12:50 ..\n-rw-r--r-- 1 mi mi 2926923776 11月 15 12:51 system.img\n```\n解出的system.img即为原始的带文件系统的镜像, 可以直接挂载\n\n```shell\n# 查看system.img镜像的文件系统类型\nfile system.img\nmkdir system\nsudo mount -t <文件系统类型> system.img system\n```\n\n\n\n\n\n### 如上提到的工具\n可以直接在打开动态分区的机型上编译对应的工具\n\n```shell\nmake simg2img lpdump lpunpack\n# 或者使用ninja编译\n# 生成目录\nout/host/linux-x86/bin\n```\n\n也可以直接下载我这里编译好的(64位的)\n\n\n\n","tags":["vab"],"categories":["Android"]},{"title":"设备bootloader上锁状态下1217无法工作问题分析","url":"/2019/10/12/OTA相关/设备上锁状态下1217无法工作问题分析/","content":"\n# 设备bootloader上锁状态下1217无法工作问题分析\n\n## 背景\n\n前面讲到r上6月份升级基线后, 因KM TA date support的升级导致recovery下无法正常使用解密服务.\n\n当时的方案是配置recovery vbmeta区域的 prop `--prop com.android.build.boot.security_patch:2020-06-05`\n从而在bootimg_hdr不支持识别date 信息的情况下, 可以在reocovery模式下bootloader能够读到天的信息, 并传给KM TA.\n\n## 新问题\n\n最近测试在复测该问题时, 发现手机bootloader上锁状态下, 无法执行1217功能. 因此需要重新分析下这个问题的原因.\n\n## locked 状态下的调试\n\n### debug abl的方法\n\n#### locked状态下的限制\n\n首先, 小米机器locked 状态有如下限制:\n\n1. 不能使用fastboot烧录新的img, 即fastboot flash  <partition.img> 是不被允许的\n2. 不能使用fastboot erase 分区, 像`fastboot erase misc` 无法执行\n3. locked状态切到unlocked状态, unlocked状态切到locked状态, 都会reboot 进recovery, 清除数据.\n\n\n\n上述限制或功能必须被禁用掉, 因为调试这个问题时, 本地打的调试(带logcat 和 adb shell)功能的在locked状态肯定会报`system has destroyed`, 其次经常需要debug abl, 烧分区的限制肯定要禁用掉, 不然每次烧录新的abl 都需要使用9008模式烧机, 非常麻烦. locked 切 unlocked状态, 或反之的情况清除数据的功能肯定要拿掉, 因为1217测的就是解主系统加密过的userdata分区, 如果在切换过程中把userdata擦了, 那就破坏了测试的前提. 第二条清misc也是必须的, 因为recovery如果无法正常启动, 出现`system has destroyed`, 可以通过清misc, 启动到主系统把recovery恢复回来.\n\n#### change\n\n去除locked状态下对fastboot flash / fastboot erase 和 切换locked unlocked 对userdata数据的操作\n\n[http://gerrit.bsp.xiaomi.srv/#/c/22341/](http://gerrit.bsp.xiaomi.srv/#/c/22341/)\n\n### locked状态下让avb校验失败的recovery成功启动起来\n\n> 注意不能修改avb校验完的状态, 保持最小变量原则\n\n\n\n#### change\n\n即将导向`system has destroyed`的入口破坏掉\n\n[http://gerrit.bsp.xiaomi.srv/22334](http://gerrit.bsp.xiaomi.srv/22334)\n\n#### 本地recovery调试1217的方法\n\n本地编译userdebug版本的recovery即可.\n\n1. 将上述change合入后, 编译abl, make aboot或者使用ninja, 注意最后abl一定要通过secureboot签名\n2. locked上锁状态可以先使用解锁工具解锁, 再通过fastboot flash abl abl.elf 烧录locked 状态修改过的abl, 然后再使用fastboot oem lock上锁.\n3. 上锁完后, fastboot flash recovery 本地的recovery.img.\n4. fastboot reboot recovery\n5. 使用下面的命令, 查看df -h的结果中是否有userdata, vold的输出的log是什么, 如果begin操作报错, 说明keymaster 返回了错误\n\n\n\n```shell\nadb root; adb shell mv /system/bin/recovery  /tmp/; adb shell touch /system/bin/recovery; adb shell /tmp/recovery --factory_test_reset&; sleep 6; adb shell df -h; adb logcat -s vold;\n```\n\n## 问题分析\n\n通过之前修改recovery 打包写入avb prop的方法已经可以使recovery在unlocked模式下1217正常工作. 而locked状态下却不行. 变量只有一个就是locked状态和unlocked状态.\n\n先根据log定位下初步原因, 测试开始提供的log中只有recovery打出的部分信息:\n\nrecovery 重启, reason= fs_mgr_mount_all\n\n根据串口log的信息, 首先可以判定是如下情形:\n\n1. 主系统bcb (reason --factory_test_reset) ->2.  recovery启动(模式为1217)-> 3. recovery重启(模式变为fs_mgr_mount_all)\n\n\n\n在第2步1217的执行步骤中触发了 RebootRecovery(fs_mgr_mount_all)的命令, 查看代码, 最终定位到\n\n`mount_all miui_factoryreset.fstab --late`时 init 在执行`vdc mountFstab /dev/block/bootdevice/by-name/userdata /data`失败后执行了上述命令, 所以需要进一步的log判断为什么这个vdc 的操作失败了.\n\n根据前面debug locked 状态下recovery的方法, 最终可以在locked状态下启动本地带调试版本的recovery\n\n得到的log如下:\n\n```shell\n01-01 01:10:19.148   630   630 D vold    : metadata_key_dir/key: /metadata/vold/metadata_encryption/key\n01-01 01:10:19.149   630   630 I vold    : List of Keymaster HALs found:\n01-01 01:10:19.149   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.150   630   630 D vold    : Computing HMAC with params { (seed: 54483455460602eb1254138a502eea6249c665fd8feebff883464d797d9f, nonce: 3f7f4c10a7eaf94e91f869e10f3f1ca1d576596d8291933b9c5305dfd90) }\n01-01 01:10:19.150   630   630 D vold    : Computing HMAC for Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.152   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.154   630   630 D vold    : Key exists, using: /metadata/vold/metadata_encryption/key\n01-01 01:10:19.156   630   630 I vold    : List of Keymaster HALs found:\n01-01 01:10:19.156   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.156   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: Begin send cmd failed\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: ret: 0\n01-01 01:10:19.161   637   637 E KeyMasterHalDevice: resp->status: -33\n01-01 01:10:19.161   630   630 E vold    : begin failed, code -33\n01-01 01:10:19.148     0     0 D vdc     : Waited 0ms for vold\n01-01 01:10:19.161     0     0 E vdc     : Command: cryptfs mountFstab /dev/block/bootdevice/by-name/userdata /data Failed: Status(-8, EX_SERVICE_SPECIFIC): '0: '\n```\n\nkeymaster返回-33的错误导致了这样的表现.\n\n根据之前对abl的分析, 这个大概率与abl传给KM TA的参数有关.\n\n搜索代码, 最终定位到\n\n1. \n\n```c\n  /* Set Boot State */\n  BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;\n  BootStateReq.Version = 0;\n  BootStateReq.Size = sizeof (BootStateReq.BootState);\n  BootStateReq.Offset =\n      (UINT8 *)&BootStateReq.BootState - (UINT8 *)&BootStateReq;\n  BootStateReq.BootState.Color = BootState->Color;\n  BootStateReq.BootState.IsUnlocked = BootState->IsUnlocked;\n  BootStateReq.BootState.SystemSecurityLevel = BootState->SystemSecurityLevel;\n  BootStateReq.BootState.SystemVersion = BootState->SystemVersion;\n  CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,\n           AVB_SHA256_DIGEST_SIZE);\n\n  DEBUG ((EFI_D_ERROR, \"KeyMasterStartApp: bootstate digest: \"\n                         \"%s\\n\", BootStateDigest));\n\n  Status = Handle.QseeComProtocol->QseecomSendCmd (\n      Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&BootStateReq,\n      sizeof (BootStateReq), (UINT8 *)&BootStateRsp, sizeof (BootStateRsp));\n```\n\ndebug分析这一过程发现locked状态下, 只有color是orange时可以让recovery在调用keymaster begin解密经主系统加密的userdata时可以正常返回.\n\n而如果userdata没有通过主系统的加密, 即在recovery下先恢复出厂设置, 再对userdata加密时, color是green情况下, 也可以正常调用keymaster,没有返回错误, 而在recovery下加密userdata完成后, 再启动到主系统, 主系统会报fs_mgr_mount_all的错误.\n\n通过上述现象, 可以推测 加密userdata相当于上层keymaster初始化, 使用当时的环境去加密的数据, 而换了环境之后, 再去解密, 由于环境的变化, 导致keymaster无法校验成功, 所以begin返回了invalid blob(-33), 而这个`环境`是什么, 通过分析BootState的字段在recovery和主系统下的区别, 只有`BootStateDigest`是值得怀疑的.\n\n## BootStateDigest即UserData->PublicKey的分析\n\n上一步怀疑这个字段有问题后, 需要分析recovery模式和主系统下这个字段的数据来源.\n\n最终发现新基线升级后, recovery的avb校验模式变成了只校验recovery分区自己, 而主系统是校验 vbmeta boot dtbo vbmeta_system. 而主系统这个字段最终来自vbmeta分区的public key. 而recovery的这个字段并没有赋值.\n\nrecovery模式:\n\n```c\n  if ( ( (!Info->MultiSlotBoot) ||\n           IsDynamicPartitionSupport ()) &&\n           (Info->BootIntoRecovery &&\n           !IsBuildUseRecoveryAsBoot ())) {\n      // 非ab机型\n    if (!Info->MultiSlotBoot) {\n        DEBUG ((EFI_D_ERROR, \"flag AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION\\n\"));\n        VerifyFlags = VerifyFlags | AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION;\n    }\n    // 只加载recovery分区\n    AddRequestedPartition (RequestedPartitionAll, IMG_RECOVERY);\n    NumRequestedPartition += 1;\n    Result = avb_slot_verify (Ops, (CONST CHAR8 *CONST *)RequestedPartition,\n               SlotSuffix, VerifyFlags, VerityFlags, &SlotData);\n      ...\n  }\n```\n\n## 问题解决\n\n上面怀疑recovery模式和主系统下abl传给KM TA的摘要是不同的, 那可以想到将vbmeta的public key 填充到 UserData->PublicKey, 下发给KM TA 是否可以解决locked状态下recovery无法使用keymaster解密经主系统加密的数据.\n\n方案如下:\n\n[http://gerrit.bsp.xiaomi.srv/#/c/22338/](http://gerrit.bsp.xiaomi.srv/#/c/22338/)\n\n只有非ab机型进入recovery情况下, 即`AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION` flag的作用范围内, 在avb verify完recovery分区后, 再avb verify下vbmeta分区, 目的是为了让其覆盖`ops->user_data`段, 而传进`load_and_verify_vbmeta`的参数需要重新设定, 因为原先的参数很多都是全局或影响avb verify recovery结果的指针, 我们这里只能覆盖`ops->user_data`段, 不能对其他段产生影响. 同时还需要对flag 重新置位, 绕开vbmeta相关的检查, 使得可以成功load vbmeta的public key, 并将其赋给`ops->user_data`段.\n\n```c\ntypedef struct {\n    BOOLEAN IsUserKey;\n    BOOLEAN IsMultiSlot;\n    UINTN PublicKeyLen;\n    CHAR8 PublicKey[MAX_USER_KEY_SIZE];\n} AvbOpsUserData;\n```\n\n重新测试后, 上述patch有效, locked下recovery中可以正常进行1217功能.\n\n### 验证\n\n1. locked状态下, 主系统开机后, 执行1217, 正常reboot到recovery中进行清数据的操作, 重启回主系统下, /data/miui/app下内容保留\n2. locked状态下, fastboot flash 本地编的recovery, fastboot reboot recovery后, 应该报`system has destroyed`\n3. unlocked 状态下, 无论是本地编的recovery还是线刷包版本的recovery, 都可以正常进行1217功能\n\n> 验证时, unlocked状态切换到locked状态, 或反之的情况, 切换过程中都需要进recovery wipe data, 擦完重新开机进主系统, 保证数据要重新经主系统初始化加密一次.\n\n","tags":["Android","FBE","1217"],"categories":["Android","加密"]},{"title":"Android 加密方案整理","url":"/2019/10/12/OTA相关/加密方案整理/","content":"\n# 1. 加密方案整理\n\n## 1.1. 简介\n\nAndroid上加密方案分为全磁盘加密(`FDE`)/文件加密(`FBE`)/元数据加密(`METADATA`)\n均是针对userdata分区进行加密, 与其他分区并无关系.\n本篇主要介绍下这三种加密方式硬件加密的实现框架\n\n## 1.2. 判断机器采用何种加密方式\n\n最直观的方式是可以通过分区表`fstab`来区分\n未加密/fde加密/fbe加密/metadata加密\n\n```shell\n/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,data=ordered,noauto_da_alloc     wait,check,encryptable=footer\n/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard latemount,wait,check,fileencryption=ice,wrappedkey,quota,reservedsize=128M\n/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard latemount,wait,check,fileencryption=ice,wrappedkey,keydirectory=/metadata/vold/metadata_encryption,quota,reservedsize=128M\n```\n\n当前版本中最常见的是fbe加密的机型.\n\n代码中判断是否加密:\n\n```java\nStorageManager.isEncrypted()\nStorageManager.isFileEncryptedNativeOnly()\nStorageManager.isBlockEncrypted()\n```\n\nnative 层多是通过FstabEntry来判断是何种加密方式\n\n```cpp\nstatic bool should_use_metadata_encryption(const FstabEntry& entry) {\n    return !entry.key_dir.empty() &&\n           (entry.fs_mgr_flags.file_encryption || entry.fs_mgr_flags.force_fde_or_fbe);\n}\n```\n\n硬件加密的启用, 其中fbe机型和metadata机型是用`fileencryption=ice`控制的(限于高通产品), 而fbe和metadata加密方式的不同是看`keydirectory=`是否为空\n\n## 1.3. 硬件加密实现策略\n\n首先跟着`fileencryption=ice`往下看\n\n```puml\n@startuml\nautoactivate on\ninit->vold: initUser0\nvold->vold: fscrypt_init_user0\nvold->vold: fscrypt_prepare_user_storage\nvold->vold: get_data_file_encryption_modes(&de_ref|&ce_ref);\nnote down: key_ref->contents_mode = entry->file_contents_mode;\nvold-->init: return init_user0\n@enduml\n```\n\n```puml\n@startuml\nautoactivate on\nStorageManagerService->vold: prepareUserStorage\nvold->vold: fscrypt_prepare_user_storage\nvold->vold: get_data_file_encryption_modes(&de_ref|&ce_ref);\nnote right: key_ref->contents_mode = entry->file_contents_mode;\nvold-->StorageManagerService: return prepareUserStorage\n@enduml\n```\n\n对于FBE方案来说, Android标准方案使用`ice`来控制是否是硬件加密\n\n[文件加密 android developer](https://source.android.com/security/encryption/file-based)\n[metadata加密 android developer](https://source.android.com/security/encryption/metadata)\n\n> 为了支持当前的元数据加密，您的硬件必须支持使用内嵌加密引擎进行文件级加密。fstab.hardware 中的用户数据分区的 `fileencryption=ice` 指令指明了这一点。\n\n> 通过将 fileencryption=contents_encryption_mode[:filenames_encryption_mode] 标记添加到 userdata 分区最后一列的 fstab 行中，可以启用 FBE。contents_encryption_mode 参数定义用于文件内容加密的算法，filenames_encryption_mode 参数定义用于文件名加密的算法。 contents_encryption_mode 只能是 aes-256-xts。 filenames_encryption_mode 有两个可能的值：aes-256-cts 和 aes-256-heh。如果未指定 filenames_encryption_mode，则使用 aes-256-cts 值。\n\n^61db89\n\n## 1.4. 硬件加密底层实现\n\n### 1.4.1. qcom实现\n\n先看下metadata加密, metadata加密方案相对FBE来说, 在fbe的基础上又对文件系统的元数据进行了加密\n\n```cpp\n#define DEFAULT_KEY_TARGET_TYPE \"default-key\"\n if (!read_key(*data_rec, needs_encrypt, &key)) return false;\n if (!get_number_of_sectors(data_rec->blk_device, &nr_sec)) return false;\n    if (!create_crypto_blk_dev(kDmNameUserdata, nr_sec, DEFAULT_KEY_TARGET_TYPE,\n                               default_key_params(blk_device, key), &crypto_blkdev))\n```\n\n上述创建dm设备时, 传入的tgt->target_type是`default-key`, 对应于device-mapper框架来说, 最终找到的插件实现是`dm-default-key.c`\n\n该层的代码在kernel md层\nkernel/msm-4.14/drivers/md/dm-default-key.c\n\n```c\nstatic struct target_type default_key_target = {\n    .name   = \"default-key\",\n    .version = {1, 0, 0},\n    .module = THIS_MODULE,\n    .ctr    = default_key_ctr,\n    .dtr    = default_key_dtr,\n    .map    = default_key_map,\n    .status = default_key_status,\n    .prepare_ioctl = default_key_prepare_ioctl,\n    .iterate_devices = default_key_iterate_devices,\n};\n```\n\n关于dm设备的转发, 这里不再详细分析. 感兴趣的可以再跟着流程看下.\n这里重点说下map函数, 在设置好dm规则后, 用户空间命令通过ioctl调用table_load函数，该函数根据用户空间传来的参数构建指定mapped device的映射表和所映射的target device。该函数先构建相应的dm_table、dm_target结构，再调用dm-table.c中的dm_table_add_target(populate_table--->dm_table_add_target)函数根据用户传入的参数初始化这些结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device对应的结构，然后再根据所建立的dm_target结构更新dm_table中维护的B树。上述过程完毕后，再将建立好的dm_table添加到mapped device的全局hash表对应的hash_cell结构中。\n\n设置io转发, 一个是通过dm create 时初始设置的`dm_wq_work`后台线程执行的\n\n```cpp\nioctl(dm_fd.get(), DM_DEV_CREATE, io)\ndev_create -> dm_create(minor, **result) -> alloc_dev(minor) ->\nINIT_WORK(&md->work, dm_wq_work);\n```\n\nwrite_back时, 调用queue_io, 或dm设备处于suspend时\n\n```cpp\nstatic void queue_io(struct mapped_device *md, struct bio *bio)\n{\n    unsigned long flags;\n\n    spin_lock_irqsave(&md->deferred_lock, flags);\n    bio_list_add(&md->deferred, bio);\n    spin_unlock_irqrestore(&md->deferred_lock, flags);\n    queue_work(md->wq, &md->work);\n}\n```\n\n还有一条路径是通过 `dm_setup_md_queue`\n\n```cpp\n    case DM_TYPE_BIO_BASED:\n    case DM_TYPE_DAX_BIO_BASED:\n        dm_init_normal_md_queue(md);\n        blk_queue_make_request(md->queue, dm_make_request);\ndm_make_request-> __dm_make_request(q, bio, __split_and_process_bio); -> __send_empty_flush | __split_and_process_non_flush \n-> __clone_and_map_data_bio | __send_duplicate_bios -> __map_bio\n```\n\n其中 `__split_and_process_bio`可以了解一下\n\n```cpp\n// mapped_device指向 映射的dm设备, map为映射规则\n// split a bio into clones and submit them to the targets\nstatic blk_qc_t __split_and_process_bio(struct mapped_device *md,\n                    struct dm_table *map, struct bio *bio)\n{\n    struct clone_info ci;\n    blk_qc_t ret = BLK_QC_T_NONE;\n    int error = 0;\n\n    blk_queue_split(md->queue, &bio);\n\n    init_clone_info(&ci, md, map, bio);\n\n    if (bio->bi_opf & REQ_PREFLUSH) {\n        ci.bio = &ci.io->md->flush_bio;\n        ci.sector_count = 0;\n        error = __send_empty_flush(&ci);\n        /* dec_pending submits any data associated with flush */\n    } else if (bio_op(bio) == REQ_OP_ZONE_RESET) {\n        ci.bio = bio;\n        ci.sector_count = 0;\n        error = __split_and_process_non_flush(&ci);\n    } else {\n        ci.bio = bio;\n        ci.sector_count = bio_sectors(bio);\n        while (ci.sector_count && !error) {\n            error = __split_and_process_non_flush(&ci);\n            if (current->bio_list && ci.sector_count && !error) {\n                struct bio *b = bio_split(bio, bio_sectors(bio) - ci.sector_count,\n                              GFP_NOIO, &md->queue->bio_split);\n                ci.io->orig_bio = b;\n                bio_chain(b, bio);\n                ret = generic_make_request(bio);\n                break;\n            }\n        }\n    }\n    /* drop the extra reference count */\n    dec_pending(ci.io, errno_to_blk_status(error));\n    return ret;\n}\n\n/*\n * Select the correct strategy for processing a non-flush bio.\n */\nstatic int __split_and_process_non_flush(struct clone_info *ci)\n{\n    struct bio *bio = ci->bio;\n    struct dm_target *ti;\n    unsigned len;\n    int r;\n// 找到target_device\n    ti = dm_table_find_target(ci->map, ci->sector);\n    if (!dm_target_is_valid(ti))\n        return -EIO;\n\n    if (unlikely(__process_abnormal_io(ci, ti, &r)))\n        return r;\n\n    if (bio_op(bio) == REQ_OP_ZONE_REPORT)\n        len = ci->sector_count;\n    else\n        len = min_t(sector_t, max_io_len(ci->sector, ti),\n                ci->sector_count);\n\n    r = __clone_and_map_data_bio(ci, ti, ci->sector, &len);\n    if (r < 0)\n        return r;\n\n    ci->sector += len;\n    ci->sector_count -= len;\n\n    return 0;\n}\n\nstatic int __clone_and_map_data_bio(struct clone_info *ci, struct dm_target *ti,\n                    sector_t sector, unsigned *len)\n{\n    struct bio *bio = ci->bio;\n    struct dm_target_io *tio;\n    int r;\n\n    tio = alloc_tio(ci, ti, 0, GFP_NOIO);\n    tio->len_ptr = len;\n    r = clone_bio(tio, bio, sector, *len);\n    if (r < 0) {\n        free_tio(tio);\n        return r;\n    }\n    (void) __map_bio(tio);\n\n    return 0;\n}\n\nstatic blk_qc_t __map_bio(struct dm_target_io *tio)\n{\n    int r;\n    sector_t sector;\n    struct bio *clone = &tio->clone;\n    struct dm_io *io = tio->io;\n    struct mapped_device *md = io->md;\n    // 取出上面封装的target_device的结构体\n    struct dm_target *ti = tio->ti;\n    blk_qc_t ret = BLK_QC_T_NONE;\n\n    clone->bi_end_io = clone_endio;\n\n    /*\n     * Map the clone.  If r == 0 we don't need to do\n     * anything, the target has assumed ownership of\n     * this io.\n     */\n    atomic_inc(&io->io_count);\n    sector = clone->bi_iter.bi_sector;\n    // 调用插件的map函数. ti为dm_target, clone为复制的bio\n    r = ti->type->map(ti, clone);\n    switch (r) {\n    ...\n    // map正常执行的话, 返回DM_MAPIO_REMAPPED\n    case DM_MAPIO_REMAPPED:\n        /* the bio has been remapped so dispatch it */\n        trace_block_bio_remap(clone->bi_disk->queue, clone,\n                      bio_dev(io->orig_bio), sector);\n        if (md->type == DM_TYPE_NVME_BIO_BASED)\n            ret = direct_make_request(clone);\n        else\n            // 往下层转发\n            ret = generic_make_request(clone);\n        break;\n        ...\n    }\n\n    return ret;\n}\n```\n\n由上述调用, 最终起到封装bio的目的. 复制了一份bio到clone中, 找到dm-target的type(插件), 用其注册的map函数封装clone, clone为指针, map函数会修改其值.\n\n```cpp\n// ti封装的private为其初始化时填入的值\n// Construct a default-key mapping: <mode> <key> <dev_path> <start>\nstatic int default_key_ctr(struct dm_target *ti, unsigned int argc, char **argv) \n{\n    ti->private = dkc;\n    hex2bin(dkc->key.raw, argv[1], key_size);\n    // 根据传入的path 找到其 target_device, 就是往dkc的dev里填入 bdev, 最后ti->private准备完成\n    dm_get_device(ti, argv[2], dm_table_get_mode(ti->table),\n                &dkc->dev);\n    sscanf(argv[3], \"%llu%c\", &tmp, &dummy)\n    dkc->start = tmp;\n    // 必须支持硬件加密?\n    if (!blk_queue_inlinecrypt(bdev_get_queue(dkc->dev->bdev))) {\n        ti->error = \"Device does not support inline encryption\";\n        err = -EINVAL;\n        goto bad;\n    }\n\n}\nstatic int default_key_map(struct dm_target *ti, struct bio *bio)\n{\n    const struct default_key_c *dkc = ti->private;\n    // 设置clone的block_device(target_device), 最后通过generic_make_request 往下层转发\n    bio_set_dev(bio, dkc->dev->bdev);\n    if (bio_sectors(bio)) {\n        // bio来自于mapped_device需要根据映射关系转换成target_device的真实的扇区号\n        bio->bi_iter.bi_sector = dkc->start +\n            dm_target_offset(ti, bio->bi_iter.bi_sector);\n    }\n\n    if (!bio->bi_crypt_key && !bio->bi_crypt_skip)\n        // 最重要的信息, 为bio带上了密钥信息\n        bio->bi_crypt_key = &dkc->key;\n\n    return DM_MAPIO_REMAPPED;\n}\n```\n\n可见metadata加密使用dm设备的目的, 就是为bio加上密钥信息, 那这个密钥信息是在哪里用的呢, 而且`dm-default-key.c`里的实现里明确提示了需要硬件支持.\n\n```cpp\nstatic int default_key_iterate_devices(struct dm_target *ti,\n                       iterate_devices_callout_fn fn,\n                       void *data)\n{\n    struct default_key_c *dkc = ti->private;\n    // fn为queue_supports_inline_encryption函数, 所以最终是通过找到target_device查看是否支持硬件加密\n    return fn(ti, dkc->dev, dkc->start, ti->len, data);\n}\nstatic int queue_supports_inline_encryption(struct dm_target *ti,\n                        struct dm_dev *dev,\n                        sector_t start, sector_t len,\n                        void *data)\n{\n    struct request_queue *q = bdev_get_queue(dev->bdev);\n    return q && blk_queue_inlinecrypt(q);\n}\n// 是否支持硬件加密是在初始化时指定的, 绕到block层了  对应于emmc和ufs, 分别走的mmc framework和scsi架构\n// mmc core的实现  是在mmc_blk_alloc_req时做的\n    if (host->inlinecrypt_support)\n        queue_flag_set_unlocked(QUEUE_FLAG_INLINECRYPT, mq->queue);\n// scsi中的实现\n    if (shost->inlinecrypt_support)\n        queue_flag_set_unlocked(QUEUE_FLAG_INLINECRYPT, q);\n```\n\n所以上述硬件加密的信息应该是做在mmc框架层, 通过mmc框架与存储器件通信, 进行硬件加密\n\n### 1.4.2. scsi架构探寻\n\n#### 1.4.2.1. 软件架构\n\nLinux kernel的驱动框架有两个要点:\n\n- 抽象硬件（硬件架构是什么样子，驱动框架就应该是什么样子）。\n- 向“客户”提供使用该硬件的API（之前我们提到最多的客户是“用户空间的Application”，不过也有其它“客户”，例如内核空间的其它driver、其它framework）。\n\n先看kconfig\n\n```cpp\nconfig SCSI_UFSHCD\n    tristate \"Universal Flash Storage Controller Driver Core\"\n    depends on SCSI && SCSI_DMA\n    select PM_DEVFREQ\n    select DEVFREQ_GOV_SIMPLE_ONDEMAND\n    select NLS\n    ---help---\n    This selects the support for UFS devices in Linux, say Y and make\n      sure that you know the name of your UFS host adapter (the card\n      inside your computer that \"speaks\" the UFS protocol, also\n      called UFS Host Controller), because you will be asked for it.\n      The module will be called ufshcd.\n\n      To compile this driver as a module, choose M here and read\n      <file:Documentation/scsi/ufs.txt>.\n      However, do not compile this as a module if your root file system\n      (the one containing the directory /) is located on a UFS device.\n\nconfig SCSI_UFSHCD_PLATFORM\n    tristate \"Platform bus based UFS Controller support\"\n    depends on SCSI_UFSHCD\n    ---help---\n    This selects the UFS host controller support. Select this if\n    you have an UFS controller on Platform bus\n\nconfig CRYPTO_DEV_QCOM_ICE\n    tristate \"Inline Crypto Module\"\n    default n\n    depends on BLK_DEV_DM\n    help\n      This driver supports Inline Crypto Engine for QTI chipsets, MSM8994\n      and later, to accelerate crypto operations for storage needs.\n      To compile this driver as a module, choose M here: the\n      module will be called ice.\n\nconfig SCSI_UFS_QCOM\n    tristate \"QCOM specific hooks to UFS controller platform driver\"\n    depends on SCSI_UFSHCD_PLATFORM && ARCH_QCOM\n    select PHY_QCOM_UFS\n    select EXTCON\n    select EXTCON_STORAGE_CD_GPIO\n    help\n      This selects the QCOM specific additions to UFSHCD platform driver.\n      UFS host on QCOM needs some vendor specific configuration before\n      accessing the hardware which includes PHY configuration and vendor\n      specific registers.\n\n      Select this if you have UFS controller on QCOM chipset.\n      If unsure, say N.\n\nconfig SCSI_UFS_QCOM_ICE\n    bool \"QCOM specific hooks to Inline Crypto Engine for UFS driver\"\n    depends on SCSI_UFS_QCOM && CRYPTO_DEV_QCOM_ICE\n    help\n      This selects the QCOM specific additions to support Inline Crypto\n      Engine (ICE).\n      ICE accelerates the crypto operations and maintains the high UFS\n      performance.\n\n      Select this if you have ICE supported for UFS on QCOM chipset.\n      If unsure, say N.\n```\n\n```Makefile\nobj-$(CONFIG_ARCH_QCOM)            += pfe/\nobj-$(CONFIG_SCSI_UFSHCD) += ufshcd-core.o\nobj-$(CONFIG_SCSI_UFSHCD_PLATFORM) += ufshcd-pltfrm.o\nobj-$(CONFIG_CRYPTO_DEV_QCOM_ICE) += ice.o\nobj-$(CONFIG_SCSI_UFS_QCOM_ICE) += ufs-qcom-ice.o\nobj-$(CONFIG_SCSI_UFS_QCOM) += ufs-qcom.o\n```\n\n从上述的依赖条件看, 主要是涉及到`ufs-qcom.c` 和  `ufs-qcom-ice.c`文件的分析\n\nplatform driver 是什么？\n一个现实的Linux设备和驱动通常挂接在一种总线上，对于本身依附于PCI、USB、I2C、SPI等的设备而言，这自然不是问题，但是在`嵌入式系统`里面，SoC系统中`集成的独立的外设控制器`、挂接在`SoC内存空间的外设`等却不依附于此类总线。基于这个背景，Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform device,驱动称为platform driver。\n**注意**platform device并不是和字符设备，块设备和网络设备并列的概念，而是实现它们的一种方式。通过这种方式实现的就称为platform device。\n\nplatform 是一个虚拟的地址总线，相比 PCI、USB，它主要用于描述SOC上的片上资源。platform 所描述的资源有一个共同点：在CPU 的总线上直接取址。平台设备会分到一个名称（用在驱动绑定中）以及一系列诸如地址和中断请求号（IRQ）之类的资源。 ^39c29c\n\n[platform_driver开发](https://blog.csdn.net/yanhe156/article/details/79062868)\n\n```cpp\nstatic struct platform_driver ufs_qcom_pltform = {\n    .probe    = ufs_qcom_probe,\n    .remove    = ufs_qcom_remove,\n    .shutdown = ufshcd_pltfrm_shutdown,\n    .driver    = {\n        .name    = \"ufshcd-qcom\",\n        .pm    = &ufs_qcom_pm_ops,\n        // 从设备数获取  { .compatible = \"qcom,ufshc\"},\n        .of_match_table = of_match_ptr(ufs_qcom_of_match),\n    },\n};\nmodule_platform_driver(ufs_qcom_pltform);\n```\n\nplatform device的.prob函数中执行的是大致为四步：\n\n1. 申请设备号\n2. 实体设备(如果是字符设备，就是cdev)初始化注册，添加填充好的file_operation\n3. 从pdev读出硬件资源\n4. 对硬件资源初始化，ioremap() ,request_irq()等操作\n\nplatform device的.remove函数实现的是注销分配的各种资源。\n\ndriver的绑定是通过driver core自动完成的，完成driver和device的匹配后以后会自动执行`probe()`函数，如果函数执行成功，则driver和device就绑定在一起了，drvier和device匹配的方法有3种： ^a36448\n\n- 当一个设备注册的时候，他会在总线上寻找匹配的driver，platform device一般在系统启动很早的时候就注册了\n\n- 当一个驱动注册[platform_driver_register()]的时候，他会`遍历所有总线上的设备来寻找匹配`，在启动的过程驱动的注册一般比较晚，或者在模块载入的时候\n ^2bbbb2\n- 当一个驱动注册[platform_driver_probe()]的时候， 功能上和使用platform_driver_register()是一样的，唯一的区别是它不能被以后其他的device probe了，也就是说这个driver只能和一个device绑定。\n  \n  Platform device 和 Platform driver实际上是cpu总线可以直接寻址的设备和驱动，他们挂载在一个虚拟的总线platform_bus_type上，是一种bus-specific设备和驱动。与其他bus-specific驱动比如pci是一样的。他们都是将device和device_driver加了一个warpper产生，仔细看看platform_device就可以看到它必然包含一个device dev，而platform_driver也一样，它必然包含一个device_driver driver。\n  所有的设备通过bus_id挂在总线上，多个device可以共用一个driver，但是一个device不可以对应多个driver。驱动去注册时候会根据设备名寻找设备，没有设备会注册失败，注册的过程会通过probe来进行相应资源的申请，以及硬件的初始化，如果probe执行成功，则device和driver的绑定就成功了。设备注册的时候同样会在总线上寻找相应的驱动，如果找到他也会试图绑定，绑定的过程同样是执行probe。\n\n这里先带着问题看一下注册的过程:  (前面说到metadata加密必须支持硬件加密才可以)\n\n`shost->inlinecrypt_support`   这个赋值是哪来的呢?\n\n搜了下代码, 是在这里\n\n```cpp\nstatic int ufs_qcom_init(struct ufs_hba *hba) {\n// err为0, 即支持硬件加密\n    err = ufs_qcom_ice_get_dev(host);\n}\n```\n\n顺着ufs_qcom_init的初始化过程, 看下ufs_hba来自哪里\nufs_qcom_probe -> ufshcd_pltfrm_init(pdev, &ufs_hba_qcom_variant) -> ufshcd_alloc_host(dev, &hba) -> host = scsi_host_alloc(&ufshcd_driver_template, sizeof(struct ufs_hba));\n\n```cpp\nint ufshcd_alloc_host(struct device *dev, struct ufs_hba **hba_handle)\n{\n    struct Scsi_Host *host;\n    struct ufs_hba *hba;\n    int err = 0;\n    host = scsi_host_alloc(&ufshcd_driver_template,\n                sizeof(struct ufs_hba));\n    hba = shost_priv(host);\n    hba->host = host;\n    hba->dev = dev;\n    *hba_handle = hba;\n\n    INIT_LIST_HEAD(&hba->clk_list_head);\n}\n```\n\n这个调用直接跑到了scsi/hosts.c中的`scsi_host_alloc`函数中. register a scsi host adapter instance. 这个函数的作用就是分配host端.\n在scsi架构中,  系统初始化时会扫描platform总线，因此挂载其上的SCSI host adapter会被扫描到，并生成一个platform device。\n扫描软件会为该platform device加载相应的驱动程序。加载SCSI host驱动时，其探测函数会初始化SCSI host，注册中断处理函数，最后调用scsi_scan_host函数扫描scsi host adapter所管理的所有scsi总线。\n通常情况下，HBA驱动在系统中以模块形式加载。从而允许模块被卸载并重新加载，在该过程中SCSI扫描函数得以调用。通常，在卸载HBA驱动之前，SCSI设备的所有I/O都应该停止，卸载文件系统，多路径服务应用也需停止。如果有代理或HBA应用帮助模块，也应当中止。\n/proc文件系统提供了可用SCSI设备的列表。如果系统中SCSI设备重新配置，那么所有这些改变通过echo /proc接口反映到SCSI设备中。添加一个设备，主机，channel，target ID，以及磁盘设备的LUN编号会被添加到/proc/scsi/，需指定scsi编号。\n\n可见这里是将host纳入了scsi架构中, 后续只要访问到对应的host adapter, 可以通过host adapter与其匹配的driver进行通信.\n\n这里列举一个加密过程的路径:\nufshcd_resume->ufshcd_reset_and_restore->ufshcd_detect_device->ufshcd_host_reset_and_restore->ufshcd_complete_requests->ufshcd_transfer_req_compl->__ufshcd_transfer_req_compl->ufshcd_vops_crypto_engine_cfg_end\nufshcd_pltfrm_init->ufshcd_init->INIT_DELAYED_WORK(&hba->card_detect_work, ufshcd_card_detect_handler)->ufshcd_detect_device...\n\n![v2-33d57d1aac13ec6a4e7f917e0a47bb69_1200x500](images/20191204223850725_1481056787.jpg)\n![\"linux storage stack\"的图片搜索结果](http://www.sysnote.org/2015/08/06/linux-io-stack/io-stack.png)\n从之前的调度上看, 下发bio经过了device_mapper层, 通用块层即block层进行io调度, 使用各类调度算法合并bio到rq中, 最后下发bio到达scsi层, 在这一层有`single-queue layer`和`multi-queue layer`的区分.\n其中`single-queue layer`是使用的`scsi_request_fn`进行io下发的, 而支持`multi-queue layer`的则是通过`blk_mq_ops`结构实现了11个函数, 提供了支持超时，轮询完成，请求初始化的命令, 而io的下发是通过`queue_rq`函数执行.\n而ufs是支持`multi-queue layer`的, 这里可以大致了解下`mq_ops`的结构的使用过程\n\n[io流程](https://lwn.net/Articles/738449/)\n\n对于多队列结果, rq需要提前分配, 可以看下scsi_alloc_sdev函数, 这里涉及到一个`Disk Array Controller`,  gdth看起来是负责这块的.\n\n> A disk array controller is a device which manages the physical disk drives and presents them to the computer as logical units.\n\nThe disk array controller is made of up 3 important parts which play a key role in the controllers functioning and also show us indicators of storage I/O bottlenecks. These are:\n\nCPU that processes the data sent to the controller\nI/O port that includes:\n\n- Back-end interface to establish communication with the storage disks\n- Front-end interface to *communicate with a computer’s host adapter*\n- Software executed by the controller’s processor which also consumes the processor resources\n\n```c\nstatic int gdth_open(struct inode *inode, struct file *filep)\n{\n    gdth_ha_str *ha;\n    list_for_each_entry(ha, &gdth_instances, list) {\n        if (!ha->sdev)\n            ha->sdev = scsi_get_host_dev(ha->shost);\n    }\n    return 0;\n}\n```\n\n还有ufshcd_init过程, \nufshcd_pltfrm_init -> ufshcd_init -> async_schedule(ufshcd_async_scan, hba); -> ufshcd_async_scan -> ufshcd_probe_hba(hba); -> scsi_scan_host(hba->host); -> async_schedule(do_scan_async, data); -> do_scsi_scan_host -> scsi_scan_host_selected -> scsi_scan_channel -> __scsi_scan_target -> scsi_probe_and_add_lun -> sdev = scsi_alloc_sdev(starget, lun, hostdata); -> sdev->request_queue = scsi_mq_alloc_queue(sdev); | sdev->request_queue = scsi_old_alloc_queue(sdev);\n\n> 定义了 `CONFIG_SCSI_MQ_DEFAULT`才走多队列模式\n\n这里还是看单队列模式  sdev->request_queue = scsi_old_alloc_queue(sdev);\nscsi_old_alloc_queue中绑定了rq相关的处理函数.\n\n```cpp\nq->request_fn = scsi_request_fn;\n```\n\n读取一个文件的时候，陷入系统调用，先检查数据是否在缓存中，如果没有则触发一次读盘操作，然后等待磁盘上的数据被更新到缓存中。\n\n读取磁盘过程：调用文件系统层的readpages函数，使用各种文件系统层的get_block函数获取磁盘物理地址，存放到`bh`里(即`buffer_head`)，使用`bh`构造`bio`，然后`提交bio`(一般使用`submit_bio`函数将数据bio提交到`io的块设备层`)。函数`generic_make_request`转发bio，generic_make_request是一个循环，通过`generic_make_request`提交请求给I/O调度层，这个函数最后调用到`q->make_request_fn(q, bio)`，那么对于这个函数的调用就是I/O调度层的入口点(ps: Generic_make_request的执行上下文可能有两种，一种是用户上下文，另一种为pdflush.)\n\nq->make_request_fn调用的是`blk_queue_bio`函数(早期版本是__make_request)，在blk_init_allocated_queue里注册。blk_queue_bio函数是Linux提供的块设备请求处理函数，实现IO Schedule。在该函数中试图将转发过来的bio merge到一个已经存在的request中，如果可以合并，那么将新的bio请求挂载到一个已经存在request中。如果不能合并，那么分配一个新的request，然后将bio添加到其中。\n\nblk_queue_bio里分为plug和unplug机制，在plug下就直接把request存到plug list(例如dio就是依赖于plug机制)。unplug下就直接调用queue的`request_fn`方法把request提交给磁盘驱动进行真正的处理了。当然，我们现在使用的是unplug机制。\n\n然后`q->request_fn`调用queue队列的request_fn方法`scsi_request_fn`函数(我们这里选择sda，sdb之类scsi设备)，\n在scsi_request_fn函数中会扫描request队列，通过`blk_peek_request`(原先版本是：elv_next_request)函数从队列中获取一个request。在`blk_peek_request`函数中通过scsi总线层注册的q->prep_rq_fn（scsi层注册为`scsi_prep_fn``blk_queue_prep_rq(q, scsi_prep_fn);`）函数将具体的request转换成scsi驱动所能认识的*scsi command*。获取一个request之后，scsi_request_fn函数直接调用`scsi_dispatch_cmd`函数将scsi command发送给一个具体的scsi host。\n\n到这一步，在scsi_dispatch_cmd函数中，通过scsi host的接口方法`queuecommand`(`.queuecommand= ufshcd_queuecommand`,)将scsi command发送给scsi host。通常scsi host的queuecommand方法会将接收到的scsi command挂到自己维护的队列中，然后再启动DMA过程将scsi command中的`数据发送给具体的磁盘`。DMA完毕之后，DMA控制器中断CPU，告诉CPU DMA过程结束，并且在中断上下文中设置DMA结束的中断下半部。DMA中断服务程序返回之后触发软中断，执行SCSI中断下半部。\n\n在SCSi中断下半部中，调用scsi command结束的回调函数，这个函数往往为scsi_done，在scsi_done函数调用blk_complete_request函数结束请求request，每个请求维护了一个bio链，所以在结束请求过程中回调每个请求中的bio回调函数，结束具体的bio。Bio又有文件系统的buffer head生成，所以在结束bio时，回调buffer_head的回调处理函数bio->bi_end_io（注册为end_bio_bh_io_sync）。自此，由中断引发的一系列回调过程结束，总结一下回调过程如下：scsi_done->end_request->end_bio->end_bufferhead。\n\n那什么时候知道数据已经在缓存里了呢?\ndo_generic_file_read –> PageUptodate(page)即检查PG_uptodate标志位。\n\n注意点是上述`queuecommand ufshcd_queuecommand`下发磁盘时, qcom的硬件加密流程正处于这个位置, 而scsi中断下半部中, 在scsi done前, 触发了`ufshcd_vops_crypto_engine_cfg_end`\ndevm_request_irq(dev, irq, ufshcd_intr, IRQF_SHARED,\n                dev_name(dev), hba)->ufshcd_intr->ufshcd_sl_intr->ufshcd_transfer_req_compl->__ufshcd_transfer_req_compl->ufshcd_vops_crypto_engine_cfg_end\n\n```c\nerr = ufshcd_vops_crypto_engine_cfg_start(hba, tag);\nstatic inline int ufshcd_vops_crypto_engine_cfg_start(struct ufs_hba *hba,\n                        unsigned int task_tag)\n{\n    if (hba->var && hba->var->crypto_vops &&\n        hba->var->crypto_vops->crypto_engine_cfg_start)\n        return hba->var->crypto_vops->crypto_engine_cfg_start\n                (hba, task_tag);\n    return 0;\n}\nqcom_host->ice.vops->config_start(qcom_host->ice.pdev, req, &ice_set, true)\n// qcom硬件加密的方案全在这个函数中\nstatic int qcom_ice_config_start(struct platform_device *pdev,\n        struct request *req,\n        struct ice_data_setting *setting, bool async)\n{\n    struct ice_crypto_setting pfk_crypto_data = {0};\n    struct ice_crypto_setting ice_data = {0};\n    int ret = 0;\n    bool is_pfe = false;\n    unsigned long sec_end = 0;\n    sector_t data_size;\n    struct ice_device *ice_dev;\n\n    ice_dev = platform_get_drvdata(pdev);\n    /*\n     * It is not an error to have a request with no  bio\n     * Such requests must bypass ICE. So first set bypass and then\n     * return if bio is not available in request\n     */\n    if (setting) {\n        setting->encr_bypass = true;\n        setting->decr_bypass = true;\n    }\n    // 判断是否是pfe模式, fbe加密和metadata加密的实现都是pfe的.\n    ret = pfk_load_key_start(req->bio, ice_dev, &pfk_crypto_data,\n            &is_pfe, async);\n    if (is_pfe) {\n        if (ret) {\n            if (ret != -EBUSY && ret != -EAGAIN)\n                pr_err(\"%s error %d while configuring ice key for PFE\\n\",\n                        __func__, ret);\n            return ret;\n        }\n\n        return qti_ice_setting_config(req, ice_dev,\n                &pfk_crypto_data, setting, ICE_CRYPTO_CXT_FBE);\n    }\n    // 是否是fde模式且是userdata分区\n    if (ice_fde_flag && req->part && req->part->info\n                && req->part->info->volname[0]) {\n        if (!strcmp(req->part->info->volname, \"userdata\")) {\n            sec_end = req->part->start_sect + req->part->nr_sects -\n                    QCOM_UD_FOOTER_SECS;\n            if ((req->__sector >= req->part->start_sect) &&\n                (req->__sector < sec_end)) {\n                data_size = req->__data_len /\n                        QCOM_SECT_LEN_IN_BYTE;\n\n                if ((req->__sector + data_size) > sec_end)\n                    return 0;\n                else\n                    return qti_ice_setting_config(req,\n                        ice_dev, &ice_data, setting,\n                        ICE_CRYPTO_CXT_FDE);\n            }\n        }\n    }\n\n    return 0;\n}\n\nint pfk_load_key_start(const struct bio *bio, struct ice_device *ice_dev,\n        struct ice_crypto_setting *ice_setting, bool *is_pfe,\n        bool async)\n{\n    int ret = 0;\n    struct pfk_key_info key_info = {NULL, NULL, 0, 0};\n    enum ice_cryto_algo_mode algo_mode = ICE_CRYPTO_ALGO_MODE_AES_XTS;\n    enum ice_crpto_key_size key_size_type = 0;\n    unsigned int data_unit = 1 << ICE_CRYPTO_DATA_UNIT_512_B;\n    u32 key_index = 0;\n\n    /*\n     * only a few errors below can indicate that\n     * this function was not invoked within PFE context,\n     * otherwise we will consider it PFE\n     */\n    // is_pfe默认为true\n    *is_pfe = true;\n\n    if (!pfk_is_ready())\n        return -ENODEV;\n\n   // 从bio中获取key的信息\n\n    ret = pfk_get_key_for_bio(bio, &key_info, &algo_mode, is_pfe,\n                    &data_unit);\n\n    if (ret != 0)\n        return ret;\n\n    ret = pfk_key_size_to_key_type(key_info.key_size, &key_size_type);\n    if (ret != 0)\n        return ret;\n\n    ret = pfk_kc_load_key_start(key_info.key, key_info.key_size,\n            key_info.salt, key_info.salt_size, &key_index, async,\n            data_unit, ice_dev);\n\n    ice_setting->key_size = key_size_type;\n    ice_setting->algo_mode = algo_mode;\n    /* hardcoded for now */\n    ice_setting->key_mode = ICE_CRYPTO_USE_LUT_SW_KEY;\n    ice_setting->key_index = key_index;\n\n    return 0;\n}\n\nstatic int pfk_get_key_for_bio(const struct bio *bio,\n        struct pfk_key_info *key_info,\n        enum ice_cryto_algo_mode *algo_mode,\n        bool *is_pfe, unsigned int *data_unit)\n{\n    const struct inode *inode;\n    enum pfe_type which_pfe;\n    const struct blk_encryption_key *key = NULL;\n    char *s_type = NULL;\n\n    // 从bio中获取inode信息\n    inode = pfk_bio_get_inode(bio);\n    which_pfe = pfk_get_pfe_type(inode);\n    // 判断inode文件系统类型\n    s_type = (char *)pfk_kc_get_storage_type();\n\n    /*\n     * Update dun based on storage type.\n     * 512 byte dun - For ext4 emmc\n     * 4K dun - For ext4 ufs, f2fs ufs and f2fs emmc\n     */\n\n    if (data_unit) {\n        if (!bio_dun(bio) && !memcmp(s_type, \"sdcc\", strlen(\"sdcc\")))\n            *data_unit = 1 << ICE_CRYPTO_DATA_UNIT_512_B;\n        else\n            *data_unit = 1 << ICE_CRYPTO_DATA_UNIT_4_KB;\n    }\n\n// 对于metadata元数据信息来说, 并没有inode信息, 所以which_pfe是INVAILD_PFE.\n    if (which_pfe != INVALID_PFE) {\n        /* Encrypted file; override ->bi_crypt_key */\n        pr_debug(\"parsing inode %lu with PFE type %d\\n\",\n             inode->i_ino, which_pfe);\n        return (*(pfk_parse_inode_ftable[which_pfe]))\n                (bio, inode, key_info, algo_mode, is_pfe);\n    }\n\n    /*\n     * bio is not for an encrypted file.  Use ->bi_crypt_key if it was set.\n     * Otherwise, don't encrypt/decrypt the bio.\n     */\n// metadata加密继续走这里, 这个bio是dm-default-key转发过来的, 所以是带有bi_crypt_key信息的, 能找到key, is_pfe即为true\n#ifdef CONFIG_DM_DEFAULT_KEY\n    key = bio->bi_crypt_key;\n#endif\n    if (!key) {\n        *is_pfe = false;\n        return -EINVAL;\n    }\n\n    key_info->key = &key->raw[0];\n    key_info->key_size = PFK_SUPPORTED_KEY_SIZE;\n    key_info->salt = &key->raw[PFK_SUPPORTED_KEY_SIZE];\n    key_info->salt_size = PFK_SUPPORTED_SALT_SIZE;\n    if (algo_mode)\n        *algo_mode = ICE_CRYPTO_ALGO_MODE_AES_XTS;\n    return 0;\n}\n```\n\n### 1.4.3. 总结\n\nqcom的硬件加密方案是按照google 规范写的, 先在fstab的userdata的表里加入了fileencryption=ice, 文件系统判断是硬件加密方案不再对page cache做额外的加解密处理.\n而metadata加密方案通过dm-default-key的插件在文件系统层下为元数据的bio挂上了加密密钥信息,而非文件系统元数据对应的目录或文件的inode(以及data block)则使用ensure_policy时对目录层级采用的加密策略.\n保证了me加密方案不会对元数据或文件inode单独的加密要求, 而在通用块层之下的scsi架构中插桩, 通用块层请求下来后, bio merge到requeset后, 对request下发到ufs device之前(queuecommand时)由scsi host adapter为request挂上了加密信息, 而加密信息来自于文件系统inode或元数据挂上的密钥信息. 保证了再下发到device后, 通过硬件器件对request进行加解密.\n\nLinux scsi设备读写流程：\nhttp://blog.chinaunix.net/uid-29634482-id-5127267.html\n块设备读写流程：\nhttp://blog.chinaunix.net/uid-25052030- id-58337.html\nusb驱动学习笔记：\nhttp://blog.chinaunix.net/uid-25627207-id-3341609.html\nplug/unplug机制：\nhttp://blog.chinaunix.net/xmlrpc.php?r= blog/article&uid=14528823&id=4778396\n\n[Linux SCSI回调IO的分析](https://www.cnblogs.com/cherishui/p/3878678.html)\n\n![scsi驱动](images/20191205212746016_750728522.png)\n![scsi三层驱动模型](images/20191205212906116_454506309.png)\n在scsi middle level定义了scsi device的数据结构，用于描述一个scsi的具体功能单元，其在scsi host中通过channel、id、lun进行寻址。\n　　在scsi host中可以存在多个channel，每个channel是一条完整的scsi总线，在scsi总线上可以连接多个scsi节点，每个节点采用id进行编号，编号的大小与具体的scsi specification相关，与总线层的驱动能力等因素相关。每个节点可以根据功能划分成多个lun，每个lun才是我们通常所说的scsi设备。\n　　![channel lun](images/20191205213052693_1193147772.png)\n　　scsi host的语义很清晰，其描述了一个scsi总线控制器。在很多实际的系统中，scsi host为一块基于PCI总线的HBA或者为一个SCSI控制器芯片。每个scsi host可以存在多个channel，一个channel实际扩展了一条SCSI总线。每个channel可以连接多个scsi节点，具体连接的数量与scsi总线带载能力有关.\n　　在scsi总线probe的过程中，scsi middle level会为每个lun抽象成scsi device，实现的核心函数为scsi_probe_and_add_lun()\n　　scsi target对scsi总线上的scsi 节点进行了抽象。每个scsi target可能拥有多个lun，即多个scsi devie\n　　\n\n#### 1.4.3.1. low-level接口方法——scsi_host_template\n\n　　scsi middle level通过scsi_host_template接口调用scsi host的具体方法。在scsi host driver向middle level注册host对象的同时需要注册scsi_host_template方法，该方法被注册到scsi host对象中。\n　　scsi middle level层提供了scsi host扫描函数，在设备枚举过程中scsi host可以调用该函数对scsi总线适配器进行扫描，当然host驱动也可以调用更加底层的函数对scsi总线进行扫描。scsi_scsn_host函数实现流程如下：\n　　![扫描channel](images/20191205213731280_1559005815.png)\n\nscsi host作为 platform 设备会被platform总线驱动层扫描到，扫描到scsi host之后，操作系统开始加载scsi host的驱动，scsi host driver就是上面说所的low level driver。scsi host driver初始化scsi控制器， 分配硬件资源，注册中断服务。最后开始扫描通过scsi控制器扩展出来的下一级总线——scsi bus。\n　　scsi bus的扫描通过scsi middle level提供的服务完成。scsi host driver可以调用scsi middle level提供的扫描算法完成scsi总线设备的扫描\n在scsi总线扫描过程中用到了scsi middle level层的如下重要函数：\n　　1、scsi_scan_host：对scsi host设备进行扫描。\n       2、scsi_add_device：探测具体的device，并且将其加入系统。 \n　　3、scsi_probe_and_add_lun：探测具体指定的lun，并且将其加入系统。\n　　4、scsi_probe_lun：采用INQUIRY命令对lun节点进行探测。\n　　5、scsi_add_lun：加入lun节点并且初始化SCSI设备。\n　　scsi总线scan过程中的函数调用情况如下图所示：\n　　![scsi扫描过程](images/20191205214309678_1411751880.png)\n\n## 1.5. scsi设备读写过程\n\n在此给出一个scsi设备的读写数据流程，通过该例子，读者可以方便查找Linux\n源代码，并且能够理清繁杂的代码结构。假设读写的scsi设备为scsi disk设备，数据首先通过文件系统，进入到文件系统的Cache。文件系统的pdflush daemon会将Cache住的数据刷新到磁盘，其根据buffer head的内容构造bio，然后调用块设备接口（submit_bio）将请求发送给块设备层。bio在块设备层多次转发，最后被merge到块设备的请求队列中。请求可能会在请求队列滞留一段时间，然后在软中断或者用户上下文中调用request_fn去处理请求队列。在scsi middle level驱动层，块设备的请求被转换成scsi command，然后通过queuecommand函数接口将scsi command提交给scsi host，通常scsi host会发起DMA操作将数据传输给具体的设备。至此，数据从应用程序转移到了scsi设备，当然上述过程还没有涉及到回调过程，实际的回调会在中断上下文、软中断上下文中完成，在请求发送的每一层都保存了相应的回调上下文。整个数据流的过程中，涉及到的函数如下：\n![读写过程](images/20191205214506707_1559031982.png)\n对scsi总线层有个提纲挈领的效果。在分析scsi middle level的过程中，有如下几点感想：\n　　1、  scsi驱动采用了规范的分层设计思想，其一共分为三层，分层之后使得设计分工更加明确，而且在逻辑上也更加清晰，设计工作也更加简单。\n　　2、  scsi驱动中比较固定的层次为scsi middle level，该层可以称之为scsi通用中间层，或者为总线驱动层。该层向上和向下都需要提供接口，所以上层驱动开发时需要注册相关接口函数，下层驱动工作时也需要注册接口函数，只有这样中间层才可以很灵活的进行上下层数据传输。\n　　scsi middle level主要实现了scsi总线扫描算法，scsi命令转换算法，scsi出错处理等机制，这些东西都是scsi的核心所在。\n\n### 1.5.1. card层\n\n设备接口层:\n     提供scsi设备的使用接口\n     scsi/sd.c:            \n        实现scsi硬盘接口，通过硬盘注册接口，将scsi硬盘注册到块设备系统，使得系统可以通过通用块设备接口来使用scsi硬盘，在scsi/sd.c里面实现。\n\nscsi host driver在初始化时，会调用scsi_scan_host来扫描host。扫描整个host以为着扫描host所对应的channel,target和lun。因此，它分别调用scsi_scan_channel，__scsi_scan_target，scsi_probe_and_add_lun来每个target及其lun。其中，在scsi_probe_and_add_lun中会分配代表每个lun即scsi设备的scsi_device结构:\n scsi_scan_host->do_scsi_scan_host->scsi_scan_host_selected->scsi_scan_channel->__scsi_scan_target->scsi_probe_and_add_lun:\nsdev = scsi_alloc_sdev(starget, lun, hostdata);\nscsi_scan_host->do_scsi_scan_host->scsi_scan_host_selected->scsi_scan_channel->__scsi_scan_target->scsi_probe_and_add_lun->scsi_probe_lun\n\n分配好scsi_device结构以后，调用scsi_probe_lun来发送`INQUIRY`命令，探测制定的lun。scsi设备返回的`inquiry data`将保存在result参数中，以备scsi_add_lun使用。其中包括了设备的信息，包括设备的种类type等。\nscsi_scan_host->do_scsi_scan_host->scsi_scan_host_selected->scsi_scan_channel->__scsi_scan_target->scsi_probe_and_add_lun->scsi_add_lun\n如果scsi_probe_lun成功，则调用scsi_add_lun来添加lun。在scsi_add_lun中，先根据inquiry data来初始化scsi_device中的一些属性，包括其type属性（在这儿为TYPE_DISK）。\nscsi_scan_host->do_scsi_scan_host->scsi_scan_host_selected->scsi_scan_channel->__scsi_scan_target->scsi_probe_and_add_lun->scsi_add_lun->`scsi_sysfs_add_sdev`\n\n之后调用scsi_sysfs_add_sdev来添加scsi_device。这儿与device_driver的注册类似，调用device_attach来对扫描bus上所有的driver，调用这些driver的probe方法来探测自身的device。如果此时，sd没有初始话，即bus上没有相应的驱动，则不会调用probe方法。即不会生成lun对应的gend。并且，sd_probe中，会检测scsi_device的具体类型，只有自己支持的才回去探测。\n\n通过上述两个过程，device_driver和device联系在了一起。总之，对于每个lun的加入，sd_probe都会执行一次。只不过sd_probe的触发，要么是通过sd驱动`scsi_register_driver`，要么是通过LLD `scsi_scan_host`。\nsd_probe调用栈（由scsi_scan_host触发）：\n\n```shell\n#0 sd_probe (dev=0xc714a4b0) at drivers/scsi/sd.c:1597\n#1 0xc018df10 in driver_probe_device (drv=0xc0335df8, dev=0xc714a4b0) at drivers/base/dd.c:121\n#2 0xc018dfd8 in __device_attach (drv=0xc714a4b0, data=0x0) at drivers/base/dd.c:207\n#3 0xc018d110 in bus_for_each_drv (bus=, start=, data=0x0, fn=0xc018dfc8 <__device_attach>) at drivers/base/bus.c:349\n#4 0xc018e078 in device_attach (dev=0x1) at drivers/base/dd.c:238\n#5 0xc018d070 in bus_attach_device (dev=0xc714a4b0) at drivers/base/bus.c:492\n#6 0xc018be64 in device_add (dev=0xc714a4b0) at drivers/base/core.c:781\n#7 0xc019fc84 in scsi_sysfs_add_sdev (sdev=0xc714a400) at drivers/scsi/scsi_sysfs.c:783\n#8 0xc019d9b8 in scsi_probe_and_add_lun (starget=0xc76d9000, lun=, bflagsp=, sdevp=0x0, rescan=0, hostdata=0x0) at drivers/scsi/scsi_scan.c:914\n#9 0xc019e088 in __scsi_scan_target (parent=0xc715e8d8, channel=0, id=0, lun=4294967295, rescan=0) at drivers/scsi/scsi_scan.c:1550\n#10 0xc019e538 in scsi_scan_channel (shost=0xc715e800, channel=0, id=0, lun=4294967295, rescan=0) at drivers/scsi/scsi_scan.c:1626\n#11 0xc019e608 in scsi_scan_host_selected (shost=0xc714a4b0, channel=1, id=1, lun=3222995532, rescan=0) at drivers/scsi/scsi_scan.c:1654\n#12 0xc019e6e8 in do_scsi_scan_host (shost=0xc715e800) ---Type to continue, or q to quit--- at drivers/scsi/scsi_scan.c:1786\n#13 0xc019eb50 in scsi_scan_host (shost=0xc715e800) at drivers/scsi/scsi_scan.c:1813\n```\n\nUL初始化时准备device_driver结构，其中包括probe方法。而LLD（准确地说，应该是middle layer）准备device结构。二者都把其bus初始化为scsi_bus_type，并挂入该总线。之后，如果是UL初始化，则调用自身的probe方法，去探测bus上的所有device，从而把device_driver绑定倒device。而如果是LLD初始化，则调用bus上所有的device_driver的probe方法来探测自身的device。因此，无论是UL先初始化还是LLD先初始化，二者都能取得联系。\n\n这里推荐一个博客, 里面有关于scsi里许多流程的介绍\n[scsi介绍多篇](http://chinaunix.net/uid/709830/list/1.html?cid=36085)\n\n## 1.6. 对总线的理解\n\n![pc桥](images/20191206200431808_1301015981.jpg)\n所谓的桥，就是Bridge，桥接的意思。以前的老式电脑中，CPU是通过南桥和北桥连接其它设备的。其中北桥连接高速设备和南桥，南桥连接低速设备。\n例如：\nCPU——北桥——内存\nCPU——北桥——显卡\nCPU——北桥——南桥——硬盘\nCPU——北桥——南桥——网卡\nCPU——北桥——南桥——PS/2键鼠\nCPU——北桥——南桥——USB设备\nIntel从SandyBridge开始，CPU整合内存控制器和PCI-E控制器、DMI通道，相当于是把原来北桥的功能集成在CPU内部了，北桥自然就消失了。南桥换了个称呼叫`IO Hub`\n\n### 1.6.1. ARM SOC上 总线协议\n\n[AMBA总线](https://www.cnblogs.com/feipeng8848/p/8484367.html)\n\n AHB总线的强大之处在于它可以将微控制器（CPU）、高带宽的片上RAM、高带宽的外部存储器接口、DMA总线master、各种拥有AHB接口的控制器等等连接起来构成一个独立的完整的SOC系统，不仅如此，还可以通过`AHB-APB桥`来连接APB总线系统。AHB可以成为一个完整独立的SOC芯片的骨架。\n ![AMBA](images/20191206203755941_65819257.png)\n\nAXI总线替代AHB APB总线\n![ufs 2.1](images/20191206213558324_298683154.png)\n\nThe IP for UFS 2.1 Host Controller allows for highlysecured applications by employing AES encryption. The data encryption and decryption is done seamlessly by the\ncontroller as data is written to or read from the UFS 2.1 device.\n\n高通平台上UFS是通过`AXI/AHB总线`连接到cpu的.\n\n回到platform driver上, 看高通的实现, ufs driver是注册在platform总线上的, 这个platform总线和AHB/AXI的关系应该怎样理解呢?\n\n这里引用一篇问答:\n\n链接：https://www.zhihu.com/question/33414159/answer/56558491\n\nbus上有driver和device，一个driver可以对应多个device，一个device只能有一个driver。比如pcie是一种总线，intel的82574网卡是一种pcie设备，e1000e.c 是网卡驱动。因为操作系统要支持外设，必须先要知道当前计算机有哪些设备，以及这些设备的访问方式、访问地址、中断号、中断触发方式等。这些资源信息假如写死在driver代码里，普通用户就无法DIY PC了。比如把硬盘换一个sata口，显卡换一个pcie插槽，控制这些设备的地址和中断就变了，用户就得自己改改驱动代码编译一下，没法玩嘛。这样就需要把当前计算机有哪些设备，以及这些设备的访问方式、访问地址、中断号、中断触发方式等 这些资源信息单独剥离出来，封进一个一个xxxx_device这样的结构体里。这样xxx_driver也更容易实现 一次编写，管你x86、arm、powerpc 到处运行。运行时，每当注册一个新的xxx_device或者xxx_driver到一条xxx_bus上，linux就尝试在xxx_bus给这个新加入的xxx_device或者xxx_driver配对（probe），device和driver配对成功了，xxx_driver就能利用xxx_device的内容去控制xxx设备了。综上，bus， device 和driver是一个清晰的树状结构，一种好的设计。可以在/sys/bus目录下用ls 、tree命令列出来这个树。\n终于能回到题目，platform 是一种虚拟的bus；而char driver 和 block driver，只是driver的细分。它们并不是并列的关系。那为什么要有platform 这条虚拟的总线呢？还是上面说的，操作系统要支持外设，必须先要知道当前计算机有哪些设备。要做到这一点，要么`硬件本身能自动探测出来当前bus上有哪些device`，要么就由程序员`事先把device资源信息写在代码或者dts这类配置文件里`。pci/pcie 总线是x86架构的脊椎，且拥有探测pci/pcie 设备的能力。PC上的usb总线控制器，对上是一个pcie设备，对下则是usb总线的控制器。等于`pcie总线下扩展出了新的usb总线`。usb总线也是有硬件探测能力的。个人电脑几乎所有重要的外设：硬盘、u盘、键盘、鼠标、声卡、显卡，都是pcie或者usb设备。再加上BIOS的帮助，普通pc的内核几乎不需要程序员手动注册一个设备信息，自己就能探测就出来当前计算机插了哪些设备。但是手机、平板等大量使用SOC的非X86架构计算机，它自己的usb控制器、i2c控制器、声卡控制器、lcd驱动器、存储控制器（一般是flash控制器，个别SOC也有sata控制器）等，都不再是X86架构下的pci设备了，`靠硬件自己是无法探测的`。此时就需要程序员自己手动写代码或者配置文件，来注册这些device的信息。假如是i2c 设备、spi设备，硬件也没有探测设备属性的能力，程序员手动注册device就注册了吧，起码知道是要注册到那条bus上去。。可偏偏`这些SOC外设并没有一个统一的总线名称`，ARM上叫`AHB、 APB` ，powerpc上叫CCB，甚至隔个几年又会发明新的叫法。platform 这条虚拟的bus，就是用来统一维护此类device的bus。\n\nlinux上把这种SOC内部bus下的设备（不一定全都是子总线控制器如usb控制器、i2c控制器，也可以是音频、视频控制器这种设备控制器），都注册到platform这条虚拟bus上。\n软件对于这种bus下的设备的访问倒很简单统一，按照芯片手册给的物理地址去访问即可。因为是SOC内部的设备，自然是SOC的厂家自己写这些设备的driver。这种driver一般注册到platform bus。","tags":["Android","FBE","FDE","metadata"],"categories":["Android","加密"]},{"title":"小米开机log相关","url":"/2019/10/01/存储相关/开机log相关/","content":"\n# 1. 开机log相关\n\n## 1.1. 抓取log的方式\n\n### 1.1.1. 通过rec overy抓取ota的log\n\n```puml\n@startuml\n-设置\n-系统更新\n-菜单(重启到recovery)\nnote right\n稳定版本需要连续点击logo\n才会出现菜单项\nend note\n-系统重启到recovery模式\n-选择连接小米助手\n- pc端执行 adb pull /cache/ .\n@enduml\n```\n\n#### 1.1.1.1. 抓取的log分析\n\n`/cache/recovery/`下面是ota升级相关的log日志\n`/cache/mqsas`下是重启到recovery模式前主系统最后保存的日志\n\n### 1.1.2. 主系统的日志\n\n如果adb 可以连接, 可查看的log信息\n`adblog\n\n`cat\n","tags":["Android"],"categories":["log"]},{"title":"github 加速","url":"/2019/09/20/工作相关/github/","content":"\n# github 加速\n\ngit 仓库地址中的`github.com`变成<span style=\"color: green\">`github.com.cnpmjs.org`</span>\n\ngit clone https://github.com.cnpmjs.org/SpencerPark/IJava.git\n\n\n\n # 全局配置 \n\n```bash\ngit config --global url.\"https://github.com.cnpmjs.org/\".insteadOf \"https://github.com/\"\n```\n\n","tags":["github"],"categories":["debug"]},{"title":"vscode 调试 C++","url":"/2019/09/20/工作相关/vscode调试c++/","content":"\n添加配置, 设置.\nlaunch脚本\n```json\n{\n    // 使用 IntelliSense 了解相关属性.\n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceRoot}/bin/main\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceRoot}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"preLaunchTask\": \"Build\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}\n```\n其中的task脚本\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    {\n        // See https://go.microsoft.com/fwlink/?LinkId=733558\n        // for the documentation about the tasks.json format\n        \"version\": \"2.0.0\",\n        \"tasks\": [\n            {\n                \"taskname\": \"build\",\n                \"label\": \"Build\",\n                \"command\": \"g++-5\",\n                \"args\": [\n                    \"-g\",\n                    \"-Wall\",\n                    \"-std=c++14\",\n                    \"${file}\",\n                    \"-lpthread\",\n                    \"-o\",\n                    \"${workspaceRoot}/bin/main\"\n                ],\n                \"problemMatcher\": {\n                    \"owner\": \"cpp\",\n                    \"fileLocation\": \"absolute\",\n                    \"pattern\": {\n                        \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(error):\\\\s+(.*)$\",\n                        \"file\": 1,\n                        \"line\": 2,\n                        \"column\": 3,\n                        \"severity\": 4,\n                        \"message\": 5\n                    }\n                }\n            },\n            {\n                \"label\": \"Run\",\n                \"type\": \"shell\",\n                \"dependsOn\": \"Build\",\n                \"command\": \"${workspaceRoot}/bin/main\",\n                \"args\": [],\n                \"presentation\": {\n                    \"reveal\": \"always\",\n                    \"focus\": true\n                },\n                \"problemMatcher\": [],\n                \"group\": {\n                    \"kind\": \"test\",\n                    \"isDefault\": true\n                }\n            }\n        ]\n    }\n}\n```\n\n其中build部分可以替换为makefile. 如果是多文件编译, 可以使用make all命令, 编译单一cpp(含main)的文件, 使用make $(file)进行替换.\n\n```make\n# 描述： multifile 项目 makefile文件\n# 版本： v2.0\n# 修改记录:  1.先测试普通的cpp文件的编译运行\n#           2.使用变量来改进我们的makefile文件\n#           3.新加了一个源文件\n#           4.使用伪目标，加上clean规则\n#           5.使用wildcard函数，自动扫描当前目录下的源文件\n#           6.加入了自动规则依赖\n#           7.实现了opencv程序的编译\n# 定义了可执行文件变量\nBIN := bin\nOUT := out\nCFLAGS := -std=c++14\n\n\n# 传递了文件参数\nFILE := $(FILE)\n\n# 定义了源文件列表变量\nifeq ($(strip $(FILE)), )\nsources := $(wildcard *.cpp)\ntarget:= all\nelse\nsources := $(FILE)\ntarget:=$(notdir $(basename $(sources)))\nendif\n\nexecutable  := $(BIN)/$(target)\nexecutable_main := $(BIN)/main\n\nSRC := $(notdir $(sources))\n\n# 使用变量的引用替换，定义了object文件列表\nobjects := $(addprefix $(OUT)/,  $(SRC:.cpp=.o))\n\n# 使用变量引用替换，定义依赖文件列表\ndeps    := $(SRC:.cpp=.d)\n# 定义编译命令变量\nCC  := g++-5\nrm  := rm -rf\n\n#需要调用的链接库\nLIBS := -lpthread\n\n# 头文件路径\nINCLUDE := -I.\n\n# 链接库路径\nLDFLAGS := -L/usr/local/lib\n# 终极目标规则，生成可执行文件\n\n\n\n$(executable) : $(objects)\n\t-mkdir bin\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS) $(LIBS)\n\tmv $(executable) $(executable_main)\n\n$(objects): %.o: $(sources)\n\t-mkdir $(OUT)\n\t$(CC) $(CFLAGS) -o $@ -c $< $(INCLUDE)\n\nall : $(executable)\n\n\n\n#clean规则\n.PHONY: clean\nclean:\n#清除编译生成的所有文件\n#$(RM) $(executable) $(objects) $(deps)\n#清除编译生成的所有文件,不包括可执行文件\n\t$(RM) $(objects) $(deps) $(executable)\n\n# 自动规则依赖\ndeps := $(addprefix $(OUT)/, $(SRC:.cpp=.d))\nsinclude $(deps)\n$(deps): %.d: $(sources)\n\t$(CC) -MM $(CFLAGS) $< > $@\n```","tags":["gdb"],"categories":["debug"]},{"title":"Android bp 编译相关","url":"/2019/09/12/OTA相关/编译相关/","content":"\n# 1. 编译相关\n\n## 1.1. bp makefile通用规则\n编译规则:\n\n- bp 可以引用bp定义的module\n- bp不能引用mk定义的module\n- mk可以引用mk和bp定义的module\n\n传统的写法下, bp中不能引用外部的make定义的变量\n\n可以借助原生文件的写法, 在soong_config.mk中引用mk文件\nbuild/core/soong_config.mk\n    --include miui/build/soong/import_miui_soong_vars.mk\n\n在mk文件中可以加bp规则的hook\n\n```Makefile\nifeq (true,$(ENABLE_MIUI_DEBUGGING))\n_adb_local_cflags := -UALLOW_ADBD_ROOT -DALLOW_ADBD_ROOT=1 -DALLOW_ADBD_DISABLE_VERITY -DALLOW_ADBD_NO_AUTH\n$(call add_additional_soong_var, adbd_defaults, cflags, $(_adb_local_cflags))\nendif\n```\n```go\ncc_defaults {\n    name: \"adbd_defaults\",\n    defaults: [\"adb_defaults\"],\n\n    cflags: [\"-UADB_HOST\", \"-DADB_HOST=0\"],\n    ...\n}\n\ncc_library {\n    name: \"libadbd\",\n    defaults: [\"adbd_defaults\", \"host_adbd_supported\"],\n    recovery_available: true,\n    ...\n}\n\n```\n\n参照上述写法, 可以在bp中引用外部的mk变量\n\n>bp中的required规则可以无视上述规则. 即bp可以required mk定义的module\n\n## 1.2. recovery bp相关编译规则\n\n在androidq上新增了`recovery_available`和`recovery`变量\n定义了`recovery_available`后, 如果目标需要被recovery引用(主系统也需要用), 需要添加 `recovery_available:true`\n如果目标只是给recovery用的可以添加`recovery:true`\n\n```go\ncc_library {\n    name: \"libadbd\",\n    defaults: [\"adbd_defaults\", \"host_adbd_supported\"],\n    recovery_available: true,\n    ...\n}\n\ncc_binary {\n    name: \"fastbootd\",\n    defaults: [\"fastboot_defaults\"],\n\n    recovery: true,\n...\n    shared_libs: [\n        ...\n        \"libadbd\",\n        \"libasyncio\",\n    ],\n}\n```\n\n定义`recovery_available`的module可以直接被引用, 如编译fastbootd时, 指定`shared_libs`可以直接引用`libadbd`\n如果不能直接引用的, 如required规则, 则需要添加`.recovery`后缀, 而定义了`recovery`的module则不需要添加`.recovery`后缀\n\n如`binary`不能被直接引用, 可以被required规则引用\n\n```go\ncc_binary {\n    name: \"recovery\",\n    recovery: true,\n...\n    required: [\n    ...\n        \"mke2fs.recovery\",\n        \"recovery_deps\",\n    ],\n}\n\ncc_binary {\n    name: \"mke2fs\",\n    host_supported: true,\n    recovery_available: true,\n    defaults: [\"e2fsprogs-defaults\"],\n    ...\n}\n```\n\n或者可以被PRODUCT_PACKAGES引用\n\n```go\nPRODUCT_PACKAGES += \\\n    adbd.recovery \\\n    android.hardware.health@2.0-impl-default.recovery \\\n    cgroups.recovery.json \\\n    charger.recovery \\\n    init_second_stage.recovery \\\n```\n\n被`PRODUCT_PACKAGES` 引用后, 在生成recoveryimage时会拷贝对应的module放到对应位置的module path下\n\n","tags":["编译"],"categories":["Android"]},{"title":"Android AOSP gdb stl 支持","url":"/2019/08/20/工作相关/gdb stl支持/","content":"\n# Android AOSP gdb stl 支持\n\n默认情况下不支持stl 输出, 需要gdb支持python脚本, 一般需要自己编译.\n\n1. 下载编译python3.x 源码:\n\n    ```shell\n    curl -O https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tar.xz\n    cd Python-3.8.1\n    mkdir build\n    #prefix 是指定安装目录, 也可指到任一目录, 因为这里只用到编译python时生成的临时文件\n    ../configure --prefix=~/Programs/python3 --enable-optimizations --enable-shared\n    make\n    make install\n    ```\n\n2. 下载编译gdb源码:\n\n    https://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz\n\n    这个链接有点慢, 可以直接下附件中的\n\n    ```shell\n    tar gdb-9.2.tar.xz\n    mkdir build\n    #prefix 是安装目录, with-python选项的路径填上一步编译python的build路径\n    # arm64\n    ../configure --target=aarch64-linux-android --prefix=/home/mi/Programs/gdb --enable-unicode=ucs4 --with-python=/home/mi/Programs/Python-3.8.1/build\n    # mips\n    ../configure --target=mips-mti-elf --prefix=/home/mi/program/mips-gdb --enable-unicode=ucs4 --with-python=/usr --with-auto-load-dir=$debugdir:$datadir/auto-load --with-auto-load-safe-path=$debugdir:$datadir/auto-load --with-expat --without-libunwind-ia64 --without-lzma --without-babeltrace --without-intel-pt --disable-libmcheck --without-mpfr --without-guile\n    make\n    make install\n    ```\n\n3. 切换本地python版本为python3\n\n   ```shell\n   sudo rm /usr/bin/python; sudo ln -s /usr/bin/python3 /usr/bin/python;\n   ```\n\n   > 这里注意的点是xiaomi的code环境是依赖python2的, repo可以切到python2上, 将repo的第一行改成`#!/usr/bin/env python2 `即可, 但代码编译时, 有些模块在python3下会报错, 目前发现的有依赖kernel 模块的, 使用ninja都会报错. 所以最好在编译时将python版本切换到python2.\n\n4. 定制gdbinit\n\n   android上废弃了stlport和gnustl的支持, 只支持libc++的方式集成stl.\n\n   所以python解析脚本是基于libc++开发的, 这里提供一下github上的一个脚本\n\n   https://github.com/koutheir/libcxx-pretty-printers\n\n   ```shell\n   git clone https://github.com/koutheir/libcxx-pretty-printers\n   ```\n\n   ```python\n   python\n   import sys\n   #路径填刚才clone到本地的, 指定到第一级src目录\n   sys.path.insert(0, '/home/mi/program/libcxx-pretty-printers/src')\n   from libcxx.v1.printers import register_libcxx_printers\n   register_libcxx_printers (None)\n   end\n   ```\n   \n   \n\n\n5. android编译module修改, Android.bp修改\n\n   ```json\n   # 添加stl支持\n   cflags: [\n           \"-O0\",\n       ],\n   stl: \"c++_static\", 或\n   stl: \"c++_shared\"\n   ```\n\n6. vscode 中使用gdb\n\n   vscode的launch.json也要配置打开 pretty-printers, 对于remote调试感兴趣的可以看另一篇文档中的介绍\n\n  ```json\n  {\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Remote Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"miDebuggerServerAddress\": \"127.0.0.1:8888\",\n            \"program\": \"/home/mi/work_space/miui-r-umi-dev/out/target/product/cmi/symbols/system/bin/test_code_aaaaaaa\",\n            \"args\": [],\n            \"stopAtEntry\": true,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"sourceFileMap\": {\n                \"system/core/crypto_test\": \"/home/mi/work_space/miui-r-umi-dev/system/core/test_code\"\n            },\n            \"logging\": {\n                \"trace\": true,\n                \"traceResponse\": true,\n                \"engineLogging\": true,\n            },\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"/home/mi/Programs/gdb/bin/aarch64-linux-android-gdb\",\n            \"setupCommands\": [\n              {\n              \"description\": \"Enable pretty-printing for gdb\",\n              \"text\": \"-enable-pretty-printing\",\n              \"ignoreFailures\": true\n              },\n            ],\n        }\n    ]\n  }\n  ```\n\n  \n\n","tags":["gdb","android","stl"],"categories":["debug"]},{"title":"f2fs gc","url":"/2019/08/12/OTA相关/f2fs gc/","content":"\nvnote_backup_file_826537664 /home/mi/Documents/backup/VnoteBook/OTA相关/f2fs gc.md\n# 1. f2fs gc\n\ndo_garbage_collect\n    -> gc_data_segment\n        -> move_data_page\n           -> f2fs_pin_file_control\n    -> stat_inc_seg_count\n\n\n解密map\n\numi:/data/media/0/downloaded_rom # sha1sum /cache/recovery/block.map                                                                 \na31f2e057e6a02fc64f55dedd3e69ed71c2c4821  /cache/recovery/block.map\n\n\n初次解密后\n\n\numi:/data/media/0/downloaded_rom # sha1sum miui_UMI_9.11.18_6d674ad5a9_10.0.zip                                                      \n631b3f61f9ea85911d354c277c98f9fcdb56b0bc  miui_UMI_9.11.18_6d674ad5a9_10.0.zip\n\nrecovery会更改?\n-rw-rw-r-- 1 media_rw media_rw 2594048280 2019-11-18 10:14 miui_UMI_9.11.18_6d674ad5a9_10.0.zip\nsha1sum miui_UMI_9.11.18_6d674ad5a9_10.0.zip                                                                                       \nparse_ld_lib_path (null)\n6fcdd51f751fe1a19af20c70302575b3fdb70086  miui_UMI_9.11.18_6d674ad5a9_10.0.zip\n\n\n\n原始\n\n[$] -> sha1sum ~/Downloads/miui_UMI_9.11.18_6d674ad5a9_10.0.zip \n88abea31fe641216b7a2659a6e63f5c4d619efaa  /home/mi/Downloads/miui_UMI_9.11.18_6d674ad5a9_10.0.zip\n\nrecovery 初始block.map\n88abea31fe641216b7a2659a6e63f5c4d619efaa\n\nGet package's sha bay MemMapping.\nsha1: 88abea31fe641216b7a2659a6e63f5c4d619efaa\n\npin_file  存到文件系统的扩展属性中\n[   34.256381] F2FS-fs (dm-4): f2fs_pin_file_control: Enable GC = ino 204c after 801 GC trials\n\n```c\nunsigned int segno = start_segno;\nunsigned int end_segno = start_segno + sbi->segs_per_sec;\nfor (segno = start_segno; segno < end_segno; segno++) {\n...\n\tunsigned char type = IS_DATASEG(get_seg_entry(sbi, segno)->type) ?\n\t\t\t\t\t\tSUM_TYPE_DATA : SUM_TYPE_NODE;\t\t\t\t\t\t\n\tif (type == SUM_TYPE_NODE)\n\t\tsubmitted += gc_node_segment(sbi, sum->entries, segno,\n\t\t\t\t\t\t\tgc_type);\n\telse\n\t\tsubmitted += gc_data_segment(sbi, sum->entries, gc_list,\n\t\t\t\t\t\tsegno, gc_type);\n\n    for (off = 0; off < sbi->blocks_per_seg; off++, entry++) {\n        inode = find_gc_inode(gc_list, dni.ino);\n        if(inode) {\n        \t\tif (f2fs_post_read_required(inode))\n    \t\t\t    err = move_data_block(inode, start_bidx,\n\t\t\t\t\t\tgc_type, segno, off);\n\t\t\t\t\t\t\n        }\n        \n\n    }\n}\n```","tags":["f2fs"],"categories":["文件系统"]},{"title":"fbe与用户安全密码","url":"/2019/08/12/OTA相关/fbe与用户安全密码/","content":"\n[TOC]\n\n# 1. fbe与用户安全密码\n\n之前介绍了fde与用户安全密码的关系，发现其是相对简单的。而对fbe和metadata加密的方式，在调研过程中发现密码的存储与文件ce区的密钥的关系则复杂的多。\n\n## 1.1. 用户ce区文件解密\n\n这个过程伴随着一个函数向下执行的，即`unlockUserKey`***函数***，首先看下伴随这个过程的密钥来自哪里\n\n```java\nunlockUserKey(userId, null, auth.deriveDiskEncryptionKey());\n    /** Unlock disk encryption */\n1712     private void unlockUserKey(int userId, byte[] token, byte[] secret) throws RemoteException {\n1713         final UserInfo userInfo = mUserManager.getUserInfo(userId);\n1714         mStorageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);\n1715     }\n```\n以机主用户为例， 上述参数中userID为0， token 为空， serialNumber为0，未知的只有secret，来自`deriveDiskEncryptionKey`\n\n```java\n       public byte[] deriveDiskEncryptionKey() {\n 179             return derivePassword(PERSONALIZATION_FBE_KEY);\n 180         }\n\n 160         private byte[] derivePassword(byte[] personalization) {\n 161             if (mVersion == SYNTHETIC_PASSWORD_VERSION_V3) {\n 162                 return (new SP800Derive(syntheticPassword.getBytes()))\n 163                     .withContext(personalization, PERSONALISATION_CONTEXT);\n 164             } else {\n 165                 return SyntheticPasswordCrypto.personalisedHash(personalization,\n 166                         syntheticPassword.getBytes());\n 167             }\n 168         }\n```\n关键参数只有一个`syntheticPassword`\n```java\n         private void initialize(byte[] P0, byte[] P1) {\n 191             this.P1 = P1;\n 192             this.syntheticPassword = String.valueOf(HexEncoding.encode(\n 193                     SyntheticPasswordCrypto.personalisedHash(\n 194                             PERSONALIZATION_SP_SPLIT, P0, P1)));\n```\n这个密码生成的时候是一个随机的值？\n\n```java\n    public AuthenticationToken newSyntheticPasswordAndSid(IGateKeeperService gatekeeper,\n 463             byte[] hash, byte[] credential, int userId) throws RemoteException {\n 464         AuthenticationToken result = AuthenticationToken.create();\n...\n 478         saveEscrowData(result, userId);\n 479         return result;\n 480     }\n\n         protected static AuthenticationToken create() {\n 204             AuthenticationToken result = new AuthenticationToken(SYNTHETIC_PASSWORD_VERSION_V3);\n 205                     result.initialize(secureRandom(SYNTHETIC_PASSWORD_LENGTH),\n 206                     secureRandom(SYNTHETIC_PASSWORD_LENGTH));\n 207             return result;\n 208         }\n```\n\n还有一个地方表明这个是伴随用户密码解锁过程解出来的\n\n```java\n     private AuthenticationToken unwrapSyntheticPasswordBlob(long handle, byte type,\n 979             byte[] applicationId, long sid, int userId) {\n 980         byte[] blob = loadState(SP_BLOB_NAME, handle, userId);\n \n94         if (version == SYNTHETIC_PASSWORD_VERSION_V1) {\n 995             secret = SyntheticPasswordCrypto.decryptBlobV1(getHandleName(handle),\n 996                     Arrays.copyOfRange(blob, 2, blob.length), applicationId);\n 997         } else {\n 998             secret = decryptSPBlob(getHandleName(handle),\n 999                 Arrays.copyOfRange(blob, 2, blob.length), applicationId);\n1000         }\n// 来自secret，secret的解密又有keymaster gatekeeper的参与\n         if (type == SYNTHETIC_PASSWORD_TOKEN_BASED) {\n1007             if (!loadEscrowData(result, userId)) {\n1008                 Log.e(TAG, \"User is not escrowable: \" + userId);\n1009                 return null;\n1010             }\n1011             result.recreate(secret);\n1012         } else {\n1013             result.syntheticPassword = new String(secret);\n1014         }\n```\n这个流程可以追溯到解锁后，解锁密码的保存时触发的\n```shell\n-> saveChosenPasswordnAndFinish(final String pin)    #ChooseLockPassword.java - MiuiSystemUI\n  \\ - saveLockPassword(pin, mUserPassword, mRequestedQuality, mUserIdToSetPassword) # LockPatternUtils.java\n     \\ -  setLockCredential(password, CREDENTIAL_TYPE_PASSWORD, savedPassword,\n                      requestedQuality, userHandle, allowUntrustedChange); #LockSettingService.java\n         \\ - setLockCredentialInternal(credential, type, savedCredential, requestedQuality, userId,\n                     allowUntrustedChange, /* isLockTiedToParent= */ false); #LockSettingService.java\n             \\ - spBasedSetLockCredentialInternalLocked(credential, credentialType, savedCredential,\n                         requestedQuality, userId, allowUntrustedChange, isLockTiedToParent); #LockSettingService.java\n                  \\ -  AuthenticationResult authResult = mSpManager.unwrapPasswordBasedSyntheticPassword(\n                            getGateKeeperService(), handle, savedCredential, userId, null);\n                  | - setLockCredentialWithAuthTokenLocked(credential, credentialType, auth, requestedQuality, userId);\n                       \\ - unlockUserKey(userId, null, auth.deriveDiskEncryptionKey());\n             | -  setUserKeyProtection(userId, credential, convertResponse(gkResponse));\n                 \\ - addUserKeyAuth(userId, token, secretFromCredential(credential)); #LockSettingService.java\n```\n上述过程只是解锁的一个流程，在用户密码校验的地方，有一处值得注意，即使用`spBasedSetLockCredentialInternalLocked`进行核对时，是有条件的\n注意这个函数`isSyntheticPasswordBasedCredentialLocked`, 只有这个函数为true时，才会对secret加这一层封装。从之前的流程分析下来，这个封装的中间文件存在了\n`/data/system_de/0/spblob`下\n\n\n```java\n     private boolean isSyntheticPasswordBasedCredentialLocked(int userId) {\n...\n2517         long handle = getSyntheticPasswordHandleLocked(userId);\n2518         // This is a global setting\n2519         long enabled = getLong(SYNTHETIC_PASSWORD_ENABLED_KEY,\n2520                 SYNTHETIC_PASSWORD_ENABLED_BY_DEFAULT, UserHandle.USER_SYSTEM);\n2521       return enabled != 0 && handle != SyntheticPasswordManager.DEFAULT_HANDLE;\n2522     }\n\n```\n\n\n初步流程分析下来，用户密码和ce区文件解锁密码之间的导出关系比较复杂，且需要多个中间参数和keymater的参与\n>上面的流程分析有点问题，unlockUserKey应该时UserController下发的\n关注下面的函数：\n\n```java\n     private VerifyCredentialResponse verifyCredential(int userId, CredentialHash storedHash,\n1907             byte[] credential, boolean hasChallenge, long challenge,\n1908             ICheckCredentialProgressCallback progressCallback) throws RemoteException {\n\n```\n\n这里如果`isSyntheticPasswordBasedCredentialLocked`返回false，再对整个解锁流程做一下梳理，密码输入后，会触发check的逻辑\n```shell\n+- onPatternDetected(List<Cell> pattern) #图案绘完 ConfirmLockPattern.java\n \\ +- startVerifyPattern(pattern)\n    \\ - long challenge = getActivity().getIntent().getLongExtra(MiuiChooseLockSettingsHelper.EXTRA_KEY_CHALLENGE, 0);\n    | +- LockPatternChecker.verifyPattern(mLockPatternUtils, pattern, challenge, localUserId, mContext, onVerifyCallback) #challenge未知，由外部传入\n       \\ +- LockPatternUtils.verifyPattern(patternCopy, challenge, userId) # LockPatternChecker.java\n         \\ - verifyCredential(patternToByteArray(pattern), CREDENTIAL_TYPE_PATTERN, challenge, userId); # LockPatternUtils.java\n            \\ - getLockSettings().verifyCredential(credential, type, challenge, userId);\n               \\ +- doVerifyCredential(credential, type, true, challenge, userId, null) # LockSettingService.java\n                  \\ +-  response = spBasedDoVerifyCredential(credential, credentialType, hasChallenge, challenge, userId, progressCallback);\n                      \\ - spBasedDoVerifyCredential<credential, credentialType, hasChallenge, challenge, userId, progressCallback>\n                        \\ - long handle = getSyntheticPasswordHandleLocked(userId);\n                        | - mSpManager.unwrapPasswordBasedSyntheticPassword( getGateKeeperService(), handle, userCredential, userId, progressCallback); \n                  | +-  response = verifyCredential(userId, storedHash, credentialToVerify, hasChallenge, challenge, progressCallback);\n                     \\ - CredentialHash storedHash = mStorage.readCredentialHash(userId) #从保存的密钥中间文件中构造hash\n                     | - gateKeeperResponse = getGateKeeperService().verifyChallenge(userId, challenge, storedHash.hash, credential); #challenge由外部传入，storedHash读取/data/system/gatekeeper.pattern.key|gatekeeper.password.key，通过verifyChallenge返回了一个token\n                     | - VerifyCredentialResponse response = convertResponse(gateKeeperResponse); #这里仍然有gatekeeper参与\n                     | - unlockKeystore(credential, userId);\n                     | - unlockUser(userId, response.getPayload(), secretFromCredential(credential)); #未知参数变成了token\n                        \\ - mActivityManager.unlockUser(userId, token, secret, listener);\n                           \\ - mUserController.unlockUser(userId, token, secret, listener) # ActivityManagerService.java\n                              \\ - unlockUserCleared(userId, token, secret, listener) #UserController.java\n                                 \\ - storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);\n                                    \\- mVold.unlockUserKey(userId, serialNumber, encodeBytes(token), encodeBytes(secret)) #StorageManagrService\n```\n\n从上面的流程看，对于`isSyntheticPasswordBasedCredentialLocked`返回false的情况，需要关注的点是外部传入的`chanllenge`, 以及用户安全密码的中间文件`storeHash`和用户输入的安全密码，unlockKeyStore GateKeeper都需要能被调用到 `system/security/keystore` `system/core/gatekeeperd`\n\n## 1.2. 小结\n从上述流程分析来看，fde和fbe用户密码与直接解锁密码的逻辑并不相同：\n\n- fde的解锁方式上看，开机时CryptKeeper接管了keyguard的操作，用户密码与解锁fde磁盘加密主密钥直接相关，因此导出关系很单一。\n- 而fbe的解锁方式，开机后直接走的keyguard，keyguard的模块逻辑比较复杂，而且用户密码经过了多层加密，最终的用户密码到ce区的文件解锁密码关系要复杂的多。中间经过了多层中转，需要逐层分析。 需要通过设备调试，发现其中的中转关系\n\n## 1.3. spblob方式流程跟进\n从上面isSyntheticPasswordBasedCredentialLocked返回true的场景上，q的机型正是用的这种加密方式\n```java\n774         long handle = getSyntheticPasswordHandleLocked(userId);\n2775         AuthenticationResult authResult = mSpManager.unwrapPasswordBasedSyntheticPassword(\n2776                 getGateKeeperService(), handle, savedCredential, userId, null);\n\n```\n先看  `getSyntheticPasswordHandleLocked`函数\n```java\n     private long getSyntheticPasswordHandleLocked(int userId) {\n2566         return getLong(SYNTHETIC_PASSWORD_HANDLE_KEY,\n2567                 SyntheticPasswordManager.DEFAULT_HANDLE, userId);\n2568     }\n```\n`SYNTHETIC_PASSWORD_HANDLE_KEY`来自于`initializeSyntheticPasswordLocked`\n\n```java\n\n2533     protected AuthenticationToken initializeSyntheticPasswordLocked(byte[] credentialHash,\n2534             byte[] credential, int credentialType, int requestedQuality,\n2535             int userId) throws RemoteException {\n2536         Slog.i(TAG, \"Initialize SyntheticPassword for user: \" + userId);\n2537         final AuthenticationToken auth = mSpManager.newSyntheticPasswordAndSid(\n2538                 getGateKeeperService(), credentialHash, credential, userId);\n2539         onAuthTokenKnownForUser(userId, auth);\n// 创建password相关的handle和spblob中间文件\n2544         long handle = mSpManager.createPasswordBasedSyntheticPassword(getGateKeeperService(),\n2545                 credential, credentialType, auth, requestedQuality, userId);\n2546         if (credential != null) {\n2547             if (credentialHash == null) {\n2548                 // Since when initializing SP, we didn't provide an existing password handle\n2549                 // for it to migrate SID, we need to create a new SID for the user.\n2550                 mSpManager.newSidForUser(getGateKeeperService(), auth, userId);\n2551             }\n2552             mSpManager.verifyChallenge(getGateKeeperService(), auth, 0L, userId);\n2553             setAuthlessUserKeyProtection(userId, auth.deriveDiskEncryptionKey());\n2554             setKeystorePassword(auth.deriveKeyStorePassword(), userId);\n2555         }\n2560         fixateNewestUserKeyAuth(userId);\n2561         setLong(SYNTHETIC_PASSWORD_HANDLE_KEY, handle, userId);\n2562         return auth;\n2563     }\n\n    public long createPasswordBasedSyntheticPassword(IGateKeeperService gatekeeper,\n 627             byte[] credential, int credentialType, AuthenticationToken authToken,\n 628             int requestedQuality, int userId)\n 29                     throws RemoteException {\n //可以看到handle是一个随机值，最终setLong(SYNTHETIC_PASSWORD_HANDLE_KEY, handle, userId); 到数据库中，再次取得时候，直接从数据库中getLong获取\n         long handle = generateHandle();\n 636         PasswordData pwd = PasswordData.create(credentialType);\n 637         byte[] pwdToken = computePasswordToken(credential, pwd);\n ...\n         saveState(PASSWORD_DATA_NAME, pwd.toBytes(), handle, userId);\n 676         createSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED, authToken,\n 677                 applicationId, sid, userId);\n}\n```\n\n而unwrapPasswordBasedSyntheticPassword函数，\n```java\n//参数为上面得handle 用户凭据  userId\n        AuthenticationResult authResult = mSpManager.unwrapPasswordBasedSyntheticPassword(\n2776                 getGateKeeperService(), handle, savedCredential, userId, null);\n\n   public AuthenticationResult unwrapPasswordBasedSyntheticPassword(IGateKeeperService gatekeeper,\n 861             long handle, byte[] credential, int userId,\n 862             ICheckCredentialProgressCallback progressCallback) throws RemoteException {\n 866         AuthenticationResult result = new AuthenticationResult();\n //从中间文件解出 passworddata\n 867         PasswordData pwd = PasswordData.fromBytes(loadState(PASSWORD_DATA_NAME, handle, userId));\n 868         result.credentialType = pwd.passwordType;\n 869         byte[] pwdToken = computePasswordToken(credential, pwd);\n// 这中间走的分支都需要debug才能知道\n918             sid = sidFromPasswordHandle(pwd.passwordHandle);\n 919             applicationId = transformUnderSecdiscardable(pwdToken,\n 920                     loadSecdiscardable(handle, userId));\n\n。。。\n // 需要参数 applicationId， sid\n        result.authToken = unwrapSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED,\n 928                 applicationId, sid, userId);\n31         result.gkResponse = verifyChallenge(gatekeeper, result.authToken, 0L, userId);\n\n// 最终要得到 authToken，进行验证得到的结果为gkResponse，然后再通过Spmanager的verifyChallenge验证challenge， 都为正确的，才说明密码是正确的。\n             if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {\n2634                 // perform verifyChallenge with synthetic password which generates the real GK auth\n2635                 // token and response for the current user\n2636                 response = mSpManager.verifyChallenge(getGateKeeperService(), authResult.authToken,\n2637                         challenge, userId);\n2638                 if (response.getResponseCode() != VerifyCredentialResponse.RESPONSE_OK) {\n2639                     // This shouldn't really happen: the unwrapping of SP succeeds, but SP doesn't\n2640                     // match the recorded GK password handle.\n2641                     Slog.wtf(TAG, \"verifyChallenge with SP failed.\");\n2642                     return VerifyCredentialResponse.ERROR;\n2643                 }\n2644             }\n\n// 而文件密码与/data/system_de/0/spblob/下存储的文件，applicationId， 上面提到的handle有关\n    private AuthenticationToken unwrapSyntheticPasswordBlob(long handle, byte type,\n 979             byte[] applicationId, long sid, int userId) {\n 980         byte[] blob = loadState(SP_BLOB_NAME, handle, userId);\n 981         if (blob == null) {\n 982             return null;\n 983         }\n 984         final byte version = blob[0];\n 985         if (version != SYNTHETIC_PASSWORD_VERSION_V3\n 986                 && version != SYNTHETIC_PASSWORD_VERSION_V2\n 987                 && version != SYNTHETIC_PASSWORD_VERSION_V1) {\n 988             throw new RuntimeException(\"Unknown blob version\");\n 989         }\n 990         if (blob[1] != type) {\n 991             throw new RuntimeException(\"Invalid blob type\");\n 992         }\n 993         final byte[] secret;\n 994         if (version == SYNTHETIC_PASSWORD_VERSION_V1) {\n // 解用户ce区文件的密码\n 995             secret = SyntheticPasswordCrypto.decryptBlobV1(getHandleName(handle),\n 996                     Arrays.copyOfRange(blob, 2, blob.length), applicationId);\n 997         } else {\n 998             secret = decryptSPBlob(getHandleName(handle),\n 999                 Arrays.copyOfRange(blob, 2, blob.length), applicationId);\n1000         }\n1005         AuthenticationToken result = new AuthenticationToken(version);\n// 这个地方也需要debug，应该是用的 SYNTHETIC_PASSWORD_TOKEN_BASED 方式\n\n1006         if (type == SYNTHETIC_PASSWORD_TOKEN_BASED) {\n1007             if (!loadEscrowData(result, userId)) {\n1008                 Log.e(TAG, \"User is not escrowable: \" + userId);\n1009                 return null;\n1010             }\n1011             result.recreate(secret);\n1012         } else {\n1013             result.syntheticPassword = new String(secret);\n1014         }\n// spblob格式升级\n1015         if (version == SYNTHETIC_PASSWORD_VERSION_V1) {\n1016             Log.i(TAG, \"Upgrade v1 SP blob for user \" + userId + \", type = \" + type);\n1017             createSyntheticPasswordBlob(handle, type, result, applicationId, sid, userId);\n1018         }\n1019         return result;\n1020     }\n```\n上述过程，很多地方需要通过debug才能确定，需要进一步调研。查看哪些是可以拆解出来的。可以通过native程序解出来。\n\n\n在keyguard解锁后校验密码的流程走的spblob的方式，在gatekeeper和keymaster的基础上对密码又做了一层封装。将spblob中间文件删除后，重启手机，用户ce区文件不能解密，重建spblob后也无法解密。用户ce区解锁也是每次开机加载机主用户时执行的，并不是每次解锁都会进行unlock。用户密码更新后，ce区密码也会更新，但该密码只是用来加密文件主密钥的密码，文件主密钥并没变，所以用户密码改变不需要重新解锁用户ce区，只需要更新中间文件spblob和/data/misc/vold/user_keys/0/current下的中间文件即可。\n需要进一步调试跟踪各中间参数是怎样生成的， 最终效果是能模拟用户密码是否输入正确及推导出加密ce区主密钥的密钥\n\n\n## 1.4. debug 调试\n\n```shell\n01-09 15:05:25.848  2575  2717 E LockPatternUtils: zlg:\n60167 01-09 15:05:25.848  2575  2717 E LockPatternUtils: java.lang.RuntimeException: checkCredential log\n60168 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.internal.widget.LockPatternUtils.checkCredential(LockPatternUtils.java:393)\n60169 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.internal.widget.LockPatternUtils.checkPattern(LockPatternUtils.java:447)\n60170 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.checkPattern(LockPatternChecker.java:91)\n60171 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.doInBackground(LockPatternChecker.java:49)\n60172 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.doInBackground(LockPatternChecker.java:39)\n60173 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at android.os.AsyncTask$3.call(AsyncTask.java:378)\n60174 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n60175 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n60176 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n60177 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.lang.Thread.run(Thread.java:919)\n60178 01-09 15:05:25.849  2115  2546 D LockSettingsService: spBasedDoVerifyCredential: user=0\n60179 01-09 15:05:25.850  2115  2546 E LockSettingsService: zlg :\n60180 01-09 15:05:25.850  2115  2546 E LockSettingsService: java.lang.RuntimeException: spBasedDoVerifyCredential log\n60181 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.spBasedDoVerifyCredential(LockSettingsService.java:2623)\n60182 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.doVerifyCredential(LockSettingsService.java:1875)\n60183 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.checkCredential(LockSettingsService.java:1840)\n60184 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.internal.widget.ILockSettings$Stub.onTransact(ILockSettings.java:556)\n60185 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at android.os.Binder.execTransactInternal(Binder.java:1021)\n60186 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at android.os.Binder.execTransact(Binder.java:994)\n\n```\n从上述流程看，是走的checkPattern\n图案解锁方式， 最后到checkCredential处，没有challenge，即challenge为0\n```java\n     public boolean checkPattern(List<LockPatternView.Cell> pattern, int userId)\n 433             throws RequestThrottledException {\n 434         return checkPattern(pattern, userId, null /* progressCallback */);\n 435     }\n 436\n 437     /**\n 438      * Check to see if a pattern matches the saved pattern.  If no pattern exists,\n 439      * always returns true.\n 440      * @param pattern The pattern to check.\n 441      * @return Whether the pattern matches the stored one.\n 442      */\n 443     public boolean checkPattern(List<LockPatternView.Cell> pattern, int userId,\n 444             @Nullable CheckCredentialProgressCallback progressCallback)\n 445             throws RequestThrottledException {\n 446         throwIfCalledOnMainThread();\n 447         return checkCredential(patternToByteArray(pattern), CREDENTIAL_TYPE_PATTERN, userId,\n 448                 progressCallback);\n 449     }\n\n1837     public VerifyCredentialResponse checkCredential(byte[] credential, int type, int userId,\n1838             ICheckCredentialProgressCallback progressCallback) throws RemoteException {\n1839         checkPasswordReadPermission(userId);\n// 没有challenge\n1840         VerifyCredentialResponse response = doVerifyCredential(credential, type,\n1841                                         false, 0, userId, progressCallback);\n1842         if ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &&\n1843                                            (userId == UserHandle.USER_OWNER)) {\n1844                 //TODO(b/127810705): Update to credentials to use byte[]\n1845                 String credentialString = credential == null ? null : new String(credential);\n1846                 retainPassword(credentialString);\n1847         }\n1848         return response;\n1849     }\n\n```\nsid和applicationId是容易解出的， 根据上面debug的关键信息， 再跟一遍代码流程和参数的求解\n```java\n/data/system_de/0/spblob/4497efca1dd620f6.secdis\napplicationId = transformUnderSecdiscardable(pwdToken,\n 927                     loadSecdiscardable(handle, userId));\n     private byte[] transformUnderSecdiscardable(byte[] data, byte[] rawSecdiscardable) {\n     // pwdToken 和 secdis文件内容联合做sha1-512\n1109         byte[] secdiscardable = SyntheticPasswordCrypto.personalisedHash(\n1110                 PERSONALISATION_SECDISCARDABLE, rawSecdiscardable);\n1111         byte[] result = new byte[data.length + secdiscardable.length];\n1112         System.arraycopy(data, 0, result, 0, data.length);\n1113         System.arraycopy(secdiscardable, 0, result, data.length, secdiscardable.length);\n1114         return result;\n1115     }\n```\n```cpp\nnativeSidFromPasswordHandle->sidFromPasswordHandle(pwd.passwordHandle);\n2static jlong android_server_SyntheticPasswordManager_nativeSidFromPasswordHandle(JNIEnv* env, jobject, jbyteArray handleArray) {\n33\n34    jbyte* data = (jbyte*)env->GetPrimitiveArrayCritical(handleArray, NULL);\n37        const gatekeeper::password_handle_t *handle =\n38                reinterpret_cast<const gatekeeper::password_handle_t *>(data);\n39        jlong sid = handle->user_id;\n45}\n```\n\n\n```shell\nLockSettingsService: zlg: credential: [B@3ada1b6 hasChallenge: false challenge: 0 handle: 4942682767425413366\nSyntheticPasswordManager: zlg weaverSlot is INVALID_WEAVER_SLOT\nSyntheticPasswordManager: zlg: unwrapSyntheticPasswordBlob version not V1\nSyntheticPasswordManager: zlg: not unwrapSyntheticPasswordBlob type SYNTHETIC_PASSWORD_TOKEN_BASED\nLockSettingsService: zlg Unlocking user 0 with secret only, length 32 secret: [B@8fb4f53\n```\n```java\n    private String getHandleName(long handle) {\n  1182         return String.format(\"%s%x\", LockPatternUtils.SYNTHETIC_PASSWORD_KEY_PREFIX, handle);\n  1183     }\n    public static final String SYNTHETIC_PASSWORD_KEY_PREFIX = \"synthetic_password_\";\n byte[] blob = loadState(SP_BLOB_NAME, handle, userId);\n // handle信息其实就是/data/system_de/0/spblob/<handle>.spblob\n // secret就是文件ce区主密钥的密钥， blob 是 /data/system_de/0/spblob/<handle>.spblob 读取的内容， applicationId是上面提到的sha1-512的值\n            secret = decryptSPBlob(getHandleName(handle),\n  1008                 Arrays.copyOfRange(blob, 2, blob.length), applicationId);\n\n     public static byte[] decryptBlob(String keyAlias, byte[] blob, byte[] applicationId) {\n139         try {\n// 调用 \"android.security.keystore\"的接口，这个地方注意KeyStore是java.Security.keyStore,是Java的公共接口\n源码在libcore/ojluni/src/main/java/java/security/KeyStore.java\n\n140             KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n141             keyStore.load(null);\n142\n143             SecretKey decryptionKey = (SecretKey) keyStore.getKey(keyAlias, null);\n144             byte[] intermediate = decrypt(decryptionKey, blob);\n145             return decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate);\n146         } \n\n1055    public final Key getKey(String alias, char[] password)\n1056        throws KeyStoreException, NoSuchAlgorithmException,\n1057            UnrecoverableKeyException\n1058    {\n1062        return keyStoreSpi.engineGetKey(alias, password);\n1063    }\n这个keyStore的调用有点深，需要进一步查看， 最终进入了AndroidKeyStoreSpi.java内部\n```\n\n\n`KeyStore.getInstance(\"AndroidKeyStore\")`返回的的是`AndroidKeyStoreSpi`的实例，调用`getKey`方法，最终调到了`AndroidKeyStoreSpi`的`engineGetKey`\n\n[ciper](https://www.cnblogs.com/diegodu/p/6273611.html)\n\n\n```shell\n+- secret = decryptSPBlob<getHandleName(handle), Arrays.copyOfRange(blob, 2, blob.length), applicationId>  #SyntheticPasswordManager.java\n                                                            # handle blob applicationId 都可以解出\n  \\ +- decryptBlob(String keyAlias, byte[] blob, byte[] applicationId)  # SyntheticPasswordCrypto.java\n    \\ - KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");  #调用java se的公共接口，最终访问到了AndroidKeyStoreSpi\n    | +- keyStore.load(null); # AndroidkeyStoreSpi.engineLoad(param);\n       \\ - android.security.KeyStore.getInstance  # 调用到了 native keyStore \"android.security.keystore\" 实例，构造AndroidKeyStoreSpi的mKeyStore 对象， 该对象持有remote 端， native的 keyStore service\n    | +- SecretKey decryptionKey = (SecretKey) keyStore.getKey(keyAlias, null);\n       \\ +- AndroidkeyStoreSpi.engineGetKey(alias, password)   # passwd 为null， alias为 synthetic_password_<handle>值 getHandleName方法\n          \\ - String userKeyAlias = Credentials.USER_PRIVATE_KEY + alias; # USERKEY_synthetic_password_<handle>\n          | +- key = AndroidKeyStoreProvider.loadAndroidKeyStoreKeyFromKeystore(mKeyStore, userKeyAlias, mUid);\n             \\ - KeyCharacteristics keyCharacteristics = getKeyCharacteristics(keyStore, userKeyAlias, uid); # keyStore为上面实例的mKeyStore实例\n             | +- keyStore.getKeyCharacteristics(alias, null, null, uid, keyCharacteristics) # clientId为空 appid为空 android KeyStore.java\n          |      \\ - mBinder.getKeyCharacteristics(promise, alias, clientId, appId, uid);  #key_store_service.cpp 这个clientId appId 是构造了两个KeymasterBlob[new byte[0]] 出来，native层也有相应的类， KeymasterBlob.h\n                | +- return loadAndroidKeyStoreSecretKeyFromKeystore(userKeyAlias, uid, keyCharacteristics)\n                   \\ - Integer keymasterAlgorithm = keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM); #获得加密算法\n          |         | - List<Integer> keymasterDigests = keyCharacteristics.getEnums(KeymasterDefs.KM_TAG_DIGEST);\n                   | - keyAlgorithmString = fromKeymasterSecretKeyAlgorithm(keymasterAlgorithm, keymasterDigest); # 解出来为AES\n                   | +- return new AndroidKeyStoreSecretKey(secretKeyAlias, uid, keyAlgorithmString);\n          |           \\ - AndroidKeyStoreKey(String alias, int uid, String algorithm) # mAlias mUid mAlgorithm   # AndroidKeyStoreKey 构造函数\n   | +- byte[] intermediate = decrypt(decryptionKey, blob); # SyntheticPasswordCrypto.java 获得key后进行解密 blob为spblob读出的数据\n      \\ - byte[] iv = Arrays.copyOfRange(blob, 0, PROFILE_KEY_IV_SIZE); #初始化向量\n      | - byte[] ciphertext = Arrays.copyOfRange(blob, PROFILE_KEY_IV_SIZE, blob.length); # 密文\n      | - Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n                  + KeyProperties.BLOCK_MODE_GCM + \"/\" + KeyProperties.ENCRYPTION_PADDING_NONE); # AES/GCM/NoPadding\n        \\ - cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(DEFAULT_TAG_LENGTH_BITS, iv));   #解密数据 128 GCMParameterSpec怎么构造？ key为SecurityKey类型， C++怎么构造\n        | - return cipher.doFinal(ciphertext); # ciphertext是密文，解密出明文\n   | +- return decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate); # intermediate为上面Cipher解出的明文\n      \\ - byte[] keyHash = personalisedHash(personalisation, keyBytes); # APPLICATION_ID_PERSONALIZATION 和 APPLICATION_ID_PERSONALIZATION\n      | - SecretKeySpec key = new SecretKeySpec(Arrays.copyOf(keyHash, AES_KEY_LENGTH), AES); # javax.crypto.spec.SecretKeySpec\n      | - decrypt(key, ciphertext) #此处ciphertext为上面的解出的intermediate， 重复上面的流程\n```\n\n从keyStore的模型上看，涉及的模块较多，如果多机型是同样的解密算法的话，解密流程还是可以还原的。 但从实现上看，预估不同机型的不同平台上的解密插件是不同的，如果做定制的话，涉及的解析debug 转换java代码很多。 当前流程涉及到了很多java的sdk的类，这些类怎么转换成native的代码也是一个大问题。 而解密这块，目前涉及到AES/GCM/NoPadding的解密，native层可以使用openssl的库来完成。 ^a300bf\n\n\n上述密码解出后，还有最后一步，即验证用户密码是否正确。\n这个主要涉及到gatekeeper的校验\n```java\n         result.authToken = unwrapSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED,\n 937                 applicationId, sid, userId);\n 938\n 939         // Perform verifyChallenge to refresh auth tokens for GK if user password exists.\n 940         result.gkResponse = verifyChallenge(gatekeeper, result.authToken, 0L, userId);\n\n43     public @Nullable VerifyCredentialResponse verifyChallenge(IGateKeeperService gatekeeper,\n  1044             @NonNull AuthenticationToken auth, long challenge, int userId) throws RemoteException {\n  1045         byte[] spHandle = loadSyntheticPasswordHandle(userId);\n  1051         VerifyCredentialResponse result;\n> 1052         GateKeeperResponse response = gatekeeper.verifyChallenge(userId, challenge,\n  1053                 spHandle, auth.deriveGkPassword());\n  1054         int responseCode = response.getResponseCode();\n  1055         if (responseCode == GateKeeperResponse.RESPONSE_OK) {\n  1056             result = new VerifyCredentialResponse(response.getPayload());\n  1057             if (response.getShouldReEnroll()) {\n  1058                 response = gatekeeper.enroll(userId, spHandle,\n  1059                         spHandle, auth.deriveGkPassword());\n  1060                 if (response.getResponseCode() == GateKeeperResponse.RESPONSE_OK) {\n  1061                     spHandle = response.getPayload();\n  1062                     saveSyntheticPasswordHandle(spHandle, userId);\n  1063                     // Call self again to re-verify with updated handle\n> 1064                     return verifyChallenge(gatekeeper, auth, challenge, userId);\n  1065                 }\n  1069             }\n  1070         } else if (responseCode == GateKeeperResponse.RESPONSE_RETRY) {\n  1071             result = new VerifyCredentialResponse(response.getTimeout());\n  1072         } else {\n  1073             result = VerifyCredentialResponse.ERROR;\n  1074         }\n  1075         return result;\n  1076     }\n```\n```shell\n+++++++++++-- verifyChallenge --+++++++++\n+- verifyChallenge(gatekeeper, result.authToken, 0L, userId); #SyntheticPasswordManager.java\n  \\ - byte[] spHandle = loadSyntheticPasswordHandle(userId); # /data/system_de/0/spblob/*.handle\n  | - response = gatekeeper.verifyChallenge(userId, challenge, spHandle, auth.deriveGkPassword()); # chanllenge 为 0\n     \\ +- auth.deriveGkPassword()\n        \\ -  derivePassword(PERSONALIZATION_SP_GK_AUTH)\n          \\ - new SP800Derive(syntheticPassword.getBytes().withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT);\n            \\ - Mac m = Mac.getInstance(\"HmacSHA256\"); m.init(new SecretKeySpec(syntheticPassword, m.getAlgorithm())); # javax.crypto.Mac\n              \\ - spi.engineInit(key, params); #javax/crypto/Mac.java\n     |          \\ - init(key, params) #AndroidKeyStoreHmacSpi.java params为空\n                | - ensureKeystoreOperationInitialized()\n                   \\ - mKeyStore.begin(mKey.getAlias(), KeymasterDefs.KM_PURPOSE_SIGN, true,keymasterArgs, ... )\n                      \\ - mBinder.begin(promise, getToken(), alias, purpose, pruneable, args, entropy, uid) # /system/core/keystore\n                      | - mChunkedStreamer = new KeyStoreCryptoOperationChunkedStreamer(\n                            new KeyStoreCryptoOperationChunkedStreamer.MainDataStream(\n                            mKeyStore, mOperationToken));    #后面update会用到,保存keystore和oprationtoken\n            | - withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT); #SP800Derive\n               \\ - m.update(label);\n     |             \\ - engineUpdate(new byte[] {input}, 0, 1);\n                      \\ -  mChunkedStreamer.update(input, offset, len)\n                         \\ - mKeyStoreStream.update(chunk)\n                             \\ - mKeyStore.update(mOperationToken, null, input)\n                                 \\ - mBinder.update(promise, token, arguments, input)\n               | - m.doFinal()      #SP800Derive.java\n                  \\ - spi.engineDoFinal()\n                      \\ -  engineDoFinal()\n                          \\ - return result = mChunkedStreamer.doFinal(null, 0, 0, null, null);\n                             \\ - output = update(input, inputOffset, inputLength)\n                                 \\ - mKeyStoreStream.update(chunk)\n                                     \\ - mKeyStore.update(mOperationToken, null, input)\n                                        \\ - mBinder.update(promise, token, arguments, input)\n                             | -  mKeyStoreStream.finish(signature, additionalEntropy)\n                                 \\ - mKeyStore.finish(mOperationToken, null, signature, additionalEntropy)\n                                     \\ - mBinder.finish(promise, token, arguments, signature, entropy);\n                  | - spi.engineReset()\n                     \\ - resetWhilePreservingInitState()\n     | - verifyChallenge(uid, challenge, (uint8_t *) currentPasswordHandle,\n                    currentPasswordHandleSize, (uint8_t *) currentPassword, currentPasswordSize,\n                    &out, &outSize, &request_reenroll); # system/core/gatekeeperd/IGateKeeperService.cpp\n        \\ -  verifyChallenge(uint32_t uid, uint64_t challenge,\n            const uint8_t *enrolled_password_handle, uint32_t enrolled_password_handle_length,\n            const uint8_t *provided_password, uint32_t provided_password_length,\n            uint8_t **auth_token, uint32_t *auth_token_length, bool *request_reenroll) #gatekeeperd.cpp 返回结果为auth_token, 如执行成功，                                                         reply->writeInt32(GATEKEEPER_RESPONSE_OK); reply->writeInt32(request_reenroll ? 1 : 0);\n  | - result = new VerifyCredentialResponse(response.getPayload()); # 执行成功，校验成功满足 GATEKEEPER_RESPONSE_OK 条件\n     \\ -  mResponseCode = RESPONSE_OK;   #  VerifyCredentialResponse payload构造函数\n  | - response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK # 校验成功， 解锁成功\n```\n\n经过debug， Mac.getInstance(\"HmacSHA256\")，并init后得到的并不是`AndroidKeyStoreHmacSpi`的实例，而是OpenSSLMac，代码位于`/external/conscrypt/repackaged/common/src/main/java/com/android/org/conscrypt/`\n```shell\n 01-09 17:41:15.323  2608  2833 E zlg:    : getMac: spi com.android.org.conscrypt.OpenSSLMac.HmacSHA256 getProvider: com.android.org.conscrypt.OpenSSLProvider\n```\n\n```shell\n+++++++++++-- verifyChallenge --+++++++++\n+- verifyChallenge(gatekeeper, result.authToken, 0L, userId); #SyntheticPasswordManager.java\n  \\ - byte[] spHandle = loadSyntheticPasswordHandle(userId); # /data/system_de/0/spblob/*.handle\n  | - response = gatekeeper.verifyChallenge(userId, challenge, spHandle, auth.deriveGkPassword()); # chanllenge 为 0\n     \\ +- auth.deriveGkPassword()\n        \\ -  derivePassword(PERSONALIZATION_SP_GK_AUTH)\n          \\ - new SP800Derive(syntheticPassword.getBytes().withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT);\n            \\ - Mac m = Mac.getInstance(\"HmacSHA256\"); m.init(new SecretKeySpec(syntheticPassword, m.getAlgorithm())); # javax.crypto.Mac\n              \\ - super(EvpMdRef.SHA256.EVP_MD, EvpMdRef.SHA256.SIZE_BYTES); #OpenSSLMac.java \n                 \\ - NativeCrypto.EVP_get_digestbyname(\"sha256\") # libopenssl\n              | - spi.engineInit(key, params); #javax/crypto/Mac.java\n                \\ - resetContext(); #OpenSSLMac.java\n                  \\ - new NativeRef.HMAC_CTX(NativeCrypto.HMAC_CTX_new()) #libopenssl\n                  | - NativeCrypto.HMAC_Init_ex(ctxLocal, keyBytes, evp_md)\n            | - withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT); #SP800Derive\n               \\ - m.update(label);\n     |             \\ - engineUpdate(singleByte, 0, 1); # OpenSSLMac.java\n                      \\ -  NativeCrypto.HMAC_Update(ctxLocal, input, offset, len) #OpenSSLMac.java\n               | - m.doFinal()      #SP800Derive.java\n                  \\ - spi.engineDoFinal()\n                     \\ - engineDoFinal() #OpenSSLMac.java\n                        \\ - output = NativeCrypto.HMAC_Final(ctxLocal); # libopenssl\n                        | - resetContext();\n     | - verifyChallenge(uid, challenge, (uint8_t *) currentPasswordHandle,\n                    currentPasswordHandleSize, (uint8_t *) currentPassword, currentPasswordSize,\n                    &out, &outSize, &request_reenroll); # system/core/gatekeeperd/IGateKeeperService.cpp\n        \\ -  verifyChallenge(uint32_t uid, uint64_t challenge,\n            const uint8_t *enrolled_password_handle, uint32_t enrolled_password_handle_length,\n            const uint8_t *provided_password, uint32_t provided_password_length,\n            uint8_t **auth_token, uint32_t *auth_token_length, bool *request_reenroll) #gatekeeperd.cpp 返回结果为auth_token, 如执行成功，                                                         reply->writeInt32(GATEKEEPER_RESPONSE_OK); reply->writeInt32(request_reenroll ? 1 : 0);\n  | - result = new VerifyCredentialResponse(response.getPayload()); # 执行成功，校验成功满足 GATEKEEPER_RESPONSE_OK 条件\n     \\ -  mResponseCode = RESPONSE_OK;   #  VerifyCredentialResponse payload构造函数\n  | - response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK # 校验成功， 解锁成功\n```\n从上述实现看， OpenSSLMac 的实现相对比较简单，都是直接调到native 的libopenssl库中，而AndroidKeyStoreHmacSpi的实现方式则复杂很多，本身上层代码经过了很复杂的处理，最后又通过keystore进行加解密。\n\n### 1.4.1. Cipher 封装\n测试下来，Cipher 的AES解密成功的条件是gatekeeper需要先\n```java\ngatekeeper.verifyChallenge(fakeUid(userId), 0L,\n 898                     pwd.passwordHandle, gkPwdToken)；\n```\n这里有必要对Cipher AES的Android封装过程调研一下。\n```java\n   public static byte[] decryptBlob(String keyAlias, byte[] blob, byte[] applicationId) {\n            KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n            keyStore.load(null);\n            SecretKey decryptionKey = (SecretKey) keyStore.getKey(keyAlias, null);\n            byte[] intermediate = decrypt(decryptionKey, blob);\n            return decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate);\n}\n\n    private static byte[] decrypt(SecretKey key, byte[] blob)\n            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n            InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        byte[] iv = Arrays.copyOfRange(blob, 0, PROFILE_KEY_IV_SIZE);\n        byte[] ciphertext = Arrays.copyOfRange(blob, PROFILE_KEY_IV_SIZE, blob.length);\n        Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n                + KeyProperties.BLOCK_MODE_GCM + \"/\" + KeyProperties.ENCRYPTION_PADDING_NONE);\n        cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(DEFAULT_TAG_LENGTH_BITS, iv));\n        return cipher.doFinal(ciphertext);\n    }\n```\n前面的过程如keystore的getInstace 和 load函数大部分都调研完了，需要注意的是Cipher的这个地方还没看\n```shell\n+ - Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n  \\ - javax.crypto.Cipher.createCipher(trans, null)\n     \\ -  cipherSpiAndProvider =  tryCombinations(null /*params*/, null, tokenizedTransformation);\n        \\ -  CipherSpiAndProvider sap = tryTransformWithProvider(null, tokenizedTransformation, transform.needToSet, service); #获得对应的Provider，这个应该最终指向了 android.security.keystore.AndroidKeyStoreBCWorkaroundProvider\n           \\ - Cipher spi = sap.cipherSpi   # 指向AndroidKeyStoreCipherSpiBase.java\n| - cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(DEFAULT_TAG_LENGTH_BITS, iv)); #SyntheticPasswordCrypto.java\n   \\ - init(opmode, key, params, JceSecurity.RANDOM); #Cipher.java\n      \\ - chooseProvider(InitType.ALGORITHM_PARAM_SPEC, DECRYPT_MODE, key, params, null, random);\n         \\ - spiAndProviderUpdater.updateAndGetSpiAndProvider(initParams, spi, provider);\n           \\ - tryTransformWithProvider(initParams, tokenizedTransformation, transform.needToSet, service);\n              \\ - spi.engineSetMode(tokenizedTransformation[1]);\n              | - spi.engineSetPadding(tokenizedTransformation[2]);\n              | - spi.engineInit(initParams.opmode, initParams.key, initParams.spec, initParams.random);\n                \\ -  init(opmode, key, random); \n                | - initAlgorithmSpecificParameters(params);\n                | - ensureKeystoreOperationInitialized();\n                   \\ -  byte[] additionalEntropy = EmptyArray.BYTE;\n                   | - KeymasterArguments keymasterInputArgs = new KeymasterArguments();\n                   | - purpose = KeymasterDefs.KM_PURPOSE_DECRYPT;\n                   | - mKeyStore.begin(mKey.getAlias(), purpose, true, keymasterInputArgs, additionalEntropy, mKey.getUid()); #调进native的keystore中                              \n| - cipher.doFinal(ciphertext) #SyntheticPasswordCrypto.java\n   \\ - updateProviderIfNeeded(); \n      \\ - spiAndProviderUpdater.updateAndGetSpiAndProvider(null, spi, provider);\n        \\ - return new CipherSpiAndProvider(sap.cipherSpi, sap.provider); \n   | -  return spi.engineDoFinal(input, 0, input.length);\n      \\ - ensureKeystoreOperationInitialized()\n          \\ -  byte[] additionalEntropy = EmptyArray.BYTE;\n          | - KeymasterArguments keymasterInputArgs = new KeymasterArguments();\n          | - purpose = KeymasterDefs.KM_PURPOSE_DECRYPT;\n          | - OperationResult opResult = mKeyStore.begin(mKey.getAlias(), purpose, true, keymasterInputArgs, additionalEntropy, mKey.getUid()); #调进native的keystore中\n          | - loadAlgorithmSpecificParametersFromBeginResult(opResult.outParams)\n             \\ - byte[] returnedIv = keymasterArgs.getBytes(KeymasterDefs.KM_TAG_NONCE, null);\n             | - if (mIvRequired) mIv = returnedIv  # mIvRequired应该是false，没看到赋值的地方，可以加log验证\n          | - mMainDataStreamer = createMainDataStreamer(mKeyStore, opResult.token); #mKeyStore为android KeyStore的instance，其对端即为native的keystore\n             \\ - return new KeyStoreCryptoOperationChunkedStreamer(                                                                                                                          \n                     new KeyStoreCryptoOperationChunkedStreamer.MainDataStream(keyStore, operationToken)); # 用到了keystore返回的参数token\n          |- mAdditionalAuthenticationDataStreamer = createAdditionalAuthenticationDataStreamer(mKeyStore, opResult.token); \n             \\ - return new KeyStoreCryptoOperationChunkedStreamer(\n                    new AdditionalAuthenticationDataStream(keyStore, operationToken)); \n      | - flushAAD()\n         \\ - output = mAdditionalAuthenticationDataStreamer.doFinal(EmptyArray.BYTE, 0 , 0 ,null, null);\n            \\ - output = update(input, inputOffset, inputLength);\n               \\ - mKeyStoreStream.update(chunk)  #经过了复杂的流程，最终调到这里 \n                  \\ - keymasterArgs.addBytes(KeymasterDefs.KM_TAG_ASSOCIATED_DATA, input);\n                  | - mKeyStore.update(mOperationToken, keymasterArgs, null);    #AdditionalAuthenticationDataStream  # - 1.\n                     \\ - output = new OperationResult(result.resultCode, result.token, result.operationHandle, input.length, result.output, result.outParams);\n            | - output = ArrayUtils.concat(output, flush()); #flush又是一个复杂的函数     \n            | - OperationResult opResult = mKeyStoreStream.finish(null, null)；\n               \\ - return new OperationResult(KeyStore.NO_ERROR, mOperationToken, 0 ,0 , EmptyArray.BYTE, new KeymasterArguments());\n            | - return ArrayUtils.concat(output, opResult.output);\n      | - output = mMainDataStreamer.doFinal(input, offset, len, null, EmptyArray.BYTE);\n         \\ - output = update(input, inputOffset, inputLength);\n            \\ - mKeyStoreStream.update(chunk)  #经过了复杂的流程，最终调到这里\n               \\ -  return mKeyStore.update(mOperationToken, null, input);  # - 2. \n         | - output = ArrayUtils.concat(output, flush()); #flush又是一个复杂的函数     \n         | - OperationResult opResult = mKeyStoreStream.finish(null, EmptyArray.BYTE)；\n           \\ - opResult = mKeyStore.finish(mOperationToken, null, null, EmptyArray.BYTE); # - 3.\n         | - return ArrayUtils.concat(output, opResult.output);\n         | - return output\n```\n从上面的流程看，经历的过程很复杂，而经过native keystore的操作有\n 1. mKeyStore.update(mOperationToken, keymasterArgs, null);\n 2. mKeyStore.update(mOperationToken, null, input);\n 3. mKeyStore.finish(mOperationToken, null, null, EmptyArray.BYTE); \n最终finish 结束了访问， 获得了结果， 而再keystore update 和 finish前 Java层又经过了一系列的转换数据的操作。包括数据分片的处理\n\n\ngatekeeperd 守护进程会向 Android 框架 API 授予访问 HAL 的权限，并且会参与向 Keystore 报告设备身份验证的活动。gatekeeperd 守护进程会在自己的进程中运行，与系统服务器隔离开来。\n\nLockSettingsService 会通过 Binder 发出一个请求，该请求会到达 Android 操作系统中的 gatekeeperd 守护进程。gatekeeperd 守护进程会发出一个请求，该请求会到达此守护进程在 TEE 中的副本 (Gatekeeper)：\n\n![gatekeeper](images/20200527161613.png)\n\n每次密码验证成功时生成的身份验证令牌 (AuthToken)\n用户安全 ID (SID)\n\n每当用户注册新密码时，如果未提供之前的密码，系统就会使用加密伪随机数生成器 (PRNG) 生成一个用户 SID。这称为“不可信”重新注册，在正常情况下，Android 框架不允许进行这种操作。如果用户提供了之前的有效密码，便会发生“可信”重新注册；在这种情况下，用户 SID 会迁移到新密码句柄，从而保留绑定到它的密钥。\n\n注册密码时，用户 SID 会随密码句柄中的密码一起接受 HMAC 处理。\n用户 SID 会写入到 verify 函数返回的 AuthToken 中，并且会同所有与身份验证绑定的 Keystore 密钥相关联（如需详细了解 AuthToken 格式和 Keystore，请参阅身份验证）。由于对 enroll 函数的不可信调用会更改用户 SID，因此此类调用会使绑定到相应密码的密钥无法再使用。攻击者在控制 Android 操作系统后可以更改设备密码，但在此过程中，他们需要破坏掉受 Root 保护的敏感密钥。\n\n#### 1.4.1.1. 身份验证\n\n用户设置凭据并收到用户 SID 后，便可以开始进行身份验证，身份验证从用户提供 PIN 码、解锁图案、密码或指纹开始。所有 TEE 组件都共用一个密钥来验证对方的消息。\n\n![身份验证](images/20200527161620.png)\n\n对于 PIN 码、解锁图案或密码，LockSettingsService 会向 gatekeeperd 发出请求。守护进程将数据发至其副本，后者生成 AuthToken：对于 PIN 码/解锁图案/密码身份验证，gatekeeperd 将 PIN 码、解锁图案或密码哈希发送到 TEE 中的 Gatekeeper。如果 TEE 中的身份验证成功，TEE 中的 Gatekeeper 会将包含相应用户 SID（已使用 AuthToken HMAC 密钥签名）的 AuthToken 发送到它在 Android 操作系统中的副本。\n守护进程收到经过签名的 AuthToken，并通过 Keystore 服务 Binder 接口的扩展程序将 AuthToken 传递给 Keystore 服务。（gatekeeperd 还会在设备被重新锁定以及设备密码发生变化时通知 Keystore 服务。）\nKeystore 服务将 AuthToken 传递给 Keymaster，并使用与 Gatekeeper 和支持的生物识别 TEE 组件共用的密钥来验证这些 AuthToken。Keymaster 会将令牌中的时间戳视为最后一次身份验证的时间，并根据该时间戳做出密钥发布决定（以允许应用使用相应密钥）。\n\ndebug验证时，keystore解密的工作前需要gatekeeper先通过对用户密码的验证，验证正确后，gatekeeperd 守护进程会向 Android 框架 API 授予访问 HAL 的权限，并且会参与向 Keystore 报告设备身份验证的活动。keystore才可以使用，而在apk demo中碰到了`android.security.KeyStoreException: Signature/MAC verification failed\n`的问题，在手机解锁后执行也报这样的错误，可能与gatekeeper的授权有关。因为gatekeeper的访问不在public api中，需要进一步在编译系统中构建应用验证。如果没有验证用户安全密码，则会报`android.security.keystore.KeyPermanentlyInvalidatedException: Key permanently invalidated`的异常。","tags":["fbe"],"categories":["文件系统","加密"]},{"title":"clion vscode 阅读Android native源码","url":"/2019/07/20/工作相关/clion 阅读调试Android native源码/","content":"\n# 1. clion vscode 阅读Android native源码\n\n## 1.1. 为native源码编译生成cmake文件\n\n```bash\nexport SOONG_GEN_CMAKEFILES=1\nexport SOONG_GEN_CMAKEFILES_DEBUG=1\n```\n将上面两句加入到~/.bashrc下, 以后新工程就不用重复export了\n\n源码source lunch后, 直接make随便一个module即可.\ncmake文件会生成在源码根目录的out/development/ide/clion下\n\n## 1.2. 使用clion导入native工程\n\n可以直接看单module, \nfile->new cmake project from sources\n\n\n\n\n但多个module 需要手动写cmake 引进子的module, 重复工作量大, 而且soong生成的cmake 同一module包含多个子目标\n\n```bash\ndrwxrwxr-x  2 mi mi 4096 3月  13 20:51 librecovery-arm64-android\ndrwxrwxr-x  2 mi mi 4096 3月  13 20:51 librecovery-arm-android\n```\n手动添加工作量比较大, 而且是重复工作\n\n这边提供一个脚本\n比如我想看 `miui-q-cepheus-dev `分支的  `bootable/recovery`/ `system/vold`等的源码, 可以这样写\n-    第一个参数: 建立的工程目录\n-    第二个参数: 哪套源码的\n-    第...个参数: 想看的子目录的源码\n```shell\nfind_and_add_cmake2.py cepheus-q-recovery miui-q-cepheus-dev bootable/recovery system/vold bionic/libc system/core/base system/core/fs_mgr system/core/crypto_test system/security/keystore system/gatekeeper system/core/libcutils system/core/init frameworks/base/media/jni\n```\n\n> 规则是 第一个参数: 工程目录位于~/program/cmake_work_space下, 建新的工程都会在该目录下创建工程的根目录\n> 第二个参数, 源码的根目录在 ~/work_space下, 这些文件夹可以自己修改脚本指定\n## 1.3. clion导入工程\n上面建的工程位于~/program/cmake_work_space下, clion 菜单 File->new cmake project from sources, 点击之前通过脚本建立的CMakeLists.txt文件导入, 点击`Open Existing Project`即可, 等待symbol加载完成.\n\n# 2. clion gdb remote debug native源码\n\n### 2.1.1. 手机端设置gdbserver\n```shell\n# 进程已经启动的情况下\nps -e ; #查找native进程的pid\ngdbserver64 --attach :8888 <pid>\n# 进程未启动情况下\ngdbserver64 :8888 /system/bin/recovery\n```\npc 端\n```shell\nadb forward tcp:8888 tcp:8888\n```\n\n### 2.1.2. clion 端配置\n参考下图\nRun->Edit Configurations\n\n+ Templates\n\n![](images/20200525151202.png)\n注意上面的几个参数都要配置正确\n\n- gdb: 源码下的prebuilts/gdb/linux-x86/bin/gdb\n- target remote args tcp:127.0.0.1:8888\n- path mappings: 注意映射完整路径\n\n# 3. vscode gdb remote debug\n\n将prebuilts/gdb/linux-x86/bin/gdb 和 gdb orig 链接到环境变量下的系统目录中,或者单独加入到环境变量下\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n      {\n          \"name\": \"(gdb) Remote Launch\",\n          \"type\": \"cppdbg\",\n          \"request\": \"launch\",\n          \"miDebuggerServerAddress\": \"127.0.0.1:8888\",\n          \"program\": \"/home/mi/work_space/miui-q-umi-dev/out/target/product/cmi/symbols/exaid/root/sbin/exaid\",\n          \"args\": [],\n          \"stopAtEntry\": false,\n          \"cwd\": \"${workspaceFolder}\",\n          \"environment\": [],\n          \"externalConsole\": false,\n          \"sourceFileMap\": {\n              \"bootable/exaid\": \"/home/mi/work_space/miui-q-umi-dev/bootable/exaid\"\n          },\n          \"logging\": {\n              \"trace\": true,\n              \"traceResponse\": true,\n              \"engineLogging\": true,\n          },\n          \"MIMode\": \"gdb\",\n      }\n  ]\n}\n```\n\n# gdb init\n\n```python\ndefine target hookpost-remote\nset solib-absolute-prefix /home/mi/work_space/miui-r-umi-dev/out/target/product/cmi/symbols/\nend\n```\n\n# stl 支持\n\n默认情况下不支持stl 输出, 需要gdb支持python脚本, 一般需要自己编译.\n\n另外需要定制gdbinit, android上废弃了stlport和gnustl的支持, 只支持libc++的方式集成stl.\n\n所以python解析脚本是基于libc++开发的, 这里提供一下github上的一个脚本\n\nhttps://github.com/koutheir/libcxx-pretty-printers\n\n同时, vscode的launch.json也要配置打开 pretty-printers\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n      {\n          \"name\": \"(gdb) Remote Launch\",\n          \"type\": \"cppdbg\",\n          \"request\": \"launch\",\n          \"miDebuggerServerAddress\": \"127.0.0.1:8888\",\n          \"program\": \"/home/mi/work_space/miui-r-umi-dev/out/target/product/cmi/symbols/system/bin/test_code_aaaaaaa\",\n          \"args\": [],\n          \"stopAtEntry\": true,\n          \"cwd\": \"${workspaceFolder}\",\n          \"environment\": [],\n          \"externalConsole\": true,\n          \"sourceFileMap\": {\n              \"system/core/crypto_test\": \"/home/mi/work_space/miui-r-umi-dev/system/core/test_code\"\n          },\n          \"logging\": {\n              \"trace\": true,\n              \"traceResponse\": true,\n              \"engineLogging\": true,\n          },\n          \"MIMode\": \"gdb\",\n          \"miDebuggerPath\": \"/home/mi/Programs/gdb/bin/aarch64-linux-android-gdb\",\n          //\"miDebuggerPath\": \"/home/mi/work_space/miui-r-umi-dev/prebuilts/gdb/linux-x86/bin/gdb\",\n          \"setupCommands\": [\n            {\n            \"description\": \"Enable pretty-printing for gdb\",\n            \"text\": \"-enable-pretty-printing\",\n            \"ignoreFailures\": true\n            },\n          ],\n      }\n  ]\n}\n```\n\n","tags":["clion","gdb","vscode"],"categories":["debug"]},{"title":"OTA相关/ext3读写过程分析 .md","url":"/2019/07/12/OTA相关/ext3读写过程分析 /","content":"\n# 1. Ext3文件系统读写过程分析\n\n\n\n## 1.1. Ext3文件读写流程概述\n\n Ext3文件系统在进行读写操作的时候，首先需要open相应的文件，然后再进行读写操作。在open操作时，Linux kernel会创建一个file对象描述这个文件。File对象和文件的dentry和inode对象建立联系，并且将ext3的文件操作方法、映射处理方法（address space）注册到file对象中。 \n\nExt3文件读写过程会涉及到VFS层的**page cache**，并且通常的读写操作都会使用到这层page cache，目的是提高磁盘的IO性能。在Linux中后台会运行writeback线程定时同步pagecache和设备之间的数据。Page cache的方式虽然能够提高IO性能，但是也对数据的安全性带来了潜在影响。 \n\n本文的目的是分析ext3文件系统读写流程中的关键函数，对于page cache原理以及writeback机制将在后继文章中做深入分析。\n\n \n\n## 1.2. 关键数据结构\n\n \n\nFile数据结构是Linux用来描述文件的关键数据结构，该对象在一个文件被进程打开的时候被创建。当一个文件被关闭的时候，file对象也会被立即销毁。file数据结构不会被作为元数据信息持久化保存至设备。该数据结构定义如下： \n\n```c\nstruct file {  \n    /*  \n     * fu_list becomes invalid after file_free is called and queued via  \n     * fu_rcuhead for RCU freeing  \n     */  \n    union {  \n        struct list_head    fu_list;  \n        struct rcu_head     fu_rcuhead;  \n    } f_u;  \n    struct path     f_path;     /* 文件路径，包含文件dentry目录项和vfsmount信息 */  \n#define f_dentry    f_path.dentry  \n#define f_vfsmnt    f_path.mnt  \n    const struct file_operations    *f_op;  /* 文件操作函数集 */  \n \n    /*  \n     * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.  \n     * Must not be taken from IRQ context.  \n     */  \n    spinlock_t      f_lock;  \n#ifdef CONFIG_SMP  \n    int         f_sb_list_cpu;  \n#endif  \n    atomic_long_t       f_count;  \n    unsigned int        f_flags;  \n    fmode_t         f_mode; /* 文件操作模式 */  \n    loff_t          f_pos;  \n    struct fown_struct  f_owner;  \n    const struct cred   *f_cred;  \n    struct file_ra_state    f_ra;  \n \n    u64         f_version;  \n#ifdef CONFIG_SECURITY  \n    void            *f_security;  \n#endif  \n    /* needed for tty driver, and maybe others */  \n    void            *private_data;  \n \n#ifdef CONFIG_EPOLL  \n    /* Used by fs/eventpoll.c to link all the hooks to this file */  \n    struct list_head    f_ep_links;  \n    struct list_head    f_tfile_llink;  \n#endif /* #ifdef CONFIG_EPOLL */  \n    struct address_space    *f_mapping; /* address space映射信息，指向inode中的i_mapping */  \n#ifdef CONFIG_DEBUG_WRITECOUNT  \n    unsigned long f_mnt_write_state;  \n#endif  \n}; \n```\n\n每个文件在内存中都会对应一个inode对象。在设备上也会保存每个文件的inode元数据信息，通过inode元数据信息可以找到该文件所占用的所有文件数据块（block）。VFS定义了一个通用的inode数据结构，同时ext3定义了ext3_inode元数据结构。在创建内存inode对象时，需要采用ext3_inode元数据信息初始化inode对象。Inode数据结构定义如下：\n\n```c\n struct inode {  \n    umode_t         i_mode;  \n    unsigned short      i_opflags;  \n    uid_t           i_uid;  \n    gid_t           i_gid;  \n    unsigned int        i_flags;  \n \n#ifdef CONFIG_FS_POSIX_ACL  \n    struct posix_acl    *i_acl;  \n    struct posix_acl    *i_default_acl;  \n#endif  \n \n    const struct inode_operations   *i_op;  /* inode操作函数集 */  \n    struct super_block  *i_sb;      /* 指向superblock */  \n    struct address_space    *i_mapping; /* 指向当前使用的页缓存的映射信息 */  \n \n#ifdef CONFIG_SECURITY  \n    void            *i_security;  \n#endif  \n \n    /* Stat data, not accessed from path walking */  \n    unsigned long       i_ino;  \n    /*  \n     * Filesystems may only read i_nlink directly.  They shall use the  \n     * following functions for modification:  \n     *  \n     *    (set|clear|inc|drop)_nlink  \n     *    inode_(inc|dec)_link_count  \n     */  \n    union {  \n        const unsigned int i_nlink;  \n        unsigned int __i_nlink;  \n    };  \n    dev_t           i_rdev;     /* 设备号，major&minor */  \n    struct timespec     i_atime;  \n    struct timespec     i_mtime;  \n    struct timespec     i_ctime;  \n    spinlock_t      i_lock; /* i_blocks, i_bytes, maybe i_size */  \n    unsigned short          i_bytes;  \n    blkcnt_t        i_blocks;   /* 文件块数量 */  \n    loff_t          i_size;  \n \n#ifdef __NEED_I_SIZE_ORDERED  \n    seqcount_t      i_size_seqcount;  \n#endif  \n \n    /* Misc */  \n    unsigned long       i_state;  \n    struct mutex        i_mutex;  \n \n    unsigned long       dirtied_when;   /* jiffies of first dirtying */  \n \n    struct hlist_node   i_hash; /* 连接到inode Hash Table中 */  \n    struct list_head    i_wb_list;  /* backing dev IO list */  \n    struct list_head    i_lru;      /* inode LRU list */  \n    struct list_head    i_sb_list;  \n    union {  \n        struct list_head    i_dentry;  \n        struct rcu_head     i_rcu;  \n    };  \n    atomic_t        i_count;  \n    unsigned int        i_blkbits;  /* 块大小，通常磁盘块大小为512字节，因此i_blkbits为9 */  \n    u64         i_version;  \n    atomic_t        i_dio_count;  \n    atomic_t        i_writecount;  \n    const struct file_operations    *i_fop; /* former ->i_op->default_file_ops，文件操作函数集 */  \n    struct file_lock    *i_flock;  \n    struct address_space    i_data; /* 页高速缓存映射信息 */  \n#ifdef CONFIG_QUOTA  \n    struct dquot        *i_dquot[MAXQUOTAS];  \n#endif  \n    struct list_head    i_devices;  \n    union {  \n        struct pipe_inode_info  *i_pipe;        /* 管道设备 */  \n        struct block_device *i_bdev;    /* block device块设备 */  \n        struct cdev     *i_cdev;    /* 字符设备 */  \n    };  \n \n    __u32           i_generation;  \n \n#ifdef CONFIG_FSNOTIFY  \n    __u32           i_fsnotify_mask; /* all events this inode cares about */  \n    struct hlist_head   i_fsnotify_marks;  \n#endif  \n \n#ifdef CONFIG_IMA  \n    atomic_t        i_readcount; /* struct files open RO */  \n#endif  \n    void            *i_private; /* fs or device private pointer */  \n}; \n```\n\n  \n\n##读过程源码分析\n\n Ext3文件系统读过程相对比较简单，函数调用关系如下图所示：\n\n[![img](https://s1.51cto.com/attachment/201301/003443623.jpg)](https://s1.51cto.com/attachment/201301/003443623.jpg) \n\n \n\n读过程可以分为两大类：Direct_io方式和page_cache方式。对于Direct_io方式，首先通过filemap_write_and_wait_range函数将page cache中的数据与设备同步并且无效掉page cache中的内容，然后再通过ext3提供的direct_io方法从设备读取数据。\n\n另一种是直接从page cache中获取数据，通过do_generic_file_read函数实现该方式。该函数的主要流程说明如下：\n\n1，通过读地址从page cache的radix树中获取相应的page页。\n\n2，如果对应的page页不存在，那么需要创建一个page，然后再从设备读取相应的数据更新至page页。\n\n3，当page页准备完毕之后，从页中拷贝数据至用户空间，page_cache方式的读操作完成。\n\n \n\n**写过程源码分析**\n\n \n\nExt3的写过程主要分为direct_io写过程和page cache写过程两大类，整个写过程的函数调用关系如下图所示：\n\n[![img](https://s1.51cto.com/attachment/201301/003523223.jpg)](https://s1.51cto.com/attachment/201301/003523223.jpg) \n\n \n\n写操作的核心函数是__generic_file_aio_write，该函数实现如下：\n\n```c\nssize_t __generic_file_aio_write(struct kiocb *iocb, const struct iovec *iov,  \n                 unsigned long nr_segs, loff_t *ppos)  \n{  \n    struct file *file = iocb->ki_filp;  \n    /* 获取address space映射信息 */  \n    struct address_space * mapping = file->f_mapping;  \n    size_t ocount;      /* original count */  \n    size_t count;       /* after file limit checks */  \n    struct inode    *inode = mapping->host; /* 获取文件inode索引节点 */  \n    loff_t      pos;  \n    ssize_t     written;  \n    ssize_t     err;  \n \n    ocount = 0;  \n    /* 检验数据区域是否存在问题，数据由iov数据结构管理 */  \n    err = generic_segment_checks(iov, &nr_segs, &ocount, VERIFY_READ);  \n    if (err)  \n        return err;  \n    /* ocount为可以写入的数据长度 */  \n    count = ocount;  \n    pos = *ppos;  \n \n    vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);  \n \n    /* We can write back this queue in page reclaim */  \n    current->backing_dev_info = mapping->backing_dev_info;  \n    written = 0;  \n    /* 边界检查，需要判断写入数据是否超界、小文件边界检查以及设备是否是read-only。如果超界，那么降低写入数据长度 */  \n    err = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));  \n    if (err)  \n        goto out;  \n    /* count为实际可以写入的数据长度，如果写入数据长度为0，直接结束 */  \n    if (count == 0)  \n        goto out;  \n \n    err = file_remove_suid(file);  \n    if (err)  \n        goto out;  \n \n    file_update_time(file);  \n \n    /* coalesce the iovecs and go direct-to-BIO for O_DIRECT */  \n    if (unlikely(file->f_flags & O_DIRECT)) {  \n        /* Direct IO操作模式，该模式会bypass Page Cache，直接将数据写入磁盘设备 */  \n        loff_t endbyte;  \n        ssize_t written_buffered;  \n        /* 将对应page cache无效掉，然后将数据直接写入磁盘 */  \n        written = generic_file_direct_write(iocb, iov, &nr_segs, pos,  \n                            ppos, count, ocount);  \n        if (written < 0 || written == count)  \n            /* 所有数据已经写入磁盘，正确返回 */  \n            goto out;  \n        /*  \n         * direct-io write to a hole: fall through to buffered I/O  \n         * for completing the rest of the request.  \n         */  \n        pos += written;  \n        count -= written;  \n        /* 有些请求由于没有和块大小（通常为512字节）对齐，那么将无法正确完成direct-io操作。在__blockdev_direct_IO 函数中会检查逻辑地址是否和块大小对齐，__blockdev_direct_IO无法处理不对齐的请求。另外，在ext3逻辑地址和物理块地址映射操作函数ext3_get_block返回失败时，无法完成buffer_head的映射，那么request请求也将无法得到正确处理。所有没有得到处理的请求通过 buffer写的方式得到处理。从这点来看，direct_io并没有完全bypass page cache，在有些情况下是一种写无效模式。generic_file_buffered_write函数完成buffer写，将数据直接写入page cache */  \n        written_buffered = generic_file_buffered_write(iocb, iov,  \n                        nr_segs, pos, ppos, count,  \n                        written);  \n        /*  \n         * If generic_file_buffered_write() retuned a synchronous error  \n         * then we want to return the number of bytes which were  \n         * direct-written, or the error code if that was zero.  Note  \n         * that this differs from normal direct-io semantics, which  \n         * will return -EFOO even if some bytes were written.  \n         */  \n        if (written_buffered < 0) {  \n            /* 如果page cache写失败，那么返回写成功的数据长度 */  \n            err = written_buffered;  \n            goto out;  \n        }  \n \n        /*  \n         * We need to ensure that the page cache pages are written to  \n         * disk and invalidated to preserve the expected O_DIRECT  \n         * semantics.  \n         */  \n        endbyte = pos + written_buffered - written - 1;  \n        /* 将page cache中的数据同步到磁盘 */  \n        err = filemap_write_and_wait_range(file->f_mapping, pos, endbyte);  \n        if (err == 0) {  \n            written = written_buffered;  \n            /* 将page cache无效掉，保证下次读操作从磁盘获取数据 */  \n            invalidate_mapping_pages(mapping,  \n                         pos >> PAGE_CACHE_SHIFT,  \n                         endbyte >> PAGE_CACHE_SHIFT);  \n        } else {  \n            /*  \n             * We don't know how much we wrote, so just return  \n             * the number of bytes which were direct-written  \n             */  \n        }  \n    } else {  \n        /* 将数据写入page cache。绝大多数的ext3写操作都会采用page cache写方式，通过后台writeback线程将page cache同步到硬盘 */  \n        written = generic_file_buffered_write(iocb, iov, nr_segs,  \n                pos, ppos, count, written);  \n    }  \nout:  \n    current->backing_dev_info = NULL;  \n    return written ? written : err;  \n} \n```\n\n \n\n从__generic_file_aio_write函数可以看出，ext3写操作主要分为两大类：一类为direct_io；另一类为buffer_io （page cache write）。Direct IO可以bypass page cache，直接将数据写入设备。下面首先分析一下direct_io的处理流程。\n\n如果操作地址对应的page页存在于page cache中，那么首先需要将这些page页中的数据同磁盘进行同步，然后将这些page缓存页无效掉，从而保证后继读操作能够从磁盘获取最新数据。在代码实现过程中，还需要考虑预读机制引入的page缓存页，所以在数据写入磁盘之后，需要再次查找page cache的radix树，保证写入的地址范围没有数据被缓存。\n\n \n\nGeneric_file_direct_write是处理direct_io的主要函数，该函数的实现如下：\n\n```c\nssize_t  \ngeneric_file_direct_write(struct kiocb *iocb, const struct iovec *iov,  \n        unsigned long *nr_segs, loff_t pos, loff_t *ppos,  \n        size_t count, size_t ocount)  \n{  \n    struct file *file = iocb->ki_filp;  \n    struct address_space *mapping = file->f_mapping;  \n    struct inode    *inode = mapping->host;  \n    ssize_t     written;  \n    size_t      write_len;  \n    pgoff_t     end;  \n \n    if (count != ocount)  \n        *nr_segs = iov_shorten((struct iovec *)iov, *nr_segs, count);  \n \n    write_len = iov_length(iov, *nr_segs);  \n    end = (pos + write_len - 1) >> PAGE_CACHE_SHIFT;  \n    /* 将对应区域page cache中的新数据页刷新到设备，这个操作是同步的 */  \n    written = filemap_write_and_wait_range(mapping, pos, pos + write_len - 1);  \n    if (written)  \n        goto out;  \n \n    /*  \n     * After a write we want buffered reads to be sure to go to disk to get  \n     * the new data.  We invalidate clean cached page from the region we're  \n     * about to write.  We do this *before* the write so that we can return  \n     * without clobbering -EIOCBQUEUED from ->direct_IO().  \n     */  \n    /* 将page cache对应page 缓存无效掉，这样可以保证后继的读操作能从磁盘获取最新数据 */  \n    if (mapping->nrpages) {  \n        /* 无效对应的page缓存 */  \n        written = invalidate_inode_pages2_range(mapping,  \n                    pos >> PAGE_CACHE_SHIFT, end);  \n        /*  \n         * If a page can not be invalidated, return 0 to fall back  \n         * to buffered write.  \n         */  \n        if (written) {  \n            if (written == -EBUSY)  \n                return 0;  \n            goto out;  \n        }  \n    }  \n    /* 调用ext3文件系统的direct io方法，将数据写入磁盘 */  \n    written = mapping->a_ops->direct_IO(WRITE, iocb, iov, pos, *nr_segs);  \n \n    /*  \n     * Finally, try again to invalidate clean pages which might have been  \n     * cached by non-direct readahead, or faulted in by get_user_pages()  \n     * if the source of the write was an mmap'ed region of the file  \n     * we're writing.  Either one is a pretty crazy thing to do,  \n     * so we don't support it 100%.  If this invalidation  \n     * fails, tough, the write still worked...  \n     */  \n    /* 再次无效掉由于预读操作导致的对应地址的page cache缓存页 */  \n    if (mapping->nrpages) {  \n        invalidate_inode_pages2_range(mapping,  \n                          pos >> PAGE_CACHE_SHIFT, end);  \n    }  \n \n    if (written > 0) {  \n        pos += written;  \n        if (pos > i_size_read(inode) && !S_ISBLK(inode->i_mode)) {  \n            i_size_write(inode, pos);  \n            mark_inode_dirty(inode);  \n        }  \n        *ppos = pos;  \n    }  \nout:  \n    return written;  \n} \n```\n\n \n\ngeneric_file_direct_write函数中刷新page cache的函数调用关系描述如下：\n\nfilemap_write_and_wait_range à__filemap_fdatawrite_rangeà do_writepages\n\ndo_writepages函数的作用是将page页中的数据同步到设备，该函数实现如下：\n\n \n\n```c\nint do_writepages(struct address_space *mapping, struct writeback_control *wbc)  \n{  \n    int ret;  \n \n    if (wbc->nr_to_write <= 0)  \n        return 0;  \n    if (mapping->a_ops->writepages)  \n        /* 如果文件系统定义了writepages方法，调用该方法刷新page cache页 */  \n        ret = mapping->a_ops->writepages(mapping, wbc);  \n    else  \n        /* ext3没有定义writepages方法，因此调用generic_writepages()函数将page cache中的脏页刷新到磁盘 */  \n        ret = generic_writepages(mapping, wbc);  \n    return ret;  \n} \n```\n\n从上述分析可以看出，direct_io需要块大小对齐，否则还会调用page cache的路径。为了提高I/O性能，通常情况下ext3都会采用page cache异步写的方式。这也就是ext3的第二种写操作方式，该方式实现的关键函数是generic_file_buffered_write，其实现如下：\n\n```c\nssize_t  \ngeneric_file_buffered_write(struct kiocb *iocb, const struct iovec *iov,  \n        unsigned long nr_segs, loff_t pos, loff_t *ppos,  \n        size_t count, ssize_t written)  \n{  \n    struct file *file = iocb->ki_filp;  \n    ssize_t status;  \n    struct iov_iter i;  \n \n    iov_iter_init(&i, iov, nr_segs, count, written);  \n    /* 执行page cache写操作 */  \n    status = generic_perform_write(file, &i, pos);  \n \n    if (likely(status >= 0)) {  \n        written += status;  \n        *ppos = pos + status;  \n    }  \n      \n    return written ? written : status;  \n} \n```\n\ngeneric_file_buffered_write其实是对generic_perform_write函数的封装，generic_perform_write实现了page cache写的所有流程，该函数实现如下：\n\n```c\nstatic ssize_t generic_perform_write(struct file *file,  \n                struct iov_iter *i, loff_t pos)  \n{  \n    struct address_space *mapping = file->f_mapping;  \n    const struct address_space_operations *a_ops = mapping->a_ops;  /* 映射处理函数集 */  \n    long status = 0;  \n    ssize_t written = 0;  \n    unsigned int flags = 0;  \n \n    /*  \n     * Copies from kernel address space cannot fail (NFSD is a big user).  \n     */  \n    if (segment_eq(get_fs(), KERNEL_DS))  \n        flags |= AOP_FLAG_UNINTERRUPTIBLE;  \n \n    do {  \n        struct page *page;  \n        unsigned long offset;   /* Offset into pagecache page */  \n        unsigned long bytes;    /* Bytes to write to page */  \n        size_t copied;      /* Bytes copied from user */  \n        void *fsdata;  \n \n        offset = (pos & (PAGE_CACHE_SIZE - 1));  \n        bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,  \n                        iov_iter_count(i));  \n \nagain:  \n        /*  \n         * Bring in the user page that we will copy from _first_.  \n         * Otherwise there's a nasty deadlock on copying from the  \n         * same page as we're writing to, without it being marked  \n         * up-to-date.  \n         *  \n         * Not only is this an optimisation, but it is also required  \n         * to check that the address is actually valid, when atomic  \n         * usercopies are used, below.  \n         */  \n        if (unlikely(iov_iter_fault_in_readable(i, bytes))) {  \n            status = -EFAULT;  \n            break;  \n        }  \n        /* 调用ext3中的write_begin函数（inode.c中）ext3_write_begin， 如果写入的page页不存在，那么ext3_write_begin会创建一个Page页，然后从硬盘中读入相应的数据 */  \n        status = a_ops->write_begin(file, mapping, pos, bytes, flags,  \n                        &page, &fsdata);  \n        if (unlikely(status))  \n            break;  \n \n        if (mapping_writably_mapped(mapping))  \n            flush_dcache_page(page);  \n \n        pagefault_disable();  \n        /* 将数据拷贝到page cache中 */  \n        copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);  \n        pagefault_enable();  \n        flush_dcache_page(page);  \n \n        mark_page_accessed(page);  \n        /* 调用ext3的write_end函数（inode.c中），写完数据之后会将page页标识为dirty，后台writeback线程会将dirty page刷新到设备 */  \n        status = a_ops->write_end(file, mapping, pos, bytes, copied,  \n                        page, fsdata);  \n        if (unlikely(status < 0))  \n            break;  \n        copied = status;  \n \n        cond_resched();  \n \n        iov_iter_advance(i, copied);  \n        if (unlikely(copied == 0)) {  \n            /*  \n             * If we were unable to copy any data at all, we must  \n             * fall back to a single segment length write.  \n             *  \n             * If we didn't fallback here, we could livelock  \n             * because not all segments in the iov can be copied at  \n             * once without a pagefault.  \n             */  \n            bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,  \n                        iov_iter_single_seg_count(i));  \n            goto again;  \n        }  \n        pos += copied;  \n        written += copied;  \n \n        balance_dirty_pages_ratelimited(mapping);  \n        if (fatal_signal_pending(current)) {  \n            status = -EINTR;  \n            break;  \n        }  \n    } while (iov_iter_count(i));  \n \n    return written ? written : status;  \n} \n```","tags":["ext4"],"categories":["文件系统"]},{"title":"fingerprint介绍","url":"/2018/10/21/其他调研/fingerprint方案/","content":"\n# 1. fingerprint编译过程\n\n```makefile\nPRODUCT_BRAND := SPRD\nPRODUCT_DEVICE :=   --TARGET_DEVICE\nPRODUCT_NAME :=   --TARGET_PRODUCT\n# build_id.mk\nBUILD_ID :=\nTARGET_BUILD_VARIANT:userdebug:user\nBUILD_VERSION_TAGS:test-keys release-keys\nBF_BUILD_NUMBER := $(USER)$$($(DATE_FROM_FILE) +%m%d%H%M)\n\nBUILD_FINGERPRINT := $(PRODUCT_BRAND)/$(TARGET_PRODUCT)/$(TARGET_DEVICE):$(PLATFORM_VERSION)/$(BUILD_ID)/$(BF_BUILD_NUMBER):$(TARGET_BUILD_VARIANT)/$(BUILD_VERSION_TAGS)\n```\n\nSPRD/sp9832e_1h10_oversea/sp9832e_1h10:9/PPR1.180610.021/liguang.zhang12111501:userdebug/test-keys\n>fingerprint的变动是跟着`BF_BUILD_NUMBER`字段变更的, 而`BF_BUILD_NUMBER`字段只在make时更新, 即执行一次make更新一次. \n>整编时, 一次编译出所有的img, img中所有的fingerprint都是一样的.\n\n```puml\n@startuml\nstart\n#HotPink:make;\n->system.img\\nvendor.img\\nproduct.img\\nrecovery.img\\n;\nnote right:ro.build.fingerprint\\nro.product.build.fingerprint\\nro.vendor.build.fingerprint\n#pink:pac;\n:make productimage;\n->product.img;\nnote right:ro.product.build.fingerprint\n:replace pac;\nend\n@enduml\n```\n\n# 2. fingerprint用途\n\n## 2.1. ota升级\n\n差分升级时会校验fingerprint. 升级包中的fingerprint来自ota素材包(target_file)中的system分区的build.prop文件.\nsrc recovery分区的fingerprint来自prop.default\n即进到recovery模式下getprop ro.build.fingerprint 与基础版本和目标版本的ro.build.fingerprint值进行比对, 有一个相等则符合要求.\n- prop.default结构:\n  ro.build.fingerprint         -< 来自system编译过程\n  ro.product.build.fingerprint -< 来自product编译过程\n\n如果只make productimage, 则recovery分区的prop.default不会更新.\n\n## 2.2. system package升级\n\n升级之前data分区保存的old ro.build.fingerprint和升级之后的ro.build.fingerprint作比较, 如果不相同, 为upgrade条件.\n\n## 2.3. google兼容性测试\n\n相同的ro.build.fingerprint被认为是同一个包, 不再重复测试.\n> vts测试会同时使用ro.vendor.build.fingerprint\n\n# 3. fingerprint方案\n\n覆盖property, 会有system分区升级的问题.\n不覆盖property, 会有送测问题.\n\n1. 现有方案, 不做改动\n- google兼容性测试问题\n- 只升级product分区(如果应用放在product分区), 升级完后, product中的应用不会更新\n\n2. ro.product.build.fingerprint覆盖ro.build.fingerprint\n- 只升级system分区\n  fingerprint读的product分区的, 升级结束后, fingerprint没变, 升级完后system中应用不更新\n- 只升级product分区  ok\n  升级结束后, fingerprint变动\n- 同时升级system分区和product分区\n  product分区如果没变化, 还是有问题.\n\n3. 不覆盖property, 修改libc, 读取ro.build.fingerprint时, 使用ro.product.build.fingerprint值替换.\n- recovery中使用android:base:GetProperty\n- android上层使用android:base:GetProperty访问\n- ~~native层也可以使用property_get访问~~\n- shell中对应toolbox, 使用类似android:base:GetProperty访问\n\n4. 手机开机时, 在初始化`ro.build.fingerprint`, 即将该ro属性加载到内存中时, 使用`ro.product.build.fingerprint`值替换\n> 前提是`ro.product.build.fingerprint`已经在前面加载到内存中了.\n\n修改init会同时作用到正常开机和recovery子系统, 但因为在recovery子系统中, ro.build.fingerprint在`ro.product.build.fingerprint`前面, 所以在recovery子系统中`ro.build.fingerprint`不会被替换掉.\n\n正常开机 init 替换`ro.build.fingerprint`流程\n\n```puml\n@startuml\nstart\n:set ro.product.build.fingerprint;\nnote right: read from product.img\n:replace ro.build.fingerprint;\nend\n@enduml\n```\n\n## 3.1. 小结\n综合考虑上述方案, 采用第4个方案修改较小, 副作用也比较小. 上述方案中2/3/4其实是对应的同一种, 仅修改方式不同. 副作用也是相同的.\n\n# 4. 修改方案提出的要求\n考虑下面几种场景:\n\n## 4.1. google兼容性测试\n需要综合考虑cts/gts/vts测试的要求, 重点是vts测试使用`ro.vendor.build.fingperint`, 如果vendor分区不跟product分区的fingerprint保持一致, 会带来同一个pac包, cts/gts的测试target和vts的测试target不是同一个的问题.\n\n因此需要保证vendor分区的`ro.vendor.build.fingperint`和product分区的`ro.product.build.fingerprint`保持一致.\n\n## 4.2. 对功能影响层面\n主要影响ota升级流程和升级结束后应用的更新流程.\n需要重点考虑只有某一个分区变动的情况:\n\n### 4.2.1. 只有product分区变动了\n这种情况对应多个product(config)对应同一软件版本的情况.\n需要将vendor和product的编译绑到一起(对应4.1中的要求)\n可以采用下面流程, 利用编译vendor会先编译product的规则.\n\n```puml\n@startuml\nstart\n:make;\n:pac;\n:...;\n:remove vendor & product;\nnote right: delete vendor.img/product.img and its dir in $PRODUCT_OUT\n:make vendorimg;\n:make productimg;\n:repac;\nend\n@enduml\n```\n\n而对应ota升级流程(recovery中的系统升级), 对差分升级来说, 如果需要差分升级product/vendor, 需要重新制作ota的target-files, 并重新制作ota的差分包.\n而对ota整包升级则不受影响\n\n### 4.2.2. 只有system分区变动\n\n这种情况对应芯片厂商向下游厂商只推送system.img情况. 由于最终的ro.build.fingerprint来自于product分区, 下游厂商需要重新编译vendor.img 和 product.img(或者手动修改vendor和product中的`ro.vendor.build.fingperint`和`ro.product.build.fingerprint`, 目的是要和system.img中的`ro.build.fingerprint`保持一致), 再重新打包.\n\n对应ota升级(recovery子系统中进行升级的情况), 因底包(system.img/vendor.img/product.img)变动了, 需要重新制作targetfiles素材包和ota差分包, ota整包不用考虑.\n\n### 4.2.3. 只有vendor分区变动\n\n这种情况对应(4.2.1中)只有product分区变动的情况\n\n# 5. Requirements\nThe solution description:\nWhen init initially sets the value of the ro.build.fingerprint property, first check if ro.product.build.fingerprint is empty. If it is not empty, use this value replace the value of ro.build.fingerprint.\nAt such situation, multiple product partitions (configurations) correspond to the same software version. Usually, only product partition is different.\n\nNeed to consider the requirements of the cts/gts/vts test, the focus is on the vts test using `ro.vendor.build.fingperint`. If `ro.vendor.build.fingerprint` in vendor partition is not consistent with the fingerprint of the product partition, it will bring the problem of for same pac package, cts/gts test target and the vts test target are not same.\n\nTherefore, need to ensure that the `ro.vendor.build.fingperint` in vendor partition is consistent with the `ro.product.build.fingerprint` in product partition.\nAnd for OTA incremental upgrade, should make OTA target-files for all different product and vendor image.","tags":["fingerprint"],"categories":["android"]},{"title":"软件小设计读书笔记","url":"/2018/10/21/其他调研/软件设计/","content":"\n\n# 1. 设计原则\n\n## 1.1. 通用原则\n\n### 1.1.1. KISS原则(keep it sample and stupid) \n  - 懒人原则\n  - 注重简约的原则, 逻辑处理上应该用简单直接的设计.\n  - 圈复杂度越小越好, if for case while的数量.\n\n`如非必要, 请远离各种设计模式`\n\n## 1.2. 核心原则\n\n### 1.2.1. 单一职责原则(SRP)\n\n`做一个专一的人`\n\n不能存在多于一个导致类变更的原因, 一个类之负责一项职责.\n> 迭代器的实现, 集合只负责存储数据, 迭代器完成遍历数据的功能\n\n### 1.2.2. 开放封闭原则 (OCP)\n\n`改造世界的大部分不能破坏原来的秩序`\n\n软件实体应该是可扩展, 不可修改的. 对扩展开放, 对修改封闭\n新的修改不要大幅度波及现有的对象\n> 小技巧: 使用继承/组合封装变化点, \n> 将变化点封装出一个抽象基类, 使用继承机制, 让子类演绎变化\n\n### 1.2.3. 里氏替换原则 (LSP)\n\n`长大后, 我就成了你`\n\n任何积累可以出现的地方, 子类一定可以出现.\n> 子类不破坏父类的接口成员\n> 当基类出现了子类不想要的接口成员时, 继承关系欠缺考虑, 违反LSP原则\n\n### 1.2.4. 接口分离原则 (ISP)\n\n`不要一口吃成胖子`\n\n不能强迫用户去依赖那些不使用的接口, 使用多个专门的接口比使用单一的总接口要好\n\n### 1.2.5. 依赖倒置原则 (DIP)\n\n`抽象的艺术才有生命力`\n\n- 高层模块不应依赖底层模块, 两者都应依赖于抽象\n- 抽象不应依赖细节\n- 细节(具体实现类)依赖抽象\n\n### 1.2.6. 核心原则小结\n\n`类要单纯, 继承要纯粹, 变化要封装, 抽象类型要多用`\n\n\n## 1.3. 扩展规则\n\n### 1.3.1. 狄米特法则\n\n`尽量不与无关的类发生关系`\n\n最少知识原则: 你调用的类的内部是如何实现的, 与我无关. 我只知道你提供的接口方法, 其他的一概不关心.\n\n通俗点的说法:\n- 只与你的朋友说话\n- 不要与陌生人说话\n- 对象因该只与必须交互的对象通信\n\n技术上的说法, 对象只与下类必须交互的各类对象进行通信:\n- 当前对象本身(this)\n- 以参数形式传入当前方法中的对象\n- 当前对象的成员对象 (this的成员变量)\n- 如果成员对象是一个集合, 集合中的元素也是可以交互的\n- 当前对象创建的对象\n\n### 1.3.2. 好莱坞法则\n\n`不要调用我, 让我调用你`\n\n多使用回调的方式. \n\n### 1.3.3. 优先使用组合\n\n多使用组合, 少使用继承.\n\n继承使用的场景:\n\n满足严格的IS-A关系, 即子类可以完全复用基类的所有信息时, 继承是必须的\n\n要么有冗余关系, 要么复用程度不够时, 不推荐完全使用继承关系.\n\n## 1.4. 应对变化\n\n### 1.4.1. 增量修改原则\n\n开闭原则, 尽量不修改原有的类和方法, 通过新增类和方法实现.\n\n### 1.4.2. 整体策略原则\n\n设计整体上考虑变化,而不仅仅考虑变化点周围的小区域\n\n### 1.4.3. 应对变化的设计思路\n\n- 预先设计\n  程序设计时就把可能存在的变化考虑到, 在程序上预留一定的扩展性\n  采用抽象类型来描述稳定的接口, 使用子类和多态机制来描述变化.\n\n- 简单设计+封装变化\n  很多时候, 变化总是不期而至,无法做到预先设计,当变化来的时候, 通过封装变化点来重构程序\n\n## 1.5. 设计的四个阶段\n\n### 1.5.1. 设计不足\n\n- 没有系统的观念, 代码写到哪想到哪,想到哪写到哪.\n- 代码随意堆彻, 各种编程元素随意使用, 元素可见性\\生命周期使用混乱\n- 元素随意命名, 数字随意使用\n- 代码随意复制和粘贴, 功能相似的函数不考虑复用\n- 代码无法应对需求变化, 维护成本很高\n\n### 1.5.2. 模仿设计\n\n- 开始考虑程序对系统其他方面的影响, 开始考虑设计\n- 开始应用简单的模式\n- 开始学习一些好的写法, 并学会整理自己的代码\n\n### 1.5.3. 过度设计\n\n- 见到全局的概念就使用单例模式\n- 需要通知就使用观察者模式\n- 见到稍微复杂一点的对象创建就使用抽象工厂模式\n- 见到算法变化了一点就使用策略模式\n- 见到软件就分三层\n- 见到变化就抽象\n- 见到依赖就注入\n- 任何行为都想抽象接口\n- 任何设计都考虑是否具有通用扩展性\n\n过度设计是在软件设计过程中实施了不必要的通用的扩展性设计, 增加了不必要的面向未来的设计, 进行了不必要的抽象封装.\n\n###　适度设计\n\n合时宜，　恰如其分，有时间制约，　合适的时间成本，　恰当的对接需求．\n\n\n\n\n","tags":["设计模式"],"categories":["设计模式","读书"]},{"title":"Incrementalfs 调研","url":"/2018/10/21/其他调研/incremental fs/","content":"\nIncremental File System\n=======================\n\nOverview\n========\nIncremental FS is special-purpose Linux virtual file system that allows\nexecution of a program while its binary and resource files are still being\nlazily downloaded over the network, USB etc. It is focused on incremental\ndelivery for a small number (under 100) of big files (more than 10 megabytes).\nIncremental FS doesn?t allow direct writes into files and, once loaded, file\ncontent never changes. Incremental FS doesn?t use a block device, instead it\nsaves data into a backing file located on a regular file-system.\n\nBut why?\n--------\nTo allow running **big** Android apps before their binaries and resources are\nfully downloaded to an Android device. If an app reads something not loaded yet,\nit needs to wait for the data block to be fetched, but in most cases hot blocks\ncan be loaded in advance.\n\nWorkflow\n--------\nA userspace process, called a data loader, mounts an instance of incremental-fs\ngiving it a file descriptor on an underlying file system (like ext4 or f2fs).\nIncremental-fs reads content (if any) of this backing file and interprets it as\na file system image with files, directories and data blocks. At this point\nthe data loader can declare new files to be shown by incremental-fs.\n\nA process is started from a binary located on incremental-fs.\nAll reads are served directly from the backing file\nwithout roundtrips into userspace. If the process accesses a data block that was\nnot originally present in the backing file, the read operation waits.\n\nMeanwhile the data loader can feed new data blocks to incremental-fs by calling\nwrite() on a special .cmd pseudo-file. The data loader can request information\nabout pending reads by calling poll() and read() on the .cmd pseudo-file.\nThis mechanism allows the data loader to serve most urgently needed data first.\nOnce a data block is given to incremental-fs, it saves it to the backing file\nand unblocks all the reads waiting for this block.\n\nEventually all data for all files is uploaded by the data loader, and saved by\nincremental-fs into the backing file. At that moment the data loader is not\nneeded any longer. The backing file will play the role of a complete\nfilesystem image for all future runs of the program.\n\nNon-goals\n---------\n* Allowing direct writes by the executing processes into files on incremental-fs\n* Allowing the data loader change file size or content after it was loaded.\n* Having more than a couple hundred files and directories.\n\n\nFeatures\n========\n\nRead-only, but not unchanging\n-----------------------------\nOn the surface a mount directory of incremental-fs would look similar to\na read-only instance of network file system: files and directories can be\nlisted and read, but can?t be directly created or modified via creat() or\nwrite(). At the same time the data loader can make changes to a directory\nstructure via external ioctl-s. i.e. link and unlink files and directories\n(if they empty). Data can't be changed this way, once a file block is loaded\nthere is no way to change it.\n\nFilesystem image in a backing file\n----------------------------------\nInstead of using a block device, all data and metadata is stored in a\nbacking file provided as a mount parameter. The backing file is located on\nan underlying file system (like ext4 or f2fs). Such approach is very similar\nto what might be achieved by using loopback device with a traditional file\nsystem, but it avoids extra set-up steps and indirections. It also allows\nincremental-fs image to dynamically grow as new files and data come without\nhaving to do any extra steps for resizing.\n\nIf the backing file contains data at the moment when incremental-fs is mounted,\ncontent of the backing file is being interpreted as filesystem image.\nNew files and data can still be added through the external interface,\nand they will be saved to the backing file.\n\nData compression\n----------------\nIncremental-fs can store compressed data. In this case each 4KB data block is\ncompressed separately. Data blocks can be provided to incremental-fs by\nthe data loader in a compressed form. Incremental-fs uncompresses blocks\neach time a executing process reads it (modulo page cache). Compression also\ntakes care of blocks composed of all zero bytes removing necessity to handle\nthis case separately.\n\nPartially present files\n-----------------------\nData in the files consists of 4KB blocks, each block can be present or absent.\nUnlike in sparse files, reading an absent block doesn?t return all zeros.\nIt waits for the data block to be loaded via the ioctl interface\n(respecting a timeout). Once a data block is loaded it never disappears\nand can?t be changed or erased from a file. This ability to frictionlessly\nwait for temporary missing data is the main feature of incremental-fs.\n\nHard links. Multiple names for the same file\n--------------------------------------------\nLike all traditional UNIX file systems, incremental-fs supports hard links,\ni.e. different file names in different directories can refer to the same file.\nAs mentioned above new hard links can be created and removed via\nthe ioctl interface, but actual data files are immutable, modulo partial\ndata loading. Each directory can only have at most one name referencing it.\n\nInspection of incremental-fs internal state\n-------------------------------------------\npoll() and read() on the .cmd pseudo-file allow data loaders to get a list of\nread operations stalled due to lack of a data block (pending reads).\n\n\nApplication Programming Interface\n=================================\n\nRegular file system interface\n-----------------------------\nExecuting process access files and directories via regular Linux file interface:\nopen, read, close etc. All the intricacies of data loading a file representation\nare hidden from them.\n\nExternal .cmd file interface\n----------------------------\nWhen incremental-fs is mounted, a mount directory contains a pseudo-file\ncalled '.cmd'. The data loader will open this file and call read(), write(),\npoll() and ioctl() on it inspect and change state of incremental-fs.\n\npoll() and read() are used by the data loader to wait for pending reads to\nappear and obtain an array of ``struct incfs_pending_read_info``.\n\nwrite() is used by the data loader to feed new data blocks to incremental-fs.\nA data buffer given to write() is interpreted as an array of\n``struct incfs_new_data_block``. Structs in the array describe locations and\nproperties of data blocks loaded with this write() call.\n\n``ioctl(INCFS_IOC_PROCESS_INSTRUCTION)`` is used to change structure of\nincremental-fs. It receives an pointer to ``struct incfs_instruction``\nwhere type field can have be one of the following values.\n\n**INCFS_INSTRUCTION_NEW_FILE**\nCreates an inode (a file or a directory) without a name.\nIt assumes ``incfs_new_file_instruction.file`` is populated with details.\n\n**INCFS_INSTRUCTION_ADD_DIR_ENTRY**\nCreates a name (aka hardlink) for an inode in a directory.\nA directory can't have more than one hardlink pointing to it, but files can be\nlinked from different directories.\nIt assumes ``incfs_new_file_instruction.dir_entry`` is populated with details.\n\n**INCFS_INSTRUCTION_REMOVE_DIR_ENTRY**\nRemove a name (aka hardlink) for a file from a directory.\nOnly empty directories can be unlinked.\nIt assumes ``incfs_new_file_instruction.dir_entry`` is populated with details.\n\nFor more details see in uapi/linux/incrementalfs.h and samples below.\n\nSupported mount options\n-----------------------\nSee ``fs/incfs/options.c`` for more details.\n\n```shell\n* ``backing_fd=<unsigned int>``\n    Required. A file descriptor of a backing file opened by the process\n    calling mount(2). This descriptor can be closed after mount returns.\n\n* ``read_timeout_msc=<unsigned int>``\n    Default: 1000. Timeout in milliseconds before a read operation fails\n    if no data found in the backing file or provided by the data loader.\n```\n\nSysfs files\n-----------\n``/sys/fs/incremental-fs/version`` - a current version of the filesystem.\nOne ASCII encoded positive integer number with a new line at the end.\n\n\nExamples\n--------\nSee ``sample_data_loader.c`` for a complete implementation of a data loader.\n\nMount incremental-fs\n~~~~~~~~~~~~~~~~~~~~c\n\n::\n\n    int mount_fs(char *mount_dir, char *backing_file, int timeout_msc)\n    {\n        static const char fs_name[] = INCFS_NAME;\n        char mount_options[512];\n        int backing_fd;\n        int result;\n\n        backing_fd = open(backing_file, O_RDWR);\n        if (backing_fd == -1) {\n            perror(\"Error in opening backing file\");\n            return 1;\n        }\n\n        snprintf(mount_options, ARRAY_SIZE(mount_options),\n            \"backing_fd=%u,read_timeout_msc=%u\", backing_fd, timeout_msc);\n\n        result = mount(fs_name, mount_dir, fs_name, 0, mount_options);\n        if (result != 0)\n            perror(\"Error mounting fs.\");\n        return result;\n    }\n\nOpen .cmd file\n~~~~~~~~~~~~~~\n\n::\n\n```c\nint open_commands_file(char *mount_dir)\n{\n    char cmd_file[255];\n    int cmd_fd;\n\n    snprintf(cmd_file, ARRAY_SIZE(cmd_file), \"%s/.cmd\", mount_dir);\n    cmd_fd = open(cmd_file, O_RDWR);\n    if (cmd_fd < 0)\n        perror(\"Can't open commands file\");\n    return cmd_fd;\n}\n```\n\nAdd a file to the file system\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c\n\n::\n\n    int create_file(int cmd_fd, char *filename, int *ino_out, size_t size)\n    {\n        int ret = 0;\n        __u16 ino = 0;\n        struct incfs_instruction inst = {\n                .version = INCFS_HEADER_VER,\n                .type = INCFS_INSTRUCTION_NEW_FILE,\n                .file = {\n                    .size = size,\n                    .mode = S_IFREG | 0555,\n                }\n        };\n\n        ret = ioctl(cmd_fd, INCFS_IOC_PROCESS_INSTRUCTION, &inst);\n        if (ret)\n            return -errno;\n\n        ino = inst.file.ino_out;\n        inst = (struct incfs_instruction){\n                .version = INCFS_HEADER_VER,\n                .type = INCFS_INSTRUCTION_ADD_DIR_ENTRY,\n                .dir_entry = {\n                    .dir_ino = INCFS_ROOT_INODE,\n                    .child_ino = ino,\n                    .name = ptr_to_u64(filename),\n                    .name_len = strlen(filename)\n                }\n            };\n        ret = ioctl(cmd_fd, INCFS_IOC_PROCESS_INSTRUCTION, &inst);\n        if (ret)\n            return -errno;\n        *ino_out = ino;\n        return 0;\n    }\n\nLoad data into a file\n~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n```c\nint cmd_fd = open_commands_file(path_to_mount_dir);\nchar *data = get_some_data();\nstruct incfs_new_data_block block;\nint err;\n\nblock.file_ino = file_ino;\nblock.block_index = 0;\nblock.compression = COMPRESSION_NONE;\nblock.data = (__u64)data;\nblock.data_len = INCFS_DATA_FILE_BLOCK_SIZE;\n\nerr = write(cmd_fd, &block, sizeof(block));\n```\n\nGet an array of pending reads\n\n::\n```c\n    int poll_res = 0;\n    struct incfs_pending_read_info reads[10];\n    int cmd_fd = open_commands_file(path_to_mount_dir);\n    struct pollfd pollfd = {\n        .fd = cmd_fd,\n        .events = POLLIN\n    };\n\n    poll_res = poll(&pollfd, 1, timeout);\n    if (poll_res > 0 && (pollfd.revents | POLLIN)) {\n        ssize_t read_res = read(cmd_fd, reads, sizeof(reads));\n        if (read_res > 0)\n            printf(\"Waiting reads %ld\\n\", read_res / sizeof(reads[0]));\n    }\n```\n\n![](images/20200604140901.svg)\n\nOndisk format\n=============\n\nGeneral principles\n------------------\n* The backbone of the incremental-fs ondisk format is an append only linked\n  list of metadata blocks. Each metadata block contains an offset of the next\n  one. These blocks describe files and directories on the\n  file system. They also represent actions of adding and removing file names\n  (hard links).\n  Every time incremental-fs instance is mounted, it reads through this list\n  to recreate filesystem's state in memory. An offset of the first record in the\n  metadata list is stored in the superblock at the beginning of the backing\n  file.\n\n* Most of the backing file is taken by data areas and blockmaps.\n  Since data blocks can be compressed and have different sizes,\n  single per-file data area can't be pre-allocated. That's why blockmaps are\n  needed in order to find a location and size of each data block in\n  the backing file. Each time a file is created, a corresponding block map is\n  allocated to store future offsets of data blocks.\n\n  Whenever a data block is given by data loader to incremental-fs:\n    - A data area with the given block is appended to the end of\n      the backing file.\n    - A record in the blockmap for the given block index is updated to reflect\n      its location, size, and compression algorithm.\n\nImportant format details\n------------------------\nOndisk structures are defined in the ``format.h`` file. They are all packed\nand use little-endian order.\nA backing file must start with ``incfs_super_block`` with ``s_magic`` field\nequal to 0x5346434e49 \"INCFS\".\n\nMetadata records:\n\n* ``incfs_inode`` - metadat^a record to declare^ a file or a directory.\n                    ``incfs_inode.i_mode`` determents if it is a file\n                    or a directory.\n* ``incfs_blockmap_entry`` - metadata record that specifies size and location\n                            of a blockmap area for a given file. This area\n                            contains an array of ``incfs_blockmap_entry``-s.\n* ``incfs_dir_action`` - metadata record that specifies changes made to a\n                    to a directory structure, e.g. add or remove a hardlink.\n* ``incfs_md_header`` - header of a metadata record. It's always a part\n                    of other structures and served purpose of metadata\n                    bookkeeping.\n\nOther ondisk structures:\n\n* ``incfs_super_block`` - backing file header\n* ``incfs_blockmap_entry`` - a record in a blockmap area that describes size\n                        and location of a data block.\n* Data blocks dont have any particular structure, they are written to the backing\n  file in a raw form as they come from a data loader.\n\n\nBacking file layout\n-------------------\n::\n\n![](images/20200601211053.png)\n\nUnreferenced files and absence of garbage collection\n----------------------------------------------------\n\nDescribed file format can produce files that don't have any names for them in\nany directories. Incremental-fs takes no steps to prevent such situations or\nreclaim space occupied by such files in the backing file. If garbage collection\nis needed it has to be implemented as a separate userspace tool.\n\n\nDesign alternatives\n===================\n\nWhy isn't incremental-fs implemented via FUSE?\n----------------------------------------------\nTLDR: FUSE-based filesystems add 20-80% of performance overhead for target\nscenarios, and increase power use on mobile beyond acceptable limit\nfor widespread deployment. A custom kernel filesystem is the way to overcome\nthese limitations.\n\nFrom the theoretical side of things, FUSE filesystem adds some overhead to\neach filesystem operation that?s not handled by OS page cache:\n\n```shell\n* When an IO request arrives to FUSE driver (D), it puts it into a queue\n  that runs on a separate kernel thread\n* Then another separate user-mode handler process (H) has to run,\n  potentially after a context switch, to read the request from the queue.\n  Reading the request adds a kernel-user mode transition to the handling.\n* (H) sends the IO request to kernel to handle it on some underlying storage\n  filesystem. This adds a user-kernel and kernel-user mode transition\n  pair to the handling.\n* (H) then responds to the FUSE request via a write(2) call.\n  Writing the response is another user-kernel mode transition.\n* (D) needs to read the response from (H) when its kernel thread runs\n  and forward it to the user\n```\n\nTogether, the scenario adds 2 extra user-kernel-user mode transition pairs,\nand potentially has up to 3 additional context switches for the FUSE kernel\nthread and the user-mode handler to start running for each IO request on the\nfilesystem.\nThis overhead can vary from unnoticeable to unmanageable, depending on the\ntarget scenario. But it will always burn extra power via CPU staying longer\nin non-idle state, handling context switches and mode transitions.\nOne important goal for the new filesystem is to be able to handle each page\nread separately on demand, because we don't want to wait and download more data\nthan absolutely necessary. Thus readahead would need to be disabled completely.\nThis increases the number of separate IO requests and the FUSE related overhead\nby almost 32x (128KB readahead limit vs 4KB individual block operations)\n\nFor more info see a 2017 USENIX research paper:\nTo FUSE or Not to FUSE: Performance of User-Space File Systems\nBharath Kumar Reddy Vangoor, Stony Brook University;\nVasily Tarasov, IBM Research-Almaden;\nErez Zadok, Stony Brook University\nhttps://www.usenix.org/system/files/conference/fast17/fast17-vangoor.pdf\n\n# references\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-1-ezemtsov@google.com/\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-2-ezemtsov@google.com/\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-3-ezemtsov@google.com/\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-4-ezemtsov@google.com/\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-5-ezemtsov@google.com/\n\nhttps://lore.kernel.org/linux-fsdevel/20190502040331.81196-7-ezemtsov@google.com/","tags":["incrementalfs","增量文件系统"],"categories":["android","文件系统"]},{"title":"Settings 搜索框架调研","url":"/2018/10/21/其他调研/设置中统一搜索接口实现/","content":"\n主要调研下Settings对应的通用搜索框架的实现.\n\n# 1. 自定义fragment支持search扩展\n\n需要继承com.android.settings.search.Indexable接口, 定义SearchIndexProvider的实例, 并需要将自己加到SearchIndexableResources的sProviders中\n\n## 1.1. 接口定义\n\n```java\n// 嵌套接口的用法\npublic interface Indexable {\n\n    interface SearchIndexProvider {\n        /**\n         * Return a list of references for indexing.\n         *\n         * See {@link android.provider.SearchIndexableResource}\n         *\n         *\n         * @param context the context.\n         * @param enabled hint telling if the data needs to be considered into the search results\n         *                or not.\n         * @return a list of {@link android.provider.SearchIndexableResource} references.\n         *         Can be null.\n         */\n        List<SearchIndexableResource> getXmlResourcesToIndex(Context context, boolean enabled);\n\n        /**\n         * Return a list of raw data for indexing. See {@link SearchIndexableRaw}\n         *\n         * @param context the context.\n         * @param enabled hint telling if the data needs to be considered into the search results\n         *                or not.\n         * @return a list of {@link SearchIndexableRaw} references. Can be null.\n         */\n        List<SearchIndexableRaw> getRawDataToIndex(Context context, boolean enabled);\n\n        /**\n         * Return a list of data keys that cannot be indexed. See {@link SearchIndexableRaw}\n         *\n         * @param context the context.\n         * @return a list of {@link SearchIndexableRaw} references. Can be null.\n         */\n        List<String> getNonIndexableKeys(Context context);\n\n        /**\n         * @param context\n         * @return a list of {@link AbstractPreferenceController} for ResultPayload data during\n         * Indexing.\n         */\n        List<AbstractPreferenceController> getPreferenceControllers(Context context);\n    }\n}\n```\n## 1.2. 接口实现\n\n```java\n    // 定义SearchIndexProvider的实例\n    public static final SearchIndexProvider SEARCH_INDEX_DATA_PROVIDER = \n            new BaseSearchIndexProvider() {\n                @Override\n                public List<SearchIndexableResource> getXmlResourcesToIndex(\n                        Context context, boolean enabled) {\n                    final SearchIndexableResource sir = new SearchIndexableResource(context);\n                    sir.xmlResId = R.xml.tether_prefs;\n                    return Arrays.asList(sir);\n                }\n            };\n    public class BaseSearchIndexProvider implements Indexable.SearchIndexProvider\n    // 加到sResMap中, 后面遍历时用打\n    addIndex(TetherSettings.class, NO_DATA_RES_ID, 0);\n```\n\n定义了通用类, BaseSearchIndexProvider, 实现接口的通用方法, 如果有具体的定制需求, 需要自定义BaseSearchIndexProvider的子类覆盖对应方法.\n\n## 1.3. 结构图\n\n```puml\n@startuml\ninterface Indexable {               \n   interface SearchIndexProvider\n}\ninterface SearchIndexProvider {\n    getXmlResourcesToIndex(...)\n    getRawDataToIndex()\n    getNonIndexableKeys()\n}\nIndexable *-- SearchIndexProvider \nclass BaseSearchIndexProvider implements SearchIndexProvider {\n    getXmlResourcesToIndex(...)\n    getRawDataToIndex()\n    getNonIndexableKeys()\n}\nclass DemoFragment implements Indexable {\n    SearchIndexProvider SEARCH_INDEX_DATA_PROVIDER\n}\n\nDemoFragment o-- BaseSearchIndexProvider\n@enduml\n```\nDemoFragment中的SEARCH_INDEX_DATA_PROVIDER为具体类, 需要根据实际情况覆写 Indexable.SearchIndexProvider的方法.\n\n# 2. Settings 搜索实现\n\n## 2.1. Search 入口分析,\n\n先看入口SettingsActivity, 工厂模式, 反射方式加载具体工厂 FeatureFactoryImpl, 进而找到 SearchFeatureProviderImpl代理.\nSearchFeatureProviderImpl类为SearchFeatureProvider的代理\n\n```java\n            FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                    .initSearchToolbar(this, toolbar);\n            final String clsName = context.getString(R.string.config_featureFactory);\n            sFactory = (FeatureFactory) context.getClassLoader().loadClass(clsName).newInstance();\n\n            public class FeatureFactoryImpl extends FeatureFactory\n```\n\nFeatureFactory为抽象类, 实现类为FeatureFactoryImpl(代理类), 实现了 getSearchFeatureProvider\n\n```java\npublic abstract class FeatureFactory {\n    public abstract SearchFeatureProvider getSearchFeatureProvider();\n}\n\n// FeatureFactoryImpl类\n    public SearchFeatureProvider getSearchFeatureProvider() {\n        if (mSearchFeatureProvider == null) {\n            mSearchFeatureProvider = new SearchFeatureProviderImpl();\n        }\n        return mSearchFeatureProvider;\n    }\n```\n\nSearchFeatureProvider为interface, 含默认方法initSearchToolbar. Java中的接口可以有默认方法\ninitSearchToolbar中指定了Settings的搜索toolbar点击对应的动作.\n启动SEARCH_UI_INTENT即SEARCH对应的fragment  \"com.android.settings.action.SETTINGS_SEARCH\"\n对应SearchActivity. \n同时通过绑定的getSlicesFeatureProvider初始化数据库.\n\n\n```java\npublic interface SearchFeatureProvider {\n    default void initSearchToolbar(Activity activity, Toolbar toolbar) {\n        if (activity == null || toolbar == null) {\n            return;\n        }\n        toolbar.setOnClickListener(tb -> {\n            final Intent intent = SEARCH_UI_INTENT;\n            intent.setPackage(getSettingsIntelligencePkgName());\n\n            FeatureFactory.getFactory(\n                    activity.getApplicationContext()).getSlicesFeatureProvider()\n                    .indexSliceDataAsync(activity.getApplicationContext());\n            activity.startActivityForResult(intent, 0 /* requestCode */);\n        });\n    }\n}\n```\n\n### 2.1.1. FeatureFactory的相关类图\n\n```puml\n@startuml\nabstract class FeatureFactory {\n    +abstract SearchFeatureProvider getSearchFeatureProvider()\n    +static FeatureFactory getFactory()\n}\n\nclass FeatureFactoryImpl extends FeatureFactory {\n    +SearchFeatureProvider getSearchFeatureProvider()\n}\n\nSearchFeatureProvider -d-o FeatureFactory\nSearchFeatureProvider ..o FeatureFactoryImpl: getSearchFeatureProvider\n\nclass SearchFeatureProviderImpl implements SearchFeatureProvider{\n    +updateIndex(Context context)\n    +DatabaseIndexingManager getIndexingManager(Context context)\n}\n\ninterface SearchFeatureProvider {\n    default void initSearchToolbar(Activity activity, Toolbar toolbar)\n}\n@enduml\n```\n\n### 2.1.2. getSlicesFeatureProvider 初始化数据\n\n通过FeatureFactory的`getSlicesFeatureProvider`方法找到SlicesFeatureProvider, 对应的实现代理为SlicesFeatureProviderImpl, 类的关系同SearchFeatureProvider\n这里主要看下indexSliceDataAsync的实现. 是SlicesFeatureProvider接口的方法\n\n```java\n    public void indexSliceDataAsync(Context context) {\n        SlicesIndexer indexer = getSliceIndexer(context);\n        1. ThreadUtils.postOnBackgroundThread(indexer);\n    }\n    // 这里的get方法通通为单例模式\n    mSlicesIndexer = new SlicesIndexer(context);\n    class SlicesIndexer implements Runnable {\n        public SlicesIndexer(Context context) {\n            // getInstance 单例\n            mHelper = SlicesDatabaseHelper.getInstance(mContext);\n        }\n\n        public void run() {\n            1. indexSliceData();\n        }\n    }\n\n    \n    // 找到数据库类\n    public class SlicesDatabaseHelper extends SQLiteOpenHelper {\n        private SlicesDatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null /* CursorFactor */, DATABASE_VERSION);\n            mContext = context;\n        }\n    }\n```\n\n通过getSliceIndexer实例化SlicesIndexer(单例), 执行ThreadUtils.postOnBackgroundThread方法.\nThreadUtils为Thread工具类,  保存了ExecutorService对象(单例), 启动线程池执行Runnable的run方法, 即SlicesIndexer的run方法\n\n```java\n    public static void postOnBackgroundThread(Runnable runnable) {\n        if (sSingleThreadExecutor == null) {\n            sSingleThreadExecutor = Executors.newSingleThreadExecutor();\n        }\n        sSingleThreadExecutor.execute(runnable);\n    }\n```\n\n接下来重点看下indexSliceData的执行流程\n\n### 2.1.3. indexSliceData\n\n```java\n\n    protected void indexSliceData() {\n        // 这里有个不重复加载的机制, 跟语言项有关, 注意替换apk的方式可能需要清空数据, 否则这里不再重新index. 与setIndexedState调用有关\n        if (mHelper.isSliceDataIndexed()) {\n            Log.d(TAG, \"Slices already indexed - returning.\");\n            return;\n        }\n\n        SQLiteDatabase database = mHelper.getWritableDatabase();\n\n        try {\n\n            database.beginTransaction();\n\n            mHelper.reconstruct(mHelper.getWritableDatabase());\n            // 数据的获得通过 getSliceData\n            1.1 List<SliceData> indexData = getSliceData();\n            // 插入数据库中\n            insertSliceData(database, indexData);\n            \n            // 只初始化一次? mHelper里也没有实现增删改的方法, 只有onUpgrade.\n            mHelper.setIndexedState();\n            database.setTransactionSuccessful();\n        } finally {\n            database.endTransaction();\n        }\n    }\n\n1.1 -> // 获取数据,  \n    List<SliceData> getSliceData() {\n        // 又见到 FeatureFactory, 同样方式拿到SliceDataConverter, 通过SlicesFeatureProviderImpl代理类拿到\n        return FeatureFactory.getFactory(mContext)\n                .getSlicesFeatureProvider()\n                .getSliceDataConverter(mContext)\n                .getSliceData();\n    }\n\n    public SliceDataConverter getSliceDataConverter(Context context) {\n        if(mSliceDataConverter == null) {\n            mSliceDataConverter = new SliceDataConverter(context.getApplicationContext());\n        }\n        return mSliceDataConverter;\n    }\n\n    class SliceDataConverter {\n        public List<SliceData> getSliceData() {\n            if (!mSliceData.isEmpty()) {\n                return mSliceData;\n            }\n            \n            // 找到代理SearchFeatureProviderImpl的resource对象.\n 1.2           final Collection<Class> indexableClasses = FeatureFactory.getFactory(mContext)\n                    .getSearchFeatureProvider().getSearchIndexableResources().getProviderValues();\n\n            for (Class clazz : indexableClasses) {\n                final String fragmentName = clazz.getName();\n\n 1.3               final SearchIndexProvider provider = DatabaseIndexingUtils.getSearchIndexProvider(\n                        clazz);\n\n                // CodeInspection test guards against the null check. Keep check in case of bad actors.\n                if (provider == null) {\n                    Log.e(TAG, fragmentName + \" dose not implement Search Index Provider\");\n                    continue;\n                }\n\n 1.4               final List<SliceData> providerSliceData = getSliceDataFromProvider(provider,\n                        fragmentName);\n                mSliceData.addAll(providerSliceData);\n            }\n\n            return mSliceData;\n        }\n    }\n\n1.2 ->  // SearchFeatureProviderImpl的resource对象.\n    @Override\n    public SearchIndexableResources getSearchIndexableResources() {\n        if (mSearchIndexableResources == null) {\n            // 单例 + 代理\n            mSearchIndexableResources = new SearchIndexableResourcesImpl();\n        }\n        return mSearchIndexableResources;\n    }\n```\n\n通过上述方法终于找到了SearchIndexableResourcesImpl类, 这个存放了所有支持搜索的fragment的class, 通过其提供的\ngetProviderValues方法获取集合. 这个地方与[自定义fragment支持search扩展](#自定义fragment支持search扩展) 呼应\n\n```java\n    void addIndex(Class indexClass) {\n        sProviders.add(indexClass);\n    }\n    public Collection<Class> getProviderValues() {\n        return sProviders;\n    }\n```\n\n### 2.1.4. 怎样找到资源的\n\n工具类 DatabaseIndexingUtils, 遍历支持搜索的fragment的class的类名, 通过反射找到其SEARCH_INDEX_DATA_PROVIDER字段(如果支持搜索, 必须定义该字段)\n反射出类 SearchIndexProvider(Indexable接口中的子接口)\n\n```java\n\nfinal SearchIndexProvider provider = DatabaseIndexingUtils.getSearchIndexProvider(clazz);\n    public static Indexable.SearchIndexProvider getSearchIndexProvider(final Class<?> clazz) {\n        try {\n            final Field f = clazz.getField(FIELD_NAME_SEARCH_INDEX_DATA_PROVIDER);\n            return (Indexable.SearchIndexProvider) f.get(null);\n        }\n        return null;\n    }\n\n\n1.4 -> 从provider中获取数据, 即支持搜索的fragment需要覆写方法提供数据\nfinal List<SliceData> providerSliceData = getSliceDataFromProvider(provider,\n                        fragmentName);\n\n    private List<SliceData> getSliceDataFromProvider(SearchIndexProvider provider,\n            String fragmentName) {\n        final List<SliceData> sliceData = new ArrayList<>();\n        // 需要覆写 getXmlResourcesToIndex方法, 提供xml 资源id\n        final List<SearchIndexableResource> resList =\n                provider.getXmlResourcesToIndex(mContext, true /* enabled */);\n\n        for (SearchIndexableResource resource : resList) {\n            int xmlResId = resource.xmlResId;\n            if (xmlResId == 0) {\n                Log.e(TAG, fragmentName + \" provides invalid XML (0) in search provider.\");\n                continue;\n            }\n\n1.4.1            List<SliceData> xmlSliceData = getSliceDataFromXML(xmlResId, fragmentName);\n            sliceData.addAll(xmlSliceData);\n        }\n\n        return sliceData;\n    }\n\n1.4.1 -> 通过xml id解析出元素填充到SliceData中\nprivate List<SliceData> getSliceDataFromXML(int xmlResId, String fragmentName) {\n        XmlResourceParser parser = null;\n\n        final List<SliceData> xmlSliceData = new ArrayList<>();\n\n        try {\n            parser = mContext.getResources().getXml(xmlResId);\n\n            int type;\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                    && type != XmlPullParser.START_TAG) {\n                // Parse next until start tag is found\n            }\n\n            String nodeName = parser.getName();\n  ...\n            final AttributeSet attrs = Xml.asAttributeSet(parser);\n            final String screenTitle = PreferenceXmlParserUtils.getDataTitle(mContext, attrs);\n\n            // TODO (b/67996923) Investigate if we need headers for Slices, since they never\n            // correspond to an actual setting.\n\n            final List<Bundle> metadata = PreferenceXmlParserUtils.extractMetadata(mContext,\n                    xmlResId,\n                    MetadataFlag.FLAG_NEED_KEY\n                            | MetadataFlag.FLAG_NEED_PREF_CONTROLLER\n                            | MetadataFlag.FLAG_NEED_PREF_TYPE\n                            | MetadataFlag.FLAG_NEED_PREF_TITLE\n                            | MetadataFlag.FLAG_NEED_PREF_ICON\n                            | MetadataFlag.FLAG_NEED_PREF_SUMMARY\n                            | MetadataFlag.FLAG_NEED_PLATFORM_SLICE_FLAG);\n\n            for (Bundle bundle : metadata) {\n                // TODO (b/67996923) Non-controller Slices should become intent-only slices.\n                // Note that without a controller, dynamic summaries are impossible.\n                final String controllerClassName = bundle.getString(METADATA_CONTROLLER);\n                if (TextUtils.isEmpty(controllerClassName)) {\n                    continue;\n                }\n                final String key = bundle.getString(METADATA_KEY);\n                final String title = bundle.getString(METADATA_TITLE);\n                final String summary = bundle.getString(METADATA_SUMMARY);\n                final int iconResId = bundle.getInt(METADATA_ICON);\n                final int sliceType = SliceBuilderUtils.getSliceType(mContext, controllerClassName,\n                        key);\n                final boolean isPlatformSlice = bundle.getBoolean(METADATA_PLATFORM_SLICE_FLAG);\n                // Build模式\n                final SliceData xmlSlice = new SliceData.Builder()\n                        .setKey(key)\n                        .setTitle(title)\n                        .setSummary(summary)\n                        .setIcon(iconResId)\n                        .setScreenTitle(screenTitle)\n                        .setPreferenceControllerClassName(controllerClassName)\n                        .setFragmentName(fragmentName)\n                        .setSliceType(sliceType)\n                        .setPlatformDefined(isPlatformSlice)\n                        .build();\n\n                xmlSliceData.add(xmlSlice);\n            }\n        }\n        ...\n        return xmlSliceData;\n    }\n\n```\n\n拿到数据后, 即List<SliceData>  后, 通过`insertSliceData(database, indexData)` 插入到数据库中.\n\n### 2.1.5. 小节\n\nSettings入口分析结束, 其中看到了统一的工厂, 抽象工厂, 具体工厂, 通过工厂管理各种工种, 成员为抽象的, 调用工厂的方法找到实际的工种代理.\n统一管理起来. 每个代理都是单例的, 其中又涉及到了builder模式, 工具类的使用等等.\n抽象 + 具体的模式使用非常普遍, 保存成员时都是保存的抽象.\n\n上述过程主要涉及到元数据的索引, provider和database并不是直接的联系, 而是通过了几层的桥接. 数据类为SliceData\n\n## 2.2. 搜索过程\n\n通过输入关键词找到关键词对应的fragment. 对应的ui是SearchActivity, 需要回想之前的fragment的生命周期. \n\n```java\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // 绑定layout 为 search_main\n        setContentView(R.layout.search_main);\n        // Keeps layouts in-place when keyboard opens.\n        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);\n\n        FragmentManager fragmentManager = getFragmentManager();\n        Fragment fragment = fragmentManager.findFragmentById(R.id.main_content);\n        // 绑定布局, 关联到SearchFragment\n        if (fragment == null) {\n            fragmentManager.beginTransaction()\n                    .add(R.id.main_content, new SearchFragment())\n                    .commit();\n        }\n    }\n```\n\n进入SearchFragment的生命周期中, 这里又使用到了Loader\n\n### 2.2.1. SearchFragment的生命周期\n\n```java\n// 继承LoaderCallbacks\npublic class SearchFragment extends Fragment implements SearchView.OnQueryTextListener,\n        LoaderManager.LoaderCallbacks<List<? extends SearchResult>>, IndexingCallback {\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        // 关联SearchFeatureProvider\n        mSearchFeatureProvider = FeatureFactory.get(context).searchFeatureProvider();\n    }\n\n    public void onCreate(Bundle savedInstanceState) {\n        final LoaderManager loaderManager = getLoaderManager();\n        // 对应的Adapter\n        mSearchAdapter = new SearchResultsAdapter(this /* fragment */);\n        mSavedQueryController = new SavedQueryController(\n                getContext(), loaderManager, mSearchAdapter);\n        // 更新元数据索引, 又更新一轮\n        1. mSearchFeatureProvider.updateIndexAsync(getContext(), this /* indexingCallback */);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        final Activity activity = getActivity();\n        final View view = inflater.inflate(R.layout.search_panel, container, false);\n        // 这里又使用到了 RecyclerView, item元素的布局为list_results\n        mResultsRecyclerView = view.findViewById(R.id.list_results);\n        mResultsRecyclerView.setAdapter(mSearchAdapter);\n        // 设定线性布局管理\n        mResultsRecyclerView.setLayoutManager(new LinearLayoutManager(activity));\n        mResultsRecyclerView.addOnScrollListener(mScrollListener);\n\n        mNoResultsView = view.findViewById(R.id.no_results_layout);\n\n        final Toolbar toolbar = view.findViewById(R.id.search_toolbar);\n        activity.setActionBar(toolbar);\n        activity.getActionBar().setDisplayHomeAsUpEnabled(true);\n\n        mSearchView = toolbar.findViewById(R.id.search_view);\n        // Query数据保存到 mQuery中. 触发时机为onQueryTextSubmit 和  onQueryTextChange时\n        // 封装了SearchView, 为Search Toolbar对应的布局.\n        mSearchView.setQuery(mQuery, false /* submitQuery */);\n        mSearchView.setOnQueryTextListener(this);\n        mSearchView.requestFocus();\n\n        return view;\n    }\n}\n```\n\n### 2.2.2. provider.updateIndexAsync\n这个地方在SearchFragment进入时, 又更新了一遍搜索数据库index, 需要重点看下, 整个过程为启动AsyncTask, 检索数据, 对数据进行处理, 放在数据库中. \n在AsyncTask中执行, 检索完成后调用callback. 回调`SearchFragment.onIndexingFinished`方法\n\n```java\n1. -> // 1. mSearchFeatureProvider.updateIndexAsync(getContext(), this /* indexingCallback */);\n// 数据的更新直接参与者都是provider, 只不过这里的provider更加抽象, 前面查到数据后往数据库里写的操作\n// callback为本身, 加载完成后通过AsyncTask的onPostExecute回调onIndexingFinished\n    public void updateIndexAsync(Context context, IndexingCallback callback) {\n        getIndexingManager(context).indexDatabase(callback);\n    }\n\n    @Override\n    public DatabaseIndexingManager getIndexingManager(Context context) {\n        if (mDatabaseIndexingManager == null) {\n            // 关联到 数据库索引管理类, 单例\n            mDatabaseIndexingManager = new DatabaseIndexingManager(context.getApplicationContext());\n        }\n        return mDatabaseIndexingManager;\n    }\n    // 启动AsyncTask\n    public void indexDatabase(IndexingCallback callback) {\n        IndexingTask task = new IndexingTask(callback);\n        task.execute();\n    }\n\n    public class IndexingTask extends AsyncTask<Void, Void, Void> {\n        protected Void doInBackground(Void... voids) {\n            1.1 performIndexing();\n            return null;\n        }\n    }\n\n1.2 // 加载完成回调SearchFragment.onIndexingFinished\n    public void onIndexingFinished() {\n        if (getActivity() == null) {\n            return;\n        }\n        if (mShowingSavedQuery) {\n            mSavedQueryController.loadSavedQueries();\n        } else {\n            final LoaderManager loaderManager = getLoaderManager();\n            loaderManager.initLoader(SearchLoaderId.SEARCH_RESULT, null /* args */,\n                    this /* callback */);\n        }\n\n        requery();\n    }\n\n\n    1.1 -> // performIndexing\n\n    public void performIndexing() {\n        // 通过intent 匹配 action provider, 关联到了 SettingsSearchIndexablesProvider\n        final Intent intent = new Intent(SearchIndexablesContract.PROVIDER_INTERFACE);\n        final List<ResolveInfo> providers =\n                mContext.getPackageManager().queryIntentContentProviders(intent, 0);\n\n        final boolean isFullIndex = IndexDatabaseHelper.isFullIndex(mContext, providers);\n\n        if (isFullIndex) {\n            // 第一次进来, 会进入里面, 实际操作数据的是IndexDatabaseHelper类\n            1.1.1  rebuildDatabase();\n        }\n\n        // 获取数据\n        1.1.2 PreIndexData indexData = getIndexDataFromProviders(providers, isFullIndex);\n\n        final long updateDatabaseStartTime = System.currentTimeMillis();\n        // setIndex后, 会往sharePreference里写, isFullIndex就变为false, 首次的话 isFullIndex 为 true\n        1.1.3   updateDatabase(indexData, isFullIndex);\n        IndexDatabaseHelper.setIndexed(mContext, providers);\n    }\n\n\n```\n\n```xml\n        <provider\n            android:name=\".search.SettingsSearchIndexablesProvider\"\n            android:authorities=\"com.android.settings\"\n            android:multiprocess=\"false\"\n            android:grantUriPermissions=\"true\"\n            android:permission=\"android.permission.READ_SEARCH_INDEXABLES\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.content.action.SEARCH_INDEXABLES_PROVIDER\" />\n            </intent-filter>\n        </provider>\n\n```\n\n先看下数据库重建\n\n```java\n1.1.1 -> // 重建数据库表, 清空sharePreference\n    private void rebuildDatabase() {\n        // Drop the database when the locale or build has changed. This eliminates rows which are\n        // dynamically inserted in the old language, or deprecated settings.\n        final SQLiteDatabase db = getWritableDatabase();\n        IndexDatabaseHelper.getInstance(mContext).reconstruct(db);\n    }\n\n    public void reconstruct(SQLiteDatabase db) {\n        // 清空sharePreference\n        mContext.getSharedPreferences(SHARED_PREFS_TAG, Context.MODE_PRIVATE)\n                .edit()\n                .clear()\n                .commit();\n        //清空数据库的table\n        dropTables(db);\n        // 重建数据库table\n        bootstrapDB(db);\n    }\n\n1.1.2 -> //获取数据 这里的跟之前又有不同\n1.1.2 PreIndexData indexData = getIndexDataFromProviders(providers, isFullIndex);\n\n    PreIndexData getIndexDataFromProviders(List<ResolveInfo> providers, boolean isFullIndex) {\n        if (mCollector == null) {\n            // 单例关联到 PreIndexDataCollector类, 找到的provider为SettingsSearchIndexablesProvider\n            mCollector = new PreIndexDataCollector(mContext);\n        }\n        return mCollector.collectIndexableData(providers, isFullIndex);\n    }\n\n    public PreIndexData collectIndexableData(List<ResolveInfo> providers, boolean isFullIndex) {\n        mIndexData = new PreIndexData();\n\n        for (final ResolveInfo info : providers) {\n            // 权限相关\n            if (!isWellKnownProvider(info)) {\n                continue;\n            }\n            final String authority = info.providerInfo.authority;\n            final String packageName = info.providerInfo.packageName;\n\n// 首次重建\n            if (isFullIndex) {\n1.1.2.1                addIndexablesFromRemoteProvider(packageName, authority);\n            }\n1.1.2.2     addNonIndexablesKeysFromRemoteProvider(packageName, authority);\n\n        }\n\n        return mIndexData;\n    }\n\n1.1.2.1  -> // 构建查询uri, 查询SettingsSearchIndexablesProvider获取数据\n    private boolean addIndexablesFromRemoteProvider(String packageName, String authority) {\n        try {\n            final Context context = BASE_AUTHORITY.equals(authority) ?\n                    mContext : mContext.createPackageContext(packageName, 0);\n\n            // 构建xml的查询数据uri\n            final Uri uriForResources = buildUriForXmlResources(authority);\n            mIndexData.dataToUpdate.addAll(getIndexablesForXmlResourceUri(context, packageName,\n                    uriForResources, SearchIndexablesContract.INDEXABLES_XML_RES_COLUMNS));\n            // 构建rawdata的查询数据uri\n            final Uri uriForRawData = buildUriForRawData(authority);\n            // 查询完后, 统一放在mIndexData.dataToUpdate中\n            mIndexData.dataToUpdate.addAll(getIndexablesForRawDataUri(context, packageName,\n                    uriForRawData, SearchIndexablesContract.INDEXABLES_RAW_COLUMNS));\n            return true;\n        }\n    }\n\n1.1.2.2 ->// 构建查询uri, 查询查询SettingsSearchIndexablesProvider获取数据\n\n    private void addNonIndexablesKeysFromRemoteProvider(String packageName,\n            String authority) {\n        // 构建NonIndexableKeys的查询uri\n        final List<String> keys =\n                getNonIndexablesKeysFromRemoteProvider(packageName, authority);\n\n        if (keys != null && !keys.isEmpty()) {\n            // 查询到后统一放入mIndexData.nonIndexableKeys map中\n            mIndexData.nonIndexableKeys.put(authority, new ArraySet<>(keys));\n        }\n    }\n\n1.1.3 -> // 填充数据\n\n    void updateDatabase(PreIndexData preIndexData, boolean needsReindexing) {\n        final Map<String, Set<String>> nonIndexableKeys = preIndexData.nonIndexableKeys;\n\n        final SQLiteDatabase database = getWritableDatabase();\n        try {\n            database.beginTransaction();\n\n            // Convert all Pre-index data to Index data.\n            // 重新获取元数据, 对元数据进行处理\n            1.1.3.1 List<IndexData> indexData = getIndexData(preIndexData);\n            // 获取元数据后, 插入数据库相应字段中   跟 insertSliceData 对比\n            1.1.3.2 insertIndexData(database, indexData);\n\n            // Only check for non-indexable key updates after initial index.\n            // Enabled state with non-indexable keys is checked when items are first inserted.\n            // 当前场景为首次, needsReindexing为true, 下面流程不走\n            if (!needsReindexing) {\n            1.1.3.3    updateDataInDatabase(database, nonIndexableKeys);\n            }\n\n            database.setTransactionSuccessful();\n        } finally {\n            database.endTransaction();\n        }\n    }\n\n1.1.3.1-> //  List<IndexData> indexData = getIndexData(preIndexData);\n    List<IndexData> getIndexData(PreIndexData data) {\n        if (mConverter == null) {\n            mConverter = new IndexDataConverter(mContext);\n        }\n        return mConverter.convertPreIndexDataToIndexData(data);\n    }\n\n    public List<IndexData> convertPreIndexDataToIndexData(PreIndexData preIndexData) {\n        final long current = System.currentTimeMillis();\n        // 取出从xml资源和rawdata数据\n        final List<SearchIndexableData> indexableData = preIndexData.dataToUpdate;\n        // 取出nonIndexableKeys获得的数据\n        final Map<String, Set<String>> nonIndexableKeys = preIndexData.nonIndexableKeys;\n        final List<IndexData> indexData = new ArrayList<>();\n\n        for (SearchIndexableData data : indexableData) {\n            if (data instanceof SearchIndexableRaw) {\n                final SearchIndexableRaw rawData = (SearchIndexableRaw) data;\n                final Set<String> rawNonIndexableKeys = nonIndexableKeys.get(\n                        rawData.intentTargetPackage);\n                // builder模式, nonIndexableKeys最终作用到了IndexData的enabled字段, 最终放在了values.put(ENABLED, dataRow.enabled);里, 可能后面数据库查询时会用到\n                final IndexData.Builder builder = convertRaw(rawData, rawNonIndexableKeys);\n\n                if (builder != null) {\n                    indexData.add(builder.build(mContext));\n                }\n            } else if (data instanceof SearchIndexableResource) {\n                final SearchIndexableResource sir = (SearchIndexableResource) data;\n                final Set<String> resourceNonIndexableKeys =\n                        getNonIndexableKeysForResource(nonIndexableKeys, sir.packageName);\n                final List<IndexData> resourceData = convertResource(sir, resourceNonIndexableKeys);\n                indexData.addAll(resourceData);\n            }\n        }\n        return indexData;\n    }\n\n1.1.3.2 -> // 更新数据库字段,  注意跟SlicesIndexer.insertSliceData的不同, 替换的是TABLE_SLICES_INDEX表\n    void insertIndexData(SQLiteDatabase database, List<IndexData> indexData) {\n        ContentValues values;\n\n        for (IndexData dataRow : indexData) {\n            if (TextUtils.isEmpty(dataRow.normalizedTitle)) {\n                continue;\n            }\n\n            values = new ContentValues();\n            values.put(IndexDatabaseHelper.IndexColumns.DOCID, dataRow.getDocId());\n            values.put(LOCALE, dataRow.locale);\n            values.put(DATA_TITLE, dataRow.updatedTitle);\n            values.put(DATA_TITLE_NORMALIZED, dataRow.normalizedTitle);\n            values.put(DATA_SUMMARY_ON, dataRow.updatedSummaryOn);\n            values.put(DATA_SUMMARY_ON_NORMALIZED, dataRow.normalizedSummaryOn);\n            values.put(DATA_ENTRIES, dataRow.entries);\n            values.put(DATA_KEYWORDS, dataRow.spaceDelimitedKeywords);\n            values.put(CLASS_NAME, dataRow.className);\n            values.put(SCREEN_TITLE, dataRow.screenTitle);\n            values.put(INTENT_ACTION, dataRow.intentAction);\n            values.put(INTENT_TARGET_PACKAGE, dataRow.intentTargetPackage);\n            values.put(INTENT_TARGET_CLASS, dataRow.intentTargetClass);\n            values.put(ICON, dataRow.iconResId);\n            values.put(ENABLED, dataRow.enabled);\n            values.put(DATA_KEY_REF, dataRow.key);\n            values.put(USER_ID, dataRow.userId);\n            values.put(PAYLOAD_TYPE, dataRow.payloadType);\n            values.put(PAYLOAD, dataRow.payload);\n\n// 注意替换的表\n            database.replaceOrThrow(TABLE_PREFS_INDEX, null, values);\n\n            if (!TextUtils.isEmpty(dataRow.className)\n                    && !TextUtils.isEmpty(dataRow.childClassName)) {\n                final ContentValues siteMapPair = new ContentValues();\n                siteMapPair.put(SiteMapColumns.PARENT_CLASS, dataRow.className);\n                siteMapPair.put(SiteMapColumns.PARENT_TITLE, dataRow.screenTitle);\n                siteMapPair.put(SiteMapColumns.CHILD_CLASS, dataRow.childClassName);\n                siteMapPair.put(SiteMapColumns.CHILD_TITLE, dataRow.updatedTitle);\n// 注意替换的表\n                database.replaceOrThrow(IndexDatabaseHelper.Tables.TABLE_SITE_MAP,\n                        null /* nullColumnHack */, siteMapPair);\n            }\n        }\n    }\n\n1.1.3.3 -> // updateDataInDatabase(database, nonIndexableKeys); 这个方法是转换往数据库中更新enable的值.\n     * All rows which are enabled but are now flagged with non-indexable keys will become disabled.\n     * All rows which are disabled but no longer a non-indexable key will become enabled.\n\n```\n\n获取数据的PreIndexDataCollector类为客户端, 匹配到Authority的远端的provider为`SettingsSearchIndexablesProvider`\n该类在内部通过`DatabaseIndexingUtils`工具类遍历注册的Indexable.SEARCH_INDEX_DATA_PROVIDER, 找到子类覆写的getXmlResourcesToIndex/getRawDataToIndex/getNonIndexableKeys/getPreferenceControllers方法, 如果没有覆写, 则使用其基类BaseSearchIndexProvider的方法\n检索元数据.\n\n在检索元数据,并将数据放入数据库中后, 检索的AsyncTask走完, 会回调\n\n### 2.2.3. 检索完数据, 回调onIndexingFinished方法\n\n```java\n1.2 -> // onIndexingFinished\n\n    public void onIndexingFinished() {\n        if (getActivity() == null) {\n            return;\n        }\n        // mShowingSavedQuery首次加载是为true.\n        if (mShowingSavedQuery) {\n   1.2.1     mSavedQueryController.loadSavedQueries();\n        } else {\n            final LoaderManager loaderManager = getLoaderManager();\n            loaderManager.initLoader(SearchLoaderId.SEARCH_RESULT, null /* args */,\n                    this /* callback */);\n        }\n\n    1.2.2    requery();\n    }\n1.2.1 -> // Loader restart\n    public void loadSavedQueries() {\n        mLoaderManager.restartLoader(SearchFragment.SearchLoaderId.SAVED_QUERIES, null /* args */,\n                this /* callback */);\n    }\n```\n调用restartLoader后, Loader的生命周期就开启了\n\n### 2.2.4. 进入Loader流程\n\n缓存Loader的控制在SavedQueryController中, `SAVED_QUERIES`应该是保存的查询项的缓存, 缓存结果保存在了saved_queries表中.\n真正查询的地方在id为 SEARCH_RESULT的SearchResultLoader中, 是由TextChange事件触发的. \n\n```java\n    @Override\n    public Loader onCreateLoader(int id, Bundle args) {\n        switch (id) {\n            case SearchFragment.SearchLoaderId.SAVE_QUERY_TASK:\n                return new SavedQueryRecorder(mContext, args.getString(ARG_QUERY));\n            case SearchFragment.SearchLoaderId.REMOVE_QUERY_TASK:\n                return new SavedQueryRemover(mContext);\n            case SearchFragment.SearchLoaderId.SAVED_QUERIES:\n                return mSearchFeatureProvider.getSavedQueryLoader(mContext);\n        }\n        return null;\n    }\n```\n\n在onQueryTextChange时会触发\n\n### 2.2.5. 触发查询\n\n```java\n    // 查询条件为 query\n    public boolean onQueryTextChange(String query) {\n        // 上次缓存的条件为 mQuery\n        if (TextUtils.equals(query, mQuery)) {\n            return true;\n        }\n\n        final boolean isEmptyQuery = TextUtils.isEmpty(query);\n\n        // Hide no-results-view when the new query is not a super-string of the previous\n        if (mQuery != null\n                && mNoResultsView.getVisibility() == View.VISIBLE\n                && query.length() < mQuery.length()) {\n            mNoResultsView.setVisibility(View.GONE);\n        }\n\n        mNeverEnteredQuery = false;\n        mQuery = query;\n\n        // If indexing is not finished, register the query text, but don't search.\n        // index 索引未完成的情况下, 先保存查询条件, 待index结束后, 回调callback, 执行requery查询\n        if (!mSearchFeatureProvider.isIndexingComplete(getActivity())) {\n            return true;\n        }\n        // 查询条件为空, 取出缓存的查询项结果\n        if (isEmptyQuery) {\n            final LoaderManager loaderManager = getLoaderManager();\n            loaderManager.destroyLoader(SearchLoaderId.SEARCH_RESULT);\n            mShowingSavedQuery = true;\n            mSavedQueryController.loadSavedQueries();\n            mSearchFeatureProvider.hideFeedbackButton(getView());\n        } else {\n            // 开始查询\n 2.           restartLoaders();\n        }\n        return true;\n    }\n\n\n    private void restartLoaders() {\n        mShowingSavedQuery = false;\n        final LoaderManager loaderManager = getLoaderManager();\n        loaderManager.restartLoader(\n                SearchLoaderId.SEARCH_RESULT, null /* args */, this /* callback */);\n    }\n\n    public Loader<List<? extends SearchResult>> onCreateLoader(int id, Bundle args) {\n        final Activity activity = getActivity();\n\n        switch (id) {\n            case SearchLoaderId.SEARCH_RESULT:\n                return mSearchFeatureProvider.getSearchResultLoader(activity, mQuery);\n            default:\n                return null;\n        }\n    }\n\n    public SearchResultLoader getSearchResultLoader(Context context, String query) {\n        return new SearchResultLoader(context, cleanQuery(query));\n    }\n    // 异步执行AsyncLoader的loadInBackground, 由构造函数传入了查询条件mQuery\n    public class SearchResultLoader extends AsyncLoader<List<? extends SearchResult>> {\n        public List<? extends SearchResult> loadInBackground() {\n            SearchResultAggregator aggregator = SearchResultAggregator.getInstance();\n 2.1           return aggregator.fetchResults(getContext(), mQuery);\n        }\n    }\n\n    public synchronized List<? extends SearchResult> fetchResults(Context context, String query) {\n        final SearchFeatureProvider mFeatureProvider = FeatureFactory.get(context)\n                .searchFeatureProvider();\n        final ExecutorService executorService = mFeatureProvider.getExecutorService();\n\n// 这里封装了四个Task, 但最终索要结果的只有一个Task.\n        final List<SearchQueryTask> tasks =\n                mFeatureProvider.getSearchQueryTasks(context, query);\n\n\n        public List<SearchQueryTask> getSearchQueryTasks(Context context, String query) {\n            final List<SearchQueryTask> tasks = new ArrayList<>();\n            final String cleanQuery = cleanQuery(query);\n            tasks.add(DatabaseResultTask.newTask(context, getSiteMapManager(), cleanQuery));\n            tasks.add(InstalledAppResultTask.newTask(context, getSiteMapManager(), cleanQuery));\n            tasks.add(AccessibilityServiceResultTask.newTask(context, getSiteMapManager(), cleanQuery));\n            tasks.add(InputDeviceResultTask.newTask(context, getSiteMapManager(), cleanQuery));\n            return tasks;\n        }\n\n        // Start tasks, 执行task \n        for (SearchQueryTask task : tasks) {\n2.2            executorService.execute(task);\n        }\n\n        // Collect results\n        final Map<Integer, List<? extends SearchResult>> taskResults = new ArrayMap<>();\n        for (SearchQueryTask task : tasks) {\n            final int taskId = task.getTaskId();\n            try {\n                // 以taskid为键值, 存入taskResults中, task.get会阻塞, 未执行完不会返回\n                taskResults.put(taskId,\n                        task.get(SHORT_CHECK_TASK_TIMEOUT_MS, TimeUnit.MILLISECONDS));\n            }\n        }\n\n        // Merge results\n2.3        final List<? extends SearchResult> mergedResults = mergeSearchResults(taskResults);\n\n        return mergedResults;\n    }\n```\n#### 2.2.5.1. DatabaseResultTask执行过程\n\nDatabaseResultTask并不是AsyncTask, 而是java中的FutureTask机制, 这里简单看一下执行过程.\n\n```java\n2.2 -> // Add and execute\n    tasks.add(DatabaseResultTask.newTask(context, getSiteMapManager(), cleanQuery));\n\n    public class DatabaseResultTask extends SearchQueryTask.QueryWorker {\n        public static SearchQueryTask newTask(Context context, SiteMapManager siteMapManager,\n                String query) {\n            return new SearchQueryTask(new DatabaseResultTask(context, siteMapManager, query));\n        }\n\n        private Set<SearchResult> query(String whereClause, String[] selection, int baseRank) {\n            final SQLiteDatabase database =\n                    IndexDatabaseHelper.getInstance(mContext).getReadableDatabase();\n            try (Cursor resultCursor = database.query(TABLE_PREFS_INDEX, SELECT_COLUMNS,\n                    whereClause,\n                    selection, null, null, null)) {\n                return mConverter.convertCursor(resultCursor, baseRank, mSiteMapManager);\n            }\n        }\n    }\n\n\n    public class SearchQueryTask extends FutureTask<List<? extends SearchResult>> {\n\n        public SearchQueryTask(@NonNull QueryWorker queryWorker) {\n            super(queryWorker);\n            mId = queryWorker.getQueryWorkerId();\n        }\n\n        public static abstract class QueryWorker implements Callable<List<? extends SearchResult>> {\n            public List<? extends SearchResult> call() throws Exception {\n                final long startTime = System.currentTimeMillis();\n                try {\n                    return query();\n                } finally {\n                }\n            }\n        }\n\n    }\n```\n\n相关类图\n\n```plantuml\n@startuml\n\nclass FutureTask\npackage SearchQueryTask {\n    class SearchQueryTask extends FutureTask {\n        QueryWorker queryWorker\n    }\n\n    abstract class QueryWorker implements Callable {\n            <b>call()\n            query()\n    }\n\n    QueryWorker -d-o SearchQueryTask\n}\n\nclass DatabaseResultTask extends QueryWorker {\n    <b>query()\n}\n@enduml\n```\n\n#### 2.2.5.2. 查询过程\n\n真正的查询是通过FutureTask的 execute执行call方法, 最终走到子类DatabaseResultTask的query中执行的查询\n\n```java\n\n    protected List<? extends SearchResult> query() {\n        if (mQuery == null || mQuery.isEmpty()) {\n            return new ArrayList<>();\n        }\n        // Start a Future to get search result scores.\n        // 出现几个Task了, Task嵌套Task再嵌套Task\n        FutureTask<List<Pair<String, Float>>> rankerTask = mFeatureProvider.getRankerTask(\n                mContext, mQuery);\n        // 这里并没有指定RankerTask, 忽略\n        if (rankerTask != null) {\n            ExecutorService executorService = mFeatureProvider.getExecutorService();\n            executorService.execute(rankerTask);\n        }\n\n        final Set<SearchResult> resultSet = new HashSet<>();\n        // 这里分别根据几个字段分别查, 最终结果保存到resultSet. 查询条件中都有AND enabled = 1, 与前面数据库enabled字段相匹配\n        // 第二个参数为评分分数, 与结果的展示有关, resultSet有去重功能\n        3.1 resultSet.addAll(firstWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[0]));\n        resultSet.addAll(secondaryWordQuery(MATCH_COLUMNS_PRIMARY, BASE_RANKS[1]));\n        resultSet.addAll(anyWordQuery(MATCH_COLUMNS_SECONDARY, BASE_RANKS[2]));\n        resultSet.addAll(anyWordQuery(MATCH_COLUMNS_TERTIARY, BASE_RANKS[3]));\n\n        // Try to retrieve the scores in time. Otherwise use static ranking.\n        // rankerTask为空, 忽略, 排名相关\n        if (rankerTask != null) {\n...\n        }\n\n        List<SearchResult> resultList = new ArrayList<>(resultSet);\n        // 采用默认排序\n        Collections.sort(resultList);\n        return resultList;\n    }\n\n    // 这里只看第一个查询条件即可\n    3.1 -> // firstWordQuery\n    private Set<SearchResult> firstWordQuery(String[] matchColumns, int baseRank) {\n        // whereClause是匹配字段, selection是通过mQuery定的匹配条件\n        final String whereClause = buildSingleWordWhereClause(matchColumns);\n        final String query = mQuery + \"%\";\n        final String[] selection = buildSingleWordSelection(query, matchColumns.length);\n\n        return query(whereClause, selection, baseRank);\n    }\n\n    private Set<SearchResult> query(String whereClause, String[] selection, int baseRank) {\n        final SQLiteDatabase database =\n                IndexDatabaseHelper.getInstance(mContext).getReadableDatabase();\n        try (Cursor resultCursor = database.query(TABLE_PREFS_INDEX, SELECT_COLUMNS,\n                whereClause,\n                selection, null, null, null)) {\n            // 查询结果由CursorToSearchResultConverter 转化为 SearchResult的集合\n            return mConverter.convertCursor(resultCursor, baseRank, mSiteMapManager);\n        }\n    }\n\n    2.3 -> //合并结果, 只取了DatabaseResultTask的结果, 其他的task执行并未索取\n    \n    private List<? extends SearchResult> mergeSearchResults(\n            Map<Integer, List<? extends SearchResult>> taskResults) {\n\n        final List<SearchResult> searchResults = new ArrayList<>();\n        // First add db results as a special case\n        // \n        searchResults.addAll(taskResults.remove(DatabaseResultTask.QUERY_WORKER_ID));\n\n        // Merge the rest into result list: add everything to heap then pop them out one by one.\n        final PriorityQueue<SearchResult> heap = new PriorityQueue<>();\n        for (List<? extends SearchResult> taskResult : taskResults.values()) {\n            heap.addAll(taskResult);\n        }\n        while (!heap.isEmpty()) {\n            searchResults.add(heap.poll());\n        }\n        return searchResults;\n    }\n\n```\n\n### 2.2.6. 搜索结果显示\n\n在走完AsyncLoader的loadInBackground后会进入LoaderCallbacks的onLoadFinished方法中, SearchResultsAdapter为RecyclerView, 保存单项的显示结果\n响应顺序:\n->`getItemViewType`(拿到viewType)\n->`onCreateViewHolder`(根据viewType设置自定义holder)\n->`onBindViewHolder`(响应自定义holder的onBind方法)\n\n```java\n    public void onLoadFinished(Loader<List<? extends SearchResult>> loader,\n            List<? extends SearchResult> data) {\n        mSearchAdapter.postSearchResults(data);\n    }\n\n    public int getItemViewType(int position) {\n        return mSearchResults.get(position).viewType;\n    }\n\n    public SearchViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        final Context context = parent.getContext();\n        final LayoutInflater inflater = LayoutInflater.from(context);\n        final View view;\n        switch (viewType) {\n            // RecyleView 可以随意更换item的布局, viewType来自getItemViewType方法\n            // IntentSearchViewHolder中定义了item的点击事件\n            case ResultPayload.PayloadType.INTENT:\n                view = inflater.inflate(R.layout.search_intent_item, parent, false);\n                return new IntentSearchViewHolder(view);\n            case ResultPayload.PayloadType.INLINE_SWITCH:\n                view = inflater.inflate(R.layout.search_intent_item, parent, false);\n                return new IntentSearchViewHolder(view);\n            case ResultPayload.PayloadType.INLINE_LIST:\n                view = inflater.inflate(R.layout.search_intent_item, parent, false);\n                return new IntentSearchViewHolder(view);\n            case ResultPayload.PayloadType.SAVED_QUERY:\n                view = inflater.inflate(R.layout.search_saved_query_item, parent, false);\n                return new SavedQueryViewHolder(view);\n            default:\n                return null;\n        }\n    }\n\n    public void onBindViewHolder(SearchViewHolder holder, int position) {\n        // 响应自定义的holder的onBind\n        holder.onBind(mFragment, mSearchResults.get(position));\n    }\n\n    public class IntentSearchViewHolder extends SearchViewHolder {\n        public void onBind(final SearchFragment fragment, final SearchResult result) {\n            super.onBind(fragment, result);\n            final SearchViewHolder viewHolder = this;\n            itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    // 点击跳转到对应的intent\n                    fragment.onSearchResultClicked(viewHolder, result);\n                    final Intent intent = result.payload.getIntent();\n                    // Use app user id to support work profile use case.\n                    if (result instanceof AppSearchResult) {\n                        AppSearchResult appResult = (AppSearchResult) result;\n                        fragment.getActivity().startActivity(intent);\n                    } else {\n                        final PackageManager pm = fragment.getActivity().getPackageManager();\n                        final List<ResolveInfo> info = pm.queryIntentActivities(intent, 0 /* flags */);\n                        if (info != null && !info.isEmpty()) {\n                            fragment.startActivityForResult(intent, REQUEST_CODE_NO_OP);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n```\n","tags":["设计模式","Settings Search"],"categories":["设计模式","读书"]},{"title":"文件加密FBE&DirectBoot模式介绍","url":"/2018/10/12/OTA相关/硬件加密整理/","content":"\n文件加密FBE&DirectBoot模式介绍\n\n# 1. File based Encryption\n\nAndroid 7.0及以上版本提供基于文件的加密方式(FBE). 这种方式允许使用不同的密钥对不同的文件进行加密, 并且可以独立进行解密.\nAndroid 7.0为基于文件的加密引入了新的功能, 命名为Direct Boot. 它允许加密设备直接启动至锁定屏幕的状态. 在以前的版本中, 使用全局磁盘加密(FDE)的设备,\n用户需要在任何数据能够被访问前提供认证凭证(图形/密码/指纹), 来预防设备可能被进行的任何基本操作.\n如: 闹钟无法执行, 辅助功能服务无法使用, 电话无法接受通话请求, 除了最基本的紧急通话操作.\n使用基于文件加密的设备, 应用可以了解当前加密的情况, 同时被允许执行限定范围内的操作. 这些操作能够在用户提供认证凭证前执行, 同时依然能够保护私有用户信息.\n在使用FBE的设备上, 设备的每个用户对于设备应用均拥有两个存储空间:\n\n- 凭证加密存储区间(`Credential Encrypted (CE)`), 这是缺省的存储空间, 并且只有当用户解锁设备后才可用.\n- 设备加密存储空间(`Device Encrypted (DE)`), 该存储空间在Direct Boot模式和用户解锁设备后均可用.\n\n## 1.1. FDE Vs FBE:\n\n- FBE: FILE BASED ENCRYPTION:\n  - 每一个用户一个CE key，CE key的加密信息存储在data分区的相应文件夹中。\n  - 每个用户对应一个DE key，除此之外，还有一个全局的DE key用来为与用户非强关联的文件夹设置加密。\n  - 设备未解锁之前，可以使用CE区域以外的文件夹。\n  - 加密针对文件夹级别，加密机制利用了Ext4 文件系统的加密特性。\n  - 这种区分能够使工作模型更为安全, 因为它允许在同一时间能够保护多个用户，并不是基于一个启动时密码。\n- FDE（FULL DISK ENCTYPTION）\n  - 只有一个key，key的加密信息存储在磁盘尾部区域。\n  - 设备未解锁之前，data目录是以tmpfs格式挂载的data分区处于完全不可使用状态。\n  - 加密针对的是分区级别，加密机制利用了dm-crypt加密特性。\n\n## 1.2. Dependencies\n\n设备必须满足以下的要求来安全使用AOSP的FBE实现:\n\n- Kernel支持ext4加密(相关的kernel config为: EXT4_FS_ENCRYPTION)\n\n- Keymaster支持1.0/2.0的HAL版本. 0.3版本的keymaster hal并不提供相关需要的属性支持, 而且不能保证加密密钥的安全保护机制.\n\n- Keymaster/Keystore 和 GateKeeper必须在可信任执行环境(TEE)中实现, 用以提供对DE密钥的保护, 该情况下, 未认证的系统OS(自行输入到设备上的OS)将不能简单的访问DE密钥.\n\n- kernel中提供的加密性能必须达到使用AES-XTS时最低为50MB/s来保证良好的用户体验.\n\n- Verified Boot机制下 Keymaster root of trust 必须绑定至keymaster的初始化过程中. 这将保证设备加密证书不会被未验证的操作系统访问到\n\n- bootloader passes the following information to the TEE after boot/recovery partition verification and\n\n  TEE initialization to bind the Keymaster root of trust:\n\n  - the public key that was used to sign the boot partition\n\n## 1.3. 加密规则 Encryption policy\n\nExt4加密可以将加密规则应用到文件夹级别. 当设备的用户数据分区初次创建时, 由init脚本来赋值基本的结构和规则. 该脚本同时会触发来创建第一个用户(0用户)的CE/DE密钥, 并且定义那些目录需要由该密钥进行加密.\n当其余的用户和工作模式被创建时, 相关所需的密钥会被创建, 相关的存储目录会被创建并且由加密规则将密钥和目录链接起来.\n在当前的AOSP实现中, 加密规则被硬编码到以下的位置:\n`/system/extras/ext4_utils/ext4_crypt_init_extensions.cpp`\n可以通过在这个文件中增加例外的规则来避免指定的目录被加密, 目录可以加入到directories_to_exclude列表中. 如果进行了该类的修改, 设备提供商必须包含增加SElinux的规则, 以使得只有必须使用未加密目录的应用才能获取访问权限, 其他未授权的应用必须被排除在外.\n\n## 1.4. 打开文件加密特性\n\nfstab中指定标志位 fileencryption 时默认开启文件加密。\n`/dev/block/platform/soc.0/f9824900.sdhci/by-name/userdata /data ext4 noatime,nosuid,nodev,barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic wait,check,fileencryption`\n同时可以通过以下方法来测试设备上的FBE实现. 可以指定标志位:\nforcefdeorfbe\n开启该标志位后，在开发者选项中，会多出一个菜单`convert encryption to file`。用户点击后，可以开启设备的文件加密特性。\nfastboot模式中也可以转变FBE模式:\n`$ fastboot --wipe-and-use-fbe`\n\n## 1.5. 文件加密相关流程\n\n### 1.5.1. Implementation\n\n- Setting中开启文件加密\n\n  - forcefdeorfbe\n  - forcefdeorfbe\n    ==> covert to file encryption\n    MASTER_CLEAR-> wipe --reason=convert_fbe --> wipe_data -->\n    format --> make_ext4fs_directory(CONVERT_FBE_DIR)\n\n- fs阶段 mount_all时判断是否进入文件加密模式\n\n  - MF_FILEENCRYPTION\n  - MF_FORCEFDEORFBE&data/convert_fbe 文件存在\n    - install_keyring 调用add_key 创建一个session keyring\n    - 密钥环创建完成后，设置属性：\n      - ro.crypto.state encrypted\n      - ro.crypto.type file\n\n- post-fs-data （late-init阶段 trigger）installkey 前置条件：ro.crypto.type=file\n\n  - installkey\n\n    - 创建目录 /data/unencrypted\n    - 启动vdc service 对vold下发命令 cryptfs enablefilecrypto\n      - 创建/data/unencrypted/key 目录\n      - 读取随机密钥ikey1： /dev/urandom 读取 64字节作为文件加密的主密钥\n      - 读取密钥种子 /dev/urandom 读取1 << 14字节存储到 secdiscardable文件中\n      - 将scrypt扩展因子存储到stretching文件中 （ro.crypto.scrypt_params）\n      - 读取加密盐 /dev/urandom 读取1 << 4字节存储到salt文件中\n      - 根据auth token（验证令牌）、密钥种子、扩展因子、加密盐生成APPLICATION_ID\n      - TEE根据auth token和 APPLICATION_ID 生成`keymaster_key_blob`（加密数据块）数据保存在 keymaster_key_blob文件中。\n      - TEE根据auth token、APPLICATION_ID、keymaster_key_blob、随机密钥ikey1生成加密主键保存在encrypted_key文件中。\n      - 对ikey1 做两次Sha512算法处理，得到ikey1的摘要key_ref2\n      - 搜索keyring（找到前面fs阶段调用add_key建立的session keyring），返回keyring的序列号\n      - 将当前的ikey1经过封装后加入到该keyring中。\n        - ikey1封装成payload数据块。\n          - mode: EXT4_ENCRYPTION_MODE_AES_256_XTS\n          - ikey1\n          - ikey1->size\n        - add_key( \"logon\", ext4:key_ref2, payload, session-keyring )\n      - 将ikey1的摘要key_ref2存储到/data/unencrypted/key/ref 文件中\n\n  - init_user0 (ro.crypto.type=file)\n\n    - 创建目录：\n\n      - data/misc/vold/user_keys\n      - data/misc/vold/user_keys/ce\n      - data/misc/vold/user_keys/de\n      - data/misc/vold/user_keys/de/0\n      - data/misc/vold/user_keys/ce/0\n\n    - create_and_install_user_keys\n\n      - 为user0 创建其对应的ce/de key\n        - 读取/dev/urandom 创建 ce_ikey1, de_ikey1\n        - 在data/misc/vold/user_keys/ce/0下根据ce_ikey1计算存储各个加密过程的文件。 存储到data/misc/vold/user_keys/ce/0/current\n        - 在data/misc/vold/user_keys/de/0下根据de_ikey1计算存储各个加密过程的文件。 存储到data/misc/vold/user_keys/de/0/\n        - 加密过程文件： version、secdiscardable、stretching、salt、keymaster_key_blob\n        - 将ce_ikey1,de_ikey1添加到keyring中。\n\n    - load_all_de_keys将根据加密过程文件进行解密出对应的de_key并安装到session-keyring中。\n\n    - e4crypt_prepare_user_storage(DE) 准备DE区域文件夹，并设置加密策略. 以空token和seceret调用e4crypt_unlock_user_key 计算ce_key,或初始化ce_key\n\n      - e4crypt_prepare_user_storage\n\n        - /data/misc_de/0\n\n        - /data/system_de/0\n\n        - /data/user_de/0/\n\n        - 加密策略存储在文件系统级别，通过\n\n          ```\n          ioctl (fd, EXT4_IOC_SET_ENCRYPTION_POLICY | EXT4_IOC_GET_ENCRYPTION_POLICY, & ext4_encryption_policy)\n          ```\n\n          ，主要是master_key_descriptor字段，保存了de_key的摘要信息。如果文件夹是空文件夹，则执行SET，非空则GET，并校验policy信息是否正确。\n\n          - e4crypt_unlock_user_key\n            - 前置条件 ro.crypto.type=file persist.sys.emulate_fbe=false\n            - 解密的流程与前面create_and_install_user_keys的思路基本一致。在`/data/misc/vold/user_keys/<userid>/current`目录下读取**version、secdiscardable、stretching、salt、keymaster_key_blob、encrypted_key及auth 解出加密键 ce_key**。将解出的key（对应前面的随机key）进行两次Sha512计算得出摘要。\n            - 将计算出的ce_key，摘要作为descriptor，add logon key 到 session-keyring中。\n\n## 1.6. ext4 加密\n\nAOSP实现使用kernel中的ext4加密功能, kernel被配置为:\n\n- 使用XTS模式的 AES-256 加密文件内容.\n- 使用CBC-CTS模式的AES-256 加密文件名.\n  密钥管理:\n- 使用512位的AES-XTS密钥作为文件的加密密钥\n- 它被保存在TEE中的另一份密钥进行加密，加密之后保存到encrypt_key文件中\n- 如果需要使用TEE密钥, 必须满足以下三个条件:\n  - 验证令牌. The auth token\n    Auth token是由GateKeeper在用户成功登录时产生的加密令牌. TEE只有在正确的加密令牌被提供时才能够对AES-XTS密钥进行处理. 如果当前用户并没有证书, 那么验证的令牌将不被使用。\n  - 扩展证书. The stretched credential\n    Stretched credential是用户的证书, 同时经过了加密算法和加盐的处理. 并且在由lock setting服务传递给vold进行加密运算前, 还进行过hash处理. 该证书同所有通过APPLICATION_ID进行的提权行为绑定, 并通过TEE中的密钥进行加密. 如果用户没有证书, 该扩展证书将不存在或者没有必要使用.\n  - 随机hash. The “secdiscardable hash”\n    `Secdiscardable hash`是一个随机的16KB单独存放的文件, 用来重建密钥, 密码种子. 这份文件将在密钥删除时同样被安全删除掉, 或者被以其他方式再加密. 这个额外的保护将限制攻击者必须使用这个文件重建密钥. 这同样通过APPLICATION_ID同TEE中的密钥进行绑定.\n\n> 所有的DE KEY、 默认密码的CE KEY及global key，对应空的token、空的secret、空的用户证书，保证了不需要用户参与即可解锁。APPLICATION_ID可以理解为同TEE的一次会话连接ID。\n\n## 1.7. 密钥管理\n\n![密钥管理](_v_images/20190314173517721_1383852013.png)\n\n## 1.8. FBE开机流程\n\nrecoveryinitvoldformat_volume(/data)/data/convert_fbemount_allinstall_keyringro.crypto.state=encryptedro.encrypto.type=fileinstallkeyvdc vold enablefileencryptoinit_user0mkdirdecrypt key from/data/uncrypt/refe4crypt_policy_ensure(dir)apply a global policy to all /data/ folderscreated viamkdirenablefileencryptodecrypt key/data/uncrypted/refe4crypt_initialize_global_de/data/unencrypted/keyversionsecdiscardablesaltstretchingencrypted_keykeymaster_key_blobadd key to keyring Logon/dev/unrandom 64bite4crypt_init_user0create_and_install_user_keys/data/misc/vold/user_keys/de/0/data/misc/vold/user_keys/ce/0/currentversionsecdiscardalbesaltstrectchingencrypted_keykeymaster_key_blobinstall_key(dekey&cekey)add_key to keyring logonload_all_de_keysdecrypt all dekey from diradd all key to keyringencrypt_prepare_user_storage(de)/data/system/users/0/data/misc/user/0/data/misc/profiles/cur/0/data/misc/profiles/cur/0/forign-dex//data/misc_de/0/data/system_de/0/data/user_de/0e4crypt_policy_ensure(dir)已经设置过加密, check当前的key_ref与node中保存的key_ref是否相同EXT4_IOC_GET_ENCRYPTION_POLICYioctl(fd,EXT4_IOC_SET_ENCRYPTION_POLICY,ext4_encryption_policy)fsinode set EXT4_INODE_ENCRYPT flag 访问文件夹时,会check EXT4_INODE_ENCRYPT flag如果有, 说明已经加密,会进行request_key的操作,policy==key_refconvert_to_file_encryption--wipe-data-reason=convert_fbeMF_FORCEFDEORFBEyesreboot生成reboot/data/convert_fbe && MF_FORCEFDEORFBEyesro.crypto.type is fileyesin directories_to_exclude/data/的下级目录no/data/uncrypted/key existyesno2-Sha512/data/misc/vold/user_keys/de/0 existno 123查询之前保存到内存中的key_ref信息dir is emptynot emptydir is empty\n\n## 1.9. 解锁流程\n\nAMSUserControllervoldbootAnimationCompletefinishBootingsendBootCompletedLockedfinishUserBootmaybeUnlockUserunlockUserClearedunlockUserKeyunlock_user_keyparse_hex(token, secret)retrieveKeydecrypt ce key from:/data/misc/vold/user_keys/ce/0/currentversionsecdiscardablesaltstretchingencrypted_keykeymaster_key_blobadd ce key to keyringsend prepare_user_storage to volde4crypt_unlock_user_key(ce)lookup ce_key_refs from s_ce_key_raw_refs:/data/system_ce/0/data/misc_ce/0/data/media/0/data/data/data/user/<userid>ensure_policy(dir)add user to mLocalUnlockedUsersfinishUserUnlockingonBeforeUnlockUserprepareUserDataprepareUserDataLIprepareUserStorage\"ro.crypto.file is file&&user not in mLocalUnlockedUsers\"yessuccess\n\n## 1.10. 加解密流程图\n\n![加密](_v_images/20190315102422314_506081545.png)\n![解密](_v_images/20190315102511557_679987494.png)\n\n# 2. Linux key retention service\n\n在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。\n密钥的属性:\n\n- 序列号（Serial number）：一个惟一的 32 位非零正数\n- 类型（Type）：Linux 密钥保留服务定义两个标准密钥类型：user 和 keyring。要添加新的密钥类型，必须由一个内核服务注册它。用户空间程序不允许创建新的密钥类型\n- 描述（Description）：一个描述密钥的可输出字符串。这个属性还可以用来执行搜索操作\n- 访问控制信息（Access control information）：每个密钥有一个所有者 ID、一个 GID 和一个权限掩码，权限掩码表示如何响应用户级或内核级程序。权限掩码给四个可能的密钥访问者类型各分配 8 位：所有者、用户、组和其他。\n- 密钥类型 (预定义的密钥类型)\n  - keyring\n  - user\n  - logon\n\n## 2.1. 访问控制信息\n\n| 访问控制信息 |   UID    |   GID    |  Other   | Permission Granted |\n| :----------: | :------: | :------: | :------: | :----------------: |\n|   01000000   | 00010000 | 00000100 | 00000001 |        View        |\n|   02000000   | 00020000 | 00000200 | 00000002 |        Read        |\n|   04000000   | 00040000 | 00000400 | 00000004 |       Write        |\n|   08000000   | 00080000 | 00000800 | 00000008 |       Search       |\n|   10000000   | 00100000 | 00001000 | 00000010 |        Link        |\n|   20000000   | 00200000 | 00002000 | 00000020 |   Set Attribute    |\n\n![keyring 钥匙环](_v_images/20190315103423887_1682470034.png)\n\n### 2.1.1. keyring\n\nKeyrings are special key types that may contain links to sequences of other keys of any type. If this interface is used to create a keyring.\nkeyring 包含一组到其他密钥或 keyring 的链接。\n\n- 线程特有的\n- 进程特有的\n- 会话特有的\n- 用户特有的会话\n- 用户默认的会话\n  用户特有的会话 keyring 通常会链接到一个会话特有的 keyring。\n  登录进程将绑定到用户默认的会话 keyring，直到创建另一个会话为止。\n\n#### 2.1.1.1. SESSION-KEYRING\n\n进程的session-keyring能够被其fork clone的进程保留。新进程可以通过设置uid、gid继承session\n当指向这个session-keyring的最后一个进程终止后，该session会被杀掉。\n进程可以创建新的session，也可以重新绑定已经存在的session。\n\n### 2.1.2. Linux key相关的系统调用\n\n- add_key 在用户空间中操作密钥\n  add_key 系统调用用来创建类型为 type、长度为 plen 的密钥。密钥描述由 desc 定义，它的有效内容由 payload 指定。密钥链接到 keyring。密钥类型可以是 user 或 keyring或logon（新增，与user类型的区别是不允许读payload的内容）。其他任何密钥类型必须已经通过内核服务向内核注册，然后才能使用。\n- request_key 由ext4 文件系统层调用\n  request_key 系统调用搜索一个进程 keyring，寻找一个密钥是否匹配查询的type和description。\n  查询不到返回ENOKEY（android中 Required key not available）\n\n```shell\n|-exam_dir\n       |-encrypt_file  \"abcd\"            read  modify rename ok\n       |-encrypt_dir\n\t      |-encrypt_file1 \"abcd\"\n                |-sub_dir                         mkdir touch \"No such file or directory\"    (no process inherit）\n#继承权限的有完全的访问读写权限, 没有继承的进程能查看修改当前已经有的文件，没法创建新的\n|-exam_dir\n       |-GWblA3FA88KbBtt70xeCHC  \"?\"                   mkdir create  mv \"No such file or directory\"\n       |-i5,V3FkRLu2LWiq8kqJSKC                              chmod   ok     rm ok\n\t      |-B,W714L8gi9jCZBChCUosA \"?\"             modify read  \"Required key not available\"\n                |-iDxJ0XhpXRowbkO2iPQHID\n```\n\n# 3. 在应用中支持Direct Boot\n\n```xml\n<application\n    android:directBootAware=\"true\"   适用所有应用\n    android:defaultToDeviceProtectedStorage=\"true\">   默认使用DE目录存储  仅适用于系统应用\n```\n\n应用级别的directBootAware作用是表明该应用中的所有组件都是已经和加密相关的.\n当DE区域解锁以后，应用可以收到`LOCKED_BOOT_COMPLETED`的广播，定义了`directBootAware`的组件可以使用\n即DE区域解锁以后，CE区域解锁之前，只有定义`directBootAware`的组件可以使用\n`Context.createDeviceProtectedStorageContext()`\n使用此上下文执行的所有存储 API 调用均访问设备加密存储（DE）\n`Context.createCredentialProtectedStorageContext()`\n使用此上下文执行的所有存储 API 调用均访问凭证加密存储（CE）\nAndroid7.0 上默认的应用存储空间指向CE区间。\n`defaultToDeviceProtectedStorag`e属性将缺省的应用存储空间由原来的指向CE区间重新连接指向DE区间。\n使用该属性标志的应用必须仔细调整所有存储于缺省空间的敏感数据，将其中的敏感数据修改路径存储至CE空间. 使用标志的设备提供商应用也必须仔细考虑,\n在存储相关数据时, 必须确保在DE空间内不包含用户信息相关的内容.\n`Context.isCredentialProtectedStorage() Context.isDeviceProtectedStorage()`\n\n> 此处 CE目录 DE目录 目前生效的只有/data/user|user_ce/目录\n\n重启后一旦用户解锁了设备，您的应用即可切换至访问凭据加密存储，并使用依赖用户凭据的常规系统服务。\n应用需要监听 `ACTION_USER_UNLOCKED`广播，来确定用户已经解锁了CE区域。\n或者可以接收现有 `ACTION_BOOT_COMPLETED` 消息，该消息现在表明设备已启动，且用户已解锁设备。\n可以通过调用 `UserManager.isUserUnlocked()`直接查询用户是否已解锁设备\n当设备解锁后，可能需要将现有数据迁移到设备加密存储。\n`Context.moveSharedPreferencesFrom(context，filename)`\n`Context.moveDatabaseFrom(context, filename)`\n根据应用自身情况决定哪些数据需要迁移，不应该将用户的私密信息迁移到DE区域\n默认情况下，应用不会在“直接启动”模式下运行。如果应用需要在“直接启动”模式下进行操作，您可以注册在此模式期间应运行的应用组件。 对于需要在“直接启动”模式下运行的应用，常见的一些用例包括：\n\n- 已安排通知的应用，如闹钟应用。\n- 提供重要用户通知的应用，如短信应用。\n- 提供无障碍服务的应用，如 Talkback。\n  如果应用在“直接启动”模式下运行时需要访问数据，则使用设备加密存储。\n  设备加密存储包含使用密钥加密的数据，仅在设备已成功执行验证启动后密钥才可用。\n\n对于应使用与用户凭据（如 PIN 或密码）关联的密钥加密的数据，使用凭据加密存储。凭据加密存储仅在用户已成功解锁设备后可用，直到用户再次重启设备。 如果用户在解锁设备后启用锁定屏幕，则不会锁定凭据加密存储。\n\n## 3.1. 支持DirectBoot的相关应用:\n\nvold负责提供android中管理存储设备和卷标的功能. FBE向vold提供了额外的新命令, 以支持在多用户情况下对于CE/DE的密钥进行管理的功能.\n使用kernel支持的基于ext4 encryption的加密属性, 很多系统应用包括锁屏界面和SystemUI都被修改以支持FBE和Direct Boot功能.","tags":["Android","FBE","FDE"],"categories":["Android","加密"]},{"title":"低存储机制说明","url":"/2018/10/01/存储相关/低存储机制说明/","content":"\n# 1. 低存储方案机制部分\n\n## 1.1. 系统通知提示\n\n获得data分区可用存储空间:\n\n```java\nEnvironment.getDataDirectory().getUsableSpace()\n```\n\n### 1.1.1. 第一档\n\n阈值为`100M`,   100 *1024 *1024\n\n弹出系统通知\n\n- 通知标题\n\n  Insufficient internal storage\n\n  内部存储空间不足\n\n- 通知内容:\n\n  Insufficient internal storage space, some system functions may not work properly, please clean up storage space immediately.\n\n  内部存储空间不足，部分系统功能可能无法正常使用，请立即清理存储空间。\n\n> 点击通知, 进入存储空间清理界面\n\n### 1.1.2. 第二档\n\n阈值为`50M`,    50 *1024 *1024\n\n弹出系统通知,  `进入存储空间清理界面`\n\n- 通知标题\n\n  Internal storage is full\n\n  内部存储空间已满\n\n- 通知内容:\n\n  The internal storage space is full, some system functions will not work properly, please clean up the storage space immediately.\n\n  内部存储空间已满，部分系统功能将无法正常使用，请立即清理存储空间。\n\n> 点击通知, 进入存储空间清理界面\n\n## 1.2. 发送sticky广播\n\n系统中常驻广播:\n\n`\"sprd.intent.action.DEVICE_STORAGE_STATE\"`\n\n根据档位需求, 在不同可用空间水平下, 广播携带字段`current_level`不同.\n\n第一档下, current_level为1,  第二档下,  current_level为2. \n\n当清理空间后, 可用空间超过第一档,  current_level为0.\n\n### 1.2.1. 应用使用广播建议\n\n在收到广播后, 应check `current_level`字段\n\n同时, 因广播发送接收有延迟,  广播只作为被动触发条件, 适合没有主动触发条件的场景.\n\n应用在收到广播后, 请再double check下可用空间. 使用如下接口查询, 返回值为byte.\n\n```java\n Environment.getDataDirectory().getUsableSpace()\n```\n\n对应用来说, 如果有主动触发条件(比如因用户操作触发, 或者满足一定条件触发某个函数)的场景, 不需要监听该广播, 直接使用上面的接口查询内部存储可用空间状态即可.\n\n### 1.2.2. 查询间隔\n\n系统服务会每隔1min检测一下data的可用空间.  查询到`可用空间档位变更时`发送广播, 如档位没有变化, 不会重复发送广播.","tags":["Android","AndroidP"],"categories":["SAF","DeviceStorageMonitor"]},{"title":"github 加速","url":"/2018/09/20/其他调研/并发编程笔记/","content":"\n# 1. 并发编程笔记\n\n## 1.1. 容器加锁注意事项\n\n-   加锁可以防止容器的迭代溢出.\n-   迭代期间对容器进行加锁会降低程序的可伸缩性. 降低程序性能及cpu使用率.甚至可能造成死锁.取决于容器的规模.\n-   替代方法是克隆容器.(克隆过程中仍然需要加锁,会有额外的性能开销)\n-   使用容器的一些方法时,会隐藏使用迭代器.\n\n## 1.2. 并发容器\n\nQueue  BlockingQueue  ConcurrentHashMap  ConcurrentMap CopyOnWriteArrayList \n\nPriorityBlockingQueue SynchronousQueue(put take一直阻塞)\n\n## 1.3. 模式\n\n生产者消费者模式  (如BlockingQueue 所有消费者有一个共享的工作队列)\n\n工作密取(对应双端队列 如BlockingDeque, 每个消费者都有各自的工作队列,如果一个消费者完成了自己双端队列上的全部工作,它可以从其它消费者双端队列上秘密的获取工作,适合执行某个工作时发现有更多的工作.)\n\n## 1.4. 闭锁\n\n一种同步工具类, 可以延迟线程的进度直到达到终止状态.\n\n-   CountDownLatch\n\n-   FutureTask\n\n    等待执行 正在运行 运行完成\n\n    Future的行为取决于任务的状态, 任务未完成时,会阻塞直到任务到运行完成阶段.\n\n## 1.5. 信号量\n\n-   计算信号量用来控制同时访问某个特定资源的操作数量,或执行某个指定操作的数量.\n-   Semaphore管理一组虚拟的许可. 许可的初始数量可以通过构造函数指定.在执行操作时首先获取许可(只要还有剩余的许可),并在使用后释放许可.如果没有剩余的许可,acquire将阻塞直到有许可.\n\n## 1.6. 栅栏\n\n类似与闭锁, 能阻塞一组线程直到某个事件发生.与闭锁的区别在于:\n\n-   闭锁用于等待事件\n-   栅栏等待其他线程.所有线程必须同时到达栅栏位置(适用于一些迭代算法,如某个步骤中的计算可以并行执行,但必须等到该步骤中的所有计算执行完毕后才能进入下一个步骤).\n-   CyclicBarrier Exchanger(交换缓冲区)\n\n# 2. 结构化并发应用程序\n\n## 2.1. 任务执行\n\n### 2.1.1. 无限制创建线程的不足\n\n即为每个任务创建一个线程的做法是不可取的.\n\n-   线程生命周期的开销非常高\n\n-   资源消耗  \n\n    活跃的线程会消耗系统资源,尤其是内存. 有足够多的线程使CPU处于忙碌状态,创建更多的线程会导致线程竞争CPU, 大量线程被闲置, 将造成性能下降\n\n-   稳定性 在可创建线程的数量上存在限制,如超出限制, 可能抛出内存溢出.(JVM启动参数,Thread构造函数中请求的栈大小等,取决于平台.)\n\n## 2.2. 线程池\n\nExecutor框架:\n\nJava提供了一种灵活的线程池实现作为Executor框架的一部分.提供了生命周期的支持,统计信息收集,应用管理机制和性能监视等机制.\n\n-   newFixedThreadPool\n-   newCachedThreadPool  可缓存的线程池, 回收空闲线程, 线程池的规模不受限制.\n-   newSingleThreadExecutor\n-   newScheduledThreadPool  以延迟或定时的方式执行任务,类似Timer\n\n基于生产者消费者模式,提交任务的操作相当于生产者,执行任务的线程相当于消费者.\n\nExecutorService 生命周期: 扩展了Executor        子类.\n\n三种状态: 运行 关闭 已终止.\n\nshutdown方法执行平缓的关闭过程:不再接受新的任务, 同事等待已经提交的任务执行完成.shutdownNow执行粗暴的关闭过程.尝试取消所有运行中的任务.\n\n### 2.2.1. 延迟任务与周期任务\n\nScheduledThreadPoolExecutor\n\n-   Timer会引起线程泄漏(发生异常时,会终止整个Timer)\n-   Timer 绝对时间的调度机制, ScheduledThreadPoolExecutor 相对时间\n\n#### 2.2.1.1. 携带结果的任务Callable 与 Future\n\nRunnable 与 Callable\n\n-   Runnable不能返回值或者抛出一个受检查的异常\n-   Callable相对Runnable是一种更好的抽象, call主入口点将返回值或者抛出异常.\n\nExecutorService中的所有submit方法(参数为一个Runnable或Callable)返回一个Future, Future用来获取任务的执行结果或者用来取消任务.\n\nCompletionService将Executor和BlockingQueue组合在一起. 将Callable任务提交给它执行, 使用类似队列操作的take和poll等方法来获得已完成的结果.完成时被封装成Future. \n\n# 3. 取消与关闭\n\n一个可取消的任务必须拥有取消策略:\n\n-   如何请求取消该任务\n-   任务何时检查是否已经请求了取消\n-   响应取消请求时应该执行哪些操作\n\n不可靠的取消操作将把生产者置于阻塞的操作中.\n\n## 3.1. 中断\n\n每个线程都有一个布尔类型的中断标志.当中断线程时,这个线程的中断状态变为true.在Thread中包含了中断线程及查询线程中断的方法.interrput能中断目标线程.isInterrputed方法能返回目标线程的中断状态.interrupted方法清除当前线程的中断状态,并返回它之前的值.也是清除中断状态的唯一方法.\n\n>   调用interrupt并不意味者立即停止目标线程正在执行的操作.而只是传递了请求中断的消息,使线程的中断标志位变为true\n\n如Thread.wait sleep join等方法,收到中断请求或者开始执行时发现已经设置好中断标志位时,将抛出InterruptedException.\n\n>   中断是实现取消的最合理的方式\n\n如果一个线程由于等待某个内置锁而阻塞,那么将无法响应中断.在Lock类中提供的lockInterruptibly方法,允许在等待一个锁的同时仍能响应中断\n\n## 3.2. 停止基于线程的服务\n\n>   对于持有线程的服务,只要服务的存在时间大于创建线程的方法的存在时间,就应该提供生命周期方法,如ExecutorService的shutdown方法.\n\n## 3.3. 处理非正常的线程终止\n\n导致线程提前死亡的主要原因是RuntimeException\n\n线程非正常退出的后果可能是良性的,当一个线程由于未捕获异常退出时,JVM将这个事件报告给应用程序提供的UncaughtExceptionHandler异常处理器.可以使用新的线程替代异常退出的线程.\n\n # 线程池的使用\n\n## 3.4. 线程池的创建和销毁\n\n线程池的基本大小, 最大大小,以及存活时间等因素共同负责线程的创建和销毁.\n\n-   基本大小即线程池的目标大小,在没有任务执行时线程池的大小\n-   最大大小表示可同时活动的线程数量的上限\n-   如某个线程的空闲时间超过了存活时间,该线程会被标记为可回收的.线程池的当前大小超过了基本大小时,这个线程会被终止.\n\nnewFixedThreadPool将线程池的基本大小和最大大小设置为参数中指定的值,且创建的线程池不会超时\n\nnewCachedThreadPool将线程池的最大大小设置为Interger.MAX_VALUE,基本大小设置为0, 超时时间设置为1min.创建出来的线程池可被无限扩展,当需求降低时(线程的空闲时间增大)会自动收缩.\n\n只有当任务相互独立时,为线程池或工作队列设置界限才是合理的.如果任务之间存在依赖性,那么有界的线程池或队列可能导致线程饥饿死锁问题,此时应使用无界的线程池.\n\n## 3.5. 饱和策略\n\n有界队列被填满后,饱和策略开始发挥作用.可以通过setRejectedExceptionHandler来修改.\n\n-   中止策略是默认的饱和策略,抛出未检查的RejectedExecutionException,调用者可捕获该异常,根据需求处理代码\n-   当新提交的任务无法保存到队列中等待执行时,抛弃策略会抛弃该任务\n-   调用者运行策略不会抛弃任务,也不会抛出异常,而是将任务回退给调用者,由调用者所在的线程执行(调用execute函数的线程.)\n\n## 3.6. 扩展ThreadPoolExecutor\n\n可以在子类中覆写的方法:\n\nbeforeExecute afterExecute terminated\n\n在线程池完成关闭操作时调用terminated,即所有任务都已经完成且工作者线程已经关闭后.可以用来释放Executor在生命周期里分配的各种资源,执行发送通知,记录日志等.\n\n无论任务从run中正常返回还是抛出一个异常返回,afterExecute都被调用. (任务在完成后带有一个ERROR,则不会调用afterExecute).\n\n如beforeExecute抛出一个RuntimeException, 也不会调用afterExecute.\n\n# 4. 活跃性\\性能测试 死锁问题\n\n## 4.1. 锁顺序死锁\n\n>   如果所有线程以固定顺序获得锁,程序中不会出现锁顺序死锁问题\n\n想验证锁顺序的一致性,需要对程序中的加锁行为进行全局分析.\n\n### 4.1.1. 动态的锁顺序死锁\n\n如锁参数问题,锁了两个传参问题, 无法保证参数的调用顺序则有可能发生死锁.\n\n可以使用System.identityHashCode方法,比较参数的hashcode值,来保证锁顺序.\n\n但两个对象可能拥有相同的hashcode值,可使用加时赛锁,在获得两个锁之前,首先需要获得这个加时赛锁.从而保证每次只有一个线程以未知的顺序获得这两个锁.\n\n### 4.1.2. 在协作对象之间发生的死锁\n\n如果在持有锁时调用某个外部方法,将出现活跃性问题.在这个外部方法中可能会获得其他锁,或阻塞时间过长,导致其他线程无法获得当前被持有的锁\n\n#### 4.1.2.1. 开放调用\n\n在调用某个方法时不需要持有锁,该调用被称为开放调用.更易于找出哪些需要获取多个锁的代码路径.\n\n>   在程序中尽量使用开放调用,与那些在持有锁时调用外部方法的程序相比,更易于对依赖于开放调用的程序进行死锁分析.\n\n### 4.1.3. 资源死锁\n\n在相同的资源集合上等待时,也会发生死锁\n\n-   如数据库连接池,每个资源池有多个连接,在发生死锁时不仅需要N个循环等待的线程,且需要大量不恰当的时序\n\n#### 4.1.3.1. 线程饥饿死锁\n\n如`单线程`Exector中,一个任务提交另一个任务.第一个任务将永远等待下去,并使得另一个任务以及这个Executor上执行的所有任务都停止执行.\n\n>   有界线程池/资源池与相互依赖的任务不能一起使用\n\n## 4.2. 死锁的避免和诊断\n\n## 4.3. 定时锁\n\ntryLock,可指定一个超时时限,在等待超过该时间后返回一个失败信息.同时获取两个锁时才有效,如果在嵌套的方法调用中请求多个锁,也无法释放超时锁.\n\n### 4.3.1. 线程转储信息\n\nUNIX上 kill -3\n\n显示的Lock类上获得的信息比在内置锁上获得的信息精确度低.内置锁与获得它们所在的线程栈帧是相关联的.显示的Lock只与获得它的线程相关.\n\n## 4.4. 其他活跃性危险\n\n饥饿\\丢失信号\\活锁\n\n>   要避免使用线程优先级,会增加平台依赖性,并可能导致活跃性问题.\n\n在Thread API中定义的线程优先级只是作为线程调度的参考.定义了10个优先级.JVM根据需要将他们映射到操作系统的调度优先级.这种映射与特定平台相关.在某个操作系统中,两个不同的JAVA优先级可能被映射到同一优先级.在另一个操作系统中可能被映射到另一个不同的优先级.\n\n#### 4.4.1.1. 糟糕的响应性\n\nGUI程序中计算密集型的后台任务(可适当降低优先级)和不良的锁管理.\n\n#### 4.4.1.2. 活锁\n\n通常发生在处理事务消息的程序中.如果不能成功的处理某个消息,消息处理机制将回滚整个事物.将重新放到队列的开头.由于这条消息又被放回队列开头,因此处理器将被反复调用,并返回相同的结果.错误的将不可修复的错误作为可修复的错误.\n\n当多个相互协作的线程都对彼此进行响应从而修改各自的状态,使得任何一个线程都无法继续执行时,将发生上述问题. \n\n在重试机制中引入随机性,使得相互协作的线程发生时间随机不撞车.\n\n## 4.5. 性能与可伸缩性\n\n执行过程中串行部分所占的比例影响计算资源的可加速比.\n\n降低锁的竞争程度:\n\n-   减少锁的持有时间\n-   降低锁的请求频率\n-   使用带有协调机制的独占锁,这些机制允许更高的并发性\n\n尽管缩小同步代码块能提高可伸缩性,但同步代码块也不能过小.当把一个同步代码块分解为多个时,反而会对性能产生负面影响.\n\n### 4.5.1. 减小锁的粒度\n\n采用多个相互独立的锁保护独立的状态变量,从而改变这些变量在之前由单个锁保护的情况,降低锁的请求频率.\n\n将锁分解技术进一步扩展为一组独立对象上的锁进行分解,称为锁分段\n\nConcurrentHashMap对于大多数读操作并不会加锁,并且在写入操作以及其他一些需要锁的读操作中使用了锁分段技术.\n\n### 4.5.2. 避免热点域\n\n一些常见的优化措施,如将一些反复计算的结果缓存起来,都会引入一些热点域,而限制可伸缩性.\n\n原子变量提供了一种方式降低更新热点域,如静态计数器\\序列发生器\\链表中头节点的引用.\n\n### 4.5.3. 并发程序中避免使用对象池\n\n通常对象分配操作的开销比同步的开销更低.\n\n## 4.6. 并发程序的测试\n\n### 4.6.1. 安全性测试\n\n>   要最大程度的检测出一些对执行时序敏感的数据竞争,测试中的线程数量应该多于CPU数量,在任意时刻都会有一些线程在运行,而另一些被交换出去,从而可以监测线程间交替行为的可预测性\n\n#### 4.6.1.1. 产生更多的交替操作,可提高发现错误的概率\n\n处理器的数量小于活跃线程的数量.\n\n在访问共享状态的操作中,使用Thread.yield产生更多的上下文切换或睡眠时间较短的sleep.\n\n# 5. 显示锁\n\nReentrantLock\n\n显示锁提供了一种无条件的\\可轮询的\\定时的以及可中断的锁获取操作.\n\n内置锁在功能上存在局限性: 无法中断一个正在等待获取锁的线程.无法在请求获取一个锁时无限的等待下去.\n\n显示锁必须在finally中释放lock.\n\n## 5.1. 轮询锁与定时锁\n\ntryLock 可避免死锁的发生.\n\n释放已经获得的锁,重新获取所有锁.(或将这个失败记录,或采取其他措施)\n\n>   如使用tryLock获取两个锁,如不能同时获得,回退重试尝试,在休眠时间包括固定部分和随机部分,从而降低活锁的发生性.如在指定时间不能获得所需要的锁,最终返回一个失败的状态.\n\n定时锁可用tryLock实现,超过timeout失败.\n\n可中断的锁,Lock.lockInterruptibly(替代lock)可在获取锁的同时保持对中断的响应.\n\n非公平锁的性能要高于公平锁的性能,显示锁和内置锁都没有保证锁是公平的(显示锁可设置公平锁)\n\n## 5.2. 内置锁与显示锁的选择\n\n显示锁vs内置锁:\n\n-   显示锁提供了一种无条件的\\可轮询的\\定时的以及可中断的锁获取操作.\n-   显示锁如未被正确使用,在finally中释放锁,可能引起灾难性后果\n-   内置锁在线程转储过程中可给出线程栈帧.并能监测和识别发生死锁的线程.\n-   java的高级版本中已经对显示锁支持更多的调试信息.可通过管理接口进行注册等.\n\n>在内置锁不能满足要求时,才可以考虑使用显示锁\n\n## 5.3. 读写锁\n\n一个资源可以被多个读操作访问,或者被一个写操作访问,但两者不能同时进行\n\n# 6. 构建自定义的同步工具\n\n条件队列使构建高效以及高响应性的状态依赖性变得更容易.但同时也很容易被不正确的使用.\n\nwait notify notifyAll方法\n\n在编译器或系统平台上可能没有遵循正确使用条件队列的规则,尽量避免使用条件队列.\n\n## 6.1. 使用条件队列\n\n条件谓词: 使某个操作成为状态依赖操作的前提条件\n\n在条件等待中存在一条重要的三元关系:\n\n加锁\\wait方法\\条件谓词\n\n>   锁对象和条件队列对象(调用wait和notify所在的对象)必须是同一对象,锁保护者条件谓词的状态变量.\n\nwait方法将释放锁,阻塞当前线程,并等待直到超时,然后线程被中断或者通过一个通知被唤醒.在唤醒进程后,wait在返回前还要重新获取锁,当线程从wait方法中被唤醒时,它在重新请求锁时不具有任何特殊的优先级,要去其他尝试进入同步代码块的线程一起竞争.\n\n### 6.1.1. wait过早唤醒\n\nwait方法的返回并不一定意味这线程正在等待的条件谓词已经成真.\n\n在发出通知的线程调用notifyAll时,条件谓词变为真,但该等待线程在重新获取锁时条件谓词可能已经变成假的了.或者并不知道另一个线程为什么调用notify或notifyAll,也许是因为与同一队列相关的另一个条件谓词变成了真.\n\n>   一个条件队列可能有多个条件谓词相关.\n\n基于上述条件,每次从wait线程中唤醒时,都必须再次测试条件谓词.需要在while循环中调用wait,每次迭代都检测条件谓词.\n\n>   当使用条件等待时(wait)\n>\n>   -   通常都有一个条件谓词\n>   -   在调用wait之前测试条件谓词,并且从wait返回时再次进行测试\n>   -   在循环中调用wait\n>   -   确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量\n>   -   当使用wait\\notify\\notifyAll等方法时,一定要持有与条件队列相关的锁\n>   -   在检查条件谓词之后以及开始执行相应的操作之前,不要释放锁\n\n### 6.1.2. 丢失信号\n\n在wait没有检查条件谓词时,会出现这种情况\n\n### 6.1.3. 通知 notify\n\n>   每当在等待一个条件时,一定要确保在条件谓词变为真时通过某种方式发出通知.\n\n-   notify\n    JVM从条件队列上等待的多条线程中选择其中一个唤醒\n-   notifyAll\n    唤醒所有...\n\n\n发出通知的线程应尽快释放锁,以使wait的线程重新获得锁.\n\n>   只有同时满足以下两个条件时,才能用单一的notify而不是notifyAll:\n>\n>   -   所有等待线程的类型都相同.只有一个条件谓词与条件队列相关,并且每个线程在从wait返回后都执行相同的操作\n>   -   单进单出. 在条件变量上的每次通知,最多只能唤醒一个线程来执行.\n\n## 6.2. 显示的Condition对象\n\n内置锁和内置条件队列存在一些缺陷,每个内置锁都只能有一个相关联的条件队列.\n\n在Condition中,await signal sinalAll\n\nCondition比内置条件队列提供了更丰富的功能:\n\n-   在每个锁上可存在多个等待\n-   条件等待可以是可中断的或不可中断的\n-   基于时限的等待\n-   公平的或非公平的队列操作\n\n对每个Lock,可有任意数量的Condition对象.一次sinal会唤醒所有在该lock上等待的线程.\n\n即在每个锁上等待多个线程集.\n\n要实现一个依赖状态的类,如果没有满足依赖状态的前提条件,这个类的方法必须阻塞,最好的方式是基于现有的类库来构建,如Semaphore BlockingQueue 或CountDonwLatch.如现有类库不能提供足够功能,可使用内置的条件队列\\显示的Condition对象或AQS来构建自己的同步器.\n\n# 7. 原子变量与非阻塞同步机制\n\nvolatile变量的使用,不能用于构建原子的符合操作.不能实现计数器或互斥体.\n\n计数操作目前为止只能用锁的方式实现.","tags":["C++","并发"],"categories":["读书"]},{"title":"Effective Modern C++ 11 笔记","url":"/2018/09/02/其他调研/c++调试头文件/","content":"\n# 1. 本地调试使用C++相关\n\n`strstr strcmp strcpy`的头文件在<string.h>中\n`std::string`的头文件在<string>中\n\n```cpp\n#include <stdio.h>\n#include <string>\n#include <string.h>\n```\n编译时需要使用如下命令:\n\n```shell\ng++ -lstdc++ <abc.cpp>\n```\n\n选择c++11编译的命令为:\n\n```shell\ng++ -g -Wall -std=c++11 <abc.cpp>\n```\n","tags":["C++"],"categories":["debug"]},{"title":"文件系统调研","url":"/2018/08/02/其他调研/文件系统理解/","content":"\n[TOC]\n\n# 1.  文件系统的组成部分\n## 1.1. block块理解\n硬盘的读写IO一次是一个扇区`512`字节, 如果要读写大量文件，以`扇区`为单位肯定很慢很消耗性能，所以Linux中通过文件系统控制使用`\"块\"`为读写单元\n比如需要读一个或多个块时，文件系统的`IO管理器`通知磁盘控制器要读取哪些`块`的数据，硬盘控制器将这些块按`扇区`读取出来，再通过硬盘控制器将这些扇区数据重组返回给计算机\n\n- block的出现使得在文件系统层面上读写性能大大提高，也大量减少了碎片\n- 可能造成空间浪费\n> 在当下硬盘容量廉价且追求性能的时代，使用block是一定的。\n\n## 1.2. inode\n假如block大小为1KB，仅仅存储一个`10M`的文件就需要10240个block，而且这些blocks很可能在位置上是`不连续`在一起的(不相邻)\n>读取该文件时难道要从前向后扫描整个文件系统的块，然后找出属于该文件的块吗？\n???\n每个文件都有属性(如权限、大小、时间戳等)，这些属性类的元数据存储在哪里呢？难道也和文件的数据部分存储在块中吗？\n如果一个文件占用多个block那是不是每个属于该文件的block都要存储一份文件元数据？\n如果不在每个block中存储元数据文件系统又怎么知道某一个block是不是属于该文件呢？\n解决方法是使用索引，通过扫描索引找到对应的数据，而且索引可以存储部分数据\n在文件系统上索引技术具体化为索引节点(`index node`)，在索引节点上存储的部分数据即为文件的属性元数据及其他少量信息.\n索引节点称为inode。在inode中存储了**inode号、文件类型、权限、文件所有者、大小、时间戳**等元数据信息，最重要的是还存储了**指向属于该文件block的指针**\n- 可以用stat命令，查看某个文件的inode信息：\n```bash\n$ stat ~/.bashrc         \n  File: ‘/home/local/SPREADTRUM/liguang.zhang/.bashrc’\n  Size: 7829      \tBlocks: 16         IO Block: 4096   regular file\nDevice: 821h/2081d\tInode: 39059515    Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (1488486870/SPREADTRUM\\liguang.zhang)   Gid: (1488454145/SPREADTRUM\\domain^users)\nAccess: 2019-03-18 09:52:16.796663821 +0800\nModify: 2019-02-22 10:10:58.044537613 +0800\nChange: 2019-02-22 10:10:58.044537613 +0800\n Birth: -\n```\n- 查看每个inode节点的大小，可以用如下命令：\n```bash\n$ sudo dumpe2fs /dev/sda1 | grep \"Inode size\"\ndumpe2fs 1.42.9 (4-Feb-2014)\nInode size:\t          256\n```\n打印文件的inode number\nls命令用于列出文件/文件夹的信息。参数 -i 说明需要显示每个文件的inode number。我们可以结合参数 -l 一起使用以列出详细信息：\n```bash\n$ ls -li\ntotal 16\n43650565 drwxr-xr-x 108 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 12288 Mar 15 10:10 extensions\n43783364 drwxr-xr-x   2 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 May 17  2018 projects\n```\n显示文件系统inode的使用信息\ndf命令汇总可用和已用的磁盘空间。你可以通过传递 -i 或 --inodes 选项来接收有关可用和已使用的inode报告。\n```bash\n$ df -i             \nFilesystem                                                            Inodes   IUsed     IFree IUse% Mounted on\nudev                                                                 2040313     563   2039750    1% /dev\ntmpfs                                                                2043070     647   2042423    1% /run\n/dev/sda1                                                            3055616  909414   2146202   30% /\nnone                                                                 2043070       2   2043068    1% /sys/fs/cgroup\nnone                                                                 2043070       5   2043065    1% /run/lock\nnone                                                                 2043070     119   2042951    1% /run/shm\nnone                                                                 2043070      38   2043032    1% /run/user\n/dev/sda3                                                           25526272  276893  25249379    2% /home\n/dev/sdb3                                                           56901632 6017447  50884185   11% /home/newdisk\n/dev/sdc1                                                          244195328 7604192 236591136    4% /home/newdisk1\n//tjnas1/data_exchange_tunnel/From_Shanghai/PLD_APPS/liguang.zhang         0       0         0     - /home/newdisk1/liguang.zhang/smb_dir/datasync\n```\n列出文件系统超级块的信息\ntune2fs -l 命令来显示所有与inode相关的信息\n```bash\n$ sudo tune2fs -l /dev/sda1 | grep inode\nFilesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize\nFree inodes:              2146270\nFirst inode:              11\nJournal inode:            8\nFirst orphan inode:       131185\nJournal backup:           inode blocks\n```\n## 1.3. bmap出现(只对写优化)\n在向硬盘存储数据时，文件系统需要知道哪些块是空闲的，哪些块是已经占用了的。\n最笨的方法当然是从前向后扫描，遇到空闲块就存储一部分，继续扫描直到存储完所有数据。\n位图只使用0和1标识对应block是空闲还是被占用，0和1在位图中的位置和block的位置一一对应，第一位标识第一个块，第二个位标识第二个块，依次下去直到标记完所有的block\n1G的文件只需要128个block做位图就能完成一一对应(1k的block)\n`bmap的优化针对的是写优化，因为只有写才需要找到空闲block并分配空闲block`\n对于读而言，只要通过inode找到了block的位置，cpu就能迅速计算出block在物理磁盘上的地址\n- bmap也有瓶颈, 每次写都需要扫描以下查看哪些块未被占用, 对于100G的, 需要128k*100, 每次写需要扫描12800个块, 不连续的地址扫描时间更长, 需要进一步优化\n出现里`块组`, 对bmap进行优化\n## 1.4. inode表\ninode存储了inode号、文件属性元数据、指向文件占用的block的指针；每一个inode占用128字节或256字节。\n引入了一个问题, 每一个文件都对应一个inode, 一个inode为128或256大小, 每一个inode都要占用一个块吗?\n- 优化出现inode表:\n`多个inode合并存储在block中`\n256字节的inode, block为4k, 则16个inode存到一个block中. 为一个inode表\n![733013-20180830092223810-1825870107](_v_images/20190318154000372_246487973.png)\n- 在文件系统创建完成后所有的inode号都已经分配好并记录到inode table中了\n    - 被使用的inode号所在的行还有文件属性的元数据信息和block位置信息\n    - 未被使用的inode号只有一个inode号而已而没有其他信息而已\n## 1.5. imap的出现\n一个大的文件系统仍将占用大量的块来存储inode, 如何快速找到inode，这同样是需要优化的，\n- 优化的方法是将文件系统的block进行`分组`划分，每个组中都存有本组inode table范围、bmap等\nbmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。\ninode也一样，在存储文件(Linux中一切皆文件)时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此产生了问题：**要为文件分配哪一个inode号呢？又如何知道某一个inode号是否已经被分配了呢？**\n标识inode号是否被分配的位图称为inodemap简称为`imap`,  *这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。*\nimap存在着和bmap和inode table一样需要解决的问题：\n- imap本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。\n- 同样，优化的方式是将文件系统占用的block划分成`块组`，每个块组有自己的imap范围。\n\n## 1.6. 块组\n前面bmap和imap inode table抛出的问题, 怎么对其快速扫描. 两个地方的优化方案都是引入块组\n- `物理层面`上的划分是将磁盘按柱面划分为多个分区，即多个文件系统\n- `逻辑层面`上的划分是将文件系统划分成块组\n    每个文件系统包含多个块组，每个块组包含多个元数据区和数据区：\n    - 元数据区就是存储bmap、inode table、imap等的数据；\n    - 数据区就是存储文件数据的区域。\n>块组是逻辑层面的概念，所以并不会真的在磁盘上按柱面、按扇区、按磁道等概念进行划分。\n\n### 1.6.1. 块组的划分\n块组在文件系统创建完成后就已经划分完成了，也就是说元数据区bmap、inode table和imap等信息占用的block以及数据区占用的block都已经划分好了。\n那么文件系统如何知道一个块组*元数据区包含多少个block，数据区又包含多少block呢？*\n只需要一个标准:\n**block的大小**\n>bmap至多只能占用一个完整的block的标准\n\n每个`block的大小`在创建文件系统时可以人为指定，不指定也有默认值。\n如当前文件系统的block大小一般为4k, 一个bmap完整占用一个block能标识4k*8 = 32K个block(注意是`元数据区和数据区一个32k个`, 因元数据区的block也要通过bamp来标识)\n每个block是4k, 一个块组bmap可以标识32k个block, 即块组大小为32K*4K =128M, 创建1G的文件系统, 可以分为1024M/ 128M = 8个块组\n每个组设定多少个inode号呢? inode table占用多少block呢？建文件系统时也可以人为指定这个指标或者百分比例\n使用`dumpe2fs`可以将ext类的文件系统信息全部显示出来，当然bmap是每个块组固定一个block的不用显示，imap比bmap更小所以也只占用1个block不用显示。\n\n```bash\n# 360M左右的文件系统: 一共三个块组,\n-rwxr-xr-x  1 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 366997504 Apr 20  2017 system.img*\n#dumpe2fs system.img\ndumpe2fs 1.42.9 (4-Feb-2014)\nFilesystem volume name:   <none>\nLast mounted on:          <not available>\nFilesystem UUID:          57f8f4bc-abf4-655f-bf67-946fc0f9f25b\nFilesystem magic number:  0xEF53\nFilesystem revision #:    1 (dynamic)\nFilesystem features:      has_journal ext_attr resize_inode filetype extent sparse_super large_file uninit_bg\nDefault mount options:    (none)\nFilesystem state:         clean\nErrors behavior:          Remount read-only\nFilesystem OS type:       Linux\nInode count:              22416 #inode总数\nBlock count:              89599 #文件系统block总数\nReserved block count:     0  #保留的block数量\nFree blocks:              32553\nFree inodes:              21102\nFirst block:              0   #第一个block号\nBlock size:               4096  #block大小\nFragment size:            4096\nReserved GDT blocks:      23 #保留的GDT数量\nBlocks per group:         32768 #一个块组的block数\nFragments per group:      32768\nInodes per group:         7472  #一个块组的inode数, 根据制作文件系统时inode ratio计算的\nInode blocks per group:   467 #一个块组inode table所占的block数\nLast mount time:          n/a\nLast write time:          Thu Jan  1 08:00:00 1970\nMount count:              0\nMaximum mount count:      -1\nLast checked:             Thu Jan  1 08:00:00 1970\nCheck interval:           0 (<none>)\nReserved blocks uid:      0 (user root)\nReserved blocks gid:      0 (group root)\nFirst inode:              11 #文件系统的第一个inode号\nInode size:\t          256 #每个inode的大小为256字节\nRequired extra isize:     28\nDesired extra isize:      28\nJournal inode:            8\nDefault directory hash:   tea\nJournal backup:           inode blocks\nJournal features:         (none)\nJournal size:             5596k\nJournal length:           1399\nJournal sequence:         0x00000001\nJournal start:            0\n\n# 一个块组标识32K个block.\nGroup 0: (Blocks 0-32767)\n  Checksum 0xa934, unused inodes 0\n  Primary superblock at 0, Group descriptors at 1-1 #superbock在0号block, 块组描述表GDT所在block 0/1/ 3/5/7幂次, 0的是主的, 0损坏再读取其他的备份\n  Reserved GDT blocks at 2-24 # 保留GDT所在的block\n  Block bitmap at 25 (+25), Inode bitmap at 26 (+26) #bmap和imap所在的block位置\n  Inode table at 27-493 (+27) #inode table所在的block位置\n  1 free blocks, 6158 free inodes, 48 directories\n  Free blocks: 32767\n  Free inodes: 1315-7472\nGroup 1: (Blocks 32768-65535) [INODE_UNINIT]\n  Checksum 0x8825, unused inodes 0\n  Backup superblock at 32768, Group descriptors at 32769-32769 # sb和GDT\n  Reserved GDT blocks at 32770-32792\n  Block bitmap at 32793 (+25), Inode bitmap at 32794 (+26)\n  Inode table at 32795-33261 (+27)\n  8958 free blocks, 7472 free inodes, 0 directories\n  Free blocks: 56578-65535\n  Free inodes: 7473-14944\n# 2号中没有sb和GDT\nGroup 2: (Blocks 65536-89598) [INODE_UNINIT]\n  Checksum 0x7e40, unused inodes 0\n  Block bitmap at 65536 (+0), Inode bitmap at 65537 (+1)\n  Inode table at 65538-66004 (+2)\n  23594 free blocks, 7472 free inodes, 0 directories\n  Free blocks: 66005-89598\n  Free inodes: 14945-22416\n```\n该文件系统共`89599`个blocks，每个block大小为4K, 所以文件系统大小为89599*4k = 350M\n块组的数量为 350M/128M = 3, 由于块组从0开始编号，所以最后一个块组编号为Group 2.\n# 2. 文件系统的完整结构\n将上文描述的`bmap、inode table、imap、数据区的blocks和块组`的概念组合起来就形成了一个文件系统，当然这还不是完整的文件系统。完整的文件系统如下图\n![文件系统组成](_v_images/20190318160947487_337430781.png)\n- 除了superblock、bmap、imap能确定占用**1**个block，其他的部分都不能确定占用几个block。\n- 图中指明了Superblock、GDT和Reserved GDT是同时出现且不一定存在于每一个块组中的，也指明了bmap、imap、inode table和data blocks是每个块组都有的。\n## 2.1. 引导块\n上图中的Boot Block部分，也称为boot sector。它位于分区上的第一个块，占用1024字节\n`并非所有分区都有这个boot sector，只有装了操作系统的主分区和装了操作系统的逻辑分区才有`, 里面存放的也是boot loader\n这段boot loader称为`VBR`(主分区装操作系统时)`或EBR`(扩展分区装操作系统时)\n开机启动的时候，首先加载mbr中的bootloader，然后定位到操作系统所在分区的boot serctor上加载此处的boot loader。如果是多系统，加载mbr中的bootloader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的boot sector上。它们之间的关系如下图所示。\n现在通常使用`grub`来管理启动菜单。尽管如此，在安装操作系统时，仍然有一步是选择boot loader安装位置的步骤\n\n## 2.2. 超级块(superblock) sb\n既然一个文件系统会分多个块组，那么\n- 文件系统怎么知道分了多少个块组呢？\n- 每个块组又有多少block多少inode号等等信息呢？\n- 文件系统本身的属性信息如各种时间戳、block总数量和空闲数量、inode总数量和空闲数量、当前文件系统是否正常、什么时候需要自检等等，它们又存储在哪里呢？\n这些信息必须要存储在block中。存储这些信息占用`1024字节`，所以也要一个block，这个block称为超级块(superblock)\n它的block号可能为0也可能为1, 如果block大小为4k, 则引导和sb同在一个block, 则block号为0, \n总之sb处在**第二个1024位置(1024-2047)字节**\n- 使用df命令读取的就是每个文件系统的superblock，所以它的统计速度非常快。\n- 用du命令查看一个较大目录的已用空间就非常慢，因为不可避免地要遍历整个目录的所有文件。\nsuperblock对于文件系统而言是至关重要的，`超级块丢失或损坏`必将导致文件系统的损坏。\n所以ext2文件系统只在块组`0、1和3、5、7幂次方`的块组中保存超级块的信息, 只有当Group0上的superblock损坏或丢失才会找下一个备份超级块复制到Group0中来恢复文件系统。\next家族的文件系统都能使用dumpe2fs -h获取。\n\n## 2.3. 块组描述符表(GDT)\n\n>每个块组的信息和属性元数据又保存在哪里呢?\n\next文件系统每一个块组信息使用`32字节`描述，这32个字节称为块组描述符，所有块组的块组描述符组成块组描述符表GDT(group descriptor table)。\n虽然每个块组都需要块组描述符来记录块组的信息和属性元数据，但是不是每个块组中都存放了块组描述符?\next文件系统的存储方式是：将它们组成一个GDT，`并将该GDT存放于某些块组中`，**存放GDT的块组和存放superblock和备份superblock的块相同**，也就是说它们是同时出现在某一个块组中的。读取时也总是读取Group0中的块组描述符表信息。\n\n假如block大小为4KB的文件系统划分了143个块组，每个块组描述符32字节，那么GDT就需要143*32=4576字节即两个block来存放。这两个GDT block中记录了所有块组的块组信息，且存放GDT的块组中的GDT都是完全相同的。\n\n## 2.4. 保留GDT(Reserved GDT)\n保留GDT用于以后**扩容**文件系统使用，防止扩容后块组太多，使得块组描述符超出当前存储GDT的blocks。保留GDT和GDT总是同时出现，当然也就和superblock同时出现了\n块组太多, 可能出现GDT的块不足以放下 32*块组大小的字节, 需要RGDT补充. 如果没有RGDT, 因分配方式已经固定好了, 增加GDT block需要为其分配block, 但备份块组中的block号占又不可能总是同0块组是一样的, 需要考虑的情况更复杂.\n同时, 新增加了GDT需要修改每个块组中superblock中的文件系统属性，所以将superblock和Reserved GDT/GDT放在一起又能提升效率。\n\n## 2.5. Data Block\n\n![文件系统结构](_v_images/20190318163341554_221896612.png)\n上图中除了data block之外的都介绍了, data block是直接存储数据的block，但事实上并非如此简单。\n数据所占用的block由文件对应inode记录中的block指针找到，不同的文件类型，数据block中存储的内容是不一样的。以下是Linux中不同类型文件的存储方式。\n- 对于常规文件，文件的数据正常存储在数据块中。\n- 对于目录，该目录下的`所有文件和一级子目录的目录名`存储在数据块中。\n    - 文件名不是存储在其自身的inode中，而是存储在其所在目录的data block中。\n- 对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。\n- 设备文件、FIFO和socket等特殊文件没有数据块，设备文件的`主设备号和次设备号`保存在inode中。\n\n常规文件的存储就不解释了，下面分别解释特殊文件的存储方式。\n\n### 2.5.1. 目录文件的data block\n对于目录文件，其inode记录:\n- 目录的inode号\n- 目录的属性元数据\n- 目录文件的block指针\n\n这里面没有存储目录自身文件名的信息\n目录的data block中保存到信息:\n- 目录中的文件名\n- 目录名\n- 目录本身的相对名称\".\"\n- 上级目录的相对名称\"..\"\n- 指向inode table中这些文件名对应的inode号的指针\n- 目录项长度rec_len\n- 文件名长度name_len\n- 文件类型file_type\n> 除了文件本身的inode记录了文件类型，其所在的目录的数据块也记录了文件类型\n目录的data block中并没有直接存储目录中文件的inode号，它存储的是指向inode table中对应文件inode号的指针，暂且称之为`inode指针`\n- 一种是inode table中每个inode记录指向其对应data block的block指针，\n- 一个此处的inode指针\n![目录data block中保存的内容](_v_images/20190318164354687_746965614.png)\n目录文件的读权限(r)和写权限(w)，都是针对目录文件的数据块本身。由于目录文件内只有文件名、文件类型和inode指针，所以如果只有读权限，只能获取文件名和文件类型信息，无法获取其他信息，尽管目录的data block中也记录着文件的inode指针，但定位指针是需要x权限的，因为其它信息都储存在文件自身对应的inode中，而要读取文件inode信息需要有目录文件的执行权限通过inode指针定位到文件对应的inode记录上。\n```bash\nls: cannot access d/a: Permission denied\nls: cannot access d/bc: Permission denied\ntotal 0\n? -????????? ? ? ? ?            ? a\n? -????????? ? ? ? ?            ? bc\n```\n\n# 3. inode基础知识\n每个文件都有一个inode，在将inode关联到文件后系统将通过inode号来识别文件，而不是文件名。\n访问文件时将先找到inode，通过inode中记录的block位置找到该文件。\n\n## 3.1. 硬链接\n多个文件的inode相同，也就即inode号、元数据、block位置都相同\n这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。\n硬链接文件的inode都相同，每个文件都有一个\"硬链接数\"的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。\n![hard link](_v_images/20190318171817426_202435032.png)\n\n```bash\nc/al --hard-link-- d/a\n# 4. stat 信息一致, 硬连接数变为2\n-rw-r--r-- 2 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users    0 Mar 18 17:12 a\n-rw-r--r-- 2 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 0 Mar 18 17:12 al\n```\n每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。\n删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数\n当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。\n>不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同，如果允许创建硬链接，复制到另一个分区时inode可能会和此分区已使用的inode号冲突。\n硬链接只能对文件创建，无法对目录创建硬链接。\n\n通过mount工具的\"--bind\"选项，可以将一个目录挂载到另一个目录下，实现伪\"硬链接\"，它们的内容和inode号是完全相同的。\n\n## 3.2. inode深入\n### 3.2.1. inode大小和划分\ninode大小为128字节的倍数，最小为128字节。它有默认值大小\n当然inodesize、inode分配比例、blocksize都可以在创建文件系统的时候人为指定。\n\n### 3.2.2. ext文件系统预留的inode号\n具体的inode号对应什么文件可以使用\"find / -inum NUM\"查看。\n\nExt4的特殊inode:\n| inode号    | 用途    |\n| :-: | :-: |\n|    0 |不存在0号inode     |\n|     1|    虚拟文件系统，如/proc和/sys  |\n|   **2**|    根目录  |\n|    3 |  ACL索引   |\n|     4|    ACL数据 |\n|     5|      Boot  loader|\n|     6|   未删除的目录  |\n|     7|     预留的块组描述符inode|\n|     8|   日志inode  |\n|11 |    第一个非预留的inode，通常是lost+found目录  |\n\n所以在ext4文件系统的dumpe2fs信息中，能观察到fisrt inode号可能为11也可能为12。\n不同文件系统之间是可能会出现使用相同inode号文件的\n\n## 3.3. ext2/3的inode直接、间接寻址\n\ninode中保存了blocks指针，但是一条inode记录中能`保存的指针数量`是有限的，否则就会超出inode大小(128字节或256字节)。\n在ext2和ext3文件系统中，一个inode中最多只能有15个指针，每个指针使用i_block[n]表示。\n前12个指针i_block[0]到i_block[11]是直接寻址指针，每个指针指向一个数据区的block。\n\n![前12直接寻址](_v_images/20190318173208037_1241667516.png)\n第13个指针i_block[12]是一级间接寻址指针，它指向一个仍然存储了指针的block即i_block[12] --> Pointerblock --> datablock。\n第14个指针i_block[13]是二级间接寻址指针，它指向一个仍然存储了指针的block，但是这个block中的指针还继续指向其他存储指针的block，即i_block[13] --> Pointerblock1 --> PointerBlock2 --> datablock。\n第15个指针i_block[14]是三级间接寻址指针，它指向一个任然存储了指针的block，这个指针block下还有两次指针指向。即i_block[13] --> Pointerblock1 --> PointerBlock2 --> PointerBlock3 --> datablock。\n\n对应的中间指针block, Pointerblock* 如果为4k, 对于32位系统, 则一个中间block对应4k/32=128个指针.\n![13-15多级指针](_v_images/20190318173451871_1809034210.png)\n\n这里的计算只是表明一个大文件是如何寻址和分配的.\n如果存放的文件大于64M，那么就继续使用三级间接指针i_block[14]，存放的指针数量为1T个, 存放的文件大小为4T左右\n```mathjax\n$$\n(4096/4)^3 + (4096/4)^2 + 4096/4 + 12 = 1T\n$$\n```\n\n# 4. 单文件系统中文件操作的原理\n## 4.1. 读取文件\n\n`cat /var/log/messages` 命令, 其中保存了inode号, 通过多级目录查找inode号\n- 找到根文件系统的块组描述符表GDT所在的blocks，读取GDT(已在内存中)找到inode table的block号。\n因为GDT总是和superblock在同一个块组，而superblock总是在分区的第`1024-2047`个字节，所以很容易就知道第一个GDT所在的块组以及GDT在这个块组中占用了哪些block。\n其实GDT早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的GDT放进内存中。\n- 在inode table的block中定位到根\"/\"的inode，找出\"/\"指向的data block。\n前文说过，ext文件系统预留了一些inode号，其中\"/\"的inode号为2，所以可以根据inode号直接定位根目录文件的data block。\n- 在\"/\"的datablock中记录了`var目录名`和指向var目录文件`inode的指针`，并找到该inode记录，\ninode记录中存储了指向var的block指针，所以也就找到了var目录文件的data block。\n通过var目录的inode指针，可以寻找到var目录的inode记录，\n但是指针定位的过程中，还需要知道该`inode记录所在的块组以及所在的inode table`，所以需要读取GDT，同样，GDT已经缓存到了内存中。\n- 在var的data block中记录了log目录名和其inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到log的data block。\n- 在log目录文件的data block中记录了messages文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到messages的data block。\n- 最后读取messages对应的datablock\n将上述步骤中GDT部分的步骤简化后比较容易理解:\n找到GDT-->找到\"/\"的inode-->找到/的数据块读取var的inode-->找到var的数据块读取log的inode-->找到log的数据块读取messages的inode-->找到messages的数据块并读取它们\n\n## 4.2. 删除、重命名和移动文件(不跨越文件系统)\n- 删除文件分为普通文件和目录文件，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。\n    - 删除普通文件\n        - 找到文件的inode和data block(根据前一个小节中的方法寻找)\n        - 将inode table中该inode记录中的data block指针删除\n        - 在imap中将该文件的inode号标记为未使用\n        - 在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针\n        - 将bmap中data block对应的block号标记为未使用。\n    - 删除目录文件\n        - 找到目录和目录下所有文件、子目录、子文件的inode和data block；\n        - 在imap中将这些inode号标记为未使用\n        - 将bmap中将这些文件占用的 block号标记为未使用\n        - 在该目录的父目录的data block中将该目录名所在的记录行删除\n        标记data block为未使用后，表示开始释放空间，这些data block可以被其他文件重用.\n        在第(5)步之前，由于data block还未被标记为未使用，在superblock中仍然认为这些data block是正在使用中的。这表示尽管文件已经被删除了，但空间却还没有释放，df也会将其统计到已用空间中(df是读取superblock中的数据块数量，并计算转换为空间大小)。\n        当一个进程正在引用文件时将该文件删除，就会出现文件已删除但空间未释放的情况。有可能出现du统计结果比df小的原因\n\n## 4.3. 移动文件\n同文件系统下移动文件实际上是修改目标文件所在目录的data block, 向其中添加一行指向inode table中待移动文件的inode指针, \n如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。\n所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。\n\n对于不同文件系统内的移动，相当于先复制再删除的动作\n![移动文件](_v_images/20190318185645317_1849434093.png)\n\n## 4.4. 存储和复制文件\n- 对于文件存储\n    - 1. 读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号；\n    - 2. 在inode table中完善该inode号所在行的记录；\n    - 3. 在目录的data block中添加一条该文件的相关记录；\n    - 4. 将数据填充到data block中。\n        - 填充到data block中的时候会调用block分配器：一次分配4KB大小的block数量，当填充完4KB的data block后会继续调用block分配器分配4KB的block，然后循环直到填充完所有数据。也就是说，如果存储一个100M的文件需要调用block分配器100*1024/4=25600次。\n        - 在block分配器分配block时，block分配器并不知道真正有多少block要分配，只是每次需要分配时就分配，在每存储一个data block前，就去bmap中标记一次该block已使用，它无法实现一次标记多个bmap位。这一点在ext4中进行了优化。\n    - 5. 填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针。\n- 对于复制，完全就是另一种方式的存储文件。步骤和存储文件的步骤一样。 \n\n# 5. 多文件系统关联\n## 5.1. 根文件系统的特殊性\n这里要明确的是，任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在\"/\"文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有\"/\"是自引用的。这里要说明挂载点的级别和自引用的概念。\n>文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。\n### 5.1.1. 自引用\n自引用的只能是文件系统，而文件系统表现形式是一个目录，所以自引用是指该目录的data block中，`\".\"和\"..\"的记录中的inode指针都指向inode table中同一个inode记录`，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。\n\n```bash\n[root@xuexi /]# ll -ai /\ntotal 102\n     2 dr-xr-xr-x.  22 root root  4096 Jun  6 18:13 .\n     2 dr-xr-xr-x.  22 root root  4096 Jun  6 18:13 .. \n```\n`cd .`和 `cd ..`效果是一样的.这是自引用最直接的表现形式。\n根目录下的\".\"和\"..\"都是\"/\"目录的硬链接，且其datablock中不记录名为\"/\"的条目，因此除去根目录下子目录数后的硬链接数为2。\n\n## 5.2. 挂载文件系统的细节\n挂载文件系统到某个目录下，例如\"mount /dev/cdrom /mnt\"，挂载成功后/mnt目录中的文件全都暂时不可见了，且挂载后权限和所有者(如果指定允许普通用户挂载)等的都改变了，知道为什么吗？\n详细说明挂载过程中涉及的细节\n当文件系统/dev/cdrom挂载到/mnt上后，/mnt此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block\n在根文件系统的inode table中，为/mnt重新分配一个inode记录m，该记录的block指针block_m指向文件系统/dev/cdrom中的data block。既然为/mnt分配了新的inode记录m，那么在\"/\"目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用。\nblock_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的`元数据信息`和`数据信息`分别存储在不同的文件系统上。\n而`卸载文件系统`，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了\n- 挂载点挂载时的inode记录是新分配的。\n- 挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。\n挂载点原来的inode记录暂时被标记为不可用，关键是没有指向该inode记录的inode指针了。在卸载文件系统后，又重新启用挂载点原来的inode记录，\"/\"目录下的mnt的inode指针又重新指向该inode记录。\n- 挂载后，挂载点的元数据和data block是分别存放在不同文件系统上的。\n- 挂载点即使在挂载后，也还是属于源文件系统的文件\n\n## 5.3. ext3文件系统的日志功能\n相比ext2文件系统，ext3多了一个日志功能。\n在创建ext3文件系统时会划分三个区：数据区、日志区和元数据区。每次存储数据时，先在日志区中进行ext2中元数据区的活动，直到文件存储完成后标记上commit才将日志区中的数据转存到元数据区。当存储文件时突然断电，下一次检查修复文件系统时，只需要检查日志区的记录，将bmap对应的data block标记为未使用，并把inode号标记未使用，这样就不需要扫描整个文件系统而耗费大量时间。\n\n\n## 5.4. ext4文件系统\next2和ext3文件系统, 对于一个巨大的文件，扫描整个bmap都将是一件浩大的工程。另外在inode寻址方面，ext2/3使用直接和间接的寻址方式，对于三级间接指针，可能要遍历的指针数量是非常非常巨大的。\next4文件系统的最大特点是在ext3的基础上使用区`(extent，或称为段`)的概念来管理。一个extent尽可能的`包含物理上连续的一堆block`。inode寻址方面也一样使用区段树的方式进行了改进。\n\n以下是ext4文件系统中一个文件的inode属性示例，注意最后两行的EXTENTS。\n```bash\nInode: 12   Type: regular    Mode:  0644   Flags: 0x80000\nGeneration: 476513974    Version: 0x00000000:00000001\nUser:     0   Group:     0   Size: 11\nFile ACL: 0    Directory ACL: 0\nLinks: 1   Blockcount: 8\nFragment:  Address: 0    Number: 0    Size: 0\n ctime: 0x5b628ca0:491d6224 -- Thu Aug  2 12:46:24 2018\n atime: 0x5b628ca0:491d6224 -- Thu Aug  2 12:46:24 2018\n mtime: 0x5b628ca0:491d6224 -- Thu Aug  2 12:46:24 2018\ncrtime: 0x5b628ca0:491d6224 -- Thu Aug  2 12:46:24 2018\nSize of extra inode fields: 28\nEXTENTS: # 注意\n(0):33409\n```\nEXT4的inode 结构做了重大改变，为增加新的信息，大小由EXT3的128字节增加到默认的256字节，同时inode寻址索引不再使用EXT3的\"12个直接寻址块+1个一级间接寻址块+1个二级间接寻址块+1个三级间接寻址块\"的索引模式，而改为4个`Extent片断流`，每个片断流设定`片断的起始block号及连续的block数量`(有可能直接指向数据区，也有可能指向索引块区)。\n片段流即下图中索引节点(inde node block)部分的`绿色区域`，每个15字节，共60字节。\n![ext4 inode](_v_images/ext4_inode.png)\n\n\n\n### 5.4.1. EXT4删除数据的结构更改\nEXT4删除数据后，会依次释放文件系统bitmap空间位、更新目录结构、释放inode空间位。\n\n### 5.4.2. ext4使用多block分配方式\n在存储数据时，ext3中的block分配器一次只能分配4KB大小的Block数量，而且每存储一个block前就标记一次bmap。假如存储1G的文件，blocksize是4KB，那么每存储完一个Block就将调用一次block分配器，即调用的次数为1024*1024/4KB=262144次，标记bmap的次数也为1024*1024/4=262144次。\n\n而在ext4中根据区段来分配，可以实现调用一次block分配器就分配一堆连续的block，并在存储这一堆block前一次性标记对应的bmap。这对于`大文件`来说极大的提升了存储效率。\n\n## 5.5. ext类的文件系统的缺点\n最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。\n\n除了格式化速度超慢以外，ext4文件系统还是非常可取的。当然，不同公司开发的文件系统都各有特色，最主要的还是根据需求选择合适的文件系统类型。\n\n## 5.6. 根据inode号找到其block号\n首先可以挂载手机中的system.img到本地\n比如查看`system/etc/recovery-resource.dat`的block号\n```bash\n$ stat recovery-resource.dat         \n  File: ‘recovery-resource.dat’\n  Size: 174555    \tBlocks: 344        IO Block: 4096   regular file\nDevice: 700h/1792d\tInode: 334         Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2017-04-20 21:53:39.000000000 +0800\nModify: 2017-04-20 21:53:39.000000000 +0800\nChange: 2017-04-20 21:53:39.000000000 +0800\n Birth: -\n```\ninode号为334, dump出的信息并没有数据block相关的内容.\n确定`Block size`\n```bash\ndumpe2fs system.img | grep \"Block size\"\n$ dumpe2fs system.img | grep size \ndumpe2fs 1.42.9 (4-Feb-2014)\nFilesystem features:      has_journal ext_attr resize_inode filetype needs_recovery extent sparse_super large_file uninit_bg\nBlock size:               4096\nFragment size:            4096\nInode size:\t          256\n```\nblock大小为4k, inode size为256.\n根据inode号为344, 确定其所在的块组.\n首先确定每个块组的inode数, 根据dumpe2fs出的信息:\n```bash\nInodes per group:         7472\n```\n(344-1)/7472 （一个块组的inode数）= 0, 即该inode 落在第0块组内\n（344-1）%7472 = 343, 该inode在某个inode Table的第343项\n0×32768（一个块组共有32768块）=0，得该文件inode落在第343块组的起始块为0\n从dump出的信息来看, 块组0的inode Table的起始块为27, 一个inode占256, 一个块中有8个inode\n```bash\nGroup 0: (Blocks 0-32767) [ITABLE_ZEROED]\n  Checksum 0x66c5, unused inodes 0\n  Primary superblock at 0, Group descriptors at 1-1\n  Reserved GDT blocks at 2-24\n  Block bitmap at 25 (+25), Inode bitmap at 26 (+26)\n  Inode table at 27-493 (+27)\n  1 free blocks, 6158 free inodes, 48 directories\n  Free blocks: 32767\n  Free inodes: 1315-7472\n```\n则344号所在的块为27+343/16 =  27+ 21 = 48\n在48块的 344%16=8 第8个256字节处.\n334%16=14  第14个256字节处\nvi查看时通过`:%!xxd`转换为16进制查看, 一行有16个字节, 16行代表一个256字节单位.\n因此第8个256在起始于16*7+1个位置 第113行位置\n上面只查找到inode table为位置.\n\n通过dump出inode table的数据块 count=512代表dump出48块开始的512个block.\n```bash\ndd if=/dev/sda5 ibs=4096 skip=48 count=512 of=inode_table\n```\n定位到0x700位置, 即7*256 转换为16进制.\n```bash\n0000700: 3f3f 0000 3f14 0000 593f 3f58 593f 3f58  ??..?...Y??XY??X\n0000710: 593f 3f58 0000 0000 0000 0100 1000 0000  Y??X............\n0000720: 3f00 0800 0000 0000 0a3f 0100 0300 0000  ?........?......\n0000730: 0000 0000 0000 0000 0200 0000 6e29 0000  ............n)..\n0000740: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000750: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000760: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000770: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000780: 1c00 0000 0000 0000 0000 0000 0000 0000  ................\n0000790: 0000 0000 0000 0000 0000 0000 0000 023f  ...............?\n00007a0: 0706 4400 0000 0000 1a00 0000 0000 0000  ..D.............\n00007b0: 7365 6c69 6e75 7800 0000 0000 0000 0000  selinux.........\n00007c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00007d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00007e0: 0000 0000 753a 6f62 6a65 6374 5f72 3a73  ....u:object_r:s\n00007f0: 7973 7465 6d5f 6669 6c65 3a73 3000 0000  ystem_file:s0...\n```\n偏移60个字节(0000600+3C), 即可定位到数据指针(6e29 0000), 由于ext4采用了小端存储,  则其数据指针为0x296e,转换为10进制为 10606\n使用`debugfs`验证一下\n```bash\n$ debugfs\ndebugfs 1.42.9 (4-Feb-2014)\ndebugfs:  open -w system.img\ndebugfs:  mi<344>\ndebugfs: Unknown request \"mi<344>\".  Type \"?\" for a request list.\ndebugfs:  mi <344>\n                          Mode    [0100644]\n                       User ID    [0]\n                      Group ID    [0]\n                          Size    [5375] \n                 Creation time    [1492695641] \n             Modification time    [1492695641] \n                   Access time    [1492695641] \n                 Deletion time    [0] \n                    Link count    [1] \n              Block count high    [0] \n                   Block count    [16] \n                    File flags    [0x80080] \n                    Generation    [0x0] \n                      File acl    [0] \n           High 32bits of size    [0] \n              Fragment address    [0] \n               Direct Block #0    [127754] \n               Direct Block #1    [3] \n               Direct Block #2    [0] \n               Direct Block #3    [0] \n               Direct Block #4    [2]\n               #db5 为10606说明是正确的\n               Direct Block #5    [10606] \n```\n334号inode 定位到0xd00位置, 即13*256转换16机制\n```bash\n0000d00: 3f3f 0000 dba9 0200 633f 3f58 633f 3f58  ??......c??Xc??X\n0000d10: 633f 3f58 0000 0000 0000 0100 5801 0000  c??X........X...\n0000d20: 3f00 0800 0000 0000 0a3f 0100 0300 0000  ?........?......\n0000d30: 0000 0000 0000 0000 2b00 0000 3329 0000  ........+...3)..\n0000d40: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000d50: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000d60: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000d70: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000d80: 1c00 0000 0000 0000 0000 0000 0000 0000  ................\n0000d90: 0000 0000 0000 0000 0000 0000 0000 023f  ...............?\n0000da0: 0706 4400 0000 0000 1a00 0000 0000 0000  ..D.............\n0000db0: 7365 6c69 6e75 7800 0000 0000 0000 0000  selinux.........\n0000dc0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000dd0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n0000de0: 0000 0000 753a 6f62 6a65 6374 5f72 3a73  ....u:object_r:s\n0000df0: 7973 7465 6d5f 6669 6c65 3a73 3000 0000  ystem_file:s0...\n```\n2933    10547也是能对应上.\n0xd00-0xdf0 即为`system/etc/recovery-resource.dat`对应的inode\n","tags":["Android","ext4"],"categories":["文件系统"]},{"title":"文件系统结构理解","url":"/2018/08/02/其他调研/文件系统知识1/","content":"\n# 1. 文件系统知识1\n\n## 1.1. 文件相关数据结构\n每个进程的task_struct结构体中, 包含一个`struct files_struct* files`结构体指针,指向该进程所有已经打开的文件/目录对应的相关信息的结构体.\nfiles内部又包含`struct file fd_array[]`数组, 每一个都是`struct file`结构体(又被称作fd, 文件描述符), 每个`file`结构体中记录了被打开文件的基本信息, 如记录该文件对应的目录项`dentry`,\n用于操作该文件的`file_operations`回调函数等, 从`dentry`中可以找到该文件对应的`inode`结构体, 从而得到该文件的各种属性信息.\n\nfd_array数组的长度存放在max_fds字段中, linux系统中，一个进程打开的文件数是有初步限制的，即其文件描述符数初始时有最大化定量，即一个进程一般只能打开`NR_OPEN_DEFAULT`个文件，该值在32位机上为32个，在64位机上为64个\ninit fork一个子进程时, 也是如此.\n\n```shell\ndo_fork======->copy_process\n    |======->dup_task_struct======->alloc_task_struct\n    |======->copy_files======->dup_fd======->alloc_files\n```\n### 1.1.1. struct  files_struct扩充\n进程打开的fd数目超过`NR_OPEN_DEFAULT`时, 对已经初始化的files_struct进行扩充\n当进行struct files_struct扩充时，会分配一个新的struct fdtable, 分配并初始化新的struct fdtable变量后，原先指向fdtab的struct files_struct指针成员`fdt`，会指向新分配的struct fdtable变量。这时，struct files_struct实例变量中就包含两个struct fdtable存储区：一个是其自身的，一个新分配的，用fdt指向。执行完上述的操作后，还要*将旧的结构存储区的内容拷贝到新的存储区*，这包括files_struct自身所包含的close_on_exec，open_fds，fd到新分配的close_on_exec，open_fds，fd的拷贝。\n执行完上述拷贝之后，就要释放旧的struct fdtable，但这里并不执行执行该项释放操作. (需要时机触发)\nstruct files_struct扩充使用内核源码中的expand_files来实现，`expand_files`会调用`expand_fdtable`：\n\n```c\nstatic int expand_fdtable(struct files_struct *files, int nr)\n{\n    struct fdtable *new_fdt, *cur_fdt;\n    new_fdt = alloc_fdtable(nr);      //分配了一个fdtable\n    cur_fdt = files_fdtable(files);   //files->fdt\n    if (nr >= cur_fdt->max_fds) {\n        /* Continue as planned */\n        copy_fdtable(new_fdt, cur_fdt);   //拷贝了其中的3个变量:fd,open_fds,close_on_exec\n        rcu_assign_pointer(files->fdt, new_fdt);  //将新分配的fdtable赋值给files的fdt\n          if (cur_fdt->max_fds > NR_OPEN_DEFAULT)  //注意它第一次初始化为NR_OPEN_DEFAULT\n            free_fdtable(cur_fdt);\n     }\n    return 1;\n}\n```\n扩充后, 内核会同时更新`max_fds`字段值.\n\n[files_struct扩充](https://blog.csdn.net/metersun/article/details/80513702)\n\n![files_struct](/home/mi/Pictures/flow/files_struct.svg)\n\n>本地FS(如ext4)在硬盘上维护的inode/dentry/superblock等数据结构, 与VFS在内存中维护的同名数据结构(上文`task_struct`使用的)是两套完全不同的东西, 虽然名称相同.\n> file_operations与address_space_operations:  f_ops hook到vfs, a_ops完成page_cache访问\n\n\n### 1.1.2. 标准输入输出文件描述符\n对于在fd数组中所有元素的每个文件来说，数组的索引就是文件描述符(file descriptor)。通常，数组的第一个元素（`索引为0`）是进程的标准输入文件，数组的第二个元素（`索引为1`）是进程的标准输出文件，数组的第三个元素（`索引为2`）是进程的标准错误文件。请注意，借助于dup()、dup2()和fcntl()系统调用，两个文件描述符可以指向同一个打开的文件，也就是说，数组的两个元素可能指向同一个文件对象。当用户使用shell结构（如2>&1）将标准错误文件重定向到标准输出文件上时，用户也能看到这一点。\n\n### 1.1.3. rlimit 设置进程可以打开文件的最大数目\n进程不能使用多于`NR_OPEN`（通常为1 048 576)个文件描述符。内核也在进程描述符的`signal->rlim[RLIMIT_NOFILE]`结构上强制动态限制文件描述符的最大数；这个值通常为1024，但是如果进程具有超级用户特权，就可以增大这个值。\n\nandroid rc中配置\n```log\n# setrlimit <resource> <cur> <max>\n# 在linux中分为软限制(soft limit)和硬限制(hard limit)的, 软限制可以在程序的进程中自行改变(突破限制)，而硬限制则不行(除非程序进程有root权限)\nsetrlimit 7  4096  4096\n```\n\n```c\nSYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit new_rlim;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\treturn do_prlimit(current, resource, &new_rlim, NULL);\n}\nstatic inline unsigned long rlimit(unsigned int limit)\n{\n\treturn task_rlimit(current, limit);\n}\nstatic int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}\n```\n## 1.2. open 调用流程\nopen过程是为待访问的具体目标文件创建和填充上述结构的过程\nmount过程为文件系统根目录创建了VFS dentry/inode等结构\n\n```c\nSYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)\n{\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n    // AT_FDCWD  -100 该值表明当 filename 为相对路径的情况下将当前进程的工作目录设置为起始路径。\n    // 也可以在另一个系统调用 openat 中为这个起始路径指定一个目录，此时 AT_FDCWD 就会被该目录的描述符所替代.\n\treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n}\n```\n```erlang\n+-COMPAT_SYSCALL_DEFINE3() <COMPAT_SYSCALL_DEFINE3 (open, const char __user *, filename, int, flags, umode_t, mode) at open.c:1135>\n  \\-do_sys_open() <long do_sys_open (int dfd, const char __user *filename, int flags, umode_t mode) at open.c:1085>\n    +-build_open_flags() <inline int build_open_flags (int flags, umode_t mode, struct open_flags op) at open.c:961>  #构建open_flags\n    +-getname()          # 把用户空间数据复制到内核空间, \n    |                    # 1. 通过kmem_cache_alloc在内核缓冲区专用队列names_cachep里申请一块内存用来放置路径名，其实这块内存就是一个 4KB 的内存页\n    |                    # 2. 如果文件路径长度大于EMBEDDED_NAME_MAX，则通过kzalloc分配内存。\n    |                    # 3. 将文件路径字符串从用户态复制到内核态\n    +-get_unused_fd_flags() <int get_unused_fd_flags (unsigned flags) at file.c:543> # 分配未使用的fd, \n    |     # 如果扩展操作导致当前进程的这个存放struct file的数组放不下了\n    |     # 如要装第65个struct flie结构体，那么将重新分配一片内存区专门用来存放struct file结构体，并且这个内存区的大小为128个struct file结构体，\n    |     # 然后将当前进程的task_struct->files_struct->fdtable->fd指针指向这片内存的首地址，然后把之前数组里面的内容复制到这片内存区里面来。\n    |     # 下次添加如果超过了128个了，则分配256个大小直到256个也装满，超过256则分配512，依次类推，总是2的幂次方，且会把之前的复制到新分配的内存里面去.\n    | \\+-__alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n    |   \\+- rlimit\n    |     \\- task_rlimit\n    +-do_filp_open()     # 一级一级查找到对应目录下对应文件系统的本地inode,初始化file对象\n    |\\ +- path_openat(&nd, op, flags)\n    |  \\ +- alloc_empty_file(op->open_flag, current_cred()) # 初始化file, 分配内存\n    |    | \\ +- __alloc_file(flags, cred)\n    |    |    \\ - kmem_cache_zalloc (filp_cachep, GFP_KERNEL) # 此处与内存管理slab分配器关联\n    |    +- path_init(nd,flags); # 初始化nameidata进行“节点路径查找, 路径初始化，确定查找的起始目录，初始化结构体 nameidata 的成员 path(初始化父目录)\n    |    +- link_path_walk(s, nd) # 节点路径查找，结果记录在nd中, 一级一级查找, 如果没有记录, \n    |    | \\  +- lookup_fast      \n    |    |    +- lookup_slow     # 先alloc dentry_cache, 初始化dentry结构, 再去本地文件系统中查找, 调用具体文件系统的lookup函数构造inode, 填充dentry\n    |    |    |  \\ +- \"d_alloc_parallel(dir, name, &wq)\"\n    |    |    |    | \\ +- kmem_cache_alloc(dentry_cache, GFP_KERNEL)   #创建dentry_cache\n    |    |    |    +- inode->i_op->lookup(inode, dentry, flags)\n                      \\ +- ext4_lookup  #详情见 ext4_lookup的分析                     \n    |    +- do_last <nd, file, op, &opened> # 创建(新文件)或者获取文件对应的inode对象，填充file 对象\n    |      \\ +- vfs_open <&nd->path, file>\n    |         \\ +- do_dentry_open (file, d_backing_inode(path->dentry), NULL) # 通过inode 填充file file跟inode 绑定, 检查open涉及的一些权限问题\n                  \\ +- security_file_open(f) # selinux 权限检查 selinux是hook到ext4中的\n                      \\ - selinux_file_open # LSM_HOOK_INIT(file_open, selinux_file_open)\n                  | +- f->f_op->open <inode>                  \n                      \\ +- ext4_file_open (inode, file * filp)\n                          \\ - fscrypt_file_open(inode, filp) # 处理加密策略, 检查父目录的加密策略和文件的是否一致\n                          | +- dquot_file_open -- generic_file_open  # ext4开启quota 特性后, #write一个节点时, \n                                                                     # quota相关的特性初始化 Initialize quota pointers in inode\n                              \\ -<f_mode & FMODE_WRITE>- __dquot_initialize <struct inode *inode, int type> \n         |- terminate_walk(nd) # 中止walk, rcu放锁有关, rcu不允许有阻塞\n    +-fsnotify_open() # inotify机制, 通知文件打开事件\n    +-fd_install() <void fd_install (unsigned int fd, struct file file) at file.c:611>  \n    | #fd填充到fd_array数组中, 创建的文件对象指针存到该进程的打开文件数组中 fdt->fd[fd] = file\n    \\-putname() # putname()释放在内核分配的路径缓冲区\n```\n\n```erlang\nSYSCALL_DEFINE3(open...)\t//open.c +1038\n\tdo_sys_open()\n\t\tbuild_open_flags()\n\t\tstruct filename *tmp = getname()\n\t\t\tgetname_flags()\n\t\t\t\tkname = (char*)result + sizeof(*result)\n\t\t\t\tresult->name = kname\n\t\t\t\tstrncpy_from_user(kname, filename,max)\n\t\t\t\tresult->uptr = filename\n\t\tfd = get_unused_fd_flags()\n\t\t\t__alloc_fd()\n\t\tstruct file *f = do_filp_open()\n\t\t\tstruct nameidata nd\n\t\t\tpath_openat()\n\t\t\t\tfile = get_empty_filp()\n\t\t\t\tfile->f_flags = op->open_flag\n\t\t\t\tpath_init()\n\t\t\t\t\tlink_path_walk()\n\t\t\t\t\t\tmay_lookup()\n\t\t\t\t\t\twalk_component()\n\t\t\t\t\t\t\thandle_dots()\n\t\t\t\t\t\t\tlookup_fast()\t\n\t\t\t\t\t\t\tlookup_slow()\t// 去真实的文件系统内查找\n\t\t\t\t\t\t\t\t__lookup_hash()\n\t\t\t\t\t\t\t\t\tlookup_dcache()\n\t\t\t\t\t\t\t\t\tlookup_real()\n\t\t\t\t\t\t\t\t\t\tdir->i_op->lookup()\t//ext4_lookup\n\t\t\t\t\t\t\t\t\t\t\tinode = ext4_iget_normal()\n\t\t\t\t\t\t\t\t\t\t\t\text4_iget()\n\t\t\t\t\t\t\t\t\t\t\t\t\tstruct ext4_inode * raw_inode\n\t\t\t\t\t\t\t\t\t\t\t\t\tstruct inode *inode\n\t\t\t\t\t\t\t\t\t\t\t\t\tinode = iget_locked()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinode = find_inode_fast()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinode = alloc_inode()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinode->i_ino = ino\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinode->i_state = I_NEW\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thlist_add_head()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinode_sb_list_add()\n\t\t\t\t\t\t\t\t\t\t\t\t\t__ext4_get_inode_loc()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstuct buffer_head *bh\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstruct ext4_group_desc *gdp\n\t\t\t\t\t\t\t\t\t\t\t\t\t\text4_inode_table()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiloc->block_group = ...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiloc->offset = ...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tget_bh(bh)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbh->b_endio = end_buffer_read_sync\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubmit_bh*()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubmit_bio()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twait_on_buffer()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiloc->bh = ...\n\t\t\t\t\t\t\t\t\t\t\t\t\traw_inode = ext4_raw_inode()\n\t\t\t\t\t\t\t\t\t\t\t\t\tinode->i_blocks = ext4_inode_blocks()\n\t\t\t\t\t\t\t\t\t\t\t\t\tinode->isize = ext4_isize()\n\t\t\t\t\t\t\t\t\t\t\t\t\tinode->i_op=...\n\t\t\t\t\t\t\t\t\t\t\t\t\tinode->i_fop= ...\n\t\t\t\t\t\t\tinode = path->dentry->d_inode\n\t\t\t\t\t\t\tnd->inode = inode\n\t\t\t\tdo_last()\n\t\t\t\t\thandle_dots()\n\t\t\t\t\tlookup_fast()\n\t\t\t\t\tcomplete_walk()\n\t\t\t\t\t\tdentry->d_op->d_weak_revalidate()\n\t\t\t\t\tlookup_open()\n\t\t\t\t\t\tstruct dentry *dir = nd->path.dentry\n\t\t\t\t\t\tstruct inode *dir_inode = dir->d_inode\n\t\t\t\t\t\tlookup_dcache()\n\t\t\t\t\t\tatomic_open()\n\t\t\t\t\t\tlookup_real()\n\t\t\t\t\t\tvfs_create()\n\t\t\t\t\taudit_inode()\n\t\t\t\t\tmnt_want_write()\n\t\t\t\t\tmay_open()\n\t\t\t\t\tvfs_open()\n\t\t\t\t\t\tstruct inode *inode = path->dentry->d_inode\n\t\t\t\t\t\tinode->i_op->dentry_open()\n\t\t\t\t\t\tdo_dentry_open()\n\t\t\t\t\t\t\tinode = f->f_inode = f->f_path.dentry->d_inode\n\t\t\t\t\t\t\tf->f_mapping = inode->i_mapping\n\t\t\t\t\t\t\tf->f_op=fops_get(inode->i_fop)\n\t\t\t\t\t\t\topen = f->f_op->open\n\t\t\t\t\t\t\topen(inode,f)\n\t\t\t\t\tterminate_walk()\n\t\tfsnotity_open()\n```\n[open在linux内核的实现](http://edsionte.com/techblog/archives/4472)\n***[open在内核中的实现2](http://edsionte.com/techblog/archives/4476)***\n[open调用流程分析](https://blog.csdn.net/younger_china/article/details/54708077)\n[open七日游](http://blog.chinaunix.net/uid-20522771-id-4419666.html)\n[open调用流程代码分析](https://juejin.im/post/5d639855518825776118b0ff)\n[详解sys_open](https://blog.csdn.net/npy_lp/article/details/78572821)\n\n### 1.2.1. ext4_lookup 流程\n\n上述open的流程调用下来, 如果dentry不在page cache中, 则会陷入到具体的文件系统中查找对应的inode\n\n```erlang\n+- dentry *ext4_lookup <struct inode *dir, struct dentry *dentry, unsigned int flags>  #inode为父目录的inode结构, dentry未刚初始化, 未填充数据查找文件的dentry结构\n    \\ +-  fscrypt_prepare_lookup(dir, dentry, flags) #设置lookup策略, 与文件加密有关\n    |  \\ +- __fscrypt_prepare_lookup(struct inode *dir, struct dentry *dentry) \n    |       \\- dentry->d_flags |= DCACHE_ENCRYPTED_WITH_KEY    # \n    |       |- d_set_d_op(dentry, &fscrypt_d_ops) # hook dentry_operations  .d_revalidate = fscrypt_d_revalidatefscrypt_d_revalidate\n    | +-  ext4_find_entry(dir, &dentry->d_name, &de, NULL); #load 父目录dentry, 从父目录中查找对应文件的inode number 放到de (ext4_dir_entry_2)中\n      |                       # direntry 实际上文件名保存在目录中，目录也是一个文件，也占用一个inode结构，它的数据块存储的是该目录下所以文件的文件名，以及各个文件对应的inode号。\n    |  \\ +- ext4_fname_setup_filename(dir, &dentry->d_name, 0, &fname);\n    |    |  \\ +-  fscrypt_setup_filename (dir, iname, lookup, &name) #设定了加密策略时, 会对文件名进行加解密\n    |    |       \\ +- fscrypt_get_encryption_info (struct inode *inode) #从父目录inode中获取加密上下文\n    |             |   \\-  \"inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx))\"\n    |             |  fname_encrypt <dir, iname, fname->crypto_buf.name, fname->crypto_buf.len> # 加密文件名放在\"fname->crypto_buf.name\"下\n    |             |  \"fname->disk_name.name = fname->crypto_buf.name\" # disk_name下存放加密的文件名\n    |     | - ext4_has_inline_data <dir>  # 很小的数据可以直接存放在 inode 之间的空余空间里，根本无需单独分配数据块\n    |            \\- ext4_find_inline_entry <dir, &fname, res_dir, &has_inline_data> 从dir的 inode的剩余空间查找是否存了对应文件名的inode\n    |     | - is_dx(dir) # EXT4 的 dir_index 特性 [dir_index](https://bean-li.github.io/EXT4_DIR_INDEX/) hash tree方式组织目录结构 ext4 默认打开\n    |         \\ - ext4_dx_find_entry(dir, &fname, res_dir)\n    |     |+- ext4_bread_batch(dir, block, ra_max, false /* wait */, bh_use) #线性查找 跟buffer_head有关, 刷盘, Read a contiguous batch of blocks\n    |         \\ +- ext4_getblk(NULL, inode, block + i, 0)   #基于给定的inode，查找或创建block，并返回与其映射的buffer； create标识用于表示当查找不到时，是否执行分配块操作。 \n    |                                                        #[ext4空间块管理](https://blog.csdn.net/younger_china/article/details/22759543)\n    |           | \\ +- bh = sb_getblk(inode->i_sb, map.m_pblk)\n    |               |  \\ +- __getblk_slow <struct block_device *bdev, sector_t block, unsigned size, gfp_t gfp> #从磁盘load 父目录 加载进dentry\n    |                     |  \\ +- grow_dev_page  #为requested block创建page-cache page \n    |                          | \\- find_or_create_page < inode->i_mapping, index, gfp_mask> #struct inode *inode = bdev->bd_inode\n    |     | - buffer_uptodate(bh) #buffer_head更新\n    |     |+- search_dirblock(bh, dir, &fname,  block << EXT4_BLOCK_SIZE_BITS(sb), res_dir)         \n    |       |  \\ +- ext4_search_dir <>      #读出dentry的数据块, 遍历其下所有的文件名, 查看是否与查找的name相匹配, \n    |                                       #如果匹配返回 ext4_dir_entry_2结构 封装了查找文件的inode 号, 名字长度/名字等信息\n    |            | \\+- ext4_match <fname, de> #加密场景下是根据diskname 做匹配的\n    |               |- fscrypt_match_name <const struct fscrypt_name *fname, const u8 *de_name, u32 de_name_len>\n    | +- inode = ext4_iget <dir->i_sb, ino, EXT4_IGET_NORMAL>  #根据上面在目录块中找出的匹配文件名对应的ino号来从磁盘中load 文件对应的inode, \n          \\                                  #参数为sb和ino(ino在特定sb中唯一)  [ext4_iget分析](https://blog.csdn.net/qq_32740107/article/details/93874383)\n          | +- __ext4_iget <sb, ino, flags>\n               \\ +- inode = iget_locked <sb, ino>;   #首先尝试从inode cache中查找 \n               |                               #根据inode_id在inode_hashtable中查找，若查找到直接返回，否则在inode_hashtable分配空的inode，并设置为I_NEW继续后续步骤\n                   \\ +- alloc_inode(sb)    #找不到, 分配inode inode\n                      \\ - inode = sb->s_op->alloc_inode(sb) #ext4_alloc_inode(sb) kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS)  分配inode_cachep  #super_operations\n                      | - inode_init_always(sb, inode) # inode初始化 \n               |- __ext4_get_inode_loc(inode, &iloc, 0)  #读出磁盘相应inode数据, buffer_head, 并指定ext4_inode在bh的偏移量\n               |- raw_inode = ext4_raw_inode(&iloc) # 获得目标索引节点对应的 ext4_inode   注意vfs中的inode描述与本地文件系统inode描述的区别\n               |- ext4_set_aops(inode)... return inode # 根据raw_inode 校验/设置 inode 参数(imapping等),  填充inode, 返回inode\n    | +- d_splice_alias(inode, dentry)  # 把inode加入到direntry树中返回 绑定dentry和inode\n        \\ +- __d_instantiate(struct dentry *dentry, struct inode *inode)\n            \\- hlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry); #dentry和inode是多对一的关系, 将dentry挂入inode的i_dentry链表中\n            |- __d_set_inode_and_type(dentry, inode, add_flags);  # dentry->d_inode = inode;                                       \n                                \n```\n\n![__ext4)get_inode_loc分析](_v_images/20191219233331326_321449507.png)\n![dentry数据块 b_data](_v_images/20191219231536499_2128254870.png)\n\n```dot\ndigraph G {\n  rankdir=LR\n  node [shape=record];\n  \n  ext4_dir_entry_2[ label=\"\n      <0> ext4_dir_entry_2 |\n      =======| <1> inode number |   <2>name_len|   <3> name [EXT4_NAME_LEN]|   file_type \"]\n  \n  ext4_filename [label=\"\n     <0> ext4_filename| =======| <1> qstr *usr_fname | <2>fscrypt_str disk_name |  dx_hash_info hinfo | fscrypt_str crypto_buf \"]\n\n  buffer_head [label=\"\n     <0> buffer_head| =======| <1> char *b_data | block_device *b_bdev|  bh_end_io_t *b_end_io| b_count| ... \"]\n\n  buffer_head:1 -> ext4_dir_entry_2:0 [label=\"目录项的数据块,\\n目录下的所有文件信息\\n都封装在里面, 参考上图\"]\n\n    dentry [label=\"<f0> dentry|\n      ======|\n      <1> d_name|\n      <f1> d_inode|\n      <f2> d_sb|\n      <f3> d_op|\n      d_parent |\n      d_child |\n      d_subdirs |\n      ...\"]\n      \n   dentry:1 -> ext4_filename:1\n   ext4_dir_entry_2:3 -> ext4_filename:2 [taillabel=\"compare\" style=dotted color=blue]\n   ext4_filename:1 -> ext4_filename:2 [label=\"encrypt\" style=dotted]\n}\n```\n\n### 1.2.2. 涉及到的slab内存分配\n从上述open的调用流程中, 可以看到多次slab高速缓存的分配\n1. inode = sb->s_op->alloc_inode(sb)  `#ext4_alloc_inode`(sb) kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS)  分配`inode_cachep`\n2. kmem_cache_alloc(dentry_cache, GFP_KERNEL)   `#创建`dentry_cache``\n3. getname()  # 在内核缓冲区专用队列`names_cachep`里申请一块内存用来放置路径名，其实这块内存就是一个 4KB 的内存页\n4. kmem_cache_zalloc (filp_cachep, GFP_KERNEL) # 此处与内存管理slab分配器关联, 分配`filp_cachep`\n\n文件系统在实现时，在vfs这一层的 inode cache 和 dentry cache，不管硬盘的系统，跨所有文件系统的通用信息。\n\n针对这些cache，这些可以回收的slab，linux提供了专门的slab shrink- 收缩函数。\n最后所有可回收的内存，都必须通过LRU算法去回收。\n有些自己申请的 reclaim的内存，由于没有写 shrink函数，所以就无法进行内存的回收。\n\n```bash\n#free pagecache:\n  echo 1 > /proc/sys/vm/drop_caches\n#free reclaimable slab objects(dentry_cache inode_cache)\n  echo 2 > /proc/sys/vm/drop_caches\n# free reclaimable slab objects and page cache\n  echo 3 > /proc/sys/vm/drop_caches\n```\n### 1.2.3. 文件访问小结\n\n访问文件时，文件结构struct file,超级块结构super_block，inode结构,目录项dentry和address_space结构是重要的。\n\n#### 1.2.3.1. struct file文件的初始化\n文件初始化过程是在文件的打开过程中完成的\n\n- 读写一个文件时都是通过文件句柄fd找到 struct file，然后在通过file操作方法进行操作，那么file是何时创建的呢？\n    一般来说是open过程创建的struct file并绑定一个fd，如此后续读写操作可根据fd找file，而file的操作方法在finish_open->do_dentry_open中填充\n    file.f_op=inode.i_fop\n\n- 文件的访问过程最重要的是文件的打开，即`open`过程，open时把大多数资源都初始化好，`read`、`write`等过程直接使用open是初始的一些信息即可，这些信息都是通过struct file结构绑定到fd上，从open传递到read,write等文件操作函数中的。\n- 如何通过struct file结构体，找到文件的super_block,inode和address_space?\n    ```c\n    struct address_space *mapping = file->f_mapping; //打开文件时do_dentry_open初始化\n    structinode *inode  = mapping->host;\n    struct super_block *sb= mapping->host->i_sb\n    ```\n- 通过struct file结构找到inode和super_block?\n\n    对于同一个文件，如果打开两次，系统中对应的file地址是不同的，但inode和super_block是相同的.\n    对于同一mount目录，不同文件对应的inode是不同的但super_block是相同的.\n\n## 1.3. EXT4 Extents\next3/ext2 的data block索引\n![inode](_v_images/20191220151339584_678391002.png)\n\n\n### 1.3.1. debug\n\n从线刷包中解出system.img, 然后使用simg2img将其转换为Android Sparse 格式, 挂载到pc上\n```shell\n# 使用stat 查看 system/etc/permissions文件的inode号\nstat privapp-permissions-miui.xml\n设备：700h/1792d\tInode：1653        硬链接：1\n# 使用istat 查看 inode号的data block索引\n istat system.img_ext4 1653\nDirect Blocks:\n255045 255046 255047 255048 255049 255050 255051 255052 \n255053 255054\n```\n\n在没有`istat`工具情况下, 可以直接通过查看block的原始数据获得data block的索引\n首先, 需要先看下inode中的`extent`的结构, [linux kernel source](https://elixir.bootlin.com/linux/v4.13.16/source/fs/ext4/ext4_extents.h#L105)\n以android kernel 4.19版本查看, \n```c\nstruct ext4_inode {\n\t__le16\ti_mode;\t\t/* File mode */     2\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */ 2\n\t__le32\ti_size_lo;\t/* Size in bytes */ 4\n\t__le32\ti_atime;\t/* Access time */ 4\n\t__le32\ti_ctime;\t/* Inode Change time */ 4\n\t__le32\ti_mtime;\t/* Modification time */ 4\n\t__le32\ti_dtime;\t/* Deletion Time */ 4\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */ 2\n\t__le16\ti_links_count;\t/* Links count */ 2\n\t__le32\ti_blocks_lo;\t/* Blocks count */ 4\n\t__le32\ti_flags;\t/* File flags */ 4\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_version;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__u32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__u32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */ 4\n\t__le32\ti_block[EXT4_N_BLOCKS];/* Pointers to blocks */ EXT4_N_BLOCKS=15\n   ...\n};\nstruct ext4_extent {\n\t__le32\tee_block;\t/* first logical block extent covers */ 4\n\t__le16\tee_len;\t\t/* number of blocks covered by extent */ 2\n\t__le16\tee_start_hi;\t/* high 16 bits of physical block */ 2\n\t__le32\tee_start_lo;\t/* low 32 bits of physical block */ 4\n};\nstruct ext4_extent_header {\n\t__le16\teh_magic;\t/* probably will support different formats */ 2\n\t__le16\teh_entries;\t/* number of valid entries */ 2\n\t__le16\teh_max;\t\t/* capacity of store in entries */ 2\n\t__le16\teh_depth;\t/* has tree real underlying blocks? */ 2\n\t__le32\teh_generation;\t/* generation of the tree */ 4\n};\nstruct ext4_extent_idx {\n\t__le32\tei_block;\t/* index covers logical blocks from 'block' */ 4\n\t__le32\tei_leaf_lo;\t/* pointer to the physical block of the next */ 4\n\t\t\t\t /* level. leaf or next index could be there */ \n\t__le16\tei_leaf_hi;\t/* high 16 bits of physical block */ 2\n\t__u16\tei_unused; 2\n};\n\n```\n对于全是`Direct Blocks`的情况, 对extents进行解读\n在手机设备中首先inode结构体中 40个bytes处为extents的内容, 而iblock一共占(4*15) bytes, 占60个字节.\n\ndump出ino 1653的内容: 需要先看下文件系统的`Inodes per group | Inode blocks per group | Inode size`\n```shell\ndumpe2fs system.img_ext4\nInode size:\t          256\nInodes per group:       8064\nInode blocks per group:   504\n```\ninode号为`1653`说明其在 第0号group 中 `inode/8064 = 0`, 所以需要看`group 0`的描述\n```shell\nGroup 0: (Blocks 0-32767) [ITABLE_ZEROED]\n  Checksum 0x0760, unused inodes 2069\n  主 superblock at 0, Group descriptors at 1-1\n  保留的GDT块位于 2-221\n  Block bitmap at 222 (+222), Inode bitmap at 223 (+223)\n  Inode表位于 224-727 (+224)\n  0 free blocks, 2069 free inodes, 877 directories, 2069个未使用的inodes\n  可用块数: \n  可用inode数: 5996-8064\n```\n注意inode table的位置`Inode表位于 224-727 (+224)`, 1653号位于 `224 + 1653/504`的第`1653 % 504`个256(`Inode size`)区间字节\n所以需要dump 327块的第5个256 区间字节\n```shell\nblkcat system.img_ext4 327  > temp.log\nxxd temp.log\n```\n或者使用 `vi -b temp.log %!xxd` 查看, 或者使用`hexdump -C -v temp.log` 查看\n> 千万不能用 `vi temp.log | %!xxd` 查看, 数据会错乱\n\n第5个 256区间 即从 `0x400-0x4f0`\n```shell\n00000400  a4 81 00 00 56 9a 00 00  80 07 5c 49 80 07 5c 49  |....V.....\\I..\\I|\n00000410  80 07 5c 49 00 00 00 00  00 00 01 00 50 00 00 00  |..\\I........P...|\n00000420  00 00 08 00 00 00 00 00  0a f3 01 00 04 00 00 00  |................|\n00000430  00 00 00 00 00 00 00 00  0a 00 00 00 45 e4 03 00  |............E...|\n00000440  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000450  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000460  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000470  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000480  20 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  | ...............|\n00000490  80 07 5c 49 00 00 00 00  00 00 00 00 00 00 00 00  |..\\I............|\n000004a0  00 00 02 ea 07 06 40 00  00 00 00 00 1a 00 00 00  |......@.........|\n000004b0  00 00 00 00 73 65 6c 69  6e 75 78 00 00 00 00 00  |....selinux.....|\n000004c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n000004d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n000004e0  00 00 00 00 75 3a 6f 62  6a 65 63 74 5f 72 3a 73  |....u:object_r:s|\n000004f0  79 73 74 65 6d 5f 66 69  6c 65 3a 73 30 00 00 00  |ystem_file:s0...|\n```\n从`inode`结构中, `0x04`位置即为文件的size, 可以初步验证下, 是否是对应的文件\n> 手机为小端存储\n\n`0x9a56` 为  39510 正好是`stat`看到的文件的size, 说明是正确的.\n`0x28-0x63` 区间为extents的内容, 一个extent段占用12个字节( `ext4_extent_header ` 结构体的大小)\n```shell\n00000420  00 00 08 00 00 00 00 00 || 0a f3 01 00 04 00 00 00  |................|\n00000430  00 00 00 00 ||00 00 00 00  0a 00 00 00 45 e4 03 00  |............E...|\n```\n`0xf30a` 为 `ext4_extent_header`的magic number\n跟着 `ext4_extent_header`的结构看, `0x2a`处为有效的extent段数目, 此处为1,  `0x2c`处为最大extent段数, 此处为4, `0x2e`处为depth, 此处为0, 说明没有extent tree, 是直接索引.\n`0x34-0x3f`区间为extent段, 占12个字节 (`ext4_extent`结构体大小), 跟着extent结构体往下看 (以|| 分割)\n\n```c\nstruct ext4_extent {\n\t__le32\tee_block;\t/* first logical block extent covers */ 4     0\n\t__le16\tee_len;\t\t/* number of blocks covered by extent */ 2    10\n\t__le16\tee_start_hi;\t/* high 16 bits of physical block */ 2    0\n\t__le32\tee_start_lo;\t/* low 32 bits of physical block */ 4     0x03e445\n};\n```\n高16位为0, 低32位是`0x03e445`,  可表示`48`位逻辑地址\n\n`0x03e445` = 255045 正好与`istat`的结果符合, `ee_len`为10, 表示从`255045`开始的连续10个块号(255045-255054)都是该inode的data block\n\n### 1.3.2. 非直接索引的情况\n\n当EXT4需要大于4个extent时，它会创建一个在磁盘上创建一个树（b树）用来保存必须的extent数据，这就是extent头上的“树深度”(`eh_depth`)一项表达的含义。\n在树最底层的叶子节点上，放置的是规则的extent结构(`ext4_extent`)，就像第一部分里展示的那样。但是在树的中间节点上，是不同的结构，称为extent索引(`ext4_extent_idx`)\n\n![ext4 Extents](_v_images/20191220151228923_647251860.png)\n![extent tree](_v_images/20191226155013453_534545095.png)\n\n```dot\ndigraph G {\n    rankdir=LR\n    node [shape=record];\n\n    ext4_inode [label=\"<0> ext4_inode|\n      ...|\n      <1> i_size_lo 0x4| \n      <2> i_block[EXT4_N_BLOCKS] 0x28|\n      ...\"];\n    \n    ext4_extent [label=\"<0> ext4_extent|\n      =======|\n      <1> ee_block 4|\n      <2> ee_len 2| \n      <3> ee_start_hi 2|\n      <4> ee_start_lo 4\n      \"];\n\n    ext4_extent_header [label=\"<0> ext4_extent_header|\n      =======|\n      <1> eh_magic 2|\n      <2> eh_entries 2| \n      <3> eh_max 2|\n      <4> eh_depth 2 |\n      <5> eh_generation 4\n      \"];\n\n    ext4_extent_idx [label=\"<0> ext4_extent_idx|\n      =======|\n      <1> ei_block 4|\n      <2> ei_leaf_lo 4| \n      <3> ei_leaf_hi 2|\n      <4> ei_unused 2\n      \"];\n    ext4_inode:2 -> ext4_extent_header:0\n    ext4_extent_header:2 -> ext4_extent:0\n    ext4_extent_header:4 -> ext4_extent_idx:0\n    ext4_extent_idx:2 -> ext4_extent:0\n}\n```\n\n\n\n```shell\nbegonia:/storage/emulated/0/downloaded_rom # stat miui_BEGONIA_9.12.25_8e8556132d_10.0.zip                                                                                                                                                                                 \n  File: miui_BEGONIA_9.12.25_8e8556132d_10.0.zip\n  Size: 2128126848\t Blocks: 4156520\t IO Blocks: 512\tregular file\nDevice: 20h/32d\t Inode: 2728207\t Links: 1\nAccess: (0660/-rw-rw----)\tUid: (    0/    root)\tGid: ( 1015/sdcard_rw)\nAccess: 2019-12-25 16:24:52.784175650 +0800\nModify: 2019-12-25 16:28:05.404175662 +0800\nChange: 2019-12-25 16:28:05.404175662 +0800\n\nInodes per group:         8192\nInode blocks per group:   512\n2728207/8192=333\n2728207-2727936=271\n271/16 = 16 | 15\n\nGroup 333: (Blocks 10911744-10944511) csum 0xed26 [ITABLE_ZEROED]\n  Block bitmap at 10911744 (+0)\n  Inode bitmap at 10911745 (+1)\n  Inode table at 10911746-10912257 (+2)\n  31180 free blocks, 7861 free inodes, 185 directories, 7857 unused inodes\n  Free blocks: 10913304-10913479, 10913483, 10913495-10913775, 10913790-10944511\n  Free inodes: 2728202, 2728264-2728265, 2728271-2736128\n\n10911746 + 16 = 10911762\n\n# ext4_extent_header\n00000e00: b481 ff03 80a3 d87e d41c 035e 951d 035e  .......~...^...^\n00000e10: 951d 035e 0000 0000 ff03 0100 686c 3f00  ...^........hl?.\n00000e20: 0008 0800 0100 0000 0af3 0100 0400 0100  ................\n00000e30: 0000 0000 0000 0000 1686 a600 0000 6e00  ..............n.\n00000e40: 6053 0000 2902 0000 60f3 6e00 1056 0000  `S..)...`.n..V..\n00000e50: b103 0000 10f6 6e00 205e 0000 8901 0000  ......n. ^......\n00000e60: 20fe 6e00 f9eb 060d 0e82 a600 0000 0000   .n.............\n00000e70: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00000e80: 2000 0000 b8ec 5c60 b8ec 5c60 8848 f6ba   .....\\`..\\`.H..\n00000e90: d41c 035e 8848 f6ba 0000 0000 0000 0000  ...^.H..........\n00000ea0: 0000 02ea 0109 4000 0000 0000 1c00 0000  ......@.........\n00000eb0: 0000 0000 6300 0000 0000 0000 0000 0000  ....c...........\n00000ec0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00000ed0: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00000ee0: 0000 0000 017f 0400 122e 4f7e 6754 5b11  ..........O~gT[.\n00000ef0: 4101 d984 1c36 1eac 9a7d 4123 9edb 6677  A....6...}A#..fw\n\n# 0x7ed8a380 = 2128126848  证明正好是这个文件\n\n00000e20: 0008 0800 0100 0000 || 0af3 0100 0400 0100  ................\nentry 项 1, 最多4个extent, depth为1\n# ext4_extent_idx\n0000 0000 1686 a600 0000 6e00\n# 指向0xa68616 = 10913302\n# 10913302块  entry 0x14  max entry 0x0154=340 340*12 = 4080, 除去extent_header的12个字节, 正好不超过4096, 证明这个extent block可以占满整个4k block\n00000000  0a f3 14 00 54 01 00 00  00 00 00 00 ||  00 00 00 00\n\n# ext4 extent block\n00000000  0a f3 14 00 54 01 00 00  00 00 00 00 00 00 00 00  |....T...........|\n00000010  00 60 00 00 00 a0 6e 00  00 60 00 00 00 28 00 00  |.`....n..`...(..|\n00000020  00 08 6f 00 00 88 00 00  00 18 00 00 00 98 6d 00  |..o...........m.|\n00000030  00 a0 00 00 00 48 00 00  00 b8 6d 00 00 e8 00 00  |.....H....m.....|\n00000040  00 48 00 00 00 38 6e 00  00 30 01 00 00 50 00 00  |.H...8n..0...P..|\n00000050  00 30 6f 00 00 80 01 00  00 78 00 00 00 88 6f 00  |.0o......x....o.|\n00000060  00 f8 01 00 00 78 00 00  00 08 70 00 00 70 02 00  |.....x....p..p..|\n00000070  00 78 00 00 00 88 70 00  00 e8 02 00 00 78 00 00  |.x....p......x..|\n00000080  00 08 71 00 00 60 03 00  00 78 00 00 00 88 71 00  |..q..`...x....q.|\n00000090  00 d8 03 00 00 78 00 00  00 08 72 00 00 50 04 00  |.....x....r..P..|\n000000a0  00 78 00 00 00 88 72 00  00 c8 04 00 00 78 00 00  |.x....r......x..|\n000000b0  00 08 73 00 00 40 05 00  00 78 00 00 00 88 73 00  |..s..@...x....s.|\n000000c0  00 b8 05 00 00 78 00 00  00 08 74 00 00 30 06 00  |.....x....t..0..|\n000000d0  00 78 00 00 00 88 74 00  00 a8 06 00 00 78 00 00  |.x....t......x..|\n000000e0  00 08 75 00 00 20 07 00  00 78 00 00 00 88 75 00  |..u.. ...x....u.|\n000000f0  00 98 07 00 8b 55 00 00  00 08 76 00 00 e9 07 00  |.....U....v.....|\n00000100  8b 04 00 00 00 59 76 00  00 e9 07 00 8b 04 00 00  |.....Yv.........|\n00000110  00 59 76 00 00 e9 07 00  8b 04 00 00 00 59 76 00  |.Yv..........Yv.|\n00000120  00 e9 07 00 c1 03 00 00  00 59 76 00 00 00 00 00  |.........Yv.....|\n# 来看第一个extent块\n00000000  ................................ ||  00 00 00 00  |....T...........|\n00000010  00 60 00 00 00 a0 6e 00 || ...\n\n\n# 24576个连续块 0x6ea000 7249920开始 从block.map中验证发现是正确的\n#  cat /cache/recovery/block.map \n7249920 7274496\n\n# 第二个extent块\n00000010  .... || 00 60 00 00 00 28 00 00  |.`....n..`...(..|\n00000020  00 08 6f 00 || ...  |..o...........m.|\n\n# 第一个 0x6000表示 第 24576个块, 正好跟第一个区段连起来.  0x2800 该区段包含10240个块, 从 0x6f0800 7276544开始\n#  cat /cache/recovery/block.map \n7276544 7286784\n\n# 第三个\n00 88 00 00  00 18 00 00 00 98 6d 00\n# 34816 6144  7182336\n\n\n#略过, 到最后\n00 98 07 00 8b 55 00 00  00 08 76 00\n# 0x079800 497664  21899  0x765900 7735296\n497664 + 21899 = 2128130048 (2128126848 正好处于 497664 + [21898-21899]之间), 没占满最后一个block\n\n# 注意前面描述的 entry一共20个, 0x00-0xff (16*16-12)/12, 结尾为0xfb 0-251 \n```\n#### 1.3.2.1. 小结\n综上, ota包的extent索引,  tree的depth为1, 引用了一个extent_idx, entent_idx引用的块中包含了一个extent的block, 该block内描述了0x14个extent段, 正好覆盖了全部的 data_block.\n在解析extent_header时, 注意其包含entry的数目, 从`eh_entries`数目可以判断接下来的哪些`ext4_extent`是有效的, 哪些`ext4_extent`是无效的\n\n间接索引4k`extent block`的布局\n\n```dot\ndigraph G {\n    rankdir=UT\n    node [shape=record];\n    ext4_extent_block [label=\"<0> ext4_entent_header 12|\n      <1> ext4_entent 12|\n      <3> ... |\n      <2> ext4_entent 12| \n      <4> tail 4\n      \"];\n}\n```\n\n此处从间接索引extent block entry数目为0x14 = 20, 才会建立b tree, 20>4, 建立了一级索引, depth为1, 另外除了根据`eh_entries`数目从上往下判断哪些entry有效的方法外, 还需要注意\nextent的成员变量`ee_len`，需要说明的是：如果该值`<=32768`,那么这个extent已经初始化的。如果该值`>32768`,这个extent还没有初始化\n\n32位的校验值可以存放在extent block的tail中,正好4个字节, 占满整个4k 块.\n\n## 1.4. read调用流程\n\n遗留问题:\n    上一节open的调用过程中, 关于inode的i_mapping, 并未发现分配内存的地方, buffer_head跟page_cache以及inode/dentry的关系是什么样的?\n\n带着这个问题, 我们继续看下read的调用流程\n```erlang\n+- SYSCALL_DEFINE3 <read, unsigned int, fd, char __user *, buf, size_t, count> #传入参数 fd, buf, count\n    \\ +- ksys_read(fd, buf, count)\n        \\ - fdget_pos(fd)  # \"__fget_light -> fcheck_files(files, fd) current->files->fdt->fd[fd]  #fd的flags 与引用计数有关, FDPUT_FPUT |  FDPUT_POS_UNLOCK(open带FMODE_ATOMIC_POS参数时保证原子性)                                                                        \n                             #[read分析](https://ithelp.ithome.com.tw/articles/10184552)\"\n        | - pos = file_pos_read <f.file>  #获取文件读位置的偏移量 要读/写的offset\n        | +- vfs_read <f.file, buf, count, &pos>\n        |    \\ - rw_verify_area(READ, file, pos, count)  #检测文件部分是否有冲突的强制锁\n        |    |+- __vfs_read(file, buf, count, pos)\n        |    |    \\ +- \"file->f_op->read\" -  \"file->f_op->read(file, buf, count, pos)\" #如果有注册了f_op中read方法, 使用read函数  file_operations ext4_file_operations\n        |    |    | +- \"file->f_op->read_iter\" - new_sync_read(file, buf, count, pos) # 注册了fop中的read_iter方法, 使用new_sync_read方法\n        |    |    |    \\ - init_sync_kiocb(&kiocb, filp) #ext4 只注册了 read_iter方法, 根据记录即将进行I/O操作的完成状态, 将file 的字段部分封装到了kiocb中\n        |    |    |    | - iov_iter_init(&iter, READ, &iov, 1, len) #来初始化iov_iter, kiocb表示io control block, 用来跟踪记录IO操作的完成状态, iov_iter iov_iter用来从用户和内核之间传递数据用 \n        |    |    |    |+- call_read_iter(filp, &kiocb, &iter)  # file->f_op->read_iter(kio, iter)\n        |    |            \\ +- ext4_file_read_iter <struct kiocb *iocb, struct iov_iter *iter>\n        |    |               \\ - ext4_forced_shutdown \"<EXT4_SB(file_inode(iocb->ki_filp)->i_sb))>\" #    检测下超级块相关flag中的EXT4_FLAGS_SHUTDOWN位, 如果是SHUTDOWN, 返回EIO 错误\n        |    |               | - IS_DAX \"(file_inode(iocb->ki_filp))\" # 判断内核是否配置了`CONFIG_FS_DAX`(Direct access),以及文件的打开方式是否是直接访问设备，这个直接影响访问是否绕过pagecache.\n                                                     #如果配置了CONFIG_FS_DAX ，且文件打开方式指定了直接访问，那么则调用`ext4_dax_read_iter` 函数。否则调用generic_file_read_iter函数. 需要inode支持直接访问\n             |               | +- generic_file_read_iter(iocb, iter) <filemap.c >\n             |                  \\ +- \"iocb->ki_flags & IOCB_DIRECT)\" \n             |                      \\ - filemap_write_and_wait_range(mapping, iocb->ki_pos, iocb->ki_pos + count - 1) #判断上次写操作是否需要 filemap_write_and_wait_range函数同步,确保读到的数据是最新的\n             |                      |+- \"mapping->a_ops->direct_IO(iocb, iter)\" # 直接访问有关, 直读模式, 如果目标文件定义了O_DIRECT标志，则直接跳过缓冲层，\n                                        #使用generic_file_direct_IO函数将读请求直接传递到块设备驱动层，没有定义则调用 generic_file_buffered_read, \n                                        # \"[ext4_read调用流程](https://zhuanlan.zhihu.com/p/36897326)\"\n             |                       | +- blkdev_direct_IO <struct kiocb *iocb, struct iov_iter *iter> \n             |                           \\ - __blkdev_direct_IO <struct kiocb *iocb, struct iov_iter *iter, int nr_pages> # bio request相关                                       \n             |                  | +- \"非直读模式\"- generic_file_buffered_read <iocb, iter, retval> # 经过page-cache, 循环在内存中寻找所读内容是否在内存中缓存, 使用offset index控制读取inode所属的所有pages\n             |                       \\ - find_get_page(mapping, index) #查找page在page tree中是否命中 index是文件位置指针转换的对应的page页面号 mapping是inode的i_mapping (index = *ppos >> PAGE_SHIFT)\n             |                       |+- \"page 未命中\" \n             |                           \\ +- page_cache_sync_readahead(mapping, ra, filp, index, last_index - index);  # 会从磁盘中读取页，并进行预读。\n                                                            #此外，还要判断页是否是最新，以免读到脏数据；\n                                                            #如果非最新则需要 调用address_space_operations中readpage函数进行读操作获取最新页, 读页的函数最后都会调用submit_bio\n             |                           | - find_get_page(mapping, index)               \n             |                           | +- \"page 未命中\"                     \n             |                               \\ +-\"内存中已经没有多余的page cache\"-  page = page_cache_alloc(mapping) # 分配page-cache\n             |                                   \\ - alloc_pages(gfp, 0) # \n             |                               | - add_to_page_cache_lru(page, mapping, index,) # 将page cache挂入lru, 同时将新分配的page-cache与mapping建立绑定关系, page的mapping节点指向mapping, \n                                                         #而mapping的绑定的tree里面挂入page                                                   \n             |                               | +- goto readpage\n                                                 \\ +- \"mapping->a_ops->readpage(filp, page)\" #调用adress_space的 readpage函数\n                                                     \\ +- blkdev_readpage # 没有定义的话, 使用默认的 def_blk_aops里的 blkdev_readpage 函数\n                                                         \\+- blkdev_readpage # 磁盘读操作, 加载进page cache, 通用 read_page函数\n                                                             \\+- block_read_full_page(page, blkdev_get_block) #Generic \"read page\" function for block devices \n                                                                     #that have the normal get_block functionality.\n                                                                  \\- head = create_page_buffers(page, inode, 0) #创建buffer_head\n                                                                  |- lblock = (i_size_read(inode)+blocksize-1) >> bbits; #inode 文件的最后一个扇区号(按inode 的i_size计算的), 即文件一共有多少个扇区\n                                                                  |- iblock = (sector_t)page->index << (PAGE_SHIFT - bbits); #inode 对应的page tree, page tree上挂着多个page, page上又挂着多个\n                                                                                     #bh(4k-512), 这个iblock的意思应该是获取当前正在访问的block在inode中的所有的块中的block扇区偏移号\n                                                                  |- get_block(inode, iblock, bh, 0); #调用传入的blkdev_get_block 取出block数据到bh中. iblock对应块号 bh->b_blocknr = iblock; \n                                                                                                      # b_bdev 块设备上 buffer 所关联的块的起始地址\n                                                                  |+- submit_bh(READ, bh); # 如果buffer_uptodate(bh) 如果缓冲区已经建立了与块的映射，但是其内容不是最新的则将缓冲区放置到一个临时的数组中,\n                                                                                  # 调用循环, for (i = 0; i < nr; i++) submit_bh(READ, bh) , 将所有需要读取的缓冲区转交给bio层, 开始读操作\n                                                                     \\ +- submit_bh(REQ_OP_READ, 0, bh);   submit_bh_wbc #根据bh page初始化bio, 可见buffer_head是一个page-bio的中转媒介\n                                                                         \\ - submit_bio(bio); #转发到bio, 开始读操作\n             |                                       | +-\"ext4 read page\"- ext4_readpage # 优化的文件系统层通常不会用默认的read_page函数, 因为磁盘数据有特殊的组织方式\n                                                         \\ - ext4_mpage_readpages(page->mapping, NULL, page, 1, false)                                                     \n                                                 | - PageUptodate  # 虽然页在缓存中了，但是其数据不一定是最新的，这里通过PageUptodate(page)来检查, 如果不是最新的, 则重新进行find page流程.\n                                                 | - goto page_ok - # 缓存的数据是最新的情况, 进入page_ok阶段\n                                                     \\ - flush_dcache_page(page) # 处理内存别名 [cachetlb](https://www.kernel.org/doc/Documentation/cachetlb.txt)\n                                                     | +-copy_page_to_iter(page, offset, nr, iter) #将内存中数据拷贝到用户空间 <iov_iter.c>\n                                                         \\ +- copy_page_to_iter_iovec(page, offset, bytes, i)\n                                                             \\ - iov = i->iov；buf = iov->iov_base; kaddr = kmap(page); from = kaddr + offset; copyout(buf, from, copy)； #从from中拷贝到buf下, 最终                         \n                                                                                 #传给iov_iter \n             | - fsnotify_access  #inotify 文件访问事件\n        | -  file_pos_write <f.file, pos> #写回offset, 便于下次读时指定offset lseek可以修改 close归0\n        | -  fdput_pos(f) # 引用计数 -1\n```\n\n\n![vfs_read](_v_images/20191224102023368_962125615.png)\n\n\n```c\nstruct bvec_iter {\n\tsector_t\t\tbi_sector;\t/* device address in 512 byte  sectors */\n\tunsigned int\t\tbi_size;\t/* residual I/O count */\n\tunsigned int\t\tbi_idx;\t\t/* current index into bvl_vec */\n\tunsigned int       bi_done;\t/* number of bytes completed */\n\tunsigned int       bi_bvec_done;\t/* number of bytes completed icurrent bvec */\n\tu64\t\t\tbi_dun;\t\t/* DUN setting for bio */\n};\n\nstruct bio {   // bio 结构直接处理 page 和地址空间，而不是 buffer\n\tstruct bio\t\t*bi_next;\t/* request queue link */\n\tstruct gendisk\t\t*bi_disk;\n\tunsigned int\t\tbi_opf;\t\t/* bottom bits req flags,\n\t\t\t\t\t\t * top bits REQ_OP. Use\n\t\t\t\t\t\t * accessors.\n\t\t\t\t\t\t */\n\tunsigned short\t\tbi_flags;\t/* status, etc and bvec pool number */\n\tunsigned short\t\tbi_ioprio;\n\tunsigned short\t\tbi_write_hint;\n\tblk_status_t\t\tbi_status;\n\tu8\t\t\tbi_partno;\n\n\t/* Number of segments in this BIO after\n\t * physical address coalescing is performed.\n\t */\n\tunsigned int\t\tbi_phys_segments;\n\n\t/*\n\t * To keep track of the max segment size, we account for the\n\t * sizes of the first and last mergeable segments in this bio.\n\t */\n\tunsigned int\t\tbi_seg_front_size;\n\tunsigned int\t\tbi_seg_back_size;\n\n\tstruct bvec_iter\tbi_iter;\n\n\tatomic_t\t\t__bi_remaining;\n\tbio_end_io_t\t\t*bi_end_io;\n\n\tvoid\t\t\t*bi_private;\n#ifdef CONFIG_BLK_CGROUP\n\t/*\n\t * Optional ioc and css associated with this bio.  Put on bio\n\t * release.  Read comment on top of bio_associate_current().\n\t */\n\tstruct io_context\t*bi_ioc;\n\tstruct cgroup_subsys_state *bi_css;\n\tstruct blkcg_gq\t\t*bi_blkg;\n\tstruct bio_issue\tbi_issue;\n#endif\n\tunion {\n#if defined(CONFIG_BLK_DEV_INTEGRITY)\n\t\tstruct bio_integrity_payload *bi_integrity; /* data integrity */\n#endif\n\t};\n#ifdef CONFIG_PFK\n\t/* Encryption key to use (NULL if none) */\n\tconst struct blk_encryption_key\t*bi_crypt_key;\n#endif\n#ifdef CONFIG_DM_DEFAULT_KEY\n\tint bi_crypt_skip;\n#endif\n\n\tunsigned short\t\tbi_vcnt;\t/* how many bio_vec's */\n\n\t/*\n\t * Everything starting with bi_max_vecs will be preserved by bio_reset()\n\t */\n\n\tunsigned short\t\tbi_max_vecs;\t/* max bvl_vecs we can hold */\n\n\tatomic_t\t\t__bi_cnt;\t/* pin count */\n\n\tstruct bio_vec\t\t*bi_io_vec;\t/* the actual vec list */\n\n\tstruct bio_set\t\t*bi_pool;\n#ifdef CONFIG_PFK\n\tstruct inode\t\t*bi_dio_inode;\n#endif\n\t/*\n\t * We can inline a number of vecs at the end of the bio, to avoid\n\t * double allocations for a small number of bio_vecs. This member\n\t * MUST obviously be kept at the very end of the bio.\n\t */\n\tstruct bio_vec\t\tbi_inline_vecs[0];\n};\n\nstruct buffer_head {   //buffer_head.h  表示在内存中的磁盘块\n\tunsigned long b_state;\t\t/* buffer state bitmap (see above) */ 这段 buffer 的状态\n\tstruct buffer_head *b_this_page;/* circular list of page's buffers */\n\tstruct page *b_page;\t\t/* the page this bh is mapped to */   指向的内存页即为 buffer 所映射的页\n\tsector_t b_blocknr;\t\t/* start block number */    b_bdev 块设备上 buffer 所关联的块的起始地址\n\tsize_t b_size;\t\t\t/* size of mapping */\n\tchar *b_data;\t\t\t/* pointer to data within the page */  b_data 为指向块的指针（在 b_page 中），并且长度为 b_size\n\tstruct block_device *b_bdev;   b_bdev 表示关联的块设备\n\tbh_end_io_t *b_end_io;\t\t/* I/O completion */\n \tvoid *b_private;\t\t/* reserved for b_end_io */\n\tstruct list_head b_assoc_buffers; /* associated with another mapping */\n\tstruct address_space *b_assoc_map;\t/* mapping this buffer is\n\t\t\t\t\t\t   associated with */\n\tatomic_t b_count;\t\t/* users using this buffer_head */ b_count 为 buffer 的引用计数 它通过 get_bh、put_bh 函数进行原子性的增加和减小\n};\n\nstruct page {   //mm_types.h\n\tunsigned long flags;\t\t/* Atomic flags, some possibly\n\t\t\t\t\t * updated asynchronously */\n\t/*\n\t * Five words (20/40 bytes) are available in this union.\n\t * WARNING: bit 0 of the first word is used for PageTail(). That\n\t * means the other users of this union MUST NOT use the bit to\n\t * avoid collision and false-positive PageTail().\n\t */\n\tunion {\n\t\tstruct {\t/* Page cache and anonymous pages */\n\t\t\t/**\n\t\t\t * @lru: Pageout list, eg. active_list protected by\n\t\t\t * zone_lru_lock.  Sometimes used as a generic list\n\t\t\t * by the page owner.\n\t\t\t */\n\t\t\tstruct list_head lru;\n\t\t\t/* See page-flags.h for PAGE_MAPPING_FLAGS */\n\t\t\tstruct address_space *mapping;\n\t\t\tpgoff_t index;\t\t/* Our offset within mapping. */\n\t\t\t/**\n\t\t\t * @private: Mapping-private opaque data.\n\t\t\t * Usually used for buffer_heads if PagePrivate.\n\t\t\t * Used for swp_entry_t if PageSwapCache.\n\t\t\t * Indicates order in the buddy system if PageBuddy.\n\t\t\t */\n\t\t\tunsigned long private;\n\t\t};\n\t\tstruct {\t/* slab, slob and slub */\n\t\t\tunion {\n\t\t\t\tstruct list_head slab_list;\t/* uses lru */\n\t\t\t\tstruct {\t/* Partial pages */\n\t\t\t\t\tstruct page *next;\n\t\t\t\t\tint pages;\t/* Nr of pages left */\n\t\t\t\t\tint pobjects;\t/* Approximate count */\n\t\t\t\t};\n\t\t\t};\n\t\t\tstruct kmem_cache *slab_cache; /* not slob */\n\t\t\t/* Double-word boundary */\n\t\t\tvoid *freelist;\t\t/* first free object */\n\t\t\tunion {\n\t\t\t\tvoid *s_mem;\t/* slab: first object */\n\t\t\t\tunsigned long counters;\t\t/* SLUB */\n\t\t\t\tstruct {\t\t\t/* SLUB */\n\t\t\t\t\tunsigned inuse:16;\n\t\t\t\t\tunsigned objects:15;\n\t\t\t\t\tunsigned frozen:1;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tstruct {\t/* Tail pages of compound page */\n\t\t\tunsigned long compound_head;\t/* Bit zero is set */\n\n\t\t\t/* First tail page only */\n\t\t\tunsigned char compound_dtor;\n\t\t\tunsigned char compound_order;\n\t\t\tatomic_t compound_mapcount;\n\t\t};\n\t\tstruct {\t/* Second tail page of compound page */\n\t\t\tunsigned long _compound_pad_1;\t/* compound_head */\n\t\t\tunsigned long _compound_pad_2;\n\t\t\tstruct list_head deferred_list;\n\t\t};\n\t\tstruct {\t/* Page table pages */\n\t\t\tunsigned long _pt_pad_1;\t/* compound_head */\n\t\t\tpgtable_t pmd_huge_pte; /* protected by page->ptl */\n\t\t\tunsigned long _pt_pad_2;\t/* mapping */\n\t\t\tunion {\n\t\t\t\tstruct mm_struct *pt_mm; /* x86 pgds only */\n\t\t\t\tatomic_t pt_frag_refcount; /* powerpc */\n\t\t\t};\n#if ALLOC_SPLIT_PTLOCKS\n\t\t\tspinlock_t *ptl;\n#else\n\t\t\tspinlock_t ptl;\n#endif\n\t\t};\n\t\tstruct {\t/* ZONE_DEVICE pages */\n\t\t\t/** @pgmap: Points to the hosting device page map. */\n\t\t\tstruct dev_pagemap *pgmap;\n\t\t\tunsigned long hmm_data;\n\t\t\tunsigned long _zd_pad_1;\t/* uses mapping */\n\t\t};\n\n\t\t/** @rcu_head: You can use this to free a page by RCU. */\n\t\tstruct rcu_head rcu_head;\n\t};\n\n\tunion {\t\t/* This union is 4 bytes in size. */\n\t\t/*\n\t\t * If the page can be mapped to userspace, encodes the number\n\t\t * of times this page is referenced by a page table.\n\t\t */\n\t\tatomic_t _mapcount;\n\n\t\t/*\n\t\t * If the page is neither PageSlab nor mappable to userspace,\n\t\t * the value stored here may help determine what this page\n\t\t * is used for.  See page-flags.h for a list of page types\n\t\t * which are currently stored here.\n\t\t */\n\t\tunsigned int page_type;\n\n\t\tunsigned int active;\t\t/* SLAB */\n\t\tint units;\t\t\t/* SLOB */\n\t};\n\n\t/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */\n\tatomic_t _refcount;\n};\n\nstruct address_space {\n\tstruct inode\t\t*host;\t\t/* owner: inode, block_device */\n\tstruct radix_tree_root\ti_pages;\t/* cached pages */\n\tatomic_t\t\ti_mmap_writable;/* count VM_SHARED mappings */\n\tstruct rb_root_cached\ti_mmap;\t\t/* tree of private and shared mappings */\n\tstruct rw_semaphore\ti_mmap_rwsem;\t/* protect tree, count, list */\n\t/* Protected by the i_pages lock */\n\tunsigned long\t\tnrpages;\t/* number of total pages */\n\t/* number of shadow or DAX exceptional entries */\n\tunsigned long\t\tnrexceptional;\n\tpgoff_t\t\t\twriteback_index;/* writeback starts here */\n\tconst struct address_space_operations *a_ops;\t/* methods */\n\tunsigned long\t\tflags;\t\t/* error bits */\n\tspinlock_t\t\tprivate_lock;\t/* for use by the address_space */\n\tgfp_t\t\t\tgfp_mask;\t/* implicit gfp mask for allocations */\n\tstruct list_head\tprivate_list;\t/* for use by the address_space */\n\tvoid\t\t\t*private_data;\t/* ditto */\n\terrseq_t\t\twb_err;\n} __attribute__((aligned(sizeof(long)))) __randomize_layout;\n\nstruct block_device {\n\tdev_t\t\t\tbd_dev;  /* not a kdev_t - it's a search key */\n\tint\t\t\tbd_openers;\n\tstruct inode *\t\tbd_inode;\t/* will die */\n\tstruct super_block *\tbd_super;\n\tstruct mutex\t\tbd_mutex;\t/* open/close mutex */\n\tvoid *\t\t\tbd_claiming;\n\tvoid *\t\t\tbd_holder;\n\tint\t\t\tbd_holders;\n\tbool\t\t\tbd_write_holder;\n#ifdef CONFIG_SYSFS\n\tstruct list_head\tbd_holder_disks;\n#endif\n\tstruct block_device *\tbd_contains;\n\tunsigned\t\tbd_block_size;\n\tu8\t\t\tbd_partno;\n\tstruct hd_struct *\tbd_part;\n\t/* number of times partitions within this device have been opened. */\n\tunsigned\t\tbd_part_count;\n\tint\t\t\tbd_invalidated;\n\tstruct gendisk *\tbd_disk;\n\tstruct request_queue *  bd_queue;\n\tstruct backing_dev_info *bd_bdi;\n\tstruct list_head\tbd_list;\n\t/*\n\t * Private data.  You must have bd_claim'ed the block_device\n\t * to use this.  NOTE:  bd_claim allows an owner to claim\n\t * the same device multiple times, the owner must take special\n\t * care to not mess up bd_private for that case.\n\t */\n\tunsigned long\t\tbd_private;\n\n\t/* The counter of freeze processes */\n\tint\t\t\tbd_fsfreeze_count;\n\t/* Mutex for freeze */\n\tstruct mutex\t\tbd_fsfreeze_mutex;\n} __randomize_layout;\n\nstruct kiocb {\n\tstruct file\t\t*ki_filp;\n\tloff_t\t\t\tki_pos;\n\tvoid (*ki_complete)(struct kiocb *iocb, long ret, long ret2);\n\tvoid\t\t\t*private;\n\tint\t\t\tki_flags;\n\tu16\t\t\tki_hint;\n\tu16\t\t\tki_ioprio; /* See linux/ioprio.h */\n};\nstruct bio_vec {\n\tstruct page\t   *bv_page;    块所在的页\n\tunsigned int\tbv_len;     块的长度\n\tunsigned int\tbv_offset;  块相对页的偏移量\n};\n```\n\n### 1.4.1. bio buffer_head page inode的关系\n\n```dot\ndigraph G {\n    rankdir=LR\n    node [shape=record];\n\n    buffer_head [label=\" <0> buffer_head|\n      ======|\n      <1>page* b_page|\n      <2> *b_this_page|\n      <3> *b_bdev |\n      <4> *b_end_io |\n      <5> *b_private |\n      <6> *b_assoc_map|\n      <7> b_blocknr |\n      <8> b_size |\n      ...\"]\n\n\n    bio [label=\" <0> bio|\n      ======|\n      <1> *bi_next|\n      <2> *bi_disk|\n      <3> *b_bdev |\n      <4> *b_end_io |\n      <5> *b_private |\n      <6> *b_assoc_map|\n      <7> *bi_crypt_key |\n      <8> *bi_io_vec |\n      <9> bvec_iter\tbi_iter |\n      <10> bi_vcnt|\n      <11> bi_idx |\n      ...\"]\n\n    page [label=\" <0> page|\n      ======|\n      <1> *mapping|\n      <2> list_head slab_list|\n      <3> page *next |\n      <4> pages |\n      <5> kmem_cache *   slab_cache |\n      <6> dev_pagemap * pgmap|\n      <7> rcu_head |\n      page_type |\n      active |\n      ...\"]\n\n\n    address_space[label=\"<0> address_space|\n      =======|\n      <1>  inode *host|\n      radix_tree_root\t i_pages|\n      nrpages|\n      <2> address_space_operations *a_ops |\n      ...\n      \"]\n\n    inode [label=\"<0> inode|\n      ======|\n      i_mode|\n      <1> i_mapping|\n      ...|\n      <2> i_sb\n      \"]\n\n    bio_vec [label=\"<0> bio_vec|\n      ======|\n      <1> *bv_page|\n      <2> bv_len|\n      <3> bv_offset |\n      ...\n      \"]\n\n    bvec_iter [label=\"<0> bvec_iter|\n      ======|\n      <1> bi_sector|\n      <2> bi_size|\n      <3> bi_done |\n      ...\n      \"]\n\n    inode:1 -> address_space:0\n    address_space:1 -> inode:0\n    page:1 -> address_space:0\n    page:1 -> inode:1\n    page:3 -> page:0 [style=dotted]\n    bio:1 -> bio:0 [style=dotted, color=blue]\n    buffer_head:1 -> page:0\n    bio:8 -> bio_vec:0 \n    bio_vec:1 -> page:0\n    bio:9 -> bvec_iter:0\n    bvec_iter:1 -> buffer_head:7 [style=dotted, color=blue]\n    bvec_iter:1 -> buffer_head:8 [style=dotted, color=blue]\n    bio:3 -> buffer_head:3 [style=dotted, color=green]\n    bio:5 -> buffer_head:0 [style=dotted color=blue]\n    bio:10 -> bio:8 \n    bio:11 -> bio:8 [headlabel=\"当前\\nio操作在\\n bi_io_vec\\n数组中的索引\" color=green]\n}\n```\n\nbuffer_head和bio关系在`submit_bh()`函数中可以充分体现：(也就是说只有在page中的块不连续时，buffer_head和bio才建立关系？)\n[Linux kernel学习-block层](https://zohead.com/archives/linux-kernel-learning-block-layer/)\n\n当块设备中的一个块（一般为扇区大小的整数倍，并不超过一个内存 page 的大小）通过读写等方式存放在内存中，一般被称为存在 buffer 中，每个` buffer` 和一个块相关联，它就表示在内存中的磁盘块。kernel 因此需要有相关的控制信息来表示块数据，每个块与一个描述符相关联，这个描述符就被称为` buffer head`，并用 struct buffer_head 来表示\n\n在 Linux 2.6 版本以前，`buffer_head` 是 kernel 中非常重要的数据结构，它曾经是 kernel 中 I/O 的基本单位（现在已经是 bio 结构）\n它曾被用于为一个块映射一个页，它被用于描述磁盘块到物理页的映射关系，所有的 block I/O 操作也包含在 buffer_head 中。但是这样也会引起比较大的问题：\n\n1.  buffer_head 结构过大（现在已经缩减了很多），用` buffer head` 来操作 I/O 数据太复杂，kernel 更喜欢根据 page 来工作（这样性能也更好）；\n2.  一个大的 buffer_head 常被用来描述单独的 buffer，**而且 buffer 还很可能比一个页还小，这样就会造成效率低下**；\n3.  buffer_head 只能描述一个 buffer，这样大块的 I/O 操作常被分散为很多个` buffer_head`，这样会增加额外占用的空间。\n因此 2.6 开始的 kernel （实际 2.5 测试版的 kernel 中已经开始引入）使用 `bio `结构直接处理 page 和地址空间，而不是 buffer。\n\nbio通过 bio_get、bio_put 宏可以对 bi_cnt 进行增加和减小操作\nbio 结构中最重要的是 `bi_vcnt、bi_idx、bi_io_vec` 等成员，bi_vcnt 为 bi_io_vec 所指向的 bio_vec 类型列表个数，bi_io_vec 表示指定的 block I/O 操作中的单独的段（如果你用过 readv 和 writev 函数那应该对这个比较熟悉），bi_idx 为当前在 bi_io_vec 数组中的索引，随着 block I/O 操作的进行，bi_idx 值被不断更新，kernel 提供 `bio_for_each_segment` 宏用于遍历 bio 中的 bio_vec。另外 kernel 中的 MD 软件 RAID 驱动也会使用 bi_idx 值来将一个 bio 请求分发到不同的磁盘设备上进行处理。\n\n每个 bio_vec 类型指向对应的 page，bv_page 表示它所在的页，bv_offset 为块相对于 page 的偏移量，bv_len 即为块的长度。\n\n#### 1.4.1.1. buffer_head 和 bio 总结：\n\n因此也可以看出 block I/O 请求是以 I/O 向量的形式进行提交和处理的。\nbio 相对 buffer_head 的好处有：\n- bio 可以更方便的使用高端内存，因为它只与 page 打交道，并不直接使用地址。\n- bio 可以表示 direct I/O（不经过 page cache，后面再详细描述）。\n- 对向量形式的 I/O（包括 sg I/O） 支持更好，防止 I/O 被打散。\n但是 buffer_head 还是需要的，它用于映射磁盘块到内存，因为 bio 中并没有包含 kernel 需要的 buffer 状态的成员以及一些其它信息。\n\n\n\n","tags":["Android","ext4"],"categories":["文件系统"]},{"title":"debugfs","url":"/2018/07/19/其他调研/debugfs/","content":"\n# 1. debugfs 简介\n\n对于ext2/ext3/ext4 系列文件系统, 可以使用debugfs来跟踪文件系统的相关信息\n\n首先看下常见的命令\n\n\n-   stats 查看文件系统super block的数据, 类似dumpe2fs的功能\n- icheck <block_number> 根据提供的block块号反查其inode号\n```shell\ndebugfs:  icheck 13440000\nBlock\tInode number\n13440000\t3358728\n```\n- ncheck <inode_number> 根据提供的inode 号反查其文件名, 文件名的信息存放在目录项的data block中\n```shell\ndebugfs:  ncheck 3358728\nInode\tPathname\n3358728\t/unencrypted/mode\n```\n- stat <file_path> 根据提供的文件路径查看文件的综合信息, 比在本地用提供的信息更多, 包括extents段也给出了\n\n```shell\nstat unencrypted\nInode: 3358728   Type: regular    Mode:  0600   Flags: 0x80000\nEXTENTS:\n(0):13435394\n```\n- bd <block_number> 打印块的内容\n```shell\ndebugfs:  bd 13435394\n# 目录下文件名和inode号的映射, 对应ext4_dir_entry_2结构\n0000  0140 3300 0c00 0102 2e00 0000 0200 0000  .@3.............\n0020  0c00 0202 2e2e 0000 0840 3300 0c00 0401  .........@3.....\n0040  6d6f 6465 0240 3300 0c00 0302 6b65 7900  mode.@3.....key.\n0060  0940 3300 d00f 0301 7265 6600 0000 0000  .@3.....ref.....\n0100  0000 0000 0000 0000 0000 0000 0000 0000  ................\n# ext4_dir_entry_2 entry总长在rec_len字段, 文件名长度在name_len字段. \n0840 3300   0x334008 = 3358728 正好是mode的inode号\n```\n![dir block](_v_images/20191226150953749_1295980059.png)\n-  filefrag 打印当前目录文件系统碎片情况\n```shell\ndebugfs:  filefrag\n./mode: 1 contiguous extents\n./key: 1 contiguous extents (dir)\n./ref: 1 contiguous extents\n```\n- testb    查询给定的块号是否已被使用 Test a block's in-use flag\n```shell\ndebugfs:  testb 20 20\nBlock 20 marked in use\nBlock 21 marked in use\nBlock 22 marked in use\nBlock 23 marked in use\nBlock 24 marked in use\nBlock 25 marked in use\nBlock 26 marked in use\nBlock 27 marked in use\nBlock 28 marked in use\nBlock 29 marked in use\nBlock 30 marked in use\nBlock 31 marked in use\nBlock 32 marked in use\nBlock 33 marked in use\nBlock 34 marked in use\nBlock 35 marked in use\nBlock 36 marked in use\nBlock 37 marked in use\nBlock 38 marked in use\nBlock 39 marked in use\n```\n- ffi 查询下一个可用的inode号是多少, 下一次创建文件时会使用该inode号\n- freefrag/e2freefrag 查询free extent的直方图\n```shell\nHISTOGRAM OF FREE EXTENT SIZES:\nExtent Size Range :  Free extents   Free Blocks  Percent\n    4K...    8K-  :            85            85    0.00%\n    8K...   16K-  :           119           301    0.00%\n   16K...   32K-  :           230          1218    0.01%\n   32K...   64K-  :           260          2814    0.02%\n   64K...  128K-  :           259          5864    0.05%\n  128K...  256K-  :           227         10680    0.09%\n  256K...  512K-  :           157         14647    0.12%\n  512K... 1024K-  :           114         20521    0.16%\n    1M...    2M-  :           119         44132    0.35%\n    2M...    4M-  :            51         35681    0.29%\n    4M...    8M-  :            59         84734    0.68%\n    8M...   16M-  :            12         33740    0.27%\n   16M...   32M-  :            24        144008    1.15%\n   32M...   64M-  :            14        162912    1.31%\n   64M...  128M-  :           360      11392885   91.32%\n```\n- id <file_path>.  dump inode号块\n```shell\n#id test\n0000  b681 0000 0200 0000 3e60 045e 3e60 045e  ........>`.^>`.^\n0020  3e60 045e 0000 0000 0000 0100 0800 0000  >`.^............\n0040  0000 0800 0100 0000 0af3 0100 0400 0000  ................\n0060  0000 0000 0000 0000 0100 0000 4d08 0000  ............M...\n0100  0000 0000 0000 0000 0000 0000 0000 0000  ................\n*\n0140  0000 0000 6752 620f 0000 0000 0000 0000  ....gRb.........\n0160  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0200  2000 0000 3458 ea2a 3458 ea2a 3458 ea2a   ...4X.*4X.*4X.*\n0220  3e60 045e 3458 ea2a 0000 0000 0000 0000  >`.^4X.*........\n0240  0000 02ea 0706 3c00 0000 0000 1f00 0000  ......<.........\n0260  0000 0000 7365 6c69 6e75 7800 0000 0000  ....selinux.....\n0300  0000 0000 0000 0000 0000 0000 0000 0000  ................\n*\n0340  753a 6f62 6a65 6374 5f72 3a73 7973 7465  u:object_r:syste\n0360  6d5f 6461 7461 5f66 696c 653a 7330 0000  m_data_file:s0..\n```\n\n\n\n\n\n\n\n","tags":["debugfs","ext4"],"categories":["debug"]},{"title":"Midi框架.md","url":"/2018/07/02/USB相关/Midi框架/","content":"\n# 1. 开启Midi function\n\n在Usb模式中切换为midi模式, 跟切换其他模式一样, 如切换mtp, ptp等\nsys.usb.config = midi\n\n收到底层的uevent, 在MSG_UPDATE_STATE中进行处理\n`updateUsbFunctions`扫描/sys/class/android_usb/android0/f_midi/alsa下文件, 调用UsbAlsaManager的setPeripheralMidiState接口添加音频设备.\n\n```java\n        private void updateMidiFunction() {\n            boolean enabled = (mCurrentFunctions & UsbManager.FUNCTION_MIDI) != 0;\n            if (enabled != mMidiEnabled) {\n                // 打开midi function\n                if (enabled) {\n                    Scanner scanner = null;\n                    try {\n                        // 扫描\"/sys/class/android_usb/android0/f_midi/alsa\"\n                        scanner = new Scanner(new File(MIDI_ALSA_PATH));\n                        // 打开midi模式后, 会生成alsa的声卡, 添加card device号\n                        mMidiCard = scanner.nextInt();\n                        mMidiDevice = scanner.nextInt();\n                    }\n                    finally {\n                        if (scanner != null) {\n                            scanner.close();\n                        }\n                    }\n                }\n                mMidiEnabled = enabled;\n            }\n1.            mUsbAlsaManager.setPeripheralMidiState(\n                    mMidiEnabled && mConfigured, mMidiCard, mMidiDevice);\n        }\n\n\n/* package */ void setPeripheralMidiState(boolean enabled, int card, int device) {\n        if (!mHasMidiFeature) {\n            return;\n        }\n\n        if (enabled && mPeripheralMidiDevice == null) {\n            Bundle properties = new Bundle();\n            Resources r = mContext.getResources();\n            properties.putString(MidiDeviceInfo.PROPERTY_NAME, r.getString(\n                    com.android.internal.R.string.usb_midi_peripheral_name));\n            properties.putString(MidiDeviceInfo.PROPERTY_MANUFACTURER, r.getString(\n                    com.android.internal.R.string.usb_midi_peripheral_manufacturer_name));\n            properties.putString(MidiDeviceInfo.PROPERTY_PRODUCT, r.getString(\n                    com.android.internal.R.string.usb_midi_peripheral_product_name));\n            properties.putInt(MidiDeviceInfo.PROPERTY_ALSA_CARD, card);\n            properties.putInt(MidiDeviceInfo.PROPERTY_ALSA_DEVICE, device);\n1.->// 创建UsbMidiDevice\n            mPeripheralMidiDevice = UsbMidiDevice.create(mContext, properties, card, device);\n        }\n   }\n\n    public static UsbMidiDevice create(Context context, Bundle properties, int card, int device) {\n        // FIXME - support devices with different number of input and output ports\n        int subDeviceCount = nativeGetSubdeviceCount(card, device);\n1.1 // 构造UsbMidiDevice\n        UsbMidiDevice midiDevice = new UsbMidiDevice(card, device, subDeviceCount);\n1.2 // 注册midi服务\n        if (!midiDevice.register(context, properties)) {\n        }\n        return midiDevice;\n    }\n\n1.1->// 创建 InputReceiverProxy  mInputPortReceivers 以\nsnprintf(path, sizeof(path), \"/dev/snd/controlC%d\", card);\n// 下的端口inputPort状态创建, 通信端\n\n    private UsbMidiDevice(int card, int device, int subdeviceCount) {\n        mAlsaCard = card;\n        mAlsaDevice = device;\n        mSubdeviceCount = subdeviceCount;\n\n        // FIXME - support devices with different number of input and output ports\n        int inputPortCount = subdeviceCount;\n\n        mInputPortReceivers = new InputReceiverProxy[inputPortCount];\n        for (int port = 0; port < inputPortCount; port++) {\n            mInputPortReceivers[port] = new InputReceiverProxy();\n        }\n    }\n1.2 ->// 启动MidiDeviceServer\n\n    private boolean register(Context context, Bundle properties) {\n        MidiManager midiManager = (MidiManager)context.getSystemService(Context.MIDI_SERVICE);\n        if (midiManager == null) {\n            Log.e(TAG, \"No MidiManager in UsbMidiDevice.create()\");\n            return false;\n        }\n1.2.1 // 构造MidiDeviceServer\n        mServer = midiManager.createDeviceServer(mInputPortReceivers, mSubdeviceCount,\n                null, null, properties, MidiDeviceInfo.TYPE_USB, mCallback);\n        if (mServer == null) {\n            return false;\n        }\n\n        return true;\n    }\n\n\n    public MidiDeviceServer createDeviceServer(MidiReceiver[] inputPortReceivers,\n            int numOutputPorts, String[] inputPortNames, String[] outputPortNames,\n            Bundle properties, int type, MidiDeviceServer.Callback callback) {\n        try {\n1.2.1.1 // 创建MidiDeviceServer\n            MidiDeviceServer server = new MidiDeviceServer(mService, inputPortReceivers,\n                    numOutputPorts, callback);\n1.2.1.2 // 调用MidiService的registerDeviceServer, add device\n            MidiDeviceInfo deviceInfo = mService.registerDeviceServer(server.getBinderInterface(),\n                    inputPortReceivers.length, numOutputPorts, inputPortNames, outputPortNames,\n                    properties, type);\n            if (deviceInfo == null) {\n                Log.e(TAG, \"registerVirtualDevice failed\");\n                return null;\n            }\n            return server;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n1.2.1.1 -> //初始化MidiDeviceServer, callback对象为MidiDeviceServer.Callback, 回调其onDeviceStatusChanged方法\n\n    // Constructor for MidiManager.createDeviceServer()\n/* package */ MidiDeviceServer(IMidiManager midiManager, MidiReceiver[] inputPortReceivers,\n            int numOutputPorts, Callback callback) {\n        mMidiManager = midiManager;\n        mInputPortReceivers = inputPortReceivers;\n        mInputPortCount = inputPortReceivers.length;\n        mOutputPortCount = numOutputPorts;\n        mCallback = callback;\n\n// 注意 mInputPortReceivers  mInputPortOutputPorts   mOutputPortDispatchers 这三个成员, 后面会用到数据传输\n        mInputPortOutputPorts = new MidiOutputPort[mInputPortCount];\n\n        mOutputPortDispatchers = new MidiDispatcher[numOutputPorts];\n        for (int i = 0; i < numOutputPorts; i++) {\n            mOutputPortDispatchers[i] = new MidiDispatcher(mInputPortFailureHandler);\n        }\n\n        mInputPortOpen = new boolean[mInputPortCount];\n        mOutputPortOpenCount = new int[numOutputPorts];\n\n        mGuard.open(\"close\");\n    }\n\n1.2.1.2-> // 注册DeviceServer,\n\n    public MidiDeviceInfo registerDeviceServer(IMidiDeviceServer server, int numInputPorts,\n            int numOutputPorts, String[] inputPortNames, String[] outputPortNames,\n            Bundle properties, int type) {\n        // 权限检查, 非系统用户不能添加\n        int uid = Binder.getCallingUid();\n        if (type == MidiDeviceInfo.TYPE_USB && uid != Process.SYSTEM_UID) {\n            throw new SecurityException(\"only system can create USB devices\");\n        } else if (type == MidiDeviceInfo.TYPE_BLUETOOTH && uid != mBluetoothServiceUid) {\n            throw new SecurityException(\"only MidiBluetoothService can create Bluetooth devices\");\n        }\n\n        //创建MidiDeviceInfo, 并设置到MidiDeviceServer中, 最后将device保存到MidiService的mDevicesByInfo中.\n        synchronized (mDevicesByInfo) {\n            return addDeviceLocked(type, numInputPorts, numOutputPorts, inputPortNames,\n                    outputPortNames, properties, server, null, false, uid);\n        }\n    }\n```\n\n上述步骤为切换USb function为midi后, 进行的初始化步骤, 其中最重要的是创建了UsbMidiDevice, 启动了UsbMidiServer服务.关联的驱动节点为\nalsa架构的节点`/dev/snd/controlC%d`\n\n# 2. App使用MidiService服务\n\n先来看一段demo code\n服务启动后, app需要通过`mMidiManager.registerDeviceCallback`注册回调. \n通过`MidiManager的getDevices`获取当前的UsbMidiDevice设备.\n\n```java\n    public MidiPortSelector(MidiManager midiManager, Activity activity,\n            int spinnerId, int type) {\n        //客户端为MidiManager, MidiManager的对端为MidiService, MidiService为一开机就加载的服务\n        mMidiManager = midiManager;\n        mActivity = activity;\n        mMidiManager.registerDeviceCallback(this,\n                new Handler(Looper.getMainLooper()));\n        // getDevice\n        MidiDeviceInfo[] infos = mMidiManager.getDevices();\n        for (MidiDeviceInfo info : infos) {\n            // 查到后, 保存到app的内部结构中, (此处关联到ui中)\n            onDeviceAdded(info);\n        }\n    }\n\n    public void onDeviceAdded(final MidiDeviceInfo info) {\n        int portCount = getInfoPortCount(info);\n        for (int i = 0; i < portCount; ++i) {\n            MidiPortWrapper wrapper = new MidiPortWrapper(info, mType, i);\n            mAdapter.add(wrapper);\n        }\n    }\n```\n\n通过`registerDeviceCallback`注册后, 在MidiService中保存, 这一步主要用到的数据成员都在1.2.1.2步骤中. 注册后, 会紧接着调用updateStickyDeviceStatus通知到客户端\nonDeviceStatusChanged\n\n```java\n    public void registerDeviceCallback(DeviceCallback callback, Handler handler) {\n        DeviceListener deviceListener = new DeviceListener(callback, handler);\n        try {\n            mService.registerListener(mToken, deviceListener);\n        }\n        // callback最终保存到mDeviceListeners中\n        mDeviceListeners.put(callback, deviceListener);\n    }\n```\n\napp端的回调, 更新ui等\n\n```java\n    public void onDeviceStatusChanged(final MidiDeviceStatus status) {\n        // If an input port becomes busy then remove it from the menu.\n        // If it becomes free then add it back to the menu.\n        if (mType == MidiDeviceInfo.PortInfo.TYPE_INPUT) {\n            MidiDeviceInfo info = status.getDeviceInfo();\n            Log.i(MidiConstants.TAG, \"MidiPortSelector.onDeviceStatusChanged status = \" + status\n                    + \", mType = \" + mType\n                    + \", activity = \" + mActivity.getPackageName()\n                    + \", info = \" + info);\n            // Look for transitions from free to busy.\n            int portCount = info.getInputPortCount();\n            for (int i = 0; i < portCount; ++i) {\n                MidiPortWrapper wrapper = new MidiPortWrapper(info, mType, i);\n                if (!wrapper.equals(mCurrentWrapper)) {\n                    if (status.isInputPortOpen(i)) { // busy?\n                        if (!mBusyPorts.contains(wrapper)) {\n                            // UI相关的变化\n                            // was free, now busy\n                            mBusyPorts.add(wrapper);\n                            mAdapter.remove(wrapper);\n                            mAdapter.notifyDataSetChanged();\n                        }\n                    } else {\n                        if (mBusyPorts.remove(wrapper)) {\n                            // was busy, now free\n                            mAdapter.add(wrapper);\n                            mAdapter.notifyDataSetChanged();\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n\n# 3. app打开midi的端口\n\n这个地方有个疑问, 关于mDestinationDeviceInfo是什么, input端口可以确认是手机打开midi function后创建的声卡对应的端口\n\n```java\n    private void setupMidi() {\n        // Setup MIDI\n        mMidiManager = (MidiManager) getSystemService(MIDI_SERVICE);\n\n        MidiDeviceInfo synthInfo = MidiTools.findDevice(mMidiManager, \"AndroidTest\",\n                \"SynthExample\");\n        int portIndex = 0;\n        // synthInfo作为mDestinationDeviceInfo\n        mPortSelector = new MidiOutputPortConnectionSelector(mMidiManager, this,\n                R.id.spinner_synth_sender, synthInfo, portIndex);\n        mPortSelector.setConnectedListener(new MyPortsConnectedListener());\n    }\n\n\n    @Override\n    public void onPortSelected(final MidiPortWrapper wrapper) {\n        close();\n        final MidiDeviceInfo info = wrapper.getDeviceInfo();\n        if (info != null) {\n            // 先调用openDevice 打开注册的端口, 打开后回调listener onDeviceOpened\n            // 在MidiService中添加DeviceConnection连接, 表示连接了client和device,保存到mDeviceConnections中\n            // 如果服务没有启动, device没有关联的UsbMidiServer, 需要先bindservice, 再关联到server上.\n            mMidiManager.openDevice(info, new MidiManager.OnDeviceOpenedListener() {\n                @Override\n                public void onDeviceOpened(MidiDevice device) {\n                    if (device == null) {\n                        Log.e(MidiConstants.TAG, \"could not open \" + info);\n                    } else {\n                        mOpenDevice = device;\n3.                        // 打开端口, 这个地方才真正和设备的端口交互, 需要用到device关联的MidiDeviceServer\n                        mInputPort = mOpenDevice.openInputPort(\n                                wrapper.getPortIndex());\n                        if (mInputPort == null) {\n                            Log.e(MidiConstants.TAG, \"could not open input port on \" + info);\n                        }\n                    }\n                }\n            }, null);\n            // Don't run the callback on the UI thread because openInputPort might take a while.\n        }\n    }\n```\n\n# 4. MidiDeviceServer打开端口\n\n```java\n3.-->// 打开端口\n    private final IMidiDeviceServer mServer = new IMidiDeviceServer.Stub() {\n\n        @Override\n        public FileDescriptor openInputPort(IBinder token, int portNumber) {\n            if (mDeviceInfo.isPrivate()) {\n                if (Binder.getCallingUid() != Process.myUid()) {\n                    throw new SecurityException(\"Can't access private device from different UID\");\n                }\n            }\n\n            if (portNumber < 0 || portNumber >= mInputPortCount) {\n                Log.e(TAG, \"portNumber out of range in openInputPort: \" + portNumber);\n                return null;\n            }\n\n            synchronized (mInputPortOutputPorts) {\n                if (mInputPortOutputPorts[portNumber] != null) {\n                    Log.d(TAG, \"port \" + portNumber + \" already open\");\n                    return null;\n                }\n\n                try {\n                    FileDescriptor[] pair = createSeqPacketSocketPair();\n                    MidiOutputPort outputPort = new MidiOutputPort(pair[0], portNumber);\n                    mInputPortOutputPorts[portNumber] = outputPort;\n                    // 加到MidiDispatcher.mReceivers中, 通过receiver处理数据\n                    outputPort.connect(mInputPortReceivers[portNumber]);\n\n                    InputPortClient client = new InputPortClient(token, outputPort);\n                    synchronized (mPortClients) {\n                        mPortClients.put(token, client);\n                    }\n                    // portOpen标记置位\n                    mInputPortOpen[portNumber] = true;    \n3.1 // 更新所有server绑定的device状态\n                    updateDeviceStatus();\n                    return pair[1];\n                } catch (IOException e) {\n                    Log.e(TAG, \"unable to create FileDescriptors in openInputPort\");\n                    return null;\n                }\n            }\n        }\n\n3.1-> // 更新所有server绑定的device状态\n    private void updateDeviceStatus() {\n        // clear calling identity, since we may be in a Binder call from one of our clients\n        long identityToken = Binder.clearCallingIdentity();\n\n        MidiDeviceStatus status = new MidiDeviceStatus(mDeviceInfo, mInputPortOpen,\n                mOutputPortOpenCount);\n        if (mCallback != null) {\n            // 在UsbMidiDevice中\n3.2            mCallback.onDeviceStatusChanged(this, status);\n        }\n        try {\n            mMidiManager.setDeviceStatus(mServer, status);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n    }\n\n\n3.2->// 需要关注下onDeviceStatusChanged, \n\n    private final MidiDeviceServer.Callback mCallback = new MidiDeviceServer.Callback() {\n\n        @Override\n        public void onDeviceStatusChanged(MidiDeviceServer server, MidiDeviceStatus status) {\n            MidiDeviceInfo deviceInfo = status.getDeviceInfo();\n            int inputPorts = deviceInfo.getInputPortCount();\n            int outputPorts = deviceInfo.getOutputPortCount();\n            boolean hasOpenPorts = false;\n\n            for (int i = 0; i < inputPorts; i++) {\n                // 已经在 3.1步骤前标记置为true了\n                if (status.isInputPortOpen(i)) {\n                    hasOpenPorts = true;\n                    break;\n                }\n            }\n\n            if (!hasOpenPorts) {\n                for (int i = 0; i < outputPorts; i++) {\n                    if (status.getOutputPortOpenCount(i) > 0) {\n                        hasOpenPorts = true;\n                        break;\n                    }\n                }\n            }\n\n            synchronized (mLock) {\n                if (hasOpenPorts && !mIsOpen) {\n  3.4           // 开port\n                   openLocked();\n                } else if (!hasOpenPorts && mIsOpen) {\n                    closeLocked();\n                }\n            }\n        }\n    };\n```\n\n# 5. 开启port\n\n```java\n    private boolean openLocked() {\n        // FIXME - support devices with different number of input and output ports\n        FileDescriptor[] fileDescriptors = nativeOpen(mAlsaCard, mAlsaDevice, mSubdeviceCount);\n        if (fileDescriptors == null) {\n            Log.e(TAG, \"nativeOpen failed\");\n            return false;\n        }\n\n        mFileDescriptors = fileDescriptors;\n        int inputStreamCount = fileDescriptors.length;\n        // last file descriptor returned from nativeOpen() is only used for unblocking Os.poll()\n        // in our input thread\n        int outputStreamCount = fileDescriptors.length - 1;\n\n        mPollFDs = new StructPollfd[inputStreamCount];\n        mInputStreams = new FileInputStream[inputStreamCount];\n        for (int i = 0; i < inputStreamCount; i++) {\n            FileDescriptor fd = fileDescriptors[i];\n            StructPollfd pollfd = new StructPollfd();\n            pollfd.fd = fd;\n            pollfd.events = (short)OsConstants.POLLIN;\n            mPollFDs[i] = pollfd;\n            mInputStreams[i] = new FileInputStream(fd);\n        }\n\n        mOutputStreams = new FileOutputStream[outputStreamCount];\n        mEventSchedulers = new MidiEventScheduler[outputStreamCount];\n        for (int i = 0; i < outputStreamCount; i++) {\n            mOutputStreams[i] = new FileOutputStream(fileDescriptors[i]);\n\n            MidiEventScheduler scheduler = new MidiEventScheduler();\n            mEventSchedulers[i] = scheduler;\n            mInputPortReceivers[i].setReceiver(scheduler.getReceiver());\n        }\n\n        final MidiReceiver[] outputReceivers = mServer.getOutputPortReceivers();\n\n        // Create input thread which will read from all output ports of the physical device\n        new Thread(\"UsbMidiDevice input thread\") {\n            @Override\n            public void run() {\n                byte[] buffer = new byte[BUFFER_SIZE];\n                try {\n                    while (true) {\n                        // Record time of event immediately after waking.\n                        long timestamp = System.nanoTime();\n                        synchronized (mLock) {\n                            if (!mIsOpen) break;\n\n                            // look for a readable FileDescriptor\n                            for (int index = 0; index < mPollFDs.length; index++) {\n                                StructPollfd pfd = mPollFDs[index];\n                                if ((pfd.revents & (OsConstants.POLLERR\n                                                            | OsConstants.POLLHUP)) != 0) {\n                                    break;\n                                } else if ((pfd.revents & OsConstants.POLLIN) != 0) {\n                                    // clear readable flag\n                                    pfd.revents = 0;\n\n                                    if (index == mInputStreams.length - 1) {\n                                        // last file descriptor is used only for unblocking Os.poll()\n                                        break;\n                                    }\n\n                                    int count = mInputStreams[index].read(buffer);\n                                    outputReceivers[index].send(buffer, 0, count, timestamp);\n                                }\n                            }\n                        }\n\n                        // wait until we have a readable port or we are signalled to close\n                        Os.poll(mPollFDs, -1 /* infinite timeout */);\n                     }\n                } catch (IOException e) {\n                    Log.d(TAG, \"reader thread exiting\");\n                } catch (ErrnoException e) {\n                    Log.d(TAG, \"reader thread exiting\");\n                }\n                Log.d(TAG, \"input thread exit\");\n            }\n        }.start();\n\n        // Create output thread for each input port of the physical device\n        for (int port = 0; port < outputStreamCount; port++) {\n            final MidiEventScheduler eventSchedulerF = mEventSchedulers[port];\n            final FileOutputStream outputStreamF = mOutputStreams[port];\n            final int portF = port;\n\n            new Thread(\"UsbMidiDevice output thread \" + port) {\n                @Override\n                public void run() {\n                    while (true) {\n                        MidiEvent event;\n                        try {\n                            event = (MidiEvent)eventSchedulerF.waitNextEvent();\n                        } catch (InterruptedException e) {\n                            // try again\n                            continue;\n                        }\n                        if (event == null) {\n                            break;\n                        }\n                        try {\n                            outputStreamF.write(event.data, 0, event.count);\n                        } catch (IOException e) {\n                            Log.e(TAG, \"write failed for port \" + portF);\n                        }\n                        eventSchedulerF.addEventToPool(event);\n                    }\n                    Log.d(TAG, \"output thread exit\");\n                }\n            }.start();\n        }\n\n        mIsOpen = true;\n        return true;\n    }\n```\n\n# 6. 图表类的关系图\n\n```puml\n@startuml\nabstract class MidiReceiver {\n    + void send(byte[] msg, int offset, int count)\n    + void onSend(byte[] msg, int offset, int count, long timestamp)\n}\nabstract class MidiSender{\n    + void onConnect(MidiReceiver receiver)\n    + void onDisconnect(MidiReceiver receiver)\n}\n\nMidiSender --o MidiDispatcher\nclass MidiDispatcher extends MidiReceiver {\n    MidiSender mSender\n    MidiReceiverFailureHandler mFailureHandler\n    List<MidiReceiver> <b>mReceivers\n    + MidiSender getSender()\n    + void <b>onSend(byte[] msg, int offset, int count, long timestamp)\n    +int getReceiverCount()\n}\nMidiReceiver --* MidiDispatcher\nMidiDispatcher --o MidiOutputPort\n\n\nclass MidiOutputPort <<<i><u>receiving data from a port on a MIDI device>> {\n    MidiDispatcher mDispatcher\n    + void <b>onConnect(MidiReceiver receiver)\n    + void onDisconnect(MidiReceiver receiver)\n    close()\n}\nMidiOutputPort -u|> MidiSender\nMidiReceiverFailureHandler -d-o MidiDispatcher\ninterface MidiReceiverFailureHandler{\n    void onReceiverFailure(MidiReceiver receiver, IOException failure)\n}\n\n\nclass MidiInputPort <<<i><u>for sending data to a port on a MIDI device>> {\n    FileDescriptor mFileDescriptor\n    +void onSend(byte[] msg, int offset, int count, long timestamp)\n    +void close()\n}\n\nMidiInputPort -|> MidiReceiver\nabstract class PortClient {\n void close()\n}\n\nclass InputPortClient extends PortClient\nclass OutputPortClient extends PortClient {\nMidiInputPort mInputPort\nvoid close()\nMidiInputPort getInputPort()\n}\n\nMidiInputPort -d-o OutputPortClient\n\nclass MidiDevice {\n    IMidiDeviceServer mDeviceServer\n    +MidiInputPort openInputPort(int portNumber)\n    +MidiOutputPort openOutputPort(int portNumber)\n}\n\n\n\nclass MidiDeviceService extends service {\n    MidiDeviceServer mServer\n    <b>onBind();\n}\nMidiDeviceServer--o MidiDeviceService\nclass MidiDeviceServer {\n    IMidiDeviceServer mServer\n    MidiReceiver[] mInputPortReceivers\n    MidiDispatcher[] mOutputPortDispatchers\n    MidiOutputPort[] mInputPortOutputPorts\n}\nclass MidiService {\n    MidiDeviceInfo[] getDevices\n    openDevice(IBinder token, MidiDeviceInfo deviceInfo,\n            IMidiDeviceOpenCallback callback)\n    notifyDeviceStatusChanged(Device device, MidiDeviceStatus status)\n}\n\n\nMidiService --* MidiManager\nMidiService --* MidiDeviceService\nclass MidiManager {\n    penDevice(MidiDeviceInfo deviceInfo, OnDeviceOpenedListener listener,)\n    createDeviceServer(MidiReceiver[] inputPortReceivers,...)\n}\n\nMidiInputPort --o MidiDevice\nMidiOutputPort --o MidiDevice\n@enduml\n```\n\n调用关系:\n在app端选择端口后, 会进行openDevice, MidiService会和MidiDeviceService进行bindService, bindService返回的binder对象为MidiDeviceService中实例化的MidiDeviceServer对象.\nopenDevice操作会导致bindService产生, 找到真正的管理类MidiDeviceServer对象.  该server对象会通过MidiDevice设备绑定.\nopenDevice成功后, 一般会调用MidiDevice的openInputPort打开相关的device端口.绑定类MidiInputPort, 关联的fd为MidiOutputPort的对端pair fd. 实际通信过程是MidiOutputPort通过connect过程与mInputPortReceivers进行直接通信的.关注MidiOutputPort的onConnect, 又经过类一层代理(mDispatcher), \nMidiOutputPort类循环接收MidiInputPort的对端(app)发送过来的消息, 又将消息转发给其连接的所有mInputPortReceivers. 为 InputReceiverProxy 类. \n这个类还是个代理类, 真实对象是通过类的setReceiver设置进去的,\n在打开端口时, 端口状态变化导致回调onDeviceStatusChanged方法, 进而调用到openLocked函数. 而设置进去的`receiver`实际上是MidiEventScheduler的receiver.\nMidiEventScheduler关联到\"UsbMidiDevice output thread\"线程上,  该线程在读取MidiEventScheduler上来的消息,再回写给device设备.\n因此app端可以操作pair[1] fd, 经过层层消息转发, 最终写到物理device设备上(对应/dev/snd...设备).\n\n而\"UsbMidiDevice input thread\"线程在持续读取真实设备上的消息, 转发给outputReceivers, 该receiver实际是MidiDeviceServer的mOutputPortDispatchers (MidiDispatcher)对象\n该对象也是一个代理, 消息是通过其内部的receiver转发的, 是通过connect过程设置的receiver.\n\n```java\n    MidiInputPort inputPort = new MidiInputPort(pair[0], portNumber);\n    MidiDispatcher dispatcher = mOutputPortDispatchers[portNumber];\n    synchronized (dispatcher) {\n        dispatcher.getSender().connect(inputPort);\n    }\n```\n\n这个直接关联到pair[0], 对应的pair[1]为app持有, 向该fd发送消息会转发到pair[1]上.即转发给app. app通过openInputPort拿到的fd负责读写, 转发给真实的device设备上.\n\n上述通信过程是基于openInputPort过程分析的, 不进行connectPort,  还有一个connectPort过程, 该过程允许指定特例化的UsbMidiService.\n可以参考`MidiSynthDeviceService `服务\n该通信过程读取真实device设备上的信息, 往回传给app的过程跟上面是一致的.\n不同的地方是app写数据, 把数据发给底层的过程.\n\n```java\n    @Override\n    public MidiReceiver[] onGetInputPortReceivers() {\n        return new MidiReceiver[]{mSynthEngine};\n    }\n```\n\n关键点在上面的函数, 返回了MidiReceiver的子类(SynthEngine)\n在构造MidiDeviceServer时, 传入了inputPortReceivers参数, 在openInputPort时, 会传入onGetInputPortReceivers的结果","tags":["Android","Midi"],"categories":["USB"]},{"title":"AndroidQ Usb差异对比","url":"/2018/07/01/USB相关/AndroidQ Usb差异对比/","content":"\n# 1. Device变化\n## 1.1. adb重构\n将adb调试相关的类抽出到新包`com.android.server.adb`中.\n- 包名变化\n`com.android.server.usb` ->`com.android.server.adb`\n- 目录文件变更\n- /frameworks/base/services/`usb/java/com/android/server/usb`  ->\n/frameworks/base/services/`core/java/com/android/server/adb`\n\nUsbDebuggingManager.java ->AdbDebuggingManager.java\n从UsbService中抽出AdbService.java\n\n原有的`UsbDebuggingManager`变为`AdbDebuggingManager`\n新增: `/frameworks/base/services/core/java/com/android/server/adb`\n\n1. AdbService --和UsbService并列, 由SystemServer启动\n2. 交互方式变更, 通过LocalService的AdbManagerInternal `registerTransport`注册adb监听.\n3. adbService中adb开关的变化通过contentProvider监听, 而其他服务通过registerTransport监听adbService中的adb开关变化回调.\n```java\n       LocalServices.getService(\n              AdbManagerInternal.class).registerTransport(new AdbTransport(this));\n```\n## 1.2. 新增adb权限\n```xml\n  <permission android:name=\"android.permission.MANAGE_DEBUGGING\"\n        android:protectionLevel=\"signature|privileged\" />\n    <!-- Permission to control Android Debug Bridge (ADB) -->\n    <uses-permission android:name=\"android.permission.MANAGE_DEBUGGING\" />\n```\nallowDebugging denyDebugging clearDebuggingKeys方法中会鉴权, 还是UsbDeviceManager中操作.\n\n## 1.3. port 重构\nExpose UsbPort and UsbPortStatus as system API\n>This is needed by making the setup wizard use only system-api?  只有usb settings包用到了,没看到其他app使用.\n\n新增文件\ncore/java/android/hardware/usb/ParcelableUsbPort.java\n\n\n## 1.4. usb gadget hal方式切换usb function避免reset\n注册监听`android.hardware.usb.gadget@1.0::IUsbGadget`服务的通知, 该服务启动时会回调`onRegistration`方法.\n服务启动后, 根据启动状态设置`preexisting`标记,  如果之前未启动过, 会重设usb默认function. 之前启动过, 则不设置.\n避免因service重启导致的usb属性被reset\n\n>This will overcome the occasional reset of the usb gadget hence the connection during phone bootup.\n\n```java\nprotected static final String GADGET_HAL_FQ_NAME =\n        \"android.hardware.usb.gadget@1.0::IUsbGadget\";\nboolean ret = IServiceManager.getService()\n        .registerForNotifications(GADGET_HAL_FQ_NAME, \"\", serviceNotification);\n```\n>平台并未采用usb gadget hal的方式. 采用的是传统的设置属性的方式\n\n\n# 2. Host端变化\n## 2.1. usbDeviceAdded 变化\nusbDeviceAdded增加增加新的黑名单, 下面的设备插入后不会上报usbDeviceAdded广播(`ACTION_USB_DEVICE_ATTACHED`), 不会上报状态(进行弹框等).\n- 只上报一个接口\n1.  对应未插入外设的空hub\n2. 为鼠标HID设备\n3. 键盘HID设备\n\n## 2.2. UsbSettingsManager重构\nUSB permission and resolve activity refactor.\nPure refactor of USB code for simple Arc logic injection.\n\n从UsbProfileGroupSettingsManager.java中抽出services/usb/java/com/android/server/usb/`UsbHandlerManager.java`\n专门负责resolve activity, 手机作为host使用时(通常是两台手机互联时),  解析弹出默认的activity行为.\n\n从UsbUserSettingsManager.java中抽出services/usb/java/com/android/server/usb/`UsbPermissionManager.java`专门负责权限管理.\nDevicePermission 和 AccessoryPermission(APP打开读取连接的device设备的权限和配件模式下打开配件的权限控制及授权框的管理等.)\n\n## 2.3. Require permission to read USB device's serial number\n新增文件\n- core/java/android/hardware/usb/IUsbSerialReader.aidl\n- services/usb/java/com/android/server/usb/UsbSerialReader.java\n\n对应连接的device设备或accessory(配件设备), 应用(`SDK>=Q`)包读取设备的SerialNumber时会先进行鉴权(DevicePermission和AccessoryPermission), 鉴权失败会报异常.\n\nSerial number的来源:\n- 对应accessory(配件设备)\n来自`/dev/usb_accessory`设备节点中读取的`ACCESSORY_GET_STRING_SERIAL`项\n- 对应Device设备\n对device文件进行`usb_device_control_transfer`通信`USB_REQ_GET_DESCRIPTOR`读出的serial_number字段.\n\napp访问方式:\nUsbDevice.getSerialNumber() --> IUsbSerialReader.getSerial\n\n\n\n\n","tags":["Android"],"categories":["USB"]},{"title":"文件系统初探","url":"/2018/07/01/存储相关/文件系统初探/","content":"\n# 1. VFS\n\nVFS以一组通用对象看待所有文件系统.\n- 超级块(SuperBlock)\n- 索引节点(inode)\n- 目录项(dentry)\n- 文件(struct file)\n\n## 1.1. 超级块 sb\n\n超级块代表一个已经安装的文件系统,存储该文件系统的有关信息(如类型\\大小\\状态等)\n>1. 对基于`磁盘`的文件系统, 该对象通常存放在磁盘的特定扇区上;\n>2. 对`非磁盘`的(如sysfs),现场创建保存在内存中\n\n```cpp\nstruct super_block {\n    //用于形成超级块链表\n\tstruct list_head\ts_list;\t\t/* Keep this first */\n    // 所属文件系统所在的设备描述符\n\tdev_t\t\t\ts_dev;\t\t/* search index; _not_ kdev_t */\n    // 一个块需要几个bit表示, 如块为1024字节, 该处就是10 块大小的就位数\n\tunsigned char\t\ts_blocksize_bits;\n    // 块大小, 以字节为单位.\n\tunsigned long\t\ts_blocksize;\n\tloff_t\t\t\ts_maxbytes;\t/* Max file size */\n    // 文件系统类型\n\tstruct file_system_type\t*s_type;\n    // 超级块操作\n\tconst struct super_operations\t*s_op;\n    // VFS磁盘限额处理方法\n\tconst struct dquot_operations\t*dq_op;\n    // 用于配置磁盘限额的方法,处理来自用户空间的请求\n\tconst struct quotactl_ops\t*s_qcop;\n    // 导出的方法, 从NFS服务器中共享目录又称导出目录\n\tconst struct export_operations *s_export_op;\n    // mount的flag,\n\tunsigned long\t\ts_flags;\n\tunsigned long\t\ts_iflags;\t/* internal SB_I_* flags */\n    // 魔数,用于识别文件系统\n\tunsigned long\t\ts_magic;\n    // 文件系统的根目录的目录项对象, 从文件系统的超级块可以读到任何一个文件, 前提是知道根目录在哪里. \n\tstruct dentry\t\t*s_root;\n    // 卸载所用的信号量\n\tstruct rw_semaphore\ts_umount;\n    // 引用计数\n\tint\t\t\ts_count;\n    // 引用计数\n\tatomic_t\t\ts_active;\n    // 指向超级块扩展属性结构的指针\n\tconst struct xattr_handler **s_xattr;\n    // 加密相关的操作\n\tconst struct fscrypt_operations\t*s_cop;\n    // 要导出的匿名目录项的列表    \n\tstruct hlist_bl_head\ts_anon;\t\t/* anonymous dentries for (nfs) exporting */\n\tstruct list_head\ts_mounts;\t/* list of mounts; _not_ for fs use */\n\tstruct block_device\t*s_bdev;\n\tstruct backing_dev_info *s_bdi;\n\tstruct mtd_info\t\t*s_mtd;\n\tstruct hlist_node\ts_instances;\n\tunsigned int\t\ts_quota_types;\t/* Bitmask of supported quota types */\n\tstruct quota_info\ts_dquot;\t/* Diskquota specific options */\n\n\tstruct sb_writers\ts_writers;\n\n\tchar s_id[32];\t\t\t\t/* Informational name */\n\tu8 s_uuid[16];\t\t\t\t/* UUID */\n\n\tvoid \t\t\t*s_fs_info;\t/* Filesystem private info */\n\tunsigned int\t\ts_max_links;\n\tfmode_t\t\t\ts_mode;\n\n\t/* Granularity of c/m/atime in ns.\n\t   Cannot be worse than a second */\n\tu32\t\t   s_time_gran;\n\n\t/*\n\t * The next field is for VFS *only*. No filesystems have any business\n\t * even looking at it. You had been warned.\n\t */\n\tstruct mutex s_vfs_rename_mutex;\t/* Kludge */\n\n\t/*\n\t * Filesystem subtype.  If non-empty the filesystem type field\n\t * in /proc/mounts will be \"type.subtype\"\n\t */\n\tchar *s_subtype;\n\n\t/*\n\t * Saved mount options for lazy filesystems using\n\t * generic_show_options()\n\t */\n\tchar __rcu *s_options;\n\tconst struct dentry_operations *s_d_op; /* default d_op for dentries */\n\n\t/*\n\t * Saved pool identifier for cleancache (-1 means none)\n\t */\n\tint cleancache_poolid;\n\n\tstruct shrinker s_shrink;\t/* per-sb shrinker handle */\n\n\t/* Number of inodes with nlink == 0 but still referenced */\n\tatomic_long_t s_remove_count;\n\n\t/* Being remounted read-only */\n\tint s_readonly_remount;\n\n\t/* AIO completions deferred from interrupt context */\n\tstruct workqueue_struct *s_dio_done_wq;\n\tstruct hlist_head s_pins;\n\n\t/*\n\t * Keep the lru lists last in the structure so they always sit on their\n\t * own individual cachelines.\n\t */\n\tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n\tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n\tstruct rcu_head\t\trcu;\n\tstruct work_struct\tdestroy_work;\n\n\tstruct mutex\t\ts_sync_lock;\t/* sync serialisation lock */\n\n\t/*\n\t * Indicates how deep in a filesystem stack this SB is\n\t */\n\tint s_stack_depth;\n\n\t/* s_inode_list_lock protects s_inodes */\n\tspinlock_t\t\ts_inode_list_lock ____cacheline_aligned_in_smp;\n\tstruct list_head\ts_inodes;\t/* all inodes */\n};\n```\n\n### 1.1.1. 超级块操作\n\n```cpp\nstruct super_operations {\n   \tstruct inode *(*alloc_inode)(struct super_block *sb);\n\tvoid (*destroy_inode)(struct inode *);\n   \tvoid (*dirty_inode) (struct inode *, int flags);\n\tint (*write_inode) (struct inode *, struct writeback_control *wbc);\n\tint (*drop_inode) (struct inode *);\n\tvoid (*evict_inode) (struct inode *);\n\tvoid (*put_super) (struct super_block *);\n\tint (*sync_fs)(struct super_block *sb, int wait);\n\tint (*freeze_super) (struct super_block *);\n\tint (*freeze_fs) (struct super_block *);\n\tint (*thaw_super) (struct super_block *);\n\tint (*unfreeze_fs) (struct super_block *);\n\tint (*statfs) (struct dentry *, struct kstatfs *);\n\tint (*remount_fs) (struct super_block *, int *, char *);\n\tint (*remount_fs2) (struct vfsmount *, struct super_block *, int *, char *);\n\tvoid *(*clone_mnt_data) (void *);\n\tvoid (*copy_mnt_data) (void *, void *);\n\tvoid (*umount_begin) (struct super_block *);\n\n\tint (*show_options)(struct seq_file *, struct dentry *);\n\tint (*show_options2)(struct vfsmount *,struct seq_file *, struct dentry *);\n\tint (*show_devname)(struct seq_file *, struct dentry *);\n\tint (*show_path)(struct seq_file *, struct dentry *);\n\tint (*show_stats)(struct seq_file *, struct dentry *);\n#ifdef CONFIG_QUOTA\n\tssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n\tssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n\tstruct dquot **(*get_dquots)(struct inode *);\n#endif\n\tint (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);\n\tlong (*nr_cached_objects)(struct super_block *,\n\t\t\t\t  struct shrink_control *);\n\tlong (*free_cached_objects)(struct super_block *,\n\t\t\t\t    struct shrink_control *);\n};\n```\n\n## 1.2. 索引节点 inode\n\n用于存放内核在操作文件或目录时需要的全部信息.\n具体文件系统的索引节点存储在磁盘上,使用时将其读入内存填充VFS的索引节点,之后VFS inode的任何修改回写到磁盘上.\n\n```cpp\nstruct inode {\n\tumode_t\t\t\ti_mode;\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid;\n\tkgid_t\t\t\ti_gid;\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t/* Stat data, not accessed from path walking */\n\tunsigned long\t\ti_ino;\n\t/*\n\t * Filesystems may only read i_nlink directly.  They shall use the\n\t * following functions for modification:\n\t *\n\t *    (set|clear|inc|drop)_nlink\n\t *    inode_(inc|dec)_link_count\n\t */\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev;\n\tloff_t\t\t\ti_size;\n\tstruct timespec\t\ti_atime;\n\tstruct timespec\t\ti_mtime;\n\tstruct timespec\t\ti_ctime;\n\tspinlock_t\t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */\n\tunsigned short          i_bytes;\n\tunsigned int\t\ti_blkbits;\n\tblkcnt_t\t\ti_blocks;\n\n#ifdef __NEED_I_SIZE_ORDERED\n\tseqcount_t\t\ti_size_seqcount;\n#endif\n\n\t/* Misc */\n\tunsigned long\t\ti_state;\n\tstruct mutex\t\ti_mutex;\n\n\tunsigned long\t\tdirtied_when;\t/* jiffies of first dirtying */\n\tunsigned long\t\tdirtied_time_when;\n\n\tstruct hlist_node\ti_hash;\n\tstruct list_head\ti_io_list;\t/* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback\t*i_wb;\t\t/* the associated cgroup wb */\n\n\t/* foreign inode detection, see wbc_detach_inode() */\n\tint\t\t\ti_wb_frn_winner;\n\tu16\t\t\ti_wb_frn_avg_time;\n\tu16\t\t\ti_wb_frn_history;\n#endif\n\tstruct list_head\ti_lru;\t\t/* inode LRU list */\n\tstruct list_head\ti_sb_list;\n\tunion {\n\t\tstruct hlist_head\ti_dentry;\n\t\tstruct rcu_head\t\ti_rcu;\n\t};\n\tu64\t\t\ti_version;\n\tatomic_t\t\ti_count;\n\tatomic_t\t\ti_dio_count;\n\tatomic_t\t\ti_writecount;\n#ifdef CONFIG_IMA\n\tatomic_t\t\ti_readcount; /* struct files open RO */\n#endif\n\tconst struct file_operations\t*i_fop;\t/* former ->i_op->default_file_ops */\n\tstruct file_lock_context\t*i_flctx;\n\tstruct address_space\ti_data;\n\tstruct list_head\ti_devices;\n\tunion {\n\t\tstruct pipe_inode_info\t*i_pipe;\n\t\tstruct block_device\t*i_bdev;\n\t\tstruct cdev\t\t*i_cdev;\n\t\tchar\t\t\t*i_link;\n\t};\n\n\t__u32\t\t\ti_generation;\n\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ti_fsnotify_mask; /* all events this inode cares about */\n\tstruct hlist_head\ti_fsnotify_marks;\n#endif\n\n#if IS_ENABLED(CONFIG_FS_ENCRYPTION)\n\tstruct fscrypt_info\t*i_crypt_info;\n#endif\n\tvoid\t\t\t*i_private; /* fs or device private pointer */\n};\n```\n\n4个管理inode的链表:\n\n1. inode_unused, 目前还没使用的linode\n2. inode_in_use,目前正在使用的inode\n3. 超级块的s_dirty字段,将所有脏inode链接\n4. inode_in_use使用效率不高,  将使用中的inode计算hash值, hash值可能重复, i_hash将同样hash值的对个inode链接\n\n### 1.2.1. 索引节点操作\n\n```cpp\nstruct inode_operations {\n    // 指定目录查找\n\tstruct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);\n\tconst char * (*follow_link) (struct dentry *, void **);\n\tint (*permission) (struct inode *, int);\n\tint (*permission2) (struct vfsmount *, struct inode *, int);\n\tstruct posix_acl * (*get_acl)(struct inode *, int);\n\n\tint (*readlink) (struct dentry *, char __user *,int);\n\tvoid (*put_link) (struct inode *, void *);\n\n\tint (*create) (struct inode *,struct dentry *, umode_t, bool);\n\tint (*link) (struct dentry *,struct inode *,struct dentry *);\n\tint (*unlink) (struct inode *,struct dentry *);\n\tint (*symlink) (struct inode *,struct dentry *,const char *);\n\tint (*mkdir) (struct inode *,struct dentry *,umode_t);\n\tint (*rmdir) (struct inode *,struct dentry *);\n\tint (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);\n\tint (*rename) (struct inode *, struct dentry *,\n\t\t\tstruct inode *, struct dentry *);\n\tint (*rename2) (struct inode *, struct dentry *,\n\t\t\tstruct inode *, struct dentry *, unsigned int);\n\tint (*setattr) (struct dentry *, struct iattr *);\n\tint (*setattr2) (struct vfsmount *, struct dentry *, struct iattr *);\n\tint (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);\n    /*为指定的文件设置特定的扩展属性, (xattr)允许用户将文件与未被文件系统解释的信息关联,与之对应的是经过文件系统严格定义的正规文件属性,如文件创建和修改的事件等. 如文件作者/编码等\n    */\n\tint (*setxattr) (struct dentry *, const char *,const void *,size_t,int);\n\tssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);\n\tssize_t (*listxattr) (struct dentry *, char *, size_t);\n\tint (*removexattr) (struct dentry *, const char *);\n\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,\n\t\t      u64 len);\n\tint (*update_time)(struct inode *, struct timespec *, int);\n\tint (*atomic_open)(struct inode *, struct dentry *,\n\t\t\t   struct file *, unsigned open_flag,\n\t\t\t   umode_t create_mode, int *opened);\n\tint (*tmpfile) (struct inode *, struct dentry *, umode_t);\n\tint (*set_acl)(struct inode *, struct posix_acl *, int);\n} ____cacheline_aligned;\n```\n\n## 1.3. 目录项(dentry)\n\n为方便查找操作, 引入目录. 每个目录项代表路径的一部分.\n\n/home/test/test.c   (test.c也是一个目录项)\n\n目录项将路径中的每个部分与其对应的inode相连,沿着路径各部分的目录项进行搜索,最终找到目标文件的inode.\n\n> 与超级块和索引节点不同, 目录项在磁盘上没有对应描述. 只存在于内存中(目录页缓存),仅仅为提高系统的性能存在.\n\n```cpp\nstruct dentry {\n\t/* RCU lookup touched fields */\n\tunsigned int d_flags;\t\t/* protected by d_lock */\n\tseqcount_t d_seq;\t\t/* per dentry seqlock */\n    // dentry的链表, 链接所用的dentry. 保存parent指针和next指针.\n\tstruct hlist_bl_node d_hash;\t/* lookup hash list */\n    // 父目录项\n\tstruct dentry *d_parent;\t/* parent directory */\n    // 目录项名字\n\tstruct qstr d_name;\n    // 与目录关联的inode\n\tstruct inode *d_inode;\t\t/* Where the name belongs to - NULL is\n\t\t\t\t\t * negative */\n\tunsigned char d_iname[DNAME_INLINE_LEN];\t/* small names */\n\n\t/* Ref lookup also touches following */\n\tstruct lockref d_lockref;\t/* per-dentry lock and refcount */\n    // dentry 操作\n\tconst struct dentry_operations *d_op;\n    // 所属文件系统的超级块\n\tstruct super_block *d_sb;\t/* The root of the dentry tree */\n\tunsigned long d_time;\t\t/* used by d_revalidate */\n\tvoid *d_fsdata;\t\t\t/* fs-specific data */\n    // 最近未使用的目录项链表\n\tstruct list_head d_lru;\t\t/* LRU list */\n    // 通过该字段加入到其父目录的 d_subdirs链表中\n\tstruct list_head d_child;\t/* child of parent list */\n    // 其子目录链表的头\n\tstruct list_head d_subdirs;\t/* our children */\n\t/*\n\t * d_alias and d_rcu can share memory\n\t */\n\tunion {\n        // 一个inode可能对应多个dentry, 与该inode相关连的所有目录通过dentry的d_alias挂入inode的i_dentry链表中\n\t\tstruct hlist_node d_alias;\t/* inode alias list */\n\t \tstruct rcu_head d_rcu;\n\t} d_u;\n};\n```\n\n### 1.3.1. 几点小结\n\n- 每个dentry通过`d_hash`字段挂入dentry_hashtable中的某个链表里. 通过该链表管理所有目录.目录一经创建, 就会加入到该链表里\n- 引用计数为0的dentry通过d_lru挂入链表dentry_unsed,等待释放或重新使用\n- 每个dentry通过d_inode与一个inode关联,多个dentry可以与一个inode关联\n- 指向同一个inode的dentry通过d_alias字段链接在一起,都挂入inode的i_dentry链表中\n- 每个dentry通过d_parent字段指向其parent目录的dentry,通过d_child跟同一目录中其他文件的dentry链接在一起,都挂在parent目录dentry的d_subdirs链表中\n- 每个d_entry通过d_sb指向所属文件系统的超级块\n\n### 1.3.2. dentry的状态\n\n- 空闲状态(free): 不包含有效信息, 且未被VFS使用\n- 未使用状态(unused): d_inode字段仍指向关联的inode, 但引用计数为0, 未被VFS使用, 没有进程访问. 在内存回收时可能被丢弃\n- 使用状态(in use) 存在使用进程, 关联inode. 不会被丢弃\n- 负状态(negative) 没有关联inode, 由于其关联的inode被删除或解析一个不存在的文件创建,留作使用\n\n### 1.3.3. 目录项操作(dentry_oprations)\n\n```cpp\nstruct dentry_operations {\n    // 判断dentry是否有效.\n\tint (*d_revalidate)(struct dentry *, unsigned int);\n\tint (*d_weak_revalidate)(struct dentry *, unsigned int);\n\tint (*d_hash)(const struct dentry *, struct qstr *);\n\tint (*d_compare)(const struct dentry *, const struct dentry *,\n\t\t\tunsigned int, const char *, const struct qstr *);\n\tint (*d_delete)(const struct dentry *);\n\tvoid (*d_release)(struct dentry *);\n\tvoid (*d_prune)(struct dentry *);\n\tvoid (*d_iput)(struct dentry *, struct inode *);\n\tchar *(*d_dname)(struct dentry *, char *, int);\n\tstruct vfsmount *(*d_automount)(struct path *);\n\tint (*d_manage)(struct dentry *, bool);\n\tstruct inode *(*d_select_inode)(struct dentry *, unsigned);\n\tstruct dentry *(*d_real)(struct dentry *, struct inode *);\n\tvoid (*d_canonical_path)(const struct path *, struct path *);\n} ____cacheline_aligned;\n```\n\n## 1.4. 文件对象\n\n文件描述进程已经打开的文件, 进程直接处理的是文件, 而不是其他三个.因多个进程可以打开和操作同一个文件, 所以同一个文件可能存在多个对应的**文件对象**.但对应的**inode**和**dentry**是唯一的.\n\n```cpp\nstruct file {\n\tunion {\n        // 文件系统的所有已打开文件通过该字段挂入文件系统的超级块(sb)的s_files链表中\n\t\tstruct llist_node\tfu_llist;\n\t\tstruct rcu_head \tfu_rcuhead;\n\t} f_u;\n\tstruct path\t\tf_path;\n    // 关联的inode\n\tstruct inode\t\t*f_inode;\t/* cached value */\n    // 文件操作\n\tconst struct file_operations\t*f_op;\n\n\t/*\n\t * Protects f_ep_links, f_flags.\n\t * Must not be taken from IRQ context.\n\t */\n\tspinlock_t\t\tf_lock;\n\tatomic_long_t\t\tf_count;\n    // 打开文件时指定的参数\n\tunsigned int \t\tf_flags;\n\tfmode_t\t\t\tf_mode;\n\tstruct mutex\t\tf_pos_lock;\n    // 目前文件的offset,每次读写从该位置开始\n\tloff_t\t\t\tf_pos;\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n    // 文件预读状态\n\tstruct file_ra_state\tf_ra;\n    // fpos改变时, f_version ++\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t/* needed for tty driver, and maybe others */\n    // 供文件系统或驱动程序使用的私有数据\n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_EPOLL\n\t/* Used by fs/eventpoll.c to link all the hooks to this file */\n\tstruct list_head\tf_ep_links;\n\tstruct list_head\tf_tfile_llink;\n#endif /* #ifdef CONFIG_EPOLL */\n    // 查看inode的i_mapping字段\n\tstruct address_space\t*f_mapping;\n} __attribute__((aligned(4)));\t/* lest something weird decides that 2 is OK */\n```\n\n内核从磁盘上将inode装入内存时, 与该inode相关的文件操作存放在i_fop字段,之后进程打开这个文件时,VFS通过inode中的i_fop初始化新文件对应的f_op字段.\n\n### 1.4.1. 文件操作(file_operations f_op)\n\n```cpp\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n    // 指定的文件映射到指定的地址空间, 由mmap()调用\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tint (*open) (struct inode *, struct file *);\n    // 当调用close时会被调用 根据具体文件系统而定\n\tint (*flush) (struct file *, fl_owner_t id);\n    // 引用计数变为0时, 调用释放文件对象\n\tint (*release) (struct inode *, struct file *);\n    // 将文件所有被缓存的数据写入磁盘, 由系统调用fsync()和fdatasync()调用, fdatasync()只会影响文件的数据部分,fsync会同步更新文件的属性\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*aio_fsync) (struct kiocb *, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n    // 从一个pipe移动数据到一个文件, 由系统调用splice()时调用\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n        // 从一个文件移动数据到一个pipe, 由系统调用splice()时调用\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n    // 为一个已打开的文件设置一个租约, 提供当一个进程试图打开或读写文件内容时,有文件租约的进程会被通知的机制\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n};\n```\n\n## 1.5. 文件系统相关的数据结构\n\n### 1.5.1. file_system_type(具体文件系统类型)\n\nex: ext2_fs_type ext3_fs_type vfat_fs_type\n\nLinux 支持的文件系统, 都会有且只有一个file_system_type结构, 每当有一个文件系统被安装时,会有一个`vfsmount`结构被创建, 代表该文件系统的一个安装实例, 也代表了该文件系统的一个安装点\n\n```cpp\nstruct file_system_type {\n\tconst char *name;\n\tint fs_flags;\n#define FS_REQUIRES_DEV\t\t1 \n#define FS_BINARY_MOUNTDATA\t2\n#define FS_HAS_SUBTYPE\t\t4\n#define FS_USERNS_MOUNT\t\t8\t/* Can be mounted by userns root */\n#define FS_USERNS_DEV_MOUNT\t16 /* A userns mount does not imply MNT_NODEV */\n#define FS_USERNS_VISIBLE\t32\t/* FS must already be visible */\n#define FS_RENAME_DOES_D_MOVE\t32768\t/* FS will handle d_move() during rename() internally. */\n\tstruct dentry *(*mount) (struct file_system_type *, int,\n\t\t       const char *, void *);\n\tstruct dentry *(*mount2) (struct vfsmount *, struct file_system_type *, int,\n\t\t\t       const char *, void *);\n\tvoid *(*alloc_mnt_data) (void);\n\tvoid (*kill_sb) (struct super_block *);\n\tstruct module *owner;\n    // 不同类型的文件系统通过next字段链接形成链表\n\tstruct file_system_type * next;\n    // 同一种文件系统的超级块通过s_instances字段链接到一起, 挂入fs_supers链表中.\n\tstruct hlist_head fs_supers;\n\n\tstruct lock_class_key s_lock_key;\n\tstruct lock_class_key s_umount_key;\n\tstruct lock_class_key s_vfs_rename_key;\n\tstruct lock_class_key s_writers_key[SB_FREEZE_LEVELS];\n\n\tstruct lock_class_key i_lock_key;\n\tstruct lock_class_key i_mutex_key;\n\tstruct lock_class_key i_mutex_dir_key;\n};\n```\n\n### 1.5.2. vfsmount实例\n\n```cpp\nstruct vfsmount {\n    // 该文件系统根目录的dentry, 与mountpoint一般是相同的.\n\tstruct dentry *mnt_root;\t/* root of the mounted tree */\n    // 指向安装文件系统的超级块\n\tstruct super_block *mnt_sb;\t/* pointer to superblock */\n    // 挂载参数\n\tint mnt_flags;\n\tvoid *data;\n};\n```\n\n### 1.5.3. 与进程相关的数据结构\n\n每个进程都有自己的根目录和当前工作目录,内核使用了struct fs_struct记录这些信息, 进程描述符的fs字段指向该进程的fs_struct结构\n\n```cpp\nstruct fs_struct {\n\tint users;\n\tspinlock_t lock;\n\tseqcount_t seq;\n    // 打开文件时默认设置的文件访问权限\n\tint umask;\n\tint in_exec;\n    // pwd指向当前工作目录\n\tstruct path root, pwd;\n};\n```\n\n除了根目录/当前工作目录, 进程还需要记录自己打开的文件. 进程已经打开的文件用struct files_struct来记录, `进程描述符`的files字段指向该进程的files_struct结构.\n\n```cpp\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n\tatomic_t count;\n\tbool resize_in_progress;\n\twait_queue_head_t resize_wait;\n// fdtab是初始的文件描述表, fdt最初指向fdtab\n\tstruct fdtable __rcu *fdt;\n\tstruct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n\tspinlock_t file_lock ____cacheline_aligned_in_smp;\n    // 最近关闭的文件描述符中最小的下一个可用的文件描述符\n\tint next_fd;\n    // 执行exec时需要关闭的文件描述符\n\tunsigned long close_on_exec_init[1];\n    // 当前已经打开的文件描述符\n\tunsigned long open_fds_init[1];\n\tunsigned long full_fds_bits_init[1];\n    // 文件对象的初始化数组\n\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n```\n\n文件描述符fd等于文件对象在数组fd_array中的下标. 通过fd_array中的前3个分别是stdin, stdout,stderr 标准描述符.\n\n内核将fd/max_fds以及其他字段组织在一起, 成了fdtable,称为文件描述符表. 当进程打开的文件数目超过32个时,内核调用expand_fdtable()生成一个新的文件描述表, 将它的地址指向fdt\n\n```cpp\nstruct fdtable {\n    // 文件对象的最大数目\n\tunsigned int max_fds;\n    // 指向当前的文件对象数组, 初始指向fd_array\n\tstruct file __rcu **fd;      /* current fd array */\n\tunsigned long *close_on_exec;\n    // 当前已经打开的文件描述符, 初始指向open_fds_init\n\tunsigned long *open_fds;\n\tunsigned long *full_fds_bits;\n\tstruct rcu_head rcu;\n};\n```\n\n### 1.5.4. 路径查找辅助结构\n\nnameidata用于在路径查找的过程中记录中间信息和查找结果\n\n```cpp\nstruct nameidata {\n    // 所解析的最后一个路径的对象\n\tstruct path\tpath;\n    // 表示当前目录项的名称\n\tstruct qstr\tlast;\n    // 根目录\n\tstruct path\troot;\n    // 父目录关联的inode\n\tstruct inode\t*inode; /* path.dentry.d_inode */\n\tunsigned int\tflags;\n\tunsigned\tseq, m_seq;\n    // 路径最后一个分量的类型, 可以去LAST_NORM/LAST_DOT/LAST_DOTDOT/LAST_BIND\n\tint\t\tlast_type;\n    // 符号链接嵌套的深度\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tvoid *cookie;\n\t\tconst char *name;\n\t\tstruct inode *inode;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n};\n```\n\n## 1.6. VFS的缓存机制\n\n内核启动时,通过vfs_caches_init()创建inode/dentry/file文件对象/vfsmount缓存提高操作系统性能\n\n### 1.6.1. inode缓存\n\n- 从内存中申请或释放一个inode对象,必须通过kmem_cache_alloc和kmem_cache_free进行\n- 将inode对象插入不同的链表, 具有相同hash值的inode对象在同一链表中. 当访问一个inode时,先在缓存hash表中查询,如果查到,引用计数+1, 如没有, 需要找到一个空闲的inode, 从底层的文件系统中读取信息填充该inode, 插入到对应的链表中.\n\n### 1.6.2. 目录项缓存\n\n执行文件操作时, VFS需要解析文件路径中的每一部分, 并为之构造目录项对象, 重复访问同一文件时或包含相同的目录项时,直接从内存中获得对应的dentry\n\n目录项的缓存机制与inode缓存类似, 不重复介绍. 申请dentry时需要关联inode.\n\n### 1.6.3. 缓冲区缓存\n\n对磁盘文件访问, 最终转化为对磁盘操作. 扇区是块设备的基本单元, 也是最小的寻址单元. 内核在扇区上抽象出了`块`的概念,块的大小是扇区的n倍, 不能超过页面长度, 通常为512b/1k/4k\n\n块被作为文件系统的最小寻址单元, 一个磁盘块被调入内存时, 需存储在对应的内存上的缓冲区中.\n\n新的kernel版本上, page cache中包含buffer cache. page cache为4k大小, 根据配置的块大小, 一个page cache可以包含一个还是多个(最多8-对应512b)buffer cache.\n\n## 1.7. 文件系统的注册与安装\n\n将指定文件系统的file_system_type对象向内核注册.已注册文件系统的file_system_type对象形成链表.\n\n### 1.7.1. 文件系统安装\n\n```cpp\nstruct mnt_namespace {\n\tatomic_t\t\tcount;\n\tstruct ns_common\tns;\n    // 该namespace下的根目录的vfsmount对象\n\tstruct mount *\troot;\n    // 链接属于该命名空间的安装的所有文件系统\n\tstruct list_head\tlist;\n\tstruct user_namespace\t*user_ns;\n\tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n\twait_queue_head_t poll;\n\tu64 event;\n\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n\tunsigned int\t\tpending_mounts;\n};\n```\n\n默认情况下, 所有进程共享同样的namespace, 即看到的是同样的结构.但如调用clone()时使用CLONE_NEWNS标志, 进程会获得一个新的namespace. 只有保证是相同的namespace, 看到的文件结构才一致.\n\nmount是基于进程的namespace进行安装的. 同样的namespace共享安装","tags":["Android"],"categories":["文件系统"]},{"title":"Android fuse 文件系统调研","url":"/2018/07/01/存储相关/Android fuse 文件系统介绍/","content":"\n# 1. 开篇\n\n本篇主要从存储挂载系统介绍fuse的相关流程. 在Android系统中, 在内部存储和外部存储之上新加了fuse 挂载, 对内部存储而言, 多用户情况下, 每个用户只能访问自己的内部存储目录(对应/mnt/runtime/read|write/emulated目录.) , 除此之外, 对应运行时权限的需求, 非特权应用(没有平台签名 , 不能申请安装权限android.permission.`WRITE_MEDIA_STORAGE` 的应用, 只能通过申请运行时WRITE_EXTERNAL_STORAGE权限的应用) 通过fuse实现了对存储的访问需求.\n\n# 2. 从sdcard volume挂载说起\n\n/system/bin/sdcard 进程为fuse的用户态守护进程. 在sd卡的volume卷挂载后, 会执行下列命令\n\n```cpp\n/system/bin/sdcard -u 1023 -g 1023 -U userid -w /mnt/media_rw/XXXX-XXXX XXXX-XXXX\nif (execl(kFusePath, kFusePath,\n                \"-u\", \"1023\", // AID_MEDIA_RW\n                \"-g\", \"1023\", // AID_MEDIA_RW\n                \"-U\", std::to_string(getMountUserId()).c_str(),\n                \"-w\",\n                mRawPath.c_str(),\n                stableName.c_str(),\n                NULL)) {\n            PLOG(ERROR) << \"Failed to exec\";\n}\n```\n进入sdcard进程, uid 1023  gid 1023 userid (当前的用户id)  -w  full_write  mRawPath对应 source_path,  label 对应 stableName\n\n没有配置sdcardfs情况下, \n\n```cpp\n// 对于sd卡, multi_user参数没传, 这里为false. 对于内部存储, multi_user为true\nrun(source_path, label, uid, gid, userid, multi_user, full_write);\n/* Physical storage is readable by all users on device, but\n * the Android directories are masked off to a single user\n * deep inside attr_from_stat(). */\n// full_write 为 true\nfuse_setup(&fuse_default, AID_SDCARD_RW, 0006)\n                || fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022)\n                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022))\n```\n\n指定了fuse_default/fuse_read/fuse_write 结构体挂载 /mnt/runtime/default | read | write.\n\n对于前面的参数, 大多保存到了 struct fuse_global global 字段中.  初始化根目录node，sdcard也类似kernel fs为每个目录和文件维护了一个node结构体\n\n## 2.1. 涉及的数据结构\n\n```cpp\n/* Global data for all FUSE mounts */\nstruct fuse_global {\n    pthread_mutex_t lock;\n\n    uid_t uid;\n    gid_t gid;\n    bool multi_user;\n\n    char source_path[PATH_MAX];\n    char obb_path[PATH_MAX];\n\n    AppIdMap* package_to_appid;\n\n    __u64 next_generation;\n   \n    struct node root;\n    __u32 inode_ctr;\n\n    struct fuse* fuse_default;\n    struct fuse* fuse_read;\n    struct fuse* fuse_write;\n};\n```\n\n前面提到的fuse_setup的初始化过程涉及到两个数据结构\n\n```cpp\n/* Single FUSE mount */\nstruct fuse {\n  // fuse_default | fuse_read | fuse_write 为 fuse 结构实例, 其中保存了 fuse_global的指针\n    struct fuse_global* global;\n    // 挂载路径\n    char dest_path[PATH_MAX];\n    // 相应打开 /dev/fuse设备的文件描述符\n    int fd;\n    // default read write的gid不同, 不写在global common中\n    gid_t gid;\n    // 同上, 挂载权限不同.\n    mode_t mask;\n};\n\nstruct node {\n    __u32 refcount;\n    __u64 nid;\n    __u64 gen;\n    /*\n     * The inode number for this FUSE node. Note that this isn't stable across\n     * multiple invocations of the FUSE daemon.\n     */\n    __u32 ino;\n\n    /* State derived based on current position in hierarchy. */\n    perm_t perm;\n    // 对应传进来的 user_id\n    userid_t userid;\n    // 分配的uid\n    uid_t uid;\n    bool under_android;\n\n    struct node *next;          /* per-dir sibling list */\n    struct node *child;         /* first contained file by this dir */\n    struct node *parent;        /* containing directory */\n\n    size_t namelen;\n    char *name;\n    /* If non-null, this is the real name of the file in the underlying storage.\n     * This may differ from the field \"name\" only by case.\n     * strlen(actual_name) will always equal strlen(name), so it is safe to use\n     * namelen for both fields.\n     */\n    char *actual_name;\n\n    /* If non-null, an exact underlying path that should be grafted into this\n     * position. Used to support things like OBB. */\n    char* graft_path;\n    size_t graft_pathlen;\n\n    bool deleted;\n};\n\n/* Private data used by a single FUSE handler */\nstruct fuse_handler {\n    struct fuse* fuse;\n    int token;\n\n    /* To save memory, we never use the contents of the request buffer and the read\n     * buffer at the same time.  This allows us to share the underlying storage. */\n    union {\n        __u8 request_buffer[MAX_REQUEST_SIZE];\n        __u8 read_buffer[MAX_READ + PAGE_SIZE];\n    };\n};\n```\n\nfuse结构体中保存了fuse_global的指针, fuse_global为common的,  被fuse_default  | fuse_read  | fuse_write共用.\n\nnode为表示目录层级的结构体, 其中保存了next | child | parent 节点的指针, 便于找到该节点的同级节点, 父目录 子目录\n\n![sdcard fuse](_v_images/20190322144135831_483226120.png)\n## 2.2. 初始化过程\n\n在run函数中首先对fuse_global   fuse_default  fuse_read  fuse_write进行初始化.\n\n```cpp\n    global.package_to_appid = new AppIdMap;\n    global.uid = uid;\n    global.gid = gid;\n    global.multi_user = multi_user;\n    global.next_generation = 0;\n    global.inode_ctr = 1;\n    // 定义global的root节点, 对应default read write三个目录\n    memset(&global.root, 0, sizeof(global.root));\n    global.root.nid = FUSE_ROOT_ID; /* 1 */\n    global.root.refcount = 2;\n    global.root.namelen = strlen(source_path);\n    // 挂载根目录为  /mnt/media_rw/XXXX-XXXX\n    global.root.name = strdup(source_path);\n    global.root.userid = userid;\n    global.root.uid = AID_ROOT;     //uid为root, gid在fuse结构体中定制.\n    global.root.under_android = false;\n\tstrcpy(global.source_path, source_path);\n    if (multi_user) {\n        // 内部存储  \n        global.root.perm = PERM_PRE_ROOT;\n        snprintf(global.obb_path, sizeof(global.obb_path), \"%s/obb\", source_path);\n    } else {\n        // 外部存储\n        global.root.perm = PERM_ROOT;\n        snprintf(global.obb_path, sizeof(global.obb_path), \"%s/Android/obb\", source_path);\n    }\n```\n\nfuse_handler 中用来处理数据\n\nfuse_setup函数中打开/dev/fuse设备, 保存fd到相应的结构体中, 并对/dev/fuse设备进行挂载\n\n## 2.3. 处理来的请求\n\nsetup完成后, 创建了三个线程分别负责接收 default | read | write 的数据并处理\n\n```cpp\nif (pthread_create(&thread_default, NULL, start_handler, &handler_default)\n        || pthread_create(&thread_read, NULL, start_handler, &handler_read)\n        || pthread_create(&thread_write, NULL, start_handler, &handler_write)) {\n    LOG(FATAL) << \"failed to pthread_create\";\n}\n// 处理函数为 start_handler, 数据放在handler中\nstatic void* start_handler(void* data) {\n    struct fuse_handler* handler = static_cast<fuse_handler*>(data);\n    // 由 handle_fuse_requests 函数处理\n    handle_fuse_requests(handler);\n    return NULL;\n}\n\nvoid handle_fuse_requests(struct fuse_handler* handler)\n{\n    struct fuse* fuse = handler->fuse;\n    for (;;) {\n        // 循环读取   相应fd 上的内容,  该fd 绑定了  对应的 default read write, 读取的数据放在 request_buffer中.\n        ssize_t len = TEMP_FAILURE_RETRY(read(fuse->fd,\n                handler->request_buffer, sizeof(handler->request_buffer)));\n        if (len == -1) {\n            // 读取失败, 且errno 为 No Such Device\n            if (errno == ENODEV) {\n                LOG(ERROR) << \"[\" << handler->token << \"] someone stole our marbles!\";\n                exit(2);\n            }\n            PLOG(ERROR) << \"[\" << handler->token << \"] handle_fuse_requests\";\n            continue;\n        }\n\n        if (static_cast<size_t>(len) < sizeof(struct fuse_in_header)) {\n            LOG(ERROR) << \"[\" << handler->token << \"] request too short: len=\" << len;\n            continue;\n        }\n\t\t// request_buffer 中包含 fuse_in_header 和 数据部分.\n        const struct fuse_in_header* hdr =\n            reinterpret_cast<const struct fuse_in_header*>(handler->request_buffer);\n        if (hdr->len != static_cast<size_t>(len)) {\n            LOG(ERROR) << \"[\" << handler->token << \"] malformed header: len=\" << len\n                       << \", hdr->len=\" << hdr->len;\n            continue;\n        }\n        // 取出数据部分, 并计算数据大小\n        const void *data = handler->request_buffer + sizeof(struct fuse_in_header);\n        size_t data_len = len - sizeof(struct fuse_in_header);\n        // 从Fuse_in_header中解析出 unique号\n        __u64 unique = hdr->unique;\n        // 具体数据由  handle_fuse_request 进行处理\n        int res = handle_fuse_request(fuse, handler, hdr, data, data_len);\n\n        /* We do not access the request again after this point because the underlying\n         * buffer storage may have been reused while processing the request. */\n\n        if (res != NO_STATUS) {\n            if (res) {\n                DLOG(INFO) << \"[\" << handler->token << \"] ERROR \" << res;\n            }\n            // 还要回复状态.\n            fuse_status(fuse, unique, res);\n        }\n    }\n}\n\n// 由 handle_fuse_request 根据fuse_in_header中的 opcode 操作码转发给具体的业务函数\nstatic int handle_fuse_request(struct fuse *fuse, struct fuse_handler* handler,\n        const struct fuse_in_header *hdr, const void *data, size_t data_len)\n{\n    switch (hdr->opcode) {\n        // 遍历node \n    case FUSE_LOOKUP: { /* bytez[] -> entry_out */\n        const char *name = static_cast<const char*>(data);\n        return handle_lookup(fuse, handler, hdr, name);\n    }\n\n    case FUSE_FORGET: {\n        const struct fuse_forget_in *req = static_cast<const struct fuse_forget_in*>(data);\n        return handle_forget(fuse, handler, hdr, req);\n    }\n    // 读权限以及文件属性相关\n    case FUSE_GETATTR: { /* getattr_in -> attr_out */\n        const struct fuse_getattr_in *req = static_cast<const struct fuse_getattr_in*>(data);\n        return handle_getattr(fuse, handler, hdr, req);\n    }\n    // 设置权限及文件属性等\n    case FUSE_SETATTR: { /* setattr_in -> attr_out */\n        const struct fuse_setattr_in *req = static_cast<const struct fuse_setattr_in*>(data);\n        return handle_setattr(fuse, handler, hdr, req);\n    }\n\n//    case FUSE_READLINK:\n//    case FUSE_SYMLINK:\n    case FUSE_MKNOD: { /* mknod_in, bytez[] -> entry_out */\n        const struct fuse_mknod_in *req = static_cast<const struct fuse_mknod_in*>(data);\n        const char *name = ((const char*) data) + sizeof(*req);\n        return handle_mknod(fuse, handler, hdr, req, name);\n    }\n\n    case FUSE_MKDIR: { /* mkdir_in, bytez[] -> entry_out */\n        const struct fuse_mkdir_in *req = static_cast<const struct fuse_mkdir_in*>(data);\n        const char *name = ((const char*) data) + sizeof(*req);\n        return handle_mkdir(fuse, handler, hdr, req, name);\n    }\n    // 删除链接\n    case FUSE_UNLINK: { /* bytez[] -> */\n        const char *name = static_cast<const char*>(data);\n        return handle_unlink(fuse, handler, hdr, name);\n    }\n\n    case FUSE_RMDIR: { /* bytez[] -> */\n        const char *name = static_cast<const char*>(data);\n        return handle_rmdir(fuse, handler, hdr, name);\n    }\n\n    case FUSE_RENAME: { /* rename_in, oldname, newname ->  */\n        const struct fuse_rename_in *req = static_cast<const struct fuse_rename_in*>(data);\n        const char *old_name = ((const char*) data) + sizeof(*req);\n        const char *new_name = old_name + strlen(old_name) + 1;\n        return handle_rename(fuse, handler, hdr, req, old_name, new_name);\n    }\n\n//    case FUSE_LINK:\n    case FUSE_OPEN: { /* open_in -> open_out */\n        const struct fuse_open_in *req = static_cast<const struct fuse_open_in*>(data);\n        return handle_open(fuse, handler, hdr, req);\n    }\n\n    case FUSE_READ: { /* read_in -> byte[] */\n        const struct fuse_read_in *req = static_cast<const struct fuse_read_in*>(data);\n        return handle_read(fuse, handler, hdr, req);\n    }\n\n    case FUSE_WRITE: { /* write_in, byte[write_in.size] -> write_out */\n        const struct fuse_write_in *req = static_cast<const struct fuse_write_in*>(data);\n        const void* buffer = (const __u8*)data + sizeof(*req);\n        return handle_write(fuse, handler, hdr, req, buffer);\n    }\n    // stat 函数对应的\n    case FUSE_STATFS: { /* getattr_in -> attr_out */\n        return handle_statfs(fuse, handler, hdr);\n    }\n    // 关闭文件\n    case FUSE_RELEASE: { /* release_in -> */\n        const struct fuse_release_in *req = static_cast<const struct fuse_release_in*>(data);\n        return handle_release(fuse, handler, hdr, req);\n    }\n    \n    case FUSE_FSYNC:\n    case FUSE_FSYNCDIR: {\n        const struct fuse_fsync_in *req = static_cast<const struct fuse_fsync_in*>(data);\n        return handle_fsync(fuse, handler, hdr, req);\n    }\n\n//    case FUSE_SETXATTR:\n//    case FUSE_GETXATTR:\n//    case FUSE_LISTXATTR:\n//    case FUSE_REMOVEXATTR:\n      \n    case FUSE_FLUSH: {\n        return handle_flush(fuse, handler, hdr);\n    }\n    // opendir 相关\n    case FUSE_OPENDIR: { /* open_in -> open_out */\n        const struct fuse_open_in *req = static_cast<const struct fuse_open_in*>(data);\n        return handle_opendir(fuse, handler, hdr, req);\n    }\n    // readdir 相关\n    case FUSE_READDIR: {\n        const struct fuse_read_in *req = static_cast<const struct fuse_read_in*>(data);\n        return handle_readdir(fuse, handler, hdr, req);\n    }\n\n    case FUSE_RELEASEDIR: { /* release_in -> */\n        const struct fuse_release_in *req = static_cast<const struct fuse_release_in*>(data);\n        return handle_releasedir(fuse, handler, hdr, req);\n    }\n\n    case FUSE_INIT: { /* init_in -> init_out */\n        const struct fuse_init_in *req = static_cast<const struct fuse_init_in*>(data);\n        return handle_init(fuse, handler, hdr, req);\n    }\n\n    case FUSE_CANONICAL_PATH: { /* nodeid -> bytez[] */\n        return handle_canonical_path(fuse, handler, hdr);\n    }\n\n    default: {\n        DLOG(INFO) << \"[\" << handler->token << \"] NOTIMPL op=\" << hdr->opcode\n                   << \"uniq=\" << std::hex << hdr->unique << \"nid=\" << hdr->nodeid << std::dec;\n        return -ENOSYS;\n    }\n    }\n}\n```\n在handle_fuse_request 中涉及的操作中包含了权限即目录管理的逻辑.\n\n## 2.4. 以FUSE_LOOKUP请求为例, 梳理流程\n\n首先看FUSE_LOOKUP,   lookup时传进的数据部分为 name?\n\n```cpp\nstatic int handle_lookup(struct fuse* fuse, struct fuse_handler* handler,\n        const struct fuse_in_header *hdr, const char* name)\n{\n    struct node* parent_node;\n    char parent_path[PATH_MAX];\n    char child_path[PATH_MAX];\n    const char* actual_name;\n\n    pthread_mutex_lock(&fuse->global->lock);\n    // 加锁保护谁?\n    //1.  lookup_node_and_path_by_id_locked 函数比较重要, 根据fuse_in_header中的nodeid找出parent_node 的 node节点, 并找到 parent_path\n    parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,\n            parent_path, sizeof(parent_path));\n    DLOG(INFO) << \"[\" << handler->token << \"] LOOKUP \" << name << \" @ \" << hdr->nodeid\n               << \" (\" << (parent_node ? parent_node->name : \"?\") << \")\";\n    pthread_mutex_unlock(&fuse->global->lock);\n    // 2. 查name 是不是在 parent_path中?, 并找出实际的名字, 和 child_path\n    if (!parent_node || !(actual_name = find_file_within(parent_path, name,\n            child_path, sizeof(child_path), 1))) {\n        return -ENOENT;\n    }\n    // 3. 查看是否有权限访问该节点\n    if (!check_caller_access_to_name(fuse, hdr, parent_node, name, R_OK)) {\n        return -EACCES;\n    }\n    // 4. 最后往 /dev/fuse中写入查出的内容, \n    return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);\n}\n\n// 1. 根据fuse_in_header中的nodeid找出parent_node 的 node节点, 并找到 parent_node\n// 对应 buf 存放parent_path(填充绝对路径), nid 为 fuse_in_header中的nodeid, 返回parent_node\nstatic struct node* lookup_node_and_path_by_id_locked(struct fuse* fuse, __u64 nid,\n        char* buf, size_t bufsize)\n{\n    struct node* node = lookup_node_by_id_locked(fuse, nid);  \n    if (node && get_node_path_locked(node, buf, bufsize) < 0) {\n        node = NULL;\n    }\n    return node;\n}\n\nstatic struct node *lookup_node_by_id_locked(struct fuse *fuse, __u64 nid)\n{\n    if (nid == FUSE_ROOT_ID) {\n        return &fuse->global->root;\n    } else {\n        // 非跟节点的, node 由 nid 转来, node的首地址和 nid相同. \n        // nodeid为 本次操作涉及的文件系统 node id     \n        return static_cast<struct node*>(id_to_ptr(nid));\n    }\n}\n\n\n// 1.2 根据node 查找 绝对路径. \n// 此函数为递归函数, 递归查找parent, 最终填充绝对路径.\nstatic ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {\n    const char* name;\n    size_t namelen;\n    // graph_path 为 obb路径使用\n    if (node->graft_path) {\n        name = node->graft_path;\n        namelen = node->graft_pathlen;\n    // actual_name 为 find_file_within 找出来的, 后面再介绍该函数, 初始时该字段为空\n    } else if (node->actual_name) {\n        name = node->actual_name;\n        namelen = node->namelen;\n    } else {\n        name = node->name;\n        namelen = node->namelen;\n    }\n\n    if (bufsize < namelen + 1) {\n        return -1;\n    }\n\n    ssize_t pathlen = 0;\n    if (node->parent && node->graft_path == NULL) {\n        // 递归 填充绝对路径\n        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\n        if (pathlen < 0) {\n            return -1;\n        }\n        buf[pathlen++] = '/';\n    }\n\n    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \\0 */\n    return pathlen + namelen;\n}\n\n// 2. 查name 是不是在 parent_path中?, 并找出实际的名字, 和 child_path 即该文件的绝对路径.\n\n/* Finds the absolute path of a file within a given directory.\n * Performs a case-insensitive search for the file and sets the buffer to the path\n * of the first matching file.  If 'search' is zero or if no match is found, sets\n * the buffer to the path that the file would have, assuming the name were case-sensitive.\n *\n * Populates 'buf' with the path and returns the actual name (within 'buf') on success,\n * or returns NULL if the path is too long for the provided buffer.\n */\n// path 为上面找到的该节点的父目录的绝对路径, name 为该节点的名字, handle_lookup 时 fuse_in_header中的数据部分为name, \n// buf为填充的子路径(该文件的绝对路径), 打开目录查找忽略大小写查找是否有匹配项, 没有原样直接返回, 有的话, 填充actual \n// \nstatic char* find_file_within(const char* path, const char* name,\n        char* buf, size_t bufsize, int search)\n{\n    size_t pathlen = strlen(path);\n    size_t namelen = strlen(name);\n    size_t childlen = pathlen + namelen + 1;\n    char* actual;\n\n    if (bufsize <= childlen) {\n        return NULL;\n    }\n    // 此时 buf  = path\n    memcpy(buf, path, pathlen);\n    buf[pathlen] = '/';\n    actual = buf + pathlen + 1;\n    // 此时buf = path/name\n    memcpy(actual, name, namelen + 1);\n    // search 为  1, 找到了该文件\n    if (search && access(buf, F_OK)) {\n        struct dirent* entry;\n        // 打开 parent_path. \n        DIR* dir = opendir(path);\n        // 打不开这个路径, 直接返回 actual = name\n        if (!dir) {\n            PLOG(ERROR) << \"opendir(\" << path << \") failed\";\n            return actual;\n        }\n        while ((entry = readdir(dir))) {\n            // 打开了parent_path, 忽略大小写, 查询该目录下是否有和 name 匹配的项, 查找到的第一个匹配项填充到 actual中. \n            if (!strcasecmp(entry->d_name, name)) {\n                /* we have a match - replace the name, don't need to copy the null again */\n                memcpy(actual, entry->d_name, namelen);\n                break;\n            }\n        }\n        closedir(dir);\n    }\n    return actual;\n}\n\n// 3.  查看是否有权限访问该节点, kernel已经进行了 uid的限制 \ncheck_caller_access_to_name(fuse, hdr, parent_node, name, R_OK)\n  \n/* Kernel has already enforced everything we returned through\n * derive_permissions_locked(), so this is used to lock down access\n * even further, such as enforcing that apps hold sdcard_rw. */\nstatic bool check_caller_access_to_name(struct fuse* fuse,\n        const struct fuse_in_header *hdr, const struct node* parent_node,\n        const char* name, int mode) {\n    /* Always block security-sensitive files at root */\n    if (parent_node && parent_node->perm == PERM_ROOT) {\n        // 根节点, 限制访问下面三个文件\n        if (!strcasecmp(name, \"autorun.inf\")\n                || !strcasecmp(name, \".android_secure\")\n                || !strcasecmp(name, \"android_secure\")) {\n            return false;\n        }\n    }\n\n    /* Root always has access; access for any other UIDs should always\n     * be controlled through packages.list. */\n    // uid 为 0, 表示访问者为 root用户, 不限制访问.\n    if (hdr->uid == 0) {\n        return true;\n    }\n\n    /* No extra permissions to enforce */\n    return true;\n}\n\n // 4. 最后往 /dev/fuse中写入查出的内容, \n    return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);\n\n\nstatic int fuse_reply_entry(struct fuse* fuse, __u64 unique,\n        struct node* parent, const char* name, const char* actual_name,\n        const char* path)\n{\n    struct node* node;\n    struct fuse_entry_out out;\n    struct stat s;\n\n    if (lstat(path, &s) == -1) {\n        return -errno;\n    }\n\n    pthread_mutex_lock(&fuse->global->lock);\n    // 4.1 获取node  或者根据需要 根据parent_path, actual等信息创建node\n    node = acquire_or_create_child_locked(fuse, parent, name, actual_name);\n    if (!node) {\n        pthread_mutex_unlock(&fuse->global->lock);\n        return -ENOMEM;\n    }\n    memset(&out, 0, sizeof(out));\n    // 4.2 设置权限, gid等属性信息\n    attr_from_stat(fuse, &out.attr, &s, node);\n    out.attr_valid = 10;\n    out.entry_valid = 10;\n    out.nodeid = node->nid;\n    out.generation = node->gen;\n    pthread_mutex_unlock(&fuse->global->lock);\n    // 4.3 回复给/dev/fuse设备, 此次 opcode 的内容 out.\n    fuse_reply(fuse, unique, &out, sizeof(out));\n    return NO_STATUS;\n}\n\n// 4.1 获取node  或者根据需要 根据parent_path, actual等信息创建node\n    node = acquire_or_create_child_locked(fuse, parent, name, actual_name);\n\nstatic struct node* acquire_or_create_child_locked(\n        struct fuse* fuse, struct node* parent,\n        const char* name, const char* actual_name)\n{\n    // 先查找 parent node 节点中的 child节点中是否中有该node 子节点\n    // 遍历顺序   parent_node->child , 由child 遍历其next节点, 即:\n    // for (node = node->child; node; node = node->next) \n    struct node* child = lookup_child_by_name_locked(parent, name);\n    if (child) {\n        // 如果有, 直接返回, 同时该节点的饮用计数 + 1\n        acquire_node_locked(child);\n    } else {\n        // 4.1.1 查不到, 正常第一次lookup时是没有这些节点的, 应该会创建. 该函数比较重要\n        child = create_node_locked(fuse, parent, name, actual_name);\n    }\n    return child;\n}\n\n// 4.1.1  创建文件的node节点 \nchild = create_node_locked(fuse, parent, name, actual_name);\n\nstruct node *create_node_locked(struct fuse* fuse,\n        struct node *parent, const char *name, const char* actual_name)\n{\n    struct node *node;\n    size_t namelen = strlen(name);\n\n    // Detect overflows in the inode counter. \"4 billion nodes should be enough\n    // for everybody\".\n    // inode_ctr 初始化为 1, 每次create_node_locked时 + 1,  __u32 格式, 当超出范围 2^32 后 + 1 会变为 0\n    if (fuse->global->inode_ctr == 0) {\n        LOG(ERROR) << \"No more inode numbers available\";\n        return NULL;\n    }\n\n    node = static_cast<struct node*>(calloc(1, sizeof(struct node)));\n    if (!node) {\n        return NULL;\n    }\n    node->name = static_cast<char*>(malloc(namelen + 1));\n    if (!node->name) {\n        free(node);\n        return NULL;\n    }\n    memcpy(node->name, name, namelen + 1);\n    // name 和 actual_name 不相同时, 也要fill actual_name字段\n    if (strcmp(name, actual_name)) {\n        node->actual_name = static_cast<char*>(malloc(namelen + 1));\n        if (!node->actual_name) {\n            free(node->name);\n            free(node);\n            return NULL;\n        }\n        memcpy(node->actual_name, actual_name, namelen + 1);\n    }\n    node->namelen = namelen;\n    // nid保存了 node的指针\n    node->nid = ptr_to_id(node);\n    // inode_ctr + 1\n    node->ino = fuse->global->inode_ctr++;\n    node->gen = fuse->global->next_generation++;\n\n    node->deleted = false;\n    // 4.1.1.1 设置perm标签, 并赋予userid uid等\n    derive_permissions_locked(fuse, parent, node);\n    // 引用计数 +1\n    acquire_node_locked(node);\n    // 4.1.1.2 将当前创建的文件节点跟parent节点绑定.\n    add_node_to_parent_locked(node, parent);\n    return node;\n}\n\n// 4.1.1.1 设置 perm 标签, 并根据情况赋予 userid uid等信息.\n// 多用户情景下的限制, 主要来自该函数.\n    derive_permissions_locked(fuse, parent, node);\nstatic void derive_permissions_locked(struct fuse* fuse, struct node *parent,\n        struct node *node) {\n    appid_t appid;\n\n    /* By default, each node inherits from its parent */\n    // node 节点继承其parent 节点的 userid uid.\n    node->perm = PERM_INHERIT;\n    node->userid = parent->userid;\n    node->uid = parent->uid;\n    node->under_android = parent->under_android;\n\n    /* Derive custom permissions based on parent and current node */\n    // 判断parent_node节点的权限\n    switch (parent->perm) {\n    // 如果为继承过来的, 不做处理\n    case PERM_INHERIT:\n        /* Already inherited above */\n        break;\n     // 为  PERM_PRE_ROOT , 表示其parent node 节点 为多用户情景下的 子节点.\n    case PERM_PRE_ROOT:\n        /* Legacy internal layout places users at top level */\n        // 此时对其赋予  PERM_ROOT , 并对其 userid赋值\n        // 如 /mnt/runtime/read 目录   emulated目录下 会有 0\\1\\2 等多用户的目录, userid = 0\\1\\2等.        \n        node->perm = PERM_ROOT;\n        node->userid = strtoul(node->name, NULL, 10);\n        break;\n    case PERM_ROOT:\n        /* Assume masked off by default. */\n        if (!strcasecmp(node->name, \"Android\")) {\n            /* App-specific directories inside; let anyone traverse */\n            node->perm = PERM_ANDROID;\n            node->under_android = true;\n        }\n        break;\n    case PERM_ANDROID:\n        if (!strcasecmp(node->name, \"data\")) {\n            /* App-specific directories inside; let anyone traverse */\n            node->perm = PERM_ANDROID_DATA;\n        } else if (!strcasecmp(node->name, \"obb\")) {\n            /* App-specific directories inside; let anyone traverse */\n            node->perm = PERM_ANDROID_OBB;\n            /* Single OBB directory is always shared */\n            node->graft_path = fuse->global->obb_path;\n            node->graft_pathlen = strlen(fuse->global->obb_path);\n        } else if (!strcasecmp(node->name, \"media\")) {\n            /* App-specific directories inside; let anyone traverse */\n            node->perm = PERM_ANDROID_MEDIA;\n        }\n        break;\n    case PERM_ANDROID_DATA:\n    case PERM_ANDROID_OBB:\n    case PERM_ANDROID_MEDIA:\n      // emulated/<userid>/Android/data|obb|media 下, 赋予uid 为  multiuser_get_uid 根据userid appid计算出的值:user_id * 100000) + (app_id % 100000) \n        // package_to_appid     std::map<std::string, appid_t, CaseInsensitiveCompare>;  从小到大排序, 将/data/system/packages.list 中扫描的 <name,uid> 保存. name为package的包名. \n //       ex:    如果有类似这样的目录 /emulated/0/Android/data|media|obb/<package_name>, 指定其uid为  \n        // user_id * 100000) + (app_id % 100000) \n        const auto& iter = fuse->global->package_to_appid->find(node->name);\n        if (iter != fuse->global->package_to_appid->end()) {\n            appid = iter->second;\n            node->uid = multiuser_get_uid(parent->userid, appid);\n        }\n        break;\n    }\n}\n\n// 4.1.1.2 将当前创建的文件节点跟parent节点绑定.\n    // 上面介绍过怎样遍历,  即指定parent节点, 每创建一个节点, 都将parent->child 指向这个节点. \n    add_node_to_parent_locked(node, parent);\nstatic void add_node_to_parent_locked(struct node *node, struct node *parent) {\n    node->parent = parent;\n    // 先将node->next 指向parent原来的child node\n    node->next = parent->child;\n    // 再将parent的child更新为现在的这个node.\n    parent->child = node;\n    acquire_node_locked(parent);\n}\n\n// 4.2 设置权限, gid等属性信息, 保存到 out.attr中\n    attr_from_stat(fuse, &out.attr, &s, node);\nstatic void attr_from_stat(struct fuse* fuse, struct fuse_attr *attr,\n        const struct stat *s, const struct node* node) {\n    // 设置属性等信息, 主要信息是从 lstat(path, &s) 中的s里取出的.\n    attr->ino = node->ino;\n    attr->size = s->st_size;\n    attr->blocks = s->st_blocks;\n    attr->atime = s->st_atim.tv_sec;\n    attr->mtime = s->st_mtim.tv_sec;\n    attr->ctime = s->st_ctim.tv_sec;\n    attr->atimensec = s->st_atim.tv_nsec;\n    attr->mtimensec = s->st_mtim.tv_nsec;\n    attr->ctimensec = s->st_ctim.tv_nsec;\n    attr->mode = s->st_mode;\n    attr->nlink = s->st_nlink;\n\n    attr->uid = node->uid;\n    // 对应 mnt/runtime/default 目录, 其gid 已在初始化时指定为 sdcard_rw.\n    // default 目录不为多用户情景, 此项对应 root用户以及一些native进程还有申请WRITE_MEDIA_STROAGE的app访问所设置的存储视图.\n    if (fuse->gid == AID_SDCARD_RW) {\n        attr->gid = AID_SDCARD_RW;\n    } else {\n        // 多用户情景下, 根据前面设置的userid 设置 uid, 公式:\n        //   userid*100000 + gid%100000 (gid为初始传入值  AID_EVERYBODY  9997)\n        // 对于应用, 应用在初始化时, 会赋予相对应的gid,  请看startProcessLocked函数\n        // gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));\n        attr->gid = multiuser_get_uid(node->userid, fuse->gid);\n    }\n    // fuse_setup 时传进来的mask, sdcard_rw的是  0006, full_write时 0007,还有别的, \n    int visible_mode = 0775 & ~fuse->mask;\n    if (node->perm == PERM_PRE_ROOT) {\n        /* Top of multi-user view should always be visible to ensure\n         * secondary users can traverse inside. */\n        visible_mode = 0711;\n      // emulated/<userid>/Android 下的目录 禁止 other访问. 而default 视图下保留other的 +x 权限\n    } else if (node->under_android) {\n        /* Block \"other\" access to Android directories, since only apps\n         * belonging to a specific user should be in there; we still\n         * leave +x open for the default view. */\n        if (fuse->gid == AID_SDCARD_RW) {\n            visible_mode = visible_mode & ~0006;\n        } else {\n            visible_mode = visible_mode & ~0007;\n        }\n    }\n    // 取出owner_mode , \n    int owner_mode = s->st_mode & 0700;\n    // filter_mode 为 owner_mode 扩展 给 group mode 和 other_mode后 与visable_mode相与\n    int filtered_mode = visible_mode & (owner_mode | (owner_mode >> 3) | (owner_mode >> 6));\n    // S_IFMT 文件类型的位遮罩  linux 中用低16位, 见附图1, 这里就是设置回mode. 其中权限为 filter_mode.\n    // 以上面传过来的 mask 0006举例, 初始 visible_mode 为 0755& 7771 = 0751 owner_mode是从stat时取出的, 如果owner_mode为 0644的话,  (owner_mode | (owner_mode >> 3) | (owner_mode >> 6) 就是 0666, 这样filter_mode就是 0751& 0666 = 0640  \n    attr->mode = (attr->mode & S_IFMT) | filtered_mode;\n}\n\n// 4.3 回复给/dev/fuse设备, 此次 opcode 的内容 out.是的是的\nfuse_reply(fuse, unique, &out, sizeof(out));\n    out.attr_valid = 10;\n    out.entry_valid = 10;\n    out.nodeid = node->nid;\n    out.generation = node->gen;\n\nstatic void fuse_reply(struct fuse *fuse, __u64 unique, void *data, int len)\n{\n    struct fuse_out_header hdr;\n    hdr.len = len + sizeof(hdr);\n    hdr.error = 0;\n    hdr.unique = unique;\n    \n    struct iovec vec[2];\n    // 构造fuse_out_header 的 数据 放在iovec[0] 中\n    vec[0].iov_base = &hdr;\n    vec[0].iov_len = sizeof(hdr);\n    // data 最终放在 iovec[1].iov_base中, 上文传过来的 out\n    vec[1].iov_base = data;\n    vec[1].iov_len = len;\n    // 会写到 /dev/fuse设备中\n    ssize_t ret = TEMP_FAILURE_RETRY(writev(fuse->fd, vec, 2));\n}\n```\n\n, ![附图1](images/file_type.jpg)  \n\n### 2.4.1. handle_lookup小节\n\n总结下上述handle_lookup的过程:\n\n1.  根据fuse_in_header中的nodeid找出parent_node 的 node节点, 并找到 parent_node\n    对应 buf 存放parent_path(填充绝对路径), nid 为 fuse_in_header中的nodeid, 返回parent_node\n\n2.  查name (name是在lookup的data字段中)是不是在 parent_path中?, 并找出实际的名字, 和 child_path 即该文件的绝对路径.\n\n3.  查看是否有权限访问该节点, kernel已经进行了 uid的限制 \n\n4.  最后往 /dev/fuse中写入查出的内容, \n\n    4.1 获取node  或者根据需要根据parent_path, actual等信息创建node\n\n    4.2 设置mode, gid stat等信息, 保存到 out.attr中\n\n    4.3 回复给/dev/fuse设备, 此次 opcode 的内容 out.\n\n此例中涉及到几个关键函数\n\n-   lookup_node_and_path_by_id_locked\n\n    根据fuse_in_header中的nodeid找出parent_node 的 node节点, 并找到 parent_node\n    以及parent_path(填充绝对路径), nid 为 fuse_in_header中的nodeid, 返回parent_node\n\n- find_file_within\n\n    查找name是否在parent目录中, 并找出实际的名字actual_name.  忽略大小写查找是否有匹配项. 并找出该name对应的绝对路径\n\n- fuse_reply_entry\n\n    该函数负责回写请求的信息. 包括查找请求的 name 对应的 node 或者找不到时创建 node, 添加引用计数,并关联 parent next node 链表.填充和设置该 node 的信息等.(包括权限管理等), 最后会写到/dev/fuse 设备中.\n\n    -   acquire_or_create_child_locked 查找当前节点, 没有则创建,并设置parent next节点关联\n    -   derive_permissions_locked  设置perm标签, 填充uid userid等\n    -   attr_from_stat 设置gid, 和 访问的mode 和 st_mode作用相同\n    -   fuse_reply  根据前面的结果填充fuse_out_header 和 data, 会写到/dev/fuse中\n\n# 3. fuse 交互传输\n\n对应一次write系统调用的过程, 其文件的真实文件系统为ext4, 而通过fuse进行权限控制等过程. \n一次系统调用需要在User Space和kernel Space中穿越6次. 如果一次调用过程中, 如果涉及到中间的消息, 如需要stat查询信息, 再做写入等, 则需要10次穿越.\n可见fuse 文件系统的效率是非常慢的.\n\n而最新的sdcard服务中使用sdcardfs取代fuse文件系统, sdcardfs没有用户态的服务, 因此其和vfs的交互是直接的, 这样对应一次系统调用用户态和内核态的穿越只需要2次.\n\n\n```puml\n@startuml\nautoactivate on\nbox \"User space\" #LightGreen\n    participant app #yellow\n    participant sdcard #pink\nend box\n\nbox \"kernel space\" #LightBlue\n    participant VFS\n    participant FUSE #dark\n    participant EXT4 #dark\nend box\n\n\napp->VFS: write file\nVFS->FUSE: write\nFUSE->>sdcard: handle lookup\nsdcard->VFS: stat\nVFS -> EXT4: stat\nEXT4-->VFS: return stat result\nVFS-->sdcard: return stat result\nsdcard ->o FUSE: reply lookup result\n\nFUSE->>sdcard: handle write\nsdcard->VFS: write\nVFS->EXT4: write\nEXT4-->VFS:return write status\nVFS-->sdcard: return write status\nsdcard->o FUSE: reply write status\nFUSE-->VFS: return write\nVFS-->app: return write\n@enduml\n```\n\n![fuse](_v_images/20200525150857614_541229649.png)","tags":["Android","fuse"],"categories":["文件系统"]},{"title":"SAF框架","url":"/2018/07/01/存储相关/SAF框架/","content":"\nAndroid 4.4（API 级别 19）引入了存储访问框架 (SAF)。它可以让用户方便的浏览、打开文档、图片和其它\n的文件。用户可以通过标准的用户界面来浏览文件、打开最近访问的文件。\n\nSAF框架包含下面三个部分:\n- `Document provider`:\n\t一种ContentProvider，DocumentsProvider的子类。Android平台内置了多个，例如Downloads，Images，Videos\n- `Client App`:\n\t\t应用端，调用`ACTION_OPEN_DOCUMENT`/`ACTION_CREATE_DOCUMENT`，并且接收provider返回的文件\n- `Picker`:\n\t系统界面，允许用户访问所有满足应用端搜索条件的provider提供的文档。例如平台的`DocumentsUI`\n\nSAF 提供的部分功能如下：\n- 允许用户浏览所有文档提供程序而不仅仅是单个应用中的内容；\n- 让应用获得对provider所拥有文档的长期、持久性访问权限。 用户可以通过此访问权限添加、编辑、保存\n和删除提供程序上的文件；\n- 支持多个用户帐户和临时根目录，如只有在插入驱动器后才会出现的 USB 存储提供程序。\n注意：\n在SAF中，客户端并不会直接与provider交互。客户端请求与文件交互(即读、编辑、创建、删除)的权限。\n\n# 1. 应用端代码示例\n\n## 1.1. 授予目录访问权限\n\n### 1.1.1. 通过`ACTION_OPEN_DOCUMENT_TREE`授予应用访问特定目录的权限\n\n```java\npublic void performGrantSdWriteAcess() {\n\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);\n\tintent.addCategory(Intent.CATEGORY_DEFAULT);\n\tstartActivityForResult(intent, TREE_REQUEST_CODE);\n}\n```\n通过`DocumentsUi` picker 选择好目录后，可以在`onActivityResult`中对返回的URI进行处理\n\n```java\npublic void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\tif(requestCode == TREE_REQUEST_CODE && resultData == Activity.RESULT_OK) {\n\t\tUri uri = null;\n\t\tif(resultData != null) {\n\t\t\turi = resultData.getData();\n\t\t\tfinal int takeFlags = resultData.getFlags() &\n\t\t\t\t(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\t\t\t//授予权限\n\t\t\tgetContentResolver().takePersistableUriPermission(uri, takeFlags);\n\t\t}\n\t}\n}\n```\n在选择好的目录中新建文件或目录:\n\n```java\npublic void testTree() {\n\tUri doc = DocumentsContract.buildDocumentUriUsingTree(uri, DocumentsContract.getTreeDocumentId(uri));\n\ttry{\n\t\tUri pic = DocumentsContract.createDocument(getContentResolver(), doc, \"image/png\", \"test.png\");\n\t\tUri dir = DocumentsContract.createDocument(getContentResolver(), doc, DocumentsContract.Document.MIME_TYPE_DIR, \"testDir\");\n\t} catch(Exception e) {\n\n\t}\n}\n```\n### 1.1.2. 通过`ACTION_OPEN_EXTERNAL_DIRECTORY`授予应用目录访问权限\n\n```java\n\tpublic void onScopedDirectoryTest() {\n\t\tfinal StorgeManager sm = (StorageManager) getApplicationContext().getSystemService(Context.STORAGE_SERVICE);\n\t\tfinal List<StorageVolume> volumes = sm.getStorageVolumes();\n\t\tfor(StorageVolume volume: volumes) {\n\t\t\tfinal Intent intent = volume.createAccessIntent();\n            String volumePath = volume.getPath();\n\t\t\tif(Environment.getExterStorageState(volumePath).equals(Environment.MEDIA_MOUNTED) && \n\t\t\t\tvolumePath.equals(EnvironmentEx.getExternalStoragePath())) {\n\t\t\t\t// for sdcard\n\t\t\t\tif(intent != null) {\n\t\t\t\t\tstartActivityForResult(intent, SCOPED_REQUEST_CODE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    public @Nullable Intent createAccessIntent(String directoryName) {\n        if ((isPrimary() && directoryName == null) ||\n                (directoryName != null && !Environment.isStandardDirectory(directoryName))) {\n            return null;\n        }\n        final Intent intent = new Intent(ACTION_OPEN_EXTERNAL_DIRECTORY);\n        intent.putExtra(EXTRA_STORAGE_VOLUME, this);\n        intent.putExtra(EXTRA_DIRECTORY_NAME, directoryName);\n        return intent;\n    }\n\n```\n\n弹出DocumentUI的请求授予该存储的对话框\n\n## 1.2. 文档搜索\n\n### 1.2.1. 通过`ACTION_OPEN_DOCUMENT`实现搜索文件\n\n```java\npublic void performFileSearch(String type) {\n\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\t// 设置搜索类型\n\tintent.setType(type);\n\tstartActivityForResult(intent, READ_REQUEST_CODE);\n}\n```\n\n在选中目标后，可以在onActivityResult中对返回的URI根据自身的业务逻辑进行处理\n\n```java\npublic void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\tif(requestCode == TREE_REQUEST_CODE && resultData == Activity.RESULT_OK) {\n\t\tUri uri = null;\n\t\tif(resultData != null) {\n\t\t\turi = resultData.getData();\n            //如搜索到的是图片时,显示图片\n            getBitmapFromUri(uri);\n            //搜索到的是文本时,读取其中内容\n            readTextFromUri(uri);\n\t\t}\n\t}\n}\n\nprivate Bitmap getBitmapFromUri(Uri uri) throws IoException {\n\tParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(uri, \"r\");\n\tFileDescriptor fd = pfd.getFileDescriptor();\n\tBitmap image = BitmapFactory.decodeFileDescriptor(fd);\n\tpfd.close();\n\treturn image;\n}\n\nprivate String readTextFromUri(Uri uri) throws IoException{\n\tInputStream is = getContentResolver().openInputStream(uri);\n\tBufferReader reader = new BufferReader(new InputStreamReader(is));\n\tString line;\n\tStringBuilder sb = new StringBuilder()\n\twhile((line = reader.readLine()) != null) {\n\t\tsb.append(line);\n\t}\n\tis.close();\n\treturn sb.toString();\n}\n```\n\n## 1.3. 文档创建\n\n### 1.3.1. 通过`ACTION_CREATE_DOCUMENT` 创建文档 \n\n```java\n// performCreateFile(\"image/png\", \"test.png\")\npublic void performCreateFile(String type, String fileName) {\n\tIntent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);\n\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\tintent.setType(type);\n\tintent.putExtra(Intent.EXTRA_TITLE, fileName);\n\tstartActivityForResult(intent, WRITE_REQUEST_CODE);\n}\n```\n\n通过pickerUi, 可以选择新建文件的位置以及文件名, 可以在返回结果中对新返回的文档的uri进行处理.\n\n## 1.4. 文档编辑\n\n### 1.4.1. 通过`ACTION_OPEN_DOCUMENT` 编辑文档\n\n```java\nprivate void editFile() {\n\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\tintent.setType(\"text/plain\");\n\tstartActivityForResult(intent, EDIT_REQUEST_CODE);\n}\n```\n\n通过pickerUi 选择要编辑的文档, 选择完成后, 在返回结果中对文档进行编辑\n\n```java\npublic void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\tif(requestCode == TREE_REQUEST_CODE && resultData == Activity.RESULT_OK) {\n\t\tUri uri = null;\n\t\tif(resultData != null) {\n\t\t\turi = resultData.getData();\n\t\t\twriteDocument(uri);\n\t\t}\n\t}\n}\n\nprivate writeDocument(Uri uri) {\n\ttry{\n\t\tParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(uri, \"w\");\n\t\tFileOutputStream fos = new FileOutputStream(pfd.getFileDescriptor());\n\t\tfos.write(\"write test code\");\n\t\tfos.close();\n\t\tpfd.close();\n\t} catch(FileNotFoundException e) {\n\t\te.printStackTrace();\n\t} catch(IOException) {\n\t\t//to do\n\t\te.printStackTrace();\n\t}\n}\n```\n\n## 1.5. 删除文档\n\n\n\n如果获得了文档的uri, 且文档的 Document.COLUMN_FLAGS 包含 `SUPPORTS_DELETE`，便可以删除该文档\n\n```java\nDocumentsContract.deleteDocument(getContentResolver(), uri);\n```\n\n在设置-存储-sd卡进入DocumentsUI，任意选中一个文档查看信息, 可以看到文档是否包含`SUPPORTS_DELETE`\n\n## 1.6. 保留权限\n\n当您的应用打开文件进行读取或写入时，系统会为您的应用提供针对该文件的 URI 授权。 该授权将一直持续到用户设备`重启`时。但假定您的应用是图像编辑应用，而且您希望用户能够直接从应用中访问他们编辑的最后5 张图像。 如果用户的设备已经重启，您就需要将用户转回系统选取器以查找这些文件，这显然不是理想的做法。\n为防止出现这种情况，您可以*保留系统为您的应用授予的权限*。 您的应用实际上是`获取`了系统提供的持\n久 URI 授权。 这使用户能够通过您的应用持续访问文件，即使设备已重启也不受影响：\n\n```java\nfinal int takeFlags = intent.getFlags()\n\t& (Intent.FLAG_GRANT_READ_URI_PERMISSION\n    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); \n\n// Check for the freshest data.\ngetContentResolver().takePersistableUriPermission(uri, takeFlags);\n```\n\n# 2. DocumentUi 相关调用解析\n\n对应上述客户端的调用, startActivity解析出来跳转的分别是`PickActivity`和`ScopedAccessActivity`\n\n```xml\n        <activity\n            android:name=\".picker.PickActivity\"\n            android:theme=\"@style/DocumentsTheme\"\n            android:visibleToInstantApps=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.OPEN_DOCUMENT\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.OPENABLE\" />\n                <data android:mimeType=\"*/*\" />\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"android.intent.action.CREATE_DOCUMENT\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.OPENABLE\" />\n                <data android:mimeType=\"*/*\" />\n            </intent-filter>\n            <intent-filter android:priority=\"100\">\n                <action android:name=\"android.intent.action.GET_CONTENT\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.OPENABLE\" />\n                <data android:mimeType=\"*/*\" />\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"android.intent.action.OPEN_DOCUMENT_TREE\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n        </activity>\n\n        <activity\n            android:name=\".ScopedAccessActivity\"\n            android:theme=\"@android:style/Theme.Translucent.NoTitleBar\">\n            <intent-filter>\n                <action android:name=\"android.os.storage.action.OPEN_EXTERNAL_DIRECTORY\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n        </activity>\n```\n\n## 2.1. `ACTION_OPEN_EXTERNAL_DIRECTORY` 授权外部存储权限流程解析\n\n在应用端调用startActivity后跳转到`ScopedAccessActivity` \n看下provider/activity/client app 三者的调用关系\n\n- ExternalStorageProvider\n- ScopedAccessActivity\n- client app\n\n1. client app 发起 startActivity请求\n2. 跳转到ScopedAccessActivity的onCreate函数中\n  a.先从保存的sharePreference中检查key为userId + \"|\" + packageName + \"|\" + uuid + \"|\" + directory的是否指定了\n  `   PERMISSION_NEVER_ASK`, 该动作是在弹出对话框点击不允许时勾选的,如果是这种情况,直接退出,返回给clientapp的结果为cancel.\n  b. 调用showFragment弹出对话框提示用户是否给予给定的volume+directory权限.\n  c. 判断目录是否是`STANDARD_DIRECTORIES`, 不是返回deny\n\n```java\n    public static final String[] STANDARD_DIRECTORIES = {\n            DIRECTORY_MUSIC,\n            DIRECTORY_PODCASTS,\n            DIRECTORY_RINGTONES,\n            DIRECTORY_ALARMS,\n            DIRECTORY_NOTIFICATIONS,\n            DIRECTORY_PICTURES,\n            DIRECTORY_MOVIES,\n            DIRECTORY_DOWNLOADS,\n            DIRECTORY_DCIM,\n            DIRECTORY_DOCUMENTS\n    };\n```\n\n   \td. 对当前存储卷进行遍历, 查找给定volume directory匹配的卷和目录   \n\n​\t查找到卷, 对于外部存储, 通过`getInternalPathForUser`方法转换了路径\n   > return new File(path.replace(\"/storage/\", \"/mnt/media_rw/\"));\n\n \t e. 调用getUriPermission返回requestedUri, 通过检索AUTHORITY名获得对应的provider实例, 调用provider的\t\tgetDocIdForFileCreateNewDir方法\n   \t最终调用到ExternalStorageProvider的 `getDocIdForFileMaybeCreate`方法,返回对应volume的 rootId + ':' + path; 最终返回通过buildTreeDocumentUri构造完的uri\n\n   >  rootid为fsuuid\n   >\n   >  requestedUri格式  content://com.android.externalstorage.documents/tree/fsuuid:path ,path为相对volume root的路径.\n   >\n   >  构造requestedUri和rootUri, 请求uri和rooturi\n\n​\tg. 回调callback, 此处开始真正检查是否有权限, 没有权限需要弹出对话框让用户选择授予还是拒绝, `getIntentForExistingPermission`检查权限, 最终是通过`AMS`的`getGrantedUriPermissions`检查是否对package授予了该uri权限,遍历ams的`mGrantedUriPermissions`map ArrayMap<GrantUri, UriPermission>. \n 检查是否匹配requestedUri或rootUri,如果匹配返回`createGrantedUriPermissionsIntent(requestedUri)`的intent, intent的data字段保存uri, flag中保存权限信息. 最终将该intent返回给clientapp.\n如果没有授权, 即没在map中, 弹出对话框ScopedAccessDialogFragment, **点击允许按钮**, 调用`createGrantedUriPermissionsIntent`, 最终还是跟上面的步骤一样返回`createGrantedUriPermissionsIntent(requestedUri)`的intent, intent的data字段保存uri, flag中保存权限信息. 最终将该intent返回给clientapp.\n***点击拒绝***, 如果勾选never ask, 以userId + \"|\" + packageName + \"|\" + uuid + \"|\" + directory为key保存`PERMISSION_NEVER_ASK`的sharePref\n\n\n```java\n      private synchronized ContentProviderClient getExternalStorageClient() {\n        if (mExternalStorageClient == null) {\n            mExternalStorageClient =\n                    getContentResolver().acquireContentProviderClient(Providers.AUTHORITY_STORAGE);\n        }\n        return mExternalStorageClient;\n      }\n   \n      bundle = storageProvider.call(\"getDocIdForFileCreateNewDir\", file.getPath(), null);\n      final String docId = bundle == null ? null : bundle.getString(\"DOC_ID\");\n      final Uri uri = DocumentsContract.buildTreeDocumentUri(Providers.AUTHORITY_STORAGE, docId);\n      return uri;\n      ...\n      requestedUri = uri;\n      // 请求目录和根目录的uri.\n      final Uri rootUri = internalRoot.equals(file) ? requestedUri\n                : getUriPermission(context, storageClient, internalRoot);\n\n      // 上述流程走完, 回调该callback\n      (file, volumeLabel, isRoot, isPrimary, grantedUri, rootUri) -> {\n                    // Checks if the user has granted the permission already.\n                    final Intent intent = getIntentForExistingPermission(activity,\n                            activity.getCallingPackage(), grantedUri, rootUri);\n                    if (intent != null) {\n                        activity.setResult(RESULT_OK, intent);\n                        activity.finish();\n                        return true;\n                    }\n\n                    // Gets the package label.\n                    final String appLabel = getAppLabel(activity);\n                    if (appLabel == null) {\n                        // Error already logged.\n                        return false;\n                    }\n\n                    // Sets args that will be retrieve on onCreate()\n                    final Bundle args = new Bundle();\n                    args.putString(EXTRA_FILE, file.getAbsolutePath());\n                    args.putString(EXTRA_VOLUME_LABEL, volumeLabel);\n                    args.putString(EXTRA_VOLUME_UUID, storageVolume.getUuid());\n                    args.putString(EXTRA_APP_LABEL, appLabel);\n                    args.putBoolean(EXTRA_IS_ROOT, isRoot);\n                    args.putBoolean(EXTRA_IS_PRIMARY, isPrimary);\n\n                    final FragmentManager fm = activity.getFragmentManager();\n                    final FragmentTransaction ft = fm.beginTransaction();\n                    final ScopedAccessDialogFragment fragment = new ScopedAccessDialogFragment();\n                    fragment.setArguments(args);\n                    ft.add(fragment, FM_TAG);\n                    ft.commitAllowingStateLoss();\n\n                    return true;\n                });\n    //如果上面没有检查到授权, 没在map中弹出ScopedAccessDialogFragment对话框\n                public void onClick(DialogInterface dialog, int which) {\n                    Intent intent = null;\n                    if (which == DialogInterface.BUTTON_POSITIVE) {\n                    \t// 点击允许\n                        intent = createGrantedUriPermissionsIntent(mActivity,\n                                mActivity.getExternalStorageClient(), mFile);\n                    }\n                    // 点击拒绝\n                    if (which == DialogInterface.BUTTON_NEGATIVE || intent == null) {\n                        final boolean checked = mDontAskAgain.isChecked();\n                        if (checked) {\n                            logValidScopedAccessRequest(mActivity, directory,\n                                    SCOPED_DIRECTORY_ACCESS_DENIED_AND_PERSIST);\n                            setScopedAccessPermissionStatus(context, mActivity.getCallingPackage(),\n                                    mVolumeUuid, directoryName, PERMISSION_NEVER_ASK);\n                        } else {\n                            setScopedAccessPermissionStatus(context, mActivity.getCallingPackage(),\n                                    mVolumeUuid, directoryName, PERMISSION_ASK_AGAIN);\n                        }\n                        mActivity.setResult(RESULT_CANCELED);\n                    } else {\n                        logValidScopedAccessRequest(mActivity, directory,\n                                SCOPED_DIRECTORY_ACCESS_GRANTED);\n                        mActivity.setResult(RESULT_OK, intent);\n                    }\n                    mActivity.finish();\n                }\n\n```\n3. 跳转到clientApp的onActivityResult中, 需要调用`takePersistableUriPermission`来持久化权限. 该函数最终会调用到ams中.最终保存到/data/system/urigrants.xml文件中.\n\n```java\n        if (resultCode == Activity.RESULT_OK) {\n            if(requestCode == REQUEST_CODE){\n                Uri uri = null;\n                if (data != null) {\n                    uri = data.getData();\n                    final ContentResolver resolver = getContentResolver();\n                    final int modeFlags = data.getFlags() & (Intent.FLAG_GRANT_READ_URI_PERMISSION\n                                            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);32\n                    resolver.takePersistableUriPermission(uri, modeFlags);\n                }\n            }\n        }\n```\n\n## 2.2. 通过`ACTION_CREATE_DOCUMENT` 创建文档调用流程分析\n\n跳转到pickui, 因为在AndroidManifest中的声明.\n先跳转到pickActivitity的`onCreate`函数中. \n1. onCreate函数中首先初始化一些特性属性manager等, 绑定到Injector上.\n2. 调用super.onCreate(icicle); 初始化一些属性, 如action. 跳转到BaseActivity的onCreate \n3. 通过setupLayout 设置布局\n4. initLocation初始化当前位置.\n\n```java\n// 注册器, 保存了相关的特性, 后面都由该类访问\nmInjector = new Injector<>(\n                features,\n                new Config(),\n                prefs,\n                new MessageBuilder(this),\n                DialogController.create(features, this, null),\n                DocumentsApplication.getFileTypeLookup(this),\n                (Collection<RootInfo> roots) -> {});\n//如selectionMgr/menuManager/focusManager/actionModeController/searchManager 管理文档的各种特性, \n\n//注意这几个\n// 跳转到BaseActivity的onCreate\n\n// 初始化state\nmState = getState(icicle);\n\n    private State getState(@Nullable Bundle icicle) {\n\n        State state = new State();\n\n        final Intent intent = getIntent();\n\n        state.sortModel = SortModel.createModel();\n        state.localOnly = intent.getBooleanExtra(Intent.EXTRA_LOCAL_ONLY, false);\n        state.excludedAuthorities = getExcludedAuthorities();\n        // 对state的action进行赋值, 根据传进来的action\n        includeState(state);\n\n        // 跳到子类pickActivity的 includeState函数中 对应ACTION_CREATE_DOCUMENT类型\n                } else if (Intent.ACTION_CREATE_DOCUMENT.equals(action)) {\n            state.action = ACTION_CREATE;\n        ///////\n\n        state.showAdvanced = Shared.mustShowDeviceRoot(intent)\n                || mInjector.prefs.getShowDeviceRoot();\n\n        // Only show the toggle if advanced isn't forced enabled.\n        state.showDeviceStorageOption = !Shared.mustShowDeviceRoot(intent);\n\n        return state;\n    }\n\nmProviders = DocumentsApplication.getProvidersCache(this);\n\n//下面有几个布局相关的\n\n    public PickActivity() {\n        super(R.layout.documents_activity, TAG);\n    }\n// 相关布局情况请看 DocumentsUI/res/layout/drawer_layout.xml文件\n    mLayoutId = R.layout.documents_activity\nsetContentView(mLayoutId);\nmNavigator = new NavigationViewManager(mDrawer, toolbar, mState, this, breadcrumb);\n\n\n\nDocumentsApplication.getFileTypeLookup(this),\n        mInjector.actions = new ActionHandler<>(\n                this,\n                mState,\n                mProviders,\n                mDocs,\n                mSearchManager,\n                ProviderExecutor::forAuthority,\n                mInjector,\n                mLastAccessed);\n\n\n    \n\n//setupLayout 根据action跳转到不同的布局fragment中\n    private void setupLayout(Intent intent) {\n        if (mState.action == ACTION_CREATE) {\n            final String mimeType = intent.getType();\n            final String title = intent.getStringExtra(Intent.EXTRA_TITLE);\n            SaveFragment.show(getFragmentManager(), mimeType, title);\n        } else if (mState.action == ACTION_OPEN_TREE ||\n                   mState.action == ACTION_PICK_COPY_DESTINATION) {\n            PickFragment.show(getFragmentManager());\n        }\n\n        if (mState.action == ACTION_GET_CONTENT) {\n            final Intent moreApps = new Intent(intent);\n            moreApps.setComponent(null);\n            moreApps.setPackage(null);\n            RootsFragment.show(getFragmentManager(), moreApps);\n        } else if (mState.action == ACTION_OPEN ||\n                   mState.action == ACTION_CREATE ||\n                   mState.action == ACTION_OPEN_TREE ||\n                   mState.action == ACTION_PICK_COPY_DESTINATION) {\n            RootsFragment.show(getFragmentManager(), (Intent) null);\n        }\n    }\n\n```\n\n4. initLocation当前位置, 主要与startActivity后初始打开的document位置有关, 下面的参数都是clientapp调用时带的, 如下面指定`EXTRA_INITIAL_URI`的方式\n\n```java\n        intent.setAction(Intent.ACTION_CREATE_DOCUMENT);\n        intent.setType(\"plain/text\");\n        intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, docUri);\n\n\n    public void initLocation(Intent intent) {   \n\n        // stack is initialized if it's restored from bundle, which means we're restoring a\n        // previously stored state.\n        if (mState.stack.isInitialized()) {\n            if (DEBUG) Log.d(TAG, \"Stack already resolved for uri: \" + intent.getData());\n            restoreRootAndDirectory();\n            return;\n        }\n\n        if (launchHomeForCopyDestination(intent)) {\n            if (DEBUG) Log.d(TAG, \"Launching directly into Home directory for copy destination.\");\n            return;\n        }\n\n        if (mFeatures.isLaunchToDocumentEnabled() && launchToDocument(intent)) {\n            if (DEBUG) Log.d(TAG, \"Launched to a document.\");\n            return;\n        }\n\n        if (DEBUG) Log.d(TAG, \"Load last accessed stack.\");\n        loadLastAccessedStack();\n    }\n```\n\n\n我们这里从最普遍的场景进行分析, 进来后跳转到 `SaveFragment`\n\n### 2.2.1. SaveFragment\n\nSaveFragment.show(getFragmentManager(), mimeType, title);\n\n// clientapp传入的type filename\n\n```xml\n# 布局置换, 在前面介绍的drawer_layout.xml布局文件中包含该布局\n<include layout=\"@layout/directory_cluster\"/>\n```\n\n```java\n    static void show(FragmentManager fm, String mimeType, String displayName) {\n        final Bundle args = new Bundle();\n        args.putString(EXTRA_MIME_TYPE, mimeType);   // clientapp\n        args.putString(EXTRA_DISPLAY_NAME, displayName);\n\n        final SaveFragment fragment = new SaveFragment();\n        fragment.setArguments(args);\n\n        final FragmentTransaction ft = fm.beginTransaction();\n        // saveframent填入该布局\n        ft.replace(R.id.container_save, fragment, TAG);\n        ft.commitAllowingStateLoss();\n    }\n```\n\n#### 2.2.1.1. fragment生命周期\n\nFragment is added\n |\nonAttach\nonCreate\nonCreateView\nonActivityCreated\nonStart\nonResume\n ||\nFragment is active\n ||\nonPause\nonStop\nonDestroyView\nonDestroy\nonDetach\n|||\nFragment is destroyed\n\n##### 2.2.1.1.1. 生命周期分析\n1. 当一个fragment被创建的时候，它会经历以下状态.\n\nonAttach()\nonCreate()\nonCreateView()\nonActivityCreated()\n\n2. 当这个fragment对用户可见的时候，它会经历以下状态。\n\nonStart()\nonResume()\n\n3. 当这个fragment进入“后台模式”的时候，它会经历以下状态。\n\nonPause()\nonStop()\n\n4. 当这个fragment被销毁了（或者持有它的activity被销毁了），它会经历以下状态。\n\nonPause()\nonStop()\nonDestroyView()\nonDestroy() // 本来漏掉类这个回调，感谢xiangxue336提出。\nonDetach()\n\n5. 就像activities一样，在以下的状态中，可以使用Bundle对象保存一个fragment的对象。\n\nonCreate()\nonCreateView()\nonActivityCreated()\n\n6. fragments的大部分状态都和activitie很相似，但fragment有一些新的状态。\n\n`onAttached()` —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。\n`onCreateView()` —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。\n`onActivityCreated()` —— 当activity的onCreated()方法返回后调用此方法\n`onDestroyView()` —— 当fragment中的视图被移除的时候，调用这个方法。\n`onDetach() `—— 当fragment和activity分离的时候，调用这个方法。\n\n> 一旦activity进入resumed状态（也就是running状态），你就可以自由地添加和删除fragment了。因此，只有当activity在resumed状态时，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。\n\n#### 2.2.1.2. saveFragment onCreateView 填充布局\n\n```java\n\n    public View onCreateView(\n            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        final Context context = inflater.getContext();\n        // 真正的布局文件在这里   fragment_save  DocumentsUI/res/layout/fragment_save.xml\n        final View view = inflater.inflate(R.layout.fragment_save, container, false);\n\n        // 初始化相关控件\n\n        final ImageView icon = (ImageView) view.findViewById(android.R.id.icon);\n        icon.setImageDrawable(\n                IconUtils.loadMimeIcon(context, getArguments().getString(EXTRA_MIME_TYPE)));\n\n        mDisplayName = (EditText) view.findViewById(android.R.id.title);\n        mDisplayName.addTextChangedListener(mDisplayNameWatcher);\n        mDisplayName.setText(getArguments().getString(EXTRA_DISPLAY_NAME));\n        mDisplayName.setOnKeyListener(\n                new View.OnKeyListener() {\n                    @Override\n                    public boolean onKey(View v, int keyCode, KeyEvent event) {\n                        ....\n\n                        if (keyCode == KeyEvent.KEYCODE_ENTER && mSave.isEnabled()) {\n                            // 按键处理\n                            performSave();\n\n                            private void performSave() {\n                                // 如果在上面选中了某文件, 表示要覆盖某文件, 这里直接替换对应的目标\n                                if (mReplaceTarget != null) {\n                                    mInjector.actions.saveDocument(getChildFragmentManager(), mReplaceTarget);\n                                } else {\n                                    // 这里代表新建文件\n                                    final String mimeType = getArguments().getString(EXTRA_MIME_TYPE);\n                                    final String displayName = mDisplayName.getText().toString();\n                                    // 最终调用到mInjector.actions.saveDocument方法保存文档\n                                    mInjector.actions.saveDocument(mimeType, displayName, mInProgressStateListener);\n                                }\n                            }\n\n\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        mSave = (TextView) view.findViewById(android.R.id.button1);\n        mSave.setOnClickListener(mSaveListener);\n        mSave.setEnabled(false);\n        ...\n\n        return view;\n    }\n\n```\n\n#### 2.2.1.3. saveFragment 保存文件\n\n在点击save时, 最终调用到 mInjector.actions.saveDocument, 新建一个 CreatePickedDocumentTask (继承AsyncTask)\n通过AsyncTask机制, 异步执行getExecutorForCurrentDirectory方法, 执行完成后回调主线程的`onPickFinished`方法\npickActivity关联的初始executor为前面初始ActionHandler时的 ProviderExecutor::forAuthority\n\n```java\n    void saveDocument(\n            String mimeType, String displayName, BooleanConsumer inProgressStateListener) {\n        assert(mState.action == ACTION_CREATE);\n        new CreatePickedDocumentTask(\n                mActivity,\n                mDocs,\n                mLastAccessed,\n                mState.stack,\n                mimeType,\n                displayName,\n                inProgressStateListener,\n                // 创建完成后会回调 onPickFinished 方法\n                this::onPickFinished)\n                .executeOnExecutor(getExecutorForCurrentDirectory());\n    }\n\n// 查找线程池, 找到线程池后执行对应线程池的executeOnExecutor方法.\n    private Executor getExecutorForCurrentDirectory() {\n        final DocumentInfo cwd = mState.stack.peek();\n        if (cwd != null && cwd.authority != null) {\n            // executor为前面初始ActionHandler时的 ProviderExecutor::forAuthority\n            // 这里涉及到java8的一种特性, 实际lookup函数会转向forAuthority函数里执行.\n            // 类似范型labda表达式的用法. 函数式接口, 方法映射 @FunctionalInterface\n            return mExecutors.lookup(cwd.authority);\n        } else {\n            return AsyncTask.THREAD_POOL_EXECUTOR;\n        }\n    }\n\n//这里最终执行CreatePickedDocumentTask的run方法, 至于具体的调用流程, 有待深究,借助AsyncTask的机制, 在其父类的\n// doInBackground  方法中调用了run方法.\n    @Override\n    protected Uri run(Void... params) {\n        DocumentInfo cwd = mStack.peek();\n        \n        // 此处的mDocs对象为Injector初始化时传入的,在BaseActivity onCreate时创建的\n        //  mDocs = DocumentsAccess.create(this); 对应 RuntimeDocumentAccess对象\n\n\n        Uri childUri = mDocs.createDocument(cwd, mMimeType, mDisplayName);\n\n            @Override\n            public Uri createDocument(DocumentInfo parentDoc, String mimeType, String displayName) {\n                final ContentResolver resolver = mContext.getContentResolver();\n                // client 对应与getAuthority对应的provider, 这里文档对象如果是外部存储的, 则对应ExternalStorageProvider\n                try (ContentProviderClient client = DocumentsApplication.acquireUnstableProviderOrThrow(\n                            resolver, parentDoc.derivedUri.getAuthority())) {\n                    1. return DocumentsContract.createDocument(\n                            client, parentDoc.derivedUri, mimeType, displayName);\n                } catch (Exception e) {\n                    Log.w(TAG, \"Failed to create document\", e);\n                    return null;\n                }\n            }\n\n        if (childUri != null) {\n            mLastAccessed.setLastAccessed(mOwner, mStack);\n        }\n\n        return childUri;\n    }\n\n```\n最终执行的方法是:\n\n```java\n                    return DocumentsContract.createDocument(\n                            client, parentDoc.derivedUri, mimeType, displayName);\n\n                                /** {@hide} */\n    public static Uri createDocument(ContentProviderClient client, Uri parentDocumentUri,\n            String mimeType, String displayName) throws RemoteException {\n        final Bundle in = new Bundle();\n        in.putParcelable(DocumentsContract.EXTRA_URI, parentDocumentUri);\n        in.putString(Document.COLUMN_MIME_TYPE, mimeType);\n        in.putString(Document.COLUMN_DISPLAY_NAME, displayName);\n        // 如果是ExternalStorageProvider会调到其对应的call方法中\n        > final Bundle out = client.call(METHOD_CREATE_DOCUMENT, null, in);\n        // 将provider创建完成的文件的完整uri取出来\n        return out.getParcelable(DocumentsContract.EXTRA_URI);\n    }\n```\n\n对应client对象, 该对象是通过 DocumentsApplication 的 静态函数acquireUnstableProviderOrThrow\n拿到的, 再往下追, 最终发现是ContextImpl的 内部类ApplicationContentResolver\n最终是通过调用ams对端的 getContentProvider( getApplicationThread(), auth, userId, stable);\n保存了一份客户端. 还要通过installProvider增加引用计数\n\n\n```java\n\n    DocumentsApplication.acquireUnstableProviderOrThrow(\n                            resolver, parentDoc.derivedUri.getAuthority())\n    public static ContentProviderClient acquireUnstableProviderOrThrow(\n            ContentResolver resolver, String authority) throws RemoteException {\n        final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(\n                authority);\n        if (client == null) {\n            throw new RemoteException(\"Failed to acquire provider for \" + authority);\n        }\n        client.setDetectNotResponding(PROVIDER_ANR_TIMEOUT);\n        return client;\n    }\n\n    public final @Nullable ContentProviderClient acquireUnstableContentProviderClient(\n            @NonNull String name) {\n        Preconditions.checkNotNull(name, \"name\");\n        IContentProvider provider = acquireUnstableProvider(name);\n        if (provider != null) {\n            return new ContentProviderClient(this, provider, false);\n        }\n\n        return null;\n    }\n\n    public final IContentProvider acquireUnstableProvider(String name) {\n        if (name == null) {\n            return null;\n        }\n        return acquireUnstableProvider(mContext, name);\n    }\n\n// 对应ContextImpl的内部类ApplicationContentResolver\n    // Activity内部的ContentResolver的初始化\n    mContentResolver = new ApplicationContentResolver(this, mainThread);\n\n    private static final class ApplicationContentResolver extends ContentResolver {\n        protected IContentProvider acquireUnstableProvider(Context c, String auth) {\n            return mMainThread.acquireProvider(c,\n                    ContentProvider.getAuthorityWithoutUserId(auth),\n                    resolveUserIdFromAuthority(auth), false);\n        }\n    }\n\n    public final IContentProvider acquireProvider(\n            Context c, String auth, int userId, boolean stable) {\n        final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);\n        if (provider != null) {\n            return provider;\n        }\n\n        ContentProviderHolder holder = null;\n        try {\n            holder = ActivityManager.getService().getContentProvider(\n                    getApplicationThread(), auth, userId, stable);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n\n\n        // Install provider will increment the reference count for us, and break\n        // any ties in the race.\n        holder = installProvider(c, holder, holder.info,\n                true /*noisy*/, holder.noReleaseNeeded, stable);\n        return holder.provider;\n    }\n\n```\n\n#### 2.2.1.4. provider端调用\n\n上面讲到了最终会执行到ams的getContentProvider拿到provider的ContentProviderHolder对象. 最终返回provider\nAms的 mProviderMap 以provider name(Authority)为key保存了provider的实例 ContentProviderRecord.\n\n\n找到ExternalStorageProvider后, 首先调用基类的call方法, 上面调用的是 `METHOD_CREATE_DOCUMENT`\n\nExternalStorageProvider -|> FileSystemProvider -|> DocumentsProvider\n\n```java\n    public static final String METHOD_CREATE_DOCUMENT = \"android:createDocument\";\n\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (!method.startsWith(\"android:\")) {\n            // Ignore non-platform methods\n            return super.call(method, arg, extras);\n        }\n\n        try {\n            return callUnchecked(method, arg, extras);\n        } catch (FileNotFoundException e) {\n            throw new ParcelableException(e);\n        }\n    }\n\n    private Bundle callUnchecked(String method, String arg, Bundle extras) {\n        else if (METHOD_CREATE_DOCUMENT.equals(method)) {\n            enforceWritePermissionInner(documentUri, getCallingPackage(), null);\n\n            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);\n            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);\n            // createDocument是子类FileSystemProvider实现的\n            final String newDocumentId = createDocument(documentId, mimeType, displayName);\n\n            // No need to issue new grants here, since caller either has\n            // manage permission or a prefix grant. We might generate a\n            // tree style URI if that's how they called us.\n            // 最后构造完整的uri\n            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri,\n                    newDocumentId);\n            // 将完整Uri 放在 DocumentsContract.EXTRA_URI中\n            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);\n        }\n    }\n```\n\n这里直接走的DocumentProvider的call`方法`, 并没有在子类ExternalStorageProvider处理.\n\ncreateDocument创建流程都是在provider进程中, provider进程会持有其管理目录的(读写访问等的)权限.\n创建完文件后, 通过buildDocumentUriMaybeUsingTree方法返回完整的`uri`. 由对端即发起方`client.call`取出uri.\n\n```java\n\n    public String createDocument(String docId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        displayName = FileUtils.buildValidFatFilename(displayName);\n        // 子类的getFileForDocId方法 查找或创建parent文件\n        final File parent = getFileForDocId(docId);\n        if (!parent.isDirectory()) {\n            throw new IllegalArgumentException(\"Parent document isn't a directory\");\n        }\n        // 创建文件\n        final File file = FileUtils.buildUniqueFile(parent, mimeType, displayName);\n        final String childId;\n        if (Document.MIME_TYPE_DIR.equals(mimeType)) {\n            // 如果是创建目录\n            if (!file.mkdir()) {\n                throw new IllegalStateException(\"Failed to mkdir \" + file);\n            }\n            // 最终返回的是docid, 即卷的rootid: + 相对path\n            childId = getDocIdForFile(file);\n            // 还要往MediaProvider中同步\n            addFolderToMediaStore(getFileForDocId(childId, true));\n        } else {\n            try {\n                if (!file.createNewFile()) {\n                    throw new IllegalStateException(\"Failed to touch \" + file);\n                }\n                childId = getDocIdForFile(file);\n            } catch (IOException e) {\n                throw new IllegalStateException(\"Failed to touch \" + file + \": \" + e);\n            }\n        }\n\n        return childId;\n    }\n    // ExtenalStorageProvider的buildFile创建 parent 文件\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        RootInfo root = getRootFromDocId(docId);\n        return buildFile(root, docId, visible);\n    }\n```\n\n\n\n### 2.2.2. application 分析\n\n上面看到了`DocumentsApplication`的相关调用, 这里说下相关的生命周期问题.\n应用可以自定义application, DocumentUi进程对应的**application**为自定义的DocumentApplication\n\n```xml\n    <application\n        android:name=\".DocumentsApplication\"\n        android:label=\"@string/app_label\"\n        android:icon=\"@drawable/app_icon\"   \n        android:supportsRtl=\"true\"\n        android:allowBackup=\"true\"\n        />\n```\n\n继承自Application, 复写`onCreate` `onTrimMemory`方法, 监听`package`变化. 如ACTION_PACKAGE_ADDED, 初始化\n\n mProviders = new ProvidersCache(this);\n\n```java\n    public ProvidersCache(Context context) {\n        mContext = context;\n        mObserver = new RootsChangedObserver();\n        // Create a new anonymous \"Recents\" RootInfo. It's a faker.\n        mRecentsRoot = new RootInfo() {{\n                // Special root for recents\n                derivedIcon = R.drawable.ic_root_recent;\n                derivedType = RootInfo.TYPE_RECENTS;\n                flags = Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_IS_CHILD;\n                title = mContext.getString(R.string.root_recent);\n                availableBytes = -1;\n            }};\n    }\n```\n\n这里涉及到onTrimMemory的地方:\n\n内存资源紧张时释放内存\n在应用生命周期的任何阶段 onTrimMemory() 回调方法都可以告诉你设备的内存越来越低的情况, 你可以根据该方法推送的内存紧张级别来释放资源.\n\n优先级从高到低, 需要释放资源的严重性由低到高\n\n- `TRIM_MEMORY_RUNNING_MODERATE`\n表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。\n\n- `TRIM_MEMORY_RUNNING_LOW`\n应用处于运行状态并且不会被杀掉, 设备可以使用的内存非常低, 可以把不用的资源释放一些提高性能(会直接影响程序的性能)\n\n- `TRIM_MEMORY_RUNNING_CRITICAL`\n应用处于运行状态但是系统已经把大多数缓存应用杀掉了, 你必须释放掉不是非常关键的资源, 如果系统不能回收足够的运行内存, 系统会清除所有缓存应用并且会把正在活动的应用杀掉.\n还有, 当你的应用被系统正缓存时, 通过 onTrimMemory() 回调方法可以收到以下几个内存级别:\n\n- `TRIM_MEMORY_UI_HIDDEN`\n表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键导致应用的UI界面不可见．这时候应该释放一些资源\n\n- `TRIM_MEMORY_BACKGROUND`\n系统处于低内存的运行状态中并且你的应用处于缓存应用列表的初级阶段.  虽然你的应用不会处于被杀的高风险中, 但是系统已经开始清除缓存列表中的其它应用, 所以你必须释放资源使你的应用继续存留在列表中以便用户再次回到你的应用时能快速恢复进行使用.\n\n- `TRIM_MEMORY_MODERATE`\n系统处于低内存的运行状态中并且你的应用处于缓存应用列表的中级阶段. 如果系运行内存收到限制, 你的应用有被杀掉的风险.\n\n- `TRIM_MEMORY_COMPLETE`\n系统处于低内存的运行状态中如果系统现在没有内存回收你的应用将会第一个被杀掉. 你必须释放掉所有非关键的资源从而恢复应用的状态.\n\n## 2.3. `ACTION_OPEN_DOCUMENT` 编辑文档相关调用分析\n\n在Picker ui的includeState对于ACTION_OPEN_DOCUMENT转化为action的ACTION_OPEN, setupLayout函数中, 对于ACTION_OPEN, 转到`RootsFragment`中.\n\nRootsFragment为DocumentUI的侧边栏, sidebar\n\n```java\n        if (Intent.ACTION_OPEN_DOCUMENT.equals(action)) {\n            state.action = ACTION_OPEN;\n        }\n else if (mState.action == ACTION_OPEN ||\n                   mState.action == ACTION_CREATE ||\n                   mState.action == ACTION_OPEN_TREE ||\n                   mState.action == ACTION_PICK_COPY_DESTINATION) {\n            RootsFragment.show(getFragmentManager(), (Intent) null);\n        }\n```\n\n这里还是用到了[fragment的生命周期分析](#生命周期分析),  在`onCreateView`函数中, 主要为布局相关的设置, 用到了ListView, 这里对该ListView添加了右键行为.\n\n```java\n        final View view = inflater.inflate(R.layout.fragment_roots, container, false);\n        mList = (ListView) view.findViewById(R.id.roots_list);\n        mList.setOnItemClickListener(mItemListener);\n```\n\n在`onActivityCreated`函数中, 添加了拖拽处理. 并初始化了Loader, 对应为`RootsLoader`, 复写其`onCreateLoader`/`onLoadFinished`/`onLoaderReset`方法, 跟RootsLoader关联的是`RootsAdapter`\n\n```java\nprivate LoaderCallbacks<Collection<RootInfo>> mCallbacks;\n```\n\n这里需要重新回顾一下Loader机制\n\n### 2.3.1. Loader机制\n\n在RootFragmenti中有进行Loader的相关调用,   作为客户端\n\n> 客户端触发Loader, 需调用LoaderManager的`initLoader`()或`restartLoader`(), 向这两个方法中传入一个LoaderCallbacks的实例。LoaderCallbacks有三个回调方法需要实现：`onCreateLoader`()、`onLoadFinished`()以及`onLoaderReset`()\n\n```java\n// fragment对用户可见的时候，它会经历 onStart onResume\n@Override\npublic void onResume() {\n    super.onResume();\n    onDisplayStateChanged();\n}\n\n    public void onDisplayStateChanged() {\n        final Context context = getActivity();\n        final State state = ((BaseActivity) context).getDisplayState();\n\n        if (state.action == State.ACTION_GET_CONTENT) {\n            mList.setOnItemLongClickListener(mItemLongClickListener);\n        } else {\n            mList.setOnItemLongClickListener(null);\n            mList.setLongClickable(false);\n        }\n        // 触发Loader  执行\n        getLoaderManager().restartLoader(2, null, mCallbacks);\n    }\n```\n\n### 2.3.2. `restartLoader`调用\n\n调用这个方法，将会重新创建一个指定ID的Loader，如果当前已经有一个和这个ID关联的Loader，那么会对它进行canceled/stopped/destroyed等操作，之后，使用新传入的Bundle参数来创建一个新的Loader，并在数据加载完毕后递交给调用者。并且，在调用完这个函数之后，所有`之前和这个ID关联的Loader`都会失效，我们将不会收到它们传递过来的任何数据。\n\n即使之前的loader关联的失效, 并构建新的loader. 先不考虑使之前loader失效的情况, 只考虑创建新loader的情况:\n\n调用过程:\n\nLoaderManager.createLoader() -> \n`LoaderCallbacks.onCreateLoader()` -> \n得到loader之后创建LoaderInfo -> \nLoaderManager.installLoader() -> \n将其放入LoaderManager内部维护的mLoaders数组中 -> \nLoaderInfo.start() -> \nLoader处于`started`状态 -> \n`Loader.startLoading() ->Loader.onStartLoading()`\n\n```java\npublic Loader<Collection<RootInfo>> onCreateLoader(int id, Bundle args) {\n    return new RootsLoader(activity, providers, state);\n}\n\n    String BROADCAST_ACTION = \"com.android.documentsui.action.ROOT_CHANGED\";\n\n    public RootsLoader(Context context, ProvidersCache providers, State state) {\n        super(context);\n        mProviders = providers;\n        mState = state;\n  // BROADCAST_ACTION是在ProviderCache的doInBackground中发送的, 这个更新是由前面介绍的 DocumentApplication的监听package变化触发的.\n        LocalBroadcastManager.getInstance(context).registerReceiver(\n                mReceiver, new IntentFilter(ProvidersAccess.BROADCAST_ACTION));\n    }\n\n    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            onContentChanged();\n        }\n    };\n\n    public void onContentChanged() {\n        if (mStarted) {\n            forceLoad();\n        } else {\n            mContentChanged = true;\n        }\n    }\n\n    @Override\n    protected void onStartLoading() {\n        if (mResult != null) {\n            // 通知loader更新, 触发LoaderCallback 的onLoadFinished.\n            deliverResult(mResult);\n        }\n        // 查询mContentChanged的状态\n        if (takeContentChanged() || mResult == null) {\n            // 在mContentChanged为true时, 需要forceLoad, 该forceLoad会异步加载数据\n            forceLoad();\n        }\n    }\n\n    @Override\n    public void deliverResult(Collection<RootInfo> result) {\n        if (isReset()) {\n            return;\n        }\n\n        mResult = result;\n        // 通知loader更新, 触发LoaderCallback 的onLoadFinished.\n        if (isStarted()) {\n            super.deliverResult(result);\n        }\n    }\n```\n\nLoader在`started`状态下，Loader应该监控数据源的变化，并将新数据发送给客户端\n\n> 具体来说就是当监控到新数据后，调用Loader.deliverResult()方法，触发LoadCallbacks.onLoadFinished()回调的执行，从而客户端可以从该回调中轻松获取数据。\n\n上面在`onStartLoading`中, 一般用法是先调用Loader.deliverResult()方法，触发LoadCallbacks.`onLoadFinished`()回调的执行, 另一方面异步执行load数据. \n\n在该处, 调用forceLoad: , 注意RootsLoader继承AsyncTaskLoader\n\n```java\n    public void forceLoad() {\n        onForceLoad();\n    }\n// AsyncTaskLoader\n    protected void onForceLoad() {\n        super.onForceLoad();\n        cancelLoad();\n        mTask = new LoadTask();\n        if (DEBUG) Log.v(TAG, \"Preparing load: mTask=\" + mTask);\n        executePendingTask();\n    }\n\nfinal class LoadTask extends AsyncTask<Void, Void, D> implements Runnable {\n        private final CountDownLatch mDone = new CountDownLatch(1);\n\n        @Override\n        protected D doInBackground(Void... params) {\n            if (DEBUG) Log.v(TAG, this + \" >>> doInBackground\");\n            try {\n                // 跑到子类中, 即RootsLoader中\n       1.         D data = AsyncTaskLoader.this.onLoadInBackground();\n                return data;\n            } \n        }\n}\n\n    protected D onLoadInBackground() {\n    1.2    return loadInBackground();\n    }\n\n1.3  //执行到RootsLoader中, 返回Collection<RootInfo>数据.\n        @Override\n    public final Collection<RootInfo> loadInBackground() {\n        return mProviders.getMatchingRootsBlocking(mState);\n    }\n```\n\nAsyncTask执行完成后, 会在主线程中执行`onPostExecute`方法, 正常情况下又会调用LoaderCallback的`onLoadFinished`, 即load完数据后,  通知数据更新的机制.\n\n```java\n        protected void onPostExecute(D data) {\n            if (DEBUG) Log.v(TAG, this + \" onPostExecute\");\n            try {\n                1. AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);\n            } finally {\n                mDone.countDown();\n            }\n        }\n\n    void dispatchOnLoadComplete(LoadTask task, D data) {\n        if (mTask != task) {\n            if (DEBUG) Log.v(TAG, \"Load complete of old task, trying to cancel\");\n            dispatchOnCancelled(task, data);\n        } else {\n            if (isAbandoned()) {\n                // This cursor has been abandoned; just cancel the new data.\n                onCanceled(data);\n            } else {\n                commitContentChanged();\n                mLastLoadCompleteTime = SystemClock.uptimeMillis();\n                mTask = null;\n                if (DEBUG) Log.v(TAG, \"Delivering result\");\n                // 这个地方再次走到子类的deliverResult, 由会调用LoaderCallback的onLoadFinished回调\n                2. deliverResult(data);\n            }\n        }\n    }\n```\n\n下面重点看下RootsLoader 对应的LoaderCallback的`onLoadFinished`方法, 数据的来源是`mProviders.getMatchingRootsBlocking(mState);` 查看下相关流程:\n\n```java\n    @Override\n    public Collection<RootInfo> getMatchingRootsBlocking(State state) {\n        waitForFirstLoad();\n        loadStoppedAuthorities();\n        synchronized (mLock) {\n            return ProvidersAccess.getMatchingRoots(mRoots.values(), state);\n        }\n    }\n\npublic static List<RootInfo> getMatchingRoots(Collection<RootInfo> roots, State state) {\n    // ... 前面有一堆的判断条件, 根据state和root的状态判断是否要忽略一些root\n    matching.add(root);\n    return matching;\n}\n\n/* 前面root的来源需要看下, state是RootFragment初始化时传入的*/\n// 还是来源于DocumentApplication 监听package变化, 导致的UpdateTask\n// mRoot = mTaskRoots\n\n        protected Void doInBackground(Void... params) {\n            final long start = SystemClock.elapsedRealtime();\n            // 先加入RecentRoot  \n            mTaskRoots.put(mRecentsRoot.authority, mRecentsRoot);\n\n            final PackageManager pm = mContext.getPackageManager();\n\n            // Pick up provider with action string\n            // 查询 PROVIDER_INTERFACE \"android.content.action.DOCUMENTS_PROVIDER\" 的action , Manifest中定义, provider定义, 存活的provider, 比如ExternalStorageProvider, 通过pm查询.\n            final Intent intent = new Intent(DocumentsContract.PROVIDER_INTERFACE);\n            final List<ResolveInfo> providers = pm.queryIntentContentProviders(intent, 0);\n            for (ResolveInfo info : providers) {\n                ProviderInfo providerInfo = info.providerInfo;\n                if (providerInfo.authority != null) {\n                   1.  handleDocumentsProvider(providerInfo);\n                }\n            }\n            // 发送ContentChanged, 前面说过, 会影响一个标志位\n            LocalBroadcastManager.getInstance(mContext).sendBroadcast(new Intent(BROADCAST_ACTION));\n            return null;\n        }\n\n1.1     \n      private void handleDocumentsProvider(ProviderInfo info) {\n            // Ignore stopped packages for now; we might query them\n            // later during UI interaction.\n    //忽略Stopped的provider\n            if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {\n                if (VERBOSE) Log.v(TAG, \"Ignoring stopped authority \" + info.authority);\n                mTaskStoppedAuthorities.add(info.authority);\n                return;\n            }\n// 这里有个需要注意的地方   loadRootsForAuthority, 后面需要再深入/\n            final boolean forceRefresh = mForceRefreshAll\n                    || Objects.equals(info.packageName, mForceRefreshPackage);\n            mTaskRoots.putAll(info.authority, loadRootsForAuthority(mContext.getContentResolver(),\n                    info.authority, forceRefresh));\n        }\n\n2. 加载完roots信息后, 通知客户端RootsFragment更新.\n\t\t\t@Override\n            public void onLoadFinished(\n                    Loader<Collection<RootInfo>> loader, Collection<RootInfo> roots) {\n\n...\n                List<Item> sortedItems =\n                        sortLoadResult(roots, excludePackage, handlerAppIntent);\n    // 指定关联的Adapter, RootsAdapter 绑定到 mList ListView中, MVC模式\n                mAdapter = new RootsAdapter(activity, sortedItems, mDragListener);\n                mList.setAdapter(mAdapter);\n\n                mInjector.shortcutsUpdater.accept(roots);\n                onCurrentRootChanged();\n            }\n```\n\nRootFragment的更新都是通过`restartLoader`调用触发`forceLoad`过程更新数据随后更新视图. 如点击menu的 \"Show Internal Storage\"进行的更新动作.\n\n### 2.3.3. RootsLoader 关联的 RootsAdapter\n\n#### 2.3.3.1. mvc框架\n\n根据MVC模式(model-view-Controller), Adapter处理视图上的数据显示, 处于Controller层\n\n- model(模型层)\n\n  保持程序的数据状态, 如数据存储, 网络请求等. 与相应的view有一定的耦合, 通过某种事件机制通知view的状态更新, 还会接收Controller的事件\n\n  此例子中  RootsLoader 管理的 RootItem数据为model.\n\n- view(视图层)\n\n  GUI组件, 响应用户的交互行为并触发Controller的逻辑, 还可能通过在Model中注册事件监听model的改变, 以此刷新并展示给用户.  \n\n  此例子中为ListView\n\n- Controller(控制器)\n\n  控制器由View根据用户行为触发并响应View的用户交互, 通过修改model并由model的事件机制来触发view更新.\n\n  此例子中为RootsAdapter\n\n\n\n![Adapter](/images/Adapter.jpg)\n\n\n\nAdapter是连接后端数据和前端显示的适配器接口，是数据和UI（View）之间一个重要的纽带。在常见的View(ListView,GridView)等地方都需要用到Adapter。\n\n[Adapter官方文档](https://developer.android.com/reference/android/widget/Adapter)\n\nRootsAdapter --|>  ArrayAdapter -->BaseAdapter\n\n此处数据是一次性添加的, 每次RootsItem数据变化时, 最后都是调用OnloadFinished方法重新初始化RootsAdapter的.\n\n这里只用到了getView方法, 这里的Apdater是比较简单的\n\n#### 2.3.3.2. 需要关注 RootItem\n\nRootItem作为model层, 通过bindView 关联到 item view层\n\n```java\n    public RootItem(RootInfo root, ActionHandler actionHandler) {\n        // 通过构造函数传入布局id\n        super(R.layout.item_root, getStringId(root));\n        this.root = root;\n        mActionHandler = actionHandler;\n    }\n// bindView 的参数 convertView 来自于构造函数中的mLayoutId 即 R.layout.item_root\n            convertView = LayoutInflater.from(parent.getContext())\n                    .inflate(mLayoutId, parent, false);\npublic void bindView(View convertView) {\n}\n```\n\n每个Item 最终组成List 填充到RootAdapter中\n\n```java\n        final List<RootItem> libraries = new ArrayList<>();\n        final List<RootItem> others = new ArrayList<>();\n        for (final RootInfo root : roots) {\n            final RootItem item = new RootItem(root, mActionHandler);\n\n            Activity activity = getActivity();\n            if (root.isHome() && !Shared.shouldShowDocumentsRoot(activity)) {\n                continue;\n            } else if (root.isLibrary()) {\n                libraries.add(item);\n            } else {\n                others.add(item);\n            }\n        }\n\n       List<Item> sortedItems =\n                        sortLoadResult(roots, excludePackage, handlerAppIntent);\n       mAdapter = new RootsAdapter(activity, sortedItems, mDragListener);\nmList.setAdapter(mAdapter);\n\n// 对于item的访问可以见下面\n    public void onCurrentRootChanged() {\n        if (mAdapter == null) {\n            return;\n        }\n\n        final RootInfo root = ((BaseActivity) getActivity()).getCurrentRoot();\n        for (int i = 0; i < mAdapter.getCount(); i++) {\n            // getItem\n            final Object item = mAdapter.getItem(i);\n            if (item instanceof RootItem) {\n                final RootInfo testRoot = ((RootItem) item).root;\n                if (Objects.equals(testRoot, root)) {\n                    // 比对item的root信息跟当前的需要展示的root信息是否一致, 一致则指定选中状态.\n                    mList.setItemChecked(i, true);\n                    return;\n                }\n            }\n        }\n    }\n```\n\n## 2.4. DirectoryFragment\n\n前面讲完了RootFragment和SaveFragment, 对应侧边栏和下边栏, 但Document最主要的部分还是中间的内容部分, 即DirectoryFragment.\n\n此处通过RootsFragment的item的点击事件往下追.\n\n```java\n    private final OnItemClickListener mItemListener = new OnItemClickListener() {\n        @Override\n        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            final Item item = mAdapter.getItem(position);\n            item.open();\n\n            getBaseActivity().setRootsDrawerOpen(false);\n        }\n    };\n\n//RootItem\n\n    @Override\n    void open() {\n        mActionHandler.openRoot(root);\n    }\n\nfinal RootItem item = new RootItem(root, mActionHandler);\n\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        mActionHandler = mInjector.actions;\n    }\n\n// RootFragment 存活在Activity中,  如果是通过PickActivity进来的, mInjector就是PickActivity的.\nmInjector = getBaseActivity().getInjector();\n\n// picker/ActionHandler.java\n    @Override\n    public void openRoot(RootInfo root) {\n        Metrics.logRootVisited(mActivity, Metrics.PICKER_SCOPE, root);\n        mActivity.onRootPicked(root);\n    }\n\n// mActivity 指向 pickActivity, 第一个参数\n        mInjector.actions = new ActionHandler<>(\n                this,\n                mState,\n                mProviders,\n                mDocs,\n                mSearchManager,\n                ProviderExecutor::forAuthority,\n                mInjector,\n                mLastAccessed);\n\nclass PickActivity extends BaseActivity implements ActionHandler.Addons\n\nabstract class BaseActivity extends Activity implements CommonAddons\n\n// onRootPicked是CommonAddons的接口, 在BaseActivity中实现\n\n    @Override\n    public void onRootPicked(RootInfo root) {\n        // Clicking on the current root removes search\n        mSearchManager.cancelSearch();\n\n        mInjector.actionModeController.finishActionMode();\n        mSortController.onViewModeChanged(mState.derivedMode);\n\n        // Set summary header's visibility. Only recents and downloads root may have summary in\n        // their docs.\n        mState.sortModel.setDimensionVisibility(\n                SortModel.SORT_DIMENSION_ID_SUMMARY,\n                root.isRecents() || root.isDownloads() ? View.VISIBLE : View.INVISIBLE);\n\n        // Clear entire backstack and start in new root\n        mState.stack.changeRoot(root);\n\n        // Recents is always in memory, so we just load it directly.\n        // Otherwise we delegate loading data from disk to a task\n        // to ensure a responsive ui.\n        \n        // recents在内存中, 直接显示. 最近项\n        if (mProviders.isRecentsRoot(root)) {\n            refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n        } else {\n1.        // 一般是下面这项, 走getRootDocument\n            mInjector.actions.getRootDocument(\n                    root,\n                    TimeoutTask.DEFAULT_TIMEOUT,\n2.                    doc -> mInjector.actions.openRootDocument(doc));\n        }\n    }\n    \n1. ->  // 进到了AbstractActionHandler中\n    @Override\n    public void getRootDocument(RootInfo root, int timeout, Consumer<DocumentInfo> callback) {\n        GetRootDocumentTask task = new GetRootDocumentTask(\n                root,\n                mActivity,\n                timeout,\n                mDocs,\n                callback);\n\n        task.executeOnExecutor(mExecutors.lookup(root.authority));\n    }\n  2. -> // 在找到docmentinfo后, 执行mInjector.actions.openRootDocument(doc)\n\n// 1 和 2中间的步骤是构建了一个GetRootDocumentTask, 通过authority 找到excutor, 请查看前面的ProviderExecutor::forAuthority\n      \n   public static ProviderExecutor forAuthority(String authority) {\n        synchronized (sExecutors) {\n            ProviderExecutor executor = sExecutors.get(authority);\n            if (executor == null) {\n                executor = new ProviderExecutor();\n                executor.setName(\"ProviderExecutor: \" + authority);\n                // 执行start方法.\n                executor.start();\n                // 以authority为key, 保存了一个executor实例到sExecutors池中.\n                sExecutors.put(authority, executor);\n            }\n            return executor;\n        }\n    }\n\n// 执行 GetRootDocumentTask的run方法\n\n    @Override\n    public @Nullable DocumentInfo run(Void... args) {\n        return mDocs.getRootDocument(mRootInfo);\n    }\n// mDoc为DocumentsAccess的接口, 实现在RuntimeDocumentAccess类中\n\n        public @Nullable DocumentInfo getRootDocument(RootInfo root) {\n            // 构建root的完整uri \n            return getDocument(\n                    DocumentsContract.buildDocumentUri(root.authority, root.documentId));\n        }\n\n        @Override\n        public @Nullable DocumentInfo getDocument(Uri uri) {\n            try {\n3.                return DocumentInfo.fromUri(mContext.getContentResolver(), uri);\n            } \n        }\n3. -> // 进入 DocumentInfo类中, 构建DocumentInfo\n    \n        public static DocumentInfo fromUri(ContentResolver resolver, Uri uri)\n            throws FileNotFoundException {\n        final DocumentInfo info = new DocumentInfo();\n        info.updateFromUri(resolver, uri);\n        return info;\n    }\n\n    public void updateFromUri(ContentResolver resolver, Uri uri) throws FileNotFoundException {\n        ContentProviderClient client = null;\n        Cursor cursor = null;\n        try {\n            // 找到对端provider实例\n            client = DocumentsApplication.acquireUnstableProviderOrThrow(\n                    resolver, uri.getAuthority());\n            // 查询root下的内容,保存到cursor中\n            cursor = client.query(uri, null, null, null, null);\n            if (!cursor.moveToFirst()) {\n                throw new FileNotFoundException(\"Missing details for \" + uri);\n            }\n3.1            updateFromCursor(cursor, uri.getAuthority());\n        } catch (Throwable t) {\n            throw asFileNotFoundException(t);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            ContentProviderClient.releaseQuietly(client);\n        }\n    }\n\n3.1 -> // updateFromCursor根据provider查到的内容填充DocumentInfo\n    \n    public void updateFromCursor(Cursor cursor, String authority) {\n        this.authority = authority;\n        this.documentId = getCursorString(cursor, Document.COLUMN_DOCUMENT_ID);\n        this.mimeType = getCursorString(cursor, Document.COLUMN_MIME_TYPE);\n        this.displayName = getCursorString(cursor, Document.COLUMN_DISPLAY_NAME);\n        this.lastModified = getCursorLong(cursor, Document.COLUMN_LAST_MODIFIED);\n        this.flags = getCursorInt(cursor, Document.COLUMN_FLAGS);\n        this.summary = getCursorString(cursor, Document.COLUMN_SUMMARY);\n        this.size = getCursorLong(cursor, Document.COLUMN_SIZE);\n        this.icon = getCursorInt(cursor, Document.COLUMN_ICON);\n        this.deriveFields();\n    }\n\n2. -> // 在有了DocumentInfo数据后, 最终执行mInjector.actions.openRootDocument(doc)\n   在AbstractHandler中执行\n   \n       @Override\n    public void openRootDocument(@Nullable DocumentInfo rootDoc) {\n        if (rootDoc == null) {\n            // There are 2 cases where rootDoc is null -- 1) loading recents; 2) failed to load root\n            // document. Either case we should call refreshCurrentRootAndDirectory() to let\n            // DirectoryFragment update UI.\n            mActivity.refreshCurrentRootAndDirectory(AnimationView.ANIM_NONE);\n        } else {\n        // 不为空, 打开rootdoc.\n      4.      openContainerDocument(rootDoc);\n        }\n    }\n    \n4. ->  // 打开rootdoc\n        @Override\n    public void openContainerDocument(DocumentInfo doc) {\n        assert(doc.isContainer());\n\n        if (mSearchMgr.isSearching()) {\n            loadDocument(\n                    doc.derivedUri,\n                    (@Nullable DocumentStack stack) -> openFolderInSearchResult(stack, doc));\n        } else {\n            // 一般进行下面这项\n            openChildContainer(doc);\n        }\n    }\n\n\n    private void openChildContainer(DocumentInfo doc) {\n        DocumentInfo currentDoc = null;\n        // 一般情况下为目录\n        if (doc.isDirectory()) {\n            // Regular directory.\n            currentDoc = doc;\n        } else if (doc.isArchive()) {\n            // Archive.\n            currentDoc = mDocs.getArchiveDocument(doc.derivedUri);\n        }\n\n        assert(currentDoc != null);\n        mActivity.notifyDirectoryNavigated(currentDoc.derivedUri);\n\n        mState.stack.push(currentDoc);\n        // Show an opening animation only if pressing \"back\" would get us back to the\n        // previous directory. Especially after opening a root document, pressing\n        // back, wouldn't go to the previous root, but close the activity.\n        // 在前面的stack push后, locationChanged, AnimationView.ANIM_ENTER\n        final int anim = (mState.stack.hasLocationChanged() && mState.stack.size() > 1)\n                ? AnimationView.ANIM_ENTER : AnimationView.ANIM_NONE;\n        // 最终执行 refreshCurrentRootAndDirectory(AnimationView.ANIM_ENTER)\n       5. mActivity.refreshCurrentRootAndDirectory(anim);\n    }\n\n5. -> // 刷新页面, refreshCurrentRootAndDirectory为CommonAddons的回调, 进到BaseActivity下\n    \n    \n    public final void refreshCurrentRootAndDirectory(int anim) {\n        mSearchManager.cancelSearch();\n        // 根据工具栏的设置是显示列表还是表格\n        mState.derivedMode = LocalPreferences.getViewMode(this, mState.stack.getRoot(), MODE_GRID);\n\n        6. //  最主要的木的是刷新目录\n        refreshDirectory(anim);\n\n        final RootsFragment roots = RootsFragment.get(getFragmentManager());\n        if (roots != null) {\n            // 设置RootFragment的item的选中状态\n            roots.onCurrentRootChanged();\n        }\n        // 导航栏更新\n        mNavigator.update();\n\n        // Causes talkback to announce the activity's new title\n    // 标题栏表更\n        setTitle(mState.stack.getTitle());\n        // 菜单项更新.\n        invalidateOptionsMenu();\n    }\n   \n6. -> // refreshDirectory 为具体的实现类, 如果是通过pickActivity进来的, 则是他的.\n    \n     protected void refreshDirectory(int anim) {\n        final FragmentManager fm = getFragmentManager();\n        final RootInfo root = getCurrentRoot();\n        final DocumentInfo cwd = getCurrentDirectory();\n        // 如果是最近 item, 展示\n        if (mState.stack.isRecents()) {\n            DirectoryFragment.showRecentsOpen(fm, anim);\n\n            // In recents we pick layout mode based on the mimetype,\n            // picking GRID for visual types. We intentionally don't\n            // consult a user's saved preferences here since they are\n            // set per root (not per root and per mimetype).\n            boolean visualMimes = MimeTypes.mimeMatches(\n                    MimeTypes.VISUAL_MIMES, mState.acceptMimes);\n            mState.derivedMode = visualMimes ? State.MODE_GRID : State.MODE_LIST;\n        } else {\n                // Normal boring directory\n            // 一般是这项, 需要展示root 的内容\n 7.               DirectoryFragment.showDirectory(fm, root, cwd, anim);\n        }\n\n        // Forget any replacement target\n        if (mState.action == ACTION_CREATE) {\n            final SaveFragment save = SaveFragment.get(fm);\n            if (save != null) {\n                save.setReplaceTarget(null);\n            }\n        }\n\n        if (mState.action == ACTION_OPEN_TREE ||\n            mState.action == ACTION_PICK_COPY_DESTINATION) {\n            final PickFragment pick = PickFragment.get(fm);\n            if (pick != null) {\n                pick.setPickTarget(mState.action, mState.copyOperationSubType, cwd);\n            }\n        }\n    }\n```\n\n在上述流程中, 最终走到了DirectoryFragment里.\n\n这里总结下相关的接口类的情况, 见下图\n\n![DocumentUI](/images/DocumentUI.png)\n\n### 2.4.1. DirectoryFragment 展示root内容\n\n```java\n    public static void showDirectory(\n            FragmentManager fm, RootInfo root, DocumentInfo doc, int anim) {\n        create(fm, root, doc, anim);\n    }\n```\n\n这里创建了DirectoryFragment,  会进入DirectoryFragment的生命周期, [参考生命周期](#fragment生命周期), 会接着进入下面几个回调中:\n\n```java\n    public View onCreateView(\n            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\n        mActivity = (BaseActivity) getActivity();\n        // 使用RecyclerView的布局\n        final View view = inflater.inflate(R.layout.fragment_directory, container, false);\n\n        mProgressBar = view.findViewById(R.id.progressbar);\n        assert mProgressBar != null;\n\n        mRecView = (RecyclerView) view.findViewById(R.id.dir_list);\n        mRecView.setRecyclerListener(\n                new RecyclerListener() {\n                    @Override\n                    // 当item被回收的时候回调\n                    public void onViewRecycled(ViewHolder holder) {\n                        cancelThumbnailTask(holder.itemView);\n                    }\n                });\n\n        // RecyclerView的父布局\n        mRefreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.refresh_layout);\n        mRefreshLayout.setOnRefreshListener(this);\n        mRecView.setItemAnimator(new DirectoryItemAnimator(mActivity));\n\n        // pickActivity的 mInjector\n        mInjector = mActivity.getInjector();\n        mModel = mInjector.getModel();\n        // model初始化\n        mModel.reset();\n        // 显示内容变更时, 回调mOnDisplayStateChanged\n        private final Runnable mOnDisplayStateChanged = this::onDisplayStateChanged;\n        private void onDisplayStateChanged() {\n            updateLayout(mState.derivedMode);\n            // 重新绑定adapter\n            mRecView.setAdapter(mAdapter);\n        }\n        mInjector.actions.registerDisplayStateChangedListener(mOnDisplayStateChanged);\n        // 剪贴板\n        mClipper = DocumentsApplication.getDocumentClipper(getContext());\n        // 拖拽相关\n        if (mInjector.config.dragAndDropEnabled()) {\n            DirectoryDragListener listener = new DirectoryDragListener(\n                    new DragHost<>(\n                            mActivity,\n                            DocumentsApplication.getDragAndDropManager(mActivity),\n                            mInjector.selectionMgr,\n                            mInjector.actions,\n                            mActivity.getDisplayState(),\n                            mInjector.dialogs,\n                            (View v) -> {\n                                return getModelId(v) != null;\n                            },\n                            this::getDocumentHolder,\n                            this::getDestination\n                    ));\n            mDragHoverListener = DragHoverListener.create(listener, mRecView);\n        }\n        // Make the recycler and the empty views responsive to drop events when allowed.\n        mRecView.setOnDragListener(mDragHoverListener);\n        return view;\n    }\n```\n\n绑定了model对象,  可以把model理解为`DirectoryFragment`对象的model数;据对象,  恰恰是mvc框架中的 [model](#mvc框架) 模型层\n\n```java\n/**\n * The data model for the current loaded directory.\n */\n```\n\n接着进到onActivityCreated中\n\n```java\npublic void onActivityCreated(Bundle savedInstanceState) { \n// 判断调用状态, 前面的includeState\n\tmState = mActivity.getDisplayState();\n    // 初始化DirectoryFragment传入参数\n    mLocalState.restore(args);\n    // RecyclerView绑定的Adapter, 这个地方使用了代理模式, 真正干活的是ModelBackedDocumentsAdapter\n    mAdapter = new DirectoryAddonsAdapter(\n                mAdapterEnv,\n                new ModelBackedDocumentsAdapter(mAdapterEnv, mIconHelper, mInjector.fileTypeLookup)\n        );\n    // 绑定到RecyclerView\n    mRecView.setAdapter(mAdapter);\n    // 布局相关的管理\n    mLayout = new GridLayoutManager(getContext(), mColumnCount) {\n            @Override\n            public void onLayoutCompleted(RecyclerView.State state) {\n                super.onLayoutCompleted(state);\n                mFocusManager.onLayoutCompleted();\n            }\n     };\n    mRecView.setLayoutManager(mLayout);\n    // 添加两个回调, 在调用model的notifyUpdateListeners方法时, 会回调这两个监听的accept方法, 对应model数据更新时的动作\n    \n    mModel.addUpdateListener(mAdapter.getModelUpdateListener());\n    mModel.addUpdateListener(mModelUpdateListener);\n    mActions = mInjector.getActionHandler(mContentLock);\n    // 选择管理器\n    mSelectionMgr = mInjector.getSelectionManager(mAdapter, selectionPredicate);\n    // 选择数据\n    mSelectionMetadata = new SelectionMetadata(mModel::getItem);\n    // 继承SelectionObserver抽象类, 订阅, 回调相应的方法, 回调在DefaultSelectionHelper 中, 工厂模式, mSelectionMetadata继承SelectionObserver,此处继承的方法为onItemStateChanged\n    mSelectionMgr.addObserver(mSelectionMetadata);\n    // item详情页面查找\n    mDetailsLookup = new DocsItemDetailsLookup(mRecView);\n    // 回调onActionItemClicked时, menu click 会执行handleMenuItemClick方法. java8 函数式接口\n    mActionModeController = mInjector.getActionModeController(\n        mSelectionMetadata,\n        this::handleMenuItemClick);\n    //又添加了监听, item动作回调\n    mSelectionMgr.addObserver(mActionModeController);\n            // Kick off loader at least once, 调用AbstractActionHandler中的\n    1. mActions.loadDocumentsForCurrentStack();    \n}\n\n1. -> // \n    \n    public void loadDocumentsForCurrentStack() {\n        DocumentStack stack = mState.stack;\n        if (!stack.isRecents() && stack.isEmpty()) {\n              .... //非正常情况\n        }\n\n        mActivity.getLoaderManager().restartLoader(LOADER_ID, null, mBindings);\n    }\n```\n\n调用restartLoader后进入了Loader的流程\n\nmBindings绑定的Loader为DirectoryLoader, 正是在onCreateLoader返回的.\n\n```java\n        public Loader<DirectoryResult> onCreateLoader(int id, Bundle args) {\n            Context context = mActivity;\n\n            if (mState.stack.isRecents()) {\n                // 对应最近item\n                if (DEBUG) Log.d(TAG, \"Creating new loader recents.\");\n                return new RecentsLoader(\n                        context,\n                        mProviders,\n                        mState,\n                        mInjector.features,\n                        mExecutors,\n                        mInjector.fileTypeLookup);\n            } else {\n\n                Uri contentsUri = mSearchMgr.isSearching()\n                        ? DocumentsContract.buildSearchDocumentsUri(\n                            mState.stack.getRoot().authority,\n                            mState.stack.getRoot().rootId,\n                            mSearchMgr.getCurrentSearch())\n                    // 未搜索情况下, \n                        : DocumentsContract.buildChildDocumentsUri(\n                                mState.stack.peek().authority,\n                                mState.stack.peek().documentId);\n\n                if (mInjector.config.managedModeEnabled(mState.stack)) {\n                    contentsUri = DocumentsContract.setManageMode(contentsUri);\n                }\n\n                if (DEBUG) Log.d(TAG,\n                        \"Creating new directory loader for: \"\n                                + DocumentInfo.debugString(mState.stack.peek()));\n\n                return new DirectoryLoader(\n                        mInjector.features,\n                        context,\n                        mState.stack.getRoot(),\n                        mState.stack.peek(),\n                    // 注意contentsUri, 通过buildChildDocumentsUri构造, \n                    // content://authority/document:rootid/children\n                        contentsUri,\n                        mState.sortModel,\n                        mInjector.fileTypeLookup,\n                        mContentLock,\n                        mSearchMgr.isSearching());\n            }\n        }\n}\n```\n\n在DirectoryLoader start状态后, 异步加载数据\n\n```java\n    public final DirectoryResult loadInBackground() {\n        synchronized (this) {\n            if (isLoadInBackgroundCanceled()) {\n                throw new OperationCanceledException();\n            }\n            mSignal = new CancellationSignal();\n        }\n\n        final ContentResolver resolver = getContext().getContentResolver();\n        final String authority = mUri.getAuthority();\n\n        final DirectoryResult result = new DirectoryResult();\n        result.doc = mDoc;\n\n        ContentProviderClient client = null;\n        Cursor cursor;\n        try {\n            client = DocumentsApplication.acquireUnstableProviderOrThrow(resolver, authority);\n            if (mDoc.isInArchive()) {\n                ArchivesProvider.acquireArchive(client, mUri);\n            }\n            result.client = client;\n\n            Resources resources = getContext().getResources();\n            if (mFeatures.isContentPagingEnabled()) {\n                Bundle queryArgs = new Bundle();\n                // 构建查询排序条件, 根据mSortedDimension制定按那个条件排序\n                mModel.addQuerySortArgs(queryArgs);\n                cursor = client.query(mUri, null, queryArgs, mSignal);\n            } else {\n                cursor = client.query(\n                        mUri, null, null, null, mModel.getDocumentSortQuery(), mSignal);\n            }\n            // 数据变动时回调监听\n            cursor.registerContentObserver(mObserver);\n            // 下面有好多CursorWrapper, 后面可以详细看一下\n            cursor = new RootCursorWrapper(mUri.getAuthority(), mRoot.rootId, cursor, -1);\n\n            if (mSearchMode && !mFeatures.isFoldersInSearchResultsEnabled()) {\n                // There is no findDocumentPath API. Enable filtering on folders in search mode.\n                cursor = new FilteringCursorWrapper(cursor, null, SEARCH_REJECT_MIMES);\n            }\n            if (mFeatures.isContentPagingEnabled()\n                        && cursor.getExtras().containsKey(ContentResolver.QUERY_ARG_SORT_COLUMNS)) {\n                if (VERBOSE) Log.d(TAG, \"Skipping sort of pre-sorted cursor. Booya!\");\n            } else {\n                cursor = mModel.sortCursor(cursor, mFileTypeLookup);\n            }\n            // 最终的结果是封装了cursor\n            result.cursor = cursor;\n        }  catch (Exception e) {\n            Log.w(TAG, \"Failed to query\", e);\n            // query出错, exception不为空\n            result.exception = e;\n        } ...\n\n        return result;\n    }\n```\n\n在数据加载完后, 调用LoaderCallback的 onLoadFinished\n\n```java\n        public void onLoadFinished(Loader<DirectoryResult> loader, DirectoryResult result) {\n            if (DEBUG) Log.d(TAG, \"Loader has finished for: \"\n                    + DocumentInfo.debugString(mState.stack.peek()));\n            assert(result != null);\n            1. 数据被封装到模型层 model中\n            mInjector.getModel().update(result);\n        }\n\n1. -> // model 数据的update\n     protected void update(DirectoryResult result) {\n        assert(result != null);\n\n        if (DEBUG) Log.i(TAG, \"Updating model with new result set.\");\n\n        if (result.exception != null) {\n            // 如果load出错, 清空数据, 回调addUpdateListener注册的监听\n            Log.e(TAG, \"Error while loading directory contents\", result.exception);\n            reset(); // Resets this model to avoid access to old cursors.\n            notifyUpdateListeners(result.exception);\n            return;\n        }\n\n        mCursor = result.cursor;\n        mCursorCount = mCursor.getCount();\n        doc = result.doc;\n2. // 从cursor中load数据\n        updateModelData();\n\n        final Bundle extras = mCursor.getExtras();\n        if (extras != null) {\n            info = extras.getString(DocumentsContract.EXTRA_INFO);\n            error = extras.getString(DocumentsContract.EXTRA_ERROR);\n            mIsLoading = extras.getBoolean(DocumentsContract.EXTRA_LOADING, false);\n        }\n\n3.// 回调监听, \n    notifyUpdateListeners();\n    }\n\n2. -> // updateModelData, 文件夹下内容保存到mFileNames中, 并生成model id用于识别document \n    private void updateModelData() {\n        mIds = new String[mCursorCount];\n        mFileNames.clear();\n        mCursor.moveToPosition(-1);\n        for (int pos = 0; pos < mCursorCount; ++pos) {\n            if (!mCursor.moveToNext()) {\n                Log.e(TAG, \"Fail to move cursor to next pos: \" + pos);\n                return;\n            }\n            // Generates a Model ID for a cursor entry that refers to a document. The Model ID is a\n            // unique string that can be used to identify the document referred to by the cursor.\n            // If the cursor is a merged cursor over multiple authorities, then prefix the ids\n            // with the authority to avoid collisions.\n            if (mCursor instanceof MergeCursor) {\n                mIds[pos] = getCursorString(mCursor, RootCursorWrapper.COLUMN_AUTHORITY)\n                        + \"|\" + getCursorString(mCursor, Document.COLUMN_DOCUMENT_ID);\n            } else {\n                mIds[pos] = getCursorString(mCursor, Document.COLUMN_DOCUMENT_ID);\n            }\n            // 文件夹下的内容加到mFileNames中, \n            mFileNames.add(getCursorString(mCursor, Document.COLUMN_DISPLAY_NAME));\n        }\n\n        // Populate the positions.\n        mPositions.clear();\n    // 以string的model id为key保存了 该项在cursor中的位置. 后面在getItem(string modelid)时用于检索\n        for (int i = 0; i < mCursorCount; ++i) {\n            mPositions.put(mIds[i], i);\n        }\n    }\n\n3. -> // 这里注册了两个监听, 回调其accept方法\n    3.1 -> // modelid的更新\n    \n    private void onModelUpdate(Update event) {\n        // make sure the delegate handles the update before we do.\n        // This isn't ideal since the delegate might be listening\n        // the updates itself. But this is the safe thing to do\n        // since we read model ids from the delegate\n        // in our update handler.\n        mDelegate.getModelUpdateListener().accept(event);\n    \n        mModelUpdateListener = new EventListener<Model.Update>() {\n            @Override\n            public void accept(Update event) {\n                if (event.hasException()) {\n                    onModelUpdateFailed(event.getException());\n                } else {\n                    onModelUpdate(mEnv.getModel());\n                }\n            }\n        };\n    \n        private void onModelUpdate(Model model) {\n            String[] modelIds = model.getModelIds();\n            mModelIds = new ArrayList<>(modelIds.length);\n            for (String id : modelIds) {\n                mModelIds.add(id);\n            }\n    \t}\n        // mModelIds为holdview的内部数据,\n    }\n\n    private final class ModelUpdateListener implements EventListener<Model.Update> {\n\n        @Override\n        public void accept(Model.Update update) {\n            if (DEBUG) Log.d(TAG, \"Received model update. Loading=\" + mModel.isLoading());\n\n            mProgressBar.setVisibility(mModel.isLoading() ? View.VISIBLE : View.GONE);\n            // 表格还是列表更新布局, 主要调用了 mRecView.requestLayout();方法, View的requestLayout方法会使view重绘,   requeLayout() : 控件会重新执行 onMesure() onLayout() ,比如 ScrollView中有LinearLaout ，LinearLayout里面有纵向排列的ImageView和TextView,那么假如ImageView的长宽发生了变化，而要立即在手机上显示这个变化的话，就可调用 imageView.requestLayout();这样的话ScrollView  会重新执行onMesure()这个方法会确定控件的大小然后在确定出自己的宽高，最后在执行onLayout()，这个方法是对所有的子控件进行定位的\n            // 这里会重绘布局, \n            updateLayout(mState.derivedMode);\n            // 更新视图数据 , 对于RecyclerView 会重新调用其onBindViewHolder 方法\n            mAdapter.notifyDataSetChanged();\n\n            if (mRestoredSelection != null) {\n                mSelectionMgr.restoreSelection(mRestoredSelection);\n                mRestoredSelection = null;\n            }\n\n            // Restore any previous instance state\n            final SparseArray<Parcelable> container =\n                    mState.dirConfigs.remove(mLocalState.getConfigKey());\n            final int curSortedDimensionId = mState.sortModel.getSortedDimensionId();\n\n            final SortDimension curSortedDimension =\n                    mState.sortModel.getDimensionById(curSortedDimensionId);\n            if (container != null\n                    && !getArguments().getBoolean(Shared.EXTRA_IGNORE_STATE, false)) {\n                getView().restoreHierarchyState(container);\n            } else if (mLocalState.mLastSortDimensionId != curSortedDimension.getId()\n                    || mLocalState.mLastSortDimensionId == SortModel.SORT_DIMENSION_ID_UNKNOWN\n                    || mLocalState.mLastSortDirection != curSortedDimension.getSortDirection()) {\n                // Scroll to the top if the sort order actually changed.\n                mRecView.smoothScrollToPosition(0);\n            }\n            ...\n\n            if (!mModel.isLoading()) {\n                mActivity.notifyDirectoryLoaded(\n                        mModel.doc != null ? mModel.doc.derivedUri : null);\n            }\n        }\n    }\n```\n\n更新视图,  这里以ListDocumentHolder为例, \n\n```java\n    @Override\n    public DocumentHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        DocumentHolder holder = null;\n        final State state = mEnv.getDisplayState();\n        switch (state.derivedMode) {\n...// 省略网格视图           \n            case MODE_LIST:\n                holder = new ListDocumentHolder(\n                        mEnv.getContext(), parent, mIconHelper, mFileTypeLookup);\n                break;\n\n        }\n\n        mEnv.initDocumentHolder(holder);\n        return holder;\n    }\n\n    public ListDocumentHolder(Context context, ViewGroup parent, IconHelper iconHelper,\n            Lookup<String, String> fileTypeLookup) {\n        // 设置布局为 item_doc_list\n        super(context, parent, R.layout.item_doc_list);\n        // 找到布局中的控件\n        mIconLayout = itemView.findViewById(android.R.id.icon);\n        mIconMime = (ImageView) itemView.findViewById(R.id.icon_mime);\n        mIconThumb = (ImageView) itemView.findViewById(R.id.icon_thumb);\n        mIconCheck = (ImageView) itemView.findViewById(R.id.icon_check);\n        mTitle = (TextView) itemView.findViewById(android.R.id.title);\n        mSummary = (TextView) itemView.findViewById(android.R.id.summary);\n        mSize = (TextView) itemView.findViewById(R.id.size);\n        mDate = (TextView) itemView.findViewById(R.id.date);\n        mType = (TextView) itemView.findViewById(R.id.file_type);\n        // Warning: mDetails view doesn't exists in layout-sw720dp-land layout\n        mDetails = (LinearLayout) itemView.findViewById(R.id.line2);\n\n        mIconHelper = iconHelper;\n        mFileTypeLookup = fileTypeLookup;\n        mDoc = new DocumentInfo();\n    }\n\n    @Override\n    public void onBindViewHolder(DocumentHolder holder, int position, List<Object> payload) {\n        if (payload.contains(SelectionHelper.SELECTION_CHANGED_MARKER)) {\n            // 设置选中状态\n            final boolean selected = mEnv.isSelected(mModelIds.get(position));\n            holder.setSelected(selected, true);\n        } else {\n            onBindViewHolder(holder, position);\n        }\n    }\n\n    @Override\n    public void onBindViewHolder(DocumentHolder holder, int position) {\n        String modelId = mModelIds.get(position);\n        // 由position 反检索出 cursor 和 id.\n        Cursor cursor = mEnv.getModel().getItem(modelId);\n        \n1.        // 更新视图,\n        holder.bind(cursor, modelId);\n\n        final String docMimeType = getCursorString(cursor, Document.COLUMN_MIME_TYPE);\n        final int docFlags = getCursorInt(cursor, Document.COLUMN_FLAGS);\n\n        boolean enabled = mEnv.isDocumentEnabled(docMimeType, docFlags);\n        boolean selected = mEnv.isSelected(modelId);\n        if (!enabled) {\n            assert(!selected);\n        }\n        holder.setEnabled(enabled);\n        holder.setSelected(mEnv.isSelected(modelId), false);\n        mEnv.onBindDocumentHolder(holder, cursor);\n    }\n\n1. -> // 更新子试图, 更新控件\n    \n   public void bind(Cursor cursor, String modelId) {\n        assert(cursor != null);\n\n        mModelId = modelId;\n        // 根据cursor更新DocumentInfo对象\n        mDoc.updateFromCursor(cursor, getCursorString(cursor, RootCursorWrapper.COLUMN_AUTHORITY));\n        // 停止显示缩略图\n        mIconHelper.stopLoading(mIconThumb);\n        mIconMime.animate().cancel();\n        mIconMime.setAlpha(1f);\n        mIconThumb.animate().cancel();\n        mIconThumb.setAlpha(0f);\n        // 重新显示缩略图信息\n        mIconHelper.load(mDoc, mIconThumb, mIconMime, null);\n\n        mTitle.setText(mDoc.displayName, TextView.BufferType.SPANNABLE);\n        mTitle.setVisibility(View.VISIBLE);\n\n\n        boolean hasDetails = false;\n        if (mDoc.isDirectory()) {\n            // Note, we don't show any details for any directory...ever.\n            hasDetails = false;\n        } else {\n            // Show summary if the file is partial. Otherwise, there tends\n            // to be a bunch of confusing junk in the summary field\n            // as populated by Downlaods (and others). So to make things\n            // simpler and clearer for the user in list view, we only\n            // show the summary if the file is partial >\n            // which we believe to mean actively downloading.\n            if (mDoc.isPartial() && mDoc.summary != null) {\n                hasDetails = true;\n                mSummary.setText(mDoc.summary);\n                mSummary.setVisibility(View.VISIBLE);\n            } else {\n                mSummary.setVisibility(View.INVISIBLE);\n            }\n\n            if (mDoc.lastModified > 0) {\n                hasDetails = true;\n                mDate.setText(Shared.formatTime(mContext, mDoc.lastModified));\n            } else {\n                mDate.setText(null);\n            }\n\n            if (mDoc.size > -1) {\n                hasDetails = true;\n                mSize.setVisibility(View.VISIBLE);\n                mSize.setText(Formatter.formatFileSize(mContext, mDoc.size));\n            } else {\n                mSize.setVisibility(View.INVISIBLE);\n            }\n\n            mType.setText(mFileTypeLookup.lookup(mDoc.mimeType));\n        }\n\n        // mDetails view doesn't exists in layout-sw720dp-land layout\n        if (mDetails != null) {\n            mDetails.setVisibility(hasDetails ? View.VISIBLE : View.GONE);\n        }\n    }\n}\n```\n","tags":["Android","AndroidP"],"categories":["SAF","DocumentUI","ExternalStorageProvider"]},{"title":"Usb Framework层框架整理","url":"/2018/07/01/USB相关/usb框架整理/","content":"\n\n\n<!-- TOC -->\n\n- [1. UsbPortManager-usb role管理](#1-usbportmanager-usb-role%E7%AE%A1%E7%90%86)\n    - [1.1. USB主机和USB设备](#11-usb%E4%B8%BB%E6%9C%BA%E5%92%8Cusb%E8%AE%BE%E5%A4%87)\n    - [1.2. Usb设备演进](#12-usb%E8%AE%BE%E5%A4%87%E6%BC%94%E8%BF%9B)\n    - [1.3. typec设备 role管理](#13-typec%E8%AE%BE%E5%A4%87-role%E7%AE%A1%E7%90%86)\n        - [1.3.1. power 模式](#131-power-%E6%A8%A1%E5%BC%8F)\n        - [1.3.2. 数据模式](#132-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F)\n        - [1.3.3. 相关底层节点](#133-%E7%9B%B8%E5%85%B3%E5%BA%95%E5%B1%82%E8%8A%82%E7%82%B9)\n        - [1.3.4. 状态切换与通知](#134-%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E9%80%9A%E7%9F%A5)\n- [2. USB host 管理](#2-usb-host-%E7%AE%A1%E7%90%86)\n    - [2.1. Usb host 添加和删除设备.](#21-usb-host-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87)\n        - [2.1.1. usb_host_load小结](#211-usbhostload%E5%B0%8F%E7%BB%93)\n        - [2.1.2. usb_host_read_event 监听节点](#212-usbhostreadevent-%E7%9B%91%E5%90%AC%E8%8A%82%E7%82%B9)\n            - [2.1.2.1. usb_host_read_event 小结](#2121-usbhostreadevent-%E5%B0%8F%E7%BB%93)\n        - [2.1.3. 两个回调函数](#213-%E4%B8%A4%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0)\n        - [2.1.4. usb_device_added方法添加设备](#214-usbdeviceadded%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87)\n        - [2.1.5. 描述符解析](#215-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A7%A3%E6%9E%90)\n                - [2.1.5.0.1. USB 端点、管道和接口的关系](#21501-usb-%E7%AB%AF%E7%82%B9%E7%AE%A1%E9%81%93%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB)\n        - [2.1.6. added_cb 回调小结](#216-addedcb-%E5%9B%9E%E8%B0%83%E5%B0%8F%E7%BB%93)\n    - [2.2. 上层获取USB 设备并进行传输](#22-%E4%B8%8A%E5%B1%82%E8%8E%B7%E5%8F%96usb-%E8%AE%BE%E5%A4%87%E5%B9%B6%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93)\n        - [2.2.1. USB传输通信](#221-usb%E4%BC%A0%E8%BE%93%E9%80%9A%E4%BF%A1)\n    - [2.3. UsbAlsaManager 音频管理](#23-usbalsamanager-%E9%9F%B3%E9%A2%91%E7%AE%A1%E7%90%86)\n        - [2.3.1. UsbAlsaManager初始化](#231-usbalsamanager%E5%88%9D%E5%A7%8B%E5%8C%96)\n        - [2.3.2. UsbAlsaManager systemReady](#232-usbalsamanager-systemready)\n        - [2.3.3. usbDeviceAdded 事件回调](#233-usbdeviceadded-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83)\n- [3. Usb device管理](#3-usb-device%E7%AE%A1%E7%90%86)\n    - [3.1. Usb枚举过程](#31-usb%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B)\n    - [3.2. 传统Usb device与accessory(配件)模式](#32-%E4%BC%A0%E7%BB%9Fusb-device%E4%B8%8Eaccessory%E9%85%8D%E4%BB%B6%E6%A8%A1%E5%BC%8F)\n        - [3.2.1. accessory模式下的枚举过程:](#321-accessory%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B)\n        - [3.2.2. accessory模式框架](#322-accessory%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6)\n            - [3.2.2.1. 申请accessory权限](#3221-%E7%94%B3%E8%AF%B7accessory%E6%9D%83%E9%99%90)\n    - [3.3. Usb 网络共享](#33-usb-%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB)\n        - [3.3.1. 配置网卡](#331-%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1)\n        - [3.3.2. StateMachine](#332-statemachine)\n            - [3.3.2.1. state 模式](#3321-state-%E6%A8%A1%E5%BC%8F)\n            - [3.3.2.2. State Machine各个模块作用](#3322-state-machine%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8)\n                - [3.3.2.2.1. Smhandler](#33221-smhandler)\n        - [3.3.3. Tethering网络状态机](#333-tethering%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%9C%BA)\n            - [3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)](#3331-tetherinterfacesmtetherinterfacestatemachine)\n                - [3.3.3.1.1. TetherInterfaceSM 初始化](#33311-tetherinterfacesm-%E5%88%9D%E5%A7%8B%E5%8C%96)\n            - [3.3.3.2. **TetherMasterSM**](#3332-tethermastersm)\n                - [3.3.3.2.1. 主控状态机初始化](#33321-%E4%B8%BB%E6%8E%A7%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96)\n                - [3.3.3.2.2. 接收interface状态机的回调](#33322-%E6%8E%A5%E6%94%B6interface%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9B%9E%E8%B0%83)\n            - [3.3.3.4. 收到configured状态后, 开启网络共享](#3334-%E6%94%B6%E5%88%B0configured%E7%8A%B6%E6%80%81%E5%90%8E-%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB)\n                - [3.3.3.4.1. 网络配置激活等](#33341-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%BF%80%E6%B4%BB%E7%AD%89)\n                - [3.3.3.4.2. 涉及到的网络知识](#33342-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86)\n    - [3.4. Usb pc-share pc互联网](#34-usb-pc-share-pc%E4%BA%92%E8%81%94%E7%BD%91)\n\n<!-- /TOC -->\n\n结构\n\n- UsbPortManager\n\n- UsbHostManager\n  - UsbAlsaManager\n\n- UsbDeviceManager\n  \n  ![usb//images/usb2.png](/images/usb2.png)\n\n  \n\n# 1. UsbPortManager-usb role管理\n\n## 1.1. USB主机和USB设备\n\nUSB通信中居于核心地位的是主机(Host)，常见的USB主机是PC机。\n\n- 任何一次USB的数据传输都必须由主机发起和控制\n\n- 所有的USB外设都只能和主机建立连接\n\n- 任何二个外设之间或是二个主机之间都无法直接通信\n\nUSB主机和USB设备的功能是不同的。\n\nUSB主机的功能:\n\n- 通过USB接口给外设提供电源（外设也可以自带电源）\n- 检测和配置设备（即设备的枚举）\n- 错误检查和管理数据的传输\n- 根据设定的传输方式与外设交换数据\n\nUSB设备的功能:\n\n- 管理电源。设备可以由USB接口获取电源，也可能有自己的电源\n\n- 检测通信\n\n  每一个设备都要检测通信信息包中的地址是否和本设备的地址相符，如果不符，设备就会忽略本次通信，这由USB接口硬件自动进行处理。在设备一开始连上USB接口时，使用固定的默认地址0，然后USB主机在检测阶段会给设备分配一个地址，以后的通信都按这个地址进行\n\n- 通信数据的错误检查。由USB接口硬件保证，不必编程处理\n- 响应请求\n  主机在检测到有设备连接上以后，会按USB协议发送相应的设备请求来了解设备的类型和能力，并对设备进行一些配置（如设定地址和配置描述符），设备应能响应这些请求，并返回相应的应答数据\n-  根据设定的传输方式与主机交换数据\n\n## 1.2. Usb设备演进\n\nUSB Type A：该标准一般适用于个人电脑PC中，是应用于最广泛的接口标准\n\nUSB Type B：一般用于3.5寸移动硬盘、以及打印机、显示器等连接\n\n![usb_device](../images/usb_device.jpg)\n\n![mini_usb](/images/mini_usb.jpg)\n\n\n\nUSB Type C：USB Type C这个接口名称是在USB 3.1时代之后出现的，该接口的亮点在于更加纤薄的设计、更快的传输速度（最高10Gbps）以及更强悍的电力传输（最高100W）。Type-C双面可插接口最大的特点是支持USB接口双面插入，主要面向更轻薄、更纤细的设备（未来可能统一手机平板的接口，取代Micro USB接口）。\n\n配备Type-C连接器的标准规格连接线可通过3A电流，同时还支持超出现有USB供电能力的“USB PD”，可以提供最大100W 的电力。\n\n![typec](/images/typec.jpg)\n\n\n\n## 1.3. typec设备 role管理\n\nType-C与既有的USB Type-A与USB Type-B相比，具备无方向性的插拔、并能同时进行*数据传输、影音输出及电源传递*。消费者无法从Type-C的物理外观判断何者是`主控端`(例如计算机或笔电)或设备端(例如手机或随身碟)，这点与传统接口有显著差异(传统上Type-A即是主控端，USB Micro-B是设备端)：因此，Type-C与USB Power Delivery(以下简称USB PD)规范定义了数种`双模式`的角色，用以解决各种设备相互连接时可能产生的问题。\n\nUSB Power Delivery(USB PD):\n\n+ POWER_ROLE_SOURCE\n+ POWER_ROLE_SINK\n\n> source 和 sink 对应 主控端和受控端，source提供电力的一方，sink接收电力的一方。\n\n设备需要支持两种模式，与计算机相连时应作为设备端，与随身碟或耳机相连时则转换角色作为主控端\n\n```xml\n<string name=\"usb_supplying_notification_title\">USB supplying power to attached device</string>\n<string name=\"usb_charging_notification_title\">USB charging this device</string>\n```\n\n相关的模式，见上层设置界面：\n\n```java\npublic static final int[] DEFAULT_MODES = {\n    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_NONE,\n    UsbBackend.MODE_POWER_SOURCE | UsbBackend.MODE_DATA_NONE,\n    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MTP,\n    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_PTP,\n    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MIDI\n};\n```\n\n### 1.3.1. power 模式\n\n+ MODE_DFP    dfp\n  DFP 是一种在host或hub上的USB Type-C端口，与device相连接 \n+ MODE_UFP    ufp\n  UFP 是一种在device或hub上的USB Type-C端口，与host或hub的DFP相连接\n+ MODE_DUAL    dual\n  DRP 是一种既可作为DFP或UFP进行工作的USB Type-C端口 \n\n\t> DRP指的是作为Power Source（提供者）和Sink（消费者）的电源端口。例如，笔记本电脑上的USB Type-C端口支持USB-PD DRP，既可以作为Power Source（连接U盘或手机时），也可以作为Sink（连接显示器或电源适配器时）\n\n### 1.3.2. 数据模式\n\n+ DATA_ROLE_HOST  host\n\n  手机作为usb主机使用\n\n+ DATA_ROLE_DEVICE device\n\n  手机作为USB设备使用\n\n### 1.3.3. 相关底层节点\n\n```powershell\n/sys/class/dual_role_usb\nsp7731e_1h10:/sys/class/dual_role_usb/sprd_dual_role_usb # ls -l\ntotal 0\n-r--r--r-- 1 root root 4096 1970-01-01 17:49 data_role\nlrwxrwxrwx 1 root root    0 1970-01-01 17:49 device -> ../../../403c0000.spi:pmic@0:typec@380\n-rw-r--r-- 1 root root 4096 1970-01-01 17:49 mode\ndrwxr-xr-x 2 root root    0 1970-01-01 00:00 power\n-r--r--r-- 1 root root 4096 1970-01-01 17:49 power_role\nlrwxrwxrwx 1 root root    0 1970-01-01 17:49 subsystem -> ../../../../../../../../../../../class/dual_role_usb\n-r--r--r-- 1 root root 4096 1970-01-01 17:49 supported_modes\n-rw-r--r-- 1 root root 4096 1970-01-01 00:00 uevent\n```\n- supportedModes 对应支持的[power模式](#power 模式),   这一项一般是固定的(不可改变)\n\n  MODE_DFP | MODE_UFP | MODE_DUAL\n\n- mode \n\n  none/dfp/ufp\n\n- power_role\n\n  no-power/source/sink\n\n- data_role\n\n  no-data/host/device\n\n```powershell\n./android/0000:7008:A111-09 14:17:01.953  3432  3450 I UsbPortManager: USB port changed: port=UsbPort{id=sprd_dual_role_usb, supportedModes=dual}, status=UsbPortStatus{connected=false, currentMode=none, currentPowerRole=source, currentDataRole=host, supportedRoleCombinations=[source:host]}, canChangeMode=true, canChangePowerRole=false, canChangeDataRole=false\n```\n\n### 1.3.4. 状态切换与通知\n\nHal层通过uevent机制监控上述底层节点的变化, 通过回调PortManager注册的callback的notifyPortStatusChange函数,使portManager更新port. 同时,portManager也可以通过queryPortStatus函数向hal层查询port的信息.\n\n+ DISPOSITION_ADDED\n\n  底层上报的portinfo在上层的mPorts中没有找到\n\n+ DISPOSITION_CHANGED\n\n  底层上报的portinfo在上层的mPorts中找到了,且对应的 currentMode | currentPowerRole | currentDataRole | supportedRoleCombinations 几个值中任一个改变了\n\n+ DISPOSITION_REMOVED\n\n  上层mPorts中有的项没有在底层上报的所有portinfo中, 该项设置为Removed\n\n+ DISPOSITION_READY\n\n  底层上报的portinfo 在上层的mPorts中,且 currentMode | currentPowerRole | currentDataRole | supportedRoleCombinations 都没变.\n\n\nPortManager对上层提供的接口:\n\n```java\n/**\n* Returns a list of physical USB ports on the device.\n* <p>\n* This list is guaranteed to contain all dual-role USB Type C ports but it might\n* be missing other ports depending on whether the kernel USB drivers have been\n* updated to publish all of the device's ports through the new \"dual_role_usb\"\n* device class (which supports all types of ports despite its name).\n* </p>\n*\n* @return The list of USB ports, or null if none.\n*\n* @hide\n*/\nUsbPort[] getPorts()\n    \n/**\n* Gets the status of the specified USB port.\n*\n* @param port The port to query.\n* @return The status of the specified USB port, or null if unknown.\n*\n* @hide\n*/\nUsbPortStatus getPortStatus(UsbPort port)\n    \n/**\n* Sets the desired role combination of the port.\n* <p>\n* The supported role combinations depend on what is connected to the port and may be\n* determined by consulting\n* {@link UsbPortStatus#isRoleCombinationSupported UsbPortStatus.isRoleCombinationSupported}.\n* </p><p>\n* Note: This function is asynchronous and may fail silently without applying\n* the requested changes.  If this function does cause a status change to occur then\n* a {@link #ACTION_USB_PORT_CHANGED} broadcast will be sent.\n* </p>\n*\n* @param powerRole The desired power role: {@link UsbPort#POWER_ROLE_SOURCE}\n* or {@link UsbPort#POWER_ROLE_SINK}, or 0 if no power role.\n* @param dataRole The desired data role: {@link UsbPort#DATA_ROLE_HOST}\n* or {@link UsbPort#DATA_ROLE_DEVICE}, or 0 if no data role.\n*\n* @hide\n*/\nvoid setPortRoles(UsbPort port, int powerRole, int dataRole)\n```\n\n在有状态变更时, 发送ACTION_USB_PORT_CHANGED的广播\n\n```java\n    /** @hide */\n    public UsbPortStatus(int currentMode, int currentPowerRole, int currentDataRole,\n            int supportedRoleCombinations) {\n        mCurrentMode = currentMode;\n        mCurrentPowerRole = currentPowerRole;\n        mCurrentDataRole = currentDataRole;\n        mSupportedRoleCombinations = supportedRoleCombinations;\n    }\n// 接收广播.\nif (UsbManager.ACTION_USB_PORT_CHANGED.equals(intent.getAction())) {\n            UsbPortStatus portStatus = intent.getExtras()\n                    .getParcelable(UsbManager.EXTRA_PORT_STATUS);\n            if (portStatus != null) {\n                mDataRole = portStatus.getCurrentDataRole();\n                mPowerRole = portStatus.getCurrentPowerRole();\n            }\n        }\n```\n\n# 2. USB host 管理\n\n## 2.1. Usb host 添加和删除设备.\n\nUsbHostManager的初始化\n\n```java\n    // 音频管理相关\n\tmAlsaManager = new UsbAlsaManager(context); \n\tif (pm.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {\n        mHostManager = new UsbHostManager(context, mAlsaManager, mSettingsManager);\n    }\n```\nUsbService systemReady时,调用UsbHostManager的systemReady\n\n```java\npublic void systemReady() {\n    synchronized (mLock) {\n        // Create a thread to call into native code to wait for USB host events.\n        // This thread will call us back on usbDeviceAdded and usbDeviceRemoved.\n        Runnable runnable = this::monitorUsbHostBus;\n        new Thread(null, runnable, \"UsbService host thread\").start();\n    }\n}\n```\n这里启动了一个线程,调用了 jni 方法 monitorUsbHostBus.\n\n对应 android_server_UsbHostManager_monitorUsbHostBus \n\n```cpp\nstatic void android_server_UsbHostManager_monitorUsbHostBus(JNIEnv* /* env */, jobject thiz)\n{\n    // 在usb_host_init 中 , 新建一个usb_host_context对象，还有新建了一个INotify，并且usb_host_context的fd就是INotify的fd。\n    struct usb_host_context* context = usb_host_init();\n    if (!context) {\n        ALOGE(\"usb_host_init failed\");\n        return;\n    }\n    // this will never return so it is safe to pass thiz directly\n    // \n    usb_host_run(context, usb_device_added, usb_device_removed, NULL, (void *)thiz);\n}\n\nvoid usb_host_run(struct usb_host_context *context,\n                  usb_device_added_cb added_cb,\n                  usb_device_removed_cb removed_cb,\n                  usb_discovery_done_cb discovery_done_cb,\n                  void *client_data)\n{\n    int done;\n\t// 先调用了usb_host_load函数，这个函数主要把add和remove的回调，放到context相应的成员变量中，然后增加了dev目录放入INotify的观察。下面循环调用usb_host_read_event函数去读取INotify fd的事件。\n1.    done = usb_host_load(context, added_cb, removed_cb, discovery_done_cb, client_data);\n\n    while (!done) {\n\n        done = usb_host_read_event(context);\n    }\n} /* usb_host_run() */\n\nint usb_host_load(struct usb_host_context *context,\n                  usb_device_added_cb added_cb,\n                  usb_device_removed_cb removed_cb,\n                  usb_discovery_done_cb discovery_done_cb,\n                  void *client_data)\n{\n    int done = 0;\n    int i;\n\t// 添加 add remove的回调\n    context->cb_added = added_cb;\n    context->cb_removed = removed_cb;\n    // 此处client_data 指向 jni 类的thiz \n    context->data = client_data;\n\n    D(\"Created device discovery thread\\n\");\n\n    /* watch for files added and deleted within USB_FS_DIR */\n    context->wddbus = -1;\n    for (i = 0; i < MAX_USBFS_WD_COUNT; i++)\n        context->wds[i] = -1;\n\n    /* watch the root for new subdirectories */\n    // 监控 root 根节点 /dev 目录的 CREATE 和 DELETE 事件, 返回 watch 描述符\n    context->wdd = inotify_add_watch(context->fd, DEV_DIR, IN_CREATE | IN_DELETE);\n    // ..监控失败\n    ....\n    // 监控存在的/dev/下的特定的子目录  /dev/bus/usb  同样是 CREATE 和 DELETE 事件\n    //  MAX_USBFS_WD_COUNT = 10;   监控 最多10个 目录\n    // /dev/bus/usb/001    ...   /dev/bus/usb/002    .. /dev/bus/usb/009\n    // 监控成功, 描述符放在对应的 wds数组中.\n    watch_existing_subdirs(context, context->wds, MAX_USBFS_WD_COUNT);\n\n    /* check for existing devices first, after we have inotify set up */\n    // 最后查找已经存在的/dev/bus/usb 下的目录, 找到的设备调用added_cb函数.   \n\n    done = find_existing_devices(added_cb, client_data);\n  \n      {\n            snprintf(devname, sizeof(devname), \"%s/%s\", busname, de->d_name);\n            // devname  ex:  /dev/bus/usb/001/001 \n            done = added_cb(devname, client_data);\n      }\n    \n    // 此处 discovery_done_cb 为空.\n    if (discovery_done_cb)\n        done |= discovery_done_cb(client_data);\n\n    return done;\n} /* usb_host_load() */\n```\n\n### 2.1.1. usb_host_load小结\n\n-   启动一个线程,初始化了iNotify实例( inotify_init ),  返回fd 赋给 usb_host_context的 fd 成员\n-   绑定 add remove的回调函数, added_cb\\removed_cb.  赋给 usb_host_context的 cb_added |  cb_removed 成员\n-   监控 root 根节点 /dev 目录的 CREATE 和 DELETE 事件, 返回 watch 描述符 给 usb_host_context 的 wdd成员\n-   监控/dev/bus/usb下存在的子目录 的CREATE 和 DELETE 事件, 返回 watch描述符给 usb_host_context的wds 数组成员\n-   查找/dev/bus/usb/<00i>/ 下的设备是否存在, 如果存在这样的设备, 调用added_cb \n\n### 2.1.2. usb_host_read_event 监听节点\n\n通过INotify中的fd读取相关的事件,usb_host_run函数会在while循环中一直循环。一直运行该函数\n\n```cpp\n// 读取 inotify_init 实例的fd, 读出对应的事件\nret = read(context->fd, event_buf, sizeof(event_buf));\nwhile (offset < ret && !done) {\n  event = (struct inotify_event*)&event_buf[offset];\n  wd = event->wd;\n  // watch描述符为 /dev 目录的描述符\n  if (wd == context->wdd) {\n    // 如果是CREATE事件, 且创建的目录为 /dev/bus\n    if ((event->mask & IN_CREATE) && !strcmp(event->name, \"bus\")) {\n      // 添加对 /dev/bus 目录的监控, 返回watch描述符赋给 context->wddbus\n      context->wddbus = inotify_add_watch(context->fd, DEV_BUS_DIR, IN_CREATE | IN_DELETE);\n      // 监控失败, 返回done 为 1, 结束循环,退出usb_host_run函数\n      if (context->wddbus < 0) {\n        done = 1;\n      } else {\n        // 监控成功, 监控/dev/bus下的子目录,  下面的过程和 usb_host_load 过程一致.\n        watch_existing_subdirs(context, context->wds, MAX_USBFS_WD_COUNT);\n        // 查找存在的/deb/bus/usb 节点, 并调用added_cb添加设备. 此处done返回0, 仍然处于循环中\n        done = find_existing_devices(context->cb_added, context->data);\n      }\n   // watch 描述符为  /dev/bus 目录的 描述符\n   } else if (wd == context->wddbus) {\n      // 如果为 CREATE 事件, 查找存在的 /dev/bus/usb 子目录节点....\n      if ((event->mask & IN_CREATE) && !strcmp(event->name, \"usb\")) {\n        watch_existing_subdirs(context, context->wds, MAX_USBFS_WD_COUNT);\n        done = find_existing_devices(context->cb_added, context->data);\n        // 为DELETE事件, 且为usb子目录被删除了, 则删除对子目录的监控\n       } else if ((event->mask & IN_DELETE) && !strcmp(event->name, \"usb\")) {\n          for (i = 0; i < MAX_USBFS_WD_COUNT; i++) {\n            if (context->wds[i] >= 0) {\n              inotify_rm_watch(context->fd, context->wds[i]);\n              context->wds[i] = -1;\n            }\n          }\n       }\n      // 如果为 /dev/bus/usb/ 目录\n      else if (wd == context->wds[0]) {\n                i = atoi(event->name);\n                snprintf(path, sizeof(path), USB_FS_DIR \"/%s\", event->name);\n                D(\"%s subdirectory %s: index: %d\\n\", (event->mask & IN_CREATE) ?\n                        \"new\" : \"gone\", path, i);\n                if (i > 0 && i < MAX_USBFS_WD_COUNT) {\n                    int local_ret = 0;\n                    // 新建了该目录  (001-00MAX_USBFS_WD_COUNT的新建)\n                    if (event->mask & IN_CREATE) {\n                        // 添加对该目录的监控 \n                        local_ret = inotify_add_watch(context->fd, path,\n                                IN_CREATE | IN_DELETE);\n                        if (local_ret >= 0)\n                            context->wds[i] = local_ret;\n                        // 查找该目录下的文件, 并调用added_cb添加设备\n                        done = find_existing_devices_bus(path, context->cb_added,\n                                context->data);\n                      // 删除了该目录\n                    } else if (event->mask & IN_DELETE) {\n                        // 对该目录取消监控\n                        inotify_rm_watch(context->fd, context->wds[i]);\n                        context->wds[i] = -1;\n                    }\n                }\n            } \n      // 如果为 /dev/bus/usb/<001-00MAX_USBFS_WD_COUNT> 目录\n      else {\n                for (i = 1; (i < MAX_USBFS_WD_COUNT) && !done; i++) {\n                    if (wd == context->wds[i]) {\n                        snprintf(path, sizeof(path), USB_FS_DIR \"/%03d/%s\", i, event->name);\n                        if (event->mask == IN_CREATE) {\n                            D(\"new device %s\\n\", path);\n                            done = context->cb_added(path, context->data);\n                        } else if (event->mask == IN_DELETE) {\n                            D(\"gone device %s\\n\", path);\n                            done = context->cb_removed(path, context->data);\n                        }\n                    }\n                }\n            }\n      // 读取下一个 inotify_event 事件\n      offset += sizeof(struct inotify_event) + event->len;\n    }\n  }\n}\n```\n\n\n\n#### 2.1.2.1. usb_host_read_event 小结\n\n该函数即读取此次的inotify实例的fd,  放在event_buf数组中(包含多个inotify_event 事件.), 每个事件都有一个watch fd,\n\n将watch fd 与之前建立的 watch fd比较, 判断是哪一个根目录的事件, 过滤出CREATE 和 DELETE 事件, 再由目录的层级添加对其子目录的监控,如果是CREATE事件,则查找目录下可能存在的usb设备节点, 找到调用added_cb添加解析设备,通知上层添加usb设备. 如果是 /dev/bus/usb/<001-00MAX_USBFS_WD_COUNT> 目录下的CREATE| DELETE 事件, 则直接添加删除设备,并通知到上层.只有在监控/dev目录失败的情况下,才会退出循环,也就是终止线程的运行.其他情况都是返回0,不退出循环,线程一直执行.\n\n### 2.1.3. 两个回调函数\n\n绑定的两个回调函数为 usb_device_added\\usb_device_removed, 这两个函数在jni层.\n\n着重介绍usb_device_added函数.\n\n参数: \n\n```cpp\nconst char *devname   //native 层通过inotify找到的设备名称  ex: /dev/bus/usb/001/001\nvoid* client_data    // jni 层的thiz \n```\n\n### 2.1.4. usb_device_added方法添加设备\n\n先调用usb_device_open 方法打开该设备文件, 返回usb_device结构体.\n\n```cpp\nstruct usb_device {\n    char dev_name[64];\n    unsigned char desc[4096];\n    int desc_length;\n    int fd;\n    int writeable;\n};\n```\n\ndev_file\n\n\n![usb_dev_file](/images/usb_dev_file.png)\n\n该结构体中 desc为 设备描述内容(包含一个设备描述符/n个配置描述符/n个接口描述符/n个端点描述符) , desc最大大小为4096, len中保存了实际的desc的大小, 即 /dev/bus/usb/001/001 的文件大小.\n\n```cpp\njboolean result = env->CallBooleanMethod(thiz, method_beginUsbDeviceAdded,\n        deviceName, usb_device_get_vendor_id(device), usb_device_get_product_id(device),\n        deviceDesc->bDeviceClass, deviceDesc->bDeviceSubClass, deviceDesc->bDeviceProtocol,\n        manufacturerName, productName, version, serialNumber);\n```\n在USB设备枚举过程中，主机端的协义软件需要解析从USB设备读取的所有描述符信息。在USB主向设备发送读取描述符的请求后，USB设备将所有的描述符以连续的数据流方式传输给USB主机。主机从第一个读到的字符开始，根据双方规定好的数据格式，顺序地解析读到的数据流\n\n**设备描述符**：给出了USB设备的一般信息，一个设备描述符可以有多个配置描述符\n\n```cpp\nstruct usb_device_descriptor {  \n    __u8  bLength;//设备描述符的字节数大小，为0x12   \n    __u8  bDescriptorType;//描述符类型编号，为0x01   \n  \n    __le16 bcdUSB;//USB 规范发布号．表示了本设备能适用于那种协议，如2.0=0200，1.1=0110等． \n    __u8  bDeviceClass;//USB设备类代码，由USB-IF分配，如果该字段为0x00，表示由接口描述符来指定（有可能该USB设备是一个复合设备，USB设备的各个接口相互独立，分别属于不同的设备类）。如果是0x01~0xfe，表示为USB-IF定义的设备类，例如0x03为HID设备，0x09为HUB设备。如果是0xff，表示由厂商自定义设备类型      \n    //0x00不是在设备描述符中定义的，如HID   \n    __u8  bDeviceSubClass;//子类型代码（由USB分配）．如果bDeviceClass值是0，一定要设置为0．其它情况就跟据USB-IF组织定义的编码． \n    __u8  bDeviceProtocol;// 协议代码（由USB分配）．如果使用USB-IF组织定义的协议，就需要设置这里的值，否则直接设置为0。如果厂商自己定义的可以设置为FFH．\n    __u8  bMaxPacketSize0;//端点０最大分组大小（只有8,16,32,64有效）  \n    __le16 idVendor;//供应商ID（由USB分配）．\n    __le16 idProduct;//产品ID（由厂商分配）．由供应商ID和产品ID，就可以让操作系统加载不同的驱动程序． \n    __le16 bcdDevice;//设备出产编码．由厂家自行设置．\n    __u8  iManufacturer;//厂商描述符字符串索引．索引到对应的字符串描述符． 为０则表示没有．  \n    __u8  iProduct;//描述产品字符串的索引  \n    __u8  iSerialNumber;//描述设备序列号字符串的索引   \n    __u8  bNumConfigurations;//可能的配置数．指配置字符串的个数\n} __attribute__ ((packed)); \n```\n\n设备描述符给出了USB设备的一般信息，包括对设备及在设备配置中起全程作用的信息，包括制造商标识号ID、产品序列号、所属设备类号、默认端点的最大包长度和配置描述符的个数等。一个USB设备必须有且仅有一个设备描述符。设备描述符是设备连接到总线上时USB主机所读取的第一个描述符.\n\n**配置描述符**：配置描述符定义了设备的配置信息\n\n```cpp\ntypedef struct _USB_CONFIGURATION_DESCRIPTOR_\n{\n    BYTE      bLength,   // 描述符大小．固定为0x09．\n    BYTE      bDescriptorType,  // 配置描述符类型．固定为0x02．\n    WORD      wTotalLength, //  返回整个数据的长度．指此配置返回的配置描述符，接口描述符以及端点描述符的全部大小．\n    BYTE      bNumInterfaces, // 配置所支持的接口数．指该配置配备的接口数量，也表示该配置下接口描述符数量．\n    BYTE      bConfigurationValue, // 作为Set Configuration的一个参数选择配置值．\n    BYTE      iConfiguration, //用于描述该配置字符串描述符的索引．\n    BYTE      bmAttributes, // 供电模式选择．Bit4-0保留，D7:总线供电，D6:自供电，D5:远程唤醒．\n    BYTE      MaxPower //总线供电的USB设备的最大消耗电流．以2mA为单位．\n}USB_CONFIGURATION_DESCRIPTOR;\n```\n\n配置描述符中包括了描述符的长度（属于此描述符的所有接口描述符和端点描述符的长度的和）、供电方式（自供电/总线供电）、最大耗电量等。主果主机发出USB标准命令Get_Descriptor要求得到设备的某个配置描述符，那么除了此配置描述符以外，此配置包含的所有接口描述符与端点描述符都将提供给USB主机。\n\n**接口描述符**：接口描述符说明了接口所提供的配置，一个配置所拥有的接口数量通过配置描述符的bNumInterfaces决定\n\n```cpp\ntypedef struct _USB_INTERFACE_DESCRIPTOR_\n{\n    BYTE      bLength, // 描述符大小．固定为0x09．\n    BYTE      bDescriptorType, // 接口描述符类型．固定为0x04．\n    BYTE      bInterfaceNumber, // 该接口的编号．\n    BYTE      bAlternateSetting, // 用于为上一个字段选择可供替换的位置．即备用的接口描述符标号．\n    BYTE      bNumEndpoint, // 使用的端点数目．端点０除外．\n    BYTE      bInterfaceClass, // 类型代码（由USB分配）．\n    BYTE      bInterfaceSubClass, // 子类型代码（由USB分配）．\n    BYTE      bInterfaceProtocol, // 协议代码（由USB分配）．\n    BYTE      iInterface // 字符串描述符的索引\n}USB_INTERFACE_DESCRIPTOR;\n```\n\n配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为`功能`更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。\n\n　　如果一个配置描述符不止支持一个接口描述符，并且每个接口描述符都有一个或多个端点描述符，那么在响应USB主机的配置描述符命令时，USB设备的端点描述符总是紧跟着相关的接口描述符后面，作为配置描述符的一部分被返回。接口描述符不可直接用Set_Descriptor和Get_Descriptor来存取。\n\n　　如果一个接口仅使用端点0，则接口描述符以后就不再返回端点描述符，并且此接口表现的是一个控制接口的特性，它使用与端点0相关联的默认管道进行数据传输。在这种情况下bNumberEndpoints域应被设置成0。接口描述符在说明端点个数并不把端点0计算在内。\n\n**端点描述符**：USB设备中的每个端点都有自己的端点描述符，由接口描述符中的bNumEndpoint决定其数量\n\n```cpp\ntypedef struct _USB_ENDPOINT_DESCRIPTOR_\n{\n    BYTE        bLength, //描述符大小．固定为0x07．\n    BYTE        bDescriptorType, // 接口描述符类型．固定为0x05．\n    BYTE        bEndpointAddress, // USB设备的端点地址．Bit7，方向，对于控制端点可以忽略，1/0:IN/OUT．Bit6-4，保留．BIt3-0：端点号．\n    BYTE        bmAttributes, // 端点属性．Bit7-2，保留．BIt1-0：00控制，01同步，02批量，03中断．\n    WORD      wMaxPacketSize, //  本端点接收或发送的最大信息包大小．\n    BYTE        bInterval // 轮循数据传送端点的时间间隔．对于批量传送和控制传送的端点忽略．对于同步传送的端点，必须为１，对于中断传送的端点，范围为１－２５５．对于全速/低速的中断端点，取值范围为 1~255，对于高速中断端点，取值范围为1~16，详细定义可以参考USB协议\n}USB_ENDPOINT_DESCRIPTOR;\n```\n端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。　　\n\n除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。\n\n在将设备描述符的信息发到上层后, 接着遍历设备的各种描述符,之后调用endUsbDeviceAdded结束添加设备\n\n### 2.1.5. 描述符解析\n\n设备描述符/配置描述符/接口描述符/端点描述符继承父类`UsbDescriptor`\n\n```java\nabstract class UsbDescriptor{\n-int mLength\n-byte mType\n---\n+postParse(ByteStream stream)\n+<b>parseRawDescriptors(ByteStream stream)\n}\n\nclass UsbDeviceDescriptor extends UsbDescriptor\nclass UsbConfigDescriptor extends UsbDescriptor\nclass UsbEndpointDescriptor extends UsbDescriptor\nclass UsbInterfaceDescriptor extends UsbDescriptor\nclass UsbUnknown extends UsbDescriptor\n\nabstract class UsbACInterface extends UsbDescriptor\nclass UsbHIDDescriptor extends UsbDescriptor\nclass UsbInterfaceAssoc extends UsbDescriptor\n\n\nabstract class UsbACEndpoint extends UsbDescriptor\npackage UsbACEndpoint {\nclass UsbACAudioControlEndpoint extends UsbACEndpoint\nclass UsbACAudioStreamEndpoint extends UsbACEndpoint\nclass UsbACMidiEndpoint extends UsbACEndpoint\n}\n\n\nabstract class UsbACInterface extends UsbDescriptor\n\npackage UsbACInterface {\nclass Usb10ASGeneral extends UsbACInterface\nclass Usb20ASGeneral extends UsbACInterface\nclass UsbACFeatureUnit extends UsbACInterface\nclass UsbACMixerUnit extends UsbACInterface\nclass UsbMSMidiInputJack extends UsbACInterface\nclass UsbMSMidiOutputJack extends UsbACInterface\nclass ... extends UsbACInterface\n\nabstract class UsbACTerminal extends UsbACInterface\nabstract class UsbACHeaderInterface extends UsbACInterface\n\npackage UsbACHeaderInterface{\nclass Usb10ACHeader extends UsbACHeaderInterface\nclass Usb20ACHeader extends UsbACHeaderInterface\n}\n\npackage UsbACTerminal {\nclass Usb10ACOutputTerminal extends UsbACTerminal\nclass Usb10ACInputTerminal extends UsbACTerminal\nclass Usb20ACInputTerminal extends UsbACTerminal\nclass Usb20ACOutputTerminal extends UsbACTerminal\n}\n\n}\n```\n\n继承parseRawDescriptors方法, descriptor前两个字节中存放了长度和类型.解析时根据长度和类型最终将一个device中存放的descriptor的全部描述符全部解析出来.\n\n##### 2.1.5.1.1. USB 端点、管道和接口的关系\n\nUSB 系统中数据的传输，宏观的看来是在HOST 和 USB 功能设备之间进行；微观的看是在应用软件的 Buffer 和 USB 功能设备的端点之间进行。一般来说端点都有 Buffer，可以认为USB通讯就是应用软件Buffer和设备端点Buffer之间的数据交换，交换的通道称为管道。应用软件通过和设备之间的数据交换来完成设备的控制和数据传输。通常需要多个管道来完成数据交换，因为同一管道只支持一种类型的数据传输。用在一起来对设备进行控制的若干管道称为设备的接口;\n\n一个 USB 设备可以包括若干个端点，不同的端点以端点编号和方向区分。不同端点可以支持不同的传输类型、访问间隔以及最大数据包大小。除端点 0外，所有的端点只支持一个方向的数据传输。端点 0是一个特殊的端点，它支持双向的控制传输。管道和端点关联，和关联的端点有相同的属性，如支持的传输类型、最大包长度、传输方向等。\n\n![usb_interface](/images/usb_interface.png)\n\n\n\n### 2.1.6. added_cb 回调小结\n\n-   将设备描述符的参数通过`beginUsbDeviceAdded`会传给上层\n-   将配置描述符的参数通过`addUsbConfiguration`回传给上层\n-   将接口描述符的参数通过`addUsbInterface`回传给上层\n-   将端口描述符的参数通过`addUsbEndpoint`回传给上层\n-   最后调用endUsbDeviceAdded方法回调上层结束该设备的添加过程.\n\nbeginUsbDeviceAdded:\n\n```java\n// 创建一个 UsbDevice 对象, 并初始化和其绑定的 mNewConfigurations| mNewInterfaces | mNewEndpoints集合\nmNewDevice = new UsbDevice(deviceName, vendorID, productID,\n                    deviceClass, deviceSubclass, deviceProtocol,\n                    manufacturerName, productName, versionString, serialNumber);\n\n            mNewConfigurations = new ArrayList<>();\n            mNewInterfaces = new ArrayList<>();\n            mNewEndpoints = new ArrayList<>();\n```\n\n```java\n// 新建一个  UsbConfiguration对象,并保存到   mNewConfigurations 集合中\nprivate void addUsbConfiguration(int id, String name, int attributes, int maxPower) {\n        if (mNewConfiguration != null) {\n            mNewConfiguration.setInterfaces(\n                    mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));\n            mNewInterfaces.clear();\n        }\n\n        mNewConfiguration = new UsbConfiguration(id, name, attributes, maxPower);\n        mNewConfigurations.add(mNewConfiguration);\n    }\n// 新建一个  UsbInterface,并保存到   mNewInterfaces 集合中\n    private void addUsbInterface(int id, String name, int altSetting,\n            int Class, int subClass, int protocol) {\n        if (mNewInterface != null) {\n            mNewInterface.setEndpoints(\n                    mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));\n            mNewEndpoints.clear();\n        }\n\n        mNewInterface = new UsbInterface(id, altSetting, name, Class, subClass, protocol);\n        mNewInterfaces.add(mNewInterface);\n    }\n// 新建一个  UsbEndpoint,并保存到   mNewEndpoints 集合中\n    private void addUsbEndpoint(int address, int attributes, int maxPacketSize, int interval) {\n        mNewEndpoints.add(new UsbEndpoint(address, attributes, maxPacketSize, interval));\n    }\n```\n\n\n```java\n    private void endUsbDeviceAdded() {\n        if (mNewInterface != null) {\n            // 接口描述符需要绑定端口描述符集合\n            mNewInterface.setEndpoints(\n                    mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));\n        }\n        if (mNewConfiguration != null) {\n            // 配置描述符需要绑定接口描述符集合\n            mNewConfiguration.setInterfaces(\n                    mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));\n        }\n\n\n        synchronized (mLock) {\n            if (mNewDevice != null) {\n              // 设备描述符需要绑定配置描述符集合\n                mNewDevice.setConfigurations(\n                        mNewConfigurations.toArray(\n                                new UsbConfiguration[mNewConfigurations.size()]));\n                mDevices.put(mNewDevice.getDeviceName(), mNewDevice);\n\n                // It is fine to call this only for the current user as all broadcasts are sent to\n                // all profiles of the user and the dialogs should only show once.\n                ComponentName usbDeviceConnectionHandler = getUsbDeviceConnectionHandler();\n                if (usbDeviceConnectionHandler == null) {\n                    getCurrentUserSettings().deviceAttached(mNewDevice);\n                } else {\n                    getCurrentUserSettings().deviceAttachedForFixedHandler(mNewDevice,\n                            usbDeviceConnectionHandler);\n                }\n                // deviceName is something like: \"/dev/bus/usb/001/001\"\n                UsbDescriptorParser parser = new UsbDescriptorParser();\n                boolean isInputHeadset = false;\n                boolean isOutputHeadset = false;\n                if (parser.parseDevice(mNewDevice.getDeviceName())) {\n                    isInputHeadset = parser.isInputHeadset();\n                    isOutputHeadset = parser.isOutputHeadset();\n                    Slog.i(TAG, \"---- isHeadset[in: \" + isInputHeadset\n                            + \" , out: \" + isOutputHeadset + \"]\");\n                }\n                // 如果为音频设备,通过UsbAlsaManager处理\n                mUsbAlsaManager.usbDeviceAdded(mNewDevice,\n                        isInputHeadset, isOutputHeadset);\n            }\n        }\n    }\n```\n\n[描述符的相关信息可参考这里](https://www.cnblogs.com/tianchiyuyin/p/5139948.html)\n\n其中几个参数描述了这几个描述符的关系:\n\n1.  设备描述符中的 bNumConfigurations : 可能的配置数．指配置字符串的个数\n2.  配置描述符中的bNumInterfaces, 指接口描述符的个数\n3.  接口描述符中的bNumEndpoint, 指定端口描述符的个数\n\n除上述几种必须的描述符外, 还有字符串描述符，HID描述符，报告描述符等等.\n\n### 2.1.7. usb_device_removed方法销毁设备\n\n调用 usbDeviceRemoved 销毁deviceName对应的设备. \n\n```java\n    private void usbDeviceRemoved(String deviceName) {\n        synchronized (mLock) {\n            UsbDevice device = mDevices.remove(deviceName);\n            if (device != null) {\n                mUsbAlsaManager.usbDeviceRemoved(device);\n                mSettingsManager.usbDeviceRemoved(device);\n                getCurrentUserSettings().usbDeviceRemoved(device);\n            }\n        }\n    }\n```\n## 2.2. 上层获取USB 设备并进行传输\n\nUsbManager提供了getDeviceList函数,获取当前的usb设备列表, \n\n最终调用到UsbHostManager中,从其保存的mDevices中拿到设备列表. \n\n拿到设备(UsbDevice)后,可以通过openDevice打开这个设备. 返回 UsbDeviceConnection 对象.\n\n```java\npublic UsbDeviceConnection openDevice(UsbDevice device) {\n    try {\n        String deviceName = device.getDeviceName();\n        ParcelFileDescriptor pfd = mService.openDevice(deviceName);\n        if (pfd != null) {\n            UsbDeviceConnection connection = new UsbDeviceConnection(device);\n            // open中调到了 native_open 为native方法, 调用到了jni层打开该设备.\n            boolean result = connection.open(deviceName, pfd, mContext);\n            pfd.close();\n            if (result) {\n                return connection;\n            }\n        }\n    } \n    return null;\n}\n```\n\n这里涉及到了另一个jni类([android_hardware_UsbDeviceConnection.cpp](http://10.0.1.79:8081/source/xref/sprdroid8.1_trunk/frameworks/base/core/jni/android_hardware_UsbDeviceConnection.cpp))\n\nnative_open中主要调用了usb_device_new函数(见这里[open_device](#open_device)), 返回了 native层 usb_device结构. 并将device跟field_context关联起来.\n\n```cpp\n    struct usb_device* device = usb_device_new(deviceNameStr, fd);\n    if (device) {\n        env->SetLongField(thiz, field_context, (jlong)device);\n    }\n```\n\n最后用户进程获取的对象就是UsbDeviceConnection，使用UsbDeviceConnection访问usb设备时,最终都会通过field_context找到device.\n\n### 2.2.1. USB传输通信\n\ngoogle提供了控制传输的两个方法:  [官方资料](https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection.html)\n- bulkTransfer (块传输)    在bulk endpoint上进行传输\n  bulkTransfer(UsbEndpoint endpoint, byte[] buffer, int length, int timeout)；  \n  在给定的端点执行一个bulk transaction；\n  参数：\n\n  ```cpp\n  endpoint: OUT or IN（Host to Device用OUT，Device to Host 用IN）；\n  buffer  : 将要发送/接收的指令或数据，当endpoint为OUT，buffer为你定义好的指令或数据，将下发给device，当endpoint为IN，buffer则是一个容器，用来存储device返回的应答指令或数据，注意buffer的大小，以足够存储所有的数据；\n  length  : 即发送/接收指令或数据的大小；\n  timeout : 即指令或数据的最长通讯时间，在通讯出现问题时，若超时还未通讯完成，视为通讯失败；\n  ```\n\n  >   每个数据包长度高速的时候为512字节，低速设备最大64个字节；用于主机与USB设备之间的批量数据传输，通常一次块传输需要分解成若干个块传输事务。\n  >\n  >   一次块传输的方向是单一的，对主机而言，要么是输入，要么是输出。因此，一次块传输是由若干个IN事务或由若干个OUT事务组成的。\n  >\n  >   对于要进行输入的块传输，一般要执行若干个IN事务。每执行一个IN事务时，主机都首先发出IN令牌包。设备端点收到后做出响应，一般是回送一个数据包。如果不能回送数据，则回送NAK包或STALL包。NAK表示设备暂时不能回送数据；STALL表示端点一直停着或需要IJSB系统软件进行干预；如果主机收到合法数据包，则回以ACK握手包；如果主机在接收数据时发现有错，则不给设备任何回音。\n  >\n  >   对于要进行输出的块传输，一般要执行若干个 OUT事务。每执行一个OUT事务时，主机都首先发出OUT令牌包，接着发出数据包。设备在收到数据包后，根据情况回以握手包；回以ACK表示数据已接收 无误，并通知主机可开始下一个0UT事务，以便传送下一个数据包；回以NAK表示数据已接收无误，但是主机不要再送数据，因为设备暂时不能接收(如缓冲区 满)；如果端点已终止，则回以STALL，通知主机不要再重发数据，因为设备出现了故障；如果接收时出现CRC校验错，则不发任何握手包。如果需要输入、输出同时进行，则需要使用2个端点。\n\n\n- controlTransfer  (控制传输)\n  controlTransfer(int requestType, int request, int value, int index, byte[] buffer, int length, int timeout)\n  零点传输执行一个control transaction，即所有的通讯都是通过endpoint 0；\n  参数：\n  ```cpp\n  \t\t   requestType，  request type for this transaction 设置通信的方向\n              request      ，request ID for this transaction   设置的是访问的类型\n              value         ，value field for this transaction  \n              index         ，index field for this transaction\n              buffer       ，同bulkTransfer()\n              length       ，同bulkTransfer()\n              timeout     ，同bulkTransfer()\n  ```\n\n\n该函数可以设置设备信息,可以看下面的例子:\n\n```java\nprivate void makeThisDeviceAnAccessory(@NonNull UsbDeviceConnection connection) {\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MANUFACTURER,\n            \"Android\");\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MODEL,\n            \"Android device\");\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_DESCRIPTION,\n            \"Android device running CTS verifier\");\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_VERSION, \"1\");\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_URI,\n            \"https://source.android.com/compatibility/cts/verifier.html\");\n    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_SERIAL, \"0\");\n    // 发送ACCESSORY_START 指令开始usb数据传输\n    AoapInterface.sendAoapStart(connection);\n}\n\n    public static void sendString(UsbDeviceConnection conn, int index, String string) {\n        byte[] buffer = (string + \"\\0\").getBytes();\n        int len = conn.controlTransfer(\n                // host to device\n                UsbConstants.USB_DIR_OUT | UsbConstants.USB_TYPE_VENDOR,\n                AoapInterface.ACCESSORY_SEND_STRING, 0, index,\n                buffer, buffer.length, 10000);\n        if (len != buffer.length) {\n            throw new RuntimeException(\"Failed to send string \" + index + \": \\\"\" + string + \"\\\"\");\n        } else {\n            Log.i(TAG, \"Sent string \" + index + \": \\\"\" + string + \"\\\"\");\n        }\n    }\n```\n\n定制了设备的  MANUFACTURER / DESCRIPTION / VERSION 等的信息. 设置了相关的String信息后,可以从device设备上读取相应的信息.  同样通过 controlTransfer 函数, 不过requestType变为了 USB_DIR_IN.\n\nUSB 体系四种传输类型:\n\n- 控制传输：主要用于在设备连接时对设备进行枚举以及其他因设备而异的特定操作。\n\n- 中断传输：用于对延迟要求严格、小数据的可靠传输，如键盘、游戏手柄等。\n\n- 批量传输：用于对延迟要求宽松，游戏手柄等大量数据的可靠传输，如U盘等, 该模式即为块传输。\n\n- 同步传输：用于对可靠性要求不高的实时数据传输，如摄像头、USB音响等.\n\n    不同的传输类型在物理上并没有太大的区别，只是在传输机制、主机安排传输任务、可占用USB 带宽的限制以及最大包长度有一定的差异。\n\n\n## 2.3. UsbAlsaManager 音频管理\n\n### 2.3.1. UsbAlsaManager初始化\n\n进行初始化扫描, 调用了AlsaCardsParser类对`\"/proc/asound/cards\"` 文件进行扫描\n\n```java\n// AlsaCardsParser的scan方法\nmCardsParser.scan();\n```\n\n扫描结果存放到AlsaCardRecord数组中 (mCardRecords) , 查看AlsaCardRecord的结构如下:\n```java\n        public int     mCardNum = -1;\n        public String  mField1 = \"\";\n        public String  mCardName = \"\";\n        public String  mCardDescription = \"\"; //只有是usb audio设备该字段才有意义\n        public boolean mIsUsb = false;\n```\n其中mIsUsb标明该音频设备是否是Usb设备. 判断标准是 包含 `at usb-` 关键字\n\n```powershell\nbullhead:/proc/asound # cat cards\n 0 [msm8994tomtomsn]: msm8994-tomtom- - msm8994-tomtom-snd-card\n                      msm8994-tomtom-snd-card\n```\n\n### 2.3.2. UsbAlsaManager systemReady\n\nsystemReady时添加对` /dev/snd/` 下的文件监控, 监控新建和删除.\n\n同时对其下面的文件调用alsaFileAdded方法, 添加已经存在的设备.\n\n新建文件时,回调alsaFileAdded方法, 删除了文件时回调 alsaFileRemoved 方法\n\n对于alsaFileAdded方法, 过滤目录下文件名:\n\n-   文件名以`pcmC`开头的,以`p`结束的为TYPE_PLAYBACK设备(播放设备)\n-   文件名以`pcmC`开头的,以`c`结束的为TYPE_CAPTURE设备(录音设备)\n-   文件名以`midiC`开头的,为TYPE_MIDI设备.\n\n对于播放设备和录音设备, 创建*AlsaDevice*,并以filename为key存放到mAlsaDevices  的map中保存起来.\n\n```java\nex:     /dev/snd/pcmC0D34c\n\t\tpublic int mCard;   //对应C后的一位\n        public int mDevice; //对应D- c|p中间的位\n        public int mType;   //对应其类型\n```\n对于alsaFileRemoved方法, 只需要将filename对应key的 AlsaDevice 从mAlsaDevices中删除即可.\n\n### 2.3.3. usbDeviceAdded 事件回调\n\n在前一章中介绍了通过inotify监控/dev/bus/usb下设备的机制.\n\n这里在UsbHostManager中, 在接收到usbDeviceAdded后, 处理后([endUsbDeviceAdded](#endUsbDeviceAdded)\n\n), 将事件转发给了UsbAlsaManager.在转发给UsbAlsaManager之前, 借助UsbDescriptorParser类对新添加usb设备的描述符进行了解析. 涉及到了 新增的 descriptors文件夹下的多个类的处理.(这里涉及的类是UsbACTerminal) 最终判断出该设备是否是 input设备和 output设备.(含有麦克|含有外放) \n\n```java\n/* package */ void usbDeviceAdded(UsbDevice usbDevice,\n        // 传入的两个参数是通过上述解析过程解析出来的\n        boolean isInputHeadset, boolean isOutputHeadset) {\n  // 进一步检查设备中是否含有audio的接口\n  int interfaceCount = usbDevice.getInterfaceCount();\n  for (int ntrfaceIndex = 0; !isAudioDevice && ntrfaceIndex < interfaceCount;\n       ntrfaceIndex++) {\n    UsbInterface ntrface = usbDevice.getInterface(ntrfaceIndex);\n    // interface 的 Class 为 USB_CLASS_AUDIO 说明是AUDIO设备\n    if (ntrface.getInterfaceClass() == UsbConstants.USB_CLASS_AUDIO) {\n      isAudioDevice = true;\n    }\n  }\n  if (!isAudioDevice) {\n    return;\n  }\n  // 再次调用AlsaCardsParser类对 /proc/asound/cards 文件进行解析.\n  // 规则, 对比这次解析前与解析后文件内容变化, 如果出现新的usb设备, 则返回其在mCardRecords中的index,\n  // 如果没有新添加的usb设备, 则从旧的记录中找出对应的usb设备,返回其index\n  int addedCard = mCardsParser.getDefaultUsbCard();\n  // 返回了usb设备, 才继续往下执行, 否则什么都不做\n  if (mCardsParser.isCardUsb(addedCard)) {\n    // 切换音频设备?  这个函数比较长, 后面进行分析, 主要和AUDIO_SERVICE进行了通信\n    UsbAudioDevice audioDevice = selectAudioCard(addedCard);\n    if (audioDevice != null) {\n      // 将新添加的usb audio 设备 以 usbDevice 添加到 mAudioDevices map中保存\n      mAudioDevices.put(usbDevice, audioDevice);\n      Slog.i(TAG, \"USB Audio Device Added: \" + audioDevice);\n    }\n    // 如果 /proc/asound/devices 中有 midi 的device, 且 android.software.midi 开关打开, 继续添加 midi device. 下面的不是重点.\n    boolean hasMidi = mDevicesParser.hasMIDIDevices(addedCard);\n       if (hasMidi && mHasMidiFeature) {\n         int device = mDevicesParser.getDefaultDeviceNum(addedCard);\n         // 等着 /dev/snd 下出现相应的 midi设备文件, 如果超时,直接返回null, 跳过后面的添加过程\n         AlsaDevice alsaDevice = waitForAlsaDevice(addedCard, device, AlsaDevice.TYPE_MIDI);\n         ... // 省略设备描述相关内容\n         UsbMidiDevice usbMidiDevice = UsbMidiDevice.create(mContext, properties,\n                                                              alsaDevice.mCard, alsaDevice.mDevice);\n         if (usbMidiDevice != null) {\n           // 以 usbDevice为key, 存放到 mMidiDevices map中\n           mMidiDevices.put(usbDevice, usbMidiDevice);\n         }\n       }\n  }\n```\n通过上面的过程分析, 可见UsbAlsaManager的流程:\n\n对于USB audio类型的设备, 首先扫描 `/proc/asound/cards `文件, 找出usb设备, 在inotify检测到`/dev/bus/usb`下有新增的usb设备时, UsbHostManager将相应的usbDeviceAdded回调转发给UsbAlsaManager, 转发前解析了设备的desciptor, 判断其中是否含有麦克/外放设备.  Alsa处理该转发时, 还需要去查找设备的接口中是否有USB_CLASS_AUDIO Class. 上述条件都满足时, 还要再次对` /proc/asound/cards ` 文件进行扫描. 查找最近添加的usb audio设备. 查到了, 则调用selectAudioCard函数, 连接音频设备.\n\n关键函数是 selectAudioCard 函数. 下面对该函数进行进一步分析:\n\n```java\n/* package */ UsbAudioDevice selectAudioCard(int card) {\n\t...\n    // 继续扫描   \"/proc/asound/devices\" 文件\n    mDevicesParser.scan();\n    // device 为 0\n    int device = mDevicesParser.getDefaultDeviceNum(card);\n    // device的数据结构:\n    /* int mCardNum\n       int mDeviceNum\n       int mDeviceType\n       int mDeviceDir */\n     boolean hasPlayback = mDevicesParser.hasPlaybackDevices(card);\n     boolean hasCapture = mDevicesParser.hasCaptureDevices(card); \n     // Playback device file needed/present?\n     //  audio playback 设备, 需要等 /dev/snd 下生成了对应的pcmC<card>D<device>p 设备节点生成, 注意此时的 device 为 0. card为相应的usb设备的卡. 等待超时时长  2.5s\n     if (hasPlayback && (waitForAlsaDevice(card, device, AlsaDevice.TYPE_PLAYBACK) == null)) {\n            return null;\n        }\n  \t  // Capture device file needed/present?\n     // audio capture 设备, 需要等 /dev/snd下 pcmC<card>D<device>c 设备节点生成,   等待超时时长  2.5s\n     if (hasCapture && (waitForAlsaDevice(card, device, AlsaDevice.TYPE_CAPTURE) == null)) {\n            return null;\n        }\n      // 生成  UsbAudioDevice 对象, 对应的数据结构:\n      /*\n        mCard = card;\n        mDevice = device;\n        mHasPlayback = hasPlayback;\n        mHasCapture = hasCapture;\n        mDeviceClass = deviceClass;    usb设备为kAudioDeviceClass_External\n      */\n      UsbAudioDevice audioDevice =\n                new UsbAudioDevice(card, device, hasPlayback, hasCapture, deviceClass);\n      // 通过 card 索引 从 mCardRecords 索引到 记录的 AlsaCardRecord\n      AlsaCardsParser.AlsaCardRecord cardRecord = mCardsParser.getCardRecordFor(card);\n      //proc/asound/cards 查看这些信息\n      audioDevice.setDeviceNameAndDescription(cardRecord.mCardName, cardRecord.mCardDescription);\n     // Notifies AudioService when a device is added or removed\n     // audioDevice - the AudioDevice that was added or removed\n     // enabled - if true, we're connecting a device (it's arrived), else disconnecting\n      // 与 AUDIO_SERVICE 进行交互, 连接当前audio设备.\n1.      notifyDeviceState(audioDevice, true /*enabled*/);\n\n      return audioDevice;\n}\n// 还需要详细看一下     notifyDeviceState 函数:\n// 分别连接录音设备和 播放设备.\n1. private void notifyDeviceState(UsbAudioDevice audioDevice, boolean enabled) {\n        int state = (enabled ? 1 : 0);\n        if (alsaCard < 0 || alsaDevice < 0) {\n            Slog.e(TAG, \"Invalid alsa card or device alsaCard: \" + alsaCard +\n                        \" alsaDevice: \" + alsaDevice);\n            return;\n        }\n        // \"card=\" + card + \";device=\" + device + \";\";\n        String address = AudioService.makeAlsaAddressString(alsaCard, alsaDevice);\n        try {\n            // Playback Device   //对应播放设备\n            if (audioDevice.mHasPlayback) {\n                int device;\n                // 这个是通过解析usb设备的描述符得到的\n                if (mIsOutputHeadset) {\n                    device = AudioSystem.DEVICE_OUT_USB_HEADSET;\n                } else {\n                    device = (audioDevice == mAccessoryAudioDevice\n                        ? AudioSystem.DEVICE_OUT_USB_ACCESSORY\n                        : AudioSystem.DEVICE_OUT_USB_DEVICE);\n                }\n                mAudioService.setWiredDeviceConnectionState(\n                        device, state, address, audioDevice.getDeviceName(), TAG);\n            }\n\n            // Capture Device   //对应录音设备\n            if (audioDevice.mHasCapture) {\n                int device;\n                if (mIsInputHeadset) {\n                    device = AudioSystem.DEVICE_IN_USB_HEADSET;\n                } else {\n                    device = (audioDevice == mAccessoryAudioDevice\n                        ? AudioSystem.DEVICE_IN_USB_ACCESSORY\n                        : AudioSystem.DEVICE_IN_USB_DEVICE);\n                }\n                mAudioService.setWiredDeviceConnectionState(\n                        device, state, address, audioDevice.getDeviceName(), TAG);\n            }\n        }\n    }\n```\n关于AudioService的setWiredDeviceConnectionState:\n\n   1.  判断是否需要发送拔出耳机的intent; (拔出耳机时,需要将当前播放的音频停掉)\n   2.  通过底层AudioSystem处理设备的连接和断开连接\n   3.  发送Intent广播(ex: ACTION_HEADSET_PLUG)通知外设状态变化\n\n关于`\"/proc/asound/devices\"` 文件内容:\n\n```powershell\nsp9832e_1h10:/proc/asound # cat devices                                        \n  0: [ 0]   : control\n 16: [ 0- 0]: digital audio playback\n 17: [ 0- 1]: digital audio playback\n 20: [ 0- 4]: digital audio playback\n 21: [ 0- 5]: digital audio playback\n 24: [ 0- 0]: digital audio capture\n 25: [ 0- 1]: digital audio capture\n```\n\n可见对应整个流程,需要四个条件准备就绪: \n\n1.  /dev/bus/usb/ 下出现了新的设备, 且解析设备描述符为 HEADSET相关的设备:(desciptor, 判断其中是否含有 麦克/外放设备.  还需要去查找设备的接口中是否有USB_CLASS_AUDIO Class)\n2.  /dev/snd/下出现对应的音频设备\n3.  \"/proc/asound/cards\" 中出现对应的声卡\n4.  \"/proc/asound/devices\" 中出现对应的设备描述\n\n上述过程对应Alsa架构的音频设备管理.\n\n[Alsa 架构声卡相关知识](http://blog.csdn.net/azloong/article/details/44181421)\n\n\n![alsa-jiagou](/images/alsa-jiagou.png)\n\n\n\n# 3. Usb device管理\n\n手机作为usb设备,主要是和pc端的交互.pc作为usb主机, 与手机进行usb通信.\n\n## 3.1. Usb枚举过程\n\n\n![usb枚举](/images/usb枚举.png)\n\n\n\n切换function涉及到的逻辑:\n\n![switch_function](/images/switch_function.png)\n\n\n\nClient 对应app或者其他服务.\n\n一个USB接口扩展出多个设备功能的实现方法有两种:\n\n- 在设备外部或内部加Hub扩展\n\n- 以Usb Composite Device方式实现（一般称为复合设备）。\n\n  复合设备其实只是一个USB设备，只有一个USB设备地址，它实现多个功能的原因主要在于它扩展实现了多个USB接口，每个接口具有不同的设备类型。Android下采用了USB Composite Device这种方式来实现一个USB口的情况下扩展出多个功能设备，这种情况下一个USB接口（Interface）便对应一种类型的功能设备，需要实现与之对应的功能驱动。\n  \n  ![usb composite](/images/usb composite.png)\n\n  \n\n## 3.2. 传统Usb device与accessory(配件)模式\n\nAndroid设备作为传统device设备, host端主要是pc(也可以是手机). 如mtp/ptp/mass_storage/虚拟光驱/tethering模式等.\n\nAndroid设备还可以作为accessory设备, 以USB Device的角色与一些具有USB Host功能，但却扮演着配件角色的设备相连.\n\n这些设备可能是机器人控制器、Dock（基座）、诊断设备、音响设备、配电设备、读卡器等等。\n\nGoogle引入USB Accessory概念的原因应该主要有如下：\n\n- 非常多的Android设备不具有USB Host的功能而只具有USB Device功能，或者即使具备USB Host的功能，也承担不起对USB外设供电的任务，因为便携式Android设备本身的电池容量就很有限。\n- 原来的Android设备，作为USB Device所实现的功能相对比较简单，内置的功能只有U盘或ADB调试设备等，Google希望提供应用层的USB开发库，让更多的软硬件厂商来开发新的功能，比如说安装一个APK应用，然后通过USB连接到一个与电视机配套的Dock上，就可以让一台Android手机变身为一个电视机遥控器。 \n\n当Android设备作为Host模式时为USB总线供电；当Android设备连接到一个USB Accessory设备时，USB Accessory设备以Host身份为USB总线供电。\n\n![usb_device_mode](/images/usb_device_mode.png)\n\n\n\nUSB Accessory设备: 配件设备, 以host方式供电\n\nAndroid 设备:  device角色, usb function切换为accessory.\n\n两台手机互联时, 在打开accessory mode情况下, 连接adapter的一端为USB Accessory设备, 直接microusb或typec接口的一端为device设备.\n\n### 3.2.1. accessory模式下的枚举过程:\n\nUSB Accessory设备和Android设备两者双方整个枚举识别工作过程如下：\n\n- USB Accessory设备发起USB控制传输进行正常的USB设备枚举，获取设备描述符和配置描述符等信息，此时大部分Android设备上报的还只是普通的U盘或MTP设备；\n- USB Accessory设备发起Vendor类型，request值为51（0x33）的控制传输命令（ACCESSORY_GET_PROTOCOL），看看该Android设备是否支持USB Accessory功能，如果支持的话会返回所支持的AOA协议版本\n- USB Accessory设备判断到该Android设备支持Accessory功能后，发起request值为52（0x34）的控制传输命令（ACCESSORY_SEND_STRING），并把该Accessory设备的相关信息（包括厂家，序列号等）告知Android设备\n- 如果是USB Audio Accessory设备，还会发起request值为58（0x3A）的控制传输命令（SET_AUDIO_MODE命令），通知Android设备进入到Audio Accessory模式\n- USB Accessory设备发起request值为53（0x35）的控制传输命令（ACCESSORY_START），通知Android设备切换到Accessory功能模式开始工作。Android设备收到此uevent信息后，会先把sys.usb.config设置为包含accessory功能,此后Android设备工作在accessory 模式下. 厂商可以通过该模式开发出适用各种场景的usb配件.\n\n### 3.2.2. accessory模式框架\n\n![accessory_mode_control](/images/accessory_mode_control.png)\n\n\n\n在Android设备切换为accessory function成功后, 会触发configured的流程, 回调accessoryAttached函数.\n\n通过匹配`android.hardware.usb.action.USB_ACCESSORY_ATTACHED`intent找到厂商的apk.apk在onCreate时会接收到的主要参数为UsbManager.EXTRA_ACCESSORY, 携带了usb accessory设备的描述信息. 也可以通过`getAccessoryList`接口拿到当前已经连接的accessory配件.\n\n```java\n    private final  String  mManufacturer;\n    private final  String  mModel;\n    private final  String mDescription;\n    private final  String mVersion;\n    private final  String mUri;\n    private final  String mSerial;\n```\n\n```xml\n\t\t<activity android:name=\"UsbAccessoryActivity\" android:label=\"DemoKit\"\n\t\t\tandroid:taskAffinity=\"\" android:launchMode=\"singleInstance\">\n\t\t\t<intent-filter>\n\t\t\t\t<action android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\" />\n\t\t\t</intent-filter>\n\n\t\t\t<meta-data android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\"\n\t\t\t\tandroid:resource=\"@xml/accessory_filter\" />\n\t\t</activity>\n```\n\n通过openAccessory方法拿到fd, 通过fd拿到输入输出流进行传输控制\n\n```java\nUsbManager usbManager = getContext().getSystemService(UsbManager.class);\nParcelFileDescriptor fd = usbManager.openAccessory(accessory);\nInputStream is = new ParcelFileDescriptor.AutoCloseInputStream(fd))\nOutputStream os = new ParcelFileDescriptor.AutoCloseOutputStream(fd))\n```\n\n而host端传输方式(假设host是手机)\n\n```java\nUsbDeviceConnection connection = mUsbManager.openDevice(device);\nUsbInterface iface = null;\nfor (int i = 0; i < device.getConfigurationCount(); i++) {\n    if (device.getInterface(i).getName().equals(\"Android Accessory Interface\")) {\n        iface = device.getInterface(i);\n        break;\n    }\n}\n//拿到输入流 输出流端口\nfinal UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);\nfinal UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);\n// 往device端发送\nint numSent = connection.bulkTransfer(out, sizeBuffer, 1, 0);\n// 接收device端的回复\nbyte[] recBytes = new byte[1];\nint numReceived = connection.bulkTransfer(in, recBytes,\n                recBytes.length, timeout);\n```\n\n#### 3.2.2.1. 申请accessory权限\n\n打开accessory配件需要权限, 需要应用进行动态申请.\n\n```java\n//uidList中保存了已经为该accessory申请权限的应用的uid列表.\nmAccessoryPermissionMap.put(accessory, uidList);\n```\n\n```java\nUsbManager mUsbManager = (UsbManager) getSystemService(Context.USB_SERVICE);\n//权限名称任意,仅是标识作用\nprivate static final String ACTION_USB_PERMISSION =\n    \"com.android.example.USB_PERMISSION\";\n...\nmPermissionIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);\nIntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);\nregisterReceiver(mUsbReceiver, filter);\n// 通过hasPermission方法查询是否已经有该配件的权限, 没有则申请权限, 启动UsbPermissionActivity弹框提示是否需要授权该类配件的权限.点击授予会调用PendingIntent.send方法发送该广播. \nif(!mUsbManager.hasPermission(accessory))\n     mUsbManager.requestPermission(accessory, mPermissionIntent);\n\nprivate final BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {\n\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if (ACTION_USB_PERMISSION.equals(action)) {\n            synchronized (this) {\n                UsbAccessory accessory = (UsbAccessory) intent.getParcelableExtra(UsbManager.EXTRA_ACCESSORY);\n                // 权限被授予\n                if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {\n                    if(accessory != null){\n                        //call method to set up accessory communication\n                        // 权限授予后, 可以进行通信.\n                    }\n                }\n                else {\n                    Log.d(TAG, \"permission denied for accessory \" + accessory);\n                }\n            }\n        }\n    }\n};\n```\n\n[Accessory的google官方文档](#https://developer.android.com/guide/topics/connectivity/usb/accessory)\n\naccessory模式的框架与host框架开发类似. host模式下device设备开发文档见[host overview](#https://developer.android.com/guide/topics/connectivity/usb/host)\n\n## 3.3. Usb 网络共享\n\nusb模式涉及到usb网络共享. (usb网络绑定与逆绑定)\n\n网络共享服务基于微软开发的rndis协议. 主要用于windows平台中usb网络设备的驱动开发.当手机通过usb连接到主机,启用usb绑定.需要将手机上的usb设置为rndis.主机上识别到新的网卡.要使用通过USB绑定的网卡,需要给主机分配IP地址.\n\n在USB绑定中,主机是DHCP的客户端,手机是DHCP的服务器端.Android中使用了DNSmasq充当DHCP服务器.\n\n切换为网络共享的流程和其他的模式是一样的, 都是通过UsbDeviceManager设置属性, init写入driver的相关节点, 开启rndis模式.开启后通过driver上报的uevent事件, 判断驱动是否可以正常工作.当收到configured状态时,开始真正的配置网络.\n\n### 3.3.1. 配置网卡\n\n等rndis切换成功后, Android设备网卡的节点会出现rndis0/usb0的接口.\n\n```shell\nsp9832a_2h11:/sys/class/net # ls -l\ntotal 0\nlrwxrwxrwx 1 root root 0 2012-01-07 00:54 dummy0 -> ../../devices/virtual/net/dummy0\nlrwxrwxrwx 1 root root 0 2012-01-07 00:54 ip6tnl0 -> ../../devices/virtual/net/ip6tnl0\nlrwxrwxrwx 1 root root 0 2012-01-07 00:54 lo -> ../../devices/virtual/net/lo\nlrwxrwxrwx 1 root root 0 2012-01-07 00:56 rndis0 -> ../../devices/20200000.usb/gadget/net/rndis0\nlrwxrwxrwx 1 root root 0 2018-07-11 10:38 usb0 -> ../../devices/platform/soc/soc:ap-ahb/e2500000.usb2/gadget/net/usb0\nlrwxrwxrwx 1 root root 0 2012-01-07 00:54 seth_lte0 -> ../../devices/virtual/net/seth_lte0\n...\n```\n\n### 3.3.2. StateMachine\n\n#### 3.3.2.1. state 模式\n\n将对象的状态封装成一个对象，在不同的状态下同样的调用执行不同的操作\n\n对象内部状态决定行为方式，对象状态改变则行为方式改变.封装对象的状态是将对象的状态与行为封装在一起；可以解决庞大的分支语句带来程序阅读性差和不便于进行扩展问题，使整个结构变得更加清晰明了，降低程序管理的复杂性提高灵活度。\n\n![stateMachine](/images/stateMachine.jpg)\n\n\n\nStateMachine的构造函数都是protected类型，不能实例化；都是由其子类进行初始化操作；\n\n```java\nprotected StateMachine(String name) {\n    mSmThread = new HandlerThread(name);\n    mSmThread.start();\n    Looper looper = mSmThread.getLooper();\n\n    initStateMachine(name, looper);\n}\n```\n\n#### 3.3.2.2. State Machine各个模块作用\n\n- **State**\n\n状态的基类，stateMachine中的状态都是由State派生而来，构造函数protected，不能实例化；只能由子类继承进行实例化.\n\n```java\npublic class State implements IState\n{\n　　protected State() {}\n　　public void enter() {}\n　　public void exit() {}\n　　public boolean processMessage(Message msg) {}\n　　public String getName() {}\n}\n```\n\n- **SmHandler**\n\n  **SmHandler**的内部类\n\n  - **StateInfo**\n\n    **存储当前State，和其parentState，以及是否激活状态；用来构建树形层次结构模型**\n\n    ```java\n    private class StateInfo \n    {\n    　　/** the  state */\n    　　State state;\n    　　/** The parent of this state, null if there is no parent */\n    　　StateInfo parentStateInfo;\n    　　/** True when the state has been entered and on the stack */\n    　　boolean active;\n    }\n    ```\n\n    \n\n  - HaltingState与QuittingState\n\n    都是State的 派生类，用于在状态停止和放弃之后处理的一些事情；都重写了ProcessMessage方法，\n\n    在StateMachine没有实际行动仅仅保留用于扩展。\n\n  整个SmHandle是消息处理派发和状态控制切换的核心，运行在单独的线程上。\n\n```java\n  private static class SmHandler extends Handler \n  {\n  　　/** The current message */\n  　　private Message mMsg;\n  \n  　　/** Stack used to manage the current hierarchy of states */\n  　　private StateInfo mStateStack[];\n  \n  　　/** The map of all of the states in the state machine */\n  　　private HashMap<State, StateInfo> mStateInfo =\n  　　　　new HashMap<State, StateInfo>();\n  \n  　　/** The initial state that will process the first message */\n  　　private State mInitialState;\n  \n  　　/** The destination state when transitionTo has been invoked */\n  　　private State mDestState;\n  }\n```\n\n##### 3.3.2.2.1. Smhandler\n\n  **SmHandle是构建StateMachine的核心，运行在独立的线程上，有三个功能：**\n\n  + 建立树形层次结构存储State；\n\n    在构成一个状态机前需要确定当前都多少状态，需要将这些状态集中起来进行管理。\n\n    StateMachine提供了这样一个protected类型方法 addState来将状态\n\n    ```java\n    /****************************************************\n    * state:　　　　加入state machine的State\n    * parent:  　　the parent of state, patent的状态节点可以为空\n    ****************************************************/\n    private final StateInfo addState(State state, State parent) {\n        StateInfo parentStateInfo = null;\n        if (parent != null) {\n            //获取当前状态parent详细信息 StateInfo\n            parentStateInfo = mStateInfo.get(parent);\n            if (parentStateInfo == null) {\n               //当前状态父状态未加入到StateMachine中，\n    　　　　　　//递归先加入其Parent State\n                parentStateInfo = addState(parent, null);\n            }\n        }\n        //判断当前状态是否加入到 StateMachine层次结构中\n        StateInfo stateInfo = mStateInfo.get(state);\n        if (stateInfo == null) {\n            //创建State详细信息对象，将其加入到StateMachine层次结构中\n            stateInfo = new StateInfo();\n            mStateInfo.put(state, stateInfo);\n        }\n    \n        //验证我们有没有加入相同的状态，在两个不同层次，否则异常\n        if ((stateInfo.parentStateInfo != null)\n                && (stateInfo.parentStateInfo != parentStateInfo)) {\n            throw new RuntimeException(\"state already added\");\n        }\n        stateInfo.state = state;\n        stateInfo.parentStateInfo = parentStateInfo;\n        stateInfo.active = false;\n        return stateInfo;\n    }\n    ```\n\n    ```java \n    private HashMap<State, StateInfo> mStateInfo = new HashMap<State, StateInfo>();\n    ```\n\n    **mStateInfo**是按照tree层次组织State的.\n\n    ```java\n    　　SmHandle sm;\n    　　sm.addState(S0,null);\n    　　sm.addState(S1,S0);\n    　　sm.addState(S2,S0);\n    　　sm.addState(S3,S1);\n    　　sm.addState(S4,S1);\n    　　sm.addState(S5,S2);\n    　　sm.addState(S6,S2);\n    　　sm.addState(S7,S2);\n    //设置初始状态\n    　　setInitialState(S4);      \n    ```\n\n    \n    ![state_tree](/images/state_tree.jpg)\n\n    \n\n  + 状态机的StateStack建立和状态切换；\n\n    各状态State加入到StateMachine，各条件初始化OK后，就可以启动状态机了。\n\n    ***``启动状态机``***:\n\n    ```java\n    　　public void start() \n    　　{\n    　　　　/** Send the complete construction message */\n    1.　　　　mSmHandler.completeConstruction();\n    　　}\n    1. private final void completeConstruction()\n    {\n        //计算State tree的最大深度以便创建运行State Stack\n        int maxDepth = 0;\n        for (StateInfo si : mStateInfo.values()) {\n               int depth = 0;\n               for (StateInfo i = si; i != null; depth++) {\n                      i = i.parentStateInfo;\n               }\n               if (maxDepth < depth) {\n                      maxDepth = depth;\n               }\n        }\n    \n        //创建State Stack\n        mStateStack = new StateInfo[maxDepth];\n        mTempStateStack = new StateInfo[maxDepth];\n    \n        //根据当前mDestState（S5）按照其层次结构沿着其父子关系，\n        //保存此条路径上的StateInfo 存储到State Stack中于是\n        //例如:S0--S2—S5 存储到mStateStack中\n        setupInitialStateStack();\n    \n        //层次结构状态构建完成调用mStateStack中State的enter方法\n        //使mStateStack中的State 处于active状态\n        mIsConstructionCompleted = true;\n        mMsg = obtainMessage(SM_INIT_CMD);\n        invokeEnterMethods(0);\n    \n        //Perform any transitions requested by the enter methods\n    1.1    performTransitions();      //待下面分析\n    }\n    ```\n\n    State Stack里面的元素结构是根据父子关系组成链式结构：S0——S2——S5；S5是mDestState，\n\n    S2，S0都是其parentState；状态是一种父子关系；\n\n    ***`状态切换`***:\n\n    StateMachine中提供了方法：  \n\n    ```java\n    protected final void transitionTo(IState destState) \n    {\n    　　mSmHandler.transitionTo(destState);\n    }\n    private final void transitionTo(IState destState) \n    {\n    　　// mDestState保存当前状态 来处理消息；\n    　　mDestState = (State) destState;\n    }\n    ```\n\n     **transitionTo**仅仅是改变了当前状态mDestState，从StateStack建立这里可以看到和这个mDestState相关的还有mStateStack，如果改变了mDestState，mStateStack也需要改变，使mStateStack仍然是链式层次式结构。\n\n    - 需要改变mStateStack: \n\n      mDestState改变时，没有同时改变 mStateStack，而是等到消息处理派发状态Handle的时候，当前的状态行为处理完，切换到下一个状态，即消息处理完毕然后才进行mStateStack的更新。目的是使状态切换和mStateStack的更新独立开来.\n\n      > ex:\n      >\n      > ​       mStateStack中存储：S0——S2——S5 mDestState为S5 （栈顶）\n      >\n      > ​       现在状态切换为S3，mDestState为S3\n      >\n      > ​       按照父子关系，mStateStack应该存储有：S0——S1——S3\n      >\n      > ​       那么此时S5，S2都要出栈pop from mStateStack\n      >\n      > ​       那我们就是要找到一个点，让S5，S2出栈；S3，S1进栈；\n\n```java\n1.1 //Do any transitions\n    private synchronized void performTransitions() \n{\n    ...\n        State destState = mDestState;\n    while (true) {\n        {\n            //当前状态切换了 存在于mStateStack中的State需要改变\n            //仍然按照链式父子关系来存储\n            //先从当前状态S3找到 最近的被激活的parent状态S0\n            //未被激活的全部保存起来(S3,S1) 返回S0\n            StateInfo commonStateInfo = setupTempStateStackWithStatesToEnter(destState);\n\n            //将mStateStack中 不属于当前状态(S3)，\n            //关系链上的State(S5,S2)退出(执行exit方法)\n            invokeExitMethods(commonStateInfo);\n\n            //将S3关系链 加入到栈中(S3,S1)\n            int stateStackEnteringIndex = moveTempStateStackToStateStack();\n\n            //将新加入到mStateStack中 未被激活的State激活(S3,S1)\n            invokeEnterMethods(stateStackEnteringIndex);\n\n            //将延迟的消息移动到消息队列的前面，以便快速得到处理               \n            moveDeferredMessageAtFrontOfQueue();\n            if (destState != mDestState) {\n                // A new mDestState so continue looping\n                destState = mDestState;\n            } else {\n                // No change in mDestState so we're done\n                break;\n            }\n        }\n        }\n```\n\n\n  + 消息处理和派发；\n\n  StateMachine处理的核心就是SmHandler，就是一个Handler，运行在单独线程中。\n\nHandler是用来异步处理派发消息，这里使用Handler管理各个状态，派发消息处理到各个状态中去执行。\n\n　　状态机准备OK后（状态加入和状态栈构建完成）就可以执行某些行为，接收消息进行处理，派发到当前状态去执行。\n\n看一下SmHandler中handleMessage是如何进行消息处理的。\n\n**消息接收：**\n\n​       StateMachine提供了sendMessage等方法将消息加入到消息队列中，当然都是交给SmHandler去处理的。\n\n消息处理:\n\n```java\npublic final void handleMessage(Message msg) \n{\n　　//处理当前消息到state中去处理\n　　1. processMsg(msg);\n　　//消息处理完毕状态切换 更新mStateStack\n　　2. performTransitions();\n}\n1. private final void processMsg(Message msg)\n{\n　　//派发消息到state中去处理\n　　StateInfo curStateInfo = mStateStack[mStateStackTopIndex];\n　　while (!curStateInfo.state.processMessage(msg))\n　　{\n　　　　//当前状态mDestState 未处理该消息，交给其parent state处理\n　　　　curStateInfo = curStateInfo.parentStateInfo;\n　　　　if (curStateInfo == null){\n　　　　　　//此消息未被当前层次状态链处理\n　　　　}\n　　}\n}\n```\n\n\n\n到这里看到建立状态栈`mStateStack`的作用，用来支持进行链式的消息处理；（Chain of Responsibility）\n\n### 3.3.3. Tethering网络状态机\n\n\n![Tethering-state](/images/Tethering-state.svg)\n\nTethering对象使用了状态模式来实现共享连接机制的实现，为每个状态创建一个状态对象，一个状态对象根据不同情景可以切换到另一个状态对象。\n\n#### 3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)\n\nTethering类图如上， Tethering对象为每一个使用共享连接的物理接口维护一个**TetherInterfaceSM**类型的状态机,管理Tethering接口的状态。TetherInterfaceSM(`TetherInterfaceStateMachine`的简写)状态机在NetworkManagementService服务触发的interfaceAdded回调中实例化。\n\nTetherInterfaceSM类型的状态机状态:\n\n+ InitialState**（初始状态）**\n+ LocalHotspotState\n+ **TetheredState**（共享状态)\n+ **UnavailableState**（连接不可用状态） \n\n```java\n//TetherState\npublic class IControlsTethering {\n    public static final int STATE_UNAVAILABLE = 0;\n    public static final int STATE_AVAILABLE   = 1;\n    public static final int STATE_TETHERED    = 2;\n    public static final int STATE_LOCAL_ONLY  = 3;\n```\n\nTetherInterfaceSM通过isAvailable、isTethered、isErrored、getLastError等函数对外提供Tethering接口的状态信息，从而使Tethering的getTetherableIfaces、getTetheredIfaces、getTetheredIfacePairs、getTetheringErroredIfaces、getLastTetherError等函数可以从接口对应的状态机中获得Tethering接口的状态。TetherInterfaceSM状态机在正常共享工作情况下应该处于**TetheredState**状态，在TetheredState状态通过NetworkManagementService的**tetherInterface**的函数来添加使用共享连接的接口。\n\n在底层配置好rndis function后, 添加rndis0/usb0的网卡接口,会回调interfaceAdded方法, 这时会新建TetherState实例, 同时会实例化一个TetherInterfaceStateMachine对象,作为TetherState的成员, 最后以接口名称为索引,加到mTetherStates的map中保存.\n\n##### 3.3.3.1.1. TetherInterfaceSM 初始化\n\n```java\n        public TetherState(TetherInterfaceStateMachine sm) {\n            stateMachine = sm;\n            // Assume all state machines start out available and with no errors.\n            // 初始状态为 STATE_AVAILABLE\n            lastState = IControlsTethering.STATE_AVAILABLE;\n            lastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;\n        }\n    public TetherInterfaceStateMachine(\n            String ifaceName, Looper looper, int interfaceType, SharedLog log,\n            INetworkManagementService nMService, INetworkStatsService statsService,\n            IControlsTethering tetherController) {\n        ...\n        mServingMode = IControlsTethering.STATE_AVAILABLE;\n        // 初始化四个状态\n        mInitialState = new InitialState();\n        mLocalHotspotState = new LocalHotspotState();\n        mTetheredState = new TetheredState();\n        mUnavailableState = new UnavailableState();\n        // 添加了四个state, \n        1.addState(mInitialState);\n        addState(mLocalHotspotState);\n        addState(mTetheredState);\n        addState(mUnavailableState);\n        // 设置SmHandler的mInitialState为 InitialState\n        setInitialState(mInitialState);\n    }\nmTetherStates.put(iface, tetherState);\n2. tetherState.stateMachine.start();\n\n1.//  addState, 每个State的parentState都为null \n    public final void addState(State state) {\n        mSmHandler.addState(state, null);\n    }\n2.// 启动状态机. 调用completeConstruction方法.\n   public void start() {\n        SmHandler smh = mSmHandler;\n        if (smh == null) return;\n        smh.completeConstruction();\n    }\n private final void completeConstruction() {\n    ...\n    // 为InitialState更新stack. 这个上面只有它自己\n    setupInitialStateStack();\n    // smhandler 发送SM_INIT_CMD消息, 通过handleMessage处理\n    2.1 sendMessageAtFrontOfQueue(obtainMessage(SM_INIT_CMD, mSmHandlerObj));\n}\n2.1\nelse if (!mIsConstructionCompleted && (mMsg.what == SM_INIT_CMD)\n                        && (mMsg.obj == mSmHandlerObj)) {\n                    /** Initial one time path. */\n                    mIsConstructionCompleted = true;\n                    2.1.1. // 调用InitialState的enter方法\n                    invokeEnterMethods(0);\n                } \n                  2.1.2 // 更新DestState, 调用DestState的enter方法,并更新DestState的Stack, 这个地方因DestState为null, 所以这个地方可以忽略  \n                    performTransitions(msgProcessedState, msg);\n2.1.1 //调用InitialState的enter方法\n         public void enter() {\n            sendInterfaceState(IControlsTethering.STATE_AVAILABLE);\n        }\n    private void sendInterfaceState(int newInterfaceState) {\n        mServingMode = newInterfaceState;\n        mTetherController.updateInterfaceState(\n                TetherInterfaceStateMachine.this, newInterfaceState, mLastError);\n        sendLinkProperties();\n    }\n    //回头看mTetherController, 这个来自makeControlCallback函数. 注册回调的方式通知到TetherMasterSM主控状态机,\n// 关于makeControlCallback回调中的notifyInterfaceStateChange和notifyLinkPropertiesChanged后面再分析.\nnew TetherInterfaceStateMachine(\n                    iface, mLooper, interfaceType, mLog, mNMService, mStatsService,\n                    makeControlCallback(iface)));\n    private IControlsTethering makeControlCallback(String ifname) {\n        return new IControlsTethering() {\n            @Override\n            public void updateInterfaceState(\n                    TetherInterfaceStateMachine who, int state, int lastError) {\n                // 通知到TetherMasterSM主控状态机,后面分析\n                notifyInterfaceStateChange(ifname, who, state, lastError);\n            }\n\n            @Override\n            public void updateLinkProperties(\n                    TetherInterfaceStateMachine who, LinkProperties newLp) {\n                // 通知到TetherMasterSM主控状态机\n                notifyLinkPropertiesChanged(ifname, who, newLp);\n            }\n        };\n    }\n```\n\n- 初始化工作\n  - 构建tree, 添加了TISM的四个状态. \n  - 初始状态为TISM的initialState, 并调用了其enter方法, 通过回调通知到主控状态机更新state.\n  - 将mIsConstructionCompleted标记为true, 后面可以处理各个state的processmessage方法.\n\n#### 3.3.3.2. **TetherMasterSM**\n\nTethering对象还提供了一个**TetherMasterSM**类型的主控状态机，提供***共享连接的启动、停止等管理及连接状态事件的监控并向TetherInterfaceSM状态机发送事件通知***。\n\nTetherMasterSM状态机的状态包括：\n\n+ InitialState**（初始状态）**\n\n+ TetherModeAliveState（共享模式激活状态)\n\n+ ErrorState\n\n  ErrorState类型的状态\n\n  + SetIpForwardingEnabledErrorState\n  + SetIpForwardingDisabledErrorState\n  + StartTetheringErrorState\n  + StopTetheringErrorState\n  + SetDnsForwardersErrorState等出错状态\n\n正常共享工作情况下**TetherMasterSM**状态机处于**TetherModeAliveState**状态，在**TetherModeAliveState**状态打开共享连接，并调用NetworkManagementService服务的setIpForwardingEnabled、setDnsForwarders、startTethering函数启动共享连接服务。 \n\n##### 3.3.3.2.1. 主控状态机初始化\n\n在Tethering的构造函数中, 进行初始化\n\n```java\n        mTetherMasterSM = new TetherMasterSM(\"TetherMaster\", mLooper);\n//启动主控状态机\n        mTetherMasterSM.start();\n        TetherMasterSM(String name, Looper looper) {\n            super(name, looper);\n// 构建tree, 每一个的parentnode也是null\n            addState(mInitialState);\n            addState(mTetherModeAliveState);\n            addState(mSetIpForwardingEnabledErrorState);\n            addState(mSetIpForwardingDisabledErrorState);\n            addState(mStartTetheringErrorState);\n            addState(mStopTetheringErrorState);\n            addState(mSetDnsForwardersErrorState);\n\n            mNotifyList = new ArrayList<>();\n            mIPv6TetheringCoordinator = new IPv6TetheringCoordinator(mNotifyList, mLog);\n            mOffload = new OffloadWrapper();\n// 初始State为 TetherMasterSM的InitialState\n            setInitialState(mInitialState);\n        }\n```\n\nTetherMasterSM的InitialState没有enter方法, 所以在启动主控状态机时并没有执行.只是更新了InitialState的stack,并将mIsConstructionCompleted标记为true\n\n##### 3.3.3.2.2. 接收interface状态机的回调\n\n\n接着TISM的初始化工作讲, 将回调interfaceAdd或interfaceChanged后, 初始化并启动了TISM状态机. 回调了notifyInterfaceStateChange方法\n\n```java\n         // TISM initalState\n         public void enter() {\n            sendInterfaceState(IControlsTethering.STATE_AVAILABLE);\n        }\n...\n        // TODO: Move into TetherMasterSM.\n    // state = STATE_AVAILABLE\n    private void notifyInterfaceStateChange(\n            String iface, TetherInterfaceStateMachine who, int state, int error) {\n        synchronized (mPublicSync) {\n            // 在TISM初始化时, 加到mTetherStates中的\n            final TetherState tetherState = mTetherStates.get(iface);\n            if (tetherState != null && tetherState.stateMachine.equals(who)) {\n                // 更新lastState为STATE_AVAILABLE\n                tetherState.lastState = state;\n                tetherState.lastError = error;\n            }\n        }\n\n        try {\n            // data_saver相关, 暂不用关注\n            mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);\n        } \n        ...\n        int which;\n        switch (state) {\n            case IControlsTethering.STATE_UNAVAILABLE:\n            case IControlsTethering.STATE_AVAILABLE:\n                // handler 处理 EVENT_IFACE_SERVING_STATE_INACTIVE消息.\n                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;\n                break;\n            case IControlsTethering.STATE_TETHERED:\n            case IControlsTethering.STATE_LOCAL_ONLY:\n                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;\n                break;\n            default:\n                Log.wtf(TAG, \"Unknown interface state: \" + state);\n                return;\n        }\n        mTetherMasterSM.sendMessage(which, state, 0, who);\n        sendTetherStateChangedBroadcast();\n    }\n// StateMachine的handleMessage进行处理\n                if (mIsConstructionCompleted) {\n                    /** Normal path */\n1.                    msgProcessedState = processMsg(msg);\n                }\n2.                performTransitions(msgProcessedState, msg);\n3. 进到TetherMasterSm的InitialState处理\n        class InitialState extends State {\n            @Override\n            public boolean processMessage(Message message) {\n                logMessage(this, message.what);\n                switch (message.what) {\n                    case EVENT_IFACE_SERVING_STATE_ACTIVE:\n                        TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;\n                        if (VDBG) Log.d(TAG, \"Tether Mode requested by \" + who);\n                        handleInterfaceServingStateActive(message.arg1, who);\n                        transitionTo(mTetherModeAliveState);\n                        break;\n                    // 处理inactive消息,这个地方在这时什么也没做\n                    case EVENT_IFACE_SERVING_STATE_INACTIVE:\n                        who = (TetherInterfaceStateMachine) message.obj;\n                        if (VDBG) Log.d(TAG, \"Tether Mode unrequested by \" + who);\n                        handleInterfaceServingStateInactive(who);\n                        break;\n                    case EVENT_IFACE_UPDATE_LINKPROPERTIES:\n                        // Silently ignore these for now.\n                        break;\n                    default:\n                        return NOT_HANDLED;\n                }\n                return HANDLED;\n            }\n        }\n  1. // 没有转换state, 因此performTransitions也没有实际的工作.\n```\n\n在仅仅有interfaceAdd回调时, 此时的TMSM主控状态机的状态保留在InitialState. 而TISM 接口状态机的状态也保存在InitialState. 同时TetherState的lastState为STATE_AVAILABLE\n\n#### 3.3.3.3. 收到configured状态后, 开启网络共享\n\n在切换rndis成功后, 首先有网卡接口消息的上报, 然后收到configured uevent消息, 并通过广播拿到该状态后, 开启网络共享.\n\n```java\n  tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED,\n                                ConnectivityManager.TETHERING_USB);\n\n    private void tetherMatchingInterfaces(int requestedState, int interfaceType) {\n        if (VDBG) {\n            Log.d(TAG, \"tetherMatchingInterfaces(\" + requestedState + \", \" + interfaceType + \")\");\n        }\n\n        String[] ifaces = null;\n        try {\n            // 下发netd找到所有网卡接口\n            ifaces = mNMService.listInterfaces();\n        } \n        String chosenIface = null;\n        if (ifaces != null) {\n            for (String iface : ifaces) {\n                // 找到usb0/rndis0\n                if (ifaceNameToType(iface) == interfaceType) {\n                    chosenIface = iface;\n                    break;\n                }\n            }\n        }\n        changeInterfaceState(chosenIface, requestedState);\n    }\n    private void changeInterfaceState(String ifname, int requestedState) {\n        final int result;\n        switch (requestedState) {\n            case IControlsTethering.STATE_UNAVAILABLE:\n            case IControlsTethering.STATE_AVAILABLE:\n                result = untether(ifname);\n                break;\n            // 处理STATE_TETHERED\n            case IControlsTethering.STATE_TETHERED:\n            case IControlsTethering.STATE_LOCAL_ONLY:\n                result = tether(ifname, requestedState);\n                break;\n        }\n    }\n    private int tether(String iface, int requestedState) {\n        if (DBG) Log.d(TAG, \"Tethering \" + iface);\n        synchronized (mPublicSync) {\n            TetherState tetherState = mTetherStates.get(iface);\n            // 检查lastState是否是STATE_AVAILABLE, 不是的话, 状态出错\n            if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {\n                Log.e(TAG, \"Tried to Tether an unavailable iface: \" + iface + \", ignoring\");\n                return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;\n            }\n            // 通知到TISM 进入TISM的当前的状态机处理CMD_TETHER_REQUESTED消息. 消息参数为STATE_TETHERED\n            tetherState.stateMachine.sendMessage(\n                    TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);\n            return ConnectivityManager.TETHER_ERROR_NO_ERROR;\n        }\n    }\n```\n\n在开启网络共享时, 先通过TISM的状态机切换状态. \n\nTISM的InitialState处理CMD_TETHER_REQUESTED消息.\n\n```java\npublic boolean processMessage(Message message) {\n    logMessage(this, message.what);\n    switch (message.what) {\n        case CMD_TETHER_REQUESTED:\n            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;\n            switch (message.arg1) {\n                case IControlsTethering.STATE_LOCAL_ONLY:\n                    transitionTo(mLocalHotspotState);\n                    break;\n                // 处理CMD_TETHER_REQUESTED消息. 消息参数为STATE_TETHERED\n                case IControlsTethering.STATE_TETHERED:\n                    // TISM 状态机切换到TetherdState\n                    transitionTo(mTetheredState);\n                    break;\n                default:\n                    mLog.e(\"Invalid tethering interface serving state specified.\");\n            }\n            break;\n```\n\n在基类StateMachine handleMessage的末尾处理performTransitions函数.\n\n调用切换前State的Exit方法, 更新DestState的Stack, 对更新后的Stack未激活的stack执行其enter方法.\n\nTISM的InitialState没有exit方法. 只执行TetherState的enter方法.\n\n```java\n    class TetheredState extends BaseServingState {\n        @Override\n        public void enter() {\n            // 执行BaseServingState的enter方法\n            super.enter();\n            if (mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {\n                transitionTo(mInitialState);\n            }\n            3. // 通知到主控状态机\n            sendInterfaceState(IControlsTethering.STATE_TETHERED);\n            // SPRD: set sys.ril.internet_tethering prop when USB internet connected\n            if(mInterfaceType == ConnectivityManager.TETHERING_USB) {\n                SystemProperties.set(\"sys.ril.internet_tethering\", \"1\");\n            }\n        }\n        \n       class BaseServingState extends State {\n        @Override\n        public void enter() {\n            1. //  配置ipv4.\n            if (!startIPv4()) {\n                mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;\n                return;\n            }\n\n            try {\n            2. // 开启网卡usb网络共享状态, 下发netd. \n                mNMService.tetherInterface(mIfaceName);\n            } catch (Exception e) {\n                mLog.e(\"Error Tethering: \" + e);\n                mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;\n                return;\n            }\n\n            if (!isTetherIpv6SprdDesigned()) {\n                if (!startIPv6()) {\n                    mLog.e(\"Failed to startIPv6\");\n                    // TODO: Make this a fatal error once Bluetooth IPv6 is sorted.\n                    return;\n                }\n            }\n        }\n        3. //sendInterfaceState(IControlsTethering.STATE_TETHERED);\n            // TODO: Move into TetherMasterSM.\n    private void notifyInterfaceStateChange(\n            String iface, TetherInterfaceStateMachine who, int state, int error) {\n        synchronized (mPublicSync) {\n            final TetherState tetherState = mTetherStates.get(iface);\n            if (tetherState != null && tetherState.stateMachine.equals(who)) {\n                // tetherState 的lastState更新为 STATE_TETHERED\n                tetherState.lastState = state;\n                tetherState.lastError = error;\n            } \n        }\n...\n\n        int which;\n        switch (state) {\n            // 处理STATE_TETHERED\n            case IControlsTethering.STATE_TETHERED:\n            case IControlsTethering.STATE_LOCAL_ONLY:\n                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;\n                break;\n        }\n        // 主控状态机切换状态. InitialState处理EVENT_IFACE_SERVING_STATE_ACTIVE消息.\n        mTetherMasterSM.sendMessage(which, state, 0, who);\n        sendTetherStateChangedBroadcast();\n    }\n            class InitialState extends State {\n            @Override\n            public boolean processMessage(Message message) {\n                logMessage(this, message.what);\n                switch (message.what) {\n                    case EVENT_IFACE_SERVING_STATE_ACTIVE:\n                        TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;\n                        handleInterfaceServingStateActive(message.arg1, who);\n                       3.1 // 主控状态机切换为 TetherModeAliveState\n                        transitionTo(mTetherModeAliveState);\n                        break;\n                       3.2 // sendMessage的末尾处理InitialState.exit方法(这里没有实现),并更新新的State的Stack, 最后执行TetherModeAliveState 的enter方法. 激活的意思.\n        private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {\n            if (mode == IControlsTethering.STATE_TETHERED) {\n                // No need to notify OffloadController just yet as there are no\n                // \"offload-able\" prefixes to pass along. This will handled\n                // when the TISM informs Tethering of its LinkProperties.\n                mForwardedDownstreams.add(who);\n            } \n        }   \n 3.2     class TetherModeAliveState extends State {\n            boolean mUpstreamWanted = false;\n            boolean mTryCell = true;\n\n            @Override\n            // 执行enter方法.\n            public void enter() {\n                // If turning on master tether settings fails, we have already\n                // transitioned to an error state; exit early.\n                3.2.1 turnOnMasterTetherSettings\n                if (!turnOnMasterTetherSettings()) {\n                    return;\n                }\n\n                mSimChange.startListening();\n                mUpstreamNetworkMonitor.start();\n\n                // TODO: De-duplicate with updateUpstreamWanted() below.\n                if (upstreamWanted()) {\n                    mUpstreamWanted = true;\n                    mOffload.start();\n                    3.2.2 chooseUpstreamType\n                    chooseUpstreamType(true);\n                    mTryCell = false;\n                }\n            }         \n```\n\n在开启网络共享后, 先是TISM行动,  切换并激活了TetherState, 然后tetherState lastState变更到STATE_TETHERD, 并通知到主控状态机TMSM切换到TetherModeAliveState 并激活.\n\n在上面两个状态机激活绑定状态时,即在enter时, 涉及到了usb网卡的配置及激活共享等操作. 这些命令抛开state的流程单独描述.\n\n##### 3.3.3.3.1. 网络配置激活等\n\n1.  startIPv4\n\n```java\n   private boolean startIPv4() { return configureIPv4(true); }\n       private boolean configureIPv4(boolean enabled) {\n           if (VDBG) Log.d(TAG, \"configureIPv4(\" + enabled + \")\");\n           // TODO: Replace this hard-coded information with dynamically selected\n           // config passed down to us by a higher layer IP-coordinating element.\n           String ipAsString = null;\n           int prefixLen = 0;\n           if (mInterfaceType == ConnectivityManager.TETHERING_USB) {\n               // \"192.168.42.129\"\n               ipAsString = USB_NEAR_IFACE_ADDR;\n               // 24\n               prefixLen = USB_PREFIX_LENGTH;\n           }\n\n           final LinkAddress linkAddr;\n           try {\n               // 获得usb0网卡的初始配置\n               // SND -> {63 interface getcfg usb0}\n               // RCV <- {213 63 9e:84:73:52:ac:0a 0.0.0.0     0      down broadcast multicast}\n               //                mHwAddr           mAddr    prefixLen  flag  flag       flag\n               final InterfaceConfiguration ifcg = mNMService.getInterfaceConfig(mIfaceName);           \n               /*\n                   \n                   private String mHwAddr;\n                   private LinkAddress mAddr;\n                   private HashSet<String> mFlags = Sets.newHashSet();\n               */\n               InetAddress addr = NetworkUtils.numericToInetAddress(ipAsString);\n               // 更新网口config, 更新后的参数\n               // mAddr 192.168.42.129  lenth为24\n               linkAddr = new LinkAddress(addr, prefixLen);\n               ifcg.setLinkAddress(linkAddr);\n                   // enabled为true\n                   if (enabled) {\n                       //         mFlags.remove(FLAG_DOWN);    mFlags.add(FLAG_UP);\n                       ifcg.setInterfaceUp();\n                   } else {\n                       ifcg.setInterfaceDown();\n                   }\n               // mFlags.remove(\"running\");\n               ifcg.clearFlag(\"running\");\n               // SND -> {64 interface setcfg usb0 192.168.42.129 24 broadcast up multicast}\n               // 更新后的usb0网卡参数, up表示会启动该网卡\n               // 9e:84:73:52:ac:0a 192.168.42.129 24 up broadcast multicast\n               // 设置更新完成后, 会收到回复\n               // RCV <- {614 Address updated 192.168.42.129/24 usb0 128 0}\n               // RCV <- {600 Iface linkstate usb0 up}\n               // RCV <- {616 Route updated fe80::/64 dev usb0}\n               // RCV <- {614 Address updated fe80::9c84:73ff:fe52:ac0a/64 usb0 196 253}\n               mNMService.setInterfaceConfig(mIfaceName, ifcg);\n           }\n           // Directly-connected route.\n           final RouteInfo route = new RouteInfo(linkAddr);\n           if (enabled) {\n               mLinkProperties.addLinkAddress(linkAddr);\n               mLinkProperties.addRoute(route);\n           } else {\n               mLinkProperties.removeLinkAddress(linkAddr);\n               mLinkProperties.removeRoute(route);\n           }\n           return true;\n       }\n```\n\n2. 开启网卡usb网络共享状态\n\n   ```java\n   mNMService.tetherInterface(mIfaceName);\n       @Override\n       public void tetherInterface(String iface) {\n           mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);\n           try {\n               // SND -> {65 tether interface add usb0}\n               mConnector.execute(\"tether\", \"interface\", \"add\", iface);\n           } \n           List<RouteInfo> routes = new ArrayList<>();\n           // SND -> {66 interface getcfg usb0}\n           // RCV <- {213 66 9e:84:73:52:ac:0a 192.168.42.129 24 up broadcast multicast}\n           routes.add(new RouteInfo(getInterfaceConfig(iface).getLinkAddress(), null, iface));\n           addInterfaceToLocalNetwork(iface, routes);\n       }\n       public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {\n           // SND -> {67 network interface add local usb0}\n           modifyInterfaceInNetwork(\"add\", \"local\", iface);\n   \n           for (RouteInfo route : routes) {\n               if (!route.isDefaultRoute()) {\n                   // SND -> {68 network route add local usb0 192.168.42.0/24}\n                   modifyRoute(\"add\", \"local\", route);\n               }\n           }\n       }\n   ```\n\n3. turnOnMasterTetherSettings\n\n   ```java\n   3.2.1. // 跳转turnOnMasterTetherSettings 函数. 启动共享连接服务\n           protected boolean turnOnMasterTetherSettings() {\n               final TetheringConfiguration cfg = mConfig;\n               try {\n      1.             mNMService.setIpForwardingEnabled(true);\n               } catch (Exception e) {\n                   mLog.e(e);\n                   transitionTo(mSetIpForwardingEnabledErrorState);\n                   return false;\n               }\n               // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.\n               try {\n                   // TODO: Find a more accurate method name (startDHCPv4()?).\n    2.1               // TetheringConfiguration最初的信息来自于TetheringConfiguration的构造函数.\n    2.2               mNMService.startTethering(cfg.dhcpRanges);\n               } catch (Exception e) {\n                   try {\n                       mNMService.stopTethering();\n                       mNMService.startTethering(cfg.dhcpRanges);\n                   } catch (Exception ee) {\n                       mLog.e(ee);\n                       transitionTo(mStartTetheringErrorState);\n                       return false;\n                   }\n               }\n               mLog.log(\"SET master tether settings: ON\");\n               return true;\n           }\n   1. setIpForwardingEnabled\n       public void setIpForwardingEnabled(boolean enable) {\n           mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);\n           try {\n               // SND -> {70 ipfwd enable tethering}\n               mConnector.execute(\"ipfwd\", enable ? \"enable\" : \"disable\", \"tethering\");\n           } catch (NativeDaemonConnectorException e) {\n               throw e.rethrowAsParcelableException();\n           }\n       }\n    2.1 TetheringConfiguration初始化\n    // Tethering构造函数中\n    updateConfiguration();\n       private void updateConfiguration() {\n           mConfig = new TetheringConfiguration(mContext, mLog);\n           mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);\n       }\n   \n        public TetheringConfiguration(Context ctx, SharedLog log) {\n           final SharedLog configLog = log.forSubComponent(\"config\");\n   \n           tetherableUsbRegexs = ctx.getResources().getStringArray(\n                   com.android.internal.R.array.config_tether_usb_regexs);\n           \n   69    <string-array translatable=\"false\" name=\"config_tether_usb_regexs\">\n   70        <item>\"usb\\\\d\"</item>\n   71        <item>\"rndis\\\\d\"</item>\n   72    </string-array>\n       \n           // TODO: Evaluate deleting this altogether now that Wi-Fi always passes\n           // us an interface name. Careful consideration needs to be given to\n           // implications for Settings and for provisioning checks.\n           tetherableWifiRegexs = ctx.getResources().getStringArray(\n                   com.android.internal.R.array.config_tether_wifi_regexs);\n           tetherableBluetoothRegexs = ctx.getResources().getStringArray(\n                   com.android.internal.R.array.config_tether_bluetooth_regexs);\n   \n           dunCheck = checkDunRequired(ctx);\n           configLog.log(\"DUN check returned: \" + dunCheckString(dunCheck));\n   \n           preferredUpstreamIfaceTypes = getUpstreamIfaceTypes(ctx, dunCheck);\n           isDunRequired = preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN);\n   \n   2.1.1        dhcpRanges = getDhcpRanges(ctx);\n           defaultIPv4DNS = copy(DEFAULT_IPV4_DNS);\n   \n           configLog.log(toString());\n       }\n   \n   2.1.1    private static String[] getDhcpRanges(Context ctx) {\n       // 这个里面没改的话是空的,\n           final String[] fromResource = ctx.getResources().getStringArray(\n                   com.android.internal.R.array.config_tether_dhcp_range);\n           if ((fromResource.length > 0) && (fromResource.length % 2 == 0)) {\n               return fromResource;\n           }\n       // 前面的为空, 返回下面这个写死的值\n       /*\n           private static final String[] DHCP_DEFAULT_RANGE = {\n               \"192.168.42.2\", \"192.168.42.254\", \"192.168.43.2\", \"192.168.43.254\",\n               \"192.168.44.2\", \"192.168.44.254\", \"192.168.45.2\", \"192.168.45.254\",\n               \"192.168.46.2\", \"192.168.46.254\", \"192.168.47.2\", \"192.168.47.254\",\n               \"192.168.48.2\", \"192.168.48.254\", \"192.168.49.2\", \"192.168.49.254\",\n               \"192.168.137.2\", \"192.168.137.254\", \"192.168.0.2\", \"192.168.0.254\",\n          };\n         */\n           return copy(DHCP_DEFAULT_RANGE);\n       }\n   \n    2.2 mNMService.startTethering(cfg.dhcpRanges);\n       public void startTethering(String[] dhcpRange) {\n           mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);\n           final Command cmd = new Command(\"tether\", \"start\");\n           for (String d : dhcpRange) {\n               cmd.appendArg(d);\n           }\n           try {\n             //SND -> {71 tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254}\n               mConnector.execute(cmd);\n           } catch (NativeDaemonConnectorException e) {\n               throw e.rethrowAsParcelableException();\n           }\n       }\n   ```\n\n   turnOnMasterTetherSettings 主要工作就是下发了两个命令:\n\n   ```shell\n   ipfwd enable tethering\n   tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254\n   ```\n\n4. chooseUpstreamType\n\n   ```java\n     3.2.2 //  跳转chooseUpstreamType函数, 进行网络通路优化 tryCell true\n   protected int chooseUpstreamType(boolean tryCell) {\n               // We rebuild configuration on ACTION_CONFIGURATION_CHANGED, but we\n               // do not currently know how to watch for changes in DUN settings.\n               // 可能更新了配置信息, 即上面的TetheringConfiguration\n               maybeUpdateConfiguration();\n               // preferredUpstreamIfaceTypes是在TetheringConfiguration传入的, 注意系统中只定义了数据流量模式, wifi模式和蓝牙网络可以作为优选网络, 1/7/0. 在数据流量模式时, 需要检查TelephoneManager的dunCheck, dunCheck为DUN_REQUIRED时忽略数据流量模式, 即不能作为优选网络. 网络通路.     \n               final NetworkState ns = mUpstreamNetworkMonitor.selectPreferredUpstreamType(\n                       mConfig.preferredUpstreamIfaceTypes);\n               if (ns == null) {\n                   if (tryCell) {\n                       mUpstreamNetworkMonitor.registerMobileNetworkRequest();\n                       // We think mobile should be coming up; don't set a retry.\n                   } else {\n                       sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);\n                   }\n               }\n               mUpstreamNetworkMonitor.setCurrentUpstream((ns != null) ? ns.network : null);\n               // 如果找到了优选网络通路. 设置dns转发  \n     3.2.2.1          setUpstreamNetwork(ns);\n   \n               ...//ipv6 相关\n               return upV6Type;\n           }\n   3.2.2.1 \n           protected void setUpstreamNetwork(NetworkState ns) {\n               String iface = null;\n               if (ns != null && ns.linkProperties != null) {\n                   // Find the interface with the default IPv4 route. It may be the\n                   // interface described by linkProperties, or one of the interfaces\n                   // stacked on top of it.\n                   mLog.i(\"Finding IPv4 upstream interface on: \" + ns.linkProperties);\n                   // 选择最佳路由\n                   RouteInfo ipv4Default = RouteInfo.selectBestRoute(\n                       ns.linkProperties.getAllRoutes(), Inet4Address.ANY);\n                   if (ipv4Default != null) {\n                       iface = ipv4Default.getInterface();\n                       mLog.i(\"Found interface \" + ipv4Default.getInterface());\n                   } else {\n                       mLog.i(\"No IPv4 upstream interface, giving up.\");\n                   }\n               }\n   \n               if (iface != null) {                \n     1.            setDnsForwarders(ns.network, ns.linkProperties);\n               }\n                // 设置桥接转发\n     2.        notifyDownstreamsOfNewUpstreamIface(iface);\n               if (ns != null && pertainsToCurrentUpstream(ns)) {\n                   // If we already have NetworkState for this network examine\n                   // it immediately, because there likely will be no second\n                   // EVENT_ON_AVAILABLE (it was already received).\n                   handleNewUpstreamNetworkState(ns);\n               } else if (mCurrentUpstreamIface == null) {\n                   // There are no available upstream networks, or none that\n                   // have an IPv4 default route (current metric for success).\n                   handleNewUpstreamNetworkState(null);\n               }\n           }\n   ```\n\n   发现优选网络通路后,  设置dns server地址, 并进行网络地址转换和ip转发\n\n```java\n   1. // SND -> {72 tether dns set 100 192.168.1.1}\n       setDnsForwarders(ns.network, ns.linkProperties);\n   2. notifyDownstreamsOfNewUpstreamIface(iface)\n      protected void notifyDownstreamsOfNewUpstreamIface(String ifaceName) {\n               mLog.log(\"Notifying downstreams of upstream=\" + ifaceName);\n               mCurrentUpstreamIface = ifaceName;\n               for (TetherInterfaceStateMachine sm : mNotifyList) {\n                   // TISM此时处于TetherState, 因此由TetherState处理该消息\n                   sm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED,\n                           ifaceName);\n               }\n           }\n   ..//TetherState的processMessage函数\n                   case CMD_TETHER_CONNECTION_CHANGED:\n                       String newUpstreamIfaceName = (String)(message.obj);\n                       cleanupUpstream();\n                       if (newUpstreamIfaceName != null) {\n                           try {\n                               \n                              2.1  // 网络地址转换\n                               mNMService.enableNat(mIfaceName, newUpstreamIfaceName);\n                               2.2 // 启动ip转发\n                               mNMService.startInterfaceForwarding(mIfaceName,\n                                       newUpstreamIfaceName);\n                           } catch (Exception e) {\n                               mLog.e(\"Exception enabling NAT: \" + e);\n                               cleanupUpstreamInterface(newUpstreamIfaceName);\n                               mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;\n                               transitionTo(mInitialState);\n                               return true;\n                           }\n                       }\n                       mMyUpstreamIfaceName = newUpstreamIfaceName;\n                       break;\n   \n      2.1     public void enableNat(String internalInterface, String externalInterface) {\n           mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);\n           try {\n               // SND -> {74 nat enable usb0 wlan0 1 192.168.42.0/24}\n               // 网络地址转换\n               modifyNat(\"enable\", internalInterface, externalInterface);\n           } catch (SocketException e) {\n               throw new IllegalStateException(e);\n           }\n       }\n   2.2    private void modifyInterfaceForward(boolean add, String fromIface, String toIface) {\n           //  SND -> {75 ipfwd add usb0 wlan0}\n           //  RCV <- {614 Address updated fe80::9c84:73ff:fe52:ac0a/64 usb0 128 253}\n           final Command cmd = new Command(\"ipfwd\", add ? \"add\" : \"remove\", fromIface, toIface);\n           try {\n               mConnector.execute(cmd);\n           } catch (NativeDaemonConnectorException e) {\n               throw e.rethrowAsParcelableException();\n           }\n       }\n```\n\n在调用turnOnMasterTetherSettings时, 执行了tether start命令, 该命令会启动dnsmasq服务.\n\ndnsmasq启动:\n```shell\n   M00AE64 06-29 08:31:02.445  7182  7182 I dnsmasq : started, version 2.51 cachesize 150\n   M00AE65 06-29 08:31:02.445  7182  7182 I dnsmasq : compile time options: IPv6 GNU-getopt no-I18N DHCP no-scripts\n   M00AE66 06-29 08:31:02.445  7182  7182 W dnsmasq : warning: no upstream servers configured\n   M00AE67 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.0.2 -- 192.168.0.254, lease time 1h\n   M00AE68 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.137.2 -- 192.168.137.254, lease time 1h\n   M00AE69 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.49.2 -- 192.168.49.254, lease time 1h\n   M00AE6A 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.48.2 -- 192.168.48.254, lease time 1h\n   M00AE6B 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.47.2 -- 192.168.47.254, lease time 1h\n   M00AE6C 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.46.2 -- 192.168.46.254, lease time 1h\n   M00AE6D 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.45.2 -- 192.168.45.254, lease time 1h\n   M00AE6E 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.44.2 -- 192.168.44.254, lease time 1h\n   M00AE6F 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.43.2 -- 192.168.43.254, lease time 1h\n   M00AE70 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.42.2 -- 192.168.42.254, lease time 1h\n   M00AE71 06-29 08:31:02.447  7182  7182 I dnsmasq : read /etc/hosts - 2 addresses\n```\n\n##### 3.3.3.3.2. 涉及到的网络知识\n\n- tether interface add usb0\n\n   将interface写到dnsmasq  update_ifaces更新列表中, 使dnsmasq监听该新加的interface. 并在后面分配ip地址.\n\n- network interface add local usb0\n\n   添加usb0 dev网卡设备到 local路由表中\n\n- network route add local usb0 192.168.42.0/24\n\n  为usb0网卡在local表中添加路由规则   \n\n   ```shell\n   sp9853i_1h10:/ # busybox route -n \n   Kernel IP routing table\n   Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\n   192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 wlan0\n   192.168.42.0    0.0.0.0         255.255.255.0   U     0      0        0 usb0\n   ```\n\n- ipfwd enable tethering\n\n   出于安全考虑，Linux系统默认是禁止数据包转发的。\n\n   > 所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。   \n\n   启用ip转发功能, echo 1  >   IPV4_FORWARDING_PROC_FILE\n\n   ```cpp\n   const char IPV4_FORWARDING_PROC_FILE[] = \"/proc/sys/net/ipv4/ip_forward\";\n   ```\n\n- tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254\n\n   启动dnsmasq服务, DNSmasq是一个小巧且方便地用于配置[DNS](https://baike.baidu.com/item/DNS/427444)和[DHCP](https://baike.baidu.com/item/DHCP)的工具，适用于小型[网络](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C)，它提供了DNS功能和可选择的DHCP功能。它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。 \n\n- tether dns set 100 192.168.1.1\n\n  设置dnsmasq的dns服务器地址, 缓存DNS\n\n- nat enable usb0 wlan0 1 192.168.42.0/24\n\n   网络地址转换, pc地址在该网段内\n\n   usb0输入设备 wlan0为输出设备  1代表后面的地址组合只有一个    192.168.42.0/24代表ip地址和子网掩码\n\n   目的是修改来自源设备的数据包，使它看起来是目标设备发出的数据包\n\n   借助于NAT，私有（保留）地址的\"内部\"网络通过[路由器](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8)发送[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)时，[私有地址](https://baike.baidu.com/item/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80)被转换成合法的IP地址，一个局域网只需使用少量IP地址即可实现私有地址网络内所有计算机与Internet的通信需求。\n\n   NAT将自动修改IP[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87)的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成。有些应用程序将源IP地址嵌入到IP[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87)的数据部分中，所以还需要同时对报文的数据部分进行修改，以匹配IP头中已经修改过的源IP地址。否则，在[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87)数据部分嵌入IP地址的应用程序就不能正常工作   \n\n- ipfwd add usb0 wlan0\n\n  新加一条路由规则.  从usb0来的网转到wlan0去处理.\n\n  [路由规则相关案例1](https://blog.csdn.net/bytxl/article/details/9850803)\n\n  [路由规则相关案例2](http://blog.51cto.com/laodou/2066476)\n\n## 3.4. Usb pc-share pc互联网\n\n```shell\n~$ sudo adb shell busybox route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 usb0\n~$ sudo adb shell ip route\n192.168.0.0/24 dev usb0 proto kernel scope link src 192.168.0.129\n```\n\n由pc端开启网络共享,给手机使用. pc端对端地址(xp 192.168.0.1), 手机端地址(xp 192.168.0.129), \n\n```shell\n0000.log|79018| S01155E 07-23 18:12:44.495   732   945 D ConnectivityService: Switching to new default network: NetworkAgentInfo{ ni{[type: USBETHER[], state: CONNECTED/CONNECTED, reason: (unspecified), extra: (none), failover: false, available: true, roaming: false]}  network{100}  nethandle{432902426637}  lp{{InterfaceName: usb0 LinkAddresses: [192.168.0.129/24,]  Routes: [0.0.0.0/0 -> 192.168.0.1 usb0,192.168.0.0/24 -> 0.0.0.0 usb0,] DnsAddresses: [192.168.0.1,] UsePrivateDns: false PrivateDnsServerName: null Domains: null MTU: 0}}  nc{[ Transports: ETHERNET Capabilities: INTERNET&NOT_RESTRICTED&TRUSTED&NOT_VPN&FOREGROUND&NOT_SUSPENDED Unwanted: ]}  Score{11}  everValidated{false}  lastValidated{false}  created{true} lingering{false} explicitlySelected{false} acceptUnvalidated{false} everCaptivePortalDetected{false} lastCaptivePortalDetected{fals[} clat{null} ]\n``: \n\n","tags":["Android"],"categories":["USB"]},{"title":"fde加密与解锁","url":"/2018/05/19/其他调研/fde加密与解锁/","content":"\n# fde加密与解锁\n\n## 加锁状态\n有以下 几种加锁状态：\n\n- 默认\n- PIN 码\n- 密码\n- 解锁图案\n- 指纹\n- 人脸解锁\n\n其中指纹加锁的前提是必须有pin/密码/解锁图案的其中一种。所以可以只看pin/密码/pattern图案解锁即可\n## 首次启动默认密码的情况\n\n首次启动时，设备会创建一个随机生成的 128 位主密钥，然后会使用`默认密码`和`存储的盐`对其进行哈希处理。默认密码是`default_password`。不过，设备还会通过 TEE（例如 TrustZone）为生成的哈希签名。TEE 会使用相应签名的哈希来加密主密钥。\n\n\n![密码加密](_v_images/20200212152048981_2758.png)\n\n\n## 在已加密的设备上设置安全密码或更改安全密码\n当用户在设备上设置 PIN 码/pattern图案密码或password时，只有 128 位的密钥会被重新加密并存储起来，加密设备的主密钥并不会改变。\n当用户选择在设置中更改或移除密码时，界面会向 vold 发送 cryptfs changepw 命令，然后 vold 会使用新密码重新加密磁盘主密钥。\n\n默认密码和用户设置的安全密码都是用来加密磁盘主密钥master_key的。\n\n\n![加密流程](_v_images/20200212152215253_16509.png)\n\n\n## 设置了安全密码下解密手机流程\n\n手机开机后，通过FallbackHome会 startActivity(homeIntent)，\n在开机过程中，会先跑到CryptKeeper.java(定义了intent-filter `android.intent.category.HOME`，且priority比较靠前)\n```xml\n                 <activity android:name=\".CryptKeeper\"\n3378                   androidprv:systemUserOnly=\"true\"\n3379                   android:immersive=\"true\"\n3380                   android:launchMode=\"singleTop\"\n3381                   android:excludeFromRecents=\"true\"\n3382                   android:theme=\"@style/Theme.MiuiCryptKeeper\"\n3383                   android:configChanges=\"mnc|mcc|keyboard|keyboardHidden|uiMode|touchscreen\"\n3384                   android:windowSoftInputMode=\"adjustResize\"\n3385                   android:screenOrientation=\"portrait\"\n3386                   android:process=\":CryptKeeper\">\n3387         <!-- END -->\n3388             <intent-filter android:priority=\"10\">\n3389                 <action android:name=\"android.intent.action.MAIN\" />\n3390                 <category android:name=\"android.intent.category.HOME\" />\n3391                 <category android:name=\"android.intent.category.DEFAULT\" />\n3392             </intent-filter>\n3393         </activity>\n```\n先调用setupUi方法\n```java\n// 如果部分加密失败，跳转到恢复出厂设置\n9         if (mEncryptionGoneBad || isDebugView(FORCE_VIEW_ERROR)) {\n 490             setContentView(R.layout.crypt_keeper_progress);\n 491             showFactoryReset(mCorrupt);\n 492             return;\n 493         }\n```\n通过StorageManagerService查询passwordType，最终传递到vold中通过`cryptfs_get_password_type`方法查询密钥类型是pattern/passwd/pin的哪个。这个方法是通过查询userdata块设备尾部存储的footer信息查出来的，而在加密的时候，也会根据用户密码的类似保存这样的type信息最终存储到设备的footer中\n\nCryptKeeper根据用户密码类型显示对应的密码输入页面，即`refreshUnlockEntry(passwordType)`函数\n对于密码类型，注册了监听类\n`passwordEntryInit`\n```java\nif (mPasswordEntry != null && !mCooldown){\n 872             // MIUI DEL:\n 873             // mPasswordEntry.setOnEditorActionListener(this);\n 874             mPasswordEntry.requestFocus();\n 875             // Become quiet when the user interacts with the Edit text screen.\n 876             mPasswordEntry.setOnKeyListener(this);\n 877             mPasswordEntry.setOnTouchListener(this);\n 878             mPasswordEntry.addTextChangedListener(this);\n 879             // MIUI ADD:\n 880             mMiuiKeyboardView.addKeyboardListener(mKeyboardActionListener);\n 881         }\n```\nmKeyboardActionListener的`onKeyBoardOK`时，即按了发送enter键后，会将输入的密码传出，发送给StorageManagerService\n最终传给vold，`decryptStorage(String password)-> cryptfs_check_passwd(passwd.c_str)`\n\n### 测试密码\nvold通过`test_mount_encrypted_fs`对用户密码解密出磁盘主密钥，通过磁盘主密钥对设备进行挂载，如果能挂载上，则说明用户密码是正确的\n```java\ndecrypt_master_key(passwd, decrypted_master_key, crypt_ftr, &intermediate_key,\n                               &intermediate_key_size)\n```\n### 小结\n通过上述解密过程，用户密码是明文的形式，并没有再次对用户密码进行加密。这个过程应该是可以模拟的，如果可以在recovery模式下模拟出pattern/passwd/pattern三种模式的输入，是可以在recovery模式下解密用户设置了安全密码的fde的数据的\n\n\n","tags":["fde"],"categories":["加密"]},{"title":"repart自适应调整物理分区","url":"/2017/11/12/OTA相关/repart自适应调整物理分区/","content":"\n![GPT物理分区结构](_v_images/20190313110847130_406087125.png)\n\n方案简要框图:\n```puml\n@startuml\nskinparam backgroundColor #EEEBDC\nskinparam handwritten true\nstart\n:通过分区表xml管理\\n手机中的物理分区信息;\n:将分区表信息打包到ota的原始target文件中;\n:制作升级包时,将分区表的信息解析,\\n并根据项目对分区的配置,产生分区配置文件\\n打包到ota升级包中;\n:recovery子系统进行ota升级,先置成check模式,\\n将升级包中的分区配置文件解压,\\n通过调整分区工具检查分区是否发生里变化;\nif (根据项目情况,以及分区变动的规则检查分区是否发生了变更,\\n分区变动了,由用户选择是否继续) then (用户选择继续升级)\n:根据分区变动的位置确定哪些分区需要备份,\\n对这些分区根据不同的分区备份策略进行备份;\n:将根据分区变动规则及\\n配置文件中配置的分区信息产生最终分区调整信息;\n:将分区调整信息写入到磁盘中记录分区的关键地址中;\n:根据不同的分区备份方案选择合适的分区恢复方案对数据进行恢复;\n:进行后续的没有分区变动的ota升级流程;\nstop\nelseif (分区变动了) then (用户选择不继续)\n:退出升级;\nstop\nelse (分区没有变动, 不会给用户提示)\n:进行没有分区变动的ota升级流程;\nstop\n@enduml\n```\n根据目标镜像动态自适应调整物理分区的技术，在升级过程中不会丢失用户数据。可供项目人员灵活配置哪些分区需要特殊处理，用户在升级时可以察觉到分区是否发生了变动。Ota升级时调整分区的场景完善的断电保护方案。小存储设备上可以留给用户更多的使用存储空间\n\n首先对于基于安卓的通用升级方案来说，是不能在ota升级的时候，根据目标版本动态修改物理分区的，这种方案存在以下弊端：\n\n1.目前的升级方案中，不会调整物理分区，假设目标版本的某分区因新加功能或者解决bug，调整架构等需要的空间增大了。如果项目初始阶段，分区的空间分配的比较小，量产发布给用户后，因为某分区的空间不足，往往会因不能动态的调整物理分区大小而使升级时会受限。\n2.由于项目需要，在发布版本给用户以后，可能需要新增分区或者删减分区，这种需求也会因为升级程序无法动态的调整物理分区而受限。\n3.对于ROM  磁盘比较小的设备，由于不能动态调整分区。厂家一般采用的方案是，项目初始阶段就分配好了各分区的大小。系统分区（如system分区或modem分区等）通常留有比较大的余量为后面的升级作准备。用户是看不到也不能使用这些系统分区的。这些系统分区留有的余量只能用作升级使用，不能达到很好的利用率。对于本来就很珍贵的ROM空间，造成了浪费。\n\n 针对以上缺点，本发明的方案可以在升级时自动的识别分区的改动，并进行针对性的调整。不会丢失数据，用户可以感知到调整了物理分区。用户可以毫无顾虑的进行系统升级。对于厂家而言，减小了分区配置的难度。同时也不需要协调各分区相应模块的研发人员必须按照一定的分区大小的标准进行开发。系统升级的难度变小，厂家可以更从容的推送升级包给用户，减小了用户强升某系统版本因分区不足导致的设备变砖风险。较小了维护成本以及退修返修的概率。对于ROM比较小的设备，合理利用了ROM空间。增大了用户的可使用空间。\n\n## 1. 编译系统修改\nota升级包含两个大步骤，本地对当前版本打包的过程\n将升级包推送到手机中，手机进recovery子系统执行系统升级的流程。\nOta的target-files中保存了完整的用于升级的各镜像的原始信息。\n通过该原始包来制作ota的整包和差分包。\n在展讯平台上通过xml文件管理手机设备中的物理分区。\n在存储容量比较小的设备上，为了留给用户尽量多的内部存储空间，需要将system分区的空间尽量减小。在编译时将xml中关于system分区大小的部分修正为自适应分区后的大小。（推送给用户的版本一般是只读的，debug版本需要留给system分区一定的余量方便研发人员调试）\n编译target-files文件时，需要将xml拷贝到target-files压缩文件中。拷贝时检索xml中是否含有Product、ProductList、 Partitions等关键字（预定的关键tag信息，分区的信息是里面的元素），同时包含这些关键字才进行拷贝。\n## 2. 解析xml分区表生成配置文件\n在进行整包升级,差分升级的过程中加入分区表的解析过程.\n解析文件,将分区的**名称,大小,分区备份**以及其他一些标志位写到配置文件, 将配置文件写入到ota升级包中.\n调整分区工具的参数有备份文件存放的目录,配置文件,磁盘节点名,是否为check模式等\n* 整包升级时, 不需要备份system\n* 差分升级, 需要备份system\n## 3. Recovery子系统中加入检测分区变化的功能\n从升级包中解压出分区表配置文件、repart二进制文件解压到设备的临时目录，调用repart进程，传入参数备份文件存放的目标目录、配置文件、磁盘节点名， check模式。\n解压时，先将升级包映射到共享内存中，将压缩包中的分区配置文件转移到ramdisk中的文件里。\n检测到分区变化时，根据返回码，如果有分区发生变化，弹出\n“分区已经变化，是否继续？”\n用户点击继续后，执行具体的升级流程。用户点击否，不再执行后面的流程，升级中止。\n## 4. 调整物理分区工具处理分区主要流程\n初始化GPT分区相关的一些通用数据结构，初始化gpt分区的加密表单。\n解析传入参数（磁盘节点名称、备份路径、是否为check模式、配置文件路径）\n解析配置文件，将分区信息置于一个partition的结构体中，保存各分区的**名称、大小、以及有配置文件中传来的一些关于该分区的标志位**。\nLoadPartitions 加载主分区信息头、备份分区信息头、具体分区数据：\n加载分区头及分区数据时，首先会从磁盘中load主分区头及备份分区头，通过header中的headerCRC值与整个header校验得出的CRC值进行比较，相等则该分区头是正确的数据。\n该过程中会初始化设置一些GPTData数据结构中的关键信息（如numParts 、blockSize、diskSize等）\nLoad详细分区数据时，有两个来源（**LBA2-LBA33**和**LBA-2 -- LBA-33**）。只有当数据块的CRC值与mainHeader或secondHeader的partitionEntriesCRC值匹配时，才说明是正确的数据。\n如果header或详细分区数据无法匹配对应的crc,程序终止,并报错分区数据损坏\n\n### 4.1. 检查分区是否有变化\n遍历分区表,通过比对磁盘中的分区和配置文件中的分区表,根据以下规则确定分区是否发生了变化.\n```puml\n@startuml\nstart\n:index = 0;\nwhile (index<pData->numParts) is (yes)\n    if (part[i].lastLBA==0) then (yes)\n        :index++;\n    else (no)\n        if(index> new partnum) then (yes)\n           :return index;\n           stop\n        else (no)\n            if (part[i].oldname is userdata) then (yes)\n                :index++;\n            else (no)\n                if(part[i].oldname != part[i].newname) then (yes)\n                    :return index;\n                    stop\n                else  (no)\n                    if (part[i].oldname is system) then (yes)\n                        if (oldsize > newsize) then (yes)\n                            :index++;\n                        else (no)\n                            if(newsize-oldsize>system_tolerate_size) then (yes)\n                                :return index;\n                                stop\n                            else (no)\n                                :index++;\n                            endif\n                        endif\n                    else (no)\n                        if(part[i].oldsize<part[i].newsize) then (yes)\n                            :return index;\n                            stop\n                        else(no)\n                            :index++;\n                        endif\n                    endif\n                endif\n            endif\n        endif\n    endif\nendwhile (no)\nend\n@enduml\n```\n通过如下方式判断分区有没有改变：\n1.检测分区名字是否变化\n2.检测分区大小是否有变化\n\n    system分区特殊处理、data分区特殊处理。（System分区特殊处理？如果system分区前面，有分区变动，认为分区变动；如果system是第一个变动的分区，\n    则与磁盘中的system分区大小进行比较，如果差值在经验值内，则认为此时分区没有变化，否则认为分区已经变化；如果system后面的分区变动，认为分区已经变动）。\n    Data分区不检测，直接忽略过去\n\n>System分区特殊处理的依据：\n    由于system分区是根据最终打包的system目录下的所有文件所占用的空间总量加上一定的余量做成的。每次更新版本时，system分区的大小都会变化，\n    而留有的余量通常也是比较小的如果每次更新版本都要因system分区的变动去调整分区，这样的设计会给用户带来非常差的体验，每次执行整包升级或差分升级都需要消耗\n    比较长的时间。我们给定一个经验值，判断如果这次版本与手机中已经存在的版本的system物理分区的大小小于该经验值，则认为system分区没有变动，\n    不需要只因为system分区的变动而调整物理分区\n3.检测分区总数是否有变化\n### 4.2. check 模式\n一旦检测到分区变化，将给变化的分区位置传出来。\n如果是check模式进程终止，返回结果（分区是否变化）\n### 4.3. 非check模式\n遍历partition结构体数组，变化分区的位置前面的所有分区设置备份标志为0。\n      根据分区变动的位置，再次判断那些分区需要备份。备份需要备份的分区到文件中。\n      备份时Data分区需要特殊处理，新的安卓版本中的selinux权限比较严格，升级程序不允许对data分区里的文件具有写权限。因此不能按文件拷贝data分区的内容。如果按字节直接拷贝data分区，因data分区物理分区空间较大，直接拷贝花费的时间较长。我们通过压缩文件系统，使得记录data分区文件系统的有效字节全被压缩到物理分区的前部，只需要拷贝有效的字节即可。\n       遍历需要备份的分区（备份标志位为1的分区），检查对应的备份文件是否已经存在，如果已经存在，将已有的文件删除。\n       检查外部存储剩余空间是否可以存放下备份文件。遍历需要备份的分区，根据备份标志位查看哪些分区需要备份，如果需备份的分区为data分区，需要mount 查看其已用空间，根据已用空间确定需要拷贝的大小。如果没有文件系统，则直接计算其分区大小。同时计算emmc中剩给data分区的可分配空间大小，与已用空间进行比较，如果前者比后者小，则退出程序。\n计算总的备份文件需要的空间，将该大小与外部存储卡的剩余空间大小比较，如果大于外部存储卡的剩余空间，返回返回码给脚本，脚本中加逻辑表明这时的情况是外部存储卡没有空间，终止脚本执行，并在屏幕上打印此时外部存储卡的剩余空间不足。\n\n## 5. 更新分区\n根据分区变更的原则，更新分区数据结构中各分区的起始偏移量和终止偏移量（firstLBA和lastLBA）。\n将新的分区数据结构按gpt分区的格式写入对应的四个关键地方（GPT物理分区结构图中的绿条和蓝条部分**LBA1  LBA2-33 LBA-1 LBA-2--LBA-33**）：\n写入的过程是顺序执行的，这样总能保证有一组header和entry的内容是完好的。\n开机引导程序需要支持从gpt 备份header和entry中读取分区数据，同时该调整物理分区的工具也支持，这样杜绝了系统变转的风险。\n\n## 6. 恢复分区\n按字节或文件系统恢复相应分区的数据，system分区特殊处理，system分区的数据是只读的，不能修改，也不能挂载，只能按字节拷贝。\n将Data分区有效的数据恢复回来后，需要将其文件系统扩满物理分区。每恢复完一个分区，需要将对应的备份文件删除。\n\n### 6.1. 升级过程中断电保护：\n需要充分考虑断电对整个升级流程的影响：\n>断电会打断当前的升级流程, 尤其对于备份恢复流程以及识别分区是否发生了变动，在断电后，这些判断逻辑都发生了变化。\n\n断电后，手机会重新进入recovery模式重新从头开始进行升级过程。\n需要一个标志位，标记手机重启前是否正在升级，且未完成升级过程，中间发生了意外断电。\n进recovery子系统后，一旦检测到该标志位有效，忽略检测过程，不需要用户参与，即使分区没有变化，也直接进入repart程序进行分区的管理。\n\n1.  此时分区没有变动，说明 上次执行时 是在更新完分区后断电退出的，一般是恢复分区的流程进行了一部分。\n        需要找备份目录中存在哪些备份文件，并校验备份文件，如果校验通过，则需要将备份文件写入到对应的分区中。\n2. 分区发生了变动，说明上次执行时还没有更新分区就发生了断电，一般是备份分区过程中发生了断电。\n        对于检测到的需要备份的分区，校验已经存在的备份文件的正确性，如果校验通过，则不需要对该分区再进行从分区备份的工作。","tags":["gpt"],"categories":["Android"]},{"title":"统计app 总使用空间","url":"/2017/10/01/存储相关/统计app总使用空间/","content":"\n\n\n# 1. Android 8.1\n\n## 1.1. 涉及的文件\n\n-   StorageStats.java\n\n-   AppStorageSettings.java\n\n-   InstalledAppDetails.java\n\n-   StorageStatsManager.java\n\n-   StorageStatsService.java\n\n-   PackageManagerService.java\n\n## 1.2. 相关代码\n\n计算方式: \n\ntotalSize = stats.(codeSize + externalCodeSize + dataSize + externalDataSize + cacheSize +externalCacheSize );\n\n```java\n\npublic void updateUi(Context context) {\n  if (mLastResult == null) {\n   ...\n  } else {\n    long codeSize = mLastResult.getCodeBytes();\n    long dataSize =\n      mDataCleared ? 0 : mLastResult.getDataBytes() - mLastResult.getCacheBytes();\n    if (mLastCodeSize != codeSize) {\n      mLastCodeSize = codeSize;\n      mAppSize.setSummary(getSizeStr(context, codeSize));\n    }\n    if (mLastDataSize != dataSize) {\n      mLastDataSize = dataSize;\n      mDataSize.setSummary(getSizeStr(context, dataSize));\n    }\n    long cacheSize = (mDataCleared || mCachedCleared) ? 0 : mLastResult.getCacheBytes();\n    if (mLastCacheSize != cacheSize) {\n      mLastCacheSize = cacheSize;\n      mCacheSize.setSummary(getSizeStr(context, cacheSize));\n    }\n    // codeBytes + dataBytes + cacheBytes\n    long totalSize = codeSize + dataSize + cacheSize;\n    if (mLastTotalSize != totalSize) {\n      mLastTotalSize = totalSize;\n      mTotalSize.setSummary(getSizeStr(context, totalSize));\n    }\n  }\n}\n\nupdateUiWithSize(mSizeController.getLastResult());\n\n@Override\npublic void onLoadFinished(Loader<AppStorageStats> loader, AppStorageStats result) {\n  mSizeController.setResult(result);\n  updateUiWithSize(result);\n}\n\n\n@Override\npublic AppStorageStats loadInBackground() {\n  AppStorageStats result = null;\n  try {\n    result = mSource.getStatsForPackage(mInfo.volumeUuid, mInfo.packageName, mUser);\n  } catch (NameNotFoundException | IOException e) {\n    Log.w(TAG, \"Package may have been removed during query, failing gracefully\", e);\n  }\n  return result;\n}\n\nmInfo = packageManager.getApplicationInfo(mPackageName, 0);\n\n// 访问 StorageStatsService的   queryStatsForPackage\npublic StorageStats queryStatsForPackage(String volumeUuid, String packageName, int userId,\n                                         String callingPackage) {\n  ...\n\n  final ApplicationInfo appInfo;\n  try {\n    appInfo = mPackage.getApplicationInfoAsUser(packageName,\n                                                PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n  }\n\n  // 以SharedUserSetting 区分, 查找shareUser, 且ps.getInstalled(userId) = true的, \n  if (defeatNullable(mPackage.getPackagesForUid(appInfo.uid)).length == 1) {\n    // 只有一个时, 直接调用 queryStatsForUid函数\n    // Only one package inside UID means we can fast-path\n    return queryStatsForUid(volumeUuid, appInfo.uid, callingPackage);\n  } else {\n    // Multiple packages means we need to go manual\n    final int appId = UserHandle.getUserId(appInfo.uid);\n    final String[] packageNames = new String[] { packageName };\n    final long[] ceDataInodes = new long[1];\n    String[] codePaths = new String[0];\n\n    if (appInfo.isSystemApp() && !appInfo.isUpdatedSystemApp()) {\n      // We don't count code baked into system image\n      // 不计算system下的app size\n    } else {\n      codePaths = ArrayUtils.appendElement(String.class, codePaths,                    appInfo.getCodePath());\n    }\n\n    final PackageStats stats = new PackageStats(TAG);\n    try {\n      mInstaller.getAppSize(volumeUuid, packageNames, userId, 0,\n                            appId, ceDataInodes, codePaths, stats);\n    }\n    return translate(stats);\n  }\n}\n\nprivate static StorageStats translate(PackageStats stats) {\n  final StorageStats res = new StorageStats();\n  // 最终是计算的这三个部分.\n  res.codeBytes = stats.codeSize + stats.externalCodeSize;\n  res.dataBytes = stats.dataSize + stats.externalDataSize;\n  res.cacheBytes = stats.cacheSize + stats.externalCacheSize;\n  return res;\n}\n\n```\n\n```java\n@Override\npublic StorageStats queryStatsForUid(String volumeUuid, int uid, String callingPackage) {\n    final int userId = UserHandle.getUserId(uid);\n    final int appId = UserHandle.getAppId(uid);\n\n    if (userId != UserHandle.getCallingUserId()) {\n        mContext.enforceCallingOrSelfPermission(\n                android.Manifest.permission.INTERACT_ACROSS_USERS, TAG);\n    }\n\n    if (Binder.getCallingUid() == uid) {\n        // No permissions required when asking about themselves\n    } else {\n        enforcePermission(Binder.getCallingUid(), callingPackage);\n    }\n\n    final String[] packageNames = defeatNullable(mPackage.getPackagesForUid(uid));\n    final long[] ceDataInodes = new long[packageNames.length];\n    String[] codePaths = new String[0];\n\n  //上面做过检验, defeatNullable(mPackage.getPackagesForUid(appInfo.uid)).length == 1),   即\n  //  packageNames.length = 1;\n    for (int i = 0; i < packageNames.length; i++) {\n        try {\n            final ApplicationInfo appInfo = mPackage.getApplicationInfoAsUser(packageNames[i],\n                    PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n            if (appInfo.isSystemApp() && !appInfo.isUpdatedSystemApp()) {\n                // We don't count code baked into system image\n            } else {\n                codePaths = ArrayUtils.appendElement(String.class, codePaths,\n                        appInfo.getCodePath());\n            }\n        } catch (NameNotFoundException e) {\n            throw new ParcelableException(e);\n        }\n    }\n\n    final PackageStats stats = new PackageStats(TAG);\n    try {\n        mInstaller.getAppSize(volumeUuid, packageNames, userId, getDefaultFlags(),\n                appId, ceDataInodes, codePaths, stats);\n    } catch (InstallerException e) {\n        throw new ParcelableException(new IOException(e.getMessage()));\n    }\n    return translate(stats);\n}\n```\n\n最终执行的代码为\n\n```java\ncodePaths = appInfo.getCodePath());\nmInstaller.getAppSize(volumeUuid, packageNames, userId, getDefaultFlags(),\n            appId, ceDataInodes, codePaths, stats);\n\npublic void getAppSize(String uuid, String[] packageNames, int userId, int flags, int appId,\n                       long[] ceDataInodes, String[] codePaths, PackageStats stats)\n  throws InstallerException {\n  if (!checkBeforeRemote()) return;\n  try {\n    final long[] res = mInstalld.getAppSize(uuid, packageNames, userId, flags,\n                                            appId, ceDataInodes, codePaths);\n    stats.codeSize += res[0];\n    stats.dataSize += res[1];\n    stats.cacheSize += res[2];\n    ...\n    stats.externalCodeSize += res[3];\n    stats.externalDataSize += res[4];\n    stats.externalCacheSize += res[5];\n  } catch (Exception e) {\n    throw InstallerException.from(e);\n  }\n}\n```\n执行进入installd中, 关注 getAppSize的实现.\n\n```cpp\n    struct stats stats;\n    // 是否开启quota\n    auto device = findQuotaDeviceForUuid(uuid);\n    if (device.empty()) {\n        flags &= ~FLAG_USE_QUOTA;\n    }\n\n    ATRACE_BEGIN(\"obb\");\n    for (auto packageName : packageNames) {\n        // data/media/obb/packageName/ 下的文件大小,计入 extStats.codeSize 中\n        auto obbCodePath = create_data_media_obb_path(uuid_, packageName.c_str());\n        calculate_tree_size(obbCodePath, &extStats.codeSize);\n    }\n    ATRACE_END();\n\n    if (flags & FLAG_USE_QUOTA && appId >= AID_APP_START) {\n        ATRACE_BEGIN(\"code\");\n        for (auto codePath : codePaths) {\n            // 统计codePath 的大小, 计入codeSize排除gid为 appid - 10000 + 50000的share gid的文件统计\n            calculate_tree_size(codePath, &stats.codeSize, -1,\n                    multiuser_get_shared_gid(0, appId));\n        }\n        ATRACE_END();\n\n        ATRACE_BEGIN(\"quota\");\n       // current usage for user or group id\n       // 查询quota中记录的  user/cachegid/sharedgid 的使用量.\n        collectQuotaStats(device, userId, appId, &stats, &extStats);\n        ATRACE_END();\n    } else {\n        // 没有开启quota的情况:\n        ATRACE_BEGIN(\"code\");\n        // 统计codePaths的大小\n        for (auto codePath : codePaths) {\n            calculate_tree_size(codePath, &stats.codeSize);\n        }\n        ATRACE_END();\n\n        for (size_t i = 0; i < packageNames.size(); i++) {\n            const char* pkgname = packageNames[i].c_str();\n\n            ATRACE_BEGIN(\"data\");\n            // data/user_ce/user_id/packageName\n            auto cePath = create_data_user_ce_package_path(uuid_, userId, pkgname, ceDataInodes[i]);\n            collectManualStats(cePath, &stats);\n            // data/user_de/user_id/packageName\n            auto dePath = create_data_user_de_package_path(uuid_, userId, pkgname);\n            // 统计上面两个目录的大小, cache code_cache下的放到 cache_size中,其他的放到data_size中.\n            // 如果lib 是链接, 忽略, 不是链接, 计入 code_size中\n            collectManualStats(dePath, &stats);\n            ATRACE_END();\n\n            if (!uuid) {\n                ATRACE_BEGIN(\"profiles\");\n                // /data/misc/profiles/cur/user_id/packageName\n                calculate_tree_size(\n                        create_primary_current_profile_package_dir_path(userId, pkgname),\n                        &stats.dataSize);\n                //  /data/misc/profiles/ref/packageName\n                calculate_tree_size(\n                        create_primary_reference_profile_package_dir_path(pkgname),\n                        &stats.codeSize);\n                ATRACE_END();\n            }         \n            ATRACE_BEGIN(\"external\");\n            // /data/media/<user_id>/Android/data/PackageName 下的大小, 计入extStats.dataSize中, cache|code_cache下放到extStats.cacheSize\n            auto extPath = create_data_media_package_path(uuid_, userId, \"data\", pkgname);\n            collectManualStats(extPath, &extStats);\n            // /data/media/<user_id>/Android/media/PackageName 下的 计入extStats.dataSize中.\n            auto mediaPath = create_data_media_package_path(uuid_, userId, \"media\", pkgname);\n            calculate_tree_size(mediaPath, &extStats.dataSize);\n            ATRACE_END();\n        }\n\n        if (!uuid) {\n            ATRACE_BEGIN(\"dalvik\");\n            // appId - 10000  + 50000\n            int32_t sharedGid = multiuser_get_shared_gid(0, appId);\n            if (sharedGid != -1) {\n                //  /data/dalvik-cache/  且文件所属用户组 为 appId - 10000  + 50000的,\n                calculate_tree_size(create_data_dalvik_cache_path(), &stats.codeSize,\n                        sharedGid, -1);\n            }\n            ATRACE_END();\n        }\n    }\n\n    std::vector<int64_t> ret;\n    ret.push_back(stats.codeSize);\n    ret.push_back(stats.dataSize);\n    ret.push_back(stats.cacheSize);\n    ret.push_back(extStats.codeSize);\n    ret.push_back(extStats.dataSize);\n    ret.push_back(extStats.cacheSize);\n\n```\n\n```cpp\n// current usage for user or group id\n// 查询quota中记录的  user/cachegid/sharedgid 的使用量. 放入 data_size cache_size data_size\nstatic void collectQuotaStats(const std::string& device, int32_t userId,\n        int32_t appId, struct stats* stats, struct stats* extStats) {\n    if (device.empty()) return;\n\n    struct dqblk dq;\n\n    if (stats != nullptr) {\n        // userid * 100000 + appid % 100000\n        uid_t uid = multiuser_get_uid(userId, appId);\n        if (quotactl(QCMD(Q_GETQUOTA, USRQUOTA), device.c_str(), uid,\n                reinterpret_cast<char*>(&dq)) != 0) {\n        } else {\n            stats->dataSize += dq.dqb_curspace;\n        }\n        // userid * 100000 + appid - 10000 + 20000\n        // cacheGid 实际指向的目录 还是CE|DE 区的  cache code_cache目录 \n        int cacheGid = multiuser_get_cache_gid(userId, appId);\n        if (cacheGid != -1) {\n            if (quotactl(QCMD(Q_GETQUOTA, GRPQUOTA), device.c_str(), cacheGid,\n                    reinterpret_cast<char*>(&dq)) != 0) {\n            } else {\n                stats->cacheSize += dq.dqb_curspace;\n            }\n        }\n\t\t//  userid * 100000 + appid - 10000 + 50000\n        // sharegid指向 /data/misc/profiles/<packageName>\n        int sharedGid = multiuser_get_shared_gid(0, appId);\n        if (sharedGid != -1) {\n            if (quotactl(QCMD(Q_GETQUOTA, GRPQUOTA), device.c_str(), sharedGid,\n                    reinterpret_cast<char*>(&dq)) != 0) {\n            } else {\n                stats->codeSize += dq.dqb_curspace;\n            }\n        }\n    }\n      if (extStats != nullptr) {\n        // 指向 /storage/emulated/<userid>/Android/obb|data|media/<packageName>, 计入 extStats->dataSize中, 除去cache目录\n        int extGid = multiuser_get_ext_gid(userId, appId);\n        if (extGid != -1) {\n            if (quotactl(QCMD(Q_GETQUOTA, GRPQUOTA), device.c_str(), extGid,\n                    reinterpret_cast<char*>(&dq)) != 0) {\n                if (errno != ESRCH) {\n                    PLOG(ERROR) << \"Failed to quotactl \" << device << \" for GID \" << extGid;\n                }\n            } else {\n#if MEASURE_DEBUG\n                LOG(DEBUG) << \"quotactl() for GID \" << extGid << \" \" << dq.dqb_curspace;\n#endif\n                extStats->dataSize += dq.dqb_curspace;\n            }\n        }\n        \n        // 指向 /storage/emulated/<userid>/Android/obb|data|media/<packageName>/cache目录, 计入 extStats->dataSize 和 cacheSize? 这个地方是不是重复了?\n        int extCacheGid = multiuser_get_ext_cache_gid(userId, appId);\n        if (extCacheGid != -1) {\n            if (quotactl(QCMD(Q_GETQUOTA, GRPQUOTA), device.c_str(), extCacheGid,\n                    reinterpret_cast<char*>(&dq)) != 0) {\n                if (errno != ESRCH) {\n                    PLOG(ERROR) << \"Failed to quotactl \" << device << \" for GID \" << extCacheGid;\n                }\n            } else {\n#if MEASURE_DEBUG\n                LOG(DEBUG) << \"quotactl() for GID \" << extCacheGid << \" \" << dq.dqb_curspace;\n#endif\n                extStats->dataSize += dq.dqb_curspace;\n                extStats->cacheSize += dq.dqb_curspace;\n            }\n        }\n    }\n}\n```\n\n### 1.2.1. 没有开启quota的情况下\n\n-   统计codePaths的大小, 放入`codeSize`中. 预制在system分区的应用codeSize不统计大小\n\n-   统计ce区 De区的应用的所占空间大小, 目录为data/user_ce|user_de/user_id/packageName, \n\n    cache目录和code_cache放到 `cacheSize`中, 其他的放到`dataSize`中.如果lib 是链接, 忽略, 不是链接, 计入`dataSize`中\n\n-   /data/misc/profiles/cur/user_id/packageName计入`dataSize`中, /data/misc/profiles/ref/packageName计入`codeSize`中.\n\n-   /data/dalvik-cache/下且文件所属用户组 为 appId - 10000  + 50000的, 计入`codeSize`中. appid>=0且appid<10000的, 统计所属用户组为appid为文件.\n\n-   /data/media/obb/packageName/ 下的文件大小,计入 extStats.codeSize 中\n\n-   /data/media/user_id/Android/data/PackageName 下的大小, 计入extStats.dataSize中, cache|code_cache下放到extStats.cacheSize\n\n-   /data/media/user_id/Android/media/PackageName 下的 计入extStats.dataSize中.\n\n### 1.2.2. 开启quota的情况\n\n-   data/media/obb/packageName/ 下的文件大小,计入 extStats.codeSize 中\n-   统计codePath 的大小, 计入codeSize, 排除gid为 appid - 10000 + 50000的share gid的文件统计,appid>=0且appid<10000的, 统计所属用户组为appid为文件.\n-   查询quota中记录的  uid/cachegid/sharedgid 的使用量.\n\n\n# 2. Android7.0\n\n## 2.1. 涉及的文件\n\n-   ApplicationState.java\n-   AppStorageSettings.java\n-   PackageManagerService.java\n\n## 2.2. 相关代码\n\nAppStorageSettings activity界面负责应用存储信息的展示.\n\nonResume时会对该app的各大小进行统计\n\n```cpp\npublic void onResume() {\n  super.onResume();\n  mState.requestSize(mPackageName, mUserId);\n}\npublic void requestSize(String packageName, int userId) {\n  synchronized (mEntriesMap) {\n    AppEntry entry = mEntriesMap.get(userId).get(packageName);\n    if (entry != null) {\n      // 调用getPackageSizeInfoAsUser函数进行查询, 查询的结果放在mStatsObserver中进行处理\n      mPm.getPackageSizeInfoAsUser(packageName, userId, mBackgroundHandler.mStatsObserver);\n    }\n  }\n}\n\nfinal IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {\n  public void onGetStatsCompleted(PackageStats stats, boolean succeeded) {\n    boolean sizeChanged = false;\n    synchronized (mEntriesMap) {\n      if (DEBUG_LOCKING) Log.v(TAG, \"onGetStatsCompleted acquired lock\");\n      HashMap<String, AppEntry> userMap = mEntriesMap.get(stats.userHandle);\n      AppEntry entry = userMap.get(stats.packageName);\n      if (entry != null) {\n        synchronized (entry) {\n          entry.sizeStale = false;\n          entry.sizeLoadStart = 0;\n          long externalCodeSize = stats.externalCodeSize\n            + stats.externalObbSize;\n          long externalDataSize = stats.externalDataSize\n            + stats.externalMediaSize;\n          // newSize的计算  \n          // newSize = stats.(externalCodeSize + externalObbSize + externalDataSize\n          //  + externalMediaSize + codeSize + dataSize)\n          long newSize = externalCodeSize + externalDataSize\n            + getTotalInternalSize(stats);\n          if (entry.size != newSize ||\n              entry.cacheSize != stats.cacheSize ||\n              entry.codeSize != stats.codeSize ||\n              entry.dataSize != stats.dataSize ||\n              entry.externalCodeSize != externalCodeSize ||\n              entry.externalDataSize != externalDataSize ||\n              entry.externalCacheSize != stats.externalCacheSize) {\n            // entry对应的 AppEntry\n            entry.size = newSize;\n            entry.cacheSize = stats.cacheSize;\n            entry.codeSize = stats.codeSize;\n            entry.dataSize = stats.dataSize;\n            entry.externalCodeSize = externalCodeSize;\n            entry.externalDataSize = externalDataSize;\n            entry.externalCacheSize = stats.externalCacheSize;\n            entry.sizeStr = getSizeStr(entry.size);\n            entry.internalSize = getTotalInternalSize(stats);\n            entry.internalSizeStr = getSizeStr(entry.internalSize);\n            entry.externalSize = getTotalExternalSize(stats);\n            entry.externalSizeStr = getSizeStr(entry.externalSize);\n            if (DEBUG) Log.i(TAG, \"Set size of \" + entry.label + \" \" + entry\n                             + \": \" + entry.sizeStr);\n            sizeChanged = true;\n          }\n        }\n        ...\n    }\n  }\n};\n  \n\n    private void refreshSizeInfo() {\n        if (mAppEntry.size == ApplicationsState.SIZE_INVALID\n                || mAppEntry.size == ApplicationsState.SIZE_UNKNOWN) {\n            ...\n        } else {\n            mHaveSizes = true;\n            long codeSize = mAppEntry.codeSize;\n            long dataSize = mAppEntry.dataSize;\n            // 主存储是否是Emulated的, 内卡主卡方案满足条件的\n            if (Environment.isExternalStorageEmulated()) {\n                codeSize += mAppEntry.externalCodeSize;\n                dataSize +=  mAppEntry.externalDataSize;\n            } else {\n                if (mLastExternalCodeSize != mAppEntry.externalCodeSize) {\n                    mLastExternalCodeSize = mAppEntry.externalCodeSize;\n                    mExternalCodeSize.setSummary(getSizeStr(mAppEntry.externalCodeSize));\n                }\n                if (mLastExternalDataSize !=  mAppEntry.externalDataSize) {\n                    mLastExternalDataSize =  mAppEntry.externalDataSize;\n                    mExternalDataSize.setSummary(getSizeStr( mAppEntry.externalDataSize));\n                }\n            }\n            if (mLastCodeSize != codeSize) {\n                mLastCodeSize = codeSize;\n                mAppSize.setSummary(getSizeStr(codeSize));\n            }\n            if (mLastDataSize != dataSize) {\n                mLastDataSize = dataSize;\n                mDataSize.setSummary(getSizeStr(dataSize));\n            }\n            long cacheSize = mAppEntry.cacheSize + mAppEntry.externalCacheSize;\n            if (mLastCacheSize != cacheSize) {\n                mLastCacheSize = cacheSize;\n                mCacheSize.setSummary(getSizeStr(cacheSize));\n            }\n            if (mLastTotalSize != mAppEntry.size) {\n                mLastTotalSize = mAppEntry.size;\n                // 将TotalSize 设为了 mAppEntry.size. \n                mTotalSize.setSummary(getSizeStr(mAppEntry.size));\n            }\n\n            if ((mAppEntry.dataSize+ mAppEntry.externalDataSize) <= 0 || !mCanClearData) {\n                mClearDataButton.setEnabled(false);\n            } else {\n                mClearDataButton.setEnabled(true);\n                mClearDataButton.setOnClickListener(this);\n            }\n            if (cacheSize <= 0) {\n                mClearCacheButton.setEnabled(false);\n            } else {\n                mClearCacheButton.setEnabled(true);\n                mClearCacheButton.setOnClickListener(this);\n            }\n        }\n        if (mAppsControlDisallowedBySystem) {\n            mClearCacheButton.setEnabled(false);\n            mClearDataButton.setEnabled(false);\n        }\n    }\n```\n\n7.0 上的 totalSize的计算方式:\n\nstats.(externalCodeSize + externalObbSize + externalDataSize + externalMediaSize + codeSize + dataSize)\n\n回到之前的核心方法:\n\n-   getPackageSizeInfoAsUser(packageName, userId, mBackgroundHandler.mStatsObserver)\n\n```java\n    @Override\n    public void getPackageSizeInfo(final String packageName, int userHandle,\n            final IPackageStatsObserver observer) {\n        mContext.enforceCallingOrSelfPermission(\n                android.Manifest.permission.GET_PACKAGE_SIZE, null);\n\n        PackageStats stats = new PackageStats(packageName, userHandle);\n        Message msg = mHandler.obtainMessage(INIT_COPY);\n        msg.obj = new MeasureParams(stats, observer);\n        mHandler.sendMessage(msg);\n    }\n \ncase INIT_COPY:\n     mPendingInstalls.add(idx, params);\n//最终执行MeasureParams的 handleStartCopy方法:\n\n        void handleStartCopy() throws RemoteException {\n            synchronized (mInstallLock) {\n                mSuccess = getPackageSizeInfoLI(mStats.packageName, mStats.userHandle, mStats);\n            }\n\n            if (mSuccess) {\n                boolean mounted = false;\n                try {\n                /* SPRD: support double sdcard\n                 * chanage interface, getExternalStorageState->getExternalStoragePathState\n                 */\n                final String status = EnvironmentEx.getExternalStoragePathState();\n                    mounted = (Environment.MEDIA_MOUNTED.equals(status)\n                            || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));\n                }\n                // 如果外部存储是挂载状态, 还要接着计算  externalCacheSize  externalDataSize       externalMediaSize  externalObbSize, 在计算方式中, 除externalCacheSize外都用到了\n                if (mounted) {\n                    final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);\n                    // 统计所有可写存储的 Android/data/packageName/cache\n                    mStats.externalCacheSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));\n\t\t\t\t   // 统计所有可写存储的 Android/data/packageName/\n                    mStats.externalDataSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppDataDirs(mStats.packageName));\n\n                    // Always subtract cache size, since it's a subdirectory\n                    mStats.externalDataSize -= mStats.externalCacheSize;\n\t\t\t\t   // 统计所有可写存储的 Android/media/packageName/\n                    mStats.externalMediaSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));\n                    // 统计所有可写存储的 Android/obb/packageName/\n                    mStats.externalObbSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppObbDirs(mStats.packageName));\n                }\n            }\n        }\n\n\n\n    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {\n        final PackageSetting ps;\n        synchronized (mPackages) {\n            ps = mSettings.mPackages.get(packageName);\n            if (ps == null) {\n                Slog.w(TAG, \"Failed to find settings for \" + packageName);\n                return false;\n            }\n        }\n        try {\n            mInstaller.getAppSize(ps.volumeUuid, packageName, userId,\n                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE,\n                    ps.getCeDataInode(userId), ps.codePathString, stats);\n        } \n        // For now, ignore code size of packages on system partition\n        // system下的app 忽略 codeSize\n        if (isSystemApp(ps) && !isUpdatedSystemApp(ps)) {\n            stats.codeSize = 0;\n        }\n\n        return true;\n    }\n```\n\n最终落到Installd统计app的internal 的 codeSize和 dataSize\n\n```cpp\nint get_app_size(const char *uuid, const char *pkgname, int userid, int flags, ino_t ce_data_inode,\n        const char *code_path, int64_t *codesize, int64_t *datasize, int64_t *cachesize,\n        int64_t* asecsize) {\n    DIR *d;\n    int dfd;\n\n    d = opendir(code_path);\n    if (d != nullptr) {\n        dfd = dirfd(d);\n        // 计算codeSize  即package的 codePaths 目录大小\n        *codesize += calculate_dir_size(dfd);\n        closedir(d);\n    }\n\n    if (flags & FLAG_STORAGE_CE) {\n        // 统计CE区的 /data/user_ce/user_id/packageName/下的\n        auto path = create_data_user_ce_package_path(uuid, userid, pkgname, ce_data_inode);\n        add_app_data_size(path, codesize, datasize, cachesize);\n    }\n    if (flags & FLAG_STORAGE_DE) {\n        // 统计CE区的 /data/user_ce/user_id/packageName/下的\n        auto path = create_data_user_de_package_path(uuid, userid, pkgname);\n        add_app_data_size(path, codesize, datasize, cachesize);\n    }\n\n    *asecsize = 0;\n\n    return 0;\n}\n\nstatic void add_app_data_size(std::string& path, int64_t *codesize, int64_t *datasize,\n        int64_t *cachesize) {\n    DIR *d;\n    int dfd;\n    struct dirent *de;\n    struct stat s;\n\n    d = opendir(path.c_str());\n    if (d == nullptr) {\n        PLOG(WARNING) << \"Failed to open \" << path;\n        return;\n    }\n    dfd = dirfd(d);\n    while ((de = readdir(d))) {\n        const char *name = de->d_name;\n\n        int64_t statsize = 0;\n        if (fstatat(dfd, name, &s, AT_SYMLINK_NOFOLLOW) == 0) {\n            statsize = stat_size(&s);\n        }\n\n        if (de->d_type == DT_DIR) {\n            int subfd;\n            int64_t dirsize = 0;\n            /* always skip \".\" and \"..\" */\n            if (name[0] == '.') {\n                if (name[1] == 0) continue;\n                if ((name[1] == '.') && (name[2] == 0)) continue;\n            }\n            subfd = openat(dfd, name, O_RDONLY | O_DIRECTORY);\n            if (subfd >= 0) {\n                dirsize = calculate_dir_size(subfd);\n                close(subfd);\n            }\n            // TODO: check xattrs!\n            // dataSize中不包含  cache  code_cache下 子文件的大小.\n            if (!strcmp(name, \"cache\") || !strcmp(name, \"code_cache\")) {\n                *datasize += statsize;\n                *cachesize += dirsize;\n            } else {\n                *datasize += dirsize + statsize;\n            }\n        } else if (de->d_type == DT_LNK && !strcmp(name, \"lib\")) {\n         // 如果是lib目录,且为链接的方式, 该目录的大小统计进了 codeSize中,但仅链接的话,statsize很小,可以忽略.\n            *codesize += statsize;\n        } else {\n            // 普通文件, 统计进dataSize中.\n            *datasize += statsize;\n        }\n    }\n    closedir(d);\n}\n```\n\n综上, Android7.0的统计app总使用量的大小为:\n\nstats.(externalCodeSize + externalObbSize + externalDataSize + externalMediaSize + codeSize + dataSize)\n\n-   计算codeSize  即package的 codePaths 目录大小\n-   统计CE区的 /data/user_ce/user_id/packageName/下的,  除cache/code_cache目录外的大小. 计入dataSize (codeSize可以忽略)\n-   统计DE区的 /data/user_de/user_id/packageName/下的,  除cache/code_cache目录外的大小. 计入dataSize\n-   统计所有可写存储的 Android/data/packageName/大小, 除cache子目录外, 计入 externalDataSize\n-   统计所有可写存储的 Android/media/packageName/,计入externalMediaSize\n-   统计所有可写存储的 Android/obb/packageName/,计入externalObbSize\n\nexternalCodeSize没看到有计算的地方\n\n# 3. Android6.0\n\n## 3.1. 涉及的文件\n\n-   AppStorageSettings.java\n-   ApplicationState.java\n-   PackageManagerService.java\n\n## 3.2. 相关代码\n\n计算方式和7.0相同:\n\nstats.(externalCodeSize + externalObbSize + externalDataSize + externalMediaSize + codeSize + dataSize)\n\n```java\n// 前面的流程与7.0大致相同.   \npublic void requestSize(String packageName, int userId) {\n        if (DEBUG_LOCKING) Log.v(TAG, \"requestSize about to acquire lock...\");\n        synchronized (mEntriesMap) {\n            AppEntry entry = mEntriesMap.get(userId).get(packageName);\n            if (entry != null) {\n                mPm.getPackageSizeInfo(packageName, userId, mBackgroundHandler.mStatsObserver);\n            }\n            if (DEBUG_LOCKING) Log.v(TAG, \"...requestSize releasing lock\");\n        }\n}\n\nfinal IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {\n  ...\n    long newSize = externalCodeSize + externalDataSize + getTotalInternalSize(stats);\n}\n\n@Override\npublic void getPackageSizeInfo(final String packageName, int userHandle,\n                               final IPackageStatsObserver observer) {\n  mContext.enforceCallingOrSelfPermission(\n    android.Manifest.permission.GET_PACKAGE_SIZE, null);\n  PackageStats stats = new PackageStats(packageName, userHandle);\n  Message msg = mHandler.obtainMessage(INIT_COPY);\n  msg.obj = new MeasureParams(stats, observer);\n  mHandler.sendMessage(msg);\n}\n\nfinal String status = Environment.getExternalStoragePathState();\nmounted = (Environment.MEDIA_MOUNTED.equals(status)\n           || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));\n}\n\nif (mounted) {\n  final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);\n\n  mStats.externalCacheSize = calculateDirectorySize(mContainerService,\n                                                    userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));\n\n  mStats.externalDataSize = calculateDirectorySize(mContainerService,\n                                                   userEnv.buildExternalStorageAppDataDirs(mStats.packageName));\n\n  // Always subtract cache size, since it's a subdirectory\n  mStats.externalDataSize -= mStats.externalCacheSize;\n\n  mStats.externalMediaSize = calculateDirectorySize(mContainerService,\n                                                    userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));\n\n  mStats.externalObbSize = calculateDirectorySize(mContainerService,\n                                                  userEnv.buildExternalStorageAppObbDirs(mStats.packageName));\n}\n\n// 上述流程都与7.0的一致, 但getPackageSizeInfoLI 函数和 7.0的不同\n\n    private boolean getPackageSizeInfoLI(String packageName, int userHandle,\n            PackageStats pStats) {\n        if (packageName == null) {\n            Slog.w(TAG, \"Attempt to get size of null packageName.\");\n            return false;\n        }\n        PackageParser.Package p;\n        boolean dataOnly = false;\n        String libDirRoot = null;\n        String asecPath = null;\n        PackageSetting ps = null;\n        synchronized (mPackages) {\n            p = mPackages.get(packageName);\n            ps = mSettings.mPackages.get(packageName);\n            if(p == null) {\n                dataOnly = true;\n                p = ps.pkg;\n            }\n            if (ps != null) {\n                // native lib库的路径\n                libDirRoot = ps.legacyNativeLibraryPathString;\n            }\n            /* SPRD: support double sdcard\n             * Add support for install apk to internal sdcard @{\n             * @orig\n             * if (p != null && (isExternal(p) || p.isForwardLocked())) {\n             */\n            if (p != null && (isExternal(p) || p.isForwardLocked() || isInternalSd(p))) {\n              /* @} */\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    String secureContainerId = cidFromCodePath(p.applicationInfo.getBaseCodePath());\n                    if (secureContainerId != null) {\n                        // 如应用安装在外部存储上, 记录asecPath\n                        // /mnt/secure/asec/<id.asec> 目录\n                        asecPath = PackageHelper.getSdFilesystem(secureContainerId);\n                    }\n                }\n            }\n        }\n        String publicSrcDir = null;\n        if(!dataOnly) {\n            final ApplicationInfo applicationInfo = p.applicationInfo;\n            // isForwardLocked为true时, code和resource分离, 需要拿到resource的路径\n            if (p.isForwardLocked()) {\n                publicSrcDir = applicationInfo.getBaseResourcePath();\n            }\n        }\n        // TODO: extend to measure size of split APKs\n        String[] dexCodeInstructionSets = getDexCodeInstructionSets(getAppDexInstructionSets(ps));\n        // 传入的路径  baseCodePath  libDirRoot publicSrcDir asecPath dexCodeInstructionSets\n        int res = mInstaller.getSizeInfo(p.volumeUuid, packageName, userHandle, p.baseCodePath,\n                libDirRoot, publicSrcDir, asecPath, dexCodeInstructionSets, pStats);\n        if (res < 0) {\n            return false;\n        }\n        if (!isExternal(p) && !isInternalSd(p)) {\n        /* @} */\n            // 安装在内部存储上的应用, 将externalCodeSize 计入codeSize中.\n            pStats.codeSize += pStats.externalCodeSize;\n            pStats.externalCodeSize = 0L;\n        }\n\n        return true;\n    }\n\ntry {\n  pStats.codeSize = Long.parseLong(res[1]);\n  pStats.dataSize = Long.parseLong(res[2]);\n  pStats.cacheSize = Long.parseLong(res[3]);\n  // externalCodeSize 指的asecsize\n  pStats.externalCodeSize = Long.parseLong(res[4]);\n  return Integer.parseInt(res[0]);\n} \n```\n\nnative层的代码, 在installd中\n\n```cpp\nint get_size(const char *uuid, const char *pkgname, int userid, const char *apkpath,\n             const char *libdirpath, const char *fwdlock_apkpath, const char *asecpath,\n             const char *instruction_set, int64_t *_codesize, int64_t *_datasize,\n             int64_t *_cachesize, int64_t* _asecsize)\n{\n    DIR *d;\n    int dfd;\n    struct dirent *de;\n    struct stat s;\n    char path[PKG_PATH_MAX];\n\n    int64_t codesize = 0;\n    int64_t datasize = 0;\n    int64_t cachesize = 0;\n    int64_t asecsize = 0;\n\n    /* count the source apk as code -- but only if it's not\n     * on the /system partition and its not on the sdcard. */\n    if (validate_system_app_path(apkpath) &&\n            strncmp(apkpath, android_asec_dir.path, android_asec_dir.len) != 0) {\n        // apk 没有在外部存储上, 统计codepath的  codesize, 不统计system分区的.\n        if (stat(apkpath, &s) == 0) {\n            codesize += stat_size(&s);\n            if (S_ISDIR(s.st_mode)) {\n                d = opendir(apkpath);\n                if (d != NULL) {\n                    dfd = dirfd(d);\n                    codesize += calculate_dir_size(dfd);\n                    closedir(d);\n                }\n            }\n        }\n    }\n\n    /* count the forward locked apk as code if it is given */\n    // foward_lock时, codepath 和 respath分开,统计respath大小计入codesize\n    if (fwdlock_apkpath != NULL && fwdlock_apkpath[0] != '!') {\n        if (stat(fwdlock_apkpath, &s) == 0) {\n            codesize += stat_size(&s);\n        }\n    }\n\n    /* count the cached dexfile as code */\n    // 统计  /data/dalvik-cache/<instruction_set>/[<codepath>/classes.dex](\"[]里的'/'被转换为'@'\")\n    // 计入codesize中.\n    if (!create_cache_path(path, apkpath, instruction_set)) {\n        if (stat(path, &s) == 0) {\n            codesize += stat_size(&s);\n        }\n    }\n\n    /* add in size of any libraries */\n    // 将package关联的native lib库的路径下大小计入codesize\n    if (libdirpath != NULL && libdirpath[0] != '!') {\n        d = opendir(libdirpath);\n        if (d != NULL) {\n            dfd = dirfd(d);\n            codesize += calculate_dir_size(dfd);\n            closedir(d);\n        }\n    }\n\n    /* compute asec size if it is given */\n    // 如果apk安装在外部存储上, 统计asecsize\n    if (asecpath != NULL && asecpath[0] != '!') {\n        if (stat(asecpath, &s) == 0) {\n            asecsize += stat_size(&s);\n        }\n    }\n\n    std::vector<userid_t> users;\n    if (userid == -1) {\n        users = get_known_users(uuid);\n    } else {\n        users.push_back(userid);\n    }\n    // 统计/data/user/<userid>/<packageName>下的文件大小, 计入codesize/cachesize/datasize\n    for (auto user : users) {\n        std::string _pkgdir(create_data_user_package_path(uuid, user, pkgname));\n        const char* pkgdir = _pkgdir.c_str();\n\n        d = opendir(pkgdir);\n        if (d == NULL) {\n            PLOG(WARNING) << \"Failed to open \" << pkgdir;\n            continue;\n        }\n        dfd = dirfd(d);\n\n        /* most stuff in the pkgdir is data, except for the \"cache\"\n         * directory and below, which is cache, and the \"lib\" directory\n         * and below, which is code...\n         */\n        while ((de = readdir(d))) {\n            const char *name = de->d_name;\n\n            if (de->d_type == DT_DIR) {\n                int subfd;\n                int64_t statsize = 0;\n                int64_t dirsize = 0;\n                    /* always skip \".\" and \"..\" */\n                if (name[0] == '.') {\n                    if (name[1] == 0) continue;\n                    if ((name[1] == '.') && (name[2] == 0)) continue;\n                }\n                if (fstatat(dfd, name, &s, AT_SYMLINK_NOFOLLOW) == 0) {\n                    statsize = stat_size(&s);\n                }\n                subfd = openat(dfd, name, O_RDONLY | O_DIRECTORY);\n                if (subfd >= 0) {\n                    dirsize = calculate_dir_size(subfd);\n                }\n                // 如为lib目录,统计目录大小, 计入codesize\n                if(!strcmp(name,\"lib\")) {\n                    codesize += dirsize + statsize;\n                // 如为cache目录,统计目录大小, 计入cachesize\n                } else if(!strcmp(name,\"cache\")) {\n                    cachesize += dirsize + statsize;\n                // 如为其他目录,统计目录大小, 计入datasize\n                } else {\n                    datasize += dirsize + statsize;\n                }\n                // lib目录且为链接, 这部分很小, 可以忽略不计\n            } else if (de->d_type == DT_LNK && !strcmp(name,\"lib\")) {\n                // This is the symbolic link to the application's library\n                // code.  We'll count this as code instead of data, since\n                // it is not something that the app creates.\n                if (fstatat(dfd, name, &s, AT_SYMLINK_NOFOLLOW) == 0) {\n                    codesize += stat_size(&s);\n                }\n            } else {\n                // 非目录, 普通文件, 计入datasize\n                if (fstatat(dfd, name, &s, AT_SYMLINK_NOFOLLOW) == 0) {\n                    datasize += stat_size(&s);\n                }\n            }\n        }\n        closedir(d);\n    }\n    *_codesize = codesize;\n    *_datasize = datasize;\n    *_cachesize = cachesize;\n    *_asecsize = asecsize;\n    return 0;\n}\n```\n\n综上, Android6.0 上统计app totalsize方式:\n\nstats.(externalCodeSize + externalObbSize + externalDataSize + externalMediaSize + codeSize + dataSize)\n\n-   apk 没有在外部存储上, 统计codepath的  codesize\n-   foward_lock时, codepath 和 respath分开,统计respath大小计入codesize\n-   统计  /data/dalvik-cache/<instruction_set>/{<codepath>/classes.dex}(\"{}里的'/'被转换为'@'\"),  计入codesize中.\n-   如果apk安装在外部存储上, 统计asecsize, 最后计为 externalCodeSize\n-   统计/data/user/<userid>/<packageName>下的文件大小, 计入codesize/cachesize/datasize\n    -   如为lib目录非链接,统计目录大小, 计入codesize\n    -   如为cache目录,统计目录大小, 计入cachesize\n    -   如为其他目录,统计目录大小, 计入datasize\n    -   lib目录且为链接, 这部分很小, 可以忽略不计, 但还是计入codesize\n    -   非目录, 普通文件, 计入datasize\n-   统计所有可写存储的 Android/data/packageName/大小, 除cache子目录外, 计入 externalDataSize\n-   统计所有可写存储的 Android/media/packageName/,计入externalMediaSize\n-   统计所有可写存储的 Android/obb/packageName/,计入externalObbSize\n\n# 4. Android5.1 \n\n## 4.1. 涉及的文件\n\n-   InstalledAppDetails.java\n-   PackageManagerService.java\n\n## 4.2. 相关代码\n\n计算方式:\n\nstats.(externalCodeSize + externalObbSize +  externalDataSize + externalMediaSize + codesize + datasize)\n\n```java\n    private void refreshSizeInfo() {\n        if (mAppEntry.size == ApplicationsState.SIZE_INVALID\n                || mAppEntry.size == ApplicationsState.SIZE_UNKNOWN) {\n         ...\n        } else {\n            mHaveSizes = true;\n            long codeSize = mAppEntry.codeSize;\n            long dataSize = mAppEntry.dataSize;\n            // 内卡作主卡, codeSize dataSize +  externalCodeSize   + externalDataSize\n            if (Environment.isExternalStorageEmulated()) {\n                codeSize += mAppEntry.externalCodeSize;\n                dataSize +=  mAppEntry.externalDataSize;\n            } else {\n                if (mLastExternalCodeSize != mAppEntry.externalCodeSize) {\n                    mLastExternalCodeSize = mAppEntry.externalCodeSize;\n                    mExternalCodeSize.setText(getSizeStr(mAppEntry.externalCodeSize));\n                }\n                if (mLastExternalDataSize !=  mAppEntry.externalDataSize) {\n                    mLastExternalDataSize =  mAppEntry.externalDataSize;\n                    mExternalDataSize.setText(getSizeStr( mAppEntry.externalDataSize));\n                }\n            }\n            if (mLastCodeSize != codeSize) {\n                mLastCodeSize = codeSize;\n                /* SPRD:438010 Monkey test NullPointerException@{*/\n                if (mAppSize != null) {\n                    mAppSize.setText(getSizeStr(codeSize));\n                }\n                /* @}*/\n            }\n            if (mLastDataSize != dataSize) {\n                mLastDataSize = dataSize;\n                mDataSize.setText(getSizeStr(dataSize));\n            }\n            long cacheSize = mAppEntry.cacheSize + mAppEntry.externalCacheSize;\n            /* SPRD:fix bug 393783 , \"let 12.00 KB does not dispaly @{*/\n            if (cacheSize > 0) {\n                cacheSize = cacheSize - 12 * 1024;\n            }\n            /* @} */\n            if (mLastCacheSize != cacheSize) {\n                mLastCacheSize = cacheSize;\n                mCacheSize.setText(getSizeStr(cacheSize));\n            }\n            if (mLastTotalSize != mAppEntry.size) {\n                mLastTotalSize = mAppEntry.size;\n                // mTotalSize 的大小.\n                mTotalSize.setText(getSizeStr(mAppEntry.size));\n            }\n        }\n    }\n// 上述逻辑与6.0 7.0相同.\n\nmCurComputingSizePkg = entry.info.packageName;\nmPm.getPackageSizeInfo(mCurComputingSizePkg, mStatsObserver);\n\n    void requestSize(String packageName) {\n        if (DEBUG_LOCKING) Log.v(TAG, \"requestSize about to acquire lock...\");\n        synchronized (mEntriesMap) {\n            AppEntry entry = mEntriesMap.get(packageName);\n            if (entry != null) {\n                mPm.getPackageSizeInfo(packageName, mBackgroundHandler.mStatsObserver);\n            }\n            if (DEBUG_LOCKING) Log.v(TAG, \"...requestSize releasing lock\");\n        }\n    }\n\n\n        final IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {\n            public void onGetStatsCompleted(PackageStats stats, boolean succeeded) {\n                synchronized (mEntriesMap) {                   \n                    AppEntry entry = mEntriesMap.get(stats.packageName);\n                    if (entry != null) {\n                        synchronized (entry) {\n                            entry.sizeStale = false;\n                            entry.sizeLoadStart = 0;\n                            long externalCodeSize = stats.externalCodeSize\n                                    + stats.externalObbSize;\n                            long externalDataSize = stats.externalDataSize\n                                    + stats.externalMediaSize;\n                            long newSize = externalCodeSize + externalDataSize\n                                    + getTotalInternalSize(stats);\n                            if (entry.size != newSize ||\n                                    entry.cacheSize != stats.cacheSize ||\n                                    entry.codeSize != stats.codeSize ||\n                                    entry.dataSize != stats.dataSize ||\n                                    entry.externalCodeSize != externalCodeSize ||\n                                    entry.externalDataSize != externalDataSize ||\n                                    entry.externalCacheSize != stats.externalCacheSize) {\n                                // stats.(externalCodeSize + externalObbSize +  externalDataSize + externalMediaSize + codesize + datasize)\n                                entry.size = newSize;\n                                entry.cacheSize = stats.cacheSize;\n                                entry.codeSize = stats.codeSize;\n                                entry.dataSize = stats.dataSize;\n                                entry.externalCodeSize = externalCodeSize;\n                                entry.externalDataSize = externalDataSize;\n                                entry.externalCacheSize = stats.externalCacheSize;\n                                entry.sizeStr = getSizeStr(entry.size);\n                                entry.internalSize = getTotalInternalSize(stats);\n                                entry.internalSizeStr = getSizeStr(entry.internalSize);\n                                entry.externalSize = getTotalExternalSize(stats);\n                                entry.externalSizeStr = getSizeStr(entry.externalSize);\n                                if (DEBUG) Log.i(TAG, \"Set size of \" + entry.label + \" \" + entry\n                                        + \": \" + entry.sizeStr);\n                                sizeChanged = true;\n                            }\n\n        };\n// 调用函数仍然为   getPackageSizeInfo.\n\n           // 下面的流程也与 6.0 7.0相同.           \n           void handleStartCopy() throws RemoteException {\n            synchronized (mInstallLock) {\n                mSuccess = getPackageSizeInfoLI(mStats.packageName, mStats.userHandle, mStats);\n            }\n\n            if (mSuccess) {\n                final boolean mounted;\n                if (Environment.isExternalStorageEmulated()) {\n                    mounted = true;\n                } else {\n                /* SPRD: support double sdcard\n                 * chanage interface, getExternalStorageState->getExternalStoragePathState\n                 */\n                final String status = Environment.getExternalStoragePathState();\n                    mounted = (Environment.MEDIA_MOUNTED.equals(status)\n                            || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));\n                }\n\n                if (mounted) {\n                    final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);\n\n                    mStats.externalCacheSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));\n\n                    mStats.externalDataSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppDataDirs(mStats.packageName));\n\n                    // Always subtract cache size, since it's a subdirectory\n                    mStats.externalDataSize -= mStats.externalCacheSize;\n\n                    mStats.externalMediaSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));\n\n                    mStats.externalObbSize = calculateDirectorySize(mContainerService,\n                            userEnv.buildExternalStorageAppObbDirs(mStats.packageName));\n                }\n            }\n             \n    // 展开 PackageManager的 getPackageSizeInfoLI 函数:\n            // 该函数与6.0的一致/\n      private boolean getPackageSizeInfoLI(String packageName, int userHandle,\n            PackageStats pStats) {\n        if (packageName == null) {\n            Slog.w(TAG, \"Attempt to get size of null packageName.\");\n            return false;\n        }\n        PackageParser.Package p;\n        boolean dataOnly = false;\n        String libDirRoot = null;\n        String asecPath = null;\n        PackageSetting ps = null;\n        synchronized (mPackages) {\n            p = mPackages.get(packageName);\n            ps = mSettings.mPackages.get(packageName);\n            if(p == null) {\n                dataOnly = true;\n                if((ps == null) || (ps.pkg == null)) {\n                    Slog.w(TAG, \"Package named '\" + packageName +\"' doesn't exist.\");\n                    return false;\n                }\n                p = ps.pkg;\n            }\n            if (ps != null) {\n                libDirRoot = ps.legacyNativeLibraryPathString;\n            }\n            /* SPRD: support double sdcard\n             * Add support for install apk to internal sdcard @{\n             * @orig\n             * if (p != null && (isExternal(p) || isForwardLocked(p))) {\n             */\n            if (p != null && (isExternal(p) || isForwardLocked(p) || isInternalSd(p))) {\n            /* @} */\n                String secureContainerId = cidFromCodePath(p.applicationInfo.getBaseCodePath());\n                if (secureContainerId != null) {\n                    asecPath = PackageHelper.getSdFilesystem(secureContainerId);\n                }\n            }\n        }\n        String publicSrcDir = null;\n        if(!dataOnly) {\n            final ApplicationInfo applicationInfo = p.applicationInfo;\n            if (applicationInfo == null) {\n                Slog.w(TAG, \"Package \" + packageName + \" has no applicationInfo.\");\n                return false;\n            }\n            if (isForwardLocked(p)) {\n                publicSrcDir = applicationInfo.getBaseResourcePath();\n            }\n        }\n        // TODO: extend to measure size of split APKs\n        String[] dexCodeInstructionSets = getDexCodeInstructionSets(getAppDexInstructionSets(ps));\n        int res = mInstaller.getSizeInfo(packageName, userHandle, p.baseCodePath, libDirRoot,\n                publicSrcDir, asecPath, dexCodeInstructionSets, pStats);\n        if (res < 0) {\n            return false;\n        }\n\n        // Fix-up for forward-locked applications in ASEC containers.\n        if (!isExternal(p) && !isInternalSd(p)) {\n        /* @} */\n            pStats.codeSize += pStats.externalCodeSize;\n            pStats.externalCodeSize = 0L;\n        }\n\n        return true;\n    }           \n  // 查看installd的get_size代码也与6.0的相同, 下面不再写了.\n```\n\n综上, Android5.1 上 total_size 的计算方式和 Android6.0的完全相同. 此处不再赘述.\n\n# 5. Android4.4\n\n## 5.1. 涉及的文件\n\n-   InstalledAppDetails.java\n-   ApplicationState.java\n\n## 5.2. 相关代码\n\n```java\nmTotalSize.setText(getSizeStr(mAppEntry.size));\n        final IPackageStatsObserver.Stub mStatsObserver = new IPackageStatsObserver.Stub() {\n            public void onGetStatsCompleted(PackageStats stats, boolean succeeded) {\n                boolean sizeChanged = false;\n                synchronized (mEntriesMap) {\n                    AppEntry entry = mEntriesMap.get(stats.packageName);\n                    if (entry != null) {\n                        synchronized (entry) {\n                            entry.sizeStale = false;\n                            entry.sizeLoadStart = 0;\n                            long externalCodeSize = stats.externalCodeSize\n                                    + stats.externalObbSize;\n                            long externalDataSize = stats.externalDataSize\n                                    + stats.externalMediaSize;\n                            long newSize = externalCodeSize + externalDataSize\n                                    + getTotalInternalSize(stats);\n                            if (entry.size != newSize ||\n                                    entry.cacheSize != stats.cacheSize ||\n                                    entry.codeSize != stats.codeSize ||\n                                    entry.dataSize != stats.dataSize ||\n                                    entry.externalCodeSize != externalCodeSize ||\n                                    entry.externalDataSize != externalDataSize ||\n                                    entry.externalCacheSize != stats.externalCacheSize) {\n                                entry.size = newSize;\n                                entry.cacheSize = stats.cacheSize;\n                                entry.codeSize = stats.codeSize;\n                                entry.dataSize = stats.dataSize;\n                                entry.externalCodeSize = externalCodeSize;\n                                entry.externalDataSize = externalDataSize;\n                                entry.externalCacheSize = stats.externalCacheSize;\n                                entry.sizeStr = getSizeStr(entry.size);\n                                entry.internalSize = getTotalInternalSize(stats);\n                                entry.internalSizeStr = getSizeStr(entry.internalSize);\n                                entry.externalSize = getTotalExternalSize(stats);\n                                entry.externalSizeStr = getSizeStr(entry.externalSize);\n                            }\n                        }\n\n            }\n        };\n         void handleStartCopy() throws RemoteException {\n            synchronized (mInstallLock) {\n                mSuccess = getPackageSizeInfoLI(mStats.packageName, mStats.userHandle, mStats);\n            }\n\n            final boolean mounted;\n            if (Environment.isExternalStorageEmulated()) {\n                mounted = true;\n            } else {\n                final String status = Environment.getExternalStoragePathState(); // SPRD: chanage interface\n                mounted = (Environment.MEDIA_MOUNTED.equals(status)\n                        || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));\n            }\n\n            if (mounted) {\n                final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);\n\n                mStats.externalCacheSize = calculateDirectorySize(mContainerService,\n                        userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));\n\n                mStats.externalDataSize = calculateDirectorySize(mContainerService,\n                        userEnv.buildExternalStorageAppDataDirs(mStats.packageName));\n\n                // Always subtract cache size, since it's a subdirectory\n                mStats.externalDataSize -= mStats.externalCacheSize;\n\n                mStats.externalMediaSize = calculateDirectorySize(mContainerService,\n                        userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));\n\n                mStats.externalObbSize = calculateDirectorySize(mContainerService,\n                        userEnv.buildExternalStorageAppObbDirs(mStats.packageName));\n            }\n        }             \n   \n      private boolean getPackageSizeInfoLI(String packageName, int userHandle,\n            PackageStats pStats) {\n        if (packageName == null) {\n            Slog.w(TAG, \"Attempt to get size of null packageName.\");\n            return false;\n        }\n        PackageParser.Package p;\n        boolean dataOnly = false;\n        String libDirPath = null;\n        String asecPath = null;\n        synchronized (mPackages) {\n            p = mPackages.get(packageName);\n            PackageSetting ps = mSettings.mPackages.get(packageName);\n            if(p == null) {\n                dataOnly = true;\n                if((ps == null) || (ps.pkg == null)) {\n                    Slog.w(TAG, \"Package named '\" + packageName +\"' doesn't exist.\");\n                    return false;\n                }\n                p = ps.pkg;\n            }\n            if (ps != null) {\n                libDirPath = ps.nativeLibraryPathString;\n            }\n            /* SPRD: Add support for install apk to internal sdcard @{ */\n            if (p != null && (isExternal(p) || isForwardLocked(p) || isInternalSd(p))) {\n            /* @} */\n                String secureContainerId = cidFromCodePath(p.applicationInfo.sourceDir);\n                if (secureContainerId != null) {\n                    asecPath = PackageHelper.getSdFilesystem(secureContainerId);\n                }\n            }\n        }\n        String publicSrcDir = null;\n        if(!dataOnly) {\n            final ApplicationInfo applicationInfo = p.applicationInfo;\n            if (applicationInfo == null) {\n                Slog.w(TAG, \"Package \" + packageName + \" has no applicationInfo.\");\n                return false;\n            }\n            if (isForwardLocked(p)) {\n                publicSrcDir = applicationInfo.publicSourceDir;\n            }\n        }\n        int res = mInstaller.getSizeInfo(packageName, userHandle, p.mPath, libDirPath,\n                publicSrcDir, asecPath, pStats);\n        if (res < 0) {\n            return false;\n        }\n\n        // Fix-up for forward-locked applications in ASEC containers.\n        /* SPRD: Add support for install apk to internal sdcard @{ */\n        if (!isExternal(p) && !isInternalSd(p)) {\n        /* @} */\n            pStats.codeSize += pStats.externalCodeSize;\n            pStats.externalCodeSize = 0L;\n        }\n\n        return true;\n    }\n   // installd中的统计方式与5.0相同\n```\n\n综上, Android4.4 与 Android5.0 / Android6.0的统计方式是一致的, 不再赘述.\n","tags":["Android 8.1"],"categories":["app storage"]},{"title":"文件加密FBE&DirectBoot模式调研","url":"/2017/08/02/其他调研/文件加密/","content":"\n文件加密FBE&DirectBoot模式介绍\n\n# 1. File based Encryption\n\n Android 7.0及以上版本提供基于文件的加密方式(FBE). 这种方式允许使用不同的密钥对不同的文件进行加密, 并且可以独立进行解密.\n       Android 7.0为基于文件的加密引入了新的功能, 命名为Direct Boot. 它允许加密设备直接启动至锁定屏幕的状态. 在以前的版本中, 使用全局磁盘加密(FDE)的设备,\n       用户需要在任何数据能够被访问前提供认证凭证(图形/密码/指纹), 来预防设备可能被进行的任何基本操作.\n     如: 闹钟无法执行, 辅助功能服务无法使用, 电话无法接受通话请求, 除了最基本的紧急通话操作.\n     使用基于文件加密的设备, 应用可以了解当前加密的情况, 同时被允许执行限定范围内的操作. 这些操作能够在用户提供认证凭证前执行, 同时依然能够保护私有用户信息.\n在使用FBE的设备上, 设备的每个用户对于设备应用均拥有两个存储空间:\n\n- 凭证加密存储区间(`Credential Encrypted (CE)`), 这是缺省的存储空间, 并且只有当用户解锁设备后才可用.\n- 设备加密存储空间(`Device Encrypted (DE)`), 该存储空间在Direct Boot模式和用户解锁设备后均可用.\n## 1.1. FDE Vs FBE:\n\n-  FBE: FILE BASED ENCRYPTION:\n    - 每一个用户一个CE key，CE key的加密信息存储在data分区的相应文件夹中。\n    - 每个用户对应一个DE key，除此之外，还有一个全局的DE key用来为与用户非强关联的文件夹设置加密。\n    - 设备未解锁之前，可以使用CE区域以外的文件夹。\n    - 加密针对文件夹级别，加密机制利用了Ext4 文件系统的加密特性。\n    - 这种区分能够使工作模型更为安全, 因为它允许在同一时间能够保护多个用户，并不是基于一个启动时密码。\n- FDE（FULL DISK ENCTYPTION）\n    - 只有一个key，key的加密信息存储在磁盘尾部区域。\n    - 设备未解锁之前，data目录是以tmpfs格式挂载的data分区处于完全不可使用状态。\n    - 加密针对的是分区级别，加密机制利用了dm-crypt加密特性。\n\n## 1.2. Dependencies\n设备必须满足以下的要求来安全使用AOSP的FBE实现:\n   - Kernel支持ext4加密(相关的kernel config为: EXT4_FS_ENCRYPTION)\n   - Keymaster支持1.0/2.0的HAL版本. 0.3版本的keymaster hal并不提供相关需要的属性支持, 而且不能保证加密密钥的安全保护机制.\n   - Keymaster/Keystore 和 GateKeeper必须在可信任执行环境(TEE)中实现, 用以提供对DE密钥的保护, 该情况下, 未认证的系统OS(自行输入到设备上的OS)将不能简单的访问DE密钥.\n   - kernel中提供的加密性能必须达到使用AES-XTS时最低为50MB/s来保证良好的用户体验.\n   - Verified Boot机制下 Keymaster root of trust 必须绑定至keymaster的初始化过程中. 这将保证设备加密证书不会被未验证的操作系统访问到\n   - bootloader passes the following information to the TEE after boot/recovery partition verification and\n     TEE initialization to bind the Keymaster root of trust:\n     -   the public key that was used to sign the boot partition\n\n## 1.3. 加密规则 Encryption policy\nExt4加密可以将加密规则应用到文件夹级别. 当设备的用户数据分区初次创建时, 由init脚本来赋值基本的结构和规则. 该脚本同时会触发来创建第一个用户(0用户)的CE/DE密钥, 并且定义那些目录需要由该密钥进行加密.\n当其余的用户和工作模式被创建时, 相关所需的密钥会被创建,  相关的存储目录会被创建并且由加密规则将密钥和目录链接起来.\n 在当前的AOSP实现中, 加密规则被硬编码到以下的位置:           \n` /system/extras/ext4_utils/ext4_crypt_init_extensions.cpp`\n 可以通过在这个文件中增加例外的规则来避免指定的目录被加密, 目录可以加入到directories_to_exclude列表中. 如果进行了该类的修改, 设备提供商必须包含增加SElinux的规则, 以使得只有必须使用未加密目录的应用才能获取访问权限, 其他未授权的应用必须被排除在外.\n\n## 1.4. 打开文件加密特性\nfstab中指定标志位 fileencryption 时默认开启文件加密。\n`/dev/block/platform/soc.0/f9824900.sdhci/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic wait,check,fileencryption `\n同时可以通过以下方法来测试设备上的FBE实现. 可以指定标志位: \n        forcefdeorfbe\n开启该标志位后，在开发者选项中，会多出一个菜单`convert encryption to file`。用户点击后，可以开启设备的文件加密特性。\n fastboot模式中也可以转变FBE模式:\n`$ fastboot --wipe-and-use-fbe`\n## 1.5. 文件加密相关流程\n### 1.5.1. Implementation\n- Setting中开启文件加密\n    - forcefdeorfbe \n    - forcefdeorfbe \n==> covert to file encryption\nMASTER_CLEAR->    wipe --reason=convert_fbe     -->  wipe_data   --> \n          format -->   make_ext4fs_directory(CONVERT_FBE_DIR)\n- fs阶段  mount_all时判断是否进入文件加密模式\n    - MF_FILEENCRYPTION\n    - MF_FORCEFDEORFBE&data/convert_fbe 文件存在\n        - install_keyring     调用add_key 创建一个session keyring\n        - 密钥环创建完成后，设置属性：\n            - ro.crypto.state      encrypted\n            - ro.crypto.type        file\n- post-fs-data  （late-init阶段 trigger）installkey      前置条件：ro.crypto.type=file\n    -  installkey\n        - 创建目录 /data/unencrypted\n        - 启动vdc service  对vold下发命令   cryptfs   enablefilecrypto\n            - 创建/data/unencrypted/key 目录\n            - 读取随机密钥ikey1：  /dev/urandom  读取 64字节作为文件加密的主密钥\n            - 读取密钥种子          /dev/urandom       读取1 << 14字节存储到  secdiscardable文件中\n            - 将scrypt扩展因子存储到stretching文件中   （ro.crypto.scrypt_params）\n            - 读取加密盐              /dev/urandom      读取1 << 4字节存储到salt文件中\n            - 根据auth  token（验证令牌）、密钥种子、扩展因子、加密盐生成APPLICATION_ID\n            - TEE根据auth token和 APPLICATION_ID 生成`keymaster_key_blob`（加密数据块）数据保存在 keymaster_key_blob文件中。\n            - TEE根据auth token、APPLICATION_ID、keymaster_key_blob、随机密钥ikey1生成加密主键保存在encrypted_key文件中。\n            -  对ikey1 做两次Sha512算法处理，得到ikey1的摘要key_ref2\n            - 搜索keyring（找到前面fs阶段调用add_key建立的session keyring），返回keyring的序列号\n            -  将当前的ikey1经过封装后加入到该keyring中。\n                - ikey1封装成payload数据块。\n                    - mode: EXT4_ENCRYPTION_MODE_AES_256_XTS\n                    - ikey1\n                    - ikey1->size\n               - add_key(   \"logon\",  ext4:key_ref2,   payload,    session-keyring   )\n             - 将ikey1的摘要key_ref2存储到/data/unencrypted/key/ref 文件中\n    - init_user0  (ro.crypto.type=file)\n        - 创建目录：\n            - data/misc/vold/user_keys\n            - data/misc/vold/user_keys/ce\n            - data/misc/vold/user_keys/de\n            - data/misc/vold/user_keys/de/0\n            - data/misc/vold/user_keys/ce/0\n        - create_and_install_user_keys\n            - 为user0 创建其对应的ce/de key\n                - 读取/dev/urandom  创建  ce_ikey1,  de_ikey1\n                - 在data/misc/vold/user_keys/ce/0下根据ce_ikey1计算存储各个加密过程的文件。  存储到data/misc/vold/user_keys/ce/0/current\n                - 在data/misc/vold/user_keys/de/0下根据de_ikey1计算存储各个加密过程的文件。  存储到data/misc/vold/user_keys/de/0/\n                - 加密过程文件：          version、secdiscardable、stretching、salt、keymaster_key_blob\n                -  将ce_ikey1,de_ikey1添加到keyring中。\n        - load_all_de_keys将根据加密过程文件进行解密出对应的de_key并安装到session-keyring中。\n        - e4crypt_prepare_user_storage(DE)  准备DE区域文件夹，并设置加密策略. 以空token和seceret调用e4crypt_unlock_user_key  计算ce_key,或初始化ce_key\n            - e4crypt_prepare_user_storage\n                - /data/misc_de/0\n                - /data/system_de/0\n                - /data/user_de/0/\n                - 加密策略存储在文件系统级别，通过`ioctl (fd, EXT4_IOC_SET_ENCRYPTION_POLICY | EXT4_IOC_GET_ENCRYPTION_POLICY,  & ext4_encryption_policy) `，主要是master_key_descriptor字段，保存了de_key的摘要信息。如果文件夹是空文件夹，则执行SET，非空则GET，并校验policy信息是否正确。\n                    - e4crypt_unlock_user_key\n                        - 前置条件 ro.crypto.type=file   persist.sys.emulate_fbe=false\n                        - 解密的流程与前面create_and_install_user_keys的思路基本一致。在`/data/misc/vold/user_keys/<userid>/current`目录下读取**version、secdiscardable、stretching、salt、keymaster_key_blob、encrypted_key及auth 解出加密键 ce_key**。将解出的key（对应前面的随机key）进行两次Sha512计算得出摘要。\n                        - 将计算出的ce_key，摘要作为descriptor，add logon key 到 session-keyring中。\n\n## 1.6. ext4 加密\nAOSP实现使用kernel中的ext4加密功能, kernel被配置为:\n- 使用XTS模式的 AES-256 加密文件内容.\n- 使用CBC-CTS模式的AES-256 加密文件名.\n密钥管理:\n- 使用512位的AES-XTS密钥作为文件的加密密钥\n- 它被保存在TEE中的另一份密钥进行加密，加密之后保存到encrypt_key文件中\n- 如果需要使用TEE密钥, 必须满足以下三个条件:\n    - 验证令牌. The auth token\nAuth token是由GateKeeper在用户成功登录时产生的加密令牌. TEE只有在正确的加密令牌被提供时才能够对AES-XTS密钥进行处理. 如果当前用户并没有证书, 那么验证的令牌将不被使用。\n    - 扩展证书. The stretched credential\nStretched credential是用户的证书, 同时经过了加密算法和加盐的处理. 并且在由lock setting服务传递给vold进行加密运算前, 还进行过hash处理. 该证书同所有通过APPLICATION_ID进行的提权行为绑定, 并通过TEE中的密钥进行加密. 如果用户没有证书, 该扩展证书将不存在或者没有必要使用. \n    - 随机hash. The “secdiscardable hash”\n`Secdiscardable hash`是一个随机的16KB单独存放的文件, 用来重建密钥, 密码种子. 这份文件将在密钥删除时同样被安全删除掉, 或者被以其他方式再加密. 这个额外的保护将限制攻击者必须使用这个文件重建密钥. 这同样通过APPLICATION_ID同TEE中的密钥进行绑定. \n>所有的DE KEY、 默认密码的CE KEY及global key，对应空的token、空的secret、空的用户证书，保证了不需要用户参与即可解锁。APPLICATION_ID可以理解为同TEE的一次会话连接ID。\n## 1.7. 密钥管理\n\n![密钥管理](../images/20201231180022.png)\n## 1.8. FBE开机流程\n\n![](../images/20201231181836.svg)\n\n## 1.9. 解锁流程\n![](../images/20201231181845.svg)\n\n\n## 1.10. 加解密流程图\n![加密](../images/20201231180016.png)\n![解密](../images/20201231180008.png)\n\n# 2. Linux key retention service\n在 Linux 内核中缓存身份验证数据。远程文件系统和其他内核服务可以使用这个服务来管理密码学、身份验证标记、跨域用户映射和其他安全问题。它还使 Linux 内核能够快速访问所需的密钥，并可以用来将密钥操作（比如添加、更新和删除）委托给用户空间。\n密钥的属性:\n- 序列号（Serial number）：一个惟一的 32 位非零正数\n- 类型（Type）：Linux 密钥保留服务定义两个标准密钥类型：user 和 keyring。要添加新的密钥类型，必须由一个内核服务注册它。用户空间程序不允许创建新的密钥类型\n- 描述（Description）：一个描述密钥的可输出字符串。这个属性还可以用来执行搜索操作\n- 访问控制信息（Access control information）：每个密钥有一个所有者 ID、一个 GID 和一个权限掩码，权限掩码表示如何响应用户级或内核级程序。权限掩码给四个可能的密钥访问者类型各分配 8 位：所有者、用户、组和其他。\n- 密钥类型 (预定义的密钥类型)\n    - keyring \n    - user \n    - logon\n## 2.1. 访问控制信息 \n| 访问控制信息 |   UID    |   GID    |  Other   | Permission Granted |\n| :--------: | :------: | :------: | :------: | :---------------: |\n|  01000000  | 00010000 | 00000100 | 00000001 |       View        |\n|  02000000  | 00020000 | 00000200 | 00000002 |       Read        |\n|  04000000  | 00040000 | 00000400 | 00000004 |       Write        |\n|  08000000  | 00080000 | 00000800 | 00000008 |       Search       |\n|  10000000  | 00100000 | 00001000 | 00000010 |       Link        |\n|  20000000  | 00200000 | 00002000 | 00000020 |   Set Attribute    |\n\n![keyring 钥匙环](../images/20201231180043.png)\n\n### 2.1.1. keyring\n\nKeyrings are special key types that may contain links to sequences of other keys of any type. If this interface is used to create a keyring.\nkeyring 包含一组到其他密钥或 keyring 的链接。\n- 线程特有的\n- 进程特有的\n- 会话特有的\n- 用户特有的会话\n- 用户默认的会话\n用户特有的会话 keyring 通常会链接到一个会话特有的 keyring。\n登录进程将绑定到用户默认的会话 keyring，直到创建另一个会话为止。\n#### 2.1.1.1. SESSION-KEYRING\n\n进程的session-keyring能够被其fork clone的进程保留。新进程可以通过设置uid、gid继承session\n当指向这个session-keyring的最后一个进程终止后，该session会被杀掉。\n进程可以创建新的session，也可以重新绑定已经存在的session。\n### 2.1.2. Linux key相关的系统调用\n\n- add_key    在用户空间中操作密钥\n add_key 系统调用用来创建类型为 type、长度为 plen 的密钥。密钥描述由 desc 定义，它的有效内容由 payload 指定。密钥链接到 keyring。密钥类型可以是 user 或 keyring或logon（新增，与user类型的区别是不允许读payload的内容）。其他任何密钥类型必须已经通过内核服务向内核注册，然后才能使用。\n\n- request_key   由ext4 文件系统层调用\nrequest_key 系统调用搜索一个进程 keyring，寻找一个密钥是否匹配查询的type和description。\n          查询不到返回ENOKEY（android中 Required key not available）\n```shell\n|-exam_dir\n       |-encrypt_file  \"abcd\"            read  modify rename ok\n       |-encrypt_dir\n\t      |-encrypt_file1 \"abcd\"\n                |-sub_dir                         mkdir touch \"No such file or directory\"    (no process inherit）\n#继承权限的有完全的访问读写权限, 没有继承的进程能查看修改当前已经有的文件，没法创建新的\n|-exam_dir\n       |-GWblA3FA88KbBtt70xeCHC  \"?\"                   mkdir create  mv \"No such file or directory\"\n       |-i5,V3FkRLu2LWiq8kqJSKC                              chmod   ok     rm ok\n\t      |-B,W714L8gi9jCZBChCUosA \"?\"             modify read  \"Required key not available\"\n                |-iDxJ0XhpXRowbkO2iPQHID\n```\n# 3. 在应用中支持Direct Boot\n```xml\n<application\n    android:directBootAware=\"true\"   适用所有应用\n    android:defaultToDeviceProtectedStorage=\"true\">   默认使用DE目录存储  仅适用于系统应用\n```\n应用级别的directBootAware作用是表明该应用中的所有组件都是已经和加密相关的.\n当DE区域解锁以后，应用可以收到` LOCKED_BOOT_COMPLETED`的广播，定义了`directBootAware`的组件可以使用\n即DE区域解锁以后，CE区域解锁之前，只有定义`directBootAware`的组件可以使用\n`Context.createDeviceProtectedStorageContext() `\n使用此上下文执行的所有存储 API 调用均访问设备加密存储（DE）\n`Context.createCredentialProtectedStorageContext() `\n使用此上下文执行的所有存储 API 调用均访问凭证加密存储（CE）\nAndroid7.0 上默认的应用存储空间指向CE区间。\n`defaultToDeviceProtectedStorag`e属性将缺省的应用存储空间由原来的指向CE区间重新连接指向DE区间。\n使用该属性标志的应用必须仔细调整所有存储于缺省空间的敏感数据，将其中的敏感数据修改路径存储至CE空间. 使用标志的设备提供商应用也必须仔细考虑, \n在存储相关数据时, 必须确保在DE空间内不包含用户信息相关的内容.\n`Context.isCredentialProtectedStorage()\nContext.isDeviceProtectedStorage()`\n>此处  CE目录 DE目录 目前生效的只有/data/user|user_ce/<userid>目录\n\n重启后一旦用户解锁了设备，您的应用即可切换至访问凭据加密存储，并使用依赖用户凭据的常规系统服务。\n应用需要监听 `ACTION_USER_UNLOCKED`广播，来确定用户已经解锁了`CE`区域。\n或者可以接收现有 `ACTION_BOOT_COMPLETED` 消息，该消息现在表明设备已启动，且用户已解锁设备。\n可以通过调用 `UserManager.isUserUnlocked() `直接查询用户是否已解锁设备\n当设备解锁后，可能需要将现有数据迁移到设备加密存储。 \n`Context.moveSharedPreferencesFrom(context，filename) `\n`Context.moveDatabaseFrom(context, filename) `\n根据应用自身情况决定哪些数据需要迁移，不应该将用户的私密信息迁移到DE区域\n默认情况下，应用不会在“直接启动”模式下运行。如果应用需要在“直接启动”模式下进行操作，您可以注册在此模式期间应运行的应用组件。 对于需要在“直接启动”模式下运行的应用，常见的一些用例包括：\n   - 已安排通知的应用，如闹钟应用。\n   - 提供重要用户通知的应用，如短信应用。\n   - 提供无障碍服务的应用，如 Talkback。\n如果应用在“直接启动”模式下运行时需要访问数据，则使用设备加密存储。\n设备加密存储包含使用密钥加密的数据，仅在设备已成功执行验证启动后密钥才可用。\n\n对于应使用与用户凭据（如 PIN 或密码）关联的密钥加密的数据，使用凭据加密存储。凭据加密存储仅在用户已成功解锁设备后可用，直到用户再次重启设备。 如果用户在解锁设备后启用锁定屏幕，则不会锁定凭据加密存储。\n## 3.1. 支持DirectBoot的相关应用:\nvold负责提供android中管理存储设备和卷标的功能. FBE向vold提供了额外的新命令, 以支持在多用户情况下对于CE/DE的密钥进行管理的功能.\n使用kernel支持的基于ext4 encryption的加密属性, 很多系统应用包括锁屏界面和SystemUI都被修改以支持FBE和Direct Boot功能. \n\n","tags":["Android","FBE","DirectBoot"],"categories":["Android"]},{"title":"Print框架整理","url":"/2017/08/02/其他调研/Print框架整理/","content":"\n# 1. 开篇\n\n涉及的主要文件:\n\n`com.android.server.print`\n\n系统打印服务,   打印服务是一种插件（ plug-in components），它能够通过一些标准协议和打印机通讯。这些服务像一座桥，处于系统和打印机之间。因此，打印机和打印协议的具体实现从系统中分离的，能够独立开发和更新。该处讲解的是和打印插件关联的系统服务.\n\n/frameworks/base/services/print/java/com/android/server/print/\n\n```sh\n/home/newdisk/local/SPREADTRUM/liguang.zhang/remote_disk/sp8.1_trunk/frameworks/base/services/print/java/com/android/server/print$ lltotal 220\ndrwxr-xr-x 1 2516 2000  4096 Jun 25 14:20 ./\ndrwxr-xr-x 1 2516 2000  4096 Nov  8  2017 ../\n# PrintService插件管理类.\n-rw-r--r-- 1 2516 2000 41807 Jun 25 16:21 PrintManagerService.java\n# 负责和PrintService插件进行bind, 以及插件的状态进行关联\n-rw-r--r-- 1 2516 2000 34039 Jun 25 14:20 RemotePrintService.java\n# 推荐选择默认的打印插件\n-rw-r--r-- 1 2516 2000  8869 Jun 25 14:20 RemotePrintServiceRecommendationService.java\n# 打印机后台处理程序,打印任务工作状态相关.\n-rw-r--r-- 1 2516 2000 34260 Nov  8  2017 RemotePrintSpooler.java\n# 和用户安装的打印服务相关的管理,通过userState中转转发和PrintManagerService进行交互\n-rw-r--r-- 1 2516 2000 85628 Jun 25 15:47 UserState.java\n```\n\n# 2. PrintManagerService初始化\n\nPrintManagerService(简写PMS) 初始化\n\nSystemServer中启动PMS\n\n```java\n            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {\n                traceBeginAndSlog(\"StartPrintManager\");\n                mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);\n                traceEnd();\n            }\n// onStart注册'print'的服务\n    public void onStart() {\n        publishBinderService(Context.PRINT_SERVICE, mPrintManagerImpl);\n    }\n// 监听DISABLED_PRINT_SERVICES 字段, 表示禁用的打印服务插件, 如果该字段变化,则需要重新更新UserState的关联的打印插件.\n            registerContentObservers();\n// 监听PACKAGE ADD/REMOVE/MODIFY等的广播, 用来更新打印插件服务的状态\n            registerBroadcastReceivers();\n```\n\n跟User关联的userState实例通过getOrCreateUserStateLocked方法创建并保存到\nPMS的mUserStates中(userid--UserState map)\n\n# 3. UserState 初始化\n\n1. 关联 RemotePrintSpooler类. 该类主要是讲远程打印机的状态本地化, 实现监控remote print的状态.   (后台作业)\n\n2. UserStateHandler, 用于处理\n\n   `PRINT_JOB_STATE_CHANGED`/\n\n    `PRINT_SERVICES_CHANGED`/\n\n   `PRINT_SERVICES_RECOMMENDATIONS_UPDATED`\n\n   `CHECK_CONFIG_CHANGED`事件.  主要为前三类.\n\n3. 读取已经为该用户安装的printService插件. 满足几个条件:\n\n   manifest定义举例:\n\n   ```java\n           <service\n               android:name=\"android.print.cts.services.FirstPrintService\"\n   1.            android:permission=\"android.permission.BIND_PRINT_SERVICE\">\n               <intent-filter>\n   2.                <action android:name=\"android.printservice.PrintService\" />\n               </intent-filter>\n               <meta-data\n   3.               android:name=\"android.printservice\"\n                  android:resource=\"@xml/printservice\">\n               </meta-data>\n           </service>\n          // printservice.xml 配置打印机的相关页面.\n          <print-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              // settingsActivity在打印插件开启界面右上角的菜单里，用于配置插件\n        android:settingsActivity=\"android.print.cts.services.SettingsActivity\"\n            // 在自定义的 addPrintersActivity 中，系统不会自动触发打印机寻找过程，需要自行处理\n        android:addPrintersActivity=\"android.print.cts.services.AddPrintersActivity\"\n            //advancedPrintOptionsActivity则是在打印文件的界面上点击更多箭头里出现的MORE OPTIONS选项触发，这个activity用配置打印机的跟多信息。\n        android:advancedPrintOptionsActivity=\"android.print.cts.services.CustomPrintOptionsActivity\"/>\n   ```\n\n4. store the disabled services, 保存到表中 Settings.Secure.ENABLED_PRINT_SERVICES, 处理mDisabledServices\n\n5. onConfigurationChangedLocked根据mDisabledServices和mActiveServices添加或删除打印插件托管,并通过`MSG_DISPATCH_PRINT_SERVICES_CHANGED`回调IPrintServicesChangeListener的onPrintServicesChanged, 该listener通过*`addPrintServicesChangeListener`*进行注册的.\n```java\n    public UserState(Context context, int userId, Object lock, boolean lowPriority) {\n        // 初始化RemotePrintSpooler, \n        mSpooler = new RemotePrintSpooler(context, userId, lowPriority, this);\n        mHandler = new UserStateHandler(context.getMainLooper());\n\n        synchronized (mLock) {\n            readInstalledPrintServicesLocked();\n            upgradePersistentStateIfNeeded();\n            readDisabledPrintServicesLocked();\n        }\n\n        // Some print services might have gotten installed before the User State came up\n        prunePrintServices();\n\n        synchronized (mLock) {\n            onConfigurationChangedLocked();\n        }\n    }\n```\n\n需要重点看下onConfigurationChangedLocked函数的处理.\n\n```java\nprivate void onConfigurationChangedLocked() {\n    ArrayList<ComponentName> installedComponents = getInstalledComponents();\n\n    final int installedCount = installedComponents.size();\n    for (int i = 0; i < installedCount; i++) {\n        ComponentName serviceName = installedComponents.get(i);\n       // 1. 既没在mDisabledServices也没在mActiveServices中, 初始化RemotePrintService,并调用addServiceLocked函数\n        if (!mDisabledServices.contains(serviceName)) {\n            if (!mActiveServices.containsKey(serviceName)) {\n                RemotePrintService service = new RemotePrintService(\n                        mContext, serviceName, mUserId, mSpooler, this);\n                addServiceLocked(service);\n            }\n        } else {\n            // 2. 在mDisabledServices中,调用removeServiceLocked\n            RemotePrintService service = mActiveServices.remove(serviceName);\n            if (service != null) {\n                removeServiceLocked(service);\n            }\n        }\n    }\n\n    Iterator<Map.Entry<ComponentName, RemotePrintService>> iterator =\n            mActiveServices.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry<ComponentName, RemotePrintService> entry = iterator.next();\n        ComponentName serviceName = entry.getKey();\n        RemotePrintService service = entry.getValue();\n        //3. 删除没有安装的过期的RemotePrintService实例\n        if (!installedComponents.contains(serviceName)) {\n            removeServiceLocked(service);\n            iterator.remove();\n        }\n    }\n    //4. 回调 IPrintServicesChangeListener的 onPrintServicesChanged\n    // listener是通过addPrintServicesChangeListener添加的.\n    onPrintServicesChanged();\n}\n\n1.0 RemotePrintService的初始化\n+ mCallbacks = callbacks;   // RemotePrintService的callback成员为UserState\n+ serviceName\n+ userid\n+ spooler   // 关联UserState的spooler.\n+ mPrintService// 关联到打印插件\n1.1. 将该printService插件加到mActiveServices中\n1.2. 回调mPrinterDiscoverySession onServiceAddedLocked(RemotePrintService)方法\n// PrinterDiscoverySessionMediator为UserState的内部类, 主要作用是跟RemotePrintService以及Session状态关联,通过SessionHandler控制RemotePrintService. SessionHandler-->RemotePrintService.Handler-->bind printService-->PrintService插件todo task.\nprivate PrinterDiscoverySessionMediator mPrinterDiscoverySession;\n\n        public void onServiceAddedLocked(RemotePrintService service) {\n            if (mIsDestroyed) {\n                Log.w(LOG_TAG, \"Not updating added service - session destroyed\");\n                return;\n            }\n            // Tell the service to create a session.\n            1.2.1 MSG_CREATE_PRINTER_DISCOVERY_SESSION 建立一个session\n            mSessionHandler.obtainMessage(\n                    SessionHandler.MSG_CREATE_PRINTER_DISCOVERY_SESSION,\n                    service).sendToTarget();\n            1.2.2 通过session查找打印机\n            // Start printer discovery if necessary.\n            if (!mStartedPrinterDiscoveryTokens.isEmpty()) {\n                mSessionHandler.obtainMessage(\n                        SessionHandler.MSG_START_PRINTER_DISCOVERY,\n                        service).sendToTarget();\n            }\n            // Start tracking printers if necessary\n            1.2.3 根据RemotePrintService 绑定的打印插件, 与搜索到的打印机, 打印机属于该打印插件时,启动tracking.\n            final int trackedPrinterCount = mStateTrackedPrinters.size();\n            for (int i = 0; i < trackedPrinterCount; i++) {\n                PrinterId printerId = mStateTrackedPrinters.get(i);\n                if (printerId.getServiceName().equals(service.getComponentName())) {\n                    SomeArgs args = SomeArgs.obtain();\n                    args.arg1 = service;\n                    args.arg2 = printerId;\n                    mSessionHandler.obtainMessage(SessionHandler\n                            .MSG_START_PRINTER_STATE_TRACKING, args)\n                            .sendToTarget();\n                }\n            }\n        }\n2. removeServiceLocked\n    private void removeServiceLocked(RemotePrintService service) {\n        // Fail all print jobs.\n2.1        failActivePrintJobsForService(service.getComponentName());\n        // If discovery is in progress, tear down the service.\n        if (mPrinterDiscoverySession != null) {\n2.2            mPrinterDiscoverySession.onServiceRemovedLocked(service);\n        } else {\n            // Otherwise, just destroy it.\n            service.destroy();\n        }\n    }\n2.1 // Fail all print jobs.\n        private void failScheduledPrintJobsForServiceInternal(ComponentName serviceName) {\n       // 根据打印插件名查找所有进行着的后台作业\n        List<PrintJobInfo> printJobs = mSpooler.getPrintJobInfos(serviceName,\n                PrintJobInfo.STATE_ANY_SCHEDULED, PrintManager.APP_ID_ANY);\n        if (printJobs == null) {\n            return;\n        }\n        try {\n            final int printJobCount = printJobs.size();\n            for (int i = 0; i < printJobCount; i++) {\n                PrintJobInfo printJob = printJobs.get(i);\n                // 全部设为FAILED state.\n                mSpooler.setPrintJobState(printJob.getId(), PrintJobInfo.STATE_FAILED,\n                        mContext.getString(R.string.reason_service_unavailable));\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n  2.2. // If discovery is in progress, tear down the service.\n      public void onServiceRemovedLocked(RemotePrintService service) {\n            if (mIsDestroyed) {\n                Log.w(LOG_TAG, \"Not updating removed service - session destroyed\");\n                return;\n            }\n            // Remove the reported and tracked printers for that service.\n            // 删除为该打印插件服务搜索到的打印机或正在跟踪的打印机\n            ComponentName serviceName = service.getComponentName();\n            // mPrinters.remove(removedPrinterIds.get(i)); \n            // 从mPrinter中删除. 并通知给通过addObserverLocked添加的observer删除了这些打印机.\n            //  handlePrintersRemoved(observer, removedPrinterIds); 回调 observer.onPrintersRemoved(new ParceledListSlice<PrinterId>(printerIds))方法            \n            removePrintersForServiceLocked(serviceName);\n 2.2.1           // 最后进到RemotePrintService的destroy流程\n            service.destroy();\n        }\n 2.2.1 //service.destroy(); --> RMS.handleDestroy\n         private void handleDestroy() {\n        // Stop tracking printers.\n        // 回调打印插件的stopPrinterStateTracking方法.\n        // tracking 是持续跟踪打印机最新状态的机制.\n        stopTrackingAllPrinters();\n        // Stop printer discovery.\n        if (mDiscoveryPriorityList != null) {\n            handleStopPrinterDiscovery();\n        }\n        // Destroy the discovery session.\n        if (mHasPrinterDiscoverySession) {\n            // 回调 mPrintService.stopPrinterDiscovery();方法. 停止该打印插件搜索打印机的过程.\n            handleDestroyPrinterDiscoverySession();\n        }\n\n        // Unbind. RMS unbind 该打印插件.\n        ensureUnbound();\n\n        // Done\n        mDestroyed = true;\n    }\n```\n\n## 3.1. 小节\n\n该处主要涉及UserState的初始化. UserState是一个很重要的桥梁,关联到\n\n- RemotePrintService   \n\n  每个RMS实例绑定到一个打印插件. UserState通过`mActiveServices`保存了激活状态的RMS.通过mDisabledServices保存了弃用的RMS. RMS是以其绑定的打印插件compnent名为标志的. 当打印插件卸载时, 对应的RMS也要销毁. 当打印插件处于关闭状态时, RMS为Disable状态. 通过UserState的SessionHandler嫁接到RMS的handler中,并通过RMS的mPrintService控制打印插件进行真正的任务处理.\n\n- `IPrinterDiscoveryObserver` (通过addObserverLocked添加)\n\n  该observer监听打印机的搜索过程, 这个地方主要关联到\n\n  [frameworks](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/)/[base](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/)/[core](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/core/)/[java](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/core/java/)/[android](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/core/java/android/)/[print](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/core/java/android/print/)/[PrinterDiscoverySession.java](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/core/java/android/print/PrinterDiscoverySession.java)\n\n  该类作为客户端,提供了setOnPrintersChangeListener方法, 通过observer的中转, 将打印机的状态变化可以通知到外部的app.\n\n  ex: Settings app\n\n  ```java\n  if (mDiscoverySession == null) {\n      PrintManager printManager = (PrintManager) getContext()\n              .getSystemService(Context.PRINT_SERVICE);\n      //SPRD 742355 main thread block by binder caused anr\n      new AsyncTask<Void, Void, Void>() {\n          @Override\n          protected Void doInBackground(Void... params) {\n              mDiscoverySession = printManager.createPrinterDiscoverySession();\n              return null;\n          }\n          @Override\n          protected void onPostExecute(Void result) {\n              if (mDiscoverySession == null) {\n                  return;\n              }\n              mDiscoverySession.setOnPrintersChangeListener(new OnPrintersChangeListener() {\n                  @Override\n                  public void onPrintersChanged() {\n                      deliverResult(new ArrayList<PrinterInfo>(\n                          mDiscoverySession.getPrinters()));\n                  }\n              });\n              mDiscoverySession.startPrinterDiscovery(null);\n          }\n      }.execute();\n  }\n  ```\n\n- `IPrintServicesChangeListener`(通过addPrintServicesChangeListener添加)通过PrintManager中转,提供给外部app使用. 通知RMS状态的变更. 外部可以通过mPrintManager.getPrintServices拿到打印插件.\n\n  ```java\n  // ENABLED_SERVICES | DISABLED_SERVICES | ALL_SERVICES\n  List<PrintServiceInfo> infos = mPrintManager.getPrintServices(\n          PrintManager.ENABLED_SERVICES);\n  addPrintServicesChangeListener\n  mPrintManager.addPrintServicesChangeListener(this, null);\n  ```\n\n- RemotePrintSpooler\n\n  bind到后台作业服务, \"com.android.printspooler\"\n\n  源码中默认为PrintSpooler [frameworks/base/packages/PrintSpooler/](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/frameworks/base/packages/PrintSpooler/)\n\n  通过setClientLocked设置PrintSpoolerClient为PrintSpooler的client.\n\n  PrintSpoolerClient 类通过callbacks 实际传导到userState类中, userState再根据消息类别转发到不同的地方进行处理.\n\n  ```java\n    public static final String PRINT_SPOOLER_PACKAGE_NAME = \"com.android.printspooler\";\n    mIntent.setComponent(new ComponentName(PrintManager.PRINT_SPOOLER_PACKAGE_NAME,\n            PrintManager.PRINT_SPOOLER_PACKAGE_NAME + \".model.PrintSpoolerService\"));\n  ```\n\n  以restartPrintJob为例. 说明下调用流程. (app调用PrintManager的接口)\n\n  PrintManager --> PrintManagerService --> `UserState` -- > RemotePrintSpooler --> RPS.SetPrintJobStateCaller--> `PrintSpooler.PrintSpoolerService` -- setPrintJobState  -->  PrintSpooler.PrintSpoolerService -- sendOnPrintJobQueued --> mClient.onPrintJobQueued(printJob);\n\n  回调过程:  \n\n  `PrintSpoolerClient`.onPrintJobQueued --> `UserState`--onPrintJobQueued--> RemotePrintService.onPrintJobQueued--> `打印插件服务`-- onPrintJobQueued\n\n  可见有最终任务的还是要通过打印插件服务传递给打印机.\n\n# 4. 系统内建打印插件服务\n\nBuiltInPrintService\n\n[packages](http://10.0.1.79:8081/source/xref/sprdroid8.1_trunk_18b_rls1/packages/)/[services](http://10.0.1.79:8081/source/xref/sprdroid8.1_trunk_18b_rls1/packages/services/)/[BuiltInPrintService](http://10.0.1.79:8081/source/xref/sprdroid8.1_trunk_18b_rls1/packages/services/BuiltInPrintService/)/\n\n## 4.1. Manifest 解释\n\n```java\n<service android:name=\"com.android.bips.BuiltInPrintService\"\n<service android:name=\"com.android.bips.render.PdfRenderService\"\nandroid:name=\"com.android.bips.ui.AddPrintersActivity\"\n```\n\n```xml\n<print-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:addPrintersActivity=\"com.android.bips.ui.AddPrintersActivity\"\n/>\n```\n\n服务插件需要继承 PrintService\n\n```java\npublic class BuiltInPrintService extends PrintService {\n```\n\n继承的方法:\n\n- onCreatePrinterDiscoverySession\n- onRequestCancelPrintJob(PrintJob printJob)\n- onPrintJobQueued(PrintJob printJob)\n\n## 4.2. PrintService 基类\n\nPrintService是RemotePrintService bind的基类, RMS中保存的mPrintService指向该类\n\n成员:\n\n+ mClient\n\n  指向RemotePrintService的内部类RemotePrintServiceClient.\n\n  该变量被传到PrintJob的mPrintServiceClient中.\n\n+ mDiscoverySession\n\n  通过子类实现的onCreatePrinterDiscoverySession的方法创建.\n\n  为PrinterDiscoverySession对象. 需要打印服务插件继承该类.提供打印插件内打印机搜索跟踪打印机状态等的功能.\n\n## 4.3. PrinterDiscoverySession基类\n\n服务插件的Session类需要继承PrinterDiscoverySession\n\n需继承的方法:\n\n- onStartPrinterDiscovery(@NonNull List<PrinterId> priorityList)\n\n- onStopPrinterDiscovery()\n\n- onValidatePrinters(@NonNull List<PrinterId> printerIds)\n\n- onStartPrinterStateTracking(@NonNull PrinterId printerId)\n\n- onRequestCustomPrinterIcon\n\n- onStopPrinterStateTracking\n\n- onDestroy\n\n  \n\n# 5. Ui 显示\n\n系统中内置的加载printer的显示为Settings进程.\n\n[packages](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/)/[apps](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/)/[Settings](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/)/[src](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/)/[com](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/com/)/[android](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/com/android/)/[settings](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/com/android/settings/)/[print](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/com/android/settings/print/)/\n\n[PrintServiceSettingsFragment.java](http://10.0.1.79:8081/xref/sprdroid8.1_trunk_18b_rls1/packages/apps/Settings/src/com/android/settings/print/PrintServiceSettingsFragment.java) \n\n涉及到LOADER的使用:\n\n```java\n   public class PrintServiceSettingsFragment extends SettingsPreferenceFragment\n        implements SwitchBar.OnSwitchChangeListener,\n        LoaderManager.LoaderCallbacks<List<PrintServiceInfo>> {\n            \nprivate final class PrintersAdapter extends BaseAdapter\n            implements LoaderManager.LoaderCallbacks<List<PrinterInfo>>, Filterable {\n\n```\n\n## 5.1. Loader\n\nLoader在执行了startLoading()方法后，会进入started状态，LoaderManager会在合适的时机执行Loader.startLoading()方法，概括来说，当我们执行LoadManager.initLoader()时，如果Loader不存在，内部会执行LoadCallbacks的onCreateLoader()方法创建Loader，并让新创建的Loader执行startLoading()方法。\n\n具体执行过程如下： \nLoaderManager.initLoader() -> \nLoaderManager.createAndInstallLoader() -> \nLoaderManager.createLoader() -> \n`LoaderCallbacks.onCreateLoader()` -> \n得到loader之后创建LoaderInfo -> \nLoaderManager.installLoader() -> \n将其放入LoaderManager内部维护的mLoaders数组中 -> \nLoaderInfo.start() -> \nLoader处于started状态 -> \n`Loader.startLoading() ->Loader.onStartLoading()`\n\n## 5.2. LoaderManager.LoaderCallbacks\n\nLoaderManager.LoaderCallbacks是LoaderManager中的内部接口，客户端与Loader的通信完全是事件机制，即客户端需要实现LoaderCallbacks中的各种回调方法，以响应Loader & LoaderManager触发的各种事件。客户端在调用LoaderManager的`initLoader`()或`restartLoader`()方法时，就需要客户端向这两个方法中传入一个LoaderCallbacks的实例。LoaderCallbacks有三个回调方法需要实现：onCreateLoader()、onLoadFinished()以及onLoaderReset()。\n\n```java\npublic class PrintServiceSettingsFragment extends SettingsPreferenceFragment\n        implements SwitchBar.OnSwitchChangeListener,\n        LoaderManager.LoaderCallbacks<List<PrintServiceInfo>> {\n// this 是 PrintServiceSettingsFragment\ngetLoaderManager().initLoader(LOADER_ID_PRINT_SERVICE_LOADER, null, this);\n       @Override\n    public Loader<List<PrintServiceInfo>> onCreateLoader(int id, Bundle args) {\n        return new PrintServicesLoader(\n                (PrintManager) getContext().getSystemService(Context.PRINT_SERVICE), getContext(),\n                PrintManager.ALL_SERVICES);\n    }         \n            \n            \n    private final class PrintersAdapter extends BaseAdapter\n            implements LoaderManager.LoaderCallbacks<List<PrinterInfo>>, Filterable {\n// this 是PrintAdapter\n        public void enable() {\n            getLoaderManager().initLoader(LOADER_ID_PRINTERS_LOADER, null, this);\n        }\n   \n                @Override\n        public Loader<List<PrinterInfo>> onCreateLoader(int id, Bundle args) {\n            if (id == LOADER_ID_PRINTERS_LOADER) {\n                return new PrintersLoader(getContext());\n            }\n            return null;\n        }\n```\n\n## 5.3. onCreateLoader\n\nonCreateLoader：我们要在onCreateLoader()方法内返回一个Loader的实例对象。很多情况下，我们需要查询ContentProvider里面的内容，那么我们就需要在onCreateLoader中返回一个CursorLoader的实例，CursorLoader继承自Loader。\n\n如果CursorLoader不能满足我们的需求，我们可以自己编写自己的Loader然后在此onCreateLoader方法中返回。\n\n此处是自己构造的loader  \n\n```java\npublic class PrintServicesLoader extends Loader<List<PrintServiceInfo>>\n```\n\n此处返回的是Loader<List<PrintServiceInfo>>, 是PrintServicesLoader对象.\n\nPrintServiceInfo是关联到安装的打印插件服务的. PrintServiceInfo中保存了打印服务插件的从PackageManager拿到的resolveInfo信息(queryIntentServicesAsUser返回的结果)和前面介绍的settingsActivityName/addPrintersActivityName/advancedPrintOptionsActivityName\n\n```java\n//readInstalledPrintServicesLocked方法中添加的PrintServiceInfo\ntempPrintServices.add(PrintServiceInfo.create(mContext, installedService));\nmInstalledServices.addAll(tempPrintServices);\n//通过PrintManager getPrintServices拿到的就是mInstalledServices集合\n```\n\n```java\npublic PrintServicesLoader(@NonNull PrintManager printManager, @NonNull Context context,\n        int selectionFlags) {\n    super(Preconditions.checkNotNull(context));\n    mHandler = new MyHandler();\n    mPrintManager = Preconditions.checkNotNull(printManager);\n    mSelectionFlags = Preconditions.checkFlagsArgument(selectionFlags,\n            PrintManager.ALL_SERVICES);\n}\n```\n\nonForceLoad\n\n```java\n@Override\nprotected void onForceLoad() {\n    queueNewResult();\n}\n\n/**\n * Read the print services and queue it to be delivered on the main thread.\n */\nprivate void queueNewResult() {\n    Message m = mHandler.obtainMessage(0);\n1.    // 此处就是调用mPrintManager.getPrintServices(PrintManager.ALL_SERVICES);拿到所有安装的打印插件\n    m.obj = mPrintManager.getPrintServices(mSelectionFlags);\n    mHandler.sendMessage(m);\n}\n\n    private class MyHandler extends Handler {\n        /**\n         * Create a new handler on the main thread.\n         */\n        public MyHandler() {\n            super(getContext().getMainLooper());\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (isStarted()) {\n2. 通知loader更新,回调LoadCallbacks.onLoadFinished()\n               deliverResult((List<PrintServiceInfo>) msg.obj);\n            }\n        }\n    }\n```\n\n在回调onPrintServiceChanged时也进行更新\n\n```java\nmListener = new PrintManager.PrintServicesChangeListener() {\n    @Override public void onPrintServicesChanged() {\n        queueNewResult();\n    }\n};\n\nmPrintManager.addPrintServicesChangeListener(mListener, null);\n```\n\n我们可以在onStartLoading()中写我们的逻辑，在started状态下，Loader应该监控数据源的变化，并将新数据发送给客户端，具体来说就是当监控到新数据后，调用Loader.deliverResult()方法，触发LoadCallbacks.onLoadFinished()回调的执行，从而客户端可以从该回调中轻松获取数据。\n\n```java\npublic void onLoadFinished(Loader<List<PrintServiceInfo>> loader,\n        List<PrintServiceInfo> services) {\n                if (services != null) {\n            final int numServices = services.size();\n            for (int i = 0; i < numServices; i++) {\n                if (services.get(i).getComponentName().equals(mComponentName)) {\n                    service = services.get(i);\n                    break;\n                }\n            }\n        }\n    // enable状态是根据是否在mActiveServices中\n    // installedService.setIsEnabled(mActiveServices.containsKey(componentName));\n   1.     mServiceEnabled = service.isEnabled();\n   2. ...//获取当前service的mSettingsIntent和mAddPrintersIntent对应打印插件的settingsActivityName/addPrintersActivityName\n   3.     updateUiForServiceState()\n       \n   3. private void updateUiForServiceState() {\n       // 根据mServiceEnabled控制按钮的开关\n        if (mServiceEnabled) {\n            mSwitchBar.setCheckedInternal(true);\n            mPrintersAdapter.enable();\n        } else {\n            mSwitchBar.setCheckedInternal(false);\n            mPrintersAdapter.disable();\n        }\n        getActivity().invalidateOptionsMenu();\n    }\n    3.1 mPrintersAdapter.enable();\n            public void enable() {\n            getLoaderManager().initLoader(LOADER_ID_PRINTERS_LOADER, null, this);\n        }\n    \n```\n\n在最后调用了PrintAdapter的initLoader方法, 该方法会触发onCreateLoader的回调.PrintAdapter对应的Loader为PrintersLoader类.\n\n```java\n@Override\npublic Loader<List<PrinterInfo>> onCreateLoader(int id, Bundle args) {\n    if (id == LOADER_ID_PRINTERS_LOADER) {\n        return new PrintersLoader(getContext());\n    }\n    return null;\n}\n```\n\nPrintersLoader重写了Loader中的onStartLoading()方法，以下是PrintersLoader在执行到onStartLoading()之后的逻辑，从中我们可以看出PrintLoader如何实现异步加载打印机数据。\n\n在onForceLoad中执行了AsyncTask启动startPrinterDiscovery进行搜索搜索打印插件关联的打印机, 在搜索到打印机后,由callback机制, 回调注册的OnPrintersChangeListener的onPrintersChanged方法, 通过deliverResult触发LoaderCallbacks的onLoadFinished方法, 再通过notifyDataSetChanged方法使得视图更新.\n\n```java\n@Override\nprotected void onStartLoading() {\n    if (DEBUG) {\n        Log.i(LOG_TAG, \"onStartLoading()\");\n    }\n    // The contract is that if we already have a valid,\n    // result the we have to deliver it immediately.\n    if (!mPrinters.isEmpty()) {\n        //触发PrintAdapter的onLoadFinished回调\n    2.    deliverResult(new ArrayList<PrinterInfo>(mPrinters.values()));\n    }\n    // We want to start discovery at this point.\n    1. onForceLoad();\n}\n\n1. protected void onForceLoad() {\n    loadInternal();\n}\n\n        private void loadInternal() {\n            if (mDiscoverySession == null) {\n                PrintManager printManager = (PrintManager) getContext()\n                        .getSystemService(Context.PRINT_SERVICE);\n                //SPRD 742355 main thread block by binder caused anr\n                new AsyncTask<Void, Void, Void>() {\n                    @Override\n                    protected Void doInBackground(Void... params) {\n                        //启动搜索打印机的服务 对应BuiltInPrintService 为 LocalDiscoverySession.\n                        // 这个地方是通过PrintManager-->PrintManagerService-->UserState-->UserState.PrinterDiscoverySessionMediator-->(通过mActiveServices遍历到所有激活的)RemotePrintService-->打印插件的session.\n                        mDiscoverySession = printManager.createPrinterDiscoverySession();\n                        return null;\n                    }\n                    @Override\n                    protected void onPostExecute(Void result) {\n                        // 搜索到打印机后触发的回调\n                        mDiscoverySession.setOnPrintersChangeListener(new OnPrintersChangeListener() {\n                            @Override\n                            public void onPrintersChanged() {\n                               // 触发PrintAdapter onLoadFinished回调\n                                deliverResult(new ArrayList<PrinterInfo>(\n                                    mDiscoverySession.getPrinters()));\n                            }\n                        });\n                        //开始搜索打印插件关联的打印机,也是最终传到打印插件的Session\n                        mDiscoverySession.startPrinterDiscovery(null);\n                    }\n\n                }.execute();\n\n            }\n            \n   2.         public void onLoadFinished(Loader<List<PrinterInfo>> loader,\n                List<PrinterInfo> printers) {\n            synchronized (mLock) {\n                mPrinters.clear();\n                final int printerCount = printers.size();\n                for (int i = 0; i < printerCount; i++) {\n                    PrinterInfo printer = printers.get(i);\n                    //只更新当前插件的\n                    if (printer.getId().getServiceName().equals(mComponentName)) {\n                        mPrinters.add(printer);\n                    }\n                }\n                mFilteredPrinters.clear();\n                mFilteredPrinters.addAll(mPrinters);\n                if (!TextUtils.isEmpty(mLastSearchString)) {\n                    getFilter().filter(mLastSearchString);\n                }\n            }\n       // 触发PrintAdapter的getView方法回调,根据更新的mPrinters列表更新视图.\n            notifyDataSetChanged();\n        }    \n```\n## 5.4. destroyLoader\n\n在由PrintServiceLoader注册的addPrintServicesChangeListener回调流程中,在检测到PrintService change时, 最终触发下面的流程.\n\n```java\n    private void updateUiForServiceState() {\n        if (mServiceEnabled) {\n            mSwitchBar.setCheckedInternal(true);\n            mPrintersAdapter.enable();\n        } else {\n            // 对应该控件绑定的service关闭了\n            mSwitchBar.setCheckedInternal(false);            \n            1. mPrintersAdapter.disable();\n        }\n        getActivity().invalidateOptionsMenu();\n    }\n 1.       public void disable() {\n            getLoaderManager().destroyLoader(LOADER_ID_PRINTERS_LOADER);\n            mPrinters.clear();\n        }\n```\n\nLoaderManager.destroy() -->\n\n`LoaderCallbacks`.onLoaderReset() -->\n\nLoader.reset() -->\n\nPrintLoader.onReset()-->\n\n```java\n//回调PrintAdapter的onLoaderReset, 更新视图,去除显示的打印机.\n@Override\npublic void onLoaderReset(Loader<List<PrinterInfo>> loader) {\n    synchronized (mLock) {\n        mPrinters.clear();\n        mFilteredPrinters.clear();\n        mLastSearchString = null;\n    }\n    notifyDataSetInvalidated();\n}\n// 回调PrintLoader的onReset\n        @Override\n        protected void onReset() {\n            if (DEBUG) {\n                Log.i(LOG_TAG, \"onReset()\");\n            }\n1.          onStopLoading();\n            mPrinters.clear();\n            if (mDiscoverySession != null) {\n 2.             mDiscoverySession.destroy();\n                mDiscoverySession = null;\n            }\n        }\n1.      protected void onStopLoading() {\n            if (DEBUG) {\n                Log.i(LOG_TAG, \"onStopLoading()\");\n            }\n            onCancelLoad();\n        }\n        protected boolean onCancelLoad() {\n            if (DEBUG) {\n                Log.i(LOG_TAG, \"onCancelLoad()\");\n            }\n            return cancelInternal();\n        }\n        private boolean cancelInternal() {\n            if (mDiscoverySession != null\n                    && mDiscoverySession.isPrinterDiscoveryStarted()) {\n                // 停止搜索, 注意这个地方是停止所有active 打印service绑定session的搜索.\n1.1                mDiscoverySession.stopPrinterDiscovery();\n                return true;\n            }\n            return false;\n        }\n```\n\n\n","tags":["Android","AndroidN","PrintManagerService"],"categories":["PrintManagerService"]},{"title":"通过adb install 安装apk","url":"/2017/08/02/其他调研/通过adb install 安装apk/","content":"\n# 1. ADB处理的流程\n\n通过adb install命令安装指定apk时，会先将该apk上传到/data/local/tmp或者/sdcard/tmp目录下，然后调用pm脚本，通过Binder通信，调用PackageManagerService的接口安装apk。\n通过PackageInstaller.apk安装指定apk时，最终也会调用PackageManagerService的接口实现apk的安装。\n以上两种情况最终都会发送INIT-COPY消息，由PackageManagerService启动过程中初始化的mHandler的handleMessage方法处理该消息，开始apk的安装。\n\n\n\n## 1.1. adb 拷贝流程分析\n\nadb 安装apk支持的命令\n\n```shell\n    \"  adb install [-lrtsdg] <file>\\n\"\n    \"                               - push this package file to the device and install it\\n\"\n    \"                                 (-l: forward lock application)\\n\"    // foward_lock\n    \"                                 (-r: replace existing application)\\n\"   // upgrade apk\n    \"                                 (-t: allow test packages)\\n\"\n    \"                                 (-s: install application on sdcard)\\n\"        // apptosd\n    \"                                 (-d: allow version code downgrade (debuggable packages only))\\n\"  // downgrade\n    \"                                 (-g: grant all runtime permissions)\\n\"   // 赋予所有的运行时权限\n```\n\n\n```cpp\nstatic int install_app_legacy(TransportType transport, const char* serial, int argc, const char** argv) {\n  static const char *const DATA_DEST = \"/data/local/tmp/%s\";\n  static const char *const SD_DEST = \"/sdcard/tmp/%s\";\n  const char* where = DATA_DEST;\n  int i;\n  struct stat sb;\n\n  for (i = 1; i < argc; i++) {\n      if (!strcmp(argv[i], \"-s\")) {\n          where = SD_DEST;\n      }\n  }\n  ...\n  int result = -1;\n  std::vector<const char*> apk_file = {argv[last_apk]};\n  std::string apk_dest = android::base::StringPrintf(\n      where, adb_basename(argv[last_apk]).c_str());\n  // adb 将pc上的apk包拷贝到手机上的 DATA_DEST/<filename>.apk  或 SD_DEST/<filename>.apk\n  if (!do_sync_push(apk_file, apk_dest.c_str())) goto cleanup_apk;\n  argv[last_apk] = apk_dest.c_str(); /* destination name, not source location */\n  // 调用pm cmd 进行处理\n  result = pm_command(transport, serial, argc, argv);\n  cleanup_apk:\n  // 清理拷贝到手机目录上的apk\n  delete_file(transport, serial, apk_dest);\n  return result;\n}\n```\n\n发送shell消息到终端, 使用pm install  <apk path> 命令安装对应的apk.期间,如果出现adb connect连接问题,则会进行重连.如果能够发送给终端执行对应的shell命令.等待执行的结果,并通过adb打印到电脑的控制台上.\n\n## 1.2. pm执行安装流程\n\n生成`system/bin/pm` 可执行文件\n\n传入参数.执行 runInstall 函数\n\n在runInstall函数中将shell传过来的pm命令进行解析,并添加到SessionParams的相应flag中\n\n```java\nprivate int runInstall() throws RemoteException {\n    // 对参数进行转换, 初始化SessionParams\n    final InstallParams params = makeInstallParams();\n    final String inPath = nextArg();\n    // 创建 PackageInstallerSession 对象,并加到mSessions 以 sessionId加到集合中,同时更新/data/system/install_sessions.xml文件\n    final int sessionId = doCreateSession(params.sessionParams,\n                                        params.installerPackageName, params.userId);\n    try {\n      if (inPath == null && params.sessionParams.sizeBytes == -1) {\n        System.err.println(\"Error: must either specify a package size or an APK file\");\n        return 1;\n      }\n      // 从之前拷贝到的地址中  DATA_DEST|SD_DEST 拷贝到 /data/app/vml<sessionid>.tmp下|sd卡相关的mnt/secure/asec?? 下的base.apk中\n      if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, \"base.apk\",\n                         false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) {\n        return 1;\n      }\n      // 提交sessionId 对应的 PackageInstaller.Session对象,通过session.commit层层传递,最终通过PKMS的installStage函数对apk进行安装\n      if (doCommitSession(sessionId, false /*logSuccess*/)\n          != PackageInstaller.STATUS_SUCCESS) {\n        return 1;\n      }\n      System.out.println(\"Success\");\n      return 0;\n    } finally {\n      try {\n        mInstaller.abandonSession(sessionId);\n      } catch (Exception ignore) {\n      }\n    }\n}\n\n  private InstallParams makeInstallParams() {\n        //初始化SessionParams和InstallParams,赋值相应参数\n        final SessionParams sessionParams = new SessionParams(SessionParams.MODE_FULL_INSTALL);\n        final InstallParams params = new InstallParams();\n        params.sessionParams = sessionParams;\n        String opt;\n        while ((opt = nextOption()) != null) {\n            switch (opt) {\n                case \"-l\":\n                    sessionParams.installFlags |= PackageManager.INSTALL_FORWARD_LOCK;\n                    break;\n                case \"-r\":\n                    sessionParams.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;\n                    break;\n                case \"-s\":\n                    sessionParams.installFlags |= PackageManager.INSTALL_EXTERNAL;\n                    break;\n                case \"-f\":\n                    sessionParams.installFlags |= PackageManager.INSTALL_INTERNAL;\n                    break;\n                case \"-g\":\n                    sessionParams.installFlags |= PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS;\n                    break;\n                ...\n                default:\n                    throw new IllegalArgumentException(\"Unknown option \" + opt);\n            }\n        }\n        return params;\n    }\n```\n/data/system/install_sessions.xml\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<sessions>\n<session sessionId=\"667330637\" userId=\"0\" installerUid=\"0\" createdMillis=\"1325393932643\" sessionStageDir=\"/data/app/vmdl667330637.tmp\" prepared=\"true\" sealed=\"true\" mode=\"1\" installFlags=\"112\" installLocation=\"1\" sizeBytes=\"-1\" originatingUid=\"-1\" />\n</sessions>\n```\n\n下一步主要涉及到doCommitSession的处理\n\n在PackageInstallerSession的commitLocked函数中,最终调到了PKMS的installStage方法进行应用的安装\n\n<span id=\"stage\">\n\n```java\nfinal OriginInfo origin;\nif (stagedDir != null) {\n  origin = OriginInfo.fromStagedFile(stagedDir);\n} else {\n  origin = OriginInfo.fromStagedContainer(stagedCid);\n}\nfinal Message msg = mHandler.obtainMessage(INIT_COPY);\nfinal InstallParams params = new InstallParams(origin, null, observer,\n        sessionParams.installFlags, installerPackageName /*安装器*/, sessionParams.volumeUuid,\n        verificationInfo, user, sessionParams.abiOverride,\n        sessionParams.grantedRuntimePermissions, certificates);\nmHandler.sendMessage(msg);\n```\n\n# 2. 安装流程\n\n## 2.1. 从INIT_COPY开始\n\n首先，获取消息的保存的InstallParams对，然后判断当前是否绑定到DefaultContainerService服务,\n\n没有绑定时，调用mHandler.connectToService方法绑定：绑定失败，直接退出；成功，将安装请求信息添加到mHandler.mPendingInstalls（存储等待安装的apk请求信息）中，稍候会处理第一个安装请求。初次绑定并成功后，会调用PackageManageService.mDefContainerConn的回调方法onServiceConnected，获取服务代理对象，并发送一个MCS-BOUND消息\n\n```java\ncase INIT_COPY: {\n    HandlerParams params = (HandlerParams) msg.obj;\n    int idx = mPendingInstalls.size();\n    if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params);\n    // If a bind was already initiated we dont really\n    // need to do anything. The pending install\n    // will be processed later on.\n    if (!mBound) {\n        Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"bindingMCS\",\n                System.identityHashCode(mHandler));\n        // If this is the only one pending we might\n        // have to bind to the service again.\n        if (!connectToService()) {\n            Slog.e(TAG, \"Failed to bind to media container service\");\n            params.serviceError();\n            return;\n        } else {\n            // Once we bind to the service, the first\n            // pending request will be processed.\n            mPendingInstalls.add(idx, params);\n        }\n    }\n    else {\n      mPendingInstalls.add(idx, params);\n      // Already bound to the service. Just make\n      // sure we trigger off processing the first request.\n      if (idx == 0) {\n        // 如果是第一个绑定的,需要发送MCS_BOUND消息\n        mHandler.sendEmptyMessage(MCS_BOUND消息);\n      }\n    }\n  }\n\n  \n  private boolean connectToService() {\n      Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);\n      Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n      // 绑定 DefaultContainerService服务\n      if (mContext.bindServiceAsUser(service, mDefContainerConn,\n                                     Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        mBound = true;\n        return true;\n      }\n      return false;\n  }\n\n  final private DefaultContainerConnection mDefContainerConn =\n    new DefaultContainerConnection();\n  class DefaultContainerConnection implements ServiceConnection {\n    public void onServiceConnected(ComponentName name, IBinder service) {\n      IMediaContainerService imcs =\n        IMediaContainerService.Stub.asInterface(service);\n       // 绑定成功,发送MCS_BOUND消息\n      mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs));\n    }\n  }\n```\n\n>   只有在没有绑定进行绑定时或已绑定且当前是第一个安装请求时才会发送MCS_BOUND空消息，接下来开始处理该消息。\n\n## 2.2. 处理MCS_BOUND消息\n\n首先要保存服务代理对象到PackageManagerService.mContainerService中。\n\n>   如果是空消息，说明已经绑定服务，代理对象已保存,即msg.obj=null的情况\n\n判断当前服务代理对象是否为null：如果为null，说明没有绑定服务，处理出错信息，清空所有安装请求；\n\n```java\ncase MCS_BOUND: {\n    if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\");\n    if (msg.obj != null) {\n        mContainerService = (IMediaContainerService) msg.obj;\n        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"bindingMCS\",\n                System.identityHashCode(mHandler));\n    }\n    if (mContainerService == null) {\n        if (!mBound) {\n            // Something seriously wrong since we are not bound and we are not\n            // waiting for connection. Bail out.\n            Slog.e(TAG, \"Cannot bind to media container service\");\n            for (HandlerParams params : mPendingInstalls) {\n                // Indicate service bind error\n                ...\n            }\n            // 清空所有安装请求\n            mPendingInstalls.clear();\n        } else {\n            Slog.w(TAG, \"Waiting to connect to media container service\");\n        }\n    } \n```\n\n已绑定，处理第一个安装请求\n\n```java\nelse if (mPendingInstalls.size() > 0) {\n    HandlerParams params = mPendingInstalls.get(0);\n    if (params != null) {\n        // 调用InstallParams.startCopy方法进行复制安装，复制安装成功后，继续以下两步；\n        if (params.startCopy()) {\n            // We are done...  look for more work or to\n            // go idle.\n            if (DEBUG_SD_INSTALL) Log.i(TAG,\n                    \"Checking for more work or unbind...\");\n            // Delete pending install\n            // 从mHandler.mPendingInstalls中移除该安装请求信息；\n            if (mPendingInstalls.size() > 0) {\n                mPendingInstalls.remove(0);\n            }\n          // 判断是否还有安装请求：没有了，如果当前绑定服务，移除前一个安装请求的MCS_UNBOUND消息，然后重新发送一个10s的延时消息MCS_UNBOUND，\n          // 用于解除服务绑定；如果还有安装请求，发送一个空的MCS_BOUND消息，用于处理下一个安装请求。\n            if (mPendingInstalls.size() == 0) {\n                if (mBound) {\n                    if (DEBUG_SD_INSTALL) Log.i(TAG,\n                            \"Posting delayed MCS_UNBIND\");\n                    removeMessages(MCS_UNBIND);\n                    Message ubmsg = obtainMessage(MCS_UNBIND);\n                    // Unbind after a little delay, to avoid\n                    // continual thrashing.\n                    sendMessageDelayed(ubmsg, 10000);\n                }\n            } else {\n                // There are more pending requests in queue.\n                // Just post MCS_BOUND message to trigger processing\n                // of next pending install.\n                if (DEBUG_SD_INSTALL) Log.i(TAG,\n                        \"Posting MCS_BOUND for next work\");\n                mHandler.sendEmptyMessage(MCS_BOUND);\n            }\n        }\n    }\n```\n\n>   1 只有当安装请求队列处理到最后，后面没有安装请求时，才会发送MCS_UNBOUND消息；\n>\n>   2.当来了新的安装请求，而消息队列中还存在前一个安装请求的MCS_UNBOUND消息时，可能存在一种情况，就是在初始化安装时是存在绑定服务的，但是在安装过程中，由于前一个请求的MCS_UNBOUND消息，导致服务解绑，出现安装错误\n\n判断每个apk尝试安装的次数，每个apk最多尝试安装4次，均失败，发送MCS_GIVE_UP消息，返回false；否则调用InstallParams.handleStartCopy方法进行复制安装，复制安装成功返回true，若失败，抛出并处理RemoteException，发送MCS_RECONNECTION消息，重新尝试安装。最后调用InstallParams.handleReturnCode方法处理返回结果。\n\n```java\nfinal boolean startCopy() {\n    boolean res;\n    try {\n\n        if (++mRetries > MAX_RETRIES) {\n            Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\");\n            mHandler.sendEmptyMessage(MCS_GIVE_UP);\n            handleServiceError();\n            return false;\n        } else {\n            // 进行复制安装\n            handleStartCopy();\n            res = true;\n        }\n    } catch (RemoteException e) {\n        if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\");\n        mHandler.sendEmptyMessage(MCS_RECONNECT);\n        res = false;\n    }\n    handleReturnCode();\n    return res;\n}\n```\n\n## 2.3. 调用InstallParams.handleStartCopy方法复制apk\n\n该方法主要根据安装位置（默认installFlags既没指定onSd，也没指定onInt），复制资源文件到内部/外部存储中，或者先验证包然后在CHECK_PENDING_VERIFICATION消息处理分支实现复制和安装。\n\n```java\n// 已经缓存了文件, 根据stage的类型重新确定安装的标志\nif (origin.staged) {\n    if (origin.file != null) {\n        installFlags |= PackageManager.INSTALL_INTERNAL;\n        installFlags &= ~PackageManager.INSTALL_EXTERNAL;\n    } else if (origin.cid != null) {\n        installFlags |= PackageManager.INSTALL_EXTERNAL;\n        installFlags &= ~PackageManager.INSTALL_INTERNAL;\n    } else {\n        throw new IllegalStateException(\"Invalid stage location\");\n    }\n}\n```\n\n### 2.3.1. 计算推荐安装位置\n\n如果安装位置标志既设置了内部标志又设置了外部标志，记录返回结果INSTALL_FAILED_INVALID_INSTALL_LOCATION到InstallParams.mRet中；\n\n否则，根据指定安装位置（内部存储/外部存储），调用mContainerService.getMinimalPackageInfo方法，解析AndroidManifest.xml文按，获取包名、installLocation、package-verifier等信息，并计算存储区域的推荐安装位置，将这些信息存储到PackageInfoLite结构中：\n\n```java\nelse {\n   // 计算推荐安装位置\n    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags,\n            packageAbiOverride);\n    // 没有缓存文件的情况,需要计算缓存文件释放后空间是否足够\n    if (!origin.staged && pkgLite.recommendedInstallLocation\n            == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {\n        // TODO: focus freeing disk space on the target device\n        final StorageManager storage = StorageManager.from(mContext);\n        final long lowThreshold = storage.getStorageLowBytes(\n                Environment.getDataDirectory());\n\n        final long sizeBytes = mContainerService.calculateInstalledSize(\n                origin.resolvedPath, isForwardLocked(), packageAbiOverride);\n\n        try {\n          \t// 清空/data/user/<user_id>/\n            // /data/user_de/<user_id>\n            // /data/media/<user_id>/Android/data/\n            // cache code_cache 下的文件,直到删除到满足要求为止\n            mInstaller.freeCache(null, sizeBytes + lowThreshold);\n            // 重新计算空间是否足够\n            pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,\n                    installFlags, packageAbiOverride);\n        } catch (InstallerException e) {\n            Slog.w(TAG, \"Failed to free cache\", e);\n        }\n\n        /*\n         * The cache free must have deleted the file we\n         * downloaded to install.\n         *\n         * TODO: fix the \"freeCache\" call to not delete\n         *       the file we care about.\n         */\n        if (pkgLite.recommendedInstallLocation\n                == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {\n            pkgLite.recommendedInstallLocation\n                = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;\n        }\n    }\n}\n```\n\n没有缓存文件时,因为要拷贝缓存文件到/data/app/***下,所以需要计算所需的空间大小,算出来后,通过installd的freecache函数清除缓存文件来释放空间.释放完之后重新计算安装位置是否满足空间要求.\n\n此处涉及到判断空间是否满足要求的判断标准,再此重新说明一下:\n\n### 2.3.2. 空间不足的判断标准\n\n对于内部存储,是通过fitsOnInternal函数进行判定的, 判定标准时 可用空间大小 >= sizeBytes + 默认1M\n\n对于外部存储,是通过fitsOnExternal函数进行判定, 首先判断外部存储是否挂载,再进行判断  可用空间大小 >= sizeBytes + 默认1M\n\n```java\n// sizeBytes是统计的apk的大小,如果forwardLock为true(code和resource分离?)需要计算解压后的大小.同时需要加上其关联的native库的大小\nsizeBytes = PackageHelper.calculateInstalledSize(pkg, isForwardLocked, abiOverride);\npublic static boolean fitsOnInternal(Context context, long sizeBytes) {\n    final StorageManager storage = context.getSystemService(StorageManager.class);\n    final File target = Environment.getDataDirectory();\n    // 即为  path.getUsableSpace() >=  getStorageFullBytes(path) + sizeBytes\n    return (sizeBytes <= storage.getStorageBytesUntilLow(target));\n}\npublic long getStorageBytesUntilLow(File path) {\n    return path.getUsableSpace() - getStorageFullBytes(path);\n}\npublic long getStorageFullBytes(File path) {\n  // 此处默认定为1M大小\n  return Settings.Global.getLong(mResolver, Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,\n                                 DEFAULT_FULL_THRESHOLD_BYTES);\n}\n```\n\n可用大小可以通过df命令查看\n\n文件系统可以通过指定uid\\gid保护对空间进行保护,特权进程访问到的可使用空间比较多,而普通进程看到的可用空间比较少,用以对存储进行保护\n\n#### 2.3.2.1. 文件系统层对存储空间做的保护\n\nboard 打开  BOARD_RESERVED_SPACE_ON 开关时\n\n​       data分区  在init checkfs时会预留空间 10M大小(手机上block大小一般为512, 2560*512B=10M)，预留给特定的uid gid的进程使用\n\n​       tune2fs -r 2560  /dev/block/platform/../userdata\n\n​\t使用tune2fs -r 指定   固定值count （指定预留的  block count）\n\n也可以通过   tune2fs -m  <percent>   指定预留block 占总 block 的百分比\n\n查看文件系统的超级块信息：\ndumpe2fs -h userdata.img 或  /dev/block/../userdata\n\n-   Reserved block group size：（`resv_blocks`）  文件系统  free_block  该项必须配置，该项为系统预留值。一般通过make_ext4fs 制作img时配置。\n-   Reserved block count：   （ `ext4_r_blocks_count` ）       该项为预留给 特殊进程使用的预留空间。\n\n特权进程调用stat 看到的及可使用的可用空间为  avail = total - resv_blocks\n普通进程调用stat看到的及可使用的可用空间为  avail  = total - resv_blocks - ext4_r_blocks_count\n\nresv_blocks 是 kernel 中进行指定:\n```c\nresv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);\n```\n取的分区的  2% 或 16M的最小值\n\n### 2.3.3. 根据推荐安装位置处理返回结果\n\n当安装位置不冲突时，根据根据推荐安装位置返回值指定相应的返回结果。\n\n存在一种情况，会调用installLocationPolicy进一步处理推荐安装位置，主要是为了防止系统级应用安装到sd卡上等操作，根据推荐安装位置更新安装位置标志\n\n正常情况下,对于安装在内部/外部存储上的应用,一般返回\n\nPackageHelper.RECOMMEND_INSTALL_INTERNAL | PackageHelper.RECOMMEND_INSTALL_EXTERNAL\n\ninstallLocationPolicy函数对应用的升级\\降级情况进行了判断,如果是升级的情况下,升级的应用是system app,是不允许升级后安装到sd卡上的.\n\n如果没有携带-r参数,且应用已经存在,即在PKMS.mPackages中能够查到,则返回应用已存在,跳出安装流程\n\n### 2.3.4. 根据安装位置创建安装参数InstallArgs\n\n根据InstallParams.mInstallFlags安装位置标志，调用createInstallArgs方法创建InstallArgs：\n\n-   对于安装在sd卡（内和外sd卡）和FORWARD-LOCKED的apk，创建AsecInstallArgs类型\n-   对于安装在手机内部存储区域的，创建FileInstallArgs类型。并存储到InstallParams.mArgs中。\n-   移动应用的情况下(从内部存储移动到外部存储或反过来的情况), 创建MoveInstallArgs.\n\n```java\nfinal InstallArgs args = createInstallArgs(this);\nmArgs = args;\nprivate InstallArgs createInstallArgs(InstallParams params) {\n  if (params.move != null) {\n    return new MoveInstallArgs(params);\n  } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {\n    return new AsecInstallArgs(params);\n  } else {\n    return new FileInstallArgs(params);\n  }\n}\n```\n\n### 2.3.5. 验证包(GMS情况下)\n\n在PMS启动阶段最后，如果指定了验证包，可以用它来验证后续需要验证的apk。该包被授予android.Manifest.permission.`PACKAGE_VERIFICATION_AGENT`权限，它包含能处理Action为`ACTION_PACKAGE_NEEDS_VERIFICATION`的Intent的组件。将该包名存储到PackageManagerService.`mRequiredVerifierPackage`中，非GMS版本中一般不会指定该验证包。\n\n[跳转](https://cototem.github.io/2017/08/02/pkms1/#bianliang)\n\n当所需要安装的apk需要验证时，将验证编号和验证状态存入PackageManagerService.mPendingVerification中。\n\n构造验证包的Intent对象\n\n传入验证包的地址, origin对象来自于[installStage](#stage)\n\n```java\nfinal Intent verification = new Intent(\n        Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);\nverification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n// 传入验证包的地址, origin对象来自于installStage\nverification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)),\n        PACKAGE_MIME_TYPE);\nverification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n// Query all live verifiers based on current user state\nfinal List<ResolveInfo> receivers = queryIntentReceiversInternal(verification,\n                                                                 PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier());\n```\n\n根据该安装包解析到的验证包和receivers，查找匹配该安装包的用来验证的组件信息列表，并向这些组件发送广播；\n\n```java\nif (sufficientVerifiers != null) {\n    final int N = sufficientVerifiers.size();\n    if (N == 0) {\n        Slog.i(TAG, \"Additional verifiers required, but none installed.\");\n        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;\n    } else {\n        for (int i = 0; i < N; i++) {\n            final ComponentName verifierComponent = sufficientVerifiers.get(i);\n            final Intent sufficientIntent = new Intent(verification);\n            sufficientIntent.setComponent(verifierComponent);\n            mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);\n        }\n    }\n}\n```\n\n然后根据系统指定验证包和receivers查找验证包中匹配的组件。在返回结果为成功安装的前提下，向该组件发送有序广播，该广播也包含接收目标组件广播的广播接收器，继而发送一个CHECK_PENDING_VERIFICATION的延时handler消息(默认为10s的延时消息)。\n\n```java\nfinal ComponentName requiredVerifierComponent = matchComponentForVerifier(\n        mRequiredVerifierPackage, receivers);\nif (ret == PackageManager.INSTALL_SUCCEEDED\n        && mRequiredVerifierPackage != null) {\n    Trace.asyncTraceBegin(\n            TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId);\n    /*\n     * Send the intent to the required verification agent,\n     * but only start the verification timeout after the\n     * target BroadcastReceivers have run.\n     */\n    verification.setComponent(requiredVerifierComponent);\n    mContext.sendOrderedBroadcastAsUser(verification, verifierUser,\n            android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,\n            new BroadcastReceiver() {\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final Message msg = mHandler\n                            .obtainMessage(CHECK_PENDING_VERIFICATION);\n                    msg.arg1 = verificationId;\n                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());\n                }\n            }, null, 0, null, null);\n\n    /*\n     * We don't want the copy to proceed until verification\n     * succeeds, so null out this field.\n     */\n     // 验证成功后,才进行拷贝安装的流程\n    mArgs = null;\n}\n```\n\n然后将InstallParams.mArgs置为null，保证在验证完成之前不进行apk的复制。在CHECK_PENDING_VERIFICATION消息处理过程中，会发送相关广播，被PMS中定义的验证包接收，然后进行apk的复制和安装，最后会发送一个MCS_UNBOUND消息。\n\n### 2.3.6. 复制apk和lib文件\n\n```java\nret = args.copyApk(mContainerService, true);\n```\n\n根据安装参数args的具体类型，决定执行FIleInstallArgs还是AsecInstallArgs的copyApk方法实现apk复制。\n\n### 2.3.7. FileInstallArgs.copyApk方法\n\n-   文件已经存在即base.apk已经拷贝完成的情况下,直接跳过拷贝流程\n\n```java\nif (origin.staged) {\n    if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\");\n    codeFile = origin.file;\n    resourceFile = origin.file;\n    return PackageManager.INSTALL_SUCCEEDED;\n}\n```\n\n\n\n-   origin.staged为空时,创建临时目录,执行文件拷贝\n\n1.  复制apk文件：调用DefaultContainerService的copyPacakge方法，先对apk文件进行解析，然后将要安装的apk文件拷贝到/data/app/vmdl<随机整数>.tmp/base.apk中；如果包含分段的apk，将各个分段apk拷贝到相应的/data/app/vmdl<随机整数>.tmp/split_<splitName[i]>.apk中；\n2.  复制本地库文件：调用NativeLibrariesHelper.copyNativeBinariesWithOverride方法，将apk中的lib文件拷贝到/data/app/ vmdl<随机整数>.tmp/lib/,,,中；\n\n最终将结果返回，保存到InstallParams.mRet中，用于handleReturnCode方法对返回结果进行处理。\n\n```java\n// 创建临时目录   \"vmdl\" + sessionId + \".tmp\"\nfinal File tempDir =\n        mInstallerService.allocateStageDirLegacy(volumeUuid, isEphemeral);\ncodeFile = tempDir;\nresourceFile = tempDir;\n\nfinal IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {\n  @Override\n  public ParcelFileDescriptor open(String name, int mode) throws RemoteException {\n    try {\n      final File file = new File(codeFile, name);\n      final FileDescriptor fd = Os.open(file.getAbsolutePath(),\n                                        O_RDWR | O_CREAT, 0644);\n      Os.chmod(file.getAbsolutePath(), 0644);\n      return new ParcelFileDescriptor(fd);\n    } catch (ErrnoException e) {\n      throw new RemoteException(\"Failed to open: \" + e.getMessage());\n    }\n  }\n};\n// 拷贝到base.apk 如果包含split app ,同时需要拷贝split app\nret = imcs.copyPackage(origin.file.getAbsolutePath(), target);\n...\nfinal File libraryRoot = new File(codeFile, LIB_DIR_NAME);\nNativeLibraryHelper.Handle handle = null;\ntry {\n  handle = NativeLibraryHelper.Handle.create(codeFile);\n  // 根据架构集,拷贝对应的native lib\n  // 如拷贝到  **/lib/arm目录下\n  /*\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"armeabi\", \"arm\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"armeabi-v7a\", \"arm\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"mips\", \"mips\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"mips64\", \"mips64\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"x86\", \"x86\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"x86_64\", \"x86_64\");\n        ABI_TO_INSTRUCTION_SET_MAP.put(\"arm64-v8a\", \"arm64\");\n   */\n  ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,\n                                                           abiOverride);\n}\n\nprivate void copyFile(String sourcePath, IParcelFileDescriptorFactory target, String targetName)\n  throws IOException, RemoteException {\n  Slog.d(TAG, \"Copying \" + sourcePath + \" to \" + targetName);\n  InputStream in = null;\n  OutputStream out = null;\n  try {\n    in = new FileInputStream(sourcePath);\n    // 前面创建了一个IParcelFileDescriptorFactory类型\n    // 通过open函数返回一个ParcelFileDescriptor类型，用于跨进程的访问临时目录下的文件，实现apk文件复制；\n    out = new ParcelFileDescriptor.AutoCloseOutputStream(\n      target.open(targetName, ParcelFileDescriptor.MODE_READ_WRITE));\n    Streams.copy(in, out);\n  } finally {\n    IoUtils.closeQuietly(out);\n    IoUtils.closeQuietly(in);\n  }\n}\n```\n\n### 2.3.8. AsecInstallArgs.copyApk方法\n\n当apk安装到sd卡（注意是安装在sd卡，并不是apk文件所在的位置），或者apk为FOWARD_LOCKED类型时调用该类的方法进行apk复制。\n\n首先，判断是否已经复制过，如果已复制，借助MountService获取复制目录信息，更新代码/资源/库路径，跳过后续复制流程：\n\n```java\nif (origin.staged && origin.cid != null) {\n    if (DEBUG_INSTALL) Slog.d(TAG, origin.cid + \" already staged; skipping copy\");\n    cid = origin.cid;\n    setMountPath(PackageHelper.getSdDir(cid));\n    return PackageManager.INSTALL_SUCCEEDED;\n}\n```\n\n如果没复制，开始复制流程，复制流程与安装在内部流程一样，主要区别在于临时目录的路径不同（首次会先在手机中创建/mnt目录，/mnt/secure/ smdl<随机整数>.tmp存放复制的apk和lib，/mnt/secure/asec存放包名-num.asec），复制apk和库文件成功后，更新代码/资源/库路径信息（将smdl<随机整数>.tmp重命名为包名-num）。\n到此，不管安装在外部还是内部存储区域的apk，复制操作完成，接下来根据复制过程的返回结果InstallParams.mRet以及InstallParams.mArgs调用InstallParams.handleReturnCode方法进行处理，实现apk的安装。\n\n### 2.3.9. InstallParams.handleReturnCode安装apk\n\n在startCopy函数中,当handleStartCopy成功执行完毕后,执行handleReturnCode函数进行apk的安装.\n\n首先，判断InstallParams.mArgs：若为null，说明MCS不可用/进行的是包验证，不进行安装操作；否则，调用InstallParams.handleReturnCode方法进行安装：\n\n<span id=\"processPendingInstall\">\n\n```java\nvoid handleReturnCode() {\n    if (mArgs != null) {\n        processPendingInstall(mArgs, mRet);\n    }\n}\n```\n\n由于apk的安装是一个耗时操作，因此在processPendingInstall方法中，将安装放到消息队列中，然后在分发消息时，作为消息的回调方法，执行该Runnable，在新的线程中进行安装：\n\n```java\nmHandler.post(new Runnable() {\n    public void run() {\n        mHandler.removeCallbacks(this);\n         // Result object to be returned\n        PackageInstalledInfo res = new PackageInstalledInfo();\n        res.setReturnCode(currentStatus);\n        res.uid = -1;\n        res.pkg = null;\n        res.removedInfo = null;\n        if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {\n            args.doPreInstall(res.returnCode);\n            synchronized (mInstallLock) {\n                installPackageTracedLI(args, res);\n            }\n            args.doPostInstall(res.returnCode, res.uid);\n        }\n      ...\n    }\n}\n```\n\n首先，创建一个PackageInstalledInfo res结构，存储安装过程中的结果信息，当成功完成复制，进行安装，其中args.doPreInstall和args.doPostInstall方法只是判定当返回码不是PackageManagerINSTALL_SUCCEEDED时删除代码/资源/本地库文件，在正常安装时二者基本不做操作。真正的安装操作是在PackageManagerService.installPackageLI中完成的.\n\n### 2.3.10. installPackageLI函数执行应用的安装\n\n以安装在内部存储为例,跟一下实际安装的流程\n\n#### 2.3.10.1. installPackageLI  安装流程图\n\n```puml\n@startuml\nPKMS-> PKMS :installPackageTracedLI\nPKMS-> PKMS : installPackageLI(args, res)\nPKMS -> PackageParser: new PackageParser()\nPKMS -> PackageParser: setSeparateProcesses(mSeparateProcesses)\nPKMS -> PackageParser: setDisplayMetrics(mMetrics)\nPKMS -> PackageParser: PackageParser.Package pkg = parsePackage(tmpPackageFile, parseFlags)\nopt args.certificates\nPKMS -> PackageParser: populateCertificates(pkg, args.certificates)\nelse\nPKMS -> PackageParser: collectCertificates(pkg, parseFlags)\nend\nPKMS->PKMS : derivePackageAbi(pkg, new File(pkg.codePath), abiOverride , extract libs);  \nPKMS-> PKMS : updateSharedLibrariesLPw(pkg, null)\nPKMS -> PackageDexOptimizer : performDexOpt(pkg, pkg.usesLibraryFiles, REASON_INSTALL);\nPKMS -> FileInstallArgs : doRename(res.returnCode, pkg, oldCodePath)\nPKMS->PKMS: startIntentFilterVerifications(userid, replace, pkg);\nPKMS->PKMS: freezePackageForInstall(pkgName, installFlags, reason:\"installPackageLI\"));\nopt replace\nPKMS->PKMS:replacePackageLIF(pkg, parseFlags, scanFlags| SCAN_REPLACING, ...)\nelse\nPKMS-> PKMS: installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, ...)\nPKMS -> PKMS: scanPackageTracedLI(pkg, parseFlags, scanFlags,...)\nPKMS ->PKMS: PackageParser.Package scannedPkg = scanPackageLI(childPkg, policyFlags, scanFlags..)\nPKMS ->PKMS: scanPackageDirtyLI(pkg, policyFlags, scanFlags...)\nPKMS -> PKMS: return scannedPkg\nPKMS -> PKMS: updateSettingsLI(newPackage, installerPackageName)\nPKMS -> PKMS: prepareAppDataAfterInstallLIF(newPackage)\nend\nPKMS->PackageSettingBase: res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds()\n@enduml\n```\n\n分解下安装流程,分成10个步骤:\n\n#### 2.3.10.2. 调用parsePackage方法解析AndroidManifest.xml文件\n\n首先调用PackageParser.parsePackage方法解析AndroidManifest.xml文件，将解析结果存入Package pkg中，这部分内容在[扫描安装过程中,跳转此处](https://cototem.github.io/2017/08/02/pkms2/#parsepackage函数)介绍过，此处略去。解析失败，结束安装，在res中存储返回码和返回信息，输出log。\n\n#### 2.3.10.3. 存入abiOverride，TEST_ONLY\n\n存入abiOverride，TEST_ONLY,  验证该APK是否只是用于测试，如果解析时该包只允许测试，而安装标志不允许测试，结束安装，在res中存储返回码和返回信息，输出log。\n\n#### 2.3.10.4. 证书验证\n\n如果安装参数中携带的certificates(install session中已经处理了签名)不为空,则执行populateCertificates方法,直接赋值签名\n\n>   Populates the correct packages fields with the given certificates.This is useful when we've already processed the certificates [such as during package installation through an installer session]\n\n```java\npkg.mCertificates = certificates;\ntry {\n    pkg.mSignatures = convertToSignatures(certificates);\n} \npkg.mSigningKeys = new ArraySet<>(certificates.length);\nfor (int i = 0; i < certificates.length; i++) {\n    Certificate[] signerCerts = certificates[i];\n    Certificate signerCert = signerCerts[0];\n    pkg.mSigningKeys.add(signerCert.getPublicKey());\n}\n```\n\n如果安装参数中没有携带签名,或者签名的过程中在 convertToSignatures 函数中处理出错,则执行**collectCertificates**方法从Apk中收集签名.\n该方法进行证书验证和ManifestDigest验证（验证AndroidManifest.xml，存入pkg.manifestDigest）, 验证失败，结束安装，在res中存储返回码和返回信息，输出log. 系统包只校验AndroidManifest.xml文件,而其他包要校验所有文件.\n\n```java\ncollectCertificatesInternal(pkg, parseFlags);\ncollectCertificates(pkg, new File(pkg.baseCodePath), parseFlags);\n```\n\n证书验证部分在Android7.0 上新加了V2签名校验的方案,详细资料可参考[这里](http://www.10tiao.com/html/223/201704/2651232457/1.html),以及[官方资料](https://source.android.com/security/apksigning/v2.html)\n\n![签名校验流程图](/images/qianming.png)\n\n##### 2.3.10.4.1. V2签名认证\n\n```java\ntry {\n    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"verifyV2\");\n    // 所以是使用  ApkSignatureSchemeV2Verifier 的verify函数进行V2签名校验的\n    allSignersCerts = ApkSignatureSchemeV2Verifier.verify(apkPath);\n    signatures = convertToSignatures(allSignersCerts);\n    // APK verified using APK Signature Scheme v2.\n    // V2 签名验证通过,此处将verified标志位设置为true,\n    verified = true;\n} catch (ApkSignatureSchemeV2Verifier.SignatureNotFoundException e) {\n    // No APK Signature Scheme v2 signature found\n    // 没有使用V2签名时, 忽略后续的步骤\n} catch (Exception e) {\n    // APK Signature Scheme v2 signature was found but did not verify\n    // V2签名校验失败,则抛出异常\n    throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,\n            \"Failed to collect certificates from \" + apkPath\n                    + \" using APK Signature Scheme v2\",\n            e);\n} finally {\n    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n}\nif (verified) {\n  if (pkg.mCertificates == null) {\n    // 填充pkg的  mCertificates   mSignatures   mSigningKeys   字段\n    pkg.mCertificates = allSignersCerts;\n    pkg.mSignatures = signatures;\n    pkg.mSigningKeys = new ArraySet<>(allSignersCerts.length);\n    for (int i = 0; i < allSignersCerts.length; i++) {\n      Certificate[] signerCerts = allSignersCerts[i];\n      Certificate signerCert = signerCerts[0];\n      pkg.mSigningKeys.add(signerCert.getPublicKey());\n    }\n  }\n  // Not yet done, because we need to confirm that AndroidManifest.xml exists and,\n  // if requested, that classes.dex exists.\n}\n\n```\n\nV2签名校验通过的情况下,不会再进行V1签名的校验; 如果存在V2签名,但校验没通过,会抛出异常,校验未通过.\n\n##### 2.3.10.4.2. V1签名校验\n\n关于V1签名的资料请查看[这里, Android APK V1 签名原理](http://www.jianshu.com/p/a27783a713f2?from=juejinim)\n\n首先创建StrictJarFile的类实例,用来初始化\n\n```java\njarFile = new StrictJarFile(\n        apkPath,\n        !verified, // whether to verify JAR signature\n        IsSprdPrebuiltApp ? false : signatureSchemeRollbackProtectionsEnforced);\n\npublic StrictJarFile(String fileName,\n            boolean verify,\n            boolean signatureSchemeRollbackProtectionsEnforced)\n                    throws IOException, SecurityException {\n        // 打开 apk文件, 解压apk文件\n        this.nativeHandle = nativeOpenJarFile(fileName);\n        this.raf = new RandomAccessFile(fileName, \"r\");\n\n        try {\n            // V2签名校验失败的情况\n            if (verify) {\n                HashMap<String, byte[]> metaEntries = getMetaEntries();\n                // 指定 MANIFEST.MF 文件,并读取其中记录的文件保存到entries中\n                this.manifest = new StrictJarManifest(metaEntries.get(JarFile.MANIFEST_NAME), true);\n                // 初始化校验器, 将manifest传入校验器\n                this.verifier = new StrictJarVerifier(\n                                fileName,\n                                manifest,\n                                metaEntries,\n                                signatureSchemeRollbackProtectionsEnforced);\n                Set<String> files = manifest.getEntries().keySet();\n                for (String file : files) {\n                    //  MANIFEST.MF 中记录的文件没有在包中,抛出异常 \n                    if (findEntry(file) == null) {\n                        throw new SecurityException(fileName + \": File \" + file + \" in manifest does not exist\");\n                    }\n                }\n              // 此处将CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改,比对是在其内部的verifyCertificate函数中\n                isSigned = verifier.readCertificates() && verifier.isSignedJar();\n              // V2 签名校验通过,此处置空,表示不再进行V1的签名校验\n            } else {\n                isSigned = false;\n                this.manifest = null;\n                this.verifier = null;\n            }\n        }\n  ...\n}\n```\n\n├── META-INF\n│   ├── ANDROID_.RSA\n│   ├── ANDROID_.SF\n│   └── MANIFEST.MF\n\n.RSA 是 [PKCS#7](http://www.jianshu.com/p/a27783a713f2?from=juejinim#fn_lemma_ref9) 标准格式的文件，我们只关心它所保存的以下两种数据：\n\n>   a. 用`私钥`对 .SF 文件`指纹`进行`非对称加密`后得到的 **加密数据**\n>   b. 携带`公钥`以及各种身份信息的 **数字证书**\n\n MANIFEST.MF、CERT.SF、CERT.RSA 如何各司其职构成了 APK 的签名：\n\n>a. 解析出 CERT.RSA 文件中的证书、公钥，解密 CERT.RSA 中的加密数据\n>b. 解密结果和 CERT.SF 的指纹进行对比，保证 CERT.SF 没有被篡改\n>c. 而 CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改\n>d. MANIFEST.MF 中的内容和 APK 所有文件指纹逐一对比，**保证 APK 没有被篡改**\n\n```java\n// 要校验的包放在 toVerify 的列表中\nfinal List<ZipEntry> toVerify = new ArrayList<>();\ntoVerify.add(manifestEntry);\n```\n\n使用loadCertificates函数进行校验:\n\n```java\nfor (ZipEntry entry : toVerify) {\n  final Certificate[][] entryCerts = loadCertificates(jarFile, entry);\n}\nfinal Certificate[][] entryCerts = loadCertificates(jarFile, entry);\n    protected static Certificate[][] loadCertificates(StrictJarFile jarFile, ZipEntry entry) throws PackageParserException {     \n        try {\n            // 返回验证entry的压缩数据流\n            is = jarFile.getInputStream(entry);\n            // 对每个待验证的entry进行校验\n            readFullyIgnoringContents(is);\n            return jarFile.getCertificateChains(entry);\n        } \n    }\n```\n\n使用getInputStream函数初始化VerifierEntry结构,并返回验证item的zip的压缩数据流\n\n```java\npublic InputStream getInputStream(ZipEntry ze) {\n    final InputStream is = getZipInputStream(ze);\n    if (isSigned) {\n        StrictJarVerifier.VerifierEntry entry = verifier.initEntry(ze.getName());\n        return new JarFileInputStream(is, ze.getSize(), entry);\n    }\n    return is;\n}\nVerifierEntry initEntry(String name) {\n  // 之前传入了MANIFEST.MF文件的句柄,即如果该文件中没有该验证item的记录,直接退出\n  Attributes  = manifest.getAttributes(name);\n  // entry has no digest\n  if (attributes == null) {\n    return null;\n  }\n\n  ArrayList<Certificate[]> certChains = new ArrayList<Certificate[]>();\n  // signatures保存的是 MANIFEST,MF文件中记录项的数据指纹的Base64值\n  // 如果把 MANIFEST.MF 当做是对 APK 中各个文件的 hash 记录，那么 *.SF 就是 MANIFEST.MF 及其各个条目的 hash 记录。\n  Iterator<Map.Entry<String, HashMap<String, Attributes>>> it = signatures.entrySet().iterator();\n  while (it.hasNext()) {\n    Map.Entry<String, HashMap<String, Attributes>> entry = it.next();\n    HashMap<String, Attributes> hm = entry.getValue();\n    if (hm.get(name) != null) {\n      // Found an entry for entry name in .SF file\n      String signatureFile = entry.getKey();\n      Certificate[] certChain = certificates.get(signatureFile);\n      if (certChain != null) {\n        certChains.add(certChain);\n      }\n    }\n  }\n\n  // entry is not signed\n  if (certChains.isEmpty()) {\n    return null;\n  }\n  Certificate[][] certChainsArray = certChains.toArray(new Certificate[certChains.size()][]);\n\n  for (int i = 0; i < DIGEST_ALGORITHMS.length; i++) {\n    // 遍历算法, 目前是这几个 \"SHA-512\", \"SHA-384\", \"SHA-256\", \"SHA1\"\n    final String algorithm = DIGEST_ALGORITHMS[i];\n    // 清单文件中记录了采用的算法计算指纹信息(比较常用的是 SHA1-Digest),可打开MANIFEST.MF文件查看\n    final String hash = attributes.getValue(algorithm + \"-Digest\");\n    try {\n      return new VerifierEntry(name, MessageDigest.getInstance(algorithm), hashBytes,\n                               certChainsArray, verifiedEntries);\n    } \n  }\n}\n\n```\n\n调用readFullyIgnoringContents函数,读取待验证entry文件的数据流,对每个待验证entry进行校验,即和计算该文件的数字指纹和清单中记录的hash值进行比对\n\n```java\n// 读取完毕后,进行校验\nif (count == 0) {\n    done = true;\n    entry.verify();\n}\nvoid verify() {\n  byte[] d = digest.digest();\n  if (!MessageDigest.isEqual(d, Base64.decode(hash))) {\n    throw invalidDigest(JarFile.MANIFEST_NAME, name, name);\n  }\n  // 校验通过后,放进上一步初始化的VerifierEntry中,以entry的name为索引,name是验证文件的名称\n  verifiedEntries.put(name, certChains);\n}\n```\n\n如果校验失败,此时verifiedEntries为空,在loadCertificates后进行检查,为空时抛出异常\n\n```java\nfinal Certificate[][] entryCerts = loadCertificates(jarFile, entry);\n if (ArrayUtils.isEmpty(entryCerts)) {\n     throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,\n             \"Package \" + apkPath + \" has no certificates at entry \"\n          }\n```\n\n#### 2.3.10.5. 判断是应用升级的情况\n\n即installFlags携带INSTALL_REPLACE_EXISTING(adb 安装时指定了-r参数)\n\n1.  在mSettings.mRenamedPackages中查找该包名,如果能够查找到返回旧的包名,再检查Package的mOriginalPackages,如果 pkg的 mOriginalPackages 包含该旧包名,且该旧包能在PKMS.mPackages中查到,则说明该包已经安装,此时为应用升级的情况.在这种情况下,需更新当前的包名为旧包的包名,以及更新其所属组件的关联的packageName名称,并将replace标记标为true.\n2.  直接在PKMS.mPackages查找到了该包,说明包已经安装,只需要将replace设置为true\n\n当replace为true时,检查版本号,在AndroidN版本上,如果新安装的包sdk小于22,而已安装的 >=22,跳出安装流程,不能从支持runtimepermission的跳到不支持的版本上\n\n#### 2.3.10.6. 当Packages.xml中存在package的记录时,比对签名\n\n>   Quick sanity check that we're signed correctly if updating; we'll check this again later when scanning, but we want to bail early here before tripping over redefined permissions.\n\nupgradeKeySets 这一项来自于解析AndroidManifest.xml节点的key-sets项,一般情况下,不会配置该项.\n\n>   当旧包记录中keySetData不为空时,比对当前包中mSigningKeys是否包含这一项,包含则通过检查,没有包含,则设置错误提示退出安装.\n\n```java\n// 使用 KeySetManagerService 查看是否使用了有效的 upgradeKeySets\nif (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {\n    // 比对签名未通过时,提示并退出安装\n    if (!checkUpgradeKeySetLP(ps, pkg)) {\n        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \"\n                + pkg.packageName + \" upgrade keys do not match the \"\n                + \"previously installed version\");\n        return;\n    }\n} else {\n    try {\n        verifySignaturesLP(ps, pkg);\n    } catch (PackageManagerException e) {\n        res.setError(e.error, e.getMessage());\n        return;\n    }\n}\nprivate boolean shouldCheckUpgradeKeySetLP(PackageSetting oldPs, int scanFlags) {\n  // Can't rotate keys during boot or if sharedUser.\n  // olgPs为存在packages.xml中的记录, 如果其有shareUserId, 返回false\n  if (oldPs == null || (scanFlags&SCAN_INITIAL) != 0 || oldPs.sharedUser != null\n      || !oldPs.keySetData.isUsingUpgradeKeySets()) {\n    return false;\n  }\n  // app is using upgradeKeySets; make sure all are valid\n  // 使用 KeySetManagerService 查看是否使用了有效的 upgradeKeySets\n  KeySetManagerService ksms = mSettings.mKeySetManagerService;\n  long[] upgradeKeySets = oldPs.keySetData.getUpgradeKeySets();\n  for (int i = 0; i < upgradeKeySets.length; i++) {\n    if (!ksms.isIdValidKeySetId(upgradeKeySets[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n```\ndemo:  通过checkUpgradeKeySetLP函数比对当前包的mSigningKeys 中是否包含 记录中的 KeySet对应的 public-key项,校验失败设置错误提示,退出安装\n\n```xml\n    <key-sets>\n        <key-set android:name=\"AB\" >\n          <public-key android:name=\"keyA\"\n                      android:value=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwf5zJblvYSB7Ym7or/7GggAAu7mp7RrykPJsXhod8doFhVT5s7eF3A4MCE55vvANP7HvwMw2b+T6qx7Pq0VJtbbSDtlBHBtIc47Pjq0CsDg590BUcgKp7PdJ9J6UVgtzDnV6cGEpXmSag3sY+lqiW04ytPhCVwzYTWGdYe9+TIl47cBrveRfLOlGrcuFQe+zCTmDFqzBKCRHK9b7l5PDWvXXyg65Uu/MBUA/TZWO0fEqOlxZG/nn6DUKQLhPdmJRXWJ3WqMNMhJGD+nKtkmdX703xRqmg4h+6g0S7M9Y3IQ2NUGyw05AYzCguHB/Mv6uVIiW659wpbyb45TgKG3UhQIDAQAB\" />\n          <public-key android:name=\"keyB\"\n                      android:value=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoeFZqMqTbZiozFTXMkXtSKJRzn2qODZgvVXAAwKTi50xYcbPcHTfKxtif8+q7OCp/50JYDH32bg6wkUunn5+dEaHkxZY8d7uw46tQtl5dNGi+6cc4MezVLCS6nkqNDusAgdvgLU6Fl6SGi02KTp1vkt6CwLO977YJP7kt9ouDRTG7ASJiq3OyRRoOqYHhD9gpsbUq4w+1bXGfuuZujA1dXyovXtvrHUGOdFIEBYOVYGfCcwh3lXPmjNJMlHtKQkurq8/LH7a1B5ocoXCGsyR8YHdlWfrqRAfzgOB1KCnNNmWqskU9LOci3uQn9IDeMEFmAd8FqF8SwV+4Ludk/xWGQIDAQAB\" />\n        </key-set>\n        <upgrade-key-set android:name=\"AB\"/>\n    </key-sets>\n```\n>   旧包中keySetData项为空, 可以查看Packages.xml文件,对应的标签为upgrade-keyset, 没有该项,则通过`verifySignaturesLP`函数进行签名比对\n\n##### 2.3.10.6.1. verifySignaturesLP 进行签名比对(新老安装包)\n\n在mSettings.mPackages中存在该包, 需要比对该包的签名和现在解析的包的签名进行比对.签名不一致,退出安装.\n\n>   关于databaseVersion项在[启动篇](https://cototem.github.io/2017/08/02/pkms1/#settings类的作用)介绍过, 对于private volume. databaseVersion的值总是3,而public volume的值往往等于sdkVersion.\n\n```java\n// 首先记录中包的签名不为空\nif (pkgSetting.signatures.mSignatures != null) {\n    // Already existing package. Make sure signatures match\n    // Make sure s2 contains all signatures in s1. 这个函数比较简单,只是简单的比对是否   s1 和 s2 完全相同\n    boolean match = compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures)\n            == PackageManager.SIGNATURE_MATCH;\n    if (!match) {\n        // 这个地方上来检测 pkg安装到的 volume 对应的databaseVersion是否小于2, 不小于2的情况下,直接退出.所以后面的流程都没走.\n        match = compareSignaturesCompat(pkgSetting.signatures, pkg)\n                == PackageManager.SIGNATURE_MATCH;\n    }\n    if (!match) {\n        // 这个地方上来检测 pkg安装到的 volume 对应的databaseVersion是否小于3, 不小于3的情况下,直接退出.所以后面的流程都没走.\n        match = compareSignaturesRecover(pkgSetting.signatures, pkg)\n                == PackageManager.SIGNATURE_MATCH;\n    }\n    if (!match) {\n        throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \"\n                + pkg.packageName + \" signatures do not match the \"\n                + \"previously installed version; ignoring!\");\n    }\n}\n```\n\n接下来检测shareUser的签名,即如果应用指定了shareUserId项,可将指定shareUser的项看作同类的包,需要挨个检测签名是否一致,以出现的第一个包的签名为基准.\n\n```java\n// Check for shared user signatures\nif (pkgSetting.sharedUser != null && pkgSetting.sharedUser.signatures.mSignatures != null) {\n    // Already existing package. Make sure signatures match\n    boolean match = compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,\n            pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;\n}\n```\n\n此处可以追溯pkgSetting.sharedUser.signatures.mSignatures第一次被赋值的地方.\n\n在[scanPackageDirtyLI函数处](https://cototem.github.io/2017/08/02/pkms2/#保存当前扫描的包和包信息)调用了mSettings.insertPackageSettingLPw(pkgSetting, pkg) 函数,此处检测shareUser的签名如果为空,会更新为当前扫描包的签名\n\n```java\n// If this app defines a shared user id initialize\n// the shared user signatures as well.\nif (p.sharedUser != null && p.sharedUser.signatures.mSignatures == null) {\n    p.sharedUser.signatures.assignSignatures(pkg.mSignatures);\n}\n```\n\n#### 2.3.10.7. 验证权限\n\n如果从apk中解析到的权限信息，在之前已经定义过，即mSettings.mPermissions包含该权限名，那么首先验证签名信息是否符合（升级包时，一般包），签名符合继续安装流程；签名不符合时，如果冲突的权限来自framework-res.apk，删除当前apk冲突的权限，继续安装流程，否则终止安装。\n\n如果不是framework-res.apk包,需要其定义的权限是否为PROTECTION_DANGEROUS权限, 如果是dangerous权限,但已经存在的同名权限的类型为非dangerous的权限,则需要变更当前权限的protectionLevel为记录中的protectionLevel\n\n原因是防止特权扩大,如某应用在其他应用组中添加了该权限,如果重新定义该权限名称为dangerous权限,则会导致之前的应用组的该权限被默认授权.??\n\n#### 2.3.10.8. 更新指令集以及拷贝本地库并执行dexopt优化\n\n可以参考[处理本地库目录](https://cototem.github.io/2017/08/02/pkms2/#处理本地库目录), 以及[为非系统应用更新共享库信息](https://cototem.github.io/2017/08/02/pkms2/#为非系统应用更新共享库信息). \n\n由于本地库目录的变更, 一些应用可能使用到了此库,所以需要更新这些应用的usesLibraries项,更新路径信息.\n\n```java\nelse if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {\n    // Enable SCAN_NO_DEX flag to skip dexopt at a later stage\n    scanFlags |= SCAN_NO_DEX;\n\n    try {\n        String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ?\n            args.abiOverride : pkg.cpuAbiOverride);\n        derivePackageAbi(pkg, new File(pkg.codePath), abiOverride,\n                true /* extract libs */);\n    } catch (PackageManagerException pme) {\n        Slog.e(TAG, \"Error deriving application ABI\", pme);\n        res.setError(INSTALL_FAILED_INTERNAL_ERROR, \"Error deriving application ABI\");\n        return;\n    }\n\n    // Shared libraries for the package need to be updated.\n    synchronized (mPackages) {\n        try {\n           // 更新pkg.usesLibraries项,更新路径信息\n            updateSharedLibrariesLPw(pkg, null);\n        } catch (PackageManagerException e) {\n            Slog.e(TAG, \"updateSharedLibrariesLPw failed: \" + e.getMessage());\n        }\n    }\n    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"dexopt\");\n    // Do not run PackageDexOptimizer through the local performDexOpt\n    // method because `pkg` may not be in `mPackages` yet.\n    //\n    // Also, don't fail application installs if the dexopt step fails.  // 失败并不退出\n    mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles,\n            null /* instructionSets */, false /* checkProfiles */,\n            getCompilerFilterForReason(REASON_INSTALL));\n    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n}\n```\n\n#### 2.3.10.9. 目录更名\n\n调用FileInstallArgs.doRename方法，将/data/app/vmdl<随机整数>.tmp目录更名为/data/app/packageName-num，num的值在1和2之间循环取值，同时还要更新FileInstallArgs和Package pkg相关的路径信息：\n\n```java\nboolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {\n\n    final File targetDir = codeFile.getParentFile();\n    final File beforeCodeFile = codeFile;\n    final File afterCodeFile = getNextCodePath(targetDir, pkg.packageName);\n\n    if (DEBUG_INSTALL) Slog.d(TAG, \"Renaming \" + beforeCodeFile + \" to \" + afterCodeFile);\n    try {\n        Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());\n    } \n    // 重新设置Selinux上下文\n    if (!SELinux.restoreconRecursive(afterCodeFile)) {\n        Slog.w(TAG, \"Failed to restorecon\");\n        return false;\n    }\n\n    // Reflect the rename internally\n    codeFile = afterCodeFile;\n    resourceFile = afterCodeFile;\n\n    // Reflect the rename in scanned details\n    pkg.setCodePath(afterCodeFile.getAbsolutePath());\n    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile,\n            afterCodeFile, pkg.baseCodePath));\n    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile,\n            afterCodeFile, pkg.splitCodePaths));\n\n    // Reflect the rename in app info\n    pkg.setApplicationVolumeUuid(pkg.volumeUuid);\n    pkg.setApplicationInfoCodePath(pkg.codePath);\n    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);\n    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);\n    pkg.setApplicationInfoResourcePath(pkg.codePath);\n    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);\n    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);\n\n    return true;\n}\n```\n\n冻结应用,杀死进程.但如果安装参数中携带了INSTALL_DONT_KILL_APP标记时,不会杀掉该进程.\n\n更名完毕后，根据是全新安装还是覆盖安装，执行[全新安装installNewPackageLI](#全新安装)或[覆盖安装replacePackageLIF方法](#覆盖安装)。\n\n#### 2.3.10.10. 覆盖安装\n\nreplacePackageLIF函数进行覆盖安装\n\n首先，对于重复安装时先比对 新包和 已安装包的签名信息是否匹配，对于升级安装时验证新包是否包含旧包的所有签名密钥，失败直接返回，停止覆盖安装\n\n```java\n// verify signatures are valid\nfinal PackageSetting ps = mSettings.mPackages.get(pkgName);\nif (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {\n    if (!checkUpgradeKeySetLP(ps, pkg)) {\n        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                \"New package not signed by keys specified by upgrade-keysets: \"\n                        + pkgName);\n        return;\n    }\n} else {\n    // default to original signature matching\n    if (compareSignatures(oldPackage.mSignatures, pkg.mSignatures)\n            != PackageManager.SIGNATURE_MATCH) {\n        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                \"New package has a different signature: \" + pkgName);\n        return;\n    }\n}\n```\n\n如果旧包的restrictUpdateHash字段不为空,且旧包为system app时,需要对apk进行MD校验, 只有当apk的md值等于该restrictUpdateHash字段的值时,才允许升级.\n\n该字段来自于解析apk的Manifest节点, restrict-update  : android:hash.\n\n>   don't allow a system upgrade unless the upgrade hash matches\n\n接下来检查新老包的shareUserid有没有发生变化,包括其parent和child包的也要一并检查.如果shareUserId变化了,提示错误,退出安装.\n\n```java\n// Check for shared user id changes\nString invalidPackageName =\n        getParentOrChildPackageChangedSharedUser(oldPackage, pkg);\nif (invalidPackageName != null) {\n    res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,\n            \"Package \" + invalidPackageName + \" tried to change user \"\n                    + oldPackage.mSharedUserId);\n    return;\n}\n```\n\n查询为哪些用户安装了旧包,并保存起来\n\n```java\ninstalledUsers = ps.queryInstalledUsers(allUsers, true);\n```\n\n更新PackageInstalledInfo.removedInfo信息\n\n<span id=\"removedInfo\">对应于PackageRemovedInfo removedInfo类\n\n最后根据apk的类型进行系统级/非系统级替换安装：\n\n##### 2.3.10.10.1. 非系统级apk覆盖安装\n\n调用replaceNonSystemPackageLIF方法进行非系统级apk的覆盖安装，与全新安装的区别主要是，在安装前会先删除内部数据结构信息，从而可以进行扫描安装：\n\n首先，调用deletePackageLI方法删除已安装apk的数据结构信息，但是保留数据目录。对于ForwardLocked/External（是否忘记porting InternalSd）类型的apk，在杀死该应用前发送一个广播，使用户可以放弃资源：\n\n```java\nif (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {\n    if (DEBUG_INSTALL) {\n        Slog.i(TAG, \"upgrading pkg \" + deletedPackage + \" is ASEC-hosted -> UNAVAILABLE\");\n    }\n    final int[] uidArray = new int[] { deletedPackage.applicationInfo.uid };\n    final ArrayList<String> pkgList = new ArrayList<String>(1);\n    pkgList.add(deletedPackage.applicationInfo.packageName);\n    //  mediaStatus为false, 发送android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE的广播\n    sendResourcesChangedBroadcast(false, true, pkgList, uidArray, null);\n}\n```\n\n调用<span id=\"clearAppDataLIF\">clearAppDataLIF方法清除所有用户下的该应用的DE区和CE区的/code_cache目录.(通过installd完成)\n\n```java\nclearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE\n        | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n```\n\n调用<span id=\"clearAppProfilesLIF\">clearAppProfilesLIF方法清除   /data/misc/profiles/ref/<packageName>/primary.prof 文件和\n\n清除所有用户下的该文件    /data/misc/profiles/cur/<userid>/<packageName>/primary.prof \n\n接下来执行的步骤和全新安装流程基本相同, 即执行<span id=\"scanPackageTracedLI\">scanPackageTracedLI进入[scanPackageLI方法](https://cototem.github.io/2017/08/02/pkms2/#scanpackageli函数)扫描安装apk,调用updateSettingsLI方法(主要调用了updateSettingsInternalLI方法)，将新安装的apk信息更新到packages.xml中.[跳转到此](#newinstall)\n\n但是需要更新新安装包PackageSetting的oldCodePaths字段(携带`SCAN_DONT_KILL_APP`标志时,即不杀应用时),该字段保存了旧包的安装包baseapk即splitapk的路径, 新安装包的子包的此字段也需要同步更新.\n\n至此，非系统级apk覆盖安装结束，最终回到installPackageLI中。\n\n##### 2.3.10.10.2. 系统级apk覆盖安装\n\n调用replaceSystemPackageLIF函数进行系统级apk的覆盖安装\n\n>   首先需要调用removePackageLI方法清除旧包的数据结构信息:  从PackageManagerService.mPackages中清除已安装的系统包，接着调用`cleanPackageDataStructuresLILPw`从PackageManagerService.mProviders/mServices/mActivities等组件中清除旧包所包含的组件信息；\n\n```java\nremovePackageLI(deletedPackage, true);\nvoid removePackageLI(PackageSetting ps, boolean chatty) {\n  synchronized (mPackages) {\n    mPackages.remove(ps.name);\n    final PackageParser.Package pkg = ps.pkg;\n    if (pkg != null) {\n      cleanPackageDataStructuresLILPw(pkg, chatty);\n    }\n  }\n}\n```\n\n>   接着，调用mSettings.`disableSystemPackageLPw`方法将已安装的包信息disabled：先根据包名查询mSettings.mDisabledSysPackages是否存在包信息，如果存在，直接返回false；不存在，更改标志为FLAG_UPDATED_SYSTEM_APP，将已安装的包信息添加到mSettings.mDisabledSysPackages中，并根据已安装的包信息创建一个新的备份，用这个备份来更替换mSettings.mPackages的包信息，以及替换共享用户的包信息/mSettings.mUserIds或mSettings.mOtherUserIds（即，要保留原始安装包信息，只对备份修改）：\n\n省略了子包的相关操作....\n\n```java\n// 将已安装的包信息disabled\nboolean disabled = mSettings.disableSystemPackageLPw(oldPkg.packageName, true);\n    boolean disableSystemPackageLPw(String name, boolean replaced) {\n        final PackageSetting p = mPackages.get(name);\n        final PackageSetting dp = mDisabledSysPackages.get(name);\n        // always make sure the system package code and resource paths dont change\n        // !isUpdatedSystemApp   // 没有被标记为   FLAG_UPDATED_SYSTEM_APP 的情况下,  初始情况下,就是没有被标记的\n        if (dp == null && p.pkg != null && p.pkg.isSystemApp() && !p.pkg.isUpdatedSystemApp()) {\n            // 进入此条件的前提是当前替换的旧包在不在系统禁用包中,  即在mDisabledSysPackages中\n            if((p.pkg != null) && (p.pkg.applicationInfo != null)) {\n                p.pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;\n            }\n            // 将旧包加入到系统禁用包中\n            mDisabledSysPackages.put(name, p);\n\n            if (replaced) {\n                // a little trick...  when we install the new package, we don't\n                // want to modify the existing PackageSetting for the built-in\n                // version.  so at this point we need a new PackageSetting that\n                // is okay to muck with.\n                // 创建新的packageSetting, 因为升级的是系统包,不再使用之前的旧的PackageSetting\n                PackageSetting newp = new PackageSetting(p);\n                // 将和name绑定的PackageSetting替换为现在新创建的PackageSetting\n                replacePackageLPw(name, newp);\n            }\n            return true;\n        }\n        // 存在直接返回false\n        return false;\n    }\n```\n\n旧包没在mDisabledSysPackages中时,说明原先的包是安装状态,需要填充PackageInstalledInfo.PackageRemovedInfo信息. 调用createInstallArgsForExisting方法生成这个信息,  We need to make sure to delete the older one's .apk.\n\n>   执行[clearAppDataLIF](#clearAppDataLIF) 和 [clearAppProfilesLIF](#clearAppProfilesLIF) 清除codecache和primary.prof 文件;\n>\n>   设置ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志,通过isUpdatedSystemApp查询时返回true\n>\n>   执行scanPackageTracedLI(#scanPackageTracedLI)函数进行安装.\n>\n>   设置应用的[安装时间和更新时间](#https://cototem.github.io/2017/08/02/pkms1/#firstInstallTime)firstInstallTime   lastUpdateTime, 还有子包的\n>\n>   遍历当前包的所有子包,检查更新包的子包是否和旧包的子包相同. 旧包子包没有在更新包中,需要将该包删除(从mPackages中清除,并包括组件信息等),并清除数据(不止是codecache,没有`DELETE_KEEP_DATA`标志的前提下)\n>\n>   调用updateSettingsLI方法(主要调用了[updateSettingsInternalLI](#updateSettingsInternalLI)方法)，将新安装的apk信息更新到packages.xml中\n>\n>   调用[prepareAppDataAfterInstallLIF方法](#prepareAppDataAfterInstallLIF)为新安装的包准备数据目录\n\n如果安装失败，调用removeInstalledPackageLI删除新的包，扫描恢复旧的安装包，若是第一次更新从mSettings.mDisabledSysPackages删除旧的包信息，更新安装的包名，并再次更新packages.xml文件\n\n```java\nif (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {\n    // Re installation failed. Restore old information\n    // Remove new pkg information\n    if (newPackage != null) {\n        removeInstalledPackageLI(newPackage, true);\n    }\n    // Add back the old system package\n    try {\n        // 重新扫描旧包\n        scanPackageTracedLI(deletedPackage, policyFlags, SCAN_UPDATE_SIGNATURE, 0, user);\n    } catch (PackageManagerException e) {\n        Slog.e(TAG, \"Failed to restore original package: \" + e.getMessage());\n    }\n\n    synchronized (mPackages) {\n        // 此标志为true,说明是第一次更新时,上述步骤中将旧包禁用 (使用disableSystemPackageLPw方法禁用的,此时要重新启用回来)\n        if (disabledSystem) {\n            enableSystemPackageLPw(deletedPackage);\n        }\n\n        // Ensure the installer package name up to date\n        // 设置应用的安装时间和更新时间firstInstallTime   lastUpdateTime, 还有子包的\n        setInstallerPackageNameLPw(deletedPackage, installerPackageName);\n\n        // Update permissions for restored package\n        updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);\n        // 更新packages.xml文件\n        mSettings.writeLPr();\n    }\n```\n\n至此，系统级apk覆盖安装完成，最终回到installPackageLI。\n\n#### 2.3.10.11. 全新安装\n\n调用PackageManagerService. installNewPackageLI方法执行全新安装。\n\n如果当前包已安装过，即使是更名的，也结束installNewPackageLI安装：\n\n```java\nif (mSettings.mRenamedPackages.containsKey(pkgName)) {\n    res.setError(INSTALL_FAILED_ALREADY_EXISTS, \"Attempt to re-install \" + pkgName\n            + \" without first uninstalling package running as \"\n            + mSettings.mRenamedPackages.get(pkgName));\n    return;\n}\nif (mPackages.containsKey(pkgName)) {\n    res.setError(INSTALL_FAILED_ALREADY_EXISTS, \"Attempt to re-install \" + pkgName\n            + \" without first uninstalling.\");\n    return;\n}\n```\n\n<span id=\"newinstall\">\n\n调用PackageManagerService.[scanPackageLI方法](https://cototem.github.io/2017/08/02/pkms2/#scanpackageli函数)扫描安装apk，创建数据目录，主要创建/data/data/<pkgName>数据目录，和/data/data/<pkgName>/lib库文件目录，并将库目录链接到/data/app/<pkgName-num>/lib/arm库文件目录；\n\n然后调用updateSettingsLI方法(主要调用了<span id=\"updateSettingsInternalLI\">updateSettingsInternalLI方法)，将新安装的apk信息更新到packages.xml中:\n\n-   首先，先更新packages.xml文件，此时该apk为安装未完成状态；\n-   调用updatePermissionsLPW，为安装的apk分配权限，并将相应的gid号保存到PackageSettngs或SharedUserSetting的gids数组中；\n-   更新安装状态为安装完成，和PackageInstalledInfo res的属性，重新更新packages.xml文件。\n\n```java\n    private void updateSettingsInternalLI(PackageParser.Package newPackage,\n            String installerPackageName, int[] allUsers, int[] installedForUsers,\n            PackageInstalledInfo res, UserHandle user) {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\");\n        String pkgName = newPackage.packageName;\n        synchronized (mPackages) {\n            // 指定安装未完成状态\n            mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_INCOMPLETE);\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\");\n            mSettings.writeLPr();\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n\n        if (DEBUG_INSTALL) Slog.d(TAG, \"New package installed in \" + newPackage.codePath);\n        synchronized (mPackages) {\n            // 调用updatePermissionsLPW，为安装的apk分配权限，并将相应的gid号保存到PackageSettngs或SharedUserSetting的gids数组中；\n            updatePermissionsLPw(newPackage.packageName, newPackage,\n                    UPDATE_PERMISSIONS_REPLACE_PKG | (newPackage.permissions.size() > 0\n                            ? UPDATE_PERMISSIONS_ALL : 0));\n            PackageSetting ps = mSettings.mPackages.get(pkgName);\n            final int userId = user.getIdentifier();\n            if (ps != null) {\n                // 新安装的包为system app,需要重新启用之前可能禁用的组件, 因为该函数可被多个地方调用, 全新安装的情况下,是不会走到这里的\n                if (isSystemApp(newPackage)) {\n                    if (DEBUG_INSTALL) {\n                        Slog.d(TAG, \"Implicitly enabling system package on upgrade: \" + pkgName);\n                    }\n                    // Enable system package for requested users\n                    // origUser不为空时,标明为覆盖安装?\n                    if (res.origUsers != null) {\n                        for (int origUserId : res.origUsers) {\n                            if (userId == UserHandle.USER_ALL || userId == origUserId) {\n                                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT,\n                                        origUserId, installerPackageName);\n                            }\n                        }\n                    }\n                    // Also convey the prior install/uninstall state\n                    if (allUsers != null && installedForUsers != null) {\n                        for (int currentUserId : allUsers) {\n                            final boolean installed = ArrayUtils.contains(\n                                    installedForUsers, currentUserId);\n                            if (DEBUG_INSTALL) {\n                                Slog.d(TAG, \"    user \" + currentUserId + \" => \" + installed);\n                            }\n                            // 重新指定安装状态, 只有installedForUsers的安装状态才为true\n                            ps.setInstalled(installed, currentUserId);\n                        } \n                    }\n                }\n                // 指定为某个用户安装, 仅为该用户安装\n                if (userId != UserHandle.USER_ALL) {\n                    ps.setInstalled(true, userId);\n                    ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId, installerPackageName);\n                }\n            }\n            res.name = pkgName;\n            res.uid = newPackage.applicationInfo.uid;\n            res.pkg = newPackage;\n           // 更新为安装完成状态\n            mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_COMPLETE);\n            mSettings.setInstallerPackageName(pkgName, installerPackageName);\n            res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);\n            //to update install status\n            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\");\n            // 更新Packages.xml文件表示安装完成\n            mSettings.writeLPr();\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n```\n\n##### 2.3.10.11.1. 准备数据目录\n\n调用prepareAppDataAfterInstallLIF<span id=\"prepareAppDataAfterInstallLIF\">方法为新安装的包准备数据目录\n\n```java\nprivate void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {\n    final PackageSetting ps;\n    synchronized (mPackages) {\n        ps = mSettings.mPackages.get(pkg.packageName);\n        // 创建/config/sdcardfs/<packageSetting.name>/appid文件,里面写入 packageSetting.appid值\n        mSettings.writeKernelMappingLPr(ps);\n    }\n\n    final UserManager um = mContext.getSystemService(UserManager.class);\n    UserManagerInternal umInternal = getUserManagerInternal();\n    for (UserInfo user : um.getUsers()) {\n        final int flags;\n        // 查询用户是否解锁, 即Unlocking 或 Unlocked状态,  \n        if (umInternal.isUserUnlockingOrUnlocked(user.id)) {\n            flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;\n        } else if (umInternal.isUserRunning(user.id)) {\n            flags = StorageManager.FLAG_STORAGE_DE;\n        } else {\n            continue;\n        }\n        // 该用户下安装了该apk, 则需要准备数据目录, 通过installd 创建目录\n        // flag携带DE时, /data/user_de/<userid>/<packageName>/\n        // 携带CE时, /data/user_ce/<userid>/<packageName>/\n        if (ps.getInstalled(user.id)) {\n            // Whenever an app changes, force a restorecon of its data\n            // TODO: when user data is locked, mark that we're still dirty\n            prepareAppDataLIF(pkg, user.id, flags, true);\n        }\n    }\n}\n```\n\ninstallNewPackageLI方法完成，回到installPackageLI方法；\n\n否则，调用deletePackageLI方法，删除安装的数据信息和数据/缓存目录，除非这些目录在安装前已经存在，然后返回installPackageL方法：\n\n### 2.3.11. 小结\n\n在安装完成后,更新已安装的用户id，保存到res的newUsers中.\n\n```java\nfinal PackageSetting ps = mSettings.mPackages.get(pkgName);\nif (ps != null) {\n    res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);\n}\n```\n\n至此，InstallPackageLI方法结束，回到[processPendingInstall](#processPendingInstall)方法继续处理。\n\n### 2.3.12. processPendingInstall方法后续处理\n\ninstallPackageLI安装完成后，首先调用args.doPostInstall方法，确保当安装失败时删除复制的apk、资源和库。\n\n```java\n// A restore should be performed at this point if (a) the install\n// succeeded, (b) the operation is not an update, and (c) the new\n// package has not opted out of backup participation.\n```\n\n>   根据之前的记录的[RemoveInfo](#removedInfo)的信息, 覆盖安装的情况下,此信息才不为空.\n>\n>   当removeinfo为空(全新安装的情况),且安装包对应的applicationinfo中有FLAG_ALLOW_BACKUP标记时(来自于Manifest),   doRestore为true\n\ndoRestore为true时,连接BACKUP_SERVICE,执行BackupManagerService.restoreAtInstall方法, 最终执行到 PerformUnifiedRestoreTask 的execute方法, startRestore方法  ??  \n\n接着，将安装次序和安装信息保存到PackageManangerService.mRunningInstalls中：（mNextInstallToken>=1）\n\n```java\ntoken = mNextInstallToken++;\nPostInstallData data = new PostInstallData(args, res);\nmRunningInstalls.put(token, data);      //以安装次序为key 保存了 PostInstallData对象\n    static class PostInstallData {\n        public InstallArgs args;\n        public PackageInstalledInfo res;\n    }\n```\n\ndoRestore为false的情况下,   即覆盖安装的情况下, 或者前面的restoreAtInstall方法执行错误的情况(可能是没有 BackupManagerService , 或连接不上时)\n\n执行POST_INSTALL阶段\n\n### 2.3.13. POST_INSTALL阶段(处理POST_INSTALL消息)\n\n这部分主要发送一些安装成功的广播，可以被launcher接收，在桌面添加图表等操作，并回调Observer安装成功的接口，具体处理流程如下：\n\n从mRunningInstalls中取出之前保存的 PostInstallData对象\n\n```java\nPostInstallData data = mRunningInstalls.get(msg.arg1);\n// 此时传来的 arg2 参数为空\nfinal boolean didRestore = (msg.arg2 != 0);\nif (data != null) {\n  InstallArgs args = data.args;\n  PackageInstalledInfo parentRes = data.res;\n\n  final boolean grantPermissions = (args.installFlags\n                                    & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0;\n  final boolean killApp = (args.installFlags\n                           & PackageManager.INSTALL_DONT_KILL_APP) == 0;\n  final String[] grantedPermissions = args.installGrantPermissions;\n\n  // Handle the parent package\n  handlePackagePostInstall(parentRes, grantPermissions, killApp,\n                           grantedPermissions, didRestore, args.installerPackageName,\n                           args.observer);\n\n  // Handle the child packages\n   ... 省略子包的\n}\n```\n\n#### 2.3.13.1. handlePackagePostInstall函数的处理\n\n主要看handlePackagePostInstall的实现, 该函数中第一个参数为  PackageInstalledInfo ,   该参数为之前保存安装结果的result, 里面保存了错误类型,安装进度,removedinfo信息等.\n\n>   如果其中removedInfo不为空,发送android.intent.action.PACKAGE_REMOVED的广播,提示旧包被删除,广播中携带参数killapp(是否杀掉相应进程)\n>\n>   a. 如果对应的removedinfo中的dataRemoved为true, 且不是删除的system app, 则另外发送android.intent.action.PACKAGE_FULLY_REMOVED的广播\n>\n>   如果对应的removedAppId>=0,发送android.intent.action.UID_REMOVED的广播,  在前面的步骤中,removedAppId赋值是在覆盖系统包时,如果系统包旧包含有子包的情况下,且旧包的某子包未在新安装的包的子包中时,会涉及到该种情况\n\n如果携带的参数中包含grantPermissions, 赋予运行时权限,并更新packages.list文件\n\n如果其parent包不为空,查看parent包是否在mDisabledSysPackages 禁用包中, 且该包为特权包, 给其赋予申请的运行时权限\n\n>   无论是否携带 grantPermissions对应的安装时参数时\n\n```java\nif (res.pkg.parentPackage != null) {\n    synchronized (mPackages) {\n        grantRuntimePermissionsGrantedToDisabledPrivSysPackageParentLPw(res.pkg);\n    }\n}\n```\n\n##### 2.3.13.1.1. 设置用户集firstUsers和updateUsers\n\n设置第一次添加该包的用户集firstUsers和更新该包的用户集updateUsers：当res.origiUsers为空时，只设置发firstUsers为res.newUsers；当存在res.origiUsers时，将res.newUsers中不存在于res.origiUsers的用户存入firstUsers，其余的存入updateUsers中。\n\n```java\n// Determine the set of users who are adding this package for\n// the first time vs. those who are seeing an update.\nint[] firstUsers = EMPTY_INT_ARRAY;\nint[] updateUsers = EMPTY_INT_ARRAY;\nif (res.origUsers == null || res.origUsers.length == 0) {\n    firstUsers = res.newUsers;\n} else {\n    for (int newUser : res.newUsers) {\n        boolean isNew = true;\n        for (int origUser : res.origUsers) {\n            if (origUser == newUser) {\n                isNew = false;\n                break;\n            }\n        }\n        if (isNew) {\n            firstUsers = ArrayUtils.appendInt(firstUsers, newUser);\n        } else {\n            // 该用户下已经安装,  需要将当前的安装的用户添加到updateUsers中\n            updateUsers = ArrayUtils.appendInt(updateUsers, newUser);\n        }\n    }\n}\n```\n\n##### 2.3.13.1.2. 向用户集发送包广播\n\n然后，向firstUsers和updateUsers中的用户发送ACTION_PACKAGE_ADDED  \"android.intent.action.PACKAGE_ADDED\" 广播：\n\n-   对于覆盖安装的情况, 并向updateUsers的用户发送包替换  ACTION_PACKAGE_REPLACED (\"android.intent.action.PACKAGE_REPLACED\" ) 广播\n-   对于全新安装的情况,  didRestore 为true,但此时传入的参数为null, 且非系统包的情况下,发送ACTION_PACKAGE_FIRST_LAUNCH的广播, 在这个安装场景下,这条是不符合条件的\n-   并对FORWARD_LOCKED/外置SD卡的包发送ACTION_EXTERNAL_APPLICATIONS_AVAILABLE的广播\n\n##### 2.3.13.1.3. 为firstUsers 新安装用户集处理挂起的运行时权限申请请求\n\n在mRestoredUserGrants中取出挂起的权限申请请求,然后从其中找出当前包申请的权限,对其进行权限授予,更新flag,并更新/data/users/<userid>/runtime-permissions.xml文件 \n\n```java\nfor (int userId : firstUsers) {\n    mSettings.applyPendingPermissionGrantsLPw(packageName, userId);\n}\n```\n\n##### 2.3.13.1.4. 覆盖安装情况下删除旧包的相关文件\n\n调用res.romovedInfo.args.doPostDeleteLI方法删除旧包的代码/资源/本地库/dex文件等。\n\n```java\nboolean doPostDeleteLI(boolean delete) {\n    // XXX err, shouldn't we respect the delete flag?\n    cleanUpResourcesLI();\n    return true;\n}\n```\n\n##### 2.3.13.1.5. 回调监听器的onPackageInstalled接口\n\n最后，当在PackageInstalled.apk安装时指定了包安装监听器，回调该监听器的onPackageInstalled接口，告知监听的应用包已经安装完成. Bundle在成功安装时为null：\n\n```java\nBundle extras = extrasForInstallResult(res);\ninstallObserver.onPackageInstalled(res.name, res.returnCode,\n        res.returnMsg, extras);\n```\n\n处理完后,安装结束\n\n```java\nLog.d(TAG, \"pms install end\");\n```\n## 2.4. 剩余消息处理\n\n-   处理MCS_RECONNECT消息\n\n当在复制apk时抛出RemoteException，startCopy会发出MCS_RECONNECTION消息，尝试重新复制和安装：如果，当前绑定到MCS上，解除绑定；然后重新绑定该服务，如果绑定失败，处理所有安装请求的错误信息，并移除所有的安装请求\n\n-   处理MCS_GIVE_UP消息\n\n  当尝试4次复制apk，均失败时，在startCopy中发送该消息将此安装请求从队列中移除：\n\n-   处理MCS_UNBIND消息\n\n当前没有安装请求时，会解除与MCS服务的绑定；如果此时又来了安装请求，那么会再次发送一个MCS_BOUND的空消息，继续进行安装\n\n\n","tags":["Android","AndroidN","PackageManagerService","adb"],"categories":["PackageManagerService"]},{"title":"PackageManagerService启动篇整理1","url":"/2017/08/02/其他调研/PackageManagerService启动篇整理1/","content":"\n# 1. PackageManagerService的启动过程\n\n>   本篇主要介绍`pkms`的构造函数所做的工作.\n\n## 1.1. BOOT_PROGRESS_PMS_START 阶段\n\n### 1.1.1. 初始化Settings类\n\n初始化Settings类对象并添加6个ShareUserId\n\n```java\nmSettings = new Settings(mPackages);\nmSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\nmSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\nmSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\nmSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\nmSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\nmSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID,\n                           ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);\n```\n\nSharedUserSettings将“android：sharedUserId”属性的名称和对应的uid关联起来，同时持有所有声明相同sharedUserId的APK的PackageSettings，因此PKMS可以为同一类APK设置相同的权限。\n\n#### 1.1.1.1. Settings类的作用\n\n首先可以看下Settings的构造函数\n\n```java\n    Settings(File dataDir, Object lock) {\n        //该 lock 为mPackages 的ArrayMap\n        mLock = lock;\n\n        mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock);\n\n        mSystemDir = new File(dataDir, \"system\");\n        mSystemDir.mkdirs();\n        FileUtils.setPermissions(mSystemDir.toString(),\n                FileUtils.S_IRWXU|FileUtils.S_IRWXG\n                |FileUtils.S_IROTH|FileUtils.S_IXOTH,\n                -1, -1);\n        // Settings 工具类， 初始化/data/system下的几个目录\n        mSettingsFilename = new File(mSystemDir, \"packages.xml\");\n        mBackupSettingsFilename = new File(mSystemDir, \"packages-backup.xml\");\n        mPackageListFilename = new File(mSystemDir, \"packages.list\");\n        FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID);\n\n        final File kernelDir = new File(\"/config/sdcardfs\");\n        mKernelMappingFilename = kernelDir.exists() ? kernelDir : null;\n\n        // Deprecated: Needed for migration\n        mStoppedPackagesFilename = new File(mSystemDir, \"packages-stopped.xml\");\n        mBackupStoppedPackagesFilename = new File(mSystemDir, \"packages-stopped-backup.xml\");\n    }\n```\n\nSettings为工具类,与权限分配和Package的信息持久化有关.\n\n创建/data/system下几个与Package包信息相关的几个文件:\n\n-   /data/system/packages.xml - 记录系统中已安装的APK的运行信息；\n-   /data/system/packages-backup.xml - 是packages.xml的备份文件，当packages.xml更新完毕时删除；\n-   /data/system/packages.list - 初始化为/data/system/packages.list，记录所有已安装APK的简略信息;\n-   /data/system/packages-stopped.xml - 记录强制stop的应用程序信息(非系统级应用默认为stopped状态)\n-   /data/system/packages-stopped-backup.xml - 初始化为/data/system/packages-stopped-backup.xml，是packages-stopped.xml的备份文件，二者在Jelly Bean中已标记为废弃。\n\n![Setting工具类图](/images/runtime-permission.png)\n\n/data/system/packages.xml \n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<packages>\n    <version volumeUuid=\"f3127468-e382-4328-9d82-40d6ba08c31d\" sdkVersion=\"26\" databaseVersion=\"3\" fingerprint=\"SPRD/sp9850ka_1h10_native:8.0.0/OPR1.170623.013/W17.31:userdebug/test-keys\" />\n    <version sdkVersion=\"26\" databaseVersion=\"3\" fingerprint=\"SPRD/sp9850ka_1h10_native:8.0.0/OPR1.170623.013/W17.31:userdebug/test-keys\" />\n    <version volumeUuid=\"primary_physical\" sdkVersion=\"26\" databaseVersion=\"26\" fingerprint=\"SPRD/sp9850ka_1h10_native:8.0.0/OPR1.170623.013/W17.31:userdebug/test-keys\" />\n    <permission-trees />\n    <permissions>\n        <item name=\"android.permission.REAL_GET_TASKS\" package=\"android\" protection=\"18\" />\n        <item name=\"android.permission.ACCESS_CACHE_FILESYSTEM\" package=\"android\" protection=\"18\" />\n        <item name=\"android.permission.REMOTE_AUDIO_PLAYBACK\" package=\"android\" protection=\"2\" />\n        <item name=\"android.permission.DOWNLOAD_WITHOUT_NOTIFICATION\" package=\"com.android.providers.downloads\" />\n        <item name=\"android.permission.REGISTER_WINDOW_MANAGER_LISTENERS\" package=\"android\" protection=\"2\" />\n        <item name=\"android.permission.INTENT_FILTER_VERIFICATION_AGENT\" package=\"android\" protection=\"18\" />\n      ...此处省略n个权限信息...\n    </permissions>\n  <package name=\"com.android.fmradio\" codePath=\"/system/priv-app/DreamFMRadio\" nativeLibraryPath=\"/system/priv-app/DreamFMRadio/lib\" primaryCpuAbi=\"armeabi-v7a\" publicFlags=\"944291397\" privateFlags=\"8\" ft=\"15d9d796930\" it=\"15d9d796930\" ut=\"15d9d796930\" version=\"2\" userId=\"10006\" isOrphaned=\"true\">\n        <sigs count=\"1\">\n            <cert index=\"0\" key=\"308204a830820390a003020102020900b3998086d056cffa300d06092a864886f70d0101040500308194310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e20566965773110300e060355040a1307416e64726f69643110300e060355040b1307416e64726f69643110300e06035504031307416e64726f69643122302006092a864886f70d0109011613616e64726f696440616e64726f69642e636f6d301e170d3038303431353232343035305a170d3335303930313232343035305a308194310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e20566965773110300e060355040a1307416e64726f69643110300e060355040b1307416e64726f69643110300e06035504031307416e64726f69643122302006092a864886f70d0109011613616e64726f696440616e64726f69642e636f6d30820120300d06092a864886f70d01010105000382010d003082010802820101009c780592ac0d5d381cdeaa65ecc8a6006e36480c6d7207b12011be50863aabe2b55d009adf7146d6f2202280c7cd4d7bdb26243b8a806c26b34b137523a49268224904dc01493e7c0acf1a05c874f69b037b60309d9074d24280e16bad2a8734361951eaf72a482d09b204b1875e12ac98c1aa773d6800b9eafde56d58bed8e8da16f9a360099c37a834a6dfedb7b6b44a049e07a269fccf2c5496f2cf36d64df90a3b8d8f34a3baab4cf53371ab27719b3ba58754ad0c53fc14e1db45d51e234fbbe93c9ba4edf9ce54261350ec535607bf69a2ff4aa07db5f7ea200d09a6c1b49e21402f89ed1190893aab5a9180f152e82f85a45753cf5fc19071c5eec827020103a381fc3081f9301d0603551d0e041604144fe4a0b3dd9cba29f71d7287c4e7c38f2086c2993081c90603551d230481c13081be80144fe4a0b3dd9cba29f71d7287c4e7c38f2086c299a1819aa48197308194310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e20566965773110300e060355040a1307416e64726f69643110300e060355040b1307416e64726f69643110300e06035504031307416e64726f69643122302006092a864886f70d0109011613616e64726f696440616e64726f69642e636f6d820900b3998086d056cffa300c0603551d13040530030101ff300d06092a864886f70d01010405000382010100572551b8d93a1f73de0f6d469f86dad6701400293c88a0cd7cd778b73dafcc197fab76e6212e56c1c761cfc42fd733de52c50ae08814cefc0a3b5a1a4346054d829f1d82b42b2048bf88b5d14929ef85f60edd12d72d55657e22e3e85d04c831d613d19938bb8982247fa321256ba12d1d6a8f92ea1db1c373317ba0c037f0d1aff645aef224979fba6e7a14bc025c71b98138cef3ddfc059617cf24845cf7b40d6382f7275ed738495ab6e5931b9421765c491b72fb68e080dbdb58c2029d347c8b328ce43ef6a8b15533edfbe989bd6a48dd4b202eda94c6ab8dd5b8399203daae2ed446232e4fe9bd961394c6300e5138e3cfd285e6e4e483538cb8b1b357\" />\n        </sigs>\n        <perms>\n            <item name=\"android.permission.MODIFY_AUDIO_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MODIFY_AUDIO_ROUTING\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.ACCESS_MOCK_LOCATION\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.ACCESS_FM_RADIO\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.BLUETOOTH\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.WRITE_MEDIA_STORAGE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.WRITE_SECURE_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.WAKE_LOCK\" granted=\"true\" flags=\"0\" />\n        </perms>\n        <proper-signing-keyset identifier=\"1\" />\n    </package>\n    ....此处省略n个package信息..\n    <package name=\"com.android.providers.telephony\" codePath=\"/system/priv-app/TelephonyProvider\" nativeLibraryPath=\"/system/priv-app/TelephonyProvider/lib\" publicFlags=\"1007402501\" privateFlags=\"8\" ft=\"15d9d7707d0\" it=\"15d9d7707d0\" ut=\"15d9d7707d0\" version=\"26\" sharedUserId=\"1001\" isOrphaned=\"true\">\n        <sigs count=\"1\">\n            <cert index=\"0\" />\n        </sigs>\n        <perms>\n            <item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MODIFY_AUDIO_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MANAGE_ACCOUNTS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SYSTEM_ALERT_WINDOW\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.BIND_CARRIER_SERVICES\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SEND_RESPOND_VIA_MESSAGE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SHUTDOWN\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CHANGE_COMPONENT_ENABLED_STATE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.INTERNAL_SYSTEM_WINDOW\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.PROCESS_PHONE_ACCOUNT_REGISTRATION\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.BROADCAST_SMS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CALL_PRIVILEGED\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CHANGE_NETWORK_STATE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.WRITE_SYNC_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" />\n\t\t\t...\n        </perms>\n        <proper-signing-keyset identifier=\"1\" />\n    </package>\n  \t....此处省略n个package信息..\n  \t<shared-user name=\"android.uid.phone\" userId=\"1001\">\n        <sigs count=\"1\">\n            <cert index=\"0\" />\n        </sigs>\n        <perms>\n            <item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MODIFY_AUDIO_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.MANAGE_ACCOUNTS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SYSTEM_ALERT_WINDOW\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.BIND_CARRIER_SERVICES\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SEND_RESPOND_VIA_MESSAGE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SHUTDOWN\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CHANGE_COMPONENT_ENABLED_STATE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.INTERNAL_SYSTEM_WINDOW\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.PROCESS_PHONE_ACCOUNT_REGISTRATION\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.BROADCAST_SMS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CALL_PRIVILEGED\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.CHANGE_NETWORK_STATE\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.WRITE_SYNC_SETTINGS\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.DEVICE_POWER\" granted=\"true\" flags=\"0\" />\n            <item name=\"android.permission.SET_TIME_ZONE\" granted=\"true\" flags=\"0\" />\n\t\t\t...\n        </perms>\n    </shared-user>\n  \t<keyset-settings version=\"1\">\n        <keys>\n            <public-key identifier=\"1\" value=\"MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAnHgFkqwNXTgc3qpl7MimAG42SAxtcgexIBG+UIY6q+K1XQCa33FG1vIgIoDHzU172yYkO4qAbCazSxN1I6SSaCJJBNwBST58Cs8aBch09psDe2AwnZB00kKA4WutKoc0NhlR6vcqSC0JsgSxh14SrJjBqnc9aAC56v3lbVi+2OjaFvmjYAmcN6g0pt/tt7a0SgSeB6Jp/M8sVJbyzzbWTfkKO42PNKO6q0z1M3GrJ3GbO6WHVK0MU/wU4dtF1R4jT7vpPJuk7fnOVCYTUOxTVge/aaL/SqB9tffqIA0JpsG0niFAL4ntEZCJOqtakYDxUugvhaRXU89fwZBxxe7IJwIBAw==\" />\n            <public-key identifier=\"2\" value=\"MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAyMLb/QlKLfRcP/GjLtIYBexy/FjQF5cb0Pa1LCYtcIGdGRln4Vjf06LH8bPg6AzlRdedKEgiAhHrhvD9gxLTe0IMETdQzJRhiuhy9IhkY73EYnyqDASDyGST41FVcRcDOL/cxM1q3dHAovNfXPJO0+QEOj5Y4rBeZkzN4SvLZ3Nf1t8SScNp5iVCvApHKeU5F/XDj/pS0Xtzycc3mN2xjtSBWQh1VH5mv8XaykwlpuuWDtlpI3CdowK6ZGy0lrMl6Gxciy56M3eyu+THzzMlQpEWP2iRUqwIhVDIPFCPS/Wt8K7VotygWD+asK0XZQ237qSyP9tFiFVH0P6rchg4iQIBAw==\" />\n            <public-key identifier=\"3\" value=\"MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEA1pMZBN7GCySx7cdi4NnYJT4+zWzrHeL/Boyo6LyozWvTeG6nCqds5g67D5k1Wf/ZPnepQ+foPUtkuOT+otPmVvHiZ6gbv7IwtXjCBEO+THIYuEb1IRWG8DihTonCvjh/jr7Pj8rD2h7jMMnqk9Cnw9xK81AiDVAIBzLggJcX7moFM1nmppTsLLPyhKCkZsh6lNg7MQk6ZzcuL2QSwG5tQvFYGN/+A4HMDNRE2mzdw7gkWBlIAbMlZBNPv96YySh3SNv1Z2pUDYFUyLvKB7niR1UzEcRrmvdv3uzMjmnnyKLQjngmIJQ/mXJ9PAT+cpkdmd+brjigshd/ox1bav7pHwIBAw==\" />\n            <public-key identifier=\"4\" value=\"MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAriUMWhbvl/woaaxlGzIXzDa6DoaWQWjVigSfQM6FhnEjo/+09tlJwzzy2joFwj6sqlfYA4ibF1m89Z58byGJCuJQhbftVqpibAmJ75zNNjYsoOjRuWA/1Ngyh2eSbMwJDGi3da5/8wk0zDae8oVaJmffDGZ/0MfPXY66ZVgGc3MDu2JHJuq67fty8H7Xp2qzy5o4HEt9zYCbFA2JHwAhO+QB9Y1qBqYercOpwvHGVnKFsJrgk0Kmb6Qh6vk633VzoCjDMdcGAas698yEAz7OfHcqOluGsNvp13fDpIqpgB7c7ieBWJ9E2eQROXlgBXaplBC6gQkSWdrZjGxo/3hLjwIBAw==\" />\n        </keys>\n        <keysets>\n            <keyset identifier=\"1\">\n                <key-id identifier=\"1\" />\n            </keyset>\n            <keyset identifier=\"2\">\n                <key-id identifier=\"2\" />\n            </keyset>\n            <keyset identifier=\"3\">\n                <key-id identifier=\"3\" />\n            </keyset>\n            <keyset identifier=\"4\">\n                <key-id identifier=\"4\" />\n            </keyset>\n        </keysets>\n        <lastIssuedKeyId value=\"4\" />\n        <lastIssuedKeySetId value=\"4\" />\n    </keyset-settings>\n</packages> \n```\n\n>   该文件记录的信息包括:\n\n-   所有包公布的权限信息:\n\n|                   权限名称                   |            公布该权限的包名             | 权限的保护级别(ProtectLevel) |\n| :--------------------------------------: | :-----------------------------: | :-------------------: |\n| android.permission.DOWNLOAD_WITHOUT_NOTIFICATION | com.android.providers.downloads |         none          |\n|    android.permission.REAL_GET_TASKS     |             android             |          18           |\n| sprd.permission.SPRD_MODIFY_PHONE_STATE  |             android             |           2           |\n| android.permission.WRITE_EXTERNAL_STORAGE |             android             |           1           |\n\n**具体的权限保护级别请查看`PermissionInfo.java`文件**\n\n-   安装包的信息: <package标签>\n\n|              item              |                    作用                    |                   例子                   |\n| :----------------------------: | :--------------------------------------: | :------------------------------------: |\n|              name              |                    包名                    |          com.android.fmradio           |\n|            codePath            |                  apk位置                   |     /system/priv-app/DreamFMRadio      |\n|       nativeLibraryPath        |                native依赖库                 |   /system/priv-app/DreamFMRadio/lib    |\n|         primaryCpuAbi          |                首要的abi指令集                 |              armeabi-v7a               |\n|          publicFlags           | pkg的flag, 解析相关.[将十进制转换为二进制后](http://tool.oschina.net/hexconvert),通过比对ApplicationInfo.java中的标志位查看带有哪些flag |               944291397                |\n|          privateFlags          | 安装\\解析 相关的flag, 比如 PRIVATE_FLAG_DIRECT_BOOT_AWARE,  android:directBootAware=\"true\", 同上,需要[将十进制转换为二进制后](http://tool.oschina.net/hexconvert),通过比对ApplicationInfo.java中的标志位查看带有哪些flag |                   8                    |\n|               ft               | <span id=\"unix\">apk文件的最后一次修改时间(时间采用UNIX时间戳格式,需要先将16进制转换为10进制,再将数字转换unix时间戳)[十六进制转换十进制](http://cn.calcuworld.com/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97%E5%99%A8) [UNIX时间戳转换,注意切换为ms](http://tool.chinaz.com/Tools/unixtime.aspx) |              15d9d796930               |\n| <span id=\"firstInstallTime\">it |                 第一次安装时间                  |              15d9d796930               |\n|  <span id=\"lastUpdateTime\">ut  |               最后一次应用升级的时间                |              15d9d796930               |\n|            version             | 软件版本, 来自于android:versionCode/AndroidManifest |                   2                    |\n|             userId             |                  appid                   |                 10006                  |\n|           isOrphaned           | 与PackageInstaller相关. FLAG_SYSTEM的 app都为true,这个值来自与解析时的PARSE_IS_SYSTEM,目前看到的所有非data目录外的app都携带该标志; 另外用户自己安装的app,如果安装该apk的installer安装器销毁,该apk的此标志位也会变为true. 该标志为默认为false. 与应用卸载的逻辑有关. |                  true                  |\n|              sigs              | 签名信息, count为签名的数目,签名可以有多个.注意修改apk签名后,或者更改shareUserId后,最好删除packages.xml文件,否则可能是读取的文件中的签名的信息 | count=\"1\"   <cert index=\"0\" key=****/> |\n|             perms              |                申请的所有权限信息                 |         MODIFY_AUDIO_SETTINGS          |\n|            granted             |                   是否授予                   |                  true                  |\n|             flags              |                  授予的标志位                  |                   0                    |\n|     proper-signing-keyset      | 可能的密钥集?/与内置的签名集合有关.比如platform的签名其值都是1.而media的签名都是4.与最后的keyset-settings项是关联的. |                   1                    |\n\n-   version标签信息:\n\n| item                        | 作用                                       | 例子                                       |\n| --------------------------- | ---------------------------------------- | ---------------------------------------- |\n| <span id=\"sdkv\"/>sdkVersion | 标明sdk的版本                                 | 24                                       |\n| databaseVersion             | package database 的版本                     | 24, 对应与绑定volumeUuid的项与sdkVersion相同       |\n| fingerprint                 | 版本信息                                     | SPRD/sp9853i_1h10_vmm_tos/sp9853i_1h10:7.0/NRD90M/W17.31.1N00:userdebug/test-keys |\n| volumeUuid                  | 通过volumeUuid创建VersionInfo信息. 对应内部存储还是外部存储 | da2a94f3-d7f6-489f-b293-5bdb44b8dcc5     |\n\n/data/system/packages.list\n\n```powershell\ncom.android.fmradio 10023 0 /data/user/0/com.android.fmradio platform:privapp 1013,3002,1023,1015,3003\nplugin.sprd.sosForEmergency 10052 0 /data/user/0/plugin.sprd.sosForEmergency default none\ncom.android.cts.priv.ctsshim 10005 0 /data/user/0/com.android.cts.priv.ctsshim default:privapp none\ncom.android.providers.telephony 1001 0 /data/user_de/0/com.android.providers.telephony platform:privapp 3002,3003,3001\ncom.sprd.engineermode 1000 0 /data/user/0/com.sprd.engineermode platform 1013,3002,1023,1015,3003,3001\ncom.android.providers.calendar 10011 0 /data/user/0/com.android.providers.calendar default:privapp 3003\ncom.android.providers.media 10017 0 /data/user/0/com.android.providers.media default:privapp 2001,1023,1015,3003,1024,3007\ncom.android.wallpapercropper 10025 0 /data/user/0/com.android.wallpapercropper platform:privapp none\n```\n\n>   该文件记录了所有已安装apk的简略信息\n\n|         包名          | appid |  用户  |               数据目录               | 包所属的性质(签名+app性质) |           gids           |\n| :-----------------: | :---: | :--: | :------------------------------: | :--------------: | :----------------------: |\n| com.android.fmradio | 10023 |  0   | /data/user/0/com.android.fmradio | platform:privapp | 1013,3002,1023,1015,3003 |\n\n### 1.1.2. 解析属性\n\n获取系统默认配置主要包括两方面：属性系统配置和默认显示参数。\n\n***debug.separate_processes***\n\n用于标记是否在独立进程中运行某个程序。根据其值设置两个全局变量的值，后续ScanDirLI扫描安装APK时需要用到这两个变量，代码如下：\n\n```java\n        String separateProcesses = SystemProperties.get(\"debug.separate_processes\");\n        if (separateProcesses != null && separateProcesses.length() > 0) {\n            if (\"*\".equals(separateProcesses)) {\n                // debug.separate_processes 为*时，解析AndroidManifest时忽略process， 即所有进程都运行在它自己的进程中\n                mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES;\n                mSeparateProcesses = null;\n                Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\");\n            } else {\n                mDefParseFlags = 0;\n                // 不为*时，指定的组件运行在自己进程中\n                mSeparateProcesses = separateProcesses.split(\",\");\n                Slog.w(TAG, \"Running with debug.separate_processes: \"\n                        + separateProcesses);\n            }\n        } else {\n            mDefParseFlags = 0;\n            mSeparateProcesses = null;\n        }\n\n...\n      // separateProcesses = mSeparateProcesses \n      // flags = mDefParseFlags \n      private static String buildProcessName(String pkg, String defProc,\n            CharSequence procSeq, int flags, String[] separateProcesses,\n            String[] outError) {\n        // procSeq 为从AndroidManifest中解析出来的 android:process的名称\n        if ((flags&PARSE_IGNORE_PROCESSES) != 0 && !\"system\".equals(procSeq)) {\n            return defProc != null ? defProc : pkg;\n        }\n        if (separateProcesses != null) {\n            for (int i=separateProcesses.length-1; i>=0; i--) {\n                String sp = separateProcesses[i];\n                if (sp.equals(pkg) || sp.equals(defProc) || sp.equals(procSeq)) {\n                    return pkg;\n                }\n            }\n        }\n        if (procSeq == null || procSeq.length() <= 0) {\n            return defProc;\n        }\n        return buildCompoundName(pkg, procSeq, \"process\", outError);\n    }\n```\n\n获取系统默认显示参数\n\n通过WindowManager获取屏幕默认显示参数，存入一个DiaplayMetrics类型的全局变量PackageManagerService.mMetric中,后续扫描安装时使用该值匹配APK的asset和resource。\n\n```java\n// mMetrics是一个描述界面显示，尺寸，分辨率，密度的类。\ngetDefaultDisplayMetrics(context, mMetrics);\n```\n\n### 1.1.3. dex优化相关\n\n创建dex优化类的实例, mPackageDexOptimizer\n\n```java\nmInstaller = installer;\nmPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context,\n        \"*dexopt*\");\n```\n\n### 1.1.4. SysConfig类构造并初始化\n\n```java\n// 执行systemConfig初始化， 权限、feature sharedLibarys相关，解析一些配置文件，解析后的结果放在  SystemConfig\n// 的 mGlobalGids  mSystemPermissions mAvailableFeatures 列表中\nSystemConfig systemConfig = SystemConfig.getInstance();\nmGlobalGids = systemConfig.getGlobalGids();\nmSystemPermissions = systemConfig.getSystemPermissions();\nmAvailableFeatures = systemConfig.getAvailableFeatures();\n```\n\n初始化SysConfig对象, 主要调用了SysConfig的构造函数\n\n```java\nSystemConfig() {\n    /*\n    解析\n    /system/etc/\n    /odm/etc/\n    /oem/etc/\n    sysconfig  permissions 下的xml文件\n    权限 features 相关\n    */\n    // Read configuration from system\n    readPermissions(Environment.buildPath(\n            Environment.getRootDirectory(), \"etc\", \"sysconfig\"), ALLOW_ALL);\n    // Read configuration from the old permissions dir\n    readPermissions(Environment.buildPath(\n            Environment.getRootDirectory(), \"etc\", \"permissions\"), ALLOW_ALL);\n    // Allow ODM to customize system configs around libs, features and apps\n    int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS;\n    readPermissions(Environment.buildPath(\n            Environment.getOdmDirectory(), \"etc\", \"sysconfig\"), odmPermissionFlag);\n    readPermissions(Environment.buildPath(\n            Environment.getOdmDirectory(), \"etc\", \"permissions\"), odmPermissionFlag);\n    // Only allow OEM to customize features\n    readPermissions(Environment.buildPath(\n            Environment.getOemDirectory(), \"etc\", \"sysconfig\"), ALLOW_FEATURES);\n    readPermissions(Environment.buildPath(\n            Environment.getOemDirectory(), \"etc\", \"permissions\"), ALLOW_FEATURES);\n}\n```\n\n但往往只存在一个目录 **/system/etc/permissions**\n\n```powershell\nsp9832a_2h11:/system/etc/permissions # ls -l\ntotal 224\n-rw-r--r-- 1 root root  820 2017-07-12 00:16 android.hardware.bluetooth.xml\n-rw-r--r-- 1 root root  830 2017-07-12 00:16 android.hardware.bluetooth_le.xml\n-rw-r--r-- 1 root root  931 2017-07-12 00:16 android.hardware.camera.autofocus.xml\n-rw-r--r-- 1 root root 1052 2017-07-12 00:16 android.hardware.camera.flash-autofocus.xml\n-rw-r--r-- 1 root root  877 2017-07-12 00:16 android.hardware.camera.front.xml\n-rw-r--r-- 1 root root  942 2017-07-12 00:16 android.hardware.location.gps.xml\n-rw-r--r-- 1 root root  824 2017-07-12 00:16 android.hardware.sensor.accelerometer.xml\n-rw-r--r-- 1 root root  816 2017-07-12 00:16 android.hardware.sensor.light.xml\n-rw-r--r-- 1 root root  815 2017-07-12 00:16 android.hardware.sensor.proximity.xml\n-rw-r--r-- 1 root root  881 2017-07-12 00:16 android.hardware.telephony.gsm.xml\n-rw-r--r-- 1 root root 1035 2017-07-12 00:16 android.hardware.touchscreen.multitouch.xml\n-rw-r--r-- 1 root root  909 2017-07-12 00:16 android.hardware.touchscreen.xml\n-rw-r--r-- 1 root root  975 2017-07-12 00:16 android.hardware.usb.accessory.xml\n-rw-r--r-- 1 root root  868 2017-07-12 00:16 android.hardware.usb.host.xml\n-rw-r--r-- 1 root root  843 2017-07-12 00:16 android.hardware.wifi.direct.xml\n-rw-r--r-- 1 root root  829 2017-07-12 00:16 android.hardware.wifi.xml\n-rw-r--r-- 1 root root 1050 2017-07-12 00:11 android.software.live_wallpaper.xml\n-rw-r--r-- 1 root root  860 2017-07-12 00:16 android.software.managed_users.xml\n-rw-r--r-- 1 root root  745 2017-07-12 00:16 android.software.midi.xml\n-rw-r--r-- 1 root root  748 2017-07-12 00:16 android.software.webview.xml\n-rw-r--r-- 1 root root  828 2017-07-12 00:14 com.android.location.provider.xml\n-rw-r--r-- 1 root root  828 2017-07-12 00:14 com.android.media.remotedisplay.xml\n-rw-r--r-- 1 root root  820 2017-07-12 00:14 com.android.mediadrm.signer.xml\n-rw-r--r-- 1 root root 4188 2017-07-12 00:16 handheld_core_hardware.xml\n-rw-r--r-- 1 root root 8467 2017-07-12 00:14 platform.xml\n```\n\n其中比较重要的文件是 **platform.xml **\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Copyright (C) 2008 The Android Open Source Project\n Licensed under the Apache License, Version 2.0 (the \"License\");\n...\n -->\n<permissions>\n<!-- The following tags are associating low-level group IDs with\n     permission names.  By specifying such a mapping, you are saying\n     that any application process granted the given permission will\n     also be running with the given group ID attached to its process,\n     so it can perform any filesystem (read, write, execute) operations\n     allowed for that group. -->\n\n<permission name=\"android.permission.BLUETOOTH_ADMIN\" >\n    <group gid=\"net_bt_admin\" />\n</permission>\n\n<permission name=\"android.permission.BLUETOOTH\" >\n    <group gid=\"net_bt\" />\n</permission>\n...\n<permission name=\"android.permission.WRITE_MEDIA_STORAGE\" >\n    <group gid=\"media_rw\" />\n    <group gid=\"sdcard_rw\" />\n</permission>\n\n<permission name=\"android.permission.ACCESS_MTP\" >\n    <group gid=\"mtp\" />\n</permission>\n\n<permission name=\"android.permission.NET_ADMIN\" >\n    <group gid=\"net_admin\" />\n</permission>\n\n<!-- The group that /cache belongs to, linked to the permission\n     set on the applications that can access /cache -->\n<permission name=\"android.permission.ACCESS_CACHE_FILESYSTEM\" >\n    <group gid=\"cache\" />\n</permission>\n\n<!-- RW permissions to any system resources owned by group 'diag'.\n     This is for carrier and manufacture diagnostics tools that must be\n     installable from the framework. Be careful. -->\n<permission name=\"android.permission.DIAGNOSTIC\" >\n    <group gid=\"input\" />\n    <group gid=\"diag\" />\n</permission>\n\n<!-- Group that can read detailed network usage statistics -->\n<permission name=\"android.permission.READ_NETWORK_USAGE_HISTORY\">\n    <group gid=\"net_bw_stats\" />\n</permission>\n\n<!-- Group that can modify how network statistics are accounted -->\n<permission name=\"android.permission.MODIFY_NETWORK_ACCOUNTING\">\n    <group gid=\"net_bw_acct\" />\n</permission>\n\n<permission name=\"android.permission.LOOP_RADIO\" >\n    <group gid=\"loop_radio\" />\n</permission>\n\n<!-- Hotword training apps sometimes need a GID to talk with low-level\n     hardware; give them audio for now until full HAL support is added. -->\n<permission name=\"android.permission.MANAGE_VOICE_KEYPHRASES\">\n    <group gid=\"audio\" />\n</permission>\n\n<permission name=\"android.permission.ACCESS_FM_RADIO\" >\n    <!-- /dev/fm is gid media, not audio -->\n    <group gid=\"media\" />\n</permission>\n\n<!-- These are permissions that were mapped to gids but we need\n     to keep them here until an upgrade from L to the current\n     version is to be supported. These permissions are built-in\n     and in L were not stored in packages.xml as a result if they\n     are not defined here while parsing packages.xml we would\n     ignore these permissions being granted to apps and not\n     propagate the granted state. From N we are storing the\n     built-in permissions in packages.xml as the saved storage\n     is negligible (one tag with the permission) compared to\n     the fragility as one can remove a built-in permission which\n     no longer needs to be mapped to gids and break grant propagation. -->\n<permission name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n\n<!-- ================================================================== -->\n<!-- ================================================================== -->\n<!-- ================================================================== -->\n\n<!-- The following tags are assigning high-level permissions to specific\n     user IDs.  These are used to allow specific core system users to\n     perform the given operations with the higher-level framework.  For\n     example, we give a wide variety of permissions to the shell user\n     since that is the user the adb shell runs under and developers and\n     others should have a fairly open environment in which to\n     interact with the system. -->\n\n<assign-permission name=\"android.permission.MODIFY_AUDIO_SETTINGS\" uid=\"media\" />\n<assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\" uid=\"media\" />\n<assign-permission name=\"android.permission.WAKE_LOCK\" uid=\"media\" />\n<assign-permission name=\"android.permission.UPDATE_DEVICE_STATS\" uid=\"media\" />\n<assign-permission name=\"android.permission.UPDATE_APP_OPS_STATS\" uid=\"media\" />\n<assign-permission name=\"android.permission.GET_PROCESS_STATE_AND_OOM_SCORE\" uid=\"media\" />\n\n<assign-permission name=\"android.permission.MODIFY_AUDIO_SETTINGS\" uid=\"cameraserver\" />\n<assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\" uid=\"cameraserver\" />\n<assign-permission name=\"android.permission.WAKE_LOCK\" uid=\"cameraserver\" />\n<assign-permission name=\"android.permission.UPDATE_DEVICE_STATS\" uid=\"cameraserver\" />\n<assign-permission name=\"android.permission.UPDATE_APP_OPS_STATS\" uid=\"cameraserver\" />\n\n<assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\" uid=\"graphics\" />\n\n<!-- This is a list of all the libraries available for application\n     code to link against. -->\n\n<library name=\"android.test.runner\"\n        file=\"/system/framework/android.test.runner.jar\" />\n<library name=\"javax.obex\"\n        file=\"/system/framework/javax.obex.jar\" />\n<library name=\"org.apache.http.legacy\"\n        file=\"/system/framework/org.apache.http.legacy.jar\" />\n\n<!-- These are the standard packages that are white-listed to always have internet\n     access while in power save mode, even if they aren't in the foreground. -->\n<!-- 白名单中的应用始终可以访问网络,即使是在省电模式下,且并不在前台也可以 -->\n<allow-in-power-save package=\"com.android.providers.downloads\" />\n\n<!-- These are the standard packages that are white-listed to always have internet\n     access while in data mode, even if they aren't in the foreground. -->\n\n<!-- 白名单中的应用始终可以访问网络,即使是节省流量模式下，仍可访问网络,且并不在前台也可以 -->\n<allow-in-data-usage-save package=\"com.android.providers.downloads\" />\n\n<!-- These are the packages that are white-listed to be able to run as system user -->\n<system-user-whitelisted-app package=\"com.android.settings\" />\n\n<!-- These are the packages that shouldn't run as system user -->\n<system-user-blacklisted-app package=\"com.android.wallpaper.livepicker\" />\n</permissions>\n```\n每一个XML文件必须要有一个顶级标签`<permissions>`，至于子标签，可以支持这么几种：\n\n| 标签                                       | 作用                                       | 关联的数据结构                     |\n| ---------------------------------------- | ---------------------------------------- | --------------------------- |\n| <span id=\"perm\"></span>permission标签      | 指定permission所属的gid,通过gid实现native层的权限控制;可以指定一个权限与几个组id对应,当一个apk被授予这个权限时,它也同时属于这几个组,拥有这几个组id了 | perm.gids                   |\n| group标签                                  | 安装到系统中的apk都具有的组id                        | mGlobalGids                 |\n| assign-permission                        | 把一个权限赋予一个UID，当进程使用这个UID运行时，就具备了这个权限      | mSystemPermissions          |\n| <span id=\"lib\"></span>                                     library | 为系统添加一些扩展库用的。对应的.jar文件放在/system/framework/目录下。 | mSharedLibraries            |\n| feature                                  | 每添加一个硬件，都要增加对应的feature                   | mAvailableFeatures          |\n| unavailable-feature                      | 保存不支持的feature                            | mUnavailableFeatures        |\n| allow-in-power-save                      | 白名单中的应用始终可以访问网络,即使是在省电模式下,且并不在前台也可以      | mAllowInPowerSave           |\n| allow-in-power-save-except-idle          | 保存省电模式下(非Idle)，可上网的应用                    | mAllowInPowerSaveExceptIdle |\n| allow-in-data-usage-save                 | 白名单中的应用始终可以访问网络,即使是节省流量模式下，仍可访问网络,且并不在前台也可以 | mAllowInDataUsageSave       |\n| system-user-whitelisted-app              | 指定以system user权限运行的app                   | mSystemUserWhitelistedApps  |\n| system-user-blacklisted-app              | 指定在system user权限下，不应该运行的app              | mSystemUserBlacklistedApp   |\n| default-enabled-vr-app                   | 指定默认运行在VR模式下的components                  | mDefaultVrComponents        |\n| backup-transport-whitelisted-service     | 保存能够传输备份数据的服务                            | mBackupTransportWhitelist   |\n\n对这些XML文件的解析是由/framework/base/services/java/com/android/server/PackageManagerService.java中的**readPermissions()**负责的。解析时会先解析其它XML文件，最后解析platform.xml。\n\n解析结果放入`mSystemPermissions`,`mSharedLibraries`,`mPermissions`,`mAvailableFeatures`等几个集合中供系统查询和权限配置使用。\n\n像重力加速、多点触摸、WIFI等，只要系统支持，就要往**/system/etc/permissions/**下面添加对应的XML配置文件。因为APK使用这些功能之前很有可能先调用**PackageManager.hasSystemFeature**查询是否支持这个某个硬件模块。\n\n/framework/base/data/etc/`handheld_core_hardware.xml`里面包含了一些系统的核心硬件模块配置文件。/framework/base/data/etc/Android.mk中会把这一块儿在编译时复制到/system/etc/permissions/目录下。这部分代码默认是关闭的，需要打开。\n\n\n```java\nprivate void readPermissionsFromXml(File permFile, int permissionFlag) {\n  FileReader permReader = null;\n  try {\n    //利用file构造fileReader\n    permReader = new FileReader(permFile);\n  } catch (FileNotFoundException e) {\n    .......\n  }\n  //读取系统属性\"ro.config.low_ram\"，如果该属性为true，不会加载指定notLowRam的feature属性\n  final boolean lowRam = ActivityManager.isLowRamDeviceStatic();\n\n  try {\n    XmlPullParser parser = Xml.newPullParser();\n    //Xml解析器的输入为fileReader读取的内容\n    parser.setInput(permReader);\n\n    //找到解析的起点\n    .........\n\n    //根据传入的flag，决定当前目录下，从xml文件中解析内容的范围\n    //对于system目录，allowAll\n    boolean allowAll = permissionFlag == ALLOW_ALL;\n    boolean allowLibs = (permissionFlag & ALLOW_LIBS) != 0;\n    boolean allowFeatures = (permissionFlag & ALLOW_FEATURES) != 0;\n    boolean allowPermissions = (permissionFlag & ALLOW_PERMISSIONS) != 0;\n    boolean allowAppConfigs = (permissionFlag & ALLOW_APP_CONFIGS) != 0;\n    while (true) {\n      XmlUtils.nextElement(parser);\n      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {\n        break;\n      }\n\n      String name = parser.getName();\n      //解析group标签，前面介绍的xml文件中没有单独使用该标签的地方\n      if (\"group\".equals(name) && allowAll) {\n        String gidStr = parser.getAttributeValue(null, \"gid\");\n        if (gidStr != null) {\n          //将Gid字符串转化成整形，保存到mGlobalGids中\n          int gid = android.os.Process.getGidForName(gidStr);\n          mGlobalGids = appendInt(mGlobalGids, gid);\n        } else {\n          .........\n        }\n        XmlUtils.skipCurrentTag(parser);\n        continue;\n      } else if (\"permission\".equals(name) && allowPermissions) {\n        String perm = parser.getAttributeValue(null, \"name\");\n        .......\n          perm = perm.intern();\n        //调用readPermission解析permission标签\n        readPermission(parser, perm);\n      } else if (\"assign-permission\".equals(name) && allowPermissions) {\n        //得到权限名\n        String perm = parser.getAttributeValue(null, \"name\");\n        ........\n          //得到uid字符串\n          String uidStr = parser.getAttributeValue(null, \"uid\");\n        ......\n          //将uid字符串转变为整形\n          int uid = Process.getUidForName(uidStr);\n        .......\n          perm = perm.intern();\n        //得到保存uid当前已有的所有权限的ArraySet\n        ArraySet<string> perms = mSystemPermissions.get(uid);\n        if (perms == null) {\n          perms = new ArraySet<string>();\n          mSystemPermissions.put(uid, perms);\n        }\n        //将uid新增的权限，加入到它的ArraySet\n        perms.add(perm);\n        XmlUtils.skipCurrentTag(parser);\n      } else if (\"library\".equals(name) && allowLibs) {\n        String lname = parser.getAttributeValue(null, \"name\");\n        String lfile = parser.getAttributeValue(null, \"file\");\n\n        if (lname == null) {\n          ......\n        } else if (lfile == null) {\n          .....\n        } else {\n          //保存library标签对应的内容\n          mSharedLibraries.put(lname, lfile);\n        }\n      } else if (\"feature\".equals(name) && allowFeatures) {\n        String fname = parser.getAttributeValue(null, \"name\");\n        int fversion = XmlUtils.readIntAttribute(parser, \"version\", 0);\n\n        if (!lowRam) {\n          allowed = true;\n        } else {\n          //内存不足时，指定notLowRam的feature不再加载\n          String notLowRam = parser.getAttributeValue(null, \"notLowRam\");\n          allowed = !\"true\".equals(notLowRam);\n        }\n\n        if (fname == null) {\n          .....\n        } else if (allowed) {\n          //将feature构造成featureInfo，加入到mAvailableFeatures对象中\n          addFeature(fname, fversion);\n        }\n        .......\n      } else if (\"unavailable-feature\".equals(name) && allowFeatures) {\n        //mUnavailableFeatures保存不支持的feature\n        .........\n      } else if (\"allow-in-power-save-except-idle\".equals(name) && allowAll) {\n        // These are the packages that are white-listed to be able to run in the\n        // background while in power save mode (but not whitelisted from device idle modes),\n        // as read from the configuration files.\n        //mAllowInPowerSaveExceptIdle中保存省电模式下(非Idle)，可上网的应用\n        .........\n      } else if (\"allow-in-power-save\".equals(name) && allowAll) {\n        // These are the packages that are white-listed to be able to run in the\n        // background while in power save mode, as read from the configuration files.\n        //mAllowInPowerSave与mAllowInPowerSaveExceptIdle类似，权限更高\n        //这与Android M新特性Doze and App Standby模式有关\n        //DeviceIdleController用于判断设备是否进入Idle状态，进入Idle状态时，mAllowInPowerSaveExceptIdle中的应用要被禁掉\n        //但mAllowInPowerSave中的应用仍可运行\n        ............\n      } else if (\"allow-in-data-usage-save\".equals(name) && allowAll) {\n        // These are the packages that are white-listed to be able to run in the\n        // background while in data-usage save mode, as read from the configuration files.\n        //mAllowInDataUsageSave保存此标签对应的packageName\n        //貌似android 7新增了一个节省数据流量的能力，有此标签的应用在节省数据流量时，仍可访问网络\n        ............\n      } else if (\"app-link\".equals(name) && allowAppConfigs) {\n        // These are the package names of apps which should be in the 'always'\n        // URL-handling state upon factory reset.\n        //mLinkedApps保存此标签对应的packageName\n        //这个不太明白，好像是指定可以一直处于URL-handling state的app\n        .......\n      } else if (\"system-user-whitelisted-app\".equals(name) && allowAppConfigs) {\n        // These are the packages that are whitelisted to be able to run as system user\n        //mSystemUserWhitelistedApps保存此标签对应的packageName\n        //指定以system user权限运行的app\n        .......\n      } else if (\"system-user-blacklisted-app\".equals(name) && allowAppConfigs) {\n        // These are the packages that should not run under system user\n        //mSystemUserBlacklistedApp保存此标签对应的packageName\n        //指定在system user权限下，不应该运行的app\n        .........\n      }else if (\"default-enabled-vr-app\".equals(name) && allowAppConfigs) {\n        // These are the components that are enabled by default as VR mode listener services.\n        //mDefaultVrComponents保存此标签对应的packageName\n        //指定默认运行在VR模式下的components\n        .......\n      } else if (\"backup-transport-whitelisted-service\".equals(name) && allowFeatures) {\n        // These are the permitted backup transport service components\n        //mBackupTransportWhitelist保存此标签对应的packageName\n        //保存能够传输备份数据的服务\n        ........\n      } else {\n        .......\n      }\n    }\n  } catch (XmlPullParserException e) {PullParserException e) {\n    .......\n  } catch (IOException e) {\n    .......\n  } finally {\n    IoUtils.closeQuietly(permReader);\n  }\n\n  // Some devices can be field-converted to FBE, so offer to splice in\n  // those features if not already defined by the static config\n  //加密相关的feature\n  if (StorageManager.isFileEncryptedNativeOnly()) {\n    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION, 0);\n    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS, 0);\n  }\n\n  for (String featureName : mUnavailableFeatures) {\n    //从mAvailableFeatures移除不支持的feature\n    removeFeature(featureName);\n  }\n}\n```\n\n从上面的代码可以看出`readPermissions`函数就是将xml文件中的标签转换成对应的数据结构，此处重要的是理解各种标签的作用。\n对于**”permission”**标签，还调用了`readPermission`函数：\n\n```java\nvoid readPermission(XmlPullParser parser, String name)\n        throws IOException, XmlPullParserException {\n    if (mPermissions.containsKey(name)) {\n        throw new IllegalStateException(\"Duplicate permission definition for \" + name);\n    }\n \n    final boolean perUser = XmlUtils.readBooleanAttribute(parser, \"perUser\", false);\n    final PermissionEntry perm = new PermissionEntry(name, perUser);\n    //将permission name和permissionEntry结合起来\n    mPermissions.put(name, perm);\n    ........\n    while(.....) {\n        .......\n        String tagName = parser.getName();\n        if (\"group\".equals(tagName)) {\n            String gidStr = parser.getAttributeValue(null, \"gid\");\n            if (gidStr != null) {\n                int gid = Process.getGidForName(gidStr);\n                //对应gid存入permissionEntry结构体中，于是permission name与gid对应起来\n                perm.gids = appendInt(perm.gids, gid);\n            } else {\n                ......\n            }\n        }\n        .......\n    }\n}\n```\n\n![20160929092228476](../images/20160929092228476.jpg)\n\n### 1.1.5. 初始化PackageHandler\n\n**PackageHandler**是PackageManagerService的内部类，它是Handler的子类。PackageManagerService启动时开启了Looper线程HandlerThread，使用HandlerThread的Looper对象与PackageHandler建立联系，负责轮询和分发处理消息。\n\n```java\n// 新建一个Thread,用来和PackageHandler绑定\nmHandlerThread = new ServiceThread(TAG,\n        Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);\nmHandlerThread.start();\nmHandler = new PackageHandler(mHandlerThread.getLooper());\n```\n>通过PackageHandler处理的消息\n```xml\nINIT_COPY\nMCS_BOUND\nMCS_RECONNECT\nMCS_UNBIND\nMCS_GIVE_UP\nSEND_PENDING_BROADCAST\nSTART_CLEANING_PACKAGE\nPOST_INSTALL\nUPDATED_MEDIA_STATUS\nWRITE_SETTINGS\nWRITE_PACKAGE_RESTRICTIONS\nWRITE_PACKAGE_LIST\nCHECK_PENDING_VERIFICATION\nPACKAGE_VERIFIED\nSTART_INTENT_FILTER_VERIFICATIONS\nINTENT_FILTER_VERIFIED\n```\nPackageHandler主要负责处理APK的复制和更名等相关的消息，但具体的处理则通过**connectToService**方法连接到**DefaulyContainerService**.apk，由它提供的**MCS**服务完成。\n\n```java\nfinal private DefaultContainerConnection mDefContainerConn =\n        new DefaultContainerConnection();\nclass DefaultContainerConnection implements ServiceConnection {\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        if (DEBUG_SD_INSTALL) Log.i(TAG, \"onServiceConnected\");\n        IMediaContainerService imcs =\n            IMediaContainerService.Stub.asInterface(service);\n        mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs));\n    }\n\n    public void onServiceDisconnected(ComponentName name) {\n        if (DEBUG_SD_INSTALL) Log.i(TAG, \"onServiceDisconnected\");\n    }\n}\n\nprivate boolean connectToService() {\n  if (DEBUG_SD_INSTALL) Log.i(TAG, \"Trying to bind to\" +\n                              \" DefaultContainerService\");\n  Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);\n  Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n  // bind DefaultContainerService\n  if (mContext.bindServiceAsUser(service, mDefContainerConn,\n                                 Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n    mBound = true;\n    return true;\n  }\n  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n  return false;\n}\n```\n![DefContainerSercice](/images/DefContainerSercice.png)\n\n### 1.1.6. 初始化UserManagerService, 并创建用户目录\n\n```java\nFile dataDir = Environment.getDataDirectory();\nmAppInstallDir = new File(dataDir, \"app\");\nmAppLib32InstallDir = new File(dataDir, \"app-lib\");\nmEphemeralInstallDir = new File(dataDir, \"app-ephemeral\");\nmAsecInternalPath = new File(dataDir, \"app-asec\").getPath();\nmDrmAppPrivateInstallDir = new File(dataDir, \"app-private\");\nsUserManager = new UserManagerServiceEx(context, this, mPackages);\n```\n\nØ mAppDataDir：初始化为/data/data\n\nØ mAppInstallDir：初始化为/data/app\n\nØ mAppLibInstallDir：初始化为/data/app-lib\n\nØ mAsecInternalPath：初始化为/data/app-asec的路径信息\n\nØ mDrmAppPrivateInstallDir：初始化为/data/app-private\n\nØ mUserAppDataDir：初始化为/data/user\n\nØ mDeletedRecord：初始化为/data/app/.delrecord\n\n#### 1.1.6.1. UserManagerService初始化\n\n```java\nprivate UserManagerService(Context context, PackageManagerService pm,\n        Object packagesLock, File dataDir) {\n    mContext = context;\n    mPm = pm;\n    mPackagesLock = packagesLock;\n    mHandler = new MainHandler();\n    synchronized (mPackagesLock) {\n        // 创建/data/system/users\n        mUsersDir = new File(dataDir, USER_INFO_DIR);\n        mUsersDir.mkdirs();\n        // Make zeroth user directory, for services to migrate their files to that location\n        // 创建/data/system/users/0\n        File userZeroDir = new File(mUsersDir, String.valueOf(UserHandle.USER_SYSTEM));\n        userZeroDir.mkdirs();\n        FileUtils.setPermissions(mUsersDir.toString(),\n                FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH,\n                -1, -1);\n        // /data/system/users/userlist.xml\n        mUserListFile = new File(mUsersDir, USER_LIST_FILENAME);\n        initDefaultGuestRestrictions();\n        // 该函数比较重要,解析userlist.xml和<id>.xml文件；并清理不完整用户\n        readUserListLP();\n        sInstance = this;\n    }\n    mLocalService = new LocalService();\n    LocalServices.addService(UserManagerInternal.class, mLocalService);\n    // 锁屏相关服务初始化\n    mLockPatternUtils = new LockPatternUtils(mContext);\n    // 机主用户初始状态为STATE_BOOTING\n    mUserStates.put(UserHandle.USER_SYSTEM, UserState.STATE_BOOTING);\n}\n```\n通过readUserListLP函数创建或解析 /data/system/users/0.xml 和 userlist.xml\n```powershell\nsp9832a_2h11:/data/system/users # cat userlist.xml                    \n```\n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<users nextSerialNumber=\"10\" version=\"6\">\n    <guestRestrictions>\n        <!--访客限制-->\n        <restrictions no_sms=\"true\" no_install_unknown_sources=\"true\" no_config_wifi=\"true\" no_outgoing_calls=\"true\" />\n    </guestRestrictions>\n    <globalRestrictionOwnerUserId id=\"-10000\" />\n    <user id=\"0\" />\n</users>\n```\n\n```powershell\nsp9832a_2h11:/data/system/users # cat 0.xml\n```\n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<user id=\"0\" serialNumber=\"0\" flags=\"19\" created=\"0\" lastLoggedIn=\"1325377476475\" lastLoggedInFingerprint=\"SPRD/sp9832a_2h11_4mvoltesea_tee/sp9832a_2h11:7.0/NRD90M/W17.28.3N00:userdebug/test-keys\">\n    <restrictions />\n    <device_policy_restrictions />\n</user>\n```\n\n```java\nprivate void readUserListLP() {\n    // 如果/data/system/users/userlist.xml  文件不存在, 调用fallbackToSingleUserLP函数创建单用户\n    if (!mUserListFile.exists()) {\n        fallbackToSingleUserLP();\n        return;\n    }\n    ...\n    AtomicFile userListFile = new AtomicFile(mUserListFile);\n    try {\n        fis = userListFile.openRead();\n        ...\n        // xml 文件损坏, 也回滚调用fallbackToSingleUserLP函数创建单用户\n        if (type != XmlPullParser.START_TAG) {\n            Slog.e(LOG_TAG, \"Unable to read user list\");\n            fallbackToSingleUserLP();\n            return;\n        }\n\n        mNextSerialNumber = -1;\n        // users标签\n        if (parser.getName().equals(TAG_USERS)) {\n            String lastSerialNumber = parser.getAttributeValue(null, ATTR_NEXT_SERIAL_NO);\n            if (lastSerialNumber != null) {\n                mNextSerialNumber = Integer.parseInt(lastSerialNumber);\n            }\n            String versionNumber = parser.getAttributeValue(null, ATTR_USER_VERSION);\n            if (versionNumber != null) {\n                mUserVersion = Integer.parseInt(versionNumber);\n            }\n        }\n\n        final Bundle newDevicePolicyGlobalUserRestrictions = new Bundle();\n\n        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {\n            if (type == XmlPullParser.START_TAG) {\n                final String name = parser.getName();\n                // user标签\n                if (name.equals(TAG_USER)) {\n                    String id = parser.getAttributeValue(null, ATTR_ID);\n\t\t\t\t\t// 根据其user id值,嵌套读取对应的/data/system/users/<id>.xml文件,返回UserData对象\n                    UserData userData = readUserLP(Integer.parseInt(id));\n\n                    if (userData != null) {\n                        synchronized (mUsersLock) {\n                           // 将UserData对象放入mUsers SparseArray中\n                            mUsers.put(userData.info.id, userData);\n                            if (mNextSerialNumber < 0\n                                    || mNextSerialNumber <= userData.info.id) {\n                                mNextSerialNumber = userData.info.id + 1;\n                            }\n                        }\n                    }\n                } else if (name.equals(TAG_GUEST_RESTRICTIONS)) {\n                    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                            && type != XmlPullParser.END_TAG) {\n                        if (type == XmlPullParser.START_TAG) {\n                            if (parser.getName().equals(TAG_RESTRICTIONS)) {\n                                synchronized (mGuestRestrictions) {\n                                    // 访客限制\n                                    UserRestrictionsUtils\n                                            .readRestrictions(parser, mGuestRestrictions);\n                                }\n                            } else if (parser.getName().equals(TAG_DEVICE_POLICY_RESTRICTIONS)\n                                    ) {\n                                UserRestrictionsUtils.readRestrictions(parser,\n                                        newDevicePolicyGlobalUserRestrictions);\n                            }\n                            break;\n                        }\n                    }\n                } else if (name.equals(TAG_GLOBAL_RESTRICTION_OWNER_ID)) {\n                    String ownerUserId = parser.getAttributeValue(null, ATTR_ID);\n                    if (ownerUserId != null) {\n                        mGlobalRestrictionOwnerUserId = Integer.parseInt(ownerUserId);\n                    }\n                }\n            }\n        }\n        synchronized (mRestrictionsLock) {\n            mDevicePolicyGlobalUserRestrictions = newDevicePolicyGlobalUserRestrictions;\n        }\n        // 根据UserData.info.partial信息确定用户信息是否完整, 只有完整的才放入mUserIds的数组中\n        updateUserIds();\n        upgradeIfNecessaryLP();\n        //SPRD: add protection mechanism for power-test @{\n        // 机主用户找不到, 回滚创建单用户\n        if(mUsers.get(UserHandle.USER_SYSTEM) == null){\n            fallbackToSingleUserLP();\n        }\n        // @}\n    } catch (IOException | XmlPullParserException e) {\n        fallbackToSingleUserLP();\n    } finally {\n        IoUtils.closeQuietly(fis);\n    }\n}\n```\n在解析过程中用到了UserData  UserInfo info类，它用于保存用户信息，包含用户id、用户名name以及用户类型标记三部分，其中用户类型分为私有用户、管理员用户和guest用户。\n\n>   通过readUserLP函数从id.xml文件中创建出UserData数据\n\n```java\nprivate UserData readUserLP(int id) {\n    int flags = 0;\n    int serialNumber = id;\n    String name = null;\n    String account = null;\n    String iconPath = null;\n    long creationTime = 0L;\n    long lastLoggedInTime = 0L;\n    String lastLoggedInFingerprint = null;\n    int profileGroupId = UserInfo.NO_PROFILE_GROUP_ID;\n    int restrictedProfileParentId = UserInfo.NO_PROFILE_GROUP_ID;\n    boolean partial = false;\n    boolean guestToRemove = false;\n    boolean persistSeedData = false;\n    String seedAccountName = null;\n    String seedAccountType = null;\n    PersistableBundle seedAccountOptions = null;\n    Bundle baseRestrictions = new Bundle();\n    Bundle localRestrictions = new Bundle();\n\n    FileInputStream fis = null;\n    try {\n        // /data/system/users/<id>.xml文件\n        AtomicFile userFile =\n                new AtomicFile(new File(mUsersDir, Integer.toString(id) + XML_SUFFIX));\n        fis = userFile.openRead();\n        XmlPullParser parser = Xml.newPullParser();\n        parser.setInput(fis, StandardCharsets.UTF_8.name());\n        int type;\n...\n        // user id标签\n        if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_USER)) {\n            int storedId = readIntAttribute(parser, ATTR_ID, -1);\n            // id 与传入的id不对应,直接返回\n            if (storedId != id) {\n                Slog.e(LOG_TAG, \"User id does not match the file name\");\n                return null;\n            }\n            serialNumber = readIntAttribute(parser, ATTR_SERIAL_NO, id);\n            flags = readIntAttribute(parser, ATTR_FLAGS, 0);\n            iconPath = parser.getAttributeValue(null, ATTR_ICON_PATH);\n            creationTime = readLongAttribute(parser, ATTR_CREATION_TIME, 0);\n            lastLoggedInTime = readLongAttribute(parser, ATTR_LAST_LOGGED_IN_TIME, 0);\n            lastLoggedInFingerprint = parser.getAttributeValue(null,\n                    ATTR_LAST_LOGGED_IN_FINGERPRINT);\n            profileGroupId = readIntAttribute(parser, ATTR_PROFILE_GROUP_ID,\n                    UserInfo.NO_PROFILE_GROUP_ID);\n            restrictedProfileParentId = readIntAttribute(parser,\n                    ATTR_RESTRICTED_PROFILE_PARENT_ID, UserInfo.NO_PROFILE_GROUP_ID);\n            String valueString = parser.getAttributeValue(null, ATTR_PARTIAL);\n            if (\"true\".equals(valueString)) {\n                partial = true;\n            }\n            valueString = parser.getAttributeValue(null, ATTR_GUEST_TO_REMOVE);\n            if (\"true\".equals(valueString)) {\n                guestToRemove = true;\n            }\n\n            seedAccountName = parser.getAttributeValue(null, ATTR_SEED_ACCOUNT_NAME);\n            seedAccountType = parser.getAttributeValue(null, ATTR_SEED_ACCOUNT_TYPE);\n            if (seedAccountName != null || seedAccountType != null) {\n                persistSeedData = true;\n            }\n\n            int outerDepth = parser.getDepth();\n            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n                   && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n                    continue;\n                }\n                String tag = parser.getName();\n                if (TAG_NAME.equals(tag)) {\n                    type = parser.next();\n                    if (type == XmlPullParser.TEXT) {\n                        name = parser.getText();\n                    }\n                } else if (TAG_RESTRICTIONS.equals(tag)) {\n                    UserRestrictionsUtils.readRestrictions(parser, baseRestrictions);\n                } else if (TAG_DEVICE_POLICY_RESTRICTIONS.equals(tag)) {\n                    UserRestrictionsUtils.readRestrictions(parser, localRestrictions);\n                } else if (TAG_ACCOUNT.equals(tag)) {\n                    type = parser.next();\n                    if (type == XmlPullParser.TEXT) {\n                        account = parser.getText();\n                    }\n                } else if (TAG_SEED_ACCOUNT_OPTIONS.equals(tag)) {\n                    seedAccountOptions = PersistableBundle.restoreFromXml(parser);\n                    persistSeedData = true;\n                }\n            }\n        }\n\n        // Create the UserInfo object that gets passed around\n        UserInfo userInfo = new UserInfo(id, name, iconPath, flags);\n        userInfo.serialNumber = serialNumber;\n        userInfo.creationTime = creationTime;\n        userInfo.lastLoggedInTime = lastLoggedInTime;\n        userInfo.lastLoggedInFingerprint = lastLoggedInFingerprint;\n        userInfo.partial = partial;\n        userInfo.guestToRemove = guestToRemove;\n        userInfo.profileGroupId = profileGroupId;\n        userInfo.restrictedProfileParentId = restrictedProfileParentId;\n\n        // Create the UserData object that's internal to this class\n        UserData userData = new UserData();\n        userData.info = userInfo;\n        userData.account = account;\n        userData.seedAccountName = seedAccountName;\n        userData.seedAccountType = seedAccountType;\n        userData.persistSeedData = persistSeedData;\n        userData.seedAccountOptions = seedAccountOptions;\n\n        synchronized (mRestrictionsLock) {\n            mBaseUserRestrictions.put(id, baseRestrictions);\n            mDevicePolicyLocalUserRestrictions.put(id, localRestrictions);\n        }\n        return userData;\n    } catch (IOException ioe) {\n    } catch (XmlPullParserException pe) {\n    } finally {\n        if (fis != null) {\n            try {\n                fis.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n    return null;\n}\n```\n>   fallbackToSingleUserLP 函数初始化用户信息,并创建id.xml文件和userlist.xml文件\n\n```java\nprivate void fallbackToSingleUserLP() {\n    int flags = UserInfo.FLAG_INITIALIZED;\n    // In split system user mode, the admin and primary flags are assigned to the first human\n    // user.\n    if (!UserManager.isSplitSystemUser()) {\n        flags |= UserInfo.FLAG_ADMIN | UserInfo.FLAG_PRIMARY;\n    }\n    // Create the system user\n    UserInfo system = new UserInfo(UserHandle.USER_SYSTEM, null, null, flags);\n    UserData userData = new UserData();\n    userData.info = system;\n    // 将创建的机主用户加入到mUsers中\n    synchronized (mUsersLock) {\n        mUsers.put(system.id, userData);\n    }\n    mNextSerialNumber = MIN_USER_ID;\n    mUserVersion = USER_VERSION;\n\n    Bundle restrictions = new Bundle();\n    synchronized (mRestrictionsLock) {\n        mBaseUserRestrictions.append(UserHandle.USER_SYSTEM, restrictions);\n    }\n\n    updateUserIds();\n    initDefaultGuestRestrictions();\n    // 创建 /data/system/users/0.xml\n    writeUserLP(userData);\n    // 创建 /data/system/users/userlist.xml文件\n    writeUserListLP();\n}\n```\n\n#### 1.1.6.2. **清理部分创建/删除的用户**\n\n根据UserInfo.**partial**属性的值，将不完整的用户信息放入UserManagerService.partials成员变量中，然后调用**cleanupPartialUsers**方法执行清理动作。\n\nonBootPhase阶段清理不完整的用户信息\n\n```java\nvoid cleanupPartialUsers() {\n    // Prune out any partially created, partially removed and ephemeral users.\n    ArrayList<UserInfo> partials = new ArrayList<>();\n    synchronized (mUsersLock) {\n        final int userSize = mUsers.size();\n        for (int i = 0; i < userSize; i++) {\n            UserInfo ui = mUsers.valueAt(i).info;\n            if ((ui.partial || ui.guestToRemove || ui.isEphemeral()) && i != 0) {\n                partials.add(ui);\n            }\n        }\n    }\n    final int partialsSize = partials.size();\n    for (int i = 0; i < partialsSize; i++) {\n        UserInfo ui = partials.get(i);\n        Slog.w(LOG_TAG, \"Removing partially created user \" + ui.id\n                + \" (name=\" + ui.name + \")\");\n        // 调用removeUserState清除不完整的用户信息\n        removeUserState(ui.id);\n    }\n}\n```\n\n直接看removeUserState函数\n\n```java\nprivate void removeUserState(final int userHandle) {\n    try {\n        // 加密相关. 清除用户的锁屏密码\n        mContext.getSystemService(StorageManager.class).destroyUserKey(userHandle);\n    } catch (IllegalStateException e) {\n        // This may be simply because the user was partially created.\n        Slog.i(LOG_TAG,\n            \"Destroying key for user \" + userHandle + \" failed, continuing anyway\", e);\n    }\n\n    // Cleanup gatekeeper secure user id\n    try {\n        final IGateKeeperService gk = GateKeeper.getService();\n        if (gk != null) {\n            // gatekeeper中清除该用户的信息\n            gk.clearSecureUserId(userHandle);\n        }\n    } catch (Exception ex) {\n        Slog.w(LOG_TAG, \"unable to clear GK secure user id\");\n    }\n\n    // Cleanup package manager settings\n    // 清除用户相关的信息.包括该用户下安装的apk信息, 申请的权限信息, 更新packages.xml文件, 与用户相关的packages的文件如\n    // /data/system/users/<id>/package-restrictions.xml   mPendingBroadcasts中去除等等\n    mPm.cleanUpUser(this, userHandle);\n\n    // Clean up all data before removing metadata\n    // 清除用户的数据目录 /data/user_de/<id>   /data/user/<id>\n    mPm.destroyUserData(userHandle,\n            StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);\n\n    // Remove this user from the list\n    synchronized (mUsersLock) {\n        mUsers.remove(userHandle);\n        mIsUserManaged.delete(userHandle);\n    }\n    synchronized (mUserStates) {\n        mUserStates.delete(userHandle);\n    }\n    synchronized (mRestrictionsLock) {\n        mBaseUserRestrictions.remove(userHandle);\n        mAppliedUserRestrictions.remove(userHandle);\n        mCachedEffectiveUserRestrictions.remove(userHandle);\n        mDevicePolicyLocalUserRestrictions.remove(userHandle);\n    }\n    // Update the user list\n    synchronized (mPackagesLock) {\n        // 更新 /data/system/users/userlist.xml文件\n        writeUserListLP();\n    }\n    // Remove user file\n    AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + XML_SUFFIX));\n    // 最后删除 /data/system/users/<id>.xml\n    userFile.delete();\n    // 更新mUserIds 数组\n    updateUserIds();\n    Slog.i(LOG_TAG, \"removeUserState finished! \" + userHandle);\n}\n```\n\n### 1.1.7. 同步SysConfig中的 [Permission](#perm)到Setting.mPermissions中\n\n\n\n[Permission](#perm)转化SystemConfig.PermissionEntry->**BasePermission**\n\n>   注意转化到BasePermission的包名为*andriod*，且对应的权限type 为  *PROTECTION_SIGNATURE*\n\n\n\n```java\n// Propagate permission configuration in to package manager.\n// SystemConfig  解析的 Permission 放进 mSettings.mPermissions 中。\n// 注意包名为andriod，且对应的权限type 为  PROTECTION_SIGNATURE\nArrayMap<String, SystemConfig.PermissionEntry> permConfig\n        = systemConfig.getPermissions();\nfor (int i=0; i<permConfig.size(); i++) {\n    SystemConfig.PermissionEntry perm = permConfig.valueAt(i);\n    BasePermission bp = mSettings.mPermissions.get(perm.name);\n    if (bp == null) {\n        bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN);\n        mSettings.mPermissions.put(perm.name, bp);\n    }\n    if (perm.gids != null) {\n        // 填充global gid\n        bp.setGids(perm.gids, perm.perUser);\n    }\n}\n```\n\n### 1.1.8. 获取共享库，将其加入到mSharedLibraries并加入到优化集合中\n\n<span id=\"shareperm\"/>\n\n将sysConfig.[getSharedLibraries](#lib) 放入 mSharedLibraries中.\n\n```java\n// 获取共享库，将其加入到mSharedLibraries 加入到优化集合中。\nArrayMap<String, String> libConfig = systemConfig.getSharedLibraries();\nfor (int i=0; i<libConfig.size(); i++) {\n    mSharedLibraries.put(libConfig.keyAt(i),\n            new SharedLibraryEntry(libConfig.valueAt(i), null));\n}\n```\n\n## 1.2. BOOT_PROGRESS_PMS_SYSTEM_SCAN_START 阶段\n\n### 1.2.1. dex优化判定\n\n>   zygote启动时,已经将 SYSTEMSERVERCLASSPATH 里的资源做过dex优化,此处不需要再次执行\n\n首先通过InstructionSets.getAllInstructionSets 获取 abi集,需要读取Build.SUPPORTED_ABIS属性.\n\n\n>   Returns the runtime instruction set corresponding to a given ABI. Multiple\n>   compatible ABIs might map to the same instruction set. For example\n>   armeabi-v7a and armeabi might map to the instruction set arm.\n>   它描述了应用程序与OS之间的底层接口。ABI涉及了程序的各个方面，比如：目标文件格式、数据类型、数据对齐、函数调用约定以及函数如何传递参数、如何返回值、系统调用号、如何实现系统调用等。   \n\n遍历支持的abi集合后, 对[mSharedLibraries](#lib) 进行dex优化\n\n```java\n// Shared libraries do not have profiles so we perform a full\n// AOT compilation (if needed).\n\n// 没有做过dex优化，或者该文件变更了，需要重新做dex优化\nint dexoptNeeded = DexFile.getDexOptNeeded(\n        lib, dexCodeInstructionSet,\n        getCompilerFilterForReason(REASON_SHARED_APK),\n        false /* newProfile */);\nif (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {\n    mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet,\n            dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/,\n            getCompilerFilterForReason(REASON_SHARED_APK),\n            StorageManager.UUID_PRIVATE_INTERNAL,\n            SKIP_SHARED_LIBRARY_CHECK);\n}\n```\n\n### 1.2.2. pre-M版本apk升级权限install->runtime判断\n\n[sdkVersion](#sdkv)\n\n其中VersionInfo中存放了\n\n-   sdkVersion\n-   databaseVersion\n-   fingerprint\n\n```java\nprivate static final String ATTR_SDK_VERSION = \"sdkVersion\";\nreadLPw(){\n ver.sdkVersion = XmlUtils.readIntAttribute(parser, ATTR_SDK_VERSION); \n}\n```\n\n```java\n// 升级前的版本信息是从Settings中读取的,读取VersionInfo\nfinal VersionInfo ver = mSettings.getInternalVersion();\nmIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);\n\n// when upgrading from pre-M, promote system app permissions from install to runtime\n\n// 从Android5.1 及之前的版本 升级上来时，将 system app 的权限从install 变更为 runtime权限,\n// 默认赋予runtime权限。\nmPromoteSystemApps =\n        mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;\n\n// When upgrading from pre-N, we need to handle package extraction like first boot,\n// as there is no profiling data available.\n\nmIsPreNUpgrade = mIsUpgrade && ver.sdkVersion < Build.VERSION_CODES.N;\n\n// save off the names of pre-existing system packages prior to scanning; we don't\n// want to automatically grant runtime permissions for new system apps\n\n\n// 保存到 mExistingSystemPackages 中，用于install-> runtime\nif (mPromoteSystemApps) {\n    Iterator<PackageSetting> pkgSettingIter = mSettings.mPackages.values().iterator();\n    while (pkgSettingIter.hasNext()) {\n        PackageSetting ps = pkgSettingIter.next();\n        // 此处为非用户安装的应用\n        if (isSystemApp(ps)) {\n            mExistingSystemPackages.add(ps.name);\n        }\n    }\n}\n```\n\n此处涉及到权限授予的流程,先摘一小段:\n\n当同时满足三个条件,会进行install->runtime权限的转换:\n\n-   从5.1及5.1之前升级上来的版本\n-   非用户安装的应用\n-   应用还在,没有被删除\n\n```java\nprivate void grantPermissionsLPw(PackageParser.Package pkg, boolean replace,\n        String packageOfInterest) {\n        ...\n        final int level = bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;\n        switch (level) {\n          ...\n           // DANGEROUS权限\n           case PermissionInfo.PROTECTION_DANGEROUS: {\n           // \n           else if (mPromoteSystemApps\n                    && isSystemApp(ps)\n                    && mExistingSystemPackages.contains(ps.name)) {\n                        // For legacy system apps, install becomes runtime.\n                        // We cannot check hasInstallPermission() for system apps since those\n                        // permissions were granted implicitly and not persisted pre-M.\n                        grant = GRANT_UPGRADE;\n                    }\n           }\n        }\n  ...\n}    \n```\n\n### 1.2.3. 开始扫描apk\n\n#### 1.2.3.1. 先扫描这两个目录\n\n```shell\n/vendor/overlay\n/system/framework\n```\n\n#### 1.2.3.2. 再扫描这几个目录下面(system app):\n\n```shell\n/system/priv-app\n/system/app\n/vendor/app\n/oem/app\n```\n\n具体的扫描流程可参考[扫描apk的流程](https://cototem.github.io/2017/08/02/pkms2/)\n\n##### 1.2.3.2.1. 扫描system app 后的处理\n\n这几个目录下面的都是system app, 扫描完成后 , 在扫描到data app之前,需要对扫描后的结果做一下处理:\n\n首先删除禁用的system app\n\n```java\n// 现在mPackages中查找是否有该包\nfinal PackageParser.Package scannedPkg = mPackages.get(ps.name);\nif (scannedPkg != null) {\n  // 遍历所有扫描到的apk（packages.xml文件中以及现在扫描到的都有），\n  // 如果该apk FLAG_SYSTEM 生效，是 system app 且 在 disabled packages list 中时，去除该apk，不再进行解析。\n  if (mSettings.isDisabledSystemPackageLPr(ps.name)) {\n      logCriticalInfo(Log.WARN, \"Expecting better updated system app for \"\n              + ps.name + \"; removing system app.  Last known codePath=\"\n              + ps.codePathString + \", installStatus=\" + ps.installStatus\n              + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\"\n              + scannedPkg.mVersionCode);\n      removePackageLI(scannedPkg, true);\n      mExpectingBetter.put(ps.name, ps.codePath);\n  }\n  continue;\n}\n// 如果未在mPackages中查找到,但在mSettings.mPackages中有, 但未在禁用列表中，需要将该项从mSettings.mPackages中删除\nif (!mSettings.isDisabledSystemPackageLPr(ps.name)) {\n  psit.remove();\n  logCriticalInfo(Log.WARN, \"System package \" + ps.name\n                  + \" no longer exists; it's data will be wiped\");\n  // Actual deletion of code and data will be handled by later\n  // reconciliation step\n} else {\n  // 如果未在mPackages中查找到,但在mSettings.mPackages中有,且在禁用列表中，且数据目录为空时，加到 possiblyDeletedUpdatedSystemApps中\n  final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);\n  if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {\n    possiblyDeletedUpdatedSystemApps.add(ps.name);\n  }\n}\n```\n<span id=\"mExpectingBetter\">\n-   查找该Package是否在PackageManagerService.mPackages和mSettings.mPackages中.如果都在,且在禁用列表中,则直接删除该apk,不再进行解析.同时将该package加到`mExpectingBetter`中\n\n\n-   如果未在mPackages中查找到,但在mSettings.mPackages中有, 但未在禁用列表中，需要将该项从mSettings.mPackages中删除 \n\n    <span id=\"possiblyDeletedUpdatedSystemApps\">\n\n-   如果未在mPackages中查找到,但在mSettings.mPackages中有,且在禁用列表中，且数据目录为空时，加到 `possiblyDeletedUpdatedSystemApps`中\n\n\n\n#### 1.2.3.3. 处理未安装完成的app\n\n遍历mPackages的packageSetting,如果其installStatus为PKG_INSTALL_INCOMPLETE,则调用mSettings.removePackageLPw对该包进行处理\n\n-   从mSettings.mPackages中删除\n-   从mSettings.mInstallerPackages中删除\n-   从其shareUser中删除该包\n-   从mUserIds或mOtherUserIds中删除\n\n```java\nArrayList<PackageSetting> deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();\nfor (int i = 0; i < deletePkgsList.size(); i++) {\n    // Actual deletion of code and data will be handled by later\n    // reconciliation step\n    final String packageName = deletePkgsList.get(i).name;\n    logCriticalInfo(Log.WARN, \"Cleaning up incompletely installed app: \" + packageName);\n    synchronized (mPackages) {\n        mSettings.removePackageLPw(packageName);\n    }\n}\n```\n\n\n\n#### 1.2.3.4. 删除临时文件以及删除没有关联的package包的shareUser\n\n在对shareUser进行处理时,即遍历Settingss.mShareUsers, 查找其中的项有没有关联shareUserSetting,没有的话,需要将该单项从mShareUser中删除.\n\n另外需要查看该shareuserSetting中关联的packageSetting有没有安装,并进行处理\n\n```java\n// 删除安装过程中产生的临时文件, vmdl***.tmp文件\ndeleteTempPackageFiles();\n// Remove any shared userIDs that have no associated packages\nmSettings.pruneSharedUsersLPw();\n\nvoid pruneSharedUsersLPw() {\n  ArrayList<String> removeStage = new ArrayList<String>();\n  for (Map.Entry<String,SharedUserSetting> entry : mSharedUsers.entrySet()) {\n    final SharedUserSetting sus = entry.getValue();\n    // mSharedUsers 绑定的 SharedUserSetting 为 null, 直接把该shareUser项从mSharedUsers中删除\n    if (sus == null) {\n      removeStage.add(entry.getKey());\n      continue;\n    }\n    // remove packages that are no longer installed\n    // 如果当前安装的包中没有 ShareUser关联的包,则删除该关联项.\n    // shareUser可以关联多个包, 单包没有安装,则从shareUser中删除这个关联的单包\n    for (Iterator<PackageSetting> iter = sus.packages.iterator(); iter.hasNext();) {\n      PackageSetting ps = iter.next();\n      if (mPackages.get(ps.name) == null) {\n        iter.remove();\n      }\n    }\n    // 如果某个shareUser关联的包列表中的所有项都没有安装,则直接将该shareuser 从mSharedUsers中去除.\n    if (sus.packages.size() == 0) {\n      removeStage.add(entry.getKey());\n    }\n  }\n  for (int i = 0; i < removeStage.size(); i++) {\n    mSharedUsers.remove(removeStage.get(i));\n  }\n}\n```\n\n## 1.3. BOOT_PROGRESS_PMS_DATA_SCAN_START阶段\n\n#### 1.3.1.1. 最后扫描这几个目录下面(data app):\n\n<span id=\"扫描data\">\n\n```bash\n/data/app\n/data/app-private\n/system/preloadapp\n/system/app-ephemeral\n```\n\n#### 1.3.1.2. possiblyDeletedUpdatedSystemApps包的处理\n\n\n> Remove disable package settings for any updated system\n> apps that were removed via an OTA. If they're not a\n> previously-updated app, remove them completely.\n> Otherwise, just revoke their system-level permissions.\n\n```java\nfor (String deletedAppName : possiblyDeletedUpdatedSystemApps) {\n  // 需要在 mPackages中查找\n    PackageParser.Package deletedPkg = mPackages.get(deletedAppName);\n  // 从禁用列表中删除\n    mSettings.removeDisabledSystemPackageLPw(deletedAppName);\n\n    String msg;\n    if (deletedPkg == null) {\n        msg = \"Updated system package \" + deletedAppName\n                + \" no longer exists; it's data will be wiped\";\n        // Actual deletion of code and data will be handled by later\n        // reconciliation step\n    } else {\n      // 在mPakcages中查到了\n        msg = \"Updated system app + \" + deletedAppName\n                + \" no longer present; removing system privileges for \"\n                + deletedAppName;\n\n        deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;\n\n        PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);\n        //removing system privileges\n      // 删除系统权限\n        deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;\n    }\n    logCriticalInfo(Log.WARN, msg);\n}\n```\n\n对应[possiblyDeletedUpdatedSystemApps](#possiblyDeletedUpdatedSystemApps), 在这个地方该包是没在mPackages,如果此处能在mPackages查到,说明中间经过了其他的扫描. 而这中间是通过[扫描dataapp](#扫描data)的,这说明该包是data app的升级包,所以此处仅撤销掉FLAG_SYSTEM的flag,标明其为data app.\n\n#### 1.3.1.3. mExpectingBetter的处理\n\n对于之前[监测到的禁用的apk](#mExpectingBetter),在删除该apk相关的信息后,  重新对这些包进行扫描安装.\n\n```java\n    for (int i = 0; i < mExpectingBetter.size(); i++) {\n        final String packageName = mExpectingBetter.keyAt(i);\n        if (!mPackages.containsKey(packageName)) {\n            final File scanFile = mExpectingBetter.valueAt(i);\n\n            logCriticalInfo(Log.WARN, \"Expected better \" + packageName\n                    + \" but never showed up; reverting to system\");\n\n            int reparseFlags = mDefParseFlags;\n            if (FileUtils.contains(privilegedAppDir, scanFile)) {\n                reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                        | PackageParser.PARSE_IS_SYSTEM_DIR\n                        | PackageParser.PARSE_IS_PRIVILEGED;\n            } else if (FileUtils.contains(systemAppDir, scanFile)) {\n                reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                        | PackageParser.PARSE_IS_SYSTEM_DIR;\n            } else if (FileUtils.contains(vendorAppDir, scanFile)) {\n                reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                        | PackageParser.PARSE_IS_SYSTEM_DIR;\n            } else if (FileUtils.contains(oemAppDir, scanFile)) {\n                reparseFlags = PackageParser.PARSE_IS_SYSTEM\n                        | PackageParser.PARSE_IS_SYSTEM_DIR;\n            } else {\n                Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile);\n                continue;\n            }\n            // 重新启用这些package\n            mSettings.enableSystemPackageLPw(packageName);\n\n            try {\n              // 重新使用新的解析参数进行解析\n                scanPackageTracedLI(scanFile, reparseFlags, scanFlags, 0, null);\n            } catch (PackageManagerException e) {\n                Slog.e(TAG, \"Failed to parse original system package: \"\n                        + e.getMessage());\n            }\n        }\n    }\n}\nmExpectingBetter.clear();\n```\n#### 1.3.1.4. 解析受保护的action filter(setupWizard相关)\n\n>Only the setup wizard is allowed to have a high priority filter for these actions.\n\n首先看下受保护的action filter\n\n```java\nprivate static final Set<String> PROTECTED_ACTIONS = new ArraySet<>();\nstatic {\n    PROTECTED_ACTIONS.add(Intent.ACTION_SEND);\n    PROTECTED_ACTIONS.add(Intent.ACTION_SENDTO);\n    PROTECTED_ACTIONS.add(Intent.ACTION_SEND_MULTIPLE);\n    PROTECTED_ACTIONS.add(Intent.ACTION_VIEW);\n}\n```\nmProtectedFilters是在parseActivity和解析BroadcastReceiver时根据intentfilter匹配添加的.\n\n将开机向导处理这些mProtectedFilters的优先级设置为最高\n\n```java\n// 从之前解析的所有包中查找setupwizard应用\nmSetupWizardPackage = getSetupWizardPackageName();\nif (mProtectedFilters.size() > 0) {\n    if (DEBUG_FILTERS && mSetupWizardPackage == null) {\n        Slog.i(TAG, \"No setup wizard;\"\n            + \" All protected intents capped to priority 0\");\n    }\n    for (ActivityIntentInfo filter : mProtectedFilters) {\n        if (filter.activity.info.packageName.equals(mSetupWizardPackage)) {\n            if (DEBUG_FILTERS) {\n                Slog.i(TAG, \"Found setup wizard;\"\n                    + \" allow priority \" + filter.getPriority() + \";\"\n                    + \" package: \" + filter.activity.info.packageName\n                    + \" activity: \" + filter.activity.className\n                    + \" priority: \" + filter.getPriority());\n            }\n            // skip setup wizard; allow it to keep the high priority filter\n            continue;\n        }\n        //拥有mProtectedFilters的其他的包的优先级降为0,降为最低,只有开机向导的优先级比较高\n        Slog.w(TAG, \"Protected action; cap priority to 0;\"\n                + \" package: \" + filter.activity.info.packageName\n                + \" activity: \" + filter.activity.className\n                + \" origPrio: \" + filter.getPriority());\n        filter.setPriority(0);\n    }\n}\n```\n\n#### 1.3.1.5. 扫描结束后,更新所有的共享库,以及为所有的shareUser更新Abi架构集\n\n这个地方与[添加共享库后,为应用更新共享库信息](https://cototem.github.io/2017/08/02/pkms2/#系统级应用向共享库中添加库)呼应, 而更新指令集的部分与[为shareUser统一调整指令集](https://cototem.github.io/2017/08/02/pkms2/#为shareuser统一调整指令集)呼应\n\n```java\n//检测pkg的 usesLibraries 和 usesOptionalLibraries 项, 如果其中有lib项,则从mSharedLibraries查找该项,如果没有找到报异常.如果能找到,则将该项的path找到,聚合应用的话,则添加包括 basecodepath splitcodepath ,将这些path更新到 pkg.usesLibraryFiles字段中\nupdateAllSharedLibrariesLPw();\nfor (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {\n  // NOTE: We ignore potential failures here during a system scan (like\n  // the rest of the commands above) because there's precious little we\n  // can do about it. A settings error is reported, though.\n  adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,\n                                false /* boot complete */);\n}\n```\n\n#### 1.3.1.6. 读取PackageUsage文件更新pkg的mLastPackageUsageTimeInMills字段\n\n>Now that we know all the packages we are keeping,read and update their last usage time\n\n```java\n// 读取data/system/package-usage.list\nmPackageUsage.readLP();\n```\n\ndata/system/package-usage.list\n\n```powershell\nPACKAGE_USAGE_VERSION1\ncom.android.providers.telephony 0 0 0 0 1420072084352 0 1420072084443 0\ncom.sprd.engineermode 1420072113355 1420072113459 0 1420072405475 1420072101365 0 0 0\ncom.android.providers.calendar 0 0 0 1420072105482 1420072100291 0 0 0\n```\n\nmLastPackageUsageTimeInMills保存了下面这几项(8项 [UNIX时间,转换见这里](#unix))\n\n```java\n//Used when starting a process for an Activity.\npublic static final int NOTIFY_PACKAGE_USE_ACTIVITY = 0;\n//Used when starting a process for a Service.\npublic static final int NOTIFY_PACKAGE_USE_SERVICE = 1;\n//Used when moving a Service to the foreground.\npublic static final int NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE = 2;\n//Used when starting a process for a BroadcastReceiver.\npublic static final int NOTIFY_PACKAGE_USE_BROADCAST_RECEIVER = 3;\n//Used when starting a process for a ContentProvider.\npublic static final int NOTIFY_PACKAGE_USE_CONTENT_PROVIDER = 4;\n//Used when starting a process for a BroadcastReceiver.\npublic static final int NOTIFY_PACKAGE_USE_BACKUP = 5;\n//Used with Context.getClassLoader() across Android packages.\npublic static final int NOTIFY_PACKAGE_USE_CROSS_PACKAGE = 6;\n//Used when starting a package within a process for Instrumentation.\npublic static final int NOTIFY_PACKAGE_USE_INSTRUMENTATION = 7;\n```\n\n## 1.4. BOOT_PROGRESS_PMS_SCAN_END\n\n上面的system扫描和data扫描结束\n\n#### 1.4.1.1. 更新赋予权限 updatePermissionsLPw\n\n```java\nver.sdkVersion != mSdkVersion\n```\n\nmSdkVersion取的是`ro.build.version.sdk`,这个值是编版本时指定的,指的是framework的sdk\n\n而ver.sdkVersion是[记录在packages.xml中](#sdkv)的\n\n对于OTA升级的场景,这个值一上来就是有的.\n\n而对于首次开机的场景,即上来packages.xml文件不存在,这个值会在mSettings.readLPw方法中创建,并将ver.sdkVersion的值设置为mSdkVersion\n\n```java\n// 升级的场景\nif (ver.sdkVersion != mSdkVersion) {\n    Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n            + mSdkVersion + \"; regranting permissions for internal storage\");\n    // 指定重新赋予 regrant权限\n    updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n}\nsynchronized (mPackages) {\n    // Make sure there are no dangling permission trees.\n    updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);\n}\nver.sdkVersion = mSdkVersion;\n```\n##### 1.4.1.1.1. 更新权限流程图\n```puml\n@startuml\nPackageManagerServcice -> PackageManagerServcice:updatePermissionsLPw\nopt UPDATE_PERMISSIONS_ALL\nPackageManagerServcice -> PackageManagerServcice: getVolumeUuidForPackage(pkg)\nPackageManagerServcice -> PackageManagerServcice: grantPermissionsLPw(pkg, replace, changingPkg);\nPackageManagerServcice ->PackageSetting: getPermissionsState\nPackageSetting ->> SettingBase: getPermissionsState\nPackageSetting -->>  PackageManagerServcice: return PermissionsState\nPackageManagerServcice -> PermissionsState: setGlobalGids\nPackageManagerServcice -> PackageParser.Package:pkg.requestedPermissions.get\nPackageParser.Package ->  PackageManagerServcice: return requestedPermission name\nPackageManagerServcice -> PackageManagerServcice: BasePermission bp = mSettings.mPermissions.get(name)\nPackageManagerServcice -> BasePermission: bp.protectionLevel\nopt GRANT_INSTALL\nPackageManagerServcice -> PermissionsState:grantInstallPermission(bp)\nelse\nend\nopt GRANT_RUNTIME\nPackageManagerServcice ->> PermissionsState:grantRuntimePermission(bp, userId)\nPackageManagerServcice ->> PermissionsState:updatePermissionFlags(bp, userId,flags, flags)\nelse\nend\nopt GRANT_UPGRADE\nPackageManagerServcice ->> PermissionsState:revokeInstallPermission(bp)\nPackageManagerServcice ->> PermissionsState:updatePermissionFlags(bp, ...)\nPackageManagerServcice ->> PermissionsState:grantRuntimePermission(bp, userId)\nPackageManagerServcice ->> PermissionsState:updatePermissionFlags(bp, userId,flags, flags)\nelse\nopt\nalt GRANT_DENIED\nPackageManagerServcice ->> PermissionsState:revokeInstallPermission(bp)\nPackageManagerServcice ->> PermissionsState:updatePermissionFlags(bp, userId,flags, flags)\nelse\nopt\nPackageManagerServcice ->> Settings:writeRuntimePermissionsForUserLPr(userId, sync)\nelse \nend\n\nopt pkginfo is not null\nPackageManagerServcice ->> PackageManagerServcice: getVolumeUuidForPackage(pkg)\nPackageManagerServcice ->> PackageManagerServcice: \tgrantPermissionsLPw\nelse\nend\n@enduml\n```\n\n\n##### 1.4.1.1.2. 具体流程\n\n###### 1.4.1.1.2.1. updatePermissionsLPw函数更新数据在内部存储上的包\n\n```java\nif (ver.sdkVersion != mSdkVersion) {\n  Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \"\n         + mSdkVersion + \"; regranting permissions for internal storage\");\n  // 为升级场景时,携带UPDATE_PERMISSIONS_REPLACE_ALL标记\n  updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;\n}\nupdatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);\n```\n\n首先读取mSettings.mPermissionTrees上的item,如果其item对应的packageSetting为空,则从该tree上删除该item\n\n其次读取mSettings.mPermissions上的项目, 如果权限为TYPE_DYNAMIC, bp.packageSetting 为空,则从其对应的tree 继承构造.\n\n如果 bp.packageSetting还为空的话,需要从 mSettings.mPermissions 中删除该权限,进行下一步\n\n最后监测是否携带了UPDATE_PERMISSIONS_ALL标记,携带此标记,说明是为**所有包**更新权限,  如果携带UPDATE_PERMISSIONS_REPLACE_ALL标记,将replace设置为true\n\n调用grantPermissionsLPw(pkg, replace, changingPkg) 更新授予权限\n\n同样检测pkgInfo是否为空,此参数表明为**单个指定的包**更新授予权限.如果携带UPDATE_PERMISSIONS_REPLACE_ALL标记,则将replace设置为true,调用调用grantPermissionsLPw(pkg, replace, changingPkg) 更新授予权限.\n\n###### 1.4.1.1.2.2. grantPermissionsLPw函数进行权限更新授予\n\n权限类型为PROTECTION_SIGNATURE和PROTECTION_NORMAL时,为安装时权限.\n\n但在`PROTECTION_SIGNATURE`的情况下,需要对签名进行校验(并不只是签名的比对),校验未通过,则grant类型为GRANT_DENIED\n\n```java\nfinal boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion\n        >= Build.VERSION_CODES.M;\nswitch (level) {\n    case PermissionInfo.PROTECTION_NORMAL: {\n        // For all apps normal permissions are install time ones.\n        grant = GRANT_INSTALL;\n    } break;\n\n    case PermissionInfo.PROTECTION_DANGEROUS: {\n        // If a permission review is required for legacy apps we represent\n        // their permissions as always granted runtime ones since we need\n        // to keep the review required permission flag per user while an\n        // install permission's state is shared across all users.\n        // 如果Build.PERMISSIONS_REVIEW_REQUIRED为true,则肯定不为GRANT_INSTALL类型\n        // 一般情况下,PERMISSIONS_REVIEW_REQUIRED 不进行设置, 即为false\n        // legacy app ,即 sdk小于M的apk, 在这种情况下,对应dangerous的权限, 授予为安装时权限\n        if (!appSupportsRuntimePermissions && !Build.PERMISSIONS_REVIEW_REQUIRED) {\n            // For legacy apps dangerous permissions are install time ones.\n            grant = GRANT_INSTALL;\n        } else if (origPermissions.hasInstallPermission(bp.name)) {\n            // 如果权限已经被赋予了,对应于legacy app 升级为sdk>=M的情况,  类型变为GRANT_UPGRADE\n            // For legacy apps that became modern, install becomes runtime.\n            grant = GRANT_UPGRADE;\n            // 对于从pre-M升级上来的 system app,即使权限没有被赋予, install->runtime\n        } else if (mPromoteSystemApps\n                && isSystemApp(ps)\n                && mExistingSystemPackages.contains(ps.name)) {\n            // For legacy system apps, install becomes runtime.\n            // We cannot check hasInstallPermission() for system apps since those\n            // permissions were granted implicitly and not persisted pre-M.\n            grant = GRANT_UPGRADE;\n        } else {\n            // For modern apps keep runtime permissions unchanged.\n            grant = GRANT_RUNTIME;\n        }\n    } break;\n\n    case PermissionInfo.PROTECTION_SIGNATURE: {\n        // For all apps signature permissions are install time ones.\n        // 进行签名校验,并不只是签名的比对\n        allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions);\n        if (allowedSig) {\n            grant = GRANT_INSTALL;\n        }\n    } break;\n}\n```\n\n授予权限时,对应安装时权限\n\n```java\nswitch (grant) {\n    case GRANT_INSTALL: {\n        // Revoke this as runtime permission to handle the case of\n        // a runtime permission being downgraded to an install one.\n        // Also in permission review mode we keep dangerous permissions\n        // for legacy apps\n      // runtime权限降级为install权限,需要将runtime权限撤销\n        for (int userId : UserManagerService.getInstance().getUserIds()) {\n            if (origPermissions.getRuntimePermissionState(\n                    bp.name, userId) != null) {\n                // Revoke the runtime permission and clear the flags.\n                origPermissions.revokeRuntimePermission(bp, userId);\n                origPermissions.updatePermissionFlags(bp, userId,\n                      PackageManager.MASK_PERMISSION_FLAGS, 0);\n                // If we revoked a permission permission, we have to write.\n                changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                        changedRuntimePermissionUserIds, userId);\n            }\n        }\n        // Grant an install permission.\n            if (permissionsState.grantInstallPermission(bp) !=\n                PermissionsState.PERMISSION_OPERATION_FAILURE) {\n            changedInstallPermission = true;\n        }\n    } break;\n```\n\n对应runtime权限的授予\n\n```java\ncase GRANT_RUNTIME: {\n    // Grant previously granted runtime permissions.\n    for (int userId : UserManagerService.getInstance().getUserIds()) {\n        PermissionState permissionState = origPermissions\n                .getRuntimePermissionState(bp.name, userId);\n        int flags = permissionState != null\n                ? permissionState.getFlags() : 0;\n      // 原来的包中已经由该权限项,不论该权限项是否被授予\n        if (origPermissions.hasRuntimePermission(bp.name, userId)) {\n           //进行授予权限\n            if (permissionsState.grantRuntimePermission(bp, userId) ==\n                    PermissionsState.PERMISSION_OPERATION_FAILURE) {\n                // If we cannot put the permission as it was, we have to write.\n              // 权限未授予成功,才对权限对应xml文件进行更新\n                changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                        changedRuntimePermissionUserIds, userId);\n            }\n            // If the app supports runtime permissions no need for a review.\n          // permission Review时,需要更新权限对应xml文件\n            if (Build.PERMISSIONS_REVIEW_REQUIRED\n                    && appSupportsRuntimePermissions\n                    && (flags & PackageManager\n                            .FLAG_PERMISSION_REVIEW_REQUIRED) != 0) {\n                flags &= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;\n                // Since we changed the flags, we have to write.\n                changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                        changedRuntimePermissionUserIds, userId);\n            }\n          // REVIEW permission Review 且 app版本小于M版本时, 授予运行时权限\n          // 一般情况下,不在permission review模式下,即该字段不存在\n        } else if (Build.PERMISSIONS_REVIEW_REQUIRED\n                && !appSupportsRuntimePermissions) {\n            // For legacy apps that need a permission review, every new\n            // runtime permission is granted but it is pending a review.\n            // We also need to review only platform defined runtime\n            // permissions as these are the only ones the platform knows\n            // how to disable the API to simulate revocation as legacy\n            // apps don't expect to run with revoked permissions.\n            if (PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage)) {\n                if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0) {\n                    flags |= FLAG_PERMISSION_REVIEW_REQUIRED;\n                    // We changed the flags, hence have to write.\n                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                            changedRuntimePermissionUserIds, userId);\n                }\n            }\n            if (permissionsState.grantRuntimePermission(bp, userId)\n                    != PermissionsState.PERMISSION_OPERATION_FAILURE) {\n                // We changed the permission, hence have to write.\n                changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                        changedRuntimePermissionUserIds, userId);\n            }\n        }\n        // Propagate the permission flags.\n        permissionsState.updatePermissionFlags(bp, userId, flags, flags);\n    }\n} break;\n```\n\n对应GRANT_UPGRADE的权限进行授予:\n\n```java\ncase GRANT_UPGRADE: {\n    // Grant runtime permissions for a previously held install permission.\n    PermissionState permissionState = origPermissions\n            .getInstallPermissionState(bp.name);\n    final int flags = permissionState != null ? permissionState.getFlags() : 0;\n    // 撤销安装时权限\n    if (origPermissions.revokeInstallPermission(bp)\n            != PermissionsState.PERMISSION_OPERATION_FAILURE) {\n        // We will be transferring the permission flags, so clear them.\n        origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL,\n                PackageManager.MASK_PERMISSION_FLAGS, 0);\n        changedInstallPermission = true;\n    }\n\n    // If the permission is not to be promoted to runtime we ignore it and\n    // also its other flags as they are not applicable to install permissions.\n    // install->runtime 的权限在被撤销后会携带FLAG_PERMISSION_REVOKE_ON_UPGRADE的标志, 应用下次升级时,就不会赋予该权限了\n    if ((flags & PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) {\n        for (int userId : currentUserIds) {\n          // 授予运行时权限\n            if (permissionsState.grantRuntimePermission(bp, userId) !=\n                    PermissionsState.PERMISSION_OPERATION_FAILURE) {\n                // Transfer the permission flags.\n                permissionsState.updatePermissionFlags(bp, userId,\n                        flags, flags);\n                // If we granted the permission, we have to write.\n                changedRuntimePermissionUserIds = ArrayUtils.appendInt(\n                        changedRuntimePermissionUserIds, userId);\n            }\n        }\n    }\n} break;\n```\n\nGRANT_DENIED类型,需要撤销安装时权限\n\n```java\nif (permissionsState.revokeInstallPermission(bp) !=\n        PermissionsState.PERMISSION_OPERATION_FAILURE) {\n    // Also drop the permission flags.\n    permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL,\n            PackageManager.MASK_PERMISSION_FLAGS, 0);\n    changedInstallPermission = true;\n    Slog.i(TAG, \"Un-granting permission \" + perm\n            + \" from package \" + pkg.packageName\n            + \" (protectionLevel=\" + bp.protectionLevel\n            + \" flags=0x\" + Integer.toHexString(pkg.applicationInfo.flags)\n            + \")\");\n}\n```\n\n最后根据变更权限的user更新权限对应的xml文件\n\n/data/system/users/<userid>/runtime-permissions.xml\n\n#### 1.4.1.2. 第一次开机或者从pre-M版本升级上来,重设偏好应用\n\n```java\n// If this is the first boot or an update from pre-M, and it is a normal\n// boot, then we need to initialize the default preferred apps across\n// all defined users.\n// mPromoteSystemApps 标志pre-M版本升级上来\n// mRestoredSettings为false 表明首次开机\nif (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {\n    for (UserInfo user : sUserManager.getUsers(true)) {\n        mSettings.applyDefaultPreferredAppsLPw(this, user.id);\n        applyFactoryDefaultBrowserLPw(user.id);\n        primeDomainVerificationsLPw(user.id);\n    }\n}\n```\n\n#### 1.4.1.3. 调整应用的数据目录\n\n```java\nfinal int storageFlags;\nif (StorageManager.isFileEncryptedNativeOrEmulated()) {\n    // 文件加密模式,只设置DE区\n    storageFlags = StorageManager.FLAG_STORAGE_DE;\n} else {\n    // 非文件加密模式, 同时设置DE区和CE区\n    storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;\n}\n// Destroys app data that isn't expected, either due to uninstallation or reinstallation on another volume.\n// 然后,为已安装该应用的用户准备数据目录,包括设置权限及设置selinux标签\n// /data/user_de/<userid>/**\n// /data/user/<userid>/**\nreconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM,\n        storageFlags);\n```\n\n#### 1.4.1.4. 当监测到为升级场景时,需要删除原来包的code_cache\n\n携带了Installer.FLAG_CLEAR_CODE_CACHE_ONLY的flag\n\n```java\nif (mIsUpgrade && !onlyCore) {\n    Slog.i(TAG, \"Build fingerprint changed; clearing code caches\");\n    for (int i = 0; i < mSettings.mPackages.size(); i++) {\n        final PackageSetting ps = mSettings.mPackages.valueAt(i);\n        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) {\n            // No apps are running this early, so no need to freeze\n            clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,\n                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE\n                            // 只清除codecache目录\n                            | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);\n        }\n    }\n    ver.fingerprint = Build.FINGERPRINT;\n}\n```\n\n#### 1.4.1.5. 更新完应用权限,且偏好应用更新完时,重置某些字段并写入packages.xml\n\n在这个地方会对packages.xml文件进行写入更新\n\n```java\n// clear only after permissions and other defaults have been updated\n// 该字段用于保存install->runtime的权限\nmExistingSystemPackages.clear();\nmPromoteSystemApps = false;\n\n// All the changes are done during package scanning.\nver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;\n\n// can downgrade to reader\n将上述扫描的结果写入packages.xml\nmSettings.writeLPr();\n```\n\n#### 1.4.1.6. 对core app执行dex优化\n\n首次开机或者升级场景或者DalvikCache被删除时,需要对core app 执行dex优化\n\ncore app来自 pkg.coreApp, 从AndroidManifest中解析的.\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:androidprv=\"http://schemas.android.com/apk/prv/res/android\"\n        package=\"com.android.proxyhandler\"\n        coreApp=\"true\">\n```\n\n## 1.5. BOOT_PROGRESS_PMS_READY阶段\n\n### 1.5.1. 初始化PackageInstallerService\n\n该服务主要处理来自应用安装器的安装请求\n\n```java\n    mInstallerService = new PackageInstallerService(context, this);\n    public PackageInstallerService(Context context, PackageManagerService pm) {\n        mContext = context;\n        mPm = pm;\n        mInstallThread = new HandlerThread(TAG);\n        mInstallThread.start();\n        mInstallHandler = new Handler(mInstallThread.getLooper());\n        mCallbacks = new Callbacks(mInstallThread.getLooper());\n\n        mSessionsFile = new AtomicFile(\n                new File(Environment.getDataSystemDirectory(), \"install_sessions.xml\"));\n        mSessionsDir = new File(Environment.getDataSystemDirectory(), \"install_sessions\");\n        mSessionsDir.mkdirs();\n\n        synchronized (mSessions) {\n            readSessionsLocked();\n\n            reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, false /*isEphemeral*/);\n            reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, true /*isEphemeral*/);\n\n            final ArraySet<File> unclaimedIcons = newArraySet(\n                    mSessionsDir.listFiles());\n\n            // Ignore stages and icons claimed by active sessions\n            for (int i = 0; i < mSessions.size(); i++) {\n                final PackageInstallerSession session = mSessions.valueAt(i);\n                unclaimedIcons.remove(buildAppIconFile(session.sessionId));\n            }\n\n            // Clean up orphaned icons\n            for (File icon : unclaimedIcons) {\n                Slog.w(TAG, \"Deleting orphan icon \" + icon);\n                icon.delete();\n            }\n        }\n    }\n```\n\n### 1.5.2. 为几个变量赋值\n\n<span id=\"bianliang\">\n\n```java\nif (!mOnlyCore) {\n   // 默认校验器,来自android.intent.action.PACKAGE_NEEDS_VERIFICATION\n    mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();\n    // 默认的安装器,来自android.intent.action.INSTALL_PACKAGE\n    mRequiredInstallerPackage = getRequiredInstallerLPr();\n    // 默认的校验器对应的component\n    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();\n    // 校验代理\n    mIntentFilterVerifier = new IntentVerifierProxy(mContext,\n            mIntentFilterVerifierComponent);\n    // 使用\"android.ext.services\" 共享库的 client apk 的名字\n    mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(\n            PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES);\n   // 使用\"android.ext.shared\" 共享库的 client apk的名字\n    mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(\n            PackageManager.SYSTEM_SHARED_LIBRARY_SHARED);\n} \n```\n\n### 1.5.3. ephemeral app 安装准备\n\n-   获取解析ephemeral app 的组件\n-   获取安装ephemeral app 的组件\n\n```java\nfinal ComponentName ephemeralResolverComponent = getEphemeralResolverLPr();\nfinal ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr();\n// both the installer and resolver must be present to enable ephemeral\nif (ephemeralInstallerComponent != null && ephemeralResolverComponent != null) {\n    if (DEBUG_EPHEMERAL) {\n        Slog.i(TAG, \"Ephemeral activated; resolver: \" + ephemeralResolverComponent\n                + \" installer:\" + ephemeralInstallerComponent);\n    }\n    mEphemeralResolverComponent = ephemeralResolverComponent;\n    mEphemeralInstallerComponent = ephemeralInstallerComponent;\n    // 初始化mEphemeralInstallerActivity 对应 ActivityInfo数据的基础信息\n    setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent);\n    mEphemeralResolverConnection =\n            new EphemeralResolverConnection(mContext, mEphemeralResolverComponent);\n}\n```\n\n### 1.5.4. 注册PackageManagerInternal 私有LOCAL service服务\n\n通过该local service, server进程内的所有服务可以通过其公布的接口拿到或设置一些组件的信息\n\n具体可以查看 PackageManagerInternalImpl类\n\n如使用`getHomeActivitiesAsUser` 查询 home activity的component name\n\n至此, pkms的构造函数执行完毕.","tags":["Android","AndroidN","PackageManagerService"],"categories":["PackageManagerService"]},{"title":"PackageManagerService启动篇整理2","url":"/2017/08/02/其他调研/PackageManagerService启动篇整理2/","content":"\n# 1. PackageManagerService的启动过程\n\n\n\n>   本篇主要介绍**PKMS**扫描包的流程\n\n\n\n-----\n\n## 1.1. BOOT_PROGRESS_PMS_SYSTEM_SCAN_START 阶段\n\n### 1.1.1. 开始扫描apk\n\n先扫描这两个目录的\n\n```shell\n/vendor/overlay\n/system/framework\n```\n\n再扫描这几个目录下面的:\n\n```shell\n/system/priv-app\n/system/app\n/vendor/app\n/oem/app\n```\n\n最后扫描这几个目录下面的:\n\n```shell\n/data/app\n/data/app-private\n/system/preloadapp\n/system/app-ephemeral\n```\n\n先看一下扫描相关的代码流程\n\n#### 1.1.1.1. **扫描流程图**\n\n```puml\n@startuml\nPackageManagerService -> PackageManagerService:scanDirTracedLI\nPackageManagerService -> PackageManagerService:scanDirLI\nPackageManagerService -> PackageManagerService:scanPackageTracedLI\nPackageManagerService ->PackageManagerService:scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user)\nPackageManagerService ->PackageParser: parsePackage\nopt packageFile.isDirectory\n   PackageParser -> PackageParser: parseClusterPackage\n   PackageParser -> PackageParser: parseClusterPackageLite\n   PackageParser -> PackageParser: parseApkLite\n   PackageParser ->  AssetManager: setConfiguration\n   AssetManager -> AssetManager: native_setConfiguration\n   PackageParser ->  AssetManager: addAssetPath\n   AssetManager -> AssetManager: addAssetPathNative\n   PackageParser -> AssetManager: parser = openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n   AssetManager -> AssetManager:openXmlBlockAsset\n   PackageParser ->PackageParser: collectCertificates\n   PackageParser -> PackageParser: loadApkIntoAssetManager\n   PackageParser -> PackageParser: parseBaseApk\n   PackageParser ->PackageParser: parsePackageSplitNames\n   PackageParser -> PackageParser: parseBaseApkCommon\n   PackageParser -> PackageParser: parseBaseApplication\n   PackageParser -> PackageParser: parseActivity\n   PackageParser -> PackageParser: parseService\n   PackageParser -> PackageParser: parseProvider\n   PackageParser -> PackageParser: end [parseBaseApplication]\n   PackageParser -> PackageParser: end [parseBaseApkCommon]\n   PackageParser -> PackageParser: end [parseBaseApk]\n   PackageParser -> PackageParser: parseSplitApk\nelse packageFile is file\n   PackageParser ->PackageParser:parseMonolithicPackage\n   PackageParser ->PackageParser:parseMonolithicPackageLite\n   PackageParser ->PackageParser:parseApkLite\n   PackageParser ->PackageParser:parseBaseApk\nend\nPackageManagerService -> PackageManagerService:scanPackageLI(pkg,   scanFile, parseFlags, scanFlags, currentTime, user)\nPackageManagerService -> PackageManagerService: scanPackageInternalLI\nPackageManagerService ->PackageManagerService: createInstallArgsForExisting\nPackageManagerService -> AsecInstallArgs: new AsecInstallArgs(codePath, instructionSets ....)\nPackageManagerService -> FileInstallArgs: new FileInstallArgs(codePath, resourcePath,  instructionSets);\nPackageManagerService -> PackageManagerService: collectCertificatesLI(ps, pkg, scanFile, policyFlags);\nPackageManagerService ->> PackageManagerService: compareSignatures\n\nPackageManagerService -> PackageManagerService: scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user)\n\nPackageManagerService -> PackageManagerService: scanPackageDirtyLI(pkg, policyFlags, scanFlags,   currentTime, user)\n\nPackageManagerService -> NativeLibraryHelper:replaceUnityLibraries(res.packageName,    res.applicationInfo.nativeLibraryDir, )\n\nopt  if scanPackageDirtyLI not success\n\nPackageManagerService -> PackageManagerService:destroyAppDataLIF(pkg, UserHandle.USER_ALL,  FLAG_STORAGE_DE | FLAG_STORAGE_CE)\n\nPackageManagerService ->> PackageManagerService: destroyAppProfilesLIF(pkg, UserHandle.USER_ALL)\n\nelse\n\nend\n\nPackageManagerService -> PackageManagerService: end [createInstallArgsForExisting]\nPackageManagerService -> PackageManagerService: end [scanPackageInternalLI]\nPackageManagerService -> PackageManagerService: end [scanPackageLI]\nPackageManagerService ->> PackageManagerService: end [scanPackageLI]\n@enduml\n```\n\n#### 1.1.1.2. 扫描流程简要分析\n\n ##### scanDirTracedLI函数\n\n```java\n// 扫描framework下的apk， 如 framework-res.apk\n      scanDirTracedLI(frameworkDir, mDefParseFlags\n          | PackageParser.PARSE_IS_SYSTEM\n          | PackageParser.PARSE_IS_SYSTEM_DIR\n          | PackageParser.PARSE_IS_PRIVILEGED,\n// framework-res.apk中没有代码,因此不需要dex优化\n          scanFlags | SCAN_NO_DEX, 0);\n\n    private void scanDirTracedLI(File dir, final int parseFlags, int scanFlags, long currentTime) {\n        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanDir\");\n        try {\n            scanDirLI(dir, parseFlags, scanFlags, currentTime);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);\n        }\n    }\n```\n\n比较重要的参数\n\n-   parseFlags\n\n```java\npublic final static int PARSE_IS_SYSTEM = 1<<0;\npublic final static int PARSE_CHATTY = 1<<1;\npublic final static int PARSE_MUST_BE_APK = 1<<2;\npublic final static int PARSE_IGNORE_PROCESSES = 1<<3;\npublic final static int PARSE_FORWARD_LOCK = 1<<4;\npublic final static int PARSE_EXTERNAL_STORAGE = 1<<5;\npublic final static int PARSE_IS_SYSTEM_DIR = 1<<6;\npublic final static int PARSE_IS_PRIVILEGED = 1<<7;\npublic final static int PARSE_COLLECT_CERTIFICATES = 1<<8;\npublic final static int PARSE_TRUSTED_OVERLAY = 1<<9;\npublic final static int PARSE_ENFORCE_CODE = 1<<10;\npublic final static int PARSE_IS_EPHEMERAL = 1<<11;\npublic final static int PARSE_FORCE_SDK = 1<<12;\n```\n\n\n\n\n| 解析参数                   | 关联到包相关的flag (ApplicationInfo) | getter方法                   |\n| ---------------------- | ----------------------------- | -------------------------- |\n| PARSE_IS_SYSTEM        | FLAG_SYSTEM                   | isSystemApp                |\n| PARSE_IS_PRIVILEGED    | PRIVATE_FLAG_PRIVILEGED       | isPrivilegedApp            |\n| PARSE_FORWARD_LOCK     | PRIVATE_FLAG_FORWARD_LOCK     | isForwardLocked            |\n| PARSE_IS_SYSTEM_DIR    | 没有指定                          | 没有指定                       |\n| PARSE_EXTERNAL_STORAGE | FLAG_EXTERNAL_STORAGE         | isExternal                 |\n| PARSE_IS_EPHEMERAL     | PRIVATE_FLAG_EPHEMERAL        | isEphemeral/isEphemeralApp |\n| PARSE_MUST_BE_APK      | 没有指定(必须后缀名为.apk)              | 没有指定                       |\n\n\n-   scanFlags\n\n```java\nstatic final int SCAN_NO_DEX = 1<<1;     // 指定此标志,不执行dex优化\nstatic final int SCAN_FORCE_DEX = 1<<2;  // 强制做dex优化\nstatic final int SCAN_UPDATE_SIGNATURE = 1<<3;  // 更新签名,一般扫描或安装时都会携带该参数\nstatic final int SCAN_NEW_INSTALL = 1<<4;  // 新安装apk时,携带该参数,如调用installPackage时\nstatic final int SCAN_NO_PATHS = 1<<5;\nstatic final int SCAN_UPDATE_TIME = 1<<6;  //在apk升级时往往会指定该参数.指定后,会更新应用的lastUpdateTime\nstatic final int SCAN_DEFER_DEX = 1<<7;   \nstatic final int SCAN_BOOTING = 1<<8;   // 标记开机扫描阶段\nstatic final int SCAN_TRUSTED_OVERLAY = 1<<9;  // 关联mTrustedOverlay , 不再执行createIdmapForPackagePairLI\nstatic final int SCAN_DELETE_DATA_ON_FAILURES = 1<<10; // 应用安装失败, 删除应用数据\nstatic final int SCAN_REPLACING = 1<<11;\nstatic final int SCAN_REQUIRE_KNOWN = 1<<12;\nstatic final int SCAN_MOVE = 1<<13;   // 应用移动相关. 重用abi数据\nstatic final int SCAN_INITIAL = 1<<14;   // 应用升级有关,该标志标明应用为第一次扫描,不需要执行 shouldCheckUpgradeKeySetLP 函数,检查升级签名问题\n\n        // Getting the package setting may have a side-effect, so if we\n        // are only checking if scan would succeed, stash a copy of the\n        // old setting to restore at the end.\nstatic final int SCAN_CHECK_ONLY = 1<<15;\nstatic final int SCAN_DONT_KILL_APP = 1<<17; //与 DELETE_DONT_KILL_APP 关联, deletePackageX时不杀应用\nstatic final int SCAN_IGNORE_FROZEN = 1<<18;  // Sadly we don't know the package name yet to freeze it\n            // Caller asked us to ignore frozen check for some reason; they\n            // probably didn't know the package name\n            // 不掉用 checkPackageFrozen\n```\n\n##### 1.1.1.2.1. scanDirLI 函数\n\n-   执行文件检查\n\n```java\nfinal boolean isPackage = (isApkFile(file) || file.isDirectory())\n  // 排除stage file的情况, stage file不算  \tvmdl**.tmp  smdl**.tmp   smdl2tmp\n        && !PackageInstallerService.isStageName(file.getName());\nif (!isPackage) {\n    // Ignore entries which are not packages\n    continue;\n}\n```\n\n-   删除无效的用户apk\n\n```java\n// Delete invalid userdata apps\nif ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0 &&\n        e.error == PackageManager.INSTALL_FAILED_INVALID_APK) {\n    logCriticalInfo(Log.WARN, \"Deleting invalid package at \" + file);\n    // 删除codePath  如/data/app/**\n    removeCodePathLI(file);\n}\n```\n\n调用scanPackageLI函数\n\n##### 1.1.1.2.2. scanPackageLI函数\n\n```java\n/**\n *  Scans a package and returns the newly parsed package.\n *  Returns {@code null} in case of errors and the error code is stored in mLastScanError\n */\nprivate PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,\n        long currentTime, UserHandle user) throws PackageManagerException {\n    if (DEBUG_INSTALL) Slog.d(TAG, \"Parsing: \" + scanFile);\n  // 创建PackageParser\n    PackageParser pp = new PackageParser();\n    pp.setSeparateProcesses(mSeparateProcesses);\n    pp.setOnlyCoreApps(mOnlyCore);\n    pp.setDisplayMetrics(mMetrics);\n  \n    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\");\n    final PackageParser.Package pkg;\n    // 调用 parsePackage函数\n        pkg = pp. parsePackage函数(scanFile, parseFlags);\n\n    /* Add for boot performance with multi-thread and preload scan @{*/\n    if(mPackageManagerServiceExUtils.isPreloadOrVitalApp(scanFile.getParent()) && mPackageManagerServiceExUtils.mDeleteRecord.exists()){\n        if(mPackageManagerServiceExUtils.isDeleteApp(pkg.packageName))return pkg;\n    }\n    /* @} */\n    // 调用scanPackageLI 进行apk的安装\n    return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);\n}\n```\n##### 1.1.1.2.3. parsePackage函数\n\n```java\n* Parse the package at the given location. Automatically detects if the\n* package is a monolithic style (single APK file) or cluster style // 聚合apk\n        if (packageFile.isDirectory()) {\n            return parseClusterPackage(packageFile, flags);\n        } else {\n            return parseMonolithicPackage(packageFile, flags);\n        }\n```\n\n##### 1.1.1.2.4. parseClusterPackage函数\n\n这里只分析parseClusterPackage,省略parseMonolithicPackage函数的分析\n\n```java\nprivate Package parseClusterPackage(File packageDir, int flags) throws PackageParserException {\n    // 调用 parseClusterPackageLite  返回PackageLite对象\n    final PackageLite lite = parseClusterPackageLite(packageDir, 0);\n    // 磁盘加密相关, 如果直解析core app. 直接跳过\n    if (mOnlyCoreApps && !lite.coreApp) {\n        throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,\n                \"Not a coreApp: \" + packageDir);\n    }\n\n    final AssetManager assets = new AssetManager();\n    try {\n        // Load the base and all splits into the AssetManager\n        // so that resources can be overriden when parsing the manifests.\n        // 将lib库加载进 AssetManager 中\n        loadApkIntoAssetManager(assets, lite.baseCodePath, flags);\n\n...\n        final File baseApk = new File(lite.baseCodePath);\n        //通过将baseApk的地址传入,解析baseApk, 返回Package对象\n        final Package pkg = parseBaseApk(baseApk, assets, flags);\n....\n        pkg.setCodePath(packageDir.getAbsolutePath());\n        pkg.setUse32bitAbi(lite.use32bitAbi);\n        return pkg;\n    } finally {\n        IoUtils.closeQuietly(assets);\n    }\n}\n```\n\n这里用到的数据结构为PackageLite\n\n##### 1.1.1.2.5. parseClusterPackageLite函数\n\n```java\nprivate static PackageLite parseClusterPackageLite(File packageDir, int flags)\n        throws PackageParserException {\n    final File[] files = packageDir.listFiles();\n.....\n    String packageName = null;\n    int versionCode = 0;\n\n    final ArrayMap<String, ApkLite> apks = new ArrayMap<>();\n    for (File file : files) {\n        if (isApkFile(file)) {\n            // 对apk文件进行解析, 返回ApkLite对象, 包含baseApk和 splitApk, \n            final ApkLite lite = parseApkLite(file, flags);\n\n            // Assert that all package names and version codes are\n            // consistent with the first one we encounter.\n         \n            if (packageName == null) {\n                packageName = lite.packageName;\n                versionCode = lite.versionCode;\n            }\n            // 以lite.splitName 为 key 保存 解析完成的ApkLite 对象,其中 baseApk 的 splitName为null\n            apks.put(lite.splitName, lite)\n          ...\n        }\n    }\n  ...\n    final ApkLite baseApk = apks.remove(null);  \n    final String codePath = packageDir.getAbsolutePath();\n    // 生成PackageLite对象\n    return new PackageLite(codePath, baseApk, splitNames, splitCodePaths,\n            splitRevisionCodes);\n}\n```\n\nparseClusterPackageLite函数用到了两个数据结构  ApkLite 和 PackageLite\n\n##### 1.1.1.2.6. parseBaseApk函数\n\n```java\nprivate Package parseBaseApk(File apkFile, AssetManager assets, int flags)\n        throws PackageParserException {\n    final String apkPath = apkFile.getAbsolutePath();\n    // apk绑定 volumeUuid data分区还是sd卡格式化为内部存储的\n    String volumeUuid = null;\n    if (apkPath.startsWith(MNT_EXPAND)) {\n        final int end = apkPath.indexOf('/', MNT_EXPAND.length());\n        volumeUuid = apkPath.substring(MNT_EXPAND.length(), end);\n    }\n\n    if (DEBUG_JAR) Slog.d(TAG, \"Scanning base APK: \" + apkPath);\n   // 将apk载入到AssetManager中,加载入内存?\n    final int cookie = loadApkIntoAssetManager(assets, apkPath, flags);\n\n    Resources res = null;\n    XmlResourceParser parser = null;\n    try {\n        res = new Resources(assets, mMetrics, null);\n        assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                Build.VERSION.RESOURCES_SDK_INT);\n       // 通过 Jni 的方法将apk的manifest文件加载到内存,返回parser对象\n        parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\n\n        final String[] outError = new String[1];\n        // 调用 重载的方法真正进行解析\n        final Package pkg = parseBaseApk(res, parser, flags, outError);\n....\n\n        pkg.setVolumeUuid(volumeUuid);\n        pkg.setApplicationVolumeUuid(volumeUuid);\n        pkg.setBaseCodePath(apkPath);\n        pkg.setSignatures(null);\n\n        return pkg;\n\n    } \n  ...\n}\n\n\nprivate Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,\n            String[] outError) throws XmlPullParserException, IOException {\n        final String splitName;\n        final String pkgName;\n\n    ... // 省略解析splitApk相关\n     \t//构造package对象\n        final Package pkg = new Package(pkgName);\n\n        TypedArray sa = res.obtainAttributes(parser,\n                com.android.internal.R.styleable.AndroidManifest);\n\n        pkg.mVersionCode = pkg.applicationInfo.versionCode = sa.getInteger(\n                com.android.internal.R.styleable.AndroidManifest_versionCode, 0);\n        pkg.baseRevisionCode = sa.getInteger(\n                com.android.internal.R.styleable.AndroidManifest_revisionCode, 0);\n        pkg.mVersionName = sa.getNonConfigurationString(\n                com.android.internal.R.styleable.AndroidManifest_versionName, 0);\n        if (pkg.mVersionName != null) {\n            pkg.mVersionName = pkg.mVersionName.intern();\n        }\n        pkg.coreApp = parser.getAttributeBooleanValue(null, \"coreApp\", false);\n\n        sa.recycle();\n    \t// 调用parseBaseApkCommon函数对apk进行解析\n        return parseBaseApkCommon(pkg, null, res, parser, flags, outError);\n    }\n```\n\n这里用到的数据结构时Package\n\n##### 1.1.1.2.7. parseBaseApkCommon函数\n\n对apk AndroidManifest进行解析,解析[manifest节点](https://developer.android.com/guide/topics/manifest/manifest-element.html?hl=zh-cn)\n\n```java\nprivate Package parseBaseApkCommon(Package pkg, Set<String> acceptedTags, Resources res,\n        XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException,\n        IOException {\n    mParseInstrumentationArgs = null;\n    mParseActivityArgs = null;\n    mParseServiceArgs = null;\n    mParseProviderArgs = null;\n\n    int type;\n    boolean foundApp = false;\n\n    TypedArray sa = res.obtainAttributes(parser,\n            com.android.internal.R.styleable.AndroidManifest);\n\n    String str = sa.getNonConfigurationString(\n            com.android.internal.R.styleable.AndroidManifest_sharedUserId, 0);\n    ...\n\n    pkg.installLocation = sa.getInteger(\n            com.android.internal.R.styleable.AndroidManifest_installLocation,\n            PARSE_DEFAULT_INSTALL_LOCATION);\n    pkg.applicationInfo.installLocation = pkg.installLocation;\n\n\n    /* Set the global \"forward lock\" flag */\n    if ((flags & PARSE_FORWARD_LOCK) != 0) {\n        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_FORWARD_LOCK;\n    }\n\n    /* Set the global \"on SD card\" flag */\n    if ((flags & PARSE_EXTERNAL_STORAGE) != 0) {\n        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_EXTERNAL_STORAGE;\n    }\n\n    if ((flags & PARSE_IS_EPHEMERAL) != 0) {\n        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_EPHEMERAL;\n    }\n\n    // Resource boolean are -1, so 1 means we don't know the value.\n    int supportsSmallScreens = 1;\n    int supportsNormalScreens = 1;\n    int supportsLargeScreens = 1;\n    int supportsXLargeScreens = 1;\n    int resizeable = 1;\n    int anyDensity = 1;\n\n    int outerDepth = parser.getDepth();\n    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n            && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {\n        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n            continue;\n        }\n\n        String tagName = parser.getName();\n\n...\n\n        if (tagName.equals(TAG_APPLICATION)) {\n            // 只能有一个application节点\n            if (foundApp) {\n                 // 刚性解析,直接跳出\n                if (RIGID_PARSER) {\n                    outError[0] = \"<manifest> has more than one <application>\";\n                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                    return null;\n                } else {\n                    Slog.w(TAG, \"<manifest> has more than one <application>\");\n                    XmlUtils.skipCurrentTag(parser);\n                    continue;\n                }\n            }\n\n            foundApp = true;\n            //  解析application节点\n            if (!parseBaseApplication(pkg, res, parser, flags, outError)) {\n                return null;\n            }\n        }\n      ...\n        // 解析manifest节点下的其他节点\n    }\n```\n\n##### 1.1.1.2.8. parseBaseApplication函数\n\n解析[application节点](https://developer.android.com/guide/topics/manifest/application-element.html?hl=zh-cn)\n\n```java\nprivate boolean parseBaseApplication(Package owner, Resources res,\n        XmlResourceParser parser, int flags, String[] outError)\n    throws XmlPullParserException, IOException {\n    final ApplicationInfo ai = owner.applicationInfo;\n    final String pkgName = owner.applicationInfo.packageName;\n\n    TypedArray sa = res.obtainAttributes(parser,\n            com.android.internal.R.styleable.AndroidManifestApplication);\n\n    String name = sa.getNonConfigurationString(\n            com.android.internal.R.styleable.AndroidManifestApplication_name, 0);\n\n\n    String manageSpaceActivity = sa.getNonConfigurationString(\n            com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,\n            Configuration.NATIVE_CONFIG_VERSION);\n\n\n    boolean allowBackup = sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_allowBackup, true);\n    ...\n\n    ai.icon = sa.getResourceId(\n            com.android.internal.R.styleable.AndroidManifestApplication_icon, 0);\n    ai.logo = sa.getResourceId(\n            com.android.internal.R.styleable.AndroidManifestApplication_logo, 0);\n    ai.banner = sa.getResourceId(\n            com.android.internal.R.styleable.AndroidManifestApplication_banner, 0);\n    ai.theme = sa.getResourceId(\n            com.android.internal.R.styleable.AndroidManifestApplication_theme, 0);\n    ai.descriptionRes = sa.getResourceId(\n            com.android.internal.R.styleable.AndroidManifestApplication_description, 0);\n\n    if ((flags&PARSE_IS_SYSTEM) != 0) {\n        // 只有 PARSE_IS_SYSTEM 标志的目录解析 带persistent的才会生效,常驻进程\n        if (sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestApplication_persistent,\n                false)) {\n            ai.flags |= ApplicationInfo.FLAG_PERSISTENT;\n        }\n    }\n\n....\n    // debug标记\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_debuggable,\n            false)) {\n        ai.flags |= ApplicationInfo.FLAG_DEBUGGABLE;\n    }\n    ...\n    // 默认为true. 除了特殊情况, An application would not have any code of its own only if it's using nothing but built-in component classes, 比如AliasActivity\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_hasCode,\n            true)) {\n        ai.flags |= ApplicationInfo.FLAG_HAS_CODE;\n    }\n\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,\n            true)) {\n        ai.flags |= ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;\n    }\n\n    // The parent package controls installation, hence specify test only installs.\n    if (owner.parentPackage == null) {\n        if (sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestApplication_testOnly,\n                false)) {\n            ai.flags |= ApplicationInfo.FLAG_TEST_ONLY;\n        }\n    }\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_largeHeap,\n            false)) {\n        ai.flags |= ApplicationInfo.FLAG_LARGE_HEAP;\n    }\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_usesCleartextTraffic,\n            true)) {\n        ai.flags |= ApplicationInfo.FLAG_USES_CLEARTEXT_TRAFFIC;\n    }\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl,\n            false /* default is no RTL support*/)) {\n        ai.flags |= ApplicationInfo.FLAG_SUPPORTS_RTL;\n    }\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_multiArch,\n            false)) {\n        ai.flags |= ApplicationInfo.FLAG_MULTIARCH;\n    }\n\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestApplication_extractNativeLibs,\n            true)) {\n        ai.flags |= ApplicationInfo.FLAG_EXTRACT_NATIVE_LIBS;\n    }\n\n    if (sa.getBoolean(\n            R.styleable.AndroidManifestApplication_defaultToDeviceProtectedStorage,\n            false)) {\n        ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE;\n    }\n    if (sa.getBoolean(\n            R.styleable.AndroidManifestApplication_directBootAware,\n            false)) {\n        ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE;\n    }\n\n...\n    String str;\n    // 自定义权限\n    str = sa.getNonConfigurationString(\n            com.android.internal.R.styleable.AndroidManifestApplication_permission, 0);\n    ai.permission = (str != null && str.length() > 0) ? str.intern() : null;\n\n    ai.taskAffinity = buildTaskAffinityName(ai.packageName, ai.packageName,\n            str, outError);\n\n    if (outError[0] == null) {\n        CharSequence pname;\n        if (owner.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.FROYO) {\n            pname = sa.getNonConfigurationString(\n                    com.android.internal.R.styleable.AndroidManifestApplication_process,\n                    Configuration.NATIVE_CONFIG_VERSION);\n        } else {\n            // Some older apps have been seen to use a resource reference\n            // here that on older builds was ignored (with a warning).  We\n            // need to continue to do this for them so they don't break.\n            pname = sa.getNonResourceString(\n                    com.android.internal.R.styleable.AndroidManifestApplication_process);\n        }\n        //重设进程名?\n        ai.processName = buildProcessName(ai.packageName, null, pname,\n                flags, mSeparateProcesses, outError);\n\n        ai.enabled = sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestApplication_enabled, true);\n\n        if (sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestApplication_isGame, false)) {\n            ai.flags |= ApplicationInfo.FLAG_IS_GAME;\n        }\n\n\n    }\n\n\n    final int innerDepth = parser.getDepth();\n    int type;\n    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT\n            && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {\n        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n            continue;\n        }\n\n        String tagName = parser.getName();\n        if (tagName.equals(\"activity\")) {\n            // 调用parseActivity对activity节点进行解析\n            Activity a = parseActivity(owner, res, parser, flags, outError, false,\n                    owner.baseHardwareAccelerated);\n            if (a == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n            owner.activities.add(a);\n\n        } else if (tagName.equals(\"receiver\")) {\n          // 调用parseActivity对receiver节点进行解析\n            Activity a = parseActivity(owner, res, parser, flags, outError, true, false);\n            if (a == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n            owner.receivers.add(a);\n\n        } else if (tagName.equals(\"service\")) {\n          // 调用parseService对service节点进行解析\n            Service s = parseService(owner, res, parser, flags, outError);\n            if (s == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n            owner.services.add(s);\n\n        } else if (tagName.equals(\"provider\")) {\n          // 调用parseProvider对provider节点进行解析\n            Provider p = parseProvider(owner, res, parser, flags, outError);\n            if (p == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n            owner.providers.add(p);\n\n        } else if (tagName.equals(\"activity-alias\")) {\n            Activity a = parseActivityAlias(owner, res, parser, flags, outError);\n            if (a == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n            owner.activities.add(a);\n\n        } else if (parser.getName().equals(\"meta-data\")) {\n            // note: application meta-data is stored off to the side, so it can\n            // remain null in the primary copy (we like to avoid extra copies because\n            // it can be large)\n            if ((owner.mAppMetaData = parseMetaData(res, parser, owner.mAppMetaData,\n                    outError)) == null) {\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n\n        } else if (tagName.equals(\"library\")) {\n            sa = res.obtainAttributes(parser,\n                    com.android.internal.R.styleable.AndroidManifestLibrary);\n\n            // Note: don't allow this value to be a reference to a resource\n            // that may change.\n            String lname = sa.getNonResourceString(\n                    com.android.internal.R.styleable.AndroidManifestLibrary_name);\n\n            sa.recycle();\n\n            if (lname != null) {\n                lname = lname.intern();\n                if (!ArrayUtils.contains(owner.libraryNames, lname)) {\n                    owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname);\n                }\n            }\n\n            XmlUtils.skipCurrentTag(parser);\n\n        } else if (tagName.equals(\"uses-library\")) {\n            sa = res.obtainAttributes(parser,\n                    com.android.internal.R.styleable.AndroidManifestUsesLibrary);\n\n            // Note: don't allow this value to be a reference to a resource\n            // that may change.\n            String lname = sa.getNonResourceString(\n                    com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);\n            boolean req = sa.getBoolean(\n                    com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,\n                    true);\n\n            sa.recycle();\n\n            if (lname != null) {\n                lname = lname.intern();\n                if (req) {\n                    owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname);\n                } else {\n                    owner.usesOptionalLibraries = ArrayUtils.add(\n                            owner.usesOptionalLibraries, lname);\n                }\n            }\n\n            XmlUtils.skipCurrentTag(parser);\n\n        } else if (tagName.equals(\"uses-package\")) {\n            // Dependencies for app installers; we don't currently try to\n            // enforce this.\n            XmlUtils.skipCurrentTag(parser);\n\n        } else {\n            if (!RIGID_PARSER) {\n                Slog.w(TAG, \"Unknown element under <application>: \" + tagName\n                        + \" at \" + mArchiveSourcePath + \" \"\n                        + parser.getPositionDescription());\n                XmlUtils.skipCurrentTag(parser);\n                continue;\n            } else {\n                outError[0] = \"Bad element under <application>: \" + tagName;\n                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;\n                return false;\n            }\n        }\n    }    \n\n    if (hasDomainURLs(owner)) {\n        owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS;\n    } else {\n        owner.applicationInfo.privateFlags &= ~ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS;\n    }\n\n    return true;\n}\n```\n\n解析的结果更新到Package owner对象中. 这里用到的数据结构是Activity 和 ApplicationInfo\n\n##### 1.1.1.2.9. parseActivity函数\n\n对[activity节点](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn)进行解析\n\n```java\nprivate Activity parseActivity(Package owner, Resources res,\n        XmlResourceParser parser, int flags, String[] outError,\n        boolean receiver, boolean hardwareAccelerated)\n        throws XmlPullParserException, IOException {\n    TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestActivity);\n\n    if (mParseActivityArgs == null) {\n        mParseActivityArgs = new ParseComponentArgs(owner, outError,\n                R.styleable.AndroidManifestActivity_name,\n                R.styleable.AndroidManifestActivity_label,\n                R.styleable.AndroidManifestActivity_icon,\n                R.styleable.AndroidManifestActivity_logo,\n                R.styleable.AndroidManifestActivity_banner,\n                mSeparateProcesses,\n                R.styleable.AndroidManifestActivity_process,\n                R.styleable.AndroidManifestActivity_description,\n                R.styleable.AndroidManifestActivity_enabled);\n    }\n\n    mParseActivityArgs.tag = receiver ? \"<receiver>\" : \"<activity>\";\n    mParseActivityArgs.sa = sa;\n    mParseActivityArgs.flags = flags;\n\n    Activity a = new Activity(mParseActivityArgs, new ActivityInfo());\n    if (outError[0] != null) {\n        sa.recycle();\n        return null;\n    }\n\t// Activity 是否可由其他应用的组件启动 若为“false”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用(shareUserId)启动。\n    boolean setExported = sa.hasValue(R.styleable.AndroidManifestActivity_exported);\n    if (setExported) {\n        a.info.exported = sa.getBoolean(R.styleable.AndroidManifestActivity_exported, false);\n    }\n\n...\n\t// Activity 逻辑父项的类名称。此处的名称必须与为相应 <activity> 元素的 android:name 属性指定的类名称一致。\n//系统会读取该属性，以确定当用户按下操作栏中的“向上”按钮时应该启动哪一个 Activity。 系统还可以利用这些信息通过 TaskStackBuilder 合成 Activity 的返回栈。\n    String parentName = sa.getNonConfigurationString(\n            R.styleable.AndroidManifestActivity_parentActivityName,\n            Configuration.NATIVE_CONFIG_VERSION);\n    if (parentName != null) {\n        String parentClassName = buildClassName(a.info.packageName, parentName, outError);\n        if (outError[0] == null) {\n            a.info.parentActivityName = parentClassName;\n        } else {\n            Log.e(TAG, \"Activity \" + a.info.name + \" specified invalid parentActivityName \" +\n                    parentName);\n            outError[0] = null;\n        }\n    }\n\n    String str;\n  //客户端启动 Activity 或以其他方式令其响应 Intent 而必须具备的权限的名称。 如果系统尚未向 startActivity() 或 startActivityForResult() 的调用方授予指定权限，其 Intent 将不会传递给 Activity。\n//如果未设置该属性，则对 Activity 应用 <application> 元素的 permission 属性设置的权限。 如果这两个属性均未设置，则 Activity 不受权限保护。\n    str = sa.getNonConfigurationString(R.styleable.AndroidManifestActivity_permission, 0);\n    if (str == null) {\n        a.info.permission = owner.applicationInfo.permission;\n    } else {\n        a.info.permission = str.length() > 0 ? str.toString().intern() : null;\n    }\n// 与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定。\n//亲和关系确定两件事 - Activity 更改到的父项任务（请参阅 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的任务。\n    str = sa.getNonConfigurationString(\n            R.styleable.AndroidManifestActivity_taskAffinity,\n            Configuration.NATIVE_CONFIG_VERSION);\n    a.info.taskAffinity = buildTaskAffinityName(owner.applicationInfo.packageName,\n            owner.applicationInfo.taskAffinity, str, outError);\n\n    a.info.flags = 0;\n    ... // 省略一系列标签,具体可参考Activity节点\n\n    if (a.info.directBootAware) {\n        owner.applicationInfo.privateFlags |=\n                ApplicationInfo.PRIVATE_FLAG_PARTIALLY_DIRECT_BOOT_AWARE;\n    }\n\n    sa.recycle();\n\n    int outerDepth = parser.getDepth();\n    int type;\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT\n           && (type != XmlPullParser.END_TAG\n                   || parser.getDepth() > outerDepth)) {\n        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n            continue;\n        }\n\n        if (parser.getName().equals(\"intent-filter\")) {\n            ActivityIntentInfo intent = new ActivityIntentInfo(a);\n            // 调用parseIntent解析intent-filter标签\n            if (!parseIntent(res, parser, true, true, intent, outError)) {\n                return null;\n            }\n            if (intent.countActions() == 0) {\n...\n            } else {\n                a.intents.add(intent);\n            }\n          // 首选应用标签.指定默认应用\n        } else if (!receiver && parser.getName().equals(\"preferred\")) {\n            ActivityIntentInfo intent = new ActivityIntentInfo(a);\n            if (!parseIntent(res, parser, false, false, intent, outError)) {\n                return null;\n            }\n            if (intent.countActions() == 0) {\n...\n            } else {\n                if (owner.preferredActivityFilters == null) {\n                    owner.preferredActivityFilters = new ArrayList<ActivityIntentInfo>();\n                }\n                owner.preferredActivityFilters.add(intent);\n            }\n        } else if (parser.getName().equals(\"meta-data\")) {\n            // 调用 parseMetaData 解析 meta-data标签\n            if ((a.metaData = parseMetaData(res, parser, a.metaData,\n                    outError)) == null) {\n                return null;\n            }\n          // activity的布局相关\n        } else if (!receiver && parser.getName().equals(\"layout\")) {\n            parseLayout(res, parser, a);\n        } \n      ...\n        }\n    }\n\n    if (!setExported) {\n        a.info.exported = a.intents.size() > 0;\n    }\n\n    return a;\n}\n```\n\n##### 1.1.1.2.10. parseActivityAlias函数\n\n对[activity-alias标签](https://developer.android.com/guide/topics/manifest/activity-alias-element.html?hl=zh-cn)进行解析:\n\n>   An alias for an activity, named by the `targetActivity` attribute. The target must be in the same application as the alias and it must be declared before the alias in the manifest.\n\n指定targetActivity的应用别名\n\n#### 1.1.1.3. 扫描对应的数据结构简要分析\n\n![ScanPackage](/images/ScanPackage.png)\n\n>   当一切解析完成，返回解析的结果PackageParser.Package pkg\n\n#### 1.1.1.4. 安装流程\n\n##### 1.1.1.4.1. 过滤解析到的package对象\n\n```java\n// Scan the parent\nPackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags,\n        scanFlags, currentTime, user);\n\n// Scan the children\nfinal int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;\nfor (int i = 0; i < childCount; i++) {\n    PackageParser.Package childPackage = pkg.childPackages.get(i);\n    scanPackageInternalLI(childPackage, scanFile, policyFlags, scanFlags,\n            currentTime, user);\n}\n```\n\n调用到了scanPackageInternalLI函数\n\n##### 1.1.1.4.2. scanPackageInternalLI函数\n\n-   获取原始包信息/解析到的包信息PackageSetting，以及查询是否是升级的系统包信息\n\n从上一步parsePackage处返回的Package 的pkg对象和mSettings中保存的进行比较?\n\n之前的mSettings中的值是从哪里来的\n\n```java\n    // Look to see if we already know about this package.\n    String oldName = mSettings.mRenamedPackages.get(pkg.packageName);\n    if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {\n        // This package has been renamed to its original name.  Let's\n        // use that.\n        ps = mSettings.peekPackageLPr(oldName);\n    }\n    // If there was no original package, see one for the real package name.\n    if (ps == null) {\n        ps = mSettings.peekPackageLPr(pkg.packageName);\n    }\n    // Check to see if this package could be hiding/updating a system\n    // package.  Must look for it either under the original or real\n    // package name depending on our state.\n    // 如果是hiding package\n    updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);\n    if (DEBUG_INSTALL && updatedPkg != null) Slog.d(TAG, \"updatedPkg = \" + updatedPkg);\n}\n```\n\n###### 1.1.1.4.2.1. 过滤要更新的系统包\n\n当前解析的包信息是需要升级的系统级应用并且APK包路径发生变化时，根据版本信息选择跳过或者升级该包：\n\n-   当前扫描到的版本信息小于已安装版本信息：\n\n直接返回null，不再进行后续的安装操作。相关代码如下：\n\n```java\nif (ps != null && !ps.codePath.equals(scanFile)) {\n    // The path has changed from what was last scanned...  check the\n    // version of the new path against what we have stored to determine\n    // what to do.\n    if (DEBUG_INSTALL) Slog.d(TAG, \"Path changing from \" + ps.codePath);\n    // 当前扫描到的版本信息小于已安装版本信息\n    if (pkg.mVersionCode <= ps.versionCode) {\n        // The system package has been updated and the code path does not match\n        // Ignore entry. Skip it.\n        if (DEBUG_INSTALL) Slog.i(TAG, \"Package \" + ps.name + \" at \" + scanFile\n                + \" ignored: updated version \" + ps.versionCode\n                + \" better than this \" + pkg.mVersionCode);\n        if (!updatedPkg.codePath.equals(scanFile)) {\n            Slog.w(PackageManagerService.TAG, \"Code path for hidden system pkg \"\n                    + ps.name + \" changing from \" + updatedPkg.codePathString\n                    + \" to \" + scanFile);\n            // 更新path\n            updatedPkg.codePath = scanFile;\n            updatedPkg.codePathString = scanFile.toString();\n            updatedPkg.resourcePath = scanFile;\n            updatedPkg.resourcePathString = scanFile.toString();\n        }\n        updatedPkg.pkg = pkg;\n        updatedPkg.versionCode = pkg.mVersionCode;\n\n        // Update the disabled system child packages to point to the package too.\n        final int childCount = updatedPkg.childPackageNames != null\n                ? updatedPkg.childPackageNames.size() : 0;\n        for (int i = 0; i < childCount; i++) {\n            String childPackageName = updatedPkg.childPackageNames.get(i);\n            PackageSetting updatedChildPkg = mSettings.getDisabledSystemPkgLPr(\n                    childPackageName);\n            if (updatedChildPkg != null) {\n                updatedChildPkg.pkg = pkg;\n                updatedChildPkg.versionCode = pkg.mVersionCode;\n            }\n        }\n\n        throw new PackageManagerException(Log.WARN, \"Package \" + ps.name + \" at \"\n                + scanFile + \" ignored: updated version \" + ps.versionCode\n                + \" better than this \" + pkg.mVersionCode);\n    }\n```\n\n-   扫描到的版本信息大于已安装版本信息:\n\n首先从PackageManagerService.mPackages删除原始包信息，创建安装参数，删除dexFile，并将包从mSettings.mDisabledSysPackages中删除，将新的包信息添加到PackageManagerService.mPackages中。\n\n```java\nelse {\n    synchronized (mPackages) {\n        // Just remove the loaded entries from package lists.\n      // 从PackageManagerService.mPackages删除原始包信息\n        mPackages.remove(ps.name);\n    }\n  // 创建安装参数，删除dexFile\n    InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),\n            ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));\n    synchronized (mInstallLock) {\n        args.cleanUpResourcesLI();\n    }\n  // 将包从mSettings.mDisabledSysPackages中删除，将新的包信息添加到PackageManagerService.mPackages中\n    synchronized (mPackages) {\n        mSettings.enableSystemPackageLPw(ps.name);\n    }\n    updatedPkgBetter = true;\n}\n```\n\n同时由于要升级的系统级APK初始没有设置系统级标志，在此处添加；如果要更新的包原来是特权包，此处也要添加该标志。\n\n```java\nif (updatedPkg != null) {\n    // An updated system app will not have the PARSE_IS_SYSTEM flag set\n    // initially\n    policyFlags |= PackageParser.PARSE_IS_SYSTEM;\n\n    // An updated privileged app will not have the PARSE_IS_PRIVILEGED\n    // flag set initially\n    if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n        policyFlags |= PackageParser.PARSE_IS_PRIVILEGED;\n    }\n}\n```\n\n###### 1.1.1.4.2.2. 进行证书验证\n\n```java\n// Verify certificates against what was last scanned, 收集证书,并进行验证.验证文件内容和记录的hash值是否一致,不一致抛出异常.\ncollectCertificatesLI(ps, pkg, scanFile, policyFlags);\n```\n\n针对系统级APK，只验证AndroidManifest.xml文件；对于非系统级APK需验证所有的文件。将获得的证书和签名信息以及签名键值分别存入pkg.mCertificates、pkg.mSignatures以及pkg.mSigningKeys中。\n\n在对非系统级APK进行证书验证时，开启了两个线程进行验证，加快了验证速度，从而减少了APK的安装时间，改善了性能。\n\n###### 1.1.1.4.2.3. 系统级包与同名非系统级包冲突\n\n当要扫描安装的是新出现的系统级包，此时已经安装了同名的非系统级包，首先要验证签名信息：\n\n-   签名信息不匹配\n\n调用deletePackageLI方法，删除已安装的应用和数据，但不更新pakcages.xml等文件。\n\n```java\nif (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)\n        != PackageManager.SIGNATURE_MATCH) {\n    logCriticalInfo(Log.WARN, \"Package \" + ps.name + \" appeared on system, but\"\n            + \" signatures don't match existing userdata copy; removing\");\n    try (PackageFreezer freezer = freezePackage(pkg.packageName,\n            \"scanPackageInternalLI\")) {\n        deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);\n    }\n    ps = null;\n}\n```\n\n-   签名信息匹配\n\n当签名信息匹配时，如果当前系统包的版本低于已安装的非系统包，暂时隐藏该系统包，稍候再次扫描，如同更新一样添加该包。\n\n当版本信息高于已安装的非系统包，删除这个已安装的应用，删除codepath及dex文件,用新的系统包代替，但是保留已安装包的数据信息\n\n```java\nInstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),\n        ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));\nsynchronized (mInstallLock) {\n    args.cleanUpResourcesLI();\n}\n```\n\n###### 1.1.1.4.2.4. 后处理\n\n对于非系统目录下的apk，当它的代码和资源在不同的文件中时，添加`PARSE_FORWARD_LOCK`标志。\n\n接下来显式设置APK的应用信息路径，pkg.application.sourceDir设置为pkg.mScanPath； pkg.application.publicSourceDir则根据APk是否为前置锁类型，设置为 ps.resourcePathString/null(前置锁类型，可以扫描到包/不可以)，或者pkg.mScanPath。主要是为前置锁类型的APK更新其代码和资源文件路径，分别为data/app-private/<包名>.apk和data/app/<包名>.zip，然后据此更新pkg.mPath、pkg.mScanpath、pkg.application.sourceDir和pkg.application.publicSourceDir。\n\n接下来调用scanPackageLI解析和安装过滤后的pkg。\n\n##### 1.1.1.4.3. scanPackageLI函数\n\n调用scanPackageDirtyLI函数进行apk的安装\n\n```java\nprivate PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags,\n        int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {\n    boolean success = false;\n    try {\n        // 调用scanPackageDirtyLI函数进行apk的安装\n        final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags,\n                currentTime, user);\n        if (true) {\n            if (res.applicationInfo.primaryCpuAbi != null\n                    && !res.applicationInfo.primaryCpuAbi.isEmpty()\n                    && res.applicationInfo.primaryCpuAbi.startsWith(\"arm\")) {\n               //primaryCpuAbi 为arm开头的情况下, 替换统一的库\n                NativeLibraryHelper.replaceUnityLibraries(res.packageName,\n                    res.applicationInfo.nativeLibraryDir, res.applicationInfo.primaryCpuAbi);\n            }\n        }\n        success = true;\n        return res;\n    } finally {\n        if (!success && (scanFlags & SCAN_DELETE_DATA_ON_FAILURES) != 0) {\n            // DELETE_DATA_ON_FAILURES is only used by frozen paths\n            // 安装失败,清除应用数据\n            destroyAppDataLIF(pkg, UserHandle.USER_ALL,\n                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);\n            destroyAppProfilesLIF(pkg, UserHandle.USER_ALL);\n        }\n    }\n}\n```\n\n##### 1.1.1.4.4. scanPackageDirtyLI函数\n\n根据要解析的apk类型（系统级/特权级/其它），更新pkg.applicationInfo.flags的值。\n\n```java\n// Apply policy\nif ((policyFlags&PackageParser.PARSE_IS_SYSTEM) != 0) {\n    pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;\n    if (pkg.applicationInfo.isDirectBootAware()) {\n        // we're direct boot aware; set for all components\n        for (PackageParser.Service s : pkg.services) {\n            s.info.encryptionAware = s.info.directBootAware = true;\n        }\n        for (PackageParser.Provider p : pkg.providers) {\n            p.info.encryptionAware = p.info.directBootAware = true;\n        }\n        for (PackageParser.Activity a : pkg.activities) {\n            a.info.encryptionAware = a.info.directBootAware = true;\n        }\n        for (PackageParser.Activity r : pkg.receivers) {\n            r.info.encryptionAware = r.info.directBootAware = true;\n        }\n    }\n} else {\n    // 不是system app不能有下面的特权\n    // Only allow system apps to be flagged as core apps.\n    pkg.coreApp = false;\n    // clear flags not applicable to regular apps\n    pkg.applicationInfo.privateFlags &=\n            ~ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE;\n    pkg.applicationInfo.privateFlags &=\n            ~ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE;\n}\n```\n\n在PackageManagerService的启动阶段，如果设置了mCustomResolverComponentName，并且要解析的包名与其包名相同，则用其值替换要解析的组件名，并设置解析信息：\n\n```java\nif (mCustomResolverComponentName != null &&\n        mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {\n    setUpCustomResolverActivity(pkg);\n}\n\n    private void setUpCustomResolverActivity(PackageParser.Package pkg) {\n        synchronized (mPackages) {\n            mResolverReplaced = true;\n            // Set up information for custom user intent resolution activity.\n            mResolveActivity.applicationInfo = pkg.applicationInfo;\n            mResolveActivity.name = mCustomResolverComponentName.getClassName();\n            mResolveActivity.packageName = pkg.applicationInfo.packageName;\n            mResolveActivity.processName = pkg.applicationInfo.packageName;\n            mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;\n            mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS |\n                    ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;\n            mResolveActivity.theme = 0;\n            mResolveActivity.exported = true;\n            mResolveActivity.enabled = true;\n            mResolveInfo.activityInfo = mResolveActivity;\n            mResolveInfo.priority = 0;\n            mResolveInfo.preferredOrder = 0;\n            mResolveInfo.match = 0;\n            mResolveComponentName = mCustomResolverComponentName;\n            Slog.i(TAG, \"Replacing default ResolverActivity with custom activity: \" +\n                    mResolveComponentName);\n        }\n    }\n```\n\n###### 1.1.1.4.4.1. 处理framework-res.apk\n\n```java\n// framework-res.apk 相关\nif (pkg.packageName.equals(\"android\")) {\n    synchronized (mPackages) {\n        // 首先判定PackageManagerService.mAndroidApplication是否为null，因为framework-res.apk只能安装一次。\n        if (mAndroidApplication != null) {\n            Slog.w(TAG, \"*************************************************\");\n            Slog.w(TAG, \"Core android package being redefined.  Skipping.\");\n            Slog.w(TAG, \" file=\" + scanFile);\n            Slog.w(TAG, \"*************************************************\");\n            throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n                    \"Core android package being redefined.  Skipping.\");\n        }\n\n        if ((scanFlags & SCAN_CHECK_ONLY) == 0) {\n            // Set up information for our fall-back user intent resolution activity.\n            mPlatformPackage = pkg;\n            pkg.mVersionCode = mSdkVersion;\n            mAndroidApplication = pkg.applicationInfo;\n            // 该mResolveActivity用于用户自选activity\n            if (!mResolverReplaced) {\n                mResolveActivity.applicationInfo = mAndroidApplication;\n                mResolveActivity.name = ResolverActivity.class.getName();\n                mResolveActivity.packageName = mAndroidApplication.packageName;\n                mResolveActivity.processName = \"system:ui\";\n                mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;\n                mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;\n                mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;\n                mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert;\n                mResolveActivity.exported = true;\n                mResolveActivity.enabled = true;\n                mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE;\n                mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE\n                        | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE\n                        | ActivityInfo.CONFIG_SCREEN_LAYOUT\n                        | ActivityInfo.CONFIG_ORIENTATION\n                        | ActivityInfo.CONFIG_KEYBOARD\n                        | ActivityInfo.CONFIG_KEYBOARD_HIDDEN;\n                mResolveInfo.activityInfo = mResolveActivity;\n                mResolveInfo.priority = 0;\n                mResolveInfo.preferredOrder = 0;\n                mResolveInfo.match = 0;\n                mResolveComponentName = new ComponentName(\n                        mAndroidApplication.packageName, mResolveActivity.name);\n            }\n        }\n    }\n}\n```\n\n###### 1.1.1.4.4.2. 跳过已安装的APK\n\n```java\nif (mPackages.containsKey(pkg.packageName)\n        || mSharedLibraries.containsKey(pkg.packageName)) {\n    throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,\n            \"Application package \" + pkg.packageName\n                    + \" already installed.  Skipping duplicate.\");\n}\n```\n\n###### 1.1.1.4.4.3. 初始化应用信息\n\n```java\n// Initialize package source and resource directories\nFile destCodeFile = new File(pkg.applicationInfo.getCodePath());\nFile destResourceFile = new File(pkg.applicationInfo.getResourcePath());\n\nSharedUserSetting suid = null;\nPackageSetting pkgSetting = null;\n\nif (!isSystemApp(pkg)) {\n    // Only system apps can use these features.\n    pkg.mOriginalPackages = null;\n    pkg.mRealPackage = null;\n    pkg.mAdoptPermissions = null;\n}\n```\n\n###### 1.1.1.4.4.4. 检查并分配SharedUserId\n\npkg. mSharedUserId是在解析manifest标签的内置属性sharedUserId时赋值的。\n\n当应用解析到该属性，调用mSettings.getSharesUserLPw方法，获取SharedUserSetting类型的对象s。\n\n该方法首先从mSettings.mSharedUsers中根据pkg. SharedUserId查找是否存在该信息：若存在直接返回；否则，创建该数据类型，并调用mSettings.newUserIdLPw方法从mSettings.mUsersId中分配一个SharedUserSetting.userId（即在mUsersId中空位置插入s，获取索引号，或者在后面添加s获取索引号，或者mSettings.mUsersId已满则返回-1），如果成功获取SharedUserSetting.userId后，将新创建的对象s添加到mSettings.mSharedUsers中，返回该s。\n\n最后根据获取到的共享用户信息s：为null时直接返回null，跳过后续部分；否则继续后续步骤。\n\n```java\nif (pkg.mSharedUserId != null) {\n    // 添加shareUser到mSharedUsers中\n    suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);\n    if (suid == null) {\n        throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,\n                \"Creating application package \" + pkg.packageName\n                + \" for shared user failed\");\n    }\n}\n```\n\n###### 1.1.1.4.4.5. 检查并分配SharedUserId\n\npkg. mSharedUserId是在解析manifest标签的内置属性sharedUserId时赋值的。\n\n```java\nif (pkg.mSharedUserId != null) {\n  // 添加shareUser到mSharedUsers中\n  suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);\n  if (suid == null) {\n      throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,\n              \"Creating application package \" + pkg.packageName\n              + \" for shared user failed\");\n  }\n}\nSharedUserSetting getSharedUserLPw(String name,\n                                   int pkgFlags, int pkgPrivateFlags, boolean create) {\n  // 查找数组中有没有该 shareUserName 名称, 比如开头的 android.uid.system\n  SharedUserSetting s = mSharedUsers.get(name);\n  if (s == null) {\n    // create 为true \n    if (!create) {\n      return null;\n    }\n    s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags);\n    // 调用mSettings.newUserIdLPw方法从mSettings.mUsersId中分配一个SharedUserSetting.userId\n    // 即在mUsersId中空位置插入s，获取索引号，或者在后面添加s获取索引号，或者mSettings.mUsersId已满则返回-1\n    s.userId = newUserIdLPw(s);\n    Log.i(PackageManagerService.TAG, \"New shared user \" + name + \": id=\" + s.userId);\n    // < 0 means we couldn't assign a userid; fall out and return\n    // s, which is currently null\n    if (s.userId >= 0) {\n      mSharedUsers.put(name, s);\n    }\n  }\n\n  return s;\n}\n```\n\n###### 1.1.1.4.4.6. 处理系统级APK的原始包名mOriginalPackages(更名的包)\n\n当AndroidManafest.xml文件指定了original-package标签(原来的包名)，将name属性存入pkg. mOriginalPackages，`当前包名`存入pkg.mRealPackage.\n\n只有系统级应用，pkg.mOriginalPackages才为非null，此步骤有效.\n\n首先与mSettings.mRenamedPackages中pkg.mRealPackage对应的旧包名对比：\n\n-   旧包名包含在pkg.mOriginalPackages，沿用旧包名\n\n当旧包名renamed包含在pkg. mOriginalPackages中时，如果当前的包名pkg.packageName与旧包名renamed不相同时，调用pkg.setPackageName方法，将当前的包名更换为旧包名，其它涉及到包名的也更换，即新包沿用旧包包名\n\n```java\n// mRenamedPackages 中保存了所有经过重命名的包名,以其realName为键值.保存了 original-package标签的名字. \n// mSetting对应过去的对象\nfinal String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);\n// 当旧包名renamed包含在pkg. mOriginalPackages中时\nif (pkg.mOriginalPackages.contains(renamed)) {\n    // This package had originally been installed as the\n    // original name, and we have already taken care of\n    // transitioning to the new one.  Just update the new\n    // one to continue using the old name.\n    realName = pkg.mRealPackage;\n  // 如果当前包名不为 original-package , 就设为 original-package\n    if (!pkg.packageName.equals(renamed)) {\n        // Callers into this function may have already taken\n        // care of renaming the package; only do it here if\n        // it is not already done.\n        // 沿用旧包名\n        pkg.setPackageName(renamed);\n    }\n} \n```\n\n-   旧包名不包含在原始包名中，保留原始包信息\n\n当旧包名不包含在pkg. mOriginalPackages中时，遍历pkg. mOriginalPackages，确定安装包是否在某个原始包名下进行了安装：如果已安装，首先验证是否是系统级应用的升级行为，接着确定已安装的包信息和当前包信息的共享用户信息是否一致，当全部匹配时结束遍历。\n\n```java\nelse {\n    for (int i=pkg.mOriginalPackages.size()-1; i>=0; i--) {\n        // 最终返回不符合下面条件的包名, origPackage后面构造PackageSetting时会用到\n        if ((origPackage = mSettings.peekPackageLPr(\n                pkg.mOriginalPackages.get(i))) != null) {\n            // We do have the package already installed under its\n            // original name...  should we use it?\n            // 非系统目录返回失败,或者origPackage包当前已经安装的情况,会返回失败\n            if (!verifyPackageUpdateLPr(origPackage, pkg)) {\n                // New package is not compatible with original.\n                origPackage = null;\n                continue;\n            } else if (origPackage.sharedUser != null) {\n                // Make sure uid is compatible between packages.\n                // sharedUserId项 和 之前的不匹配,\n                if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {\n                    Slog.w(TAG, \"Unable to migrate data from \" + origPackage.name\n                            + \" to \" + pkg.packageName + \": old uid \"\n                            + origPackage.sharedUser.name\n                            + \" differs from \" + pkg.mSharedUserId);\n                    origPackage = null;\n                    continue;\n                }\n                // TODO: Add case when shared user id is added [b/28144775]\n            } else {\n                if (DEBUG_UPGRADE) Log.v(TAG, \"Renaming new package \"\n                        + pkg.packageName + \" to old name \" + origPackage.name);\n            }\n            break;\n        }\n    }\n```\n\n\n\n>   当安装包安装完成后，包名发生变更，在重启手机重新扫描该包时，将新包名更换为旧包名，沿用旧包名；但当pkg.mOriginalPackages中匹配不到旧包名时，保留新包名，并保留原始包信息，但下一章节中会对包名和原始包信息处理，最终更名的包都会沿用初始安装时的包名。\n\n###### 1.1.1.4.4.7. 获取/创建包信息PackageSetting\n\n调用mSettings.getPackageLPw方法获取已安装的包信息/创建新的包信息，但是并不添加到mSettings.mPackages中。\n\n首先判断mSettings.mPackages是否存在该包信息，即是否已经安装过安装包，从而决定是创建新的包信息还是返回原有包信息。\n\n如果存在包信息，说明包已经安装过，且是需要升级/更名的包，打印一些相关log信息，以及验证共享用户信息是否一致，代码如下：\n\n```java\npkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,\n        destResourceFile, pkg.applicationInfo.nativeLibraryRootDir,\n        pkg.applicationInfo.primaryCpuAbi,\n        pkg.applicationInfo.secondaryCpuAbi,\n        pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags,\n        user, false);\nif (pkgSetting == null) {\n    throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,\n            \"Creating application package \" + pkg.packageName + \" failed\");\n}\n\nPackageSetting getPackageLPw(PackageParser.Package pkg, PackageSetting origPackage,\n                             String realName, SharedUserSetting sharedUser, File codePath, File resourcePath,\n                             String legacyNativeLibraryPathString, String primaryCpuAbi, String secondaryCpuAbi,\n                             int pkgFlags, int pkgPrivateFlags, UserHandle user, boolean add) {\n  final String name = pkg.packageName;\n  final String parentPackageName = (pkg.parentPackage != null)\n    ? pkg.parentPackage.packageName : null;\n  // 处理包的子包,最终把 parentPackage childPackage的name取出来放到相应数据中\n  List<String> childPackageNames = null;\n  if (pkg.childPackages != null) {\n    // 遍历 childPackages\n    final int childCount = pkg.childPackages.size();\n    childPackageNames = new ArrayList<>(childCount);\n    for (int i = 0; i < childCount; i++) {\n      String childPackageName = pkg.childPackages.get(i).packageName;\n      childPackageNames.add(childPackageName);\n    }\n  }\n  \n  PackageSetting p = getPackageLPw(name, origPackage, realName, sharedUser, codePath,\n                                   resourcePath, legacyNativeLibraryPathString, primaryCpuAbi, secondaryCpuAbi,\n                                   pkg.mVersionCode, pkgFlags, pkgPrivateFlags, user, add, true /* allowInstall */,\n                                   // 传入上面得到的parentPackageName childPackageNames\n                                   parentPackageName, childPackageNames);\n  return p;\n}\n\n    private PackageSetting getPackageLPw(String name, PackageSetting origPackage,\n            String realName, SharedUserSetting sharedUser, File codePath, File resourcePath,\n            String legacyNativeLibraryPathString, String primaryCpuAbiString,\n            String secondaryCpuAbiString, int vc, int pkgFlags, int pkgPrivateFlags,\n            UserHandle installUser, boolean add, boolean allowInstall, String parentPackage,\n            List<String> childPackageNames) {\n        // mPackages 中是否能查到该对象\n        PackageSetting p = mPackages.get(name);\n        UserManagerService userManager = UserManagerService.getInstance();\n        if (p != null) {\n            // 能查到,则更新其字段\n...\n            if (!p.codePath.equals(codePath)) {\n                if ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {\n                    // 原来的是system app情况下, 此时解析的是data app, codepath并没有变更,沿用旧的值\n                    Slog.w(PackageManagerService.TAG, \"Trying to update system app code path from \"\n                            + p.codePathString + \" to \" + codePath.toString());\n                } else {\n                    // 此处为System app的情况, 设置所有用户都默认安装该应用\n                    if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 &&\n                            getDisabledSystemPkgLPr(name) == null) {\n                        List<UserInfo> allUserInfos = getAllUsers();\n                        if (allUserInfos != null) {\n                            for (UserInfo userInfo : allUserInfos) {\n                                p.setInstalled(true, userInfo.id);\n                            }\n                        }\n                    }\n            }\n            // sharedUser不相等时, 直接清空PackageSetting对象,即原来的作废\n            if (p.sharedUser != sharedUser) {\n                p = null;\n            } else {\n                // 此处对应的是新扫描的apk如果是特权apk, 则特权继承\n                p.pkgFlags |= pkgFlags & ApplicationInfo.FLAG_SYSTEM;\n                p.pkgPrivateFlags |= pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;\n            }\n        }\n        // 构造新的PackageSetting对象\n        if (p == null) {\n            // 如果 origPackage 不为空时, 很多属性会从 origPackage 拿过来.\n            if (origPackage != null) {\n                // We are consuming the data from an existing package.\n                // 如果是新的PackageSetting对象,则沿用旧的包名. 当前的包名 name 存放到 realName 字段\n                p = new PackageSetting(origPackage.name, name, codePath, resourcePath,\n                        legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString,\n                        null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags,\n                        parentPackage, childPackageNames);\n\n....\n                p.origPackage = origPackage;\n                p.getPermissionsState().copyFrom(origPackage.getPermissionsState());\n                mRenamedPackages.put(name, origPackage.name);\n                name = origPackage.name;\n                // Update new package state.\n                p.setTimeStamp(codePath.lastModified());\n            } else {\n              // 如果 origPackage 为空时\n                p = new PackageSetting(name, realName, codePath, resourcePath,\n                        legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString,\n                        null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags,\n                        parentPackage, childPackageNames);\n                p.setTimeStamp(codePath.lastModified());\n                p.sharedUser = sharedUser;\n                // If this is not a system app, it starts out stopped.\n                // 如果是非系统应用，置为stopped状态，并写入pakckage-restrictions.xml\n                if ((pkgFlags&ApplicationInfo.FLAG_SYSTEM) == 0) {                    \n                    if (DEBUG_STOPPED) {\n                        RuntimeException e = new RuntimeException(\"here\");\n                        e.fillInStackTrace();\n                        Slog.i(PackageManagerService.TAG, \"Stopping package \" + name, e);\n                    }\n                    List<UserInfo> users = getAllUsers();\n                    final int installUserId = installUser != null ? installUser.getIdentifier() : 0;\n                    if (users != null && allowInstall) {\n                        for (UserInfo user : users) {\n                            final boolean installed = installUser == null\n                                    || (installUserId == UserHandle.USER_ALL\n                                        && !isAdbInstallDisallowed(userManager, user.id))\n                                    || installUserId == user.id;\n                            p.setUserState(user.id, 0, COMPONENT_ENABLED_STATE_DEFAULT,\n                                    installed,\n                                    true, // stopped,   非系统应用默认禁用\n                                    true, // notLaunched\n                                    false, // hidden\n                                    false, // suspended\n                                    null, null, null,\n                                    false, // blockUninstall\n                                    INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0);\n                            // 此处会更新pakckage-restrictions.xml文件\n                            writePackageRestrictionsLPr(user.id);\n                        }\n                    }\n                }\n                if (sharedUser != null) {\n                    // shareUser 不为空, app对应的appid是shareUser的\n                    p.appId = sharedUser.userId;\n                } else {\n                    // Clone the setting here for disabled system packages\n                    // 当前包在禁用的系统包中的时候\n                    PackageSetting dis = mDisabledSysPackages.get(name);\n                    if (dis != null) {\n                        // 签名继承在mDisabledSysPackages找到的\n                        if (dis.signatures.mSignatures != null) {\n                            p.signatures.mSignatures = dis.signatures.mSignatures.clone();\n                        }\n                        p.appId = dis.appId;\n                        // Clone permissions\n                        p.getPermissionsState().copyFrom(dis.getPermissionsState());\n                        // Clone component info\n                        List<UserInfo> users = getAllUsers();\n                        if (users != null) {\n                            for (UserInfo user : users) {\n                                int userId = user.id;\n                                p.setDisabledComponentsCopy(\n                                        dis.getDisabledComponents(userId), userId);\n                                p.setEnabledComponentsCopy(\n                                        dis.getEnabledComponents(userId), userId);\n                            }\n                        }\n                        // Add new setting to list of user ids\n                        // 将p.appId添加到mSettngs.mUserIds或者mSettings.otherUserIds中\n                        addUserIdLPw(p.appId, p, name);\n                    } else {\n                        // Assign new user id\n                      // 获取应用id或者分配新的的id，添加到mSettngs.mUserIds或者mSettings.otherUserIds中\n                        p.appId = newUserIdLPw(p);\n                    }\n                }\n            }\n            if (p.appId < 0) {\n                return null;\n            }\n            if (add) {\n                // Finish adding new package by adding it and updating shared\n                // user preferences\n                addPackageSettingLPw(p, name, sharedUser);\n            }\n            // packageSetting不为新构造的情况下, 即packageSetting不为新构造的情况下, 当包信息存在时：不需要创建新的包信息，只需要获取包信息的安装状态，并根据安装状态决定是否更新pakckage-restrictions.xml文件。\n        } else {\n            if (installUser != null && allowInstall) {\n                List<UserInfo> users = getAllUsers();\n                if (users != null) {\n                    for (UserInfo user : users) {\n                    // 为所有用户安装,且没有禁用adb安装情况下|| 或指定为某个用户安装情况下, 对这些用户安装该apk, 并更新Pakcages.xml文件\n                        if ((installUser.getIdentifier() == UserHandle.USER_ALL\n                                    && !isAdbInstallDisallowed(userManager, user.id))\n                                || installUser.getIdentifier() == user.id) {\n                            boolean installed = p.getInstalled(user.id);\n                            if (!installed) {\n                                p.setInstalled(true, user.id);\n                                writePackageRestrictionsLPr(user.id);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return p;\n    }\n```\n\n最终返回创建/的包信息，如果包信息为null，说明无法创建该应用信息，直接返回，null，跳过后续步骤。\n\n###### 1.1.1.4.4.8. 更名包的后续处理\n\n创建的包信息包含原始包信息时，将包名更换为原始包信息的包名，并将原始包信息置为null。\n\n```java\nif (pkgSetting.origPackage != null) {\n\n  // 将包名更换为原始包信息的包名\n    pkg.setPackageName(origPackage.name);\n\n    // Make a note of it.\n    if ((scanFlags & SCAN_CHECK_ONLY) == 0) {\n        mTransferedPackages.add(origPackage.name);\n    }\n\n    // No longer need to retain this.\n    // 并将原始包信息置为null\n    pkgSetting.origPackage = null;\n}\n```\n\n对该包进行SELinux相关的操作。\n\n```java\nif (mFoundPolicyFile) {\n    SELinuxMMAC.assignSeinfoValue(pkg);\n}\n```\n\n将申请的包信息的应用pkgSetting.appId存入到pkg.applicationInfo.uid中，包信息pkgSetting存入到pkg.mExtras中。\n\n```java\npkg.applicationInfo.uid = pkgSetting.appId;\npkg.mExtras = pkgSetting;\n```\n\n###### 1.1.1.4.4.9. 为非系统应用更新共享库信息\n\n只有非系统级应用在扫描安装过程才会由于更新共享库导致安装失败，因此只针对非系统级应用在扫描过程中更新其共享库信息，而系统级应用在扫描完成后统一更新所有的共享库信息。\n\n调用**updateSharedLibrariesLPw**方法更新共享库信息，若失败，直接返回null。\n\n该方法主要是针对在AndroidManifest.xml文件中解析到的uses-library标签信息，信息存入了pkg.usesLibraries和pkg.usesOptionalLibraries。若二者都为null，说明没有用到库信息，直接返回true，解析过程继续；\n\n当pkg.usesLibraries不为null时，检查PackageManagerService.mSharedLibraries中是否存在该库信息：如果存在则将共享库对应的路径信息存入PackageManagerService.mTmpSharedLibraries中；否则说明APK声明了一个不存在的共享库，那么更新失败，返回false。\n\n当pkg.usesOptionalLibraries不为null时：检查PackageManagerService.mSharedLibraries中是否存在该库信息：如果存在则将共享库对应的路径信息存入PackageManagerService.mTmpSharedLibraries中；否则输出警告信息。\n\n最后，将共享库路径信息更新到pkg.usesLibrariesFiles中。\n\n```java\nif ((policyFlags&PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {\n    updateSharedLibrariesLPw(pkg, null);\n}\n\n    private void updateSharedLibrariesLPw(PackageParser.Package pkg,\n            PackageParser.Package changingLib) throws PackageManagerException {\n        if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {\n            final ArraySet<String> usesLibraryFiles = new ArraySet<>();\n            int N = pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;\n            for (int i=0; i<N; i++) {\n                // 从 mSharedLibraries 找对应的lib项\n                final SharedLibraryEntry file = mSharedLibraries.get(pkg.usesLibraries.get(i));\n                if (file == null) {\n                    //没有找到,报异常\n                    throw new PackageManagerException(INSTALL_FAILED_MISSING_SHARED_LIBRARY,\n                            \"Package \" + pkg.packageName + \" requires unavailable shared library \"\n                            + pkg.usesLibraries.get(i) + \"; failing!\");\n                }\n                // 此处changingLib为null,将file关联的codepath添加到usesLibraryFiles中\n                addSharedLibraryLPw(usesLibraryFiles, file, changingLib);\n            }\n            N = pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;\n            for (int i=0; i<N; i++) {\n                final SharedLibraryEntry file = mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));\n                if (file == null) {\n                    Slog.w(TAG, \"Package \" + pkg.packageName\n                            + \" desires unavailable shared library \"\n                            + pkg.usesOptionalLibraries.get(i) + \"; ignoring!\");\n                } else {\n                    addSharedLibraryLPw(usesLibraryFiles, file, changingLib);\n                }\n            }\n            // 最终更新到 package的usesLibraryFiles数组中\n            N = usesLibraryFiles.size();\n            if (N > 0) {                \n                pkg.usesLibraryFiles = usesLibraryFiles.toArray(new String[N]);\n            } else {\n                pkg.usesLibraryFiles = null;\n            }\n        }\n    }\n    private void addSharedLibraryLPw(ArraySet<String> usesLibraryFiles, SharedLibraryEntry file,\n            PackageParser.Package changingLib) {\n        if (file.path != null) {\n            usesLibraryFiles.add(file.path);\n            return;\n        }\n        // file.path为空时,继续往下走\n        PackageParser.Package p = mPackages.get(file.apk);\n        if (changingLib != null && changingLib.packageName.equals(file.apk)) {\n            // 没找到对应的package 或者 package和changingLib为同一包名时, 替换为ChangingLib的codepath\n            if (p == null || p.packageName.equals(changingLib.packageName)) {\n                p = changingLib;\n            }\n        }\n        // 将package的 codepath添加到usesLibraryFiles中\n        if (p != null) {\n            usesLibraryFiles.addAll(p.getAllCodePaths());\n        }\n    }\n```\n\n###### 1.1.1.4.4.10. 调用verifySignaturesLP验证签名\n\n要验证的签名信息是在验证证书时获取到的，验证通过继续后续步骤，主要是验证上一次安装的签名信息和本次扫描的签名信息是否一致，上一次共享用户信息的签名信息是否和本次扫描的签名信息一致\n\n```java\n// 检查其upgradeKeySets是否有效  pkgSetting 作为olgPkg\nif (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) {\n    // 检查PackageSettting和pkg中的签名是否一致\n    if (checkUpgradeKeySetLP(pkgSetting, pkg)) {\n        // We just determined the app is signed correctly, so bring\n        // over the latest parsed certs.\n        pkgSetting.signatures.mSignatures = pkg.mSignatures;\n    } else {\n        // 不一致且为data app的情况. 抛出异常\n        if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {\n            throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE,\n                    \"Package \" + pkg.packageName + \" upgrade keys do not match the \"\n                    + \"previously installed version\");\n        } else {\n            // 如果不一致,但pkg是system app, 直接替换掉旧签名\n            pkgSetting.signatures.mSignatures = pkg.mSignatures;\n            String msg = \"System package \" + pkg.packageName\n                + \" signature changed; retaining data.\";\n            reportSettingsProblem(Log.WARN, msg);\n        }\n    }\n} else {\n    // 包签名无效的情况, 验证签名\n    try {\n        verifySignaturesLP(pkgSetting, pkg);\n        // We just determined the app is signed correctly, so bring\n        // over the latest parsed certs.\n        // 验证通过,则替换到pkgSetting的签名为 pkg的签名\n        pkgSetting.signatures.mSignatures = pkg.mSignatures;\n    } catch (PackageManagerException e) {\n        if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {\n            // data app直接往上抛异常\n            throw e;\n        }\n        // The signature has changed, but this package is in the system\n        // image...  let's recover!\n        // 没有验证通过时, 如果为system app 仍然替换\n        pkgSetting.signatures.mSignatures = pkg.mSignatures;\n        // However...  if this package is part of a shared user, but it\n        // doesn't match the signature of the shared user, let's fail.\n        // What this means is that you can't change the signatures\n        // associated with an overall shared user, which doesn't seem all\n        // that unreasonable.\n        if (pkgSetting.sharedUser != null) {\n            // 如果其shareUserId不为空时, 如果shareuser 包对应的签名和当前pkg的签名不一致,抛出异常\n            if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,\n                                  pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {\n                throw new PackageManagerException(\n                        INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,\n                                \"Signature mismatch for shared user: \"\n                                + pkgSetting.sharedUser);\n            }\n    }\n}\n```\n\n\n\n当验证不通过时：对于扫描的是非系统目录，直接返回null，不再继续后续步骤；对于系统目录，将包的签名信息更新到包信息的签名信息中，然后验证包信息的共享用户信息的签名信息和包的签名信息是否一致，不一致直接返回null\n\n\n\n###### 1.1.1.4.4.11. 检查新包和已安装包的ContentProvider是否冲突\n\n对于首次安装的包，即`scanMode`&SCAN_NEW_INSTALL！=0，才检查该包的providers是否与PackageManagerService.mProvidersByAuthority冲突，当冲突时（即pkg.providers存储的某个成员存在于PackageManagerService.mProvidersByAuthority）返回null，跳过后续步骤，否则继续。\n\n```java\nif ((scanFlags & SCAN_NEW_INSTALL) != 0) {\n    final int N = pkg.providers.size();\n    int i;\n    for (i=0; i<N; i++) {\n        PackageParser.Provider p = pkg.providers.get(i);\n        if (p.info.authority != null) {\n            String names[] = p.info.authority.split(\";\");\n            for (int j = 0; j < names.length; j++) {\n                if (mProvidersByAuthority.containsKey(names[j])) {\n                    PackageParser.Provider other = mProvidersByAuthority.get(names[j]);\n                    final String otherPackageName =\n                            ((other != null && other.getComponentName() != null) ?\n                                    other.getComponentName().getPackageName() : \"?\");\n                   // 检查到冲突,抛出异常\n                    throw new PackageManagerException(\n                            INSTALL_FAILED_CONFLICTING_PROVIDER,\n                                    \"Can't install because provider name \" + names[j]\n                                    + \" (in package \" + pkg.applicationInfo.packageName\n                                    + \") is already used by \" + otherPackageName);\n                }\n            }\n        }\n    }\n}\n```\n\n###### 1.1.1.4.4.12. 为系统级包抽取权限信息\n\n只有系统级包才能抽取其它系统级包定义的权限，将该权限所属的包变为所要抽取的系统包名，被抽取的包名是通过pkg.mAdoptPermissions指定的。\n\n```java\nif ((scanFlags & SCAN_CHECK_ONLY) == 0 && pkg.mAdoptPermissions != null) {\n    // This package wants to adopt ownership of permissions from\n    // another package.\n    for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {\n      // 从 mAdoptPermissions 中取出原包名\n        final String origName = pkg.mAdoptPermissions.get(i);\n        final PackageSetting orig = mSettings.peekPackageLPr(origName);\n        if (orig != null) {\n           // orig package必须在system 中, 且 在mPackages中查询不到,即该 orig package还没有安装,只是经过扫描\n            if (verifyPackageUpdateLPr(orig, pkg)) {\n                Slog.i(TAG, \"Adopting permissions from \" + origName + \" to \"\n                        + pkg.packageName);\n                // Transfer ownership of permissions to the new package.\n                // 从orig package抽取 权限信息, 将其source package替换为现在的包名\n                mSettings.transferPermissionsLPw(origName, pkg.packageName);\n            }\n        }\n    }\n}\n```\n\n###### 1.1.1.4.4.13. 创建数据目录\n\n首先获取当前扫描的时间戳，便于更新第一次安装/升级时间。\n\n对于framework-res.apk，将/data/system路径存入pkg.applicationInfo.dataDir中。\n\n当前数据目录所有者ID与pkg,applicationInfo.uid匹配时，直接将数据目录存入pkg.applicationInfo.dataDir中；\n\n\n\n```java\n// 此处 mPlatformPackage 指的是 framework-res.apk\nif (pkg !=  mPlatformPackage ) {\n    // Get all of our default paths setup 机主用户\n    pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);\n}\n\npublic void initForUser(int userId) {\n  uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));\n  // android开头的包名,比如android.ext.services\n  if (\"android\".equals(packageName)) {\n    // 路径设置为 /data/system\n    dataDir = Environment.getDataSystemDirectory().getAbsolutePath();\n    return;\n  }\n  // DE区  /data/user_de/0\n  deviceEncryptedDataDir = deviceProtectedDataDir = Environment\n    .getDataUserDePackageDirectory(volumeUuid, userId, packageName)\n    .getAbsolutePath();\n  // CE区  /data/user/0   | /data/data\n  credentialEncryptedDataDir = credentialProtectedDataDir = Environment\n    .getDataUserCePackageDirectory(volumeUuid, userId, packageName)\n    .getAbsolutePath();\n  // 设置了 defaultToDeviceProtectedStorage 后,默认的数据目录在DE区\n  if ((privateFlags & PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) != 0\n      && PackageManager.APPLY_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) {\n    dataDir = deviceProtectedDataDir;\n  } else {\n    // 否则在CE区\n    dataDir = credentialProtectedDataDir;\n  }\n}\n```\n\n###### 1.1.1.4.4.14. 处理本地库目录\n\n当存储了本地库路径信息时，根据包的不同类型对本地库进行处理，决定是否从apk中解压出库文件到相应的本地库目录中`extractLibs`=true：\n\n```java\n// cpuAbiOverride 来源于 安装时 指定的参数\nfinal String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);\nif (pkgSetting != null && pkgSetting.hasMultiArchLibString != null)\n    pkg.applicationInfo.hasMultiArchLib = pkgSetting.hasMultiArchLibString;\n\nif ((scanFlags & SCAN_NEW_INSTALL) == 0) {\n    // 不是新安装的包名, 抽取native库到对应的库目录中\n    derivePackageAbi(pkg, scanFile, cpuAbiOverride, true /* extract libs */);\n\n    // Some system apps still use directory structure for native libraries\n    // in which case we might end up not detecting abi solely based on apk\n    // structure. Try to detect abi based on directory structure.\n  \n    // 上面使用 derivePackageAbi 无效时, primaryCpuAbi 为null. 需要基于 目录结构 监测abi,并设定指令集\n    if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() &&\n            pkg.applicationInfo.primaryCpuAbi == null) {\n        // 根据目录是否存在来设定指令集\n        setBundledAppAbisAndRoots(pkg, pkgSetting);\n        //  更新  pkg.applicationinfo的  nativeLibraryRootDir  nativeLibraryRootRequiresIsa nativeLibraryDir secondaryNativeLibraryDir\n        setNativeLibraryPaths(pkg);\n    }\n\n} else {\n    // 新安装的包的情况\n    if ((scanFlags & SCAN_MOVE) != 0) {\n        // 为移动apk的场景时. 直接继承原来的abi\n        // We haven't run dex-opt for this move (since we've moved the compiled output too)\n        // but we already have this packages package info in the PackageSetting. We just\n        // use that and derive the native library path based on the new codepath.\n        pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;\n        pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;\n    }\n\n    // Set native library paths again. For moves, the path will be updated based on the\n    // ABIs we've determined above. For non-moves, the path will be updated based on the\n    // ABIs we determined during compilation, but the path will depend on the final\n    // package path (after the rename away from the stage path).\n    setNativeLibraryPaths(pkg);\n}\n\n// This is a special case for the \"system\" package, where the ABI is\n// dictated by the zygote configuration (and init.rc). We should keep track\n// of this ABI so that we can deal with \"normal\" applications that run under\n// the same UID correctly.\n// framework-res.apk  初始化primaryCpuAbi\nif (mPlatformPackage == pkg) {\n    pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ?\n            Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];\n}\n\n    private void derivePackageAbi(PackageParser.Package pkg, File scanFile,\n                                 String cpuAbiOverride, boolean extractLibs)\n            throws PackageManagerException {\n        // 设定本地库目录, 本地库目录下可能并没有东西\n        setNativeLibraryPaths(pkg);\n\n        // We would never need to extract libs for forward-locked and external packages,\n        // since the container service will do it for us. We shouldn't attempt to\n        // extract libs from system app when it was not updated.\n        if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() ||\n                (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {\n            extractLibs = false;\n        }\n\n        final String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;\n        final boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;\n\n        NativeLibraryHelper.Handle handle = null;\n        try {\n            // 打开 apk 文件及splitapp文件\n            handle = NativeLibraryHelper.Handle.create(pkg);\n            final File nativeLibraryRoot = new File(nativeLibraryRootStr);\n\n            // Null out the abis so that they can be recalculated.\n            pkg.applicationInfo.primaryCpuAbi = null;\n            pkg.applicationInfo.secondaryCpuAbi = null;\n            // 包含多个指令集的情况\n            if (isMultiArch(pkg.applicationInfo)) {\n                // Warn if we've set an abiOverride for multi-lib packages..\n                // By definition, we need to copy both 32 and 64 bit libraries for\n                // such packages.\n                // install apk的参数\n                if (pkg.cpuAbiOverride != null\n                        && !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {\n                    Slog.w(TAG, \"Ignoring abiOverride for multi arch application.\");\n                }\n\n                int abi32 = PackageManager.NO_NATIVE_LIBRARIES;\n                int abi64 = PackageManager.NO_NATIVE_LIBRARIES;\n                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {\n              // data app 该值才为true 或者 system app 但不是update app的情况, 该标志的含义是从apk文件中解压出库文件写到对应的库目录中\n                    if (extractLibs) {\n                        // 创建 nativeLibraryRoot 目录, 将native 库的字节从apk 压缩文件中复制到相应库目录下\n                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,\n                                nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS,\n                                useIsaSpecificSubdirs);\n                    } else {\n                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);\n                    }\n                }\n\n                if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {\n                    if (extractLibs) {\n                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,\n                                nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS,\n                                useIsaSpecificSubdirs);\n                    } else {\n                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);\n                    }\n                }\n                if (abi64 >= 0) {\n                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];\n                }\n                // 同时有abi32 和abi64 的情况, 查询pkg的 use32bitAbi 确定其primaryCpuAbi\n                if (abi32 >= 0) {\n                    final String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];\n                    if (abi64 >= 0) {\n                        // use32bitAbi , 则 primaryCpuAbi 为abi32 . secondaryCpuAbi为abi64\n                        if (pkg.use32bitAbi) {\n                            pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;\n                            pkg.applicationInfo.primaryCpuAbi = abi;\n                        } else {\n                            // 否则 primaryCpuAbi 为abi64 . secondaryCpuAbi为abi32\n                            pkg.applicationInfo.secondaryCpuAbi = abi;\n                        }\n                    } else {\n                        // 只支持32. primaryCpuAbi为abi32\n                        pkg.applicationInfo.primaryCpuAbi = abi;\n                    }\n                }\n\n            } else {\n                // 单一指令集的情况\n                String[] abiList = (cpuAbiOverride != null) ?\n                        new String[] { cpuAbiOverride } : Build.SUPPORTED_ABIS;\n\n                // 编译优化相关. 暂不了解具体作用\n                // Renderscript compiler generates LLVM bitcode that is then shipped inside the application APK\n                boolean needsRenderScriptOverride = false;\n                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null &&\n                        NativeLibraryHelper.hasRenderscriptBitcode(handle)) {\n                    abiList = Build.SUPPORTED_32_BIT_ABIS;\n                    needsRenderScriptOverride = true;\n                }\n\n                final int copyRet;\n                if (extractLibs) {\n                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,\n                            nativeLibraryRoot, abiList, useIsaSpecificSubdirs);\n                } else {\n                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);\n                }\n\n                if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {\n                    throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,\n                            \"Error unpackaging native libs for app, errorCode=\" + copyRet);\n                }\n\n                if (copyRet >= 0) {\n                    // copyRet 中保存的是支持的abi集\n                    pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];\n                } else if (copyRet == PackageManager.NO_NATIVE_LIBRARIES && cpuAbiOverride != null) {\n                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;\n                } else if (needsRenderScriptOverride) {\n                    pkg.applicationInfo.primaryCpuAbi = abiList[0];\n                }\n            }\n        } catch (IOException ioe) {\n            Slog.e(TAG, \"Unable to get canonical file \" + ioe.toString());\n        } finally {\n            IoUtils.closeQuietly(handle);\n        }\n\n        if (pkg.applicationInfo.hasMultiArchLib == null&& pkg.applicationInfo.primaryCpuAbi != null && PRC_COMPATIBILITY) {\n            // 如果 hasMultiArchLib 为 null , primaryCpuAbi不为null ,则从apk中压缩文件中的lib相关目录判断是否是多指令集的\n             pkg.applicationInfo.hasMultiArchLib = String.valueOf(hasMultiArch(pkg.baseCodePath));\n        }\n\n        // Now that we've calculated the ABIs and determined if it's an internal app,\n        // we will go ahead and populate the nativeLibraryPath.\n        setNativeLibraryPaths(pkg);\n    }\n```\n\n###### 1.1.1.4.4.15. 为shareUser统一调整指令集\n\n处理原则如下\n\n-   当前包的指令集不为空, 当前包的requiredInstructionSet不为空, adjustedAbi 直接取当前包的 primaryCpuAbi, 更新shareUser所有包的 primaryCpuAbiString 为当前包的primaryCpuAbi, 删除primaryCpuAbi不一致的 shareUser 里对应包的dex文件\n-   当前包的指令集为空, 则赋值为 shareUser中第一个有指令集的包的架构集.同时更新shareUser所有包的 primaryCpuAbiString 为第一个包有架构集包的primaryCpuAbi, 删除primaryCpuAbi不一致的 shareUser 里对应包的dex文件\n\n```java\nif ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {\n    // We don't do this here during boot because we can do it all\n    // at once after scanning all existing packages.\n    //\n    // We also do this *before* we perform dexopt on this package, so that\n    // we can avoid redundant dexopts, and also to make sure we've got the\n    // code and package path correct.\n    // boot阶段不进行该操作, 为shareUser 调整abi\n    adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages,\n            pkg, true /* boot complete */);\n}\n    // bootComplete 已经开机完成,true 表明不是在boot阶段\n    // scannedPackage 为当前扫描的 包,\n    // packagesForUser   同shareUser的包\n    private void adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser,\n            PackageParser.Package scannedPackage, boolean bootComplete) {\n\n        String requiredInstructionSet = null;\n        // 以当前包为基准, 找 primaryCpuAbi 值,为需要的架构集 保存到requiredInstructionSet\n        if (scannedPackage != null && scannedPackage.applicationInfo.primaryCpuAbi != null) {\n            requiredInstructionSet = VMRuntime.getInstructionSet(\n                     scannedPackage.applicationInfo.primaryCpuAbi);\n        }\n\n        PackageSetting requirer = null;\n        for (PackageSetting ps : packagesForUser) {\n            // If packagesForUser contains scannedPackage, we skip it. This will happen\n            // when scannedPackage is an update of an existing package. Without this check,\n            // we will never be able to change the ABI of any package belonging to a shared\n            // user, even if it's compatible with other packages.\n            // shareUser 中的包名为当前包时略过\n            if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {\n                if (ps.primaryCpuAbiString == null) {\n                    continue;\n                }\n\n                final String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);\n                if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {\n                    // We have a mismatch between instruction sets (say arm vs arm64) warn about\n                    // this but there's not much we can do.\n                    // 如果shareUser中其他包和当前包的需要的架构集不一致,打出log\n                    String errorMessage = \"Instruction set mismatch, \"\n                            + ((requirer == null) ? \"[caller]\" : requirer)\n                            + \" requires \" + requiredInstructionSet + \" whereas \" + ps\n                            + \" requires \" + instructionSet;\n                    Slog.w(TAG, errorMessage);\n                }\n                // 如果当前包需要的架构集为空,则赋值为 shareUser中其他包的需要的架构集\n                if (requiredInstructionSet == null) {\n                    requiredInstructionSet = instructionSet;\n                    requirer = ps;\n                }\n            }\n        }\n\n        if (requiredInstructionSet != null) {\n            String adjustedAbi;\n            if (requirer != null) {\n                // requirer != null implies that either scannedPackage was null or that scannedPackage\n                // did not require an ABI, in which case we have to adjust scannedPackage to match\n                // the ABI of the set (which is the same as requirer's ABI)\n                // 此时只对应当前包所需架构集为空,但shareUser中其他包 架构集不为空的情况, 该中情况下,更新当前包的   primaryCpuAbi 为 shareUser中对应包的架构集\n                adjustedAbi = requirer.primaryCpuAbiString;\n                if (scannedPackage != null) {\n                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;\n                }\n            } else {\n                // requirer == null implies that we're updating all ABIs in the set to\n                // match scannedPackage.\n                // 当前包的requiredInstructionSet不为空, adjustedAbi 直接取当前包的 primaryCpuAbi\n                adjustedAbi =  scannedPackage.applicationInfo.primaryCpuAbi;\n            }\n\n            for (PackageSetting ps : packagesForUser) {\n                if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {\n                    if (ps.primaryCpuAbiString != null) {\n                        continue;\n                    }\n                    // 更新shareUser所有包的 primaryCpuAbiString 为当前包的primaryCpuAbi\n                    ps.primaryCpuAbiString = adjustedAbi;\n                    if (ps.pkg != null && ps.pkg.applicationInfo != null &&\n                            !TextUtils.equals(adjustedAbi, ps.pkg.applicationInfo.primaryCpuAbi)) {\n                        ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;\n                        Slog.i(TAG, \"Adjusting ABI for \" + ps.name + \" to \" + adjustedAbi\n                                + \" (requirer=\"\n                                + (requirer == null ? \"null\" : requirer.pkg.packageName)\n                                + \", scannedPackage=\"\n                                + (scannedPackage != null ? scannedPackage.packageName : \"null\")\n                                + \")\");\n                        try {\n                            // 删除primaryCpuAbi不一致的 shareUser 里对应包的dex文件\n                            mInstaller.rmdex(ps.codePathString,\n                                    getDexCodeInstructionSet(getPreferredInstructionSet()));\n                        } catch (InstallerException ignored) {\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n\n###### 1.1.1.4.4.16. 扫描模式未设置SCAN_NO_DEX标志\n\n当扫描模式未设置此标志时，调用performDexOptLI方法对该包强制进行dexopt。根据参数值，会进行dexopt优化，或者跳过/推后，如果优化失败，输出Log信息，跳过后续步骤。并且如果设置了失败删除数据目录标志，也会删除数据目录和data/app-lib目录。\n\n###### 1.1.1.4.4.17. 只有特权包或者更新的特权包才有权添加子包\n\n```java\n// Only privileged apps and updated privileged apps can add child packages.\nif (pkg.childPackages != null && !pkg.childPackages.isEmpty()) {\n    if ((policyFlags & PARSE_IS_PRIVILEGED) == 0) {\n        // 非特权应用拥有子包,直接抛出异常\n        throw new PackageManagerException(\"Only privileged apps and updated \"\n                + \"privileged apps can add child packages. Ignoring package \"\n                + pkg.packageName);\n    }\n    final int childCount = pkg.childPackages.size();\n    for (int i = 0; i < childCount; i++) {\n        PackageParser.Package childPkg = pkg.childPackages.get(i);\n        // 如果禁用包的子包中有和当前包的子包重合的,直接抛出异常\n        if (mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName,\n                childPkg.packageName)) {\n            throw new PackageManagerException(\"Cannot override a child package of \"\n                    + \"another disabled system app. Ignoring package \" + pkg.packageName);\n        }\n    }\n}\n```\n\n###### 1.1.1.4.4.18. 系统级应用向共享库中添加库\n\n应用为升级包, 查找该包是否在系统禁用包中\n\n-   如果该包在更新前在系统禁用包中, 则对当前的shareLib单项进行判断是否匹配旧包的lib项匹配才允许加到共享库中\n-   如果该包不在系统禁用包中, 则其对应的库不允许添加到共享库中\n\n对于系统级应用，如果library标签中声明的库信息不存在于PackageManagerService.mSharedLibraries中且被允许添加的情况下，往mSharedLibraries添加该库信息.\n\n为其他应用更新共享库信息\n\n-   判定当前是不是在启动扫描阶段，如果不在启动扫描阶段，为已安装且涉及到当前扫描到的该应用的库的其它应用更新共享库路径信息（即用最新的路径信息，最新的包）；\n-   对于启动扫描阶段，在扫描完成后统一更新。\n\n不是在启动扫描阶段,由于需要为已安装且涉及到当前扫描到该应用的库的其它应用更新共享库路径信息,所以需要将这些应用杀死.\n\n```java\n// writer\nsynchronized (mPackages) {\n    if ((pkg.applicationInfo.flags&ApplicationInfo.FLAG_SYSTEM) != 0) {\n        // Only system apps can add new shared libraries.\n        if (pkg.libraryNames != null) {\n            for (int i=0; i<pkg.libraryNames.size(); i++) {\n                String name = pkg.libraryNames.get(i);\n                boolean allowed = false;\n                if (pkg.isUpdatedSystemApp()) {\n                    // 如果是package更新的场景,查找该包是否在系统禁用包中.如果该包在更新前在系统禁用包中,\n                    // 则对当前的shareLib单项进行判断是否匹配旧包的lib项.匹配才允许加到共享库中\n                    final PackageSetting sysPs = mSettings\n                            .getDisabledSystemPkgLPr(pkg.packageName);\n                    if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {\n                        for (int j=0; j<sysPs.pkg.libraryNames.size(); j++) {\n                            if (name.equals(sysPs.pkg.libraryNames.get(j))) {\n                                allowed = true;\n                                break;\n                            }\n                        }\n                    }\n                    // 没在系统禁用包中,或者lib项不匹配,allowed为false\n                } else {\n                    allowed = true;\n                }\n                if (allowed) {\n                    if (!mSharedLibraries.containsKey(name)) {\n                        mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));\n                    } else if (!name.equals(pkg.packageName)) {\n                        Slog.w(TAG, \"Package \" + pkg.packageName + \" library \"\n                                + name + \" already exists; skipping\");\n                    }\n                } else {\n                    Slog.w(TAG, \"Package \" + pkg.packageName + \" declares lib \"\n                            + name + \" that is not declared on system image; skipping\");\n                }\n            }\n            if ((scanFlags & SCAN_BOOTING) == 0) {\n                // If we are not booting, we need to update any applications\n                // that are clients of our shared library.  If we are booting,\n                // this will all be done once the scan is complete.\n                clientLibPkgs = updateAllSharedLibrariesLPw(pkg);\n            }\n        }\n    }\n}\n        // Also need to kill any apps that are dependent on the library.\n        if (clientLibPkgs != null) {\n            for (int i=0; i<clientLibPkgs.size(); i++) {\n                PackageParser.Package clientPkg = clientLibPkgs.get(i);\n              // 杀死这些关联到该共享库的应用\n                killApplication(clientPkg.applicationInfo.packageName,\n                        clientPkg.applicationInfo.uid, \"update lib\");\n            }\n        }\n```\n\n###### 1.1.1.4.4.19. 保存当前扫描的包和包信息\n\n将当前包信息和包（保持信息一致性）分别存入mSettings.mPackages和PackageManagerService.mPackages中。\n\n并从mSettings.mPackagesToBeCleaned（保存已卸载并且清除外部数据的包名）移除当前包信息，防止误删。\n\n```java\n// Add the new setting to mSettings\nmSettings.insertPackageSettingLPw(pkgSetting, pkg);\n// Add the new setting to mPackages\nmPackages.put(pkg.applicationInfo.packageName, pkg);\n// Make sure we don't accidentally delete its data.\nfinal Iterator<PackageCleanItem> iter = mSettings.mPackagesToBeCleaned.iterator();\nwhile (iter.hasNext()) {\n    PackageCleanItem item = iter.next();\n    if (pkgName.equals(item.packageName)) {\n        iter.remove();\n    }\n}\n```\n\n###### 1.1.1.4.4.20. 更新第一次安装/升级时间以及密钥信息\n\n根据传来的扫描时间或者在创建数据目录时获取到的时间戳，更新包信息第一次安装pkgSetting.firstInstallTime或者升级的时间pkgSetting.lastUpdataTime。\n\n接下来，将AndroidManifest.xml解析到的密钥信息更新到mSettings.mKeySetManager结构中。\n\n```java\n// Take care of first install / last update times.\nif (currentTime != 0) {\n    if (pkgSetting.firstInstallTime == 0) {\n        pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;\n    } else if ((scanFlags&SCAN_UPDATE_TIME) != 0) {\n        pkgSetting.lastUpdateTime = currentTime;\n    }\n} else if (pkgSetting.firstInstallTime == 0) {\n    // We need *something*.  Take time time stamp of the file.\n    pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;\n} else if ((policyFlags&PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {\n    if (scanFileTime != pkgSetting.timeStamp) {\n        // A package on the system image has changed; consider this\n        // to be an update.\n        pkgSetting.lastUpdateTime = scanFileTime;\n    }\n  \n  // Add the package's KeySets to the global KeySetManagerService\n  ksms.addScannedPackageLPw(pkg);\n```\n\n###### 1.1.1.4.4.21. 遍历并保存各组件信息\n\n遍历在AndroidManifest.xml中解析到的各组件信息，并保存到PackageManagerService相应成员中。\n\n-   遍历pkg.providers\n\n遍历pkg.providers，将其中的各个Provider类型的元素添加到ProviderIntentResolver类型的PackageMamangerService.mProviders的成员变量ProviderIntentResolver.**mProviders**（HashMap<ComponentName,Provider类型>）中。并根据成员值`authority`，将元素添加到PackageManagerService.**mProvidersByAuthority**。\n\n-   遍历pkg.services\n\n遍历pkg.services，将其中的各个Service类型的元素添加到ServiceIntentResolver类型的PackageMamangerService.mServices的成员变量ServiceIntentResolver.**mServices**（HashMap<ComponentName, Service >类型）中。\n\n-   遍历pkg.receivers\n\n遍历pkg. receivers，将其中的各个Activity类型的元素添加到ActivityIntentResolver类型的PackageMamangerService.mReceivers的成员变量ActivityIntentResolver.**mActivitys**（HashMap<ComponentName, Activity>类型）中。\n\n-   遍历pkg.activities\n\n遍历pkg.activities，将其中的各个Activity类型的元素添加到ActivityIntentResolver类型的PackageMamangerService.mActivitys的成员变量ActivityIntentResolver.**mActivitys**（HashMap<ComponentName, Activity>类型）中。\n\n-   遍历pkg.permissionGroups\n\n遍历pkg.permissionGroups，将其中的各个PermissionGroup类型的元素添加到PackageMamangerService.**mPermissionGroups**（HashMap<String, permissionGroup>类型）中。\n\n-   遍历pkg.permissions\n\n遍历pkg.permissions，根据PackageMamangerService.mPermissionGroups，以及mSettings.mPermissions/mSettings.mPermissionTrees中是否包含该Permission类型元素p的权限名p.info.name，将BasePermission类型元素（根据p更新其中的成员）添加到mSettings.**mPermissions**/mSettings.**mPermissionTrees**中。\n\n-   遍历pkg.instrumentation\n\n遍历pkg.instrumentation，根据pkg数据信息更新Instrumentation类型元素，并将该元素添加到PackageManagerService.**mInstrumentation**中（HashMap<ComponentName,Instrumentation>类型）\n\n-   遍历pkg.protectedBroadcasts\n\n遍历pkg.protectedBroadcasts，将元素添加到PackageManagerService.**mProtectedBroadcasts**中。\n\n![各组件的组成结构](/images/aaab.jpg)\n\n###### 1.1.1.4.4.22. 处理overlay资源\n\n这个是在解析parseBaseApkCommon函数解析manifest节点时得到的. TAG_OVERLAY(overlay)标签\n\n```java\npkg.mOverlayTarget = com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage\n```\n\nmOverLays中以 pkg.mOverlayTarget为key, 保存 本package的ArrayMap\n\n其中Arraymap 中以本package的包名为key,存放了本包的package对象\n\n如果能够在 mPackages 找到本pakcage的 mOverlayTarget包,  则要为 target 包 和 本包创建idmap\n在package的 mOverlayTarget为空的情况下, 如果能够在mOverlays找到本包名为key的ArrayMap, 则说明本包存在关联的target包,同样为本包和target包创建idmap\n\n[idmap相关知识](https://docs.oracle.com/cd/E56344_01/html/E54077/idmap-1m.html)\n\n###### 1.1.1.4.4.23. 小结\n\n上述过程结束后,scanPackageDirtyLI函数结束, 返回PackageParser.Package 对象,在这个过程中,将PackageParser.Package 的一些值保存到PackageManagerService的全局变量中,详见[保存各组件信息](#遍历并保存各组件信息)\n\nscanPackageDirtyLi函数结束后,上面的调用栈整个返回,进行下一步的操作\n","tags":["Android","AndroidN","PackageManagerService"],"categories":["PackageManagerService"]},{"title":"Jni 基础学习文档","url":"/2017/07/21/其他调研/Jni 基础学习文档/","content":"\n# 1. Jni层简介\n\n\n## 1.1. Jni层的作用\n>   Java层的函数可以调用Native层函数\n>   Native层函数可以调用Java层函数\n\n## 1.2. 实例分析\n以`MediaScanner`为例实例拆解`JNI`层基础用法\n\n### 1.2.1. 库名相关\n\nJNI层对应的是libmedia_jni.so,  media_jni对应Jni库的名字，`Android`平台基本采用`lib` `模块名_jni`.so的名字命名。\n\n\n```cpp\nstatic {\n        System.loadLibrary(\"media_jni\");\n        native_init();\n}\n// Native函数声明，加native关键字， 实际功能由Jni层完成\nprivate static native final void native_init()\n```\n\n要使用Jni层函数，必须先加载Jni库文件，只要调用Jni函数前加载即可。其次声明该Jni层函数。\n\n加载一般放在 `static`静态块里，这样类一经创建，就加载对应的Jni库。\n\n调用`System.loadLibrary`就可以，系统会根据平台扩展成对应的库文件名。\n\n### 1.2.2. Jni层文件名一般与Java层文件是对应的\n\n```powershell\n   ../java/android/media/MediaSanner.java\n   ../jni/android_media_MediaSanner.cpp\n```\n\n### 1.2.3. 注册Jni函数\n\n> 如何能从库文件中找到对应的Jni层函数?\n> 注册——将Java层的Native声明的函数与Jni层的实现函数关联起来\n\n#### 1.2.3.1. 静态方法\n```powershell\nMediaSanner.java-->MediaSanner .class\nJavah  .class     android_media_MediaSanner.h\n```\n保存Jni层函数的`函数指针`，并和`Java`层`native`函数建立关联，再调用`native`声明的函数时,直接调用相应的函数指针。\n\n#### 1.2.3.2. **动态注册**\n\n结构体保存关联信息\n\n```cpp\nTypedef struct {\n// java层函数名字，如”native_init”,不用携带包的名称\nConst char* name;\n// Java层函数的签名信息，是代表参数类型和返回值的字符串\nConst char* signature;\n// 函数指针\nVoid * fnPtr;\n}JniNativeMethod;\n```\n\n如MediaScanner层的Jni函数保存在`gMethods`数组中，成员和Java层由native声明的函数一一对应。\n\n```cpp\nstatic JNINativeMethod gMethods[] = {\n    {\n        \"processDirectory\",\n        \"(Ljava/lang/String;Landroid/media/MediaScannerClient;)V\",\n        (void *)android_media_MediaScanner_processDirectory\n    },\n    {\n        \"processFile\",\n        \"(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V\",\n        (void *)android_media_MediaScanner_processFile\n    },\n    {\n        \"setLocale\",\n        \"(Ljava/lang/String;)V\",\n        (void *)android_media_MediaScanner_setLocale\n    },\n    {\n        \"extractAlbumArt\",\n        \"(Ljava/io/FileDescriptor;)[B\",\n        (void *)android_media_MediaScanner_extractAlbumArt\n    },\n    {\n        \"native_init\",\n        \"()V\",\n        (void *)android_media_MediaScanner_native_init\n    },\n    {\n        \"native_setup\",\n        \"()V\",\n        (void *)android_media_MediaScanner_native_setup\n    },\n    {\n        \"native_finalize\",\n        \"()V\",\n        (void *)android_media_MediaScanner_native_finalize\n    },\n}\n```\n\n\n\n注册`gMethods`数组：\n\n```cpp\nint register_android_media_MediaScanner(JNIEnv *env)\n{\n    return AndroidRuntime::registerNativeMethods(env,\n                kClassMediaScanner, gMethods, NELEM(gMethods));\n}\nint AndroidRuntime::registerNativeMethods(JNIEnv* env,\n    const char* className, const JNINativeMethod* gMethods, int numMethods)\n{\n    return jniRegisterNativeMethods(env, className, gMethods, numMethods);\n}\n\n//  /libnativehelper/JNIHelp.cpp\nextern \"C\" int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,\n    const JNINativeMethod* gMethods, int numMethods)\n{\n    JNIEnv* e = reinterpret_cast<JNIEnv*>(env);\n    ALOGV(\"Registering %s's %d native methods...\", className, numMethods);\n    scoped_local_ref<jclass> c(env, findClass(env, className));\n    if (c.get() == NULL) {\n        char* msg;\n        asprintf(&msg, \"Native registration unable to find class '%s'; aborting...\", className);\n        e->FatalError(msg);\n    }\n   //调用JniEnv的RegisterNatives函数，注册关联起来。\n    if ((*env)->RegisterNatives(e, c.get(), gMethods, numMethods) < 0) {\n        char* msg;\n        asprintf(&msg, \"RegisterNatives failed for '%s'; aborting...\", className);\n        e->FatalError(msg);\n    }\n    return 0;\n}\n```\n\n当Java层通过`System.LoadLibrary`加载Jni库文件后，需要动态注册Jni函数，库文件中有一个`JNI_OnLoad()`函数，加载时会执行该函数。如果需要动态注册，必须实现该函数。\n\n***android/media/MediaPlayer.cpp***\n\n```cpp\n// 注册所有Media相关类的Jni函数\njint JNI_OnLoad(JavaVM* vm, void* /* reserved */)\n{\n    JNIEnv* env = NULL;\n    jint result = -1;\n    // 第一个参数为JavaVM,虚拟机在Jni层的代表，每个JAVA进程只有一个这样的//JavaVM。\n    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {\n        ALOGE(\"ERROR: GetEnv failed\\n\");\n        goto bail;\n    }\n    assert(env != NULL);\n\n    if (register_android_media_ImageReader(env) < 0) {\n        ALOGE(\"ERROR: ImageReader native registration failed\");\n        goto bail;\n    }\n\n    if (register_android_media_MediaPlayer(env) < 0) {\n        ALOGE(\"ERROR: MediaPlayer native registration failed\\n\");\n        goto bail;\n    }\n\n    if (register_android_media_MediaRecorder(env) < 0) {\n        ALOGE(\"ERROR: MediaRecorder native registration failed\\n\");\n        goto bail;\n    }\n\n    if (register_android_media_MediaScanner(env) < 0) {\n        ALOGE(\"ERROR: MediaScanner native registration failed\\n\");\n        goto bail;\n    }\n.......\n   if (register_android_media_MediaHTTPConnection(env) < 0) {\n        ALOGE(\"ERROR: MediaHTTPConnection native registration failed\");\n        goto bail;\n    }\n\n    /* success -- return valid version number */\n    result = JNI_VERSION_1_4;\n\nbail:\nreturn result;\n}\n```\n\n#### 1.2.3.3. 数据类型转换\n\nJava数据分为**基本**数据类型和**引用**数据类型\n\n##### 1.2.3.3.1. 基本数据类型转换\n\n![Picture2](/images/Picture2.png)\n\n>   注意字长\n\n\n\n##### 1.2.3.3.2. 引用数据类型转换\n\n![Picture3](/images/Picture3.png)\n\n\n\n>   除了Java中基本数据类型的`数组`、`class`、`String`外，其他全用`jobject`表示，如Java中`MediaScannerClient` 类就用`jobject`表示，这就牵扯到如何用jobject操作类中的成员变量和成员函数的问题。\n\n### 1.2.4. JNIEnv\n\n**JNIEnv**代表一个**线程相关**的代表Jni环境的结构体，`JNIEnv`的结构如下:\n\n![Picture4](/images/Picture4.png)\n\n\n\n**JNIEnv**提供了一些系统函数，通过系统函数可以:\n\n-   调用Java函数\n-   操作jobject对象\n\n>每个Java进程只有一个JavaVM,进程中的线程共享该JavaVM\n\n```cpp\njint JNI_OnLoad(JavaVM* vm, void* /* reserved */)\n```\n\nJavaVM和JNIEnv有如下关系：\n\n-   调用`JavaVM`的`attachCurrentThread`函数，返回`JNIEnv`结构体，`Native`层可通过`JNIEnv`结构体`回调`Java层函数。\n-   后台进程退出前，调用`JavaVM`的`detachCurrentThread`函数，释放对应的线程资源。\n\n#### 1.2.4.1. 通过JNIEnv操作jobject\n\n即操作java 对象类的`成员函数`和`成员变量`\n\n**jobject**的**`jfieldID`和`jmethodID`**\n\n>   取出`jfieldID`和`jmethodID`\n\nJNIEnv的两个系统函数:\n\n![Picture5](/images/Picture5.png)\n\n```cpp\nprivate native void processDirectory(String path, MediaScannerClient client);\nandroid_media_MediaScanner_processDirectory(\n        JNIEnv *env, jobject thiz, jstring path, jobject client)\n{\n.........\n    MediaScanner *mp = getNativeScanner_l(env, thiz);\n    const char *pathStr = env->GetStringUTFChars(path, NULL);\n    MyMediaScannerClient myClient(env, client);\n    MediaScanResult result = mp->processDirectory(pathStr, myClient);\n    env->ReleaseStringUTFChars(path, pathStr);\n} \n\n// MyMediaScannerClient 构造函数\n    MyMediaScannerClient(JNIEnv *env, jobject client)\n        :   mEnv(env),\n            mClient(env->NewGlobalRef(client)),\n            mScanFileMethodID(0),\n            mHandleStringTagMethodID(0),\n            mSetMimeTypeMethodID(0)\n    {\n         jclass mediaScannerClientInterface =\n         env->FindClass(kClassMediaScannerClient);        \n         mScanFileMethodID = env->GetMethodID(\n                                    mediaScannerClientInterface,\n                                    \"scanFile\",\n                                    \"(Ljava/lang/String;JJZZ)V\");\n         mHandleStringTagMethodID = env->GetMethodID(\n                                    mediaScannerClientInterface,\n                                    \"handleStringTag\",\n                                    \"(Ljava/lang/String;Ljava/lang/String;)V\")；\n.........\n     }\n```\n\n如上，取出`MethoidId`,保存为`MyMediaScannerClient`类的成员变量（提高运行效率），下一步就是如何使用这些`fieldID`和`methodID`。\n\n>   使用`jfieldID`和`jmethodID`\n\n```cpp\n//通过JNIEnv，Native层回调Java层函数    \nvirtual status_t scanFile(const char* path, long long lastModified,\n            long long fileSize, bool isDirectory, bool noMedia)\n{\n    jstring pathStr;\n        pathStr = mEnv->NewStringUTF(path));\n        mEnv->CallVoidMethod(mClient, mScanFileMethodID, pathStr, lastModified,\n                fileSize, isDirectory, noMedia);\n        mEnv->DeleteLocalRef(pathStr);\n        return checkAndClearExceptionFromCallback(mEnv, \"scanFile\");\n}\n```\n\n**type**对应返回值类型\n\n>   调用非静态方法\n\n```cpp\nNativeType Call<type>Method (JNIEnv* env, jobject obj,  jmethodID methodID,...);\n```\n\n>   调用静态方法\n\n```cpp\nNativeType CallStatic<type>Method(...);\n```\n\n>   获取jobject对象的对应的成员变量值\n\n```cpp\nNativeType Get<type>Field(JNIEnv* env, jobject obj, jfieldID fieldID,...);\n```\n\n>   设置jobject对象的对应的成员变量值\n\n```cpp\nNativeType Set<type>Field(JNIEnv* env, jobject obj, jfieldID fieldID,...);\n```\n\n![Picture6](/images/Picture6.png)\n\n### 1.2.5. **jstring类型介绍**\n\n>   JAVA中的String也是引用类。由于使用比较频繁，Jni创建了jstring类。\n\n```cpp\n// 由Native本地字符串(char*)转换成jstring，得到Java 的String对象。\nJNIEnv::NewString(...)      //unicode\nJNIEnv::NewStringUTF(...)  //utf-8\n// Java.String (jstring)转换为Native. String(const char*);\nJNIEnv::GetStringChars(...)\nJNIEnv::GetStringUTFChars(...);\n//调用完成后，需要释放资源\nJNIEnv::ReleaseStringChars(...)\nJNIEnv::ReleaseStringUTFChars(...);\n```\n\n### 1.2.6. **Jni 类型签名**\n\n```cpp\n        void processFile(String path,String mimetype);\n         ......\n \t\t \"processFile\",\n        \"(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V\",\n        (void *)android_media_MediaScanner_processFile\n    ..........\n```\n\nJava支持函数重载，将参数信息和返回值信息写到签名信息里，便于查找到对应的函数.\n\n最左侧是参数名，在括号里面，括号外面的是返回值类型。\n\n-   V代表void， 当参数类型是引用类型时，格式为 ”L包名”, String 格式为”Ljava/lang/String”;\n-   **基本**类型名字可以直接写。\n-   数组类型，后面回跟着” [” \n-   **引用**类型最后跟 “ ;”.\n\nJava提供javap的工具帮助生成变量或函数的签名信息。\n\n```powershell\nJavap -s -p xxx.class\n```\n\n### 1.2.7. 垃圾回收\n\nJava中创建的对象由垃圾回收器释放回收内存。\n\n#### 1.2.7.1. Local Reference\n\n>   非全局引用\n\nJni函数返回，对象可能被回收。\n\n需要及时回收该类型资源，不要忘记用`JNIEnv::DeleteLocalRef`函数回收该资源。\n\n#### 1.2.7.2. Global Reference\n\n>   全局引用\n\n不主动释放，永远不会被回收。\n\n在类构造函数中创建和释放该类型对象（类似`new`  `delete`的用法）\n\n#### 1.2.7.3. Weak Global Reference\n\n>   弱全局引用\n\n可能在运行过程中被回收\n\n`JNIEnv::isSameObject` 判断是否被回收\n\n### 1.2.8. Jni中的异常处理\n\nJNI中也有异常，但是与Java、C++不同，异常***不会中断***函数执行，一旦出现异常，只能释放资源，`return`。\n\n| 关键字              | 作用            |\n| ---------------- | ------------- |\n| ExceptionOccured | 判断是否发生异常      |\n| ExceptionClear   | 清理当前JNI层发生的异常 |\n| ThrowNew         | 向Java层抛出异常    |\n","tags":["Android","Jni"],"categories":["Jni"]},{"title":"Android storage sandbox","url":"/2017/07/20/存储相关/AndroidQ 存储sandbox/","content":"\n# 1. prepareSandboxForApp\n\n```puml\n\nskinparam backgroundColor #EEEBDC\n\nskinparam sequence {\n\tArrowColor DeepSkyBlue\n\tActorBorderColor DeepSkyBlue\n\tLifeLineBorderColor blue\n\tLifeLineBackgroundColor #A9DCDF\n\t\n\tParticipantBorderColor DeepSkyBlue\n\tParticipantBackgroundColor DodgerBlue\n\tParticipantFontName Impact\n\tParticipantFontSize 17\n\tParticipantFontColor #A9DCDF\n\t\n\tActorBackgroundColor aqua\n\tActorFontColor DeepSkyBlue\n\tActorFontSize 17\n\tActorFontName Aapex\n}\n\nautoactivate on\npkms -> SMS: prepareSandboxForApp\\n(pkg.packageName, appId,\\n pkg.mSharedUserId, userId);\nSMS->SMS: getSandboxId\\n(packageName, sharedUserId);\nreturn sandboxId\nnote left: packageName || \"shared-\" + packageName\nSMS -> vold: <b>prepareSandboxForApp\\n(packageName, appId, \\n sandboxId, userId)\nvold -> VM: prepareSandboxForApp\nalt hasIsolatedStorage\nVM->VM: hasIsolatedStorage\nnote left:\"sys.isolated_storage_snapshot\" true || \"persist.sys.isolated_storage\" true\nelse\nVM-->pkms:end\nend\n\nVM->VM:verify package\nreturn \nVM->VM:<b>prepareSandboxes\\n(userId, {packageName}, visibleVolLabels)\nVM->VM:prepareSubDirs\nnote left:<b>sandboxRoot:\\n/mnt/runtime/write/<vlable>Android/sandbox/\nreturn\n\nVM->VM:prepareSandboxTargets\\n(userId, visibleVolLabels)\nnote left:<b>mntTargetRoot:\\n/mnt/user/<userid>/package\\n\\\n<b>sandboxTarget:\\n/mnt/user/<userid>/package/<vlabel>/<userid>\\n\\\n<b>primaryPath</b>(/stor**age/emulated/<userid>) <b>-></b> $mntTargetRoot/self/primary\nreturn\n\nVM->VM:mountPkgSpecificDirsForRunningProcs\\n(userId, packageNames, \\n visibleVolLabels, -1)\nnote left:obbMountDir:\\n\\\n/mnt/user/<userId>/obb_mount\\n\\\n<b>read /proc/<pid>/ns/mnt \\n\\\nsetns(nsFd.get(), CLONE_NEWNS\nVM->VM:getMountModeForRunningProc\nnote left: <b>stat(\"/storage\", &storageSb) \\n\\\nvs stat(\"/mnt/runtime/full\", &mntFullSb) -> <b>REMOUNT_MODE_FULL \\n\\\nvs stat(\"/mnt/runtime/write\", &mntWriteSb) -> <b>REMOUNT_MODE_LEGACY \\n\\\nobbMountFile: \"/mnt/user/<userid>/obb_mount/package\" <b> \\n\\\n<b>obbMountFile exist -> REMOUNT_MODE_INSTALLER \\n\\\nvs /mnt/user/<userid>/package-><b>REMOUNT_MODE_WRITE\nreturn mountmode\n\nalt mountMode == remountMode\nVM->VM:handleMountModeInstaller\nreturn 0\nend\n\nalt REMOUNT_MODE_FULL || REMOUNT_MODE_LEGACY || REMOUNT_MODE_NONE\nVM->pkms:end\nelse REMOUNT_MODE_INSTALLER || REMOUNT_MODE_WRITE\nVM->VM ++ : mount\nnote left #LightBlue:mntSource: /mnt/runtime/write/<vlabel>/<userid> (for emulated)\\n\\\nmntTarget: /storage/<vlabel>/<userid> (storage/emulated/0) \\n\\\nsandboxSource: $mntSource/Android/sandbox/<sandboxid> \\n\\\n<b>$sandboxSource <b>-></b> $mntTarget \\n\\\nobbSourceDir: $mntSource/Android/obb \\n\\\nobbTargetDir: $mntTarget/Android/obb \\n\\\nREMOUNT_MODE_INSTALLER: $obbSourceDir <b>-></b> $obbTargetDir \\n\\\nREMOUNT_MODE_WRITE: $mntSource/Android/data|media/<package>/ <b>-></b> $mntTarget/Android/data|media/<package>/ \\n\\\n$mntSource/Android/data|media/<package>/ <b>-></b> $mntTarget/Android/data|media/<package>/\nreturn\nVM->pkms:end\nend\n```\n\n","tags":["Android","StorageService"],"categories":["Android"]},{"title":"Android Storage 存储架构分析1","url":"/2017/07/20/存储相关/Android Storage 存储架构分析1/","content":"\n# 1. Android Storage 存储架构分析1\n## 1.1. StorageManagerService初始化\n\n以下StorageManagerService简称SMS。\n\nSMS的初始化在SystemServer中。\n\nSystem Server 引入\n\n### 1.1.1. startOtherService\n\nDisplayReady后启动 SMS:\n```java\ntraceBeginAndSlog(\"MakeDisplayReady\");\n//在DisplayReady后启动 SMS\ntraceBeginAndSlog(\"StartStorageManagerService\");\n...\nmSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);\n// \"com.android.server.StorageManagerService$Lifecycle\";\nstorageManager = IStorageManager.Stub.asInterface(\n        ServiceManager.getService(\"mount\"));\n```\n\n> SMS 在 ServiceManager中的代理名称为 mount， 可以使用dumpsys mount命令打印SMS的内存信息，执行SMS的dump函数 \n\n#### 1.1.1.1. startService\n\n```java\npublic <T extends SystemService> T startService(Class<T> serviceClass) {\n//T模板  为 SystemService的子类\ntry {\n        final String name = serviceClass.getName();\n        // name为   StorageManagerService#LifeCircle\n        Slog.i(TAG, \"Starting \" + name);\n        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartService \" + name);\n        // Create the service.\n        if (!SystemService.class.isAssignableFrom(serviceClass)) {\n            throw new RuntimeException(\"Failed to create \" + name\n                    + \": service must extend \" + SystemService.class.getName());\n        }\n        final T service;\n        try {\n        //寻找 StorageManagerService#LifeCircle的构造器，创建实例，传入参数为mContext,  mContext为 SystemServiceManager的context\n            Constructor<T> constructor = serviceClass.getConstructor(Context.class);\n            service = constructor.newInstance(mContext);\n\n...\n        //启动对应的service， 响应子类的onStart方法\n        startService(service);       \n        return service;\n    } finally {\n        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);\n    }\n}\n```\n\nstartService 后， 会响应 SystemService 子类， 也就是 StroageManagerService内部类 Lifecycle  的onStart函数， 并传入了 SystemServiceManager的context。\n\n#### 1.1.1.2. SMS#Lifecycle-onStart\n\n \n\n```java\n@Override\npublic void onStart() {\n    //SMS的初始化\n    mStorageManagerService = new StorageManagerService(getContext());\n    // 往ServiceManager中注册的服务代理名称为mount。 \n    publishBinderService(\"mount\", mStorageManagerService);\n    mStorageManagerService.start();\n}\n```\n此处通过publishBinderService注册代理名称，与1处呼应。\n\n#### 1.1.1.3. StorageManagerService-构造函数\n\n```java\npublic StorageManagerService(Context context) {\n    sSelf = this;\n    //保存供内部类使用\n    mContext = context;\n   //前台线程，  StorageManagerService 的Callback内部类\n    mCallbacks = new Callbacks(FgThread.get().getLooper());\n    // 直接拿到PackagaManagerService的实例。 Service之间是可以互相访问的\n    // XXX: This will go away soon in favor of IMountServiceObserver\n    mPms = (PackageManagerService) ServiceManager.getService(\"package\");\n    // 主handler ，  通过HandlerThread创建的新的线程\n    HandlerThread hthread = new HandlerThread(TAG);\n    hthread.start();\n    mHandler = new StorageManagerServiceHandler(hthread.getLooper());\n    // obb相关的handler\n    // Add OBB Action Handler to StorageManagerService thread.\n    mObbActionHandler = new ObbActionHandler(IoThread.get().getLooper());\n....\n//省略Fstrim相关\n....\n// data/system/storage.xml文件\n    mSettingsFile = new AtomicFile(\n            new File(Environment.getDataSystemDirectory(), \"storage.xml\"));\n    synchronized (mLock) {\n        readSettingsLocked();\n    }\n   // StorageManagerInternal 实例加到了LocalServices中\n    LocalServices.addService(StorageManagerInternal.class, mStorageManagerInternal); （A）\n    /*\n     * Create the connection to vold with a maximum queue of twice the\n     * amount of containers we'd ever expect to have. This keeps an\n     * \"asec list\" from blocking a thread repeatedly.\n     */\n    // MAX_CONTAINERS*2  阻止 aesc list block 反复block线程\n// asec mount 数量最大为 MAX_CONTAINERS\n    // NativeDaemonConnector （B）\n    mConnector = new NativeDaemonConnector(this, \"vold\", MAX_CONTAINERS * 2, VOLD_TAG, 25, null); （B）\n    mConnector.setDebug(true);\n    mConnector.setWarnIfHeld(mLock);\n// 执行mConnector的run方法，  listenToSocket\n    mConnectorThread = new Thread(mConnector, VOLD_TAG);\n    // Reuse parameters from first connector since they are tested and safe\n    mCryptConnector = new NativeDaemonConnector(this, \"cryptd\",\n            MAX_CONTAINERS * 2, CRYPTD_TAG, 25, null);\n    mCryptConnector.setDebug(true);\n    mCryptConnectorThread = new Thread(mCryptConnector, CRYPTD_TAG);\n    final IntentFilter userFilter = new IntentFilter();\n    userFilter.addAction(Intent.ACTION_USER_ADDED);\n    userFilter.addAction(Intent.ACTION_USER_REMOVED);\n    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);\n    synchronized (mLock) {\n        addInternalVolumeLocked();\n    }\n    // Add ourself to the Watchdog monitors if enabled.\n    if (WATCHDOG_ENABLE) {\n        Watchdog.getInstance().addMonitor(this);\n    }\n}\n```\n##### 1.1.1.3.1. (A) StorageManagerInternal - LocalServices\n\n为了提升通信的效率，google将service分成binder service 和 local service。\n\n如果service只在本进程使用，则可以将这个service 发布为localservice。避免进程间通信。只能在本进程中使用。\n\n> ( A )  StorageManagerInternal 为抽象类，借助StorageManagerInternal类来实现具体的功能， 该类控制挂载相关的策略。 （mount read write default）。\n> 本地服务 Local Service 用于应用程序内部。\n\n它可以启动并运行，直至有人停止了它或它自己停止。在这种方式下，它以调用Context.startService()启动，以调用Context.stopService()结束。它可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。\n用于实现应用程序自己的一些耗时任务，比如查询升级信息，并不占用应用程序比如Activity所属线程，而是单开线程后台执行，这样用户体验比较好。\n\n这里将StorageManagerInternal  加到LocalServices中，可以保证SystemServer进程的其他service都能较为方便的使用其中的方法。  \n如AppOpsService  AMS PKMS 等.\n\n##### 1.1.1.3.2. （B）NativeDaemonConnector\n\n构造时传入 第一个参数为 StorageManagerService本身， 自身作为INativeDaemonConnectorCallbacks, Socket名称为“vold”， 没有传入looper，则使用的FgThread.get().getLooper(), Android.fg 的 looper线程。\n\n```java\n\nNativeDaemonConnector(INativeDaemonConnectorCallbacks callbacks, String socket,\n        int responseQueueSize, String logTag, int maxLogSize, PowerManager.WakeLock wl,\n        Looper looper) {\n    mCallbacks = callbacks;\n    mSocket = socket;\n// 消息队列，从vold接收来的消息处理，可能延迟\n    mResponseQueue = new ResponseQueue(responseQueueSize);\n// 传入的wakelock为 null\n    mWakeLock = wl;\n    if (mWakeLock != null) {\n        mWakeLock.setReferenceCounted(true);\n    }\n    mLooper = looper;\n// 原子性操作，多线程不会错乱，  SND  index | RCV index\n    mSequenceNumber = new AtomicInteger(0);\n    TAG = logTag != null ? logTag : \"NativeDaemonConnector\";\n    mLocalLog = new LocalLog(maxLogSize);\n}\n```\n## 1.2. 通信篇- SMS与vold通信\n\n```java\nOs.socket(OsConstants.AF_UNIX, SOCKET_STREAM , 0)\nsocket.connect(address);\n```\n连接成功后，通过INativeDaemonConnectorCallbacks 响应 onDaemonConnected。\n\nSMS发送 H_DAEMON_CONNECTED， 由HandlerThread创建的子线程进行处理:\n\n该子线程处理的消息包括：\n\n \n\n- H_SYSTEM_READY\n- H_DAEMON_CONNECTED\n- H_FSTRIM\n- H_SHUTDOWN\n- H_VOLUME_MOUNT\n- H_VOLUME_UNMOUNT\n- H_VOLUME_BROADCAST\n- H_INTERNAL_BROADCAST\n- H_PARTITION_FORGET\n- H_RESET\n### 1.2.1. 与vold通信 - listenToSocket\n\n重点看下 listenToSocket 的消息循环：\n\n \n\n```java\nwhile (true) {\n    int count = inputStream.read(buffer, start, BUFFER_SIZE - start);\n    // fdList 是从对端发送过来的\n    fdList = socket.getAncillaryFileDescriptors();\n    // Add our starting point to the count and reset the start.\n    count += start;\n    start = 0;    \n    //一次可能接收到多个命令包过来  \n    for (int i = 0; i < count; i++) {\n        if (buffer[i] == 0) {\n            // Note - do not log this raw message since it may contain\n            // sensitive data\n            //命令包过来的原始信息，支持UTF-8 编码格式的中文\n            final String rawEvent = new String(\n                    buffer, start, i - start, StandardCharsets.UTF_8);\n            boolean releaseWl = false;\n            try {\n                final NativeDaemonEvent event =\n                        NativeDaemonEvent.parseRawEvent(rawEvent, fdList);\n                log(\"RCV <- {\" + event + \"}\");\n                // 与卷挂载Disk状态相关的event处理  600-700\n                if (event.isClassUnsolicited()) {\n                    // TODO: migrate to sending NativeDaemonEvent instances\n                    // StorageManagerService 这个地方总是false。 因为前面传的wakelock 也是null，不走入\n                    if (mCallbacks.onCheckHoldWakeLock(event.getCode())\n                            && mWakeLock != null) {\n                        mWakeLock.acquire();\n                        releaseWl = true;\n                    }\n                    // mCallbackHandler， 是绑定的传入的looper，此前由于并没有传入looper对象，此处使用的是android.fg线程，往此线程发送消息，则其中的消息循环的处理绑定的handler对应的callback的handleMessage中。（C）\n                    Message msg = mCallbackHandler.obtainMessage(\n                            event.getCode(), uptimeMillisInt(), 0, event.getRawEvent());\n                    if (mCallbackHandler.sendMessage(msg)) {\n                        releaseWl = false;\n                    }\n                }\n               // 控制类的event 放在 ResponseQueue中 （D）\n          else {\n                    mResponseQueue.add(event.getCmdNumber(), event);\n                }\n            } \n          。。。\n            start = i + 1;\n        }\n    }\n    <span id=\"jump\">this</span>\n    if (start == 0) {\n        log(\"RCV incomplete\");\n    }\n    // We should end at the amount we read. If not, compact then\n    // buffer and read again.\n    if (start != count) {\n        final int remaining = BUFFER_SIZE - start;\n        System.arraycopy(buffer, start, buffer, 0, remaining);\n        start = remaining;\n    } else {\n        start = 0;\n    }\n}\n```\n#### 1.2.1.1. （C）  与vold 通信的 主Handler\n\nDaemonConnector 绑定了 mCallbackHandler ：\n\n \n\n```java\nmCallbackHandler = new Handler(mLooper, this);\n```\n看Handler的构造函数中的第二个参数 callback\n\n> Callback是跟Handler 存在绑定关系的，Looper里存的是大的MessageQueue。\n> 使用Handler发送消息时，只能对应callback的 HandleMessage处理。\n```java\n@Override\npublic boolean handleMessage(Message msg) {\n    final String event = (String) msg.obj;\n    final int start = uptimeMillisInt();\n    final int sent = msg.arg1;\n    try {\n        // 此处的mCallbacks 为 StorageManagerService\n        if (!mCallbacks.onEvent(msg.what, event, NativeDaemonEvent.unescapeArgs(event))) {\n            log(String.format(\"Unhandled event '%s'\", event));\n        }\n    } finally {\n        final int end = uptimeMillisInt();\n        if (start > sent && start - sent > WARN_EXECUTE_DELAY_MS) {\n            loge(String.format(\"NDC event {%s} processed too late: %dms\", event, start - sent));\n        }\n        if (end > start && end - start > WARN_EXECUTE_DELAY_MS) {\n            loge(String.format(\"NDC event {%s} took too long: %dms\", event, end - start));\n        }\n    }\n    return true;\n}\n```\n其中 StorageManagerService  的 onEvent 处理了下列事件：\n\nDISK_CREATED\n\nDISK_SIZE_CHANGED\n\nDISK_LABEL_CHANGED\n\nDISK_SCANNED\n\nDISK_SYS_PATH_CHANGED\n\nDISK_DESTROYED\n\nVOLUME_CREATED\n\nVOLUME_STATE_CHANGED\n\nVOLUME_FS_TYPE_CHANGED\n\nVOLUME_FS_UUID_CHANGED\n\nVOLUME_FS_LABEL_CHANGED\n\nVOLUME_PATH_CHANGED\n\nVOLUME_INTERNAL_PATH_CHANGED\n\nVOLUME_DESTROYED\n\nMOVE_STATUS\n\nBENCHMARK_RESULT\n\nTRIM_RESULT\n\n#### 1.2.1.2. StorageManagerService#Callbacks\n\nStorageManagerService#Callbacks 中也有一个 Android.fg 线程Looper的Handler。\n通过上面的onEvent处理，在对应特殊事件时, 回调回 Callbacks 中。\n\n- VOLUME_STATE_CHANGED ：\n  onVolumeStateChangedLocked\n\n- DISK_DESTROYED :\n  notifyDiskDestroyed\n\n- DISK_SCANNED ：\n  onDiskScannedLocked\n\n>通过SMS#Callbacks内部类通知到各个注册的StorageEventListener。其他的情况也有可能会回调，根据实际情况进行处理：如 onUnlockUser\n>SMS#Callbacks 内部类处理的消息：\n\nMSG_STORAGE_STATE_CHANGED\n\nMSG_VOLUME_STATE_CHANGED\n\nMSG_VOLUME_RECORD_CHANGED\n\nMSG_VOLUME_FORGOTTEN\n\nMSG_DISK_SCANNED\n\nMSG_DISK_DESTROYED\n\n> 消息全部与卷状态有关，且优先级比子线程处理的消息高，此处通过内部类Callbacks 绑定了许多的callback。 这些callback是通过 StorageEventListener register关联的：\n\n\n#### 1.2.1.3. （D） 控制类Event处理\n\n##### 1.2.1.3.1. ResponseQueue类\n\nmResponseQueue \n\nResponseQueue#PendingCmd\n\nPendingCmd 成员 BlockingQueue<NativeDaemonEvent> responses;\n\n>如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒.同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作. \n>利用了BlockingQueque如果为空，从中取东西会阻塞的特性。\n\n \n\n```java\nmResponseQueue.add(event.getCmdNumber(), event);\n```\n在发送一条命令时，一般对端会返回一条控制命令（成功或失败）回来，返回的控制命令最终会放在BlockingQueue中。 这样在命令返回之前，由于队列是空的，所以会将当前代码阻塞住，返回的控制命令被填入到队列中，代码才会继续往下走，通过这样的机制去判断相对应的发往对端的命令执行的时间。\n每一条命令的 cmdNumber 是绑定的往对端vold发命令时的命令码， 往对端发的命令码对应的返回命令可能有多条（如asec list命令），这样保证了对应每一条发往对端 （native 进程）的命令都绑定了一个 BlockingQueue.\n\ncmdNumber 15相关的通信过程：\n\n```java\n105-19 13:39:51.916  3185  3212  D VoldConnector: SND -> {15 asec list}\nA105-19 13:39:51.926  3185  3266 D VoldConnector: RCV <- {111 15 com.UCMobile-2}\nA105-19 13:39:51.927  3185  3266 D VoldConnector: RCV <- {111 15 com.taobao.taobao-1}\nA105-19 13:39:51.930  3185  3266 D VoldConnector: RCV <- {111 15 com.youku.phone-2}\nA105-19 13:39:51.934  3185  3266 D VoldConnector: RCV <- {111 15 com.tencent.mobileqq-2}\nA105-19 13:39:51.935  3185  3266 D VoldConnector: RCV <- {111 15 com.sina.weibo-2}\nA105-19 13:39:51.936  3185  3266 D VoldConnector: RCV <- {111 15 com.kiloo.subwaysurf-2}\nA105-19 13:39:51.936  3185  3266 D VoldConnector: RCV <- {111 15 com.youdao.huihui.deals-2}\nA105-19 13:39:51.937  3185  3266 D VoldConnector: RCV <- {111 15 com.facebook.katana-2}\nA105-19 13:39:51.937  3185  3266 D VoldConnector: RCV <- {111 15 com.duowan.mobile-2}\nA105-19 13:39:51.938  3185  3266 D VoldConnector: RCV <- {111 15 com.imangi.templerun2-2}\nA105-19 13:39:51.939  3185  3266 D VoldConnector: RCV <- {111 15 com.taobao.taobao-2}\nA105-19 13:39:51.940  3185  3266 D VoldConnector: RCV <- {111 15 com.happyelements.AndroidAnimal-2}\nA105-19 13:39:51.944  3185  3266 D VoldConnector: RCV <- {111 15 com.kiloo.subwaysurf-1}\nA105-19 13:39:51.945  3185  3266 D VoldConnector: RCV <- {111 15 com.wandoujia.phoenix2.usbproxy-1}\nA105-19 13:39:51.946  3185  3266 D VoldConnector: RCV <- {200 15 asec operation succeeded}\n```\n对应的往native进程发送命令的代码：\n\n```java\n\npublic NativeDaemonEvent[] executeForList(long timeoutMs, String cmd, Object... args)\n        throws NativeDaemonConnectorException {\n    final long startTime = SystemClock.elapsedRealtime();\n    final ArrayList<NativeDaemonEvent> events = Lists.newArrayList();\n   。。。\n    log(\"SND -> {\" + logCmd + \"}\");\n    synchronized (mDaemonLock) {\n            try {\n mOutputStream.write(rawCmd.getBytes(StandardCharsets.UTF_8));\n            } catch (IOException e) {\n                throw new NativeDaemonConnectorException(\"problem sending command\", e);\n            }\n        }\n    }\n    NativeDaemonEvent event = null;\n    do {\n        // mResponseQueue接收对端发送回来的消息，如果该队列为空，此处remove会block住，直到队列不为空，才继续往下走。\n        event = mResponseQueue.remove(sequenceNumber, timeoutMs, logCmd);\n        if (event == null) {\n            loge(\"timed-out waiting for response to \" + logCmd);\n            throw new NativeDaemonTimeoutException(logCmd, event);\n        }\n        if (VDBG) log(\"RMV <- {\" + event + \"}\");\n        events.add(event);\n     //  100-200 范围内的可以循环\n      // 如上面的asec list 的消息码为111。\n    } while (event.isClassContinue());\n\n//  根据mResponseQueue的情况得出 native 进程端处理的时间\n    final long endTime = SystemClock.elapsedRealtime();\n    if (endTime - startTime > WARN_EXECUTE_DELAY_MS) {\n        loge(\"NDC Command {\" + logCmd + \"} took too long (\" + (endTime - startTime) + \"ms)\");\n    }\n     //  500-600  ClientError\n    if (event.isClassClientError()) {\n        throw new NativeDaemonArgumentException(logCmd, event);\n    }\n//  400-600  ServerError\n    if (event.isClassServerError()) {\n        throw new NativeDaemonFailureException(logCmd, event);\n    }\n    return events.toArray(new NativeDaemonEvent[events.size()]);\n}\n```\n对应的event消息码：\n\n```java\n        public static final int VolumeListResult               = 110;\n        public static final int AsecListResult                 = 111;\n        public static final int StorageUsersListResult         = 112;\n        public static final int CryptfsGetfieldResult          = 113;\n\n        /*\n         * 200 series - Requestion action has been successfully completed.\n         */\n        public static final int ShareStatusResult              = 210;\n        public static final int AsecPathResult                 = 211;\n        public static final int ShareEnabledResult             = 212;\n\n        /*\n         * 400 series - Command was accepted, but the requested action\n         *              did not take place.\n         */\n        public static final int OpFailedNoMedia                = 401;\n        public static final int OpFailedMediaBlank             = 402;\n        public static final int OpFailedMediaCorrupt           = 403;\n        public static final int OpFailedVolNotMounted          = 404;\n        public static final int OpFailedStorageBusy            = 405;\n        public static final int OpFailedStorageNotFound        = 406;\n\n        /*\n         * 600 series - Unsolicited broadcasts.\n         */\n        public static final int DISK_CREATED = 640;\n        public static final int DISK_SIZE_CHANGED = 641;\n        public static final int DISK_LABEL_CHANGED = 642;\n        public static final int DISK_SCANNED = 643;\n        public static final int DISK_SYS_PATH_CHANGED = 644;\n        public static final int DISK_DESTROYED = 649;\n\n        public static final int VOLUME_CREATED = 650;\n        public static final int VOLUME_STATE_CHANGED = 651;\n        public static final int VOLUME_FS_TYPE_CHANGED = 652;\n        public static final int VOLUME_FS_UUID_CHANGED = 653;\n        public static final int VOLUME_FS_LABEL_CHANGED = 654;\n        public static final int VOLUME_PATH_CHANGED = 655;\n        public static final int VOLUME_INTERNAL_PATH_CHANGED = 656;\n        public static final int VOLUME_DESTROYED = 659;\n\n        public static final int MOVE_STATUS = 660;\n        public static final int BENCHMARK_RESULT = 661;\n        public static final int TRIM_RESULT = 662;\n```\n\n","tags":["Android","StorageService"],"categories":["Android"]},{"title":"cts 跑测使用方法","url":"/2017/07/19/其他调研/cts 跑测使用方法/","content":"\n# 1. CTS 测试使用方法\n\n## 1.1. 下载cts测试包\n\n可以在[展讯内部自动测试地址](http://tjtest.spreadtrum.com/autotest/)进行下载cts或gts等相关的测试资源。\n\n>   **CTS** 测试包分为`x86`和`arm`系列，针对相应的芯片下载对应的系列。如`intel`系列的手机需要下载`x86`的（比如`7.0_r10_x86`）。\n\n## 1.2. 进行cts测试\n\n将资源包下载下来后解压，得到`android-cts`的文件夹。\n\n执行`./cts-tradefed` 命令。\n\n```powershell\ncts_7.0_r10_x86/android-cts/tools$ ./cts-tradefed\n```\n\n\n\n### 1.2.1. 单条测试case跑测\n\n```powershell\ncts-tf > run cts -m CtsAppSecurityHostTestCases  -t android.appsecurity.cts.AdoptableHostTest#testApps  --abi arm64-v8a --skip-preconditions\n```\n\n>   `CtsAppSecurityHostTestCases` 为模块名， `android.appsecurity.cts.AdoptableHostTest#testApps`为方法名，可以通过查看`testApps`找到其对应的模块和方法，一般是通过查看运行结果页面`test_result.xml`文件来确定。\n\n### 1.2.2. CTS case 整测\n\n```powershell\nrun cts\n```\n\n### 1.2.3. CTS 测试结果\n\n```powershell\n07-19 11:16:13 I/ConsoleReporter: [SC98531I10074210256] x86 CtsLibcoreTestCases completed in 0 ms. 1 passed, 0 failed, 0 not executed\n07-19 11:21:06 I/ResultReporter: Invocation finished in 8m 2s. PASSED: 2, FAILED: 0, MODULES: 2 of 2\n07-19 11:21:08 I/ResultReporter: Test Result: /home/local/SPREADTRUM/liguang.zhang/Program/cts/cts_7.0_r10_x86/android-cts/results/2017.07.19_11.13.04/test_result_failures.html\n07-19 11:21:08 I/ResultReporter: Full Result: /home/local/SPREADTRUM/liguang.zhang/Program/cts/cts_7.0_r10_x86/android-cts/results/2017.07.19_11.13.04.zip\n\ndrwxr-xr-x 6 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 Jul 19 10:58 ./\ndrwxr-xr-x 3 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 Jul 19 10:46 ../\ndrwxr-xr-x 5 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 Jul 19 11:13 logs/\ndrwxr-xr-x 5 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 Jul 19 11:21 results/\ndrwxr-xr-x 2 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 28672 Jul 19 10:46 testcases/\ndrwxr-xr-x 2 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  4096 Jul 19 10:46 tools/\n```\n\n>   结果存放在android-cts/results文件夹中，使用浏览器查看测试结果\n\n![Screenshot from 2017-07-19 16:29:36](/images/Screenshot from 2017-07-19 16:29:36.png)\n\n### 1.2.4. 查看log分析问题\n\ncts测试时，会在设备上安装相应的测试`apk`文件，可以直接查看跑测时间内的`adb log`， 或者查看`slog`或`ylog`。\n\nCTS也会抓取相应的`log`，放在`logs`文件夹下：\n\n```powershell\n-rw-r--r-- 1 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 1182724 Jul 19 11:21 bugreport-checker-post-module-CtsLibcoreTestCases_5645527917568831077.zip\n-rw-r--r-- 1 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users 1218461 Jul 19 11:18 bugreport-checker-post-module-CtsLibcoreTestCases_6806238881515812829.zip\n-rw-r--r-- 1 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users  268328 Jul 19 11:21 device_logcat_744877579665120107.zip\n-rw-r--r-- 1 SPREADTRUM\\liguang.zhang SPREADTRUM\\domain^users    8489 Jul 19 11:21 host_log_6331625108956460261.zip\n```\n\n>   `PC` 的 `host` `log`中的时间并不总是与设备中的  `log` 时间戳对应，分析时请不要受其误导，常见的问题是设备中的时间并未同步。\n\n# 2. vts测试\n```shell\nrun vts -m VtsHalBluetoothV1_0Target -t BluetoothHidlTest.LoopbackModeBandwidth_64bit\n```\n\n\n","tags":["Android","cts"],"categories":["Android"]},{"title":"磁盘配额调研报告","url":"/2017/07/18/存储相关/磁盘配额调研报告/","content":"\n# 1. 磁盘配额调研报告\n\n---\n\n## 1.1. 实际磁盘配额控制\n\n### 1.1.1. 依赖项情况\n\n-   `Ext4`文件系统默认开启了`DQUOT_USAGE_ENABLED`\n\n>   `Kernel`中 `filesystem support`中开启了`quota support` \n\n### 1.1.2. 磁盘配额初始化\n\n-   由`Installd`开启`data`分区的磁盘配额 （`/mnt/runtime/default`）\n\n>   Sd卡格式化内部存储后，应该也可以支持\n\n`StorageStatesService`和`installd`的联动\n\n在`invalidateMounts` 函数中完成了磁盘配额的初始化\n\n```cpp\nFound quota mount \" << source << \" at \" << target;\nquotactl(QCMD(Q_QUOTAON, USRQUOTA), source.\nquotactl(QCMD(Q_QUOTAON, GRPQUOTA), source\n```\n\n>   并没有将配置放在fstab中，使用fstab对分区的文件系统进行自动配额调整。可以使用fstab对某一分区进行配额的设定。\n\n### 1.1.3. 磁盘配额的额外设定\n\n为每个应用设置的实际磁盘配额 ：\n\n-   **90%** of `disk blocks`, or**50%** of disk inodes.\n\n>   ***设定原因***：\n>\n>   Abusive or broken apps can go crazy and try allocating all of the disk space on the device.  To mitigate the impact on system health,\n>\n>   set hard limits to block any given app from using more than 90% of disk blocks, or 50% of disk inodes.\n>\n>   Also define the hard limit for AID_MEDIA_RW to avoid filling up the device via the SD card.    \n>\n>   Kick QUOTAON when scanning devices, since ext4 doesn't toggle DQUOT_LIMITS_ENABLED during initial mount.\n\n\n\n# 2. 虚拟的磁盘配额(cache quota)\n\nAndroid O 围绕缓存数据提供更加出色的导航和性能。每个应用均获得一定的磁盘空间配额，用于存储 [getCacheQuotaBytes(File)](#getCacheQuotaBytes(java.io.File)) 返回的缓存数据。\n\n## 2.1. cache quota 初始化\n\n由`Framework`层的`StorageStatsService`进行初始化：\n\n```java\nmHandler.sendEmptyMessage(H.MSG_LOAD_CACHED_QUOTAS_FROM_FILE);\n```\n\n默认生成`/data/system/cachequota.xml`文件，用于持久化应用初始的cache磁盘配额。\n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<cache-info previousBytes=\"0\">\n<quota uid=\"1000\" bytes=\"338152713\" />\n<quota uid=\"10012\" bytes=\"235993028\" />\n</cache-info>\n```\n\n```puml\n@startuml\n\t  StorageStatsService -> StorageStatsService: {}create /data/system/cachequota.xml\n\t  StorageStatsService->StorageStatsService: {}MSG:MSG_LOAD_CACHED_QUOTAS_FROM_FILE\n\t  StorageStatsService->CacheQuotaStrategy: setupQuotasFromFile\n\t  CacheQuotaStrategy->CacheQuotaStrategy:    readFromXml(cachequota.xml)\n\t  CacheQuotaStrategy->CacheQuotaStrategy:   pushProcessedQuotas(item): \n\t  note right of CacheQuotaStrategy: \\nupdate item value in java and native(installd)\n\t  StorageStatsService->StorageStatsService:{}:MSG: MSG_CHECK_STORAGE_DELTADELAY_IN_MILLIS\n\t  loop default 30s\n\t  StorageStatsService->StorageStatsService:MSG_CHECK_STORAGE_DELTADELAY_IN_MILLIS\n\t          opt previousBytes - available bytes < 0.05 * total bytes { perviousBytes保存了上一次调整时的available bytes }\n\t              StorageStatsService->CacheQuotaStrategy: recalculateQuotas\n\t              CacheQuotaStrategy->CacheQuotaStrategy: getUnfulfilledRequests\n\t              CacheQuotaStrategy->UsageStatsService: queryUsageStatsForUser[to get application usage]\n\t              CacheQuotaStrategy->CacheQuotaService: computeCacheQuotaHints(In: application usage) \n\t              CacheQuotaService-->CacheQuotaService: MSG: MSG_SEND_LIST\n\t              CacheQuotaService->CacheQuotaService: onComputeCacheQuotaHints\n\t              note right of CacheQuotaService:使用根据应用的使用时间进行排序， 排序后放在队列中。\\n 根据在队列中的位置，  按照一定的加权值分配相应的配额。\\n 总配额(freesize * 0.15)使用的时间越长， 获得的配额越大\n\t              CacheQuotaService->StorageStatsService: reply\n\t          end\n\n@enduml\n```\n\n## 2.2. 内部存储不足时，根据cache quota 释放cache\n\n当系统需要释放磁盘空间时，将开始从超过配额最多的应用中删除缓存文件。因此，如果将您的缓存数据量始终保持低于配额的水平，则在必须清除系统中的某些文件时，您的缓存文件将能坚持到最后。系统在决定删除您的应用中的哪些缓存文件时，将首先考虑删除最旧的文件（由修改时间决定）。\n\n#### 2.2.1.1. 目录的两种删除机制\n\n可以针对每个目录启用两种新行为，以控制系统如何释放缓存数据：\n\n###### 2.2.1.1.1.1. 整体\n\n\n-  setCacheBehaviorAtomic(File, boolean)\n\n    可用于指示某个目录及其所有内容应作为一个不可分割的整体进行删除。只能作用于目录。设置后，该目录下的所有子目录及文件都标记为一个整体。  \n\n    >   其下面的每一个文件的修改，修改时间都会标记到该目录层级上。\n\n\n###### 2.2.1.1.1.2. 截断\n\n- setCacheBehaviorTombstone(File, boolean)\n\n    可用于指示不应删除某个目录内的文件，而应将它们截断到 0 字节长度，使空文件保持完好。也可用于目录，则该级目录下的所有文件（除链接之外的）删除时都会截断到0字节长度。\n\n\n\n<span id=\"jump\">跳转到的地方</span>\n\n#### 2.2.1.2. 根据cache quota 释放 cache\n\n-   删除目录层次：\n\n    ```cpp\n    /data/user/<user_id>/\n    /data/user_de/<user_id>\n    /data/media/<user_id>/Android/data/\n    ```\n\n    -   以`uid` 为索引，创建相应的`tracker`。特殊的对于`media`下的，其为 `external data`\n    -   以 `getCacheRatio` (`cacheUsed`/ `quota配额`)为排序依据保存了`tracker`\n    -   `cacheRatio`越大，越排在前面\n    -   `tracker`中保存应用下 `cache`  `code_cache`  子目录中的各级文件: 保存到了`items` 的`vector`中。\n    -   `items` 按照修改时间进行排序，特定的对于使用前面两个接口设置文件绑定关系([1](#整体) [2](#截断))的，会绑定为一个item。\n\n\n>   ***在对item进行删除时，首先找到cacheRatio最大的应用相关的目录，去其中的文件按照修改时间的顺序进行删除，每删除一项，检查删除后的空间是否满足要求，如果满足要求，则不再进行删除，如果不满足，重新计算每个应用的cacheRadio，然后，对cacheRadio最大的，找到其中修改时间最早的项。进行删除。  依此步骤，直到删除到满足条件为止。***\n\n### 2.2.2. 为应用分配空间时，查询可使用的空间\n\n在需要为大文件分配磁盘空间时，可考虑使用新的 [allocateBytes(File, long, int)](#allocateBytes(java.io.File, long, int)) API，它将==自动清除==属于其他应用的缓存文件（根据需要），以满足您的请求。在确定设备是否有足够的磁盘空间保存您的新数据时，请调用 [getAllocatableBytes(File, int)](#getAllocatableBytes(java.io.File, int)) 而不要使用 [getUsableSpace()](#getUsableSpace())，因为前者会考虑系统要为您清除的任何缓存数据。\n\n[跳转](#jump)","tags":["AndroidO"],"categories":["Android"]},{"title":"Effective Modern C++ 11 笔记","url":"/2016/09/02/其他调研/c++11语法/","content":"\n> Effective Modern C++ 11 笔记\n\n# 1. 型别推导\n## 1.1. 条款1 理解模型型别推导\n>理解 auto 和 decltype\n\n伪代码:\n```cpp\ntemplate<typename T>\nvoid f(ParamType param);\nf(expr); //以表达式调用f\n```\n编译期间, 编译器通过expr推导两个型别: T 和 ParamType\nT的型别推导结果, 不仅仅依赖表达式`expr`的型别, 还依赖ParamType的形式, 分下面三种情况:\n- ParamType具有指针或引用型别, 但不是万能引用(条款24)\n- ParmaType 是万能引用\n- ParamType 非指针也非引用\n\n### 1.1.1. ParamType具有指针或引用型别\n1. expr 具有引用类型, 先将引用忽略\n2. 执行模式匹配, 决定T的型别\n\nParamType 引用类型\nex:\n```cpp\nvoid(T& param);\nint x=27;\nconst int cx = x;    //T->const int\nconst int& rx = x;   //T->const int&\nf(x);     //T->int        ParamType->int&\nf(cx);    //T->const int  ParamType->const int&\nf(rx);    //T->const int  ParamType->const int&\n```\nParamType指针类型\nex:\n```cpp\nvoid f(T* param);\nint x = 27;\nconst int *px = &x;     px->const int\nf(&x);            // int, int*\nf(px);            //   const int, const int *\n```\n### 1.1.2. ParamType 是万能引用\n>万能引用 T&&\n- 如`expr`是左值, T和ParamType都为左值引用\n- `expr`是右值, 符合情况1中的规则\n```cpp\nvoid f(T&& param);\nconst int cx = x;    //T->const int\nconst int& rx = x;   //T->const int&\nf(x);     //int&, int&\nf(cx);    //const int&, const int&\nf(rx);    //const int&, const int&\nf(27);       // 27是右值, T变为int, ParamType为int&&\n```\n### 1.1.3. ParamType非指针也非引用\n>按值传递, 形参是原对象的一份拷贝\n- `expr`如具有引用, 则忽略\n- 忽略后, 若还是const, 也忽略.若是volatile, 也忽略\n```cpp\nvoid f(T param);\nf(x);\nf(cx);      都是int\nf(rx);\nconst char* const p = \"abc\";    //p->const char* const\nf(p);                             //推导为const char*    指针指向的内容不能更改, 但指针可以指向其他的地方\n```\n### 1.1.4. 数组实参\n```cpp\nconst char name[] = \"who\";    //const char [4]\nconst char* pname = name      // pname-> const char* 退化为指针\nvoid f(T param);\nf(name);                 // const char*  退化为指针\nvoid f2(T& param);       //没有退化, ParamType const char (&)[4]\n```\n可以通过编译器常量形式返回数组尺寸\n```cpp\ntemplate<typename T, std::size_t N>\nconstexpr std::size_t arraySize(T (&)[N]) noexcept{\n    return N;\n}\nchar nameCopy[arraySize(name)];\n```\n### 1.1.5. 函数实参\n```cpp\ntemplate<typename T>\nvoid f(T param);           // 按值\ntemplate<typename T>\nvoid f2(T& param);          // 按引用\nvoid someFunc(int, char*);       void(int, char*)\nf(someFunc);                     // void (*)(int, char*)  退化成指针\nf2(someFunc);                    // void (&)(int, char*)\n```\n### 1.1.6. 要点速记\n- 在模板性别推导过程中, 具有引用型别的实参会被当成非引用型别来处理, 引用性被忽略\n- 对万能引用形参, 左值实参会进行特殊处理\n- 按值传递的形参, 是拷贝复制, const 和 volatile被丢弃\n- 数组或函数型的实参会退化成对应的指针, 除非被用来初始化引用\n\n## 1.2. 条款2 理解auto型别推导\n> 和模板型别推导类似, 修饰的左值的类型极为模板型别推导中的ParamType\nex:\n```cpp\nauto x= 27;\nconst auto cx = x;\nconst auto& rx = cx;      // rx的类型为ParamType   const int&\nauto&& uref1 = x; //万能引用,形参为左值 int&\nauto&& uref2 = rx;   // const int &\nauto&& uref3 = 27;    // 形参为右值, int&&\nconst char name[] = \"abc\";\nauto s=name;     //退化为指针, 不同于按值传递   const char*\nauto& s1=name; //const char (&)[4]\nvoid someFunc(int, char*);\nauto f1 = someFunc;  // 退化为指针, void (*)(int, char*)\nauto& f1 = someFunc; //void (&)(int, char*)\n```\n### 1.2.1. 跟模板不同的例外情况:\n当采用auto声明的变量使用{}初始化表达式来进行初始化时, 得到的型别是`std::initializer_list`, 而模板推导不出来, 编译错误\n```cpp\nauto x {1,2,3,4};\nvoid f(T param);\nf({1,2,3,4});   //error\nstd::vector<int> v;\n//函数表达式\nauto retV = [&v](const auto& newVal) {v = newVal;};\nretV({1,2,3});  //error\n```\n> 使用auto {}统一初始化时注意std::initializer_list的情况\n> lambda表达式的形参中使用auto, 是使用模板型别推导而非auto型别推导, 传递{}表达式实参会有编译报错的情况\n### 1.2.2. 要点速记\n- 一般情况下, auto型别推导 = 模板型别推导, 但使用{}初始化表达式会产生`std::initializer_list`, 而模板会报错\n- 在函数返回值中或lambda表达式的形参中使用auto, 不能传递{}表达式实参.\n## 1.3. 条款3 理解decltype\ndecltype返回给定的名字或表达式的确切类型\n>主要用于声明那些返回值型别依赖于形参型别的函数模板\n```cpp\n// C++ 11\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container& c, Index i) -> decltype(c[i])\n{\n\treturn c[i];\n}\n```\n大多数含有型别T对象的容器的operator []会返回T&, 但在模型型别推导中, 初始化表达式的引用会被丢弃\n```cpp\nstd::deque<int> d;\nauthAndAccess(d, 5) = 10;   //编译error, 引用性被丢弃\n```\n最终版本, 使用万能引用, 这样上面直接作为左值就可以编译通过了. 可以进行赋值.\n```cpp\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container&& c, Index i) -> decltype(std::forward<Container>(c)[i])\n{\n\treturn std::forward<Container>(c)[i];\n}\n```\n### 1.3.1. 要点速记\n- 绝大多数情况下, decltype会得出变量或表达式的型别而不做任何修改\n- 对于T的左值表达式, 除非该表达式仅有一个名字, deletype总是得出型别T&\n- C++14支持decltype(auto), 会从初始化表达式推导型别, 使用decltype的规则\n## 1.4. 条款4 查看型别推导的结果的方法\n- IDE查看, 作用有限\n- 编译器诊断信息, 导致编译错误\n```cpp\ntemplate<typename T>\nclass TD;\nconst int s = 0;\nauto x = s;\n// 输出错误\nx = \"error\";\n```\n- 运行时输出\n```cpp\n//编译器会做一些特殊处理, 同时结果因为使用了按值传递, 会丢弃一些信息\ntypeid(param).name();\n```\n使用Boost.TypeIndex来产生精确的型别识别信息\n```cpp\n#include <boost/type_index.hpp>\nusing boost:typeindex:type_id_with_cvr;\ntype_id_with_cvr<T>().pretty_name();\ntype_id_with_cvr<decltype(param)>().pretty_name();\n```\n### 1.4.1. 要点速记\n- 利用IDE编辑器\\编译器错误消息和Boost.TypeIndex库能查到推导的类型\n- 有些工具产生的结果无用或不准确, 理解是必要的\n\n# 2. auto\n\n## 2.1. 条款5 优选使用auto, 而非显示型别声明\n\n>使用auto必须初始化, 避免了变量未初始化引起的错误;\n>auto可以直接表示函数指针, 比std::function使用的内存更少\n>避免隐式类型转换, 避免无谓的内存开销\n```cpp\nstd::unordered_map<std::string, int>m;\nfor(const std::pair<std::string,int>&p:m){\n...\n}\n```\nstd::unordered_map的键值部分是const, 遍历时应该是`std::pair<const std::string,int>`而不是`std::pair<std::string,int>`\n每循环一次, 都会发生一次隐式转换,  p也指向的临时对象, 每次迭代结束, 临时对象需要析构.\n```cpp\nfor(const auto &p:m){\n...\n}\n```\n### 2.1.1. 要点速记\n- auto变量必须初始化, 基本上对会导致兼容性和效率问题的型别不匹配现象免疫, 还可以简化重构流程\n- auto型别的变量有条款2和条款6的毛病\n## 2.2. 条款 6 当auto推导型别不符合要求时, 使用(强制类型转换)显示型别的初始化习惯用法\n>`std::vector<bool>`类型[]返回值不能用auto, 返回的不是bool类型. 而是`std::vector<bool>::reference`, 它是std::vector<bool>的代理类\n>由上面的规则推导出普遍规律: 隐形代理类和auto无法和平共处. 防止写出`auto var = \"隐形\"代理型别表达式`\n>对于上面的隐形代理类, 使用强制类型转换来使用auto\n```cpp\nstd::vector<bool> features {0,1,0};\nauto feture1 = static_cast<bool>features[2];\n// feature2 auto 指向返回隐士代理, 离开作用域后, 变成野指针\nauto feature2 = features[2];\n```\n>使用static_cast强制类型转换, 可以表明我是故意这样转换的, 比如降低精度, double->float double->int等.\n### 2.2.1. 要点速记\n- 隐形的代理型别可以导致auto根据初始化表达式推导出错误的型别\n- 带显示型别的初始化习惯用法强制auto推倒想要的类型(强制类型转换)\n# 3. 转向现代C++\n## 3.1. 条款7 创建对象时区分() 和 {}\n```cpp\nclass D;\nD d1;    //调用默认构造函数\nD d2 = d1;  // 并非赋值, 调用复制构造函数\nd1 = d2;    // 并非复制, 调用复制赋值运算符  =\n```\nC++ 11引入了统一初始化\n> {}初始化禁止内建类型之间进行隐式窄化类型转换\n`缺陷`:\n>伴随意外行为\nstd::initializer_list, 见条款2\n如果类中的构造函数重载了以`std::initializer_list`作为参数的构造函数, 使用{}初始化会优先使用该构造函数进行初始化\n```cpp\nclass D {\n    D(int i, bool b);\n    D(std::initializer_list<long, double> l);\n};\n// 使用initializer_list的构造函数, 10, true被强制转换\nD d1{10, true};\n```\n只有找不到实参可以转换为initializer_list中的形参类型的情况下, 才会去找别的构造函数\n>`std::vector`中就使用了这样的构造方法, 所以一定要注意vector构造时使用()还是{}进行初始化.\n>{}初始化会进行auto的型别推导\n### 3.1.1. 要点速记\n- {}初始化可以应用的语境最为广泛, 可以阻止隐式窄化转换, 对函数表达不带形参的()初始化免疫\n- 在构造函数重载决议期间, 只要有任何可能, {}初始化就会与带有`std::initializer_list`型别的形参相匹配,即使其他重载版本有更加匹配的形参表\n- 使用()还是{}, 最后的结果可能不一样, 如vector对象的初始化\n```cpp\n\tstd::vector<int> vx(10,20);\n\tstd::vector<int> vd{10,20};\n\tfor(const auto& p : vx) {\n\t\tcout<< p << endl;\n\t}\n\tfor(const auto& p : vd) {\n\t\tcout<< p << endl;\n\t}\n```\n- 在模板内容进行对象创建时, 到底使用()还是{}会成为一个棘手的问题\n## 3.2. 条款8 优先使用nullptr, 而非NULL或0\n在只能使用指针的语境中使用0, 会被勉强解释为空指针.\n>0和NULL都不具体有指针型别, nullptr不具备整形型别.\nf(NULL)的不确定性, 在函数重载时, 调用出错.\n```\nvoid f(void *);\nvoid f(int);\n```\n>nullptr可以隐式转换为所有的裸指针型别.\n>使用auto声明变量时, 如果还是用0或NULL, 如返回值返回0或NULL, auto声明变量的类型会推导出错.\n错误的用法:\n```cpp\nchar* findRecord(char* name) {\n...\nreturn NULL;\n}\nauto ret = findRecord(key);\nif(ret == NULL)\n...\n```\n>nullptr在有函数模板的前提下表现最亮眼\n```cpp\nint f1(std::shared_ptr<D> ptr);\nint f2(std::unique_ptr<D> ptr);\nbool f3(D* ptr);\ntemplate<typename, Functype, typename MuxType, typename PtrType>\nauto lockAndCall(Functype func, MutxtType& mutex, PtrType ptr)\n->decltype(func(ptr)) {\n    MuxGuard g(mutex);\n    return func(ptr);\n}\nauto ret = lockAndCall(f3, f3m, nullptr);\n```\n上述的函数模板可以编译通过, 如果使用NULL或0就不可以.\n### 3.2.1. 要点速记\n- 想对于0或NULL, 优先使用nullptr\n- 避免在整形和指针型别之间重载\n## 3.3. 条款9 优先使用别名声明, 而非typedef\n>别名声明可以模板化, typedef就不行\n```cpp\ntemplate<typename T>\nusing MyAllocList = std::list<T, MyAlloc<T>>; //使用别名后, 就能使用 MyAlloc<T>了\nMyAllocList<D> ld;  //客户代码,使用api\n...\ntemplate<typename T>\nclass C{\n    private:\n        MyAlloc<T> list;\n}\n// typedef 的写法需要加上 typename 和 ::type\nusing remove_const_t = typename remove_const<T>::type;\n```\n### 3.3.1. 要点速记\n- typedef 不支持模版化，但别名声明支持\n- 别名模板可以免写::type后缀,并且在模板内, 对于内嵌typedef的引用经常要求加上typename前缀\n## 3.4. 条款10 优先使用限定作用域的枚举类型\n>通用规则, 如果在{}内声明一个名字,则改名字的可见性就被限定在{}内\n>上面的规则不适用于枚举量, 此作用域内不能有其他实体去相同名字. 即存在`名字污染`问题\n>不限范围的枚举类型可以隐式转换为整数型别, 限定的就不可以, 如果确实需要转换为int, 可以使用`static_cast`强转.\n```cpp\nenum class Color{black, white, red};\n```\n### 3.4.1. 要点速记\n- c++ 98风格的枚举类型, 称为不限范围的枚举类型\n- 限定作用域的枚举类型仅在枚举型别内可见, 只能通过强制类型转换转到其他型别\n- 限定作用域的枚举型别和不限制范围的都支持底层型别指定. 限定的默认是int, 不限定的没有默认\n- 限定作用域的枚举型别可以前置声明, 而不限的在指定了默认底层型别的前提下才可以.\n## 3.5. 条款11 优先使用删除函数, 而非private未定义函数\n>压制某函数,  不让别人用\n```cpp\nclass C{\n    C(const C&) = delete;     //复制构造函数\n    C& oprator=(const C&) = delete;    //复制赋值运算符\n}\n```\n>如果客户代码访问了delete的函数, 会在编译阶段就报错.\n>成员函数和友元函数也会无法访问\n>任何函数都可以成为删除函数\n>可以删除某些有些转换后能够变成重载的形参的函数的特定版本\n```cpp\nbool isLucky(int number);\nbool isLucky(double number) = delete;\nisLucky(3.5f); // 编译出错\n```\n> 阻止不应该进行的模板具现\n```cpp\ntemplate<typename T>\nvoid processPointer(T* ptr);\nvoid processPointer<void>(void*) = delete;\nvoid processPointer<char>(char*) = delete;\n```\n### 3.5.1. 要点速记\n- 优先使用删除函数, 而非private未定义函数\n- 任何函数都可以删除, 包括非成员函数和模板具现\n## 3.6. 条款12 为改写的函数添加override声明\n改写(override), 重载(overload)\n好处:\n- 编译器在你想要改写的函数实际上并未改写是提示\n- 如果派生类都写了override生命,则改函数签名时可以知道有多少派生类被影响到了\n```cpp\nclass Base{\nvirtual void f();\nvirtual doWork();\n}\nclass Dp:public Base{\npublic:\nvoid f() overide;\nvoid doWork() & override; //仅在*this是左值时调用\nvoid doWork() && override; //仅在*this是右值时调用\n}\nDp dp;\ndp.doWork();        //以左值调用doWork\nmakeDp().doWork();   // 以右值调用doWork\n```\n区分返回左值版本还是右值版本\n### 3.6.1. 要点速记\n- 为在意改写的函数添加override声明\n- 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分\n## 3.7. 条款13 优先使用const_iterator, 而不是iterator\n```cpp\nstd::vector<int> values;\nauto it=std::find(values,cbegin(), values,cend(), 1983);\nvalues.insert(it, 1998);\n```\n容器的cbegin, cend返回const_iterator. \nSTL成员函数若要取用指示位置的迭代器, 也要求使用const_iterator型别\n如果容器的成员函数未提供cbegin, cend.\n非成员函数版本cbegin的一个实现:\n```cpp\ntemplate<class C>\nauto cbegin(const C& container) -> decltype(std::begin(container)\n{\n     return std::begin(container);\n}\n```\n### 3.7.1. 要点速记\n - 优先使用const_iterator, 而不是iterator\n - 在最通用的代码中, 优先使用非成员函数版本的begin, end, rbegin等\n## 3.8. 条款14 只要函数不发生异常, 加上noexcept声明\n### 3.8.1. 要点速记\n- noexcept声明是函数接口的组成部分, 调用方可能对它有依赖\n- 想对于不带noexcept声明的函数, 带有的有可能得到优化\n- noexcept性质对于移动操作/swap/内存释放函数/和析构函数最有价值\n- 大多数函数都是异常中立的, 不具备noexcept性质\n## 3.9. 条款15 优先使用constexpr\n- 所有的constexpr对象都是const对象\n- 并非所有的const对象都是constexpr\n- constexpr可以保证编译期可知\n- constexpr函数可以用在编译期常量的语境中.\n```cpp\nconstexpr int pow(int base, int exp) noexcept\n{\n    return (exp == 0)? 1: base * pow(base, exp - 1);\n}\nconstexpr auto exp = 5;\nstd::array<int, pow(3, exp)> results;\n```\n即base和exp都是编译期常量, pow的返回结果就可以当成编译期常量使用\n如果base和exp有一个不是编译期常量, 则pow的返回结果就是执行期量.\n>constexpr的函数实现因为需要保证在编译期能返回编译期结果, 因此需要对函数实现添加限制\n- 只能有一条return语句.\n可以通过条件表达式或者递归的方式实现.\n用户自定义型别同样可能是字面型别, 因它的构造函数和其他成员函数可能也是constexpr函数\n- constexpr函数除了void, 其他的内建型别都支持, 另外不允许有io语句\n### 3.9.1. 要点速记\n- constexpr对象都具备const属性, 并由编译期已知的值完成初始化\n- constexpr函数在调用时若传入的实参是编译期已知的, 则会产生编译期结果\n- 比起非constexpr对象或constexpr函数而言, constexpr对象或函数都可以用在作用域更广的语境中\n## 3.10. 条款16 保证const成员函数的线程安全性\n### 3.10.1. 要点速记\n- 保证const成员函数的线程安全性, 除非可以确认它们不会用在并发语境下\n- 运用std::atomic型别的变量会比运用互斥量提供更好的性能 , 但前者仅仅适用于单个变量或内存区域的操作\n## 3.11. 条款17 理解特种成员函数的生成机制\n>特种成员函数是指从c++自动生成的成员函数\n默认构造函数. 析构函数 复制构造函数. 复制赋值运算符函数\nC++11中, 加入了两个新成员:\n移动构造函数和移动赋值运算符\n```cpp\nclass D{\n    D(D&& rhs)；//移动构造函数\n    D& operator=(D&& rhs); //移动赋值运算符\n}\n```\n两种移动操作不是独立的, 声明了其中一个, 会阻止生成另一个.\n- 按成员移动由两部分构成:\n1.  支持移动操作的成员上执行的移动操作\n2. 不支持...\n复制操作和移动操作一般来说也不是独立的, 一旦声明了移动操作, 就废弃了复制操作.\n大三律:\n声明了复制构造函数/复制赋值运算符或析构函数的任一个, 就需要同时声明这三个\n\n大三律的推论:\n如果声明了析构函数, 复制操作就不应该自动生成, 因为自动生成的行为一定不正确.\n如声明了析构函数, 就不会生成移动操作\n\n移动操作的生成条件(自动生成, 按需生成), 仅当以下三者同时成立的条件下:\n- 该类未声明任何复制操作\n- 该类未声明任何析构函数\n- 该类未声明任何移动操作\n\n如果不想让上述规则生效, 需要添加 `=default`来显示的表达我就想用某操作\n```cpp\nclass D\n{\n    public:\n        ~D();\n        D& oprator=(constD& ) = default; //默认复制赋值运算符的行为是正确的\n        D(D&& rhs) = default;   // 提供移动操作的支持\n}\n```\n|特种函数名称|机制|\n|--|--|\n|默认构造函数|仅仅当类中不包含用户声明的构造函数时才生成|\n|析构函数|默认为noexecpt, 仅当基类的是虚的, 派生类的才是虚的|\n|复制构造函数|仅当类中不包含用户声明的复制构造函数时才生成, 如果声明了移动操作, 则复制构造会被删除.在已经存在复制赋值运算符或析构函数的条件下,不会生成复制构造函数|\n|复制赋值运算符|如果声明了移动操作, 复制赋值运算符将被移除,在已经存在了复制构造或析构函数的条件下,废弃|\n|移动构造函数和移动赋值运算符|类中不包含用户声明的复制操作/移动操作/析构函数时才生成|\n特例:\n>成员函数模板的存在不会阻止编译器生成任何特种成员函数\n```cpp\nclass D\n{\n    template<typename T>\n    D(const T& rhs);\n    D& oprator=(const T& rhs);\n}\n```\n编译器会始终自动生成D的复制和移动操作, 即使这些模板具现了复制或复制赋值运算符的函数签名(T为D也会生成)\n### 3.11.1. 要点速记\n- 特种成员函数是指那些C++自行生成的成员函数, 默认构造 析构函数 复制操作 移动操作\n- 移动操作仅当类中未包含用户显示声明的复制 移动 析构时才生成\n- 复制构造仅当类中不包含显示声明的复制构造时才生成.如声明了移动操作, 则复制构造会被废弃; 复制赋值仅当类中不包含显示声明的复制赋值时才生成, 如果声明了移动操作,会废弃;已经存在显示析构的条件下, 生成复制操作会被废弃\n- 成员函数模板在任何情况下都不会抑制特种成员函数的生成\n# 4. 智能指针\n>关于裸指针\n1. 裸指针在声明中没有指出指到的是单个对象还是一个数组\n2. 裸指针在生命中也没有提示在使用完指的对象后, 是否需要被析构.从声明中看不出指针是否指到了对象\n3. 即使知道需要析构指针所指的对象, 也不要知道如果适当析构, 是使用delelte, 还是专门的析构函数\n4. 即使知道了使用delete, 会是不知道是指单个对象还是数组, 是使用delelte还是delelte []\n5. 即使知道delelte的形式, 也不能保证析构在所有代码路径上都仅执行一次(包括异常导致的代码路径).只要少在一路上执行, 就会导致资源泄漏,执行多了会出现未定义行为\n6. 没有任何正规的方式能检测出指针是否空悬\n在上面裸指针的种种问题下, 请优先使用智能指针, 保证在合适的时机下析构\n- `std::auto_ptr`\nC++ 98残留,后来变成了unique_ptr,不再建议使用\n- `std::unique_ptr`\n在C++11中用来代替auto_ptr的\n- `std::shared_ptr`\n- `std::weak_ptr`\n## 4.1. 条款18 使用`std::unique_ptr`管理专属所有权的资源\n考虑使用智能指针时, 优先使用unique_ptr, 和裸指针的代价差不多, 实现专属所有权语义.\n`std::unique_ptr`是只移动型别,资源的析构是通过对其内部的裸指针实施delete完成\n常见用法是在对象继承谱系中作为工厂函数的返回类型, 调用者需要对工厂函数返回的资源负责, 属于专属所有权\n\n```cpp\nclass Investment{...};\nclass Stock:\n    public Investment {...};\nclass Bond:\n    public Investment {...};\n//调用者通过工厂函数创建对象, 工厂函数声明\ntemplate<typename... Ts>\nstd::unique_ptr<Investment> makeInvestmnet(Ts&&... params);\n//客户代码\n{\nauto pInvestment = makeInvestment(arguments);\n}  //*pInvestment在此析构\n```\n如果所有权链由于异常或其他非典型控制流(如函数提早返回)而中断时, 有托管资源所有权的std::unique_ptr最终将调用该资源的析构函数. 其托管资源最终被析构\n在析构过程中, 可以设定自定义析构器.\n```cpp\nauto delInvmt = [](Investment* pInvestment)\n{\n    makeLogEntry(pInvestment);\n    delete pInvestment;\n};\ntemplate<typename... Ts>\nstd::unique_ptr<Investment, decltype(delInvmt)>\nmakeInvestment(Ts&&... params)\n{\n    std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt);\n    if(/*创建stock型别对象*/) {\n        pInv.reset(new Stock(std::foward<Ts>(params)...)));\n    } else if() {\n        pInv.rest(new Bond(std::forward<Ts>(params)...));\n    }\n    return pInv;\n}\n```\n自定义析构器接受一个型别为Investment* 的形参, 终究会在lambda表达式中作为一个Investment* 对象被删除,意味着我们会通过基类指针删除一个派生类对象.\n基类必须具备一个虚析构函数\n```cpp\nclass Investment \n{\n    public:\n        //必须有{}, 否则会链接出错\n        virtual ~Investment(){};\n}\n```\n还可以这样定义工厂函数的返回值, 使用函数作为自定义析构器\n```cpp\nvoid delInvmt2(Investmt* pInv) {\n    makeLogEntry(pInv);\n    delete pInv;\n}\ntemplate<typename... Ts>\nstd::unique_ptr<Investment, void(*)(Investment*)> makeInvestment(Ts&&... params);\n```\nlambda表达式的方案更好.\nstd::unique_ptr以两种方式提供, 一种是单个对象, (std::unique_ptr<T>), 另一个是数组(std::unique_ptr<T[]>). 数组方式不推荐使用, 建议使用容器类.\n\n- std::unique_ptr可以更加高效的转换为std::shared_ptr;\n### 4.1.1. 要点速记\n- std::unique_ptr是小巧/高速的/具备只移型别的智能指针, 对托管资源实施专属所有权语义.\n- 默认采用delete运算实现, 但可以指定自定义删除器.有状态的删除器和采用函数指针实现的删除器会增加该型别的大小.\n- std::unique_ptr可以很容易的转换为`std::shared_ptr`\n## 4.2. 条款19 使用std::shared_ptr管理具备共享所有权的资源\n>采用共享所有权来管理生存期,当最后一个指到该对象的指针不再指它时, 该std::shared_ptr会析构所指的对象\nstd::shared_ptr的复制赋值动作会执行两种操作:\n`sp1 = sp2`\n- 最初sp1所指的对象的引用技数递减, 如减到0, 资源析构\n- sp2所指对象的引用计数递增\n引用计数的存在会带来一些性能影响:\n- 尺寸是裸指针的两倍, 一个指到裸指针, 一个指到引用计数\n- 引用计数的内存必须动态分配\n- 引用计数的递增和递减必须是原子操作\n移动构造函数, 会将源std::shared_ptr悬空, 原来的指针不再指到资源\n自定义析构器的型别不是std::shared_ptr指针的一部分, 而unique_ptr是\n```cpp\nstd::unique_ptr<Investment, decltype(delInvmet)> upw(new Investment, delInvmet);\nstd::shared_ptr<Investment> spw(new Investment, delInvmet);\nauto cd1 = [](Investment* p) {...};\nauto cd2 = [](Investment* p) {...};\n//std::shared_ptr的设计更有弹性\nstd::shared_ptr<Investment> spw1(new Investment, cd1);\nstd::shared_ptr<Investment> spw1(new Investment, cd1);\nstd::vector<std::shared_ptr<Investment>> vpw{spw1, spw1};\n```\n相对unique_ptr, shared_ptr的设计更有弹性\nshared_ptr的尺寸永远是裸指针的两倍, 不随析构器的尺寸发生变化\n尽可能避免将裸指针传递给一个std::shared_ptr的构造函数,常用的替换手法是使用`std::make_shared`\n如果必须将裸指针传递给std::shared_ptr的构造函数, 请在构造函数中直接new\n反面教材:\n```cpp\nauto pw = new D;\nstd::shared_ptr<D> spw1(pw, cd1);        //not ok\nstd::shared_ptr<D> spw3(new D, cd1);  //ok\nstd::shared_ptr<D> spw2(pw, cd2);        // not ok\nstd::shared_ptr<D> spw4(spw3)  //ok\n```\nstd::make_shared总是创建一个控制块\n### 4.2.1. 要点速记\n- std::shared_ptr提供方便的手段, 实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收机制\n- 与unique_ptr相比, 其尺寸通常是裸指针的两倍, 还带来了控制块的开销, 并要求原子引用计数\n- 默认的资源析构是delete, 同时支持定制自定义析构器, 自定义析构器不影响shared_ptr的型别\n- 避免使用裸指针型别的变量创建shared_ptr指针, 直接通过传入形参构造的方式.\n## 4.3. 条款20 对于类似std::shared_ptr但有可能悬空的指针使用std::weak_ptr\n这种指针像std::shared_ptr那样运作,但又不影响其所指对象的引用计数,真正的智能指针, 能够跟踪何时指针空悬.\nstd::weak_ptr是std::shared_ptr的一种扩充\n一般是通过shared_ptr来创建的,\n```cpp\nauto spw = make_shared<D>();\nstd::weak_ptr<D> wpw(spw);     //wpw和spw指向同一个D\nspw = nullptr;     //引用计数变为0, D对象被析构, wpw空悬,也被成为失效\nif(wpw.expired())   //wpw失效\nauto  spw2 = wpw.lock() //若wpw失效, spw2指针为空\n```\n在非严格继承谱系的数据结构中, 以及缓存和观察者的列表实现等情况下, std::weak_ptr非常适用\n### 4.3.1. 要点速记\n- 使用std::weak_ptr来代替可能空悬的shared_ptr\n- weak_ptr可能的用武之地包括缓存/观察者列表以及避免std::shared_ptr指针回路\n## 4.4. 条款21 优先选用make_shared和std::make_unique, 而非直接使用new\nmake_unique是C++ 14中的.\nmake系列函数会把一个任意实参集合完美转发给动态分配的内存对象的构造函数,并返回一个指到该对象的智能指针.\n```cpp\ntemplate<typename T, typename... Ts>\nstd::unique_ptr<T> make_unique(Ts&&... params)\n{\n    return std::unique_ptr<T>(new T(std::forward<Ts>(params)...));\n}\n```\n优先使用make系列与异常安全有关,性能有关\n但使用make系列无法自定义析构器\n```cpp\nauto spw1(std::make_shared<D>());\nstd::shared_ptr<D> d1(new D);\nprocessD(std::shared_ptr<D>(new D), computePriority); //潜在的资源泄漏\nprocessD(std::make_shared<D>(), computePriority);     //没有发生潜在资源泄漏的情况\nprocessD(d1, computePriority);  //也不会发生资源泄漏\n```\n### 4.4.1. 要点速记\n- 相比直接使用new表达式, make系列消除了重复代码, 引进了异常安全性, 并且对于std::make_shared和std::allocate_shared而言, 生成的目标代码会尺寸更小/速度更快\n- 不适用make系列函数的场景包括自定义析构器,以及期望直接传递{}初始物\n- 对于std::shared_ptr, 不建议使用make的额外场景包括:1.  自定义内存管理的类, 2. 内存紧张的系统/非常大的对象,以及存在比指到相同shared_ptr对象生存期更久的weak_ptr\n## 4.5. 条款22 使用Pimpl习惯用法时, 将特殊成员函数的定义放到实现文件中\n### 4.5.1. 要点速记\n- Pimpl惯用法通过降低类的客户和类实现者之间的依赖性, 减少了构建遍数\n- 对于采用unique_ptr来实现的pImpl指针, 须在类的头文件中声明特种成员函数, 但需要在实现文件中实现他们\n- 上述建议使用与unique_ptr, 不适用与shared_ptr\n# 5. 右值引用 移动语义和完美转发\n>移动语义: 以代价比较小的移动操作代替昂贵的复制操作,移动构造函数和移动复制赋值运算符函数也给了移动语义的能力\n>完美转发:使得可以任意撰写接受任意实参的函数模板, 并将其转发给其他函数, 目标函数会接受到与转发函数完全相同的实参.\n>注意点: 形参总是左值, 即使其型别是右值引用\n## 5.1. 理解std::move和std::forward\nstd::move无条件的将实参转换为右值, std::forward则仅在某个条件下才执行强制转换\nstd::move做的是强制类型转换, 不做的是移动, 转换为右值后, 表明其具备了可移动的条件\n经验:\n\n- 如果想取得对某个对象执行移动操作的能力, 不要将其声明为常量, 以为针对常量对象执行的移动操作将一声不吭的变换为复制操作\n- std::move不仅不实际移动, 甚至不保证转换后的对象具有可移动的能力, 唯一可以确定的是转换后, 会变为右值\n- std::move 执行了移动构造函数， 移动的原目标的值会被清空。其内容移动给了新的目标。\n```cpp\nvoid process(const D& d1)  //处理左值\nvoid process(D&& d1)  //处理右值\ntemplate<typename T>\nvoid logAndProcess(T&& param)\n{\n    auto now = std::chrono::system_clock::now();\n    makeLogEntry(\"calling process\", now);\n    //进行转发\n    process(std::forward<T>(param));\n}\nD d;   //左值\nlogAndProcess(d);\nlogAndProcess(std::move(d));     //调用时转换为右值\n```\n### 5.1.1. 要点速记\n- std::move实施的是无条件的转换为右值, 对其本身而言, 不会执行移动\n- 仅当传入的实参被绑定为右值时, std::forward才会针对该实参实施转换为右值, 实现的是转发语义\n- 在运行期间, std::move和std::forward不执行任何操作\n\n## 5.2. 条款24 区分万能引用和右值引用\n\n```cpp\nvoid f(D&& param);       右值引用\nD&& d = D();             右值引用\nauto&& d2 = d；          非右值引用\ntemplate<typename T>\nvoid f(std::vector<T>&& param)   右值引用\ntemplate<typename T>\nvoid f(T&& param)                非右值引用\ntemplate<typename T>\nvoid f(const T&& param)          右值引用\n```\n> T&& 为右值引用, 主要的理由是能识别出可移对象\n> 不涉及型别推导, 就是右值引用\n> 必须指定为T&&的模式. 加上修饰符也不行\n```cpp\ntemplate<typename T>\nvoid f(std::vector<T>&& param)   //右值引用\nstd::vector<int> v;\nf(v)   //编译出错, 无法绑定到右值, 传入的是左值\n```\n## 5.3. 条款25 针对右值引用实施std::move, 针对万能引用实施std::forward\n这里只给出一个错误示范:\n```cpp\nclass D\n{\n    public:\n        template<typename T>\n        void setName(T&& newName) {\n            name = std::move(newName);\n        }\n    private:\n        std::string name;\n};\nstd::string getDname();\nD d;\nauto n = getDname();\nd.setName(n);   //将n移入了d中\n//n将变成未知的.\n```\nstd::move将引用形参无条件的强制转换为右值, n的值就被移入d.name中.\n返回值优化:\n - 局部对象型别和函数返回值型别形同\n - 返回的就是局部对象本身\n### 5.3.1. 要点速记\n- 针对右值引用的最后一次实施std::move, 针对万能引用的最后一次实施std::forward\n- 若局部对象可能适用于返回值优化, 则请勿针对其实施std::move或std::forward\n### 5.3.2. 要点速记\n避免使用万能引用进行函数重载\n- 把万能引用作为重载候选型别, 几乎总会让该重载版本在始料未及的情况下被调用到\n- 完美转发构造函数的问题尤其严重, 因为对于非常量的左值型别, 他们一般都会形成想对于复制构造函数的更佳匹配.并且还会劫持派生类中对基类的复制和移动构造函数的调用\n## 5.4. 条款27 熟悉万能引用作为函数重载方案的替代方案\n- 传递const T& 型别的形参\n- 传值\n将传递的形参从引用型替换为值型别\n```cpp\nclass Person{\n    public:\n    explicit Person(std::string n):name(std::move(n)){};\n    explicit Person(int idx):name(nameFromIdx(idx)){};\n    private:\n    std::string name;\n}\n```\n- 标签分类\n传递左值常量还是传值, 都不支持完美转发, 标签分类支持完美转发, 标签值决定了调用了哪个重载版本\n```cpp\ntemplate<typename T>\nvoid logAndAdd(T&& name)\n{\n    logAndAddImpl(std::forward<T>(name),\n    std::is_illegal<typename std::remove_reference<T>::type>());\n}\ntemplate<typename T>\nvoid logAndAddImpl(T&& name, std::false_type)\n{\n    auto now = ...\n    log...\n    names.emplace(std::forward<T>(name));\n}\ntemplate<typename T>\nvoid logAndAddImpl(int idx, std::true_type)\n{\n    logAndAdd(nameFromIdx(idx));\n}\n```\n- 对接受万能引用的模板施加限制\n完美转发构造函数使用标签分类的方式并不能保证自动生成的特种函数一定会经过标签分派设计.\n完美转发的效率更高, 但写起来非常麻烦, 而且当客户代码传递了非法形参时, 编译信息的可理解性非常差\n### 5.4.1. 要点速记\n- 如果不能使用万能引用和重载的组合, 则替代方案包括使用彼此不同的函数名字/传值/传递const T&型别的形参,和标签分类\n- 万能引用形参通常在性能方面有优势, 但在易用性方面非常劣势\n## 5.5. 条款28 理解引用折叠\n引用的引用是非法的, 编译器会报错.\n但是在模板推导过程中和auto型别推导过程中,如果遇到引用的引用,即&&, 会进行引用折叠\n引用合成\n```cpp\nT& & => T&\nT&& & => T&\nT& && => T&\nT&& && => T&&\n```\n### 5.5.1. 要点速记\n- 引用折叠会在四种语境中发生, 模板实例化 auto型别生成 创建和运用typedef和别名声明以及decltype\n## 5.6. 条款29 假设移动操作不存在,成本高,未使用\n整个C++98标准库都已经被C++11彻底翻修过, 但还是有很多库未进行过修改.如果不支持移动操作, 就没有任何区别\n即使支持移动操作, 也不一定代价小\n在这样几种场景下, C++11的移动语义不会带来什么好处:\n1. **没有移动操作**: 待移动的对象未能提供移动操作\n2. **移动未能更快**:虽然有移动, 但并不比复制更快\n3. **移动不可用**:移动可以发生的语境下, 要求移动不可发生异常,但该操作未加上noexcept声明\n对于那些型别或对于移动语义的支持情况已知的代码,则无需上述假定\n## 5.7. 条款30 熟悉完美转发的失败情形\n转发函数天然就是泛型的, 接受**可变长形参**模板, 从而能够接受任意数量的实参\n```cpp\ntemplate<typename... Ts>\nvoid fwd(Ts&&... params)\n{\n    f(std::forward<Ts>(params)...);  //转发所有实参到f\n}\nf(expr)      //执行某种操作\nfwd(expr)    //如果执行了另外一种操作,则转发失败, fwd完美转发expr到f失败\n```\n**会导致完美转发失败的实参种类**有分为下面几种情况:\n1. {}初始化expr\n```cpp\nvoid f(const std::vector<int>& v);\nf({1,2,3,4});\nfwd({1,2,3,4});//error\n```\n- 编译器无法为一个或多个fwd的形参推导出型别结果\n- 编译器为一个或多个fwd的形参推导出了错误的型别\n2. 0和NULL用作空指针\n不能推倒出指针, 用nullptr代替\n3. 仅有声明的整形static const成员变量\n`static const std::size_t MinVals = 28;` 仅给出了声明, 并没有定义.\n4. 重载的函数名字和模板名字\n5. 位域\n非const引用不能绑定到位域\n只能进行复制,再转发\n万能引用的作用机制是引用, 在硬件级别, 引用就是指针的提领\n### 5.7.1. 要点速记\n- 完美转发的失败情形, 源于模板型别推导失败, 或推导结果是错误的型别\n- 会导致完美转发失败的实参种类有..., 见上面\n# 6. lambda表达式\n用法:\n- 自定义析构器, shared_ptr unique_ptr \n- 标准库 std::find_of remove_if count_if等\n- 制作回调函数,接口适配函数或语境相关的特化版本等\n闭包可以复制\n## 6.1. 条款31 避免默认捕获模式\n默认捕获模式:\n- 按引用捕获\n会导致闭包包含指到局部变量的引用, 一旦超出作用域, 闭包内引用可能空悬\n```cpp\nvoid addDivisorFilter()\n{\n    auto divisor = computeDivisor(cal1, cal2);\n    filters.emplace_back(\n        [&](int value) {return value % divisor == 0;}\n    );\n}\n```\n上面例子中filters可能为全局变量, 但其加入的lamda表达式中的divisor在离开了addDivisorFilter函数作用域后,就不存在了\n解决这个问题的一个办法是对`divisor`采用按值的默认捕获模式\n```cpp\nfilters.emplace_back([=](int value) {return value%divisor==0;});\n```\n捕获只能对创建lamda式内的作用域内`可见的非静态局部变量进行捕获, 如果是成员变量等, 不能进行捕获`\n```cpp\nclass D{\npublic:\n    void addFilter(){\n        filters.emplace_back(\n            [=](int value) {return value%divisor == 0;}\n        );\n    };\n    private int divisor;\n}\n```\n上面这个成员函数中lamda等同于下面这个\n```cpp\nclass D{\nauto p = this;\npublic:\n    void addFilter(){\n        filters.emplace_back(\n            [p](int value) {return value%p->divisor == 0;}\n        );\n    };\n    private int divisor;\n}\n```\n被捕获的实际是D的this指针而不是divisor, 因此在离开D对象作用域后, 生命周期结束后, 会导致指针空悬\n可以通过复制解决,\n```cpp\nclass D{\nauto p = this;\npublic:\n    void addFilter(){\n        auto devisor1 = devisor;\n        filters.emplace_back(\n            [devisor1](int value) {return value%divisor1 == 0;}\n        );\n    };\n    private int divisor;\n}\n```\n使用默认捕获模式的另一个缺点是与闭包外的变化绝缘\n不能捕获静态变量, 依赖于静态变量存储期, 会引起代码误读\n```cpp\nstatic int divisor = 1;\nvoid addF(){\n    divisor++;\n}\nvoid addDivisorFilter()\n{\n    filters.emplace_back(\n        [=](int value) {return value % divisor == 0;}   //未捕获任何东西, 但会指到静态变量上, 静态变量可能变化, 导致该表达式的含义变化\n    );\n}\n```\n### 6.1.1. 要点速记\n- 按引用的默认捕获会导致空悬指针问题\n- 按值的默认捕获易受空悬指针影响, 并且容易引起代码误读\n## 6.2. 条款32 使用初始化捕获将对象移入闭包\nC++11 不支持初始化捕获, c++14 支持\n```cpp\nauto func = [pw=std::move(pw)] {return pw->isValidated();};\n```\n上面的[]内的即为初始化表达式, =两侧的作用域不同. \n也称为广义lamda捕获模式\nC++ 11中需要使用std::bind, 按移动捕获\n- 把需要捕获的对象移动到std::bind产生的函数对象中\n- 给到lambda一个指到捕获对象的引用\n```cpp\nstd::vector<double> data;\nauto func=std::bind([](const std::vector<double>& data){/*对data进行操作*/}, std::move(data));\n```\nstd::bind返回的函数对象为绑定对象, 第一个实参是可调用对象, 接下来的所有实参是传给该对象的值\n绑定对象被调用时,采用了右值的实参传给了std::bind绑定的lambda式\n```cpp\nauto func=std::bind([const std::unique_ptr<D>& d]{return d->isValidate();}, std::make_unique<D>());\n```\n### 6.2.1. 要点速记\n- 使用C++14的初始化捕获将对象移入闭包\n- 在C++11中, 经由手工实现的类或std::bind去模拟初始化捕获\n## 6.3. 条款33 对auto&& 型别的形参使用decltype, 以std::foward之\n```cpp\nauto f=[](auto&& param) {\n    return func(normalize(std::forward<decltype(param)>(param)));\n};\n```\n## 6.4. 条款34 优先使用lambda表达式, 而非std::bind\n### 6.4.1. 要点速记\n- lambda表达式比起使用std::bind而言, 可读性更好,表达力更强, 运行效率更高\n- 仅在C++11中, std::bind在实现移动捕获或是绑定到具备模版化的函数调用运算符的对象的场合中,可有余热. 见条款32\n","tags":["C++11"],"categories":["C++","读书"]},{"title":"Android parcel 机制","url":"/2016/08/02/其他调研/Android parcel 机制/","content":"\nAndroid parcel 机制\n\n# 1. Serialize 说起\n\nJava中的Serialize机制, 串行化机制,效率较慢:\n\n*   使用的反射机制\n*  会生成很多临时文件,造成了垃圾回收\n\n将数据对象存入字节流中,在需要时重新生成对象.应用外部存储器保存对象状态,以及通过网络传输对象等.\n\n>   串行化: 将对象转化成字节流,保存在存储设备\\内存或二进制方式通过网络传输. 之后通过反串行化从连续的字节数据重新构建一个原始对象状态相同的对象.\n\n# 2. Parcel 简介\n\nAndroid工程师新设计了Parcel机制, 定位于轻量级的高效串行化和反串行化. 字节流主要保存在内存中, 用于IPC通信.\n\n# 3. Parcel 机制详解\n\n## 3.1. 源码位置\n\nFrameworks/base/core/java/android/os/Parcel.java\nFrameworks/base/core/jni/android_util_Binder.cpp\nframeworks/native/libs/binder/Parcel.cpp\n\n### 3.1.1. Parcel.java\n\n-   obtain() 获得一个新的parcel对象，相当于java中new一个对象\n\n从parcel池中拿出一个parcel. pool size 为6.取出不为空的parcel后, 将 pool池中的该对象设置为空. 如果池中都为空, 则新建一个parcel对象.\n\nobtain的参数为内存的指针. \n\n-   recyle() 清空并回收parcel对象所占内存\n\n清空当前Parcel对象, 回收Parcel占用内存. 同时将该parcel对象重新放入parcel 池中. 调用完该方法后, 不能再使用该对象.\n\n-   dataSize() 得到当前parcel对象的实际存储空间 \n-   dataCapacity() 得到当前parcel对象的已分配的存储空间,该值大于或等于dataSize()返回值 。\n-   dataPostion() 获得当前parcel对象的偏移量(类似于文件流指针的偏移量) \n-   setDataPosition() 设置偏移量（类似于移动指针到特定位置）\n-   writeXXX（）方法表示写于一个XXX类型的数\n-   readXXX（）方法表示读取一个XXX类型的数\n\n比如：writeInt(int) 写入一个整数；readInt（）读取一个整数。","tags":["Android","parcel"],"categories":["Android"]},{"title":"文件IO测试调研","url":"/2016/08/02/其他调研/文件IO测试/","content":"\n# 1. 文件IO测试调研\n\n## 1.1. 测试环境\n直接创建物理分区的测试环境比较麻烦, 而且操作硬盘如果出现误操作可能会对硬盘上的数据产生损坏.\n而创建虚拟分区的方法则比较安全, 还可以对其应用硬盘加密/启用多个文件系统等操作, 比较方便.\n本篇先通过建立一个虚拟的分区来测试文件IO\n\n### 1.1.1. 建立虚拟分区\n执行歩骤:\n\n```bash\n# 建立20M的虚拟硬盘\ndd if=/dev/zero of=~/test.img bs=1M count=20\n#在虚拟设备上创建文件系统\nmkfs.ext4 -q ~/test.img\ne2label new.img rootfs\n#挂载虚拟镜像到本地进行使用\nsudo mount -t ext4 ~/test.img ~/test\n```\n为测试文件io权限等, 可以对文件系统添加quota支持\n\n```bash\n# 对虚拟映像添加quota支持\nsudo mount -o rw,usrjquota=aquota.user,jqfmt=vfsv0 ~/test.img ~/test\nsudo quotacheck -cugv ~/test\n# 添加用户\nsudo useradd quota1 -d ~/test/quota1\n# 对用户添加quota限制\nsudo edquota -u quota1\n# 启用quota\nquotaon ~/test\n```\n\n## 1.2. File io测试\n挂载到本地目录test后, 可以对其进行文件io测试.\n以创建目录为例\n\n```bash\n#可以先将test目录填满\ndd if=/dev/zero of=largefile count=1024 bs=30M\n#也可以修改文件的owener为其他的\nsudo chown quota1 -R test\n```\n\n创建目录\n\n```java\n\t\tPath testDir = Paths.get(\"/home/newdisk1/liguang.zhang/test\", \"testdir\");\n\t\ttry {\n\t\t\tPath path = Files.createDirectories(testDir);\n\t\t\tSystem.out.println(path.toAbsolutePath() + \" create success\" );\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n            if(e instanceof FileSystemException) {\n            \tSystem.out.println(((FileSystemException) e).getReason());\n            }\n        }\n```\n对应没有权限时的trace\n```bash\njava.nio.file.AccessDeniedException: /home/newdisk1/liguang.zhang/test/testdir\n\tat sun.nio.fs.UnixException.translateToIOException(UnixException.java:84)\n\tat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)\n\tat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)\n\tat sun.nio.fs.UnixFileSystemProvider.createDirectory(UnixFileSystemProvider.java:384)\n\tat java.nio.file.Files.createDirectory(Files.java:674)\n\tat java.nio.file.Files.createAndCheckIsDirectory(Files.java:781)\n\tat java.nio.file.Files.createDirectories(Files.java:767)\n\tat Test.main(Test.java:39)\n```\n对应空间满的情况下的trace\n```bash\njava.nio.file.FileSystemException: /home/newdisk1/liguang.zhang/test/testdir: No space left on device\nNo space left on device\n\tat sun.nio.fs.UnixException.translateToIOException(UnixException.java:91)\n\tat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)\n\tat sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)\n\tat sun.nio.fs.UnixFileSystemProvider.createDirectory(UnixFileSystemProvider.java:384)\n\tat java.nio.file.Files.createDirectory(Files.java:674)\n\tat java.nio.file.Files.createAndCheckIsDirectory(Files.java:781)\n\tat java.nio.file.Files.createDirectories(Files.java:767)\n\tat Test.main(Test.java:39)\n```\n\n可以通过`e.getReason`方法取出对应的exception的报错原因.\n","tags":["Android","ext4","quota"],"categories":["文件系统"]},{"title":"Android权限管理","url":"/2016/04/02/其他调研/Android权限管理/","content":"\n# 1. Android权限管理\n\n>   原作者： xiaoguang.dong\n\n## 1.1. 基本概念\n\n### 1.1.1. AndroidManifest权限相关标签\n\n![permissionimage9](../images/permissionimage9.png)\n\n#### 1.1.1.1. permission 标签\n\n![permissionimage10](/images/permissionimage10.png)\n\n>   -   `permission`标签用于声明一个权限\n>   -   `android:name` 指定权限名称\n>   -   `android:protectionLevel`指定权限的保护级别\n>   -   `android:protectionLevel`指定权限的保护级别\n\n![permissionimage11](/images/permissionimage11.png)\n\n#### 1.1.1.2. uses-permission标签\n\n![permissionimage12](/images/permissionimage12.png)\n\n-   `<uses-permission>`用于申请特定权限\n-   `android:name`指定申请的权限名称\n-   `android:maxSdkVersion`用于指定可被授权的最高的`API level`\n\n>在4.4平台(API level 19)之前，使用某个接口依赖于权限A；但是在4.4平台上A权限已经被废弃或者该接口已经不依赖于A权限，那么可以做如下配置：`<uses-permission android:name=“A” android:maxSdkVersion=“18”/>`那么在4.4平台之后，系统将不会授予应用A权限\n\n#### 1.1.1.3. permission-group标签\n\n![permissionimage13](/images/permissionimage13.png)\n\n-   `<permission-group>`用于标记权限的逻辑分组。\n-   `android:name`用于指定权限组的名称。\n-   `android:label`用于指定权限组的标签。\n-   `android:descriptiopn`用于指定权限组的描述信息。\n-   `android:icon`用于指定权限组的图标。\n\n>   如果权限有`Permission-group`属性，用户在`Setting`权限界面看到的就是permission-`group`的`label`和`description`，否则使用`permission`本身的`label`和`description`。\n\n![permissionimage14](/images/permissionimage14.png)\n\n#### 1.1.1.4. permission-tree标签\n\n```xml\n<permission-tree android:icon=\"drawable resource\"\n                 android:label=\"string resource\" ]\n                 android:name=\"string\" />\n```\n\n>   注意这个元素自身不声明一个权限，只是一个名字空间，更多的权限可以被放置在它里面。\n\n-   `<permission-tree>`用于定义一组权限的命名空间。作用是可以使程序在运行时动态声明权限。\n-   `android:name`用于指定权限树根节点的名称。\n-   `android:label` 组的用户可读名称, 标签可以直接设置为一个原始字符串， 使它可以像用户界面中的其它字符串那样被本地化。\n\n>   如果某个应用使用了`<permission-tree>`标签，可以通过调用`PackageManager.addPermission()`方法来动态声明新权限。假如根节点的名称是`com.sprd.core`，则可以声明如下权限： `com.sprd.core.CONTACTS `       `com.sprd.core.MMS`...\n\n### 1.1.2. 权限控制\n\n#### 1.1.2.1. 四大组件权限检查\n\n![permissionimage16](/images/permissionimage16.png)\n\n-   `android:permission`适用于`activity`/`service`/`provider`/`receiver`标签。\n\n>   以`activity`为例，假如服务端`activity`配置了`android:permission`属性，客户端在调用 `startActivity()` 或` startActivityForResult() `启动服务端`activity`时，如果没有被授予指定权限，其 `Intent` 将不会传递给服务端`Activity`。如果未设置该属性，则对 `Activity` 应用 `<application>` 元素的 `permission` 属性设置的权限。 如果这两个属性均未设置，则 `Activity` 不受权限保护。\n\n#### 1.1.2.2. shareUserId 属性\n\n![permissionimage17](/images/permissionimage17.png)\n\n![permissionimage18](/images/permissionimage18.png)\n\n-   `android:SharedUserId`指定与其它应用共享一个`UID`，只有两个使用相同证书签名（并且请求相同的 `sharedUserId`）的应用才被分配同一`UID`。通过共享`UID`，不同的`APK`之间可以实现数据共享。\n\n>   `PackageManager`初始化时默认提供`6`个系统级`sharedUserId`，均使用`platform`证书验证。\n\n```xml\nandroid.uid.system\nandroid.uid.phone\nandroid.uid.log\nandroid.uid.shell\nandroid.uid.nfc\nandroid.uid.bluetooth\n```\n\n#### 1.1.2.3. 权限级别/ProtectionLevel\n\n##### 1.1.2.3.1. normal\n\n低风险权限，只要申请了就可以使用（在AndroidManifest.xml中添加uses-permission标签），安装时不需要用户确认\n\n##### 1.1.2.3.2. Dangerous\n\n高风险权限，需要用户的确认才可被授权\n\n##### 1.1.2.3.3. Signature\n\n当申请权限的APK与声明此权限的APK的使用的签名证书相同时，才能被授权\n\n##### 1.1.2.3.4. SignatureOrSystem\n\n1.  当申请权限的APK与声明此权限的APK的使用的签名证书相同时，才能被授权。\n2.  申请权限的应用为系统应用\n\n#### 1.1.2.4. Signature vs SignatureOrSystem\n\n-   针对`ProtectionLevel`中`signatureOrSystem`的应用，有如下应用场景：如果有多个不同的厂商同时在`system/app`下预制了多个不同的`APK`，每个`APK`签名使用的证书是不同的。但是这些`APK`之间彼此还希望访问对方的一些数据。此时就可以使用`signatureOrSystem`权限来保护应用数据。\n-   与之而来的问题在于，所有`/system/app`下的应用都可以访问用`signatureOrSystem`访问的数据，虽然可以用`getCallingUid`,`getCallingPackage`来确认访问者的身份。但是这里是存在隐患的。\n-   添加`priva-app`目录解决了这个问题。在`4.4`以后`SignatureOrSystem`级别的权限只有具有相同签名，或者预制在`priv-app`下的应用才被授权。\n-   默认情况下预制在`priv-app`下的应用必须`Google`原生应用或是`OEM`厂商确保安全的第三方应用。\n\n#### 1.1.2.5. 定义权限作用？怎样通过权限实现应用数据和资源的保护？\n\n-   程序的基础是`代码`和`数据`，所以定义权限的两个目的就是控制`代码执行流程`和`保护数据/文件`。\n-   针对`AndroidManifest`中定义的各种权限，其权限的授权状态都会存储在`PackageManagerService`中，`系统/APP`可以通过`PackageManager`相关接口来检查调用端进程`UID`是否具有特定权限，进而决定是否允许其进一步执行代码或者访问数据/文件。可以将`PackageManager`看做一个权限管理的中转站。\n\n![permissionimage19](/images/permissionimage19.png)\n\n#### 1.1.2.6. Native层的权限控制\n\nNative层的权限控制建立在Linux已有的uid/gid/gids基础上的。\n\n-   `UID`: `Android` 每安装一个应用程序，就会为它分配一个 `uid` 。其中普通 `Android` 应用程序的 `uid` 是从 `10000` 开始分配 （`Process.FIRST_APPLICATION_UID `）， `10000` 以下是系统应用预留的 `uid` \n-   `GID`: 对于普通应用程序来说， `gid` 等于 `uid` 。\n-   由于每个应用程序的 `uid` 和 `gid` 都不相同， 因此不管是 `native` 层还是 `java` 层都能够达到保护私有数据的作用。\n-   `GIDS`: 在 `Apk`安装过程中生成，与申请的具体权限相关。 如果APK某个申请的`permission` 被 `granted` ，而且这个权限在`/system/etc/permisions/*xml`中有对应的 `gid`， 那么 这个 Apk对应的进程`gids`中将 包含`xml`中配置的`gid`。\n\n`Eg`: 在`Android5.1`平台上，应用申请了如下权限：`<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />  `，同时在`frameworks\\base\\data\\etc\\Platform.xml`中由如下配置：\n\n```xml\n<permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" >  \n    <group gid=\"sdcard_rw\" />  \n</permission> \n```\n\n对于申请`WRITE_EXTERNAL_STORAGE`特权的应用，进程的`gids`就包含了`sdcard_rw`，就可以对`sd`卡中的文件进行操作。\n\n## 1.2. 运行时权限\n\n-   `normal`/`signature`/`signatureOrSystem`会在`App`安装时判断是否授权，可以看做是安装时权限。\n-   从`AndroidM`开始，`Google`提出了运行时权限(`runtime permission`)的概念。针对`protectionLevle`为`dangerous`的权限，在安装时默认不授权，而是在运行时由用户动态授权。\n-   对于运行时权限，要求App在代码中做一定的适配，在运行时动态向用户请求相关权限。\n-   在多用户模式下，所有用户共享安装时权限，独占运行时权限。\n\n`Android`定义的Runtime权限一览共9组25个：\n\n![permissionimage20](/images/permissionimage20.png)\n\n![permissionimage21](/images/permissionimage21.png)\n\n![permissionimage22](/images/permissionimage22.png)\n\n![permissionimage23](/images/permissionimage23.png)\n\n![permissionimage24](/images/permissionimage24.png)\n\n![permissionimage25](/images/permissionimage25.png)\n### 1.2.1. 注意事项\n\n>   1.  如果应用开发时使用的`targetSDK`低于`23`，在安装到`M`和以上平台时，考虑到不支持动态权限相关的接口。系统会默认授予所有权限。\n>   2.  同一组的任何一个权限被授权了，其他权限也自动被授权。不需要重复申请。\n>   3.  只申请需要的权限，需要的时候再申请权限；每次权限申请，都会弹出权限申请窗口，打断用户的操作。建议只申请你需要的权限。\n>   4.  `Setting`中动态关闭权限会导致进程被`Kill`。\n>   5.  权限请求需要弹出`Dialog`，因此请求代码要添加到`Activity`或`Fragment`中\n>   6.  尽可能避免在`Service`中申请权限。如果确实需要，要做一个`work around`。比如弹出一个`Notification`，提醒用户缺少相关权限。当用户点击`Notification`在弹出权限申请框，继续权限申请流程。\n\n## 1.3. 默认授权机制\n- 为了确保`Android`原生应用，或者`GMS`包中的应用在开机后具有必需的权限。比如`CameraApp`默认授予`Camera Group`相关权限，`Contacts`默认授予`Contacts Group`相关权限….\n- `PackageManager`默认在首次开机/恢复出厂设置后，对一部分系统应用默认授予一些必需的权限。\n\n### 1.3.1. 首次开机时默认授权的应用\n\n应用使用`requestPermissions`接口申请运行时权限，首次开机时，满足下列条件时，会对相应的权限进行授予：\n\n-   `UID` < `10000`的应用\n-   同时满足如下条件的应用：\n    1.  预制在`/system/priv-app`下。\n    2.  `Application`标签中配置了`android:persistence=“true”`。\n    3.  使用`Platform`证书签名。\n-   通过`Intent`匹配查询出的默认应用，为其授予合适分组的权限。\n    -   以`Music`为例，代码中会自动匹配如下`Intent`对应的`component`：\n\n```java\nIntent musicIntent = new Intent(Intent.ACTION_VIEW);\nmusicIntent.addCategory(Intent.CATEGORY_DEFAULT);\nmusicIntent.setDataAndType(Uri.fromFile(new File(\"foo.mp3\")), AUDIO_MIME_TYPE);\n```\n\n>   默认情况下，`6.0`和`7.0`下匹配结果是不一致的。如果有多个同类型的应用，在`6.0`上会根据返回结果取第一个元素进行授权；在`7.0`上则会进行一系列比较，选出*优先级最高*的那个进行授权。*如果前两个元素的优先级相同，则不会对任何一个匹配到的元素授权*。\n\n-   对于首次开机授权的应用，有一部分权限是***系统固定***的，用户无法修改。在`Setting->APP`中也看不到对应的权限状态。\n-   修改**默认授权**的逻辑会导致`GTS CASE`失败。\n\n### 1.3.2. 查看Package当前的权限状态\n\n通过`adb shell dumpsys package `可以查看某个Package当前的权限状态：\n\n![permissionimage26](/images/permissionimage26.png)\n","tags":["Android","Runtime Permission"],"categories":["Android"]},{"title":"opensbi框架","url":"/2013/07/01/riscv/opensbi框架/","content":"\n# opensbi底层初始化\n\n先进入`_start`函数, 将a0-a2 保存到 s0-s2, 启动 fw_boot_hart, a0-a2 是qemu传递给opensbi的参数.\n在riscv模式中会将riscv的core称为hart(硬件线程)\n\n代码重定位, 判断 `_load_start` 与 `_link_start` 是否一致, 如不一致, 则需要重定位\n清除寄存器值, 清除除 a0-a2 外的所有寄存器的值 \n清空bss, `_bss_start` 到 `_bss_end` 范围设置为0\n设置临时的 trap_hander 为 `_start_hang` \n设置 sp, 紧挨 bss 段, 大小为 0x1000 * 2, 向上增长, 所以 sp top 为 bss_end + 0x2000位置 \n读取设备树中的信息:\n`fw_platform_init` (opensbi/platform/generic/platform.c)\na1是设备树地址, 从设备树中解析qemu中设定相关的信息\n\n```bash\nqemu-system-riscv64 -m 2G -nographic -machine virt -bios /keystone/build/bootrom.build/bootrom.bin -kernel /keystone/build/sm.build/platform/generic/firmware/fw_payload.elf\n```\n\n**fdt重定位**\n\n需要把设备树重定位，从而让 uboot 也知道\n初始化scratch space, 紧挨着stack, 大小为0x1000\n\n- 存储 `_fw_start` 和 `_fw_end` 到 scratch space \n- 存储 next arg1 (FW_JUMP_FDT_ADDR 0x82200000)\n- 存储 payload_bin, FW_PAYLOAD_PATH 被填充到 opensbi 预留的指令地址处, 0x80200000, 此处把 kernel 的 bin 填充到这个地方了 \n- 存储 fw_next_mode, S 模式\n- warm_boot address\n- platform address\n- `_hartid_to_scratch` `_trap_exit` fw_options等\n\n```shell\n      \"-DFW_TEXT_START=0x80000000\",\n      \"-DFW_JUMP_ADDR=0x80200000\",\n      \"-DFW_JUMP_FDT_ADDR=0x82200000\",\n      \"-DFW_PAYLOAD_PATH=\\\"/keystone/build/linux.build/arch/riscv/boot/Image\\\"\",\n      \"-DFW_PAYLOAD_OFFSET=0x200000\",\n      \"-DFW_PAYLOAD_FDT_ADDR=0x82200000\",\n```\n\nstart_warm 除 a0-a2 外的所有寄存器重置, 禁用中断, 读取 hartid(CSR_MHARTID), 根据 hartid 查找对应的 scratch space, 设置对应的 sp, 设置_trap_handler 为最终的陷阱入口函数, 支持的 hardid count 数是通过 qemu-system-riscv64 命令行传入的, 定制到 fdt 中去的 `platform.hart_count = hart_count;` \n\n## 进入c函数\n\nsbi_init -> init_coldboot (参数为 scratch, 即前面 scratch space 空间填充的数据, 对应的结构体为 `struct sbi_scratch`), nextmode 固定为 S \ninit_coldboot  做的事情很多, 下面进行详细拆解\n\n### sbi_scratch_init\n\n根据 hardid 填充 hartid_to_scratch_table \n\n### **sbi_domain_init**\n\n初始化动态加载的镜像的模块, 应该是当前域 root_domain, root_memregs, 设定内存地址范围, order(位宽), base(基址), 填充 root domain, root domain 的 hardid 同当前唤起的 coldboot 的 hardid, 最后将 root domain 填充到 `domidx_to_domain_table`, index 为 hardid \n\n### sbi_scratch_alloc_offset\n\n为 scratch space 分配空间, 内容清0 \n\n### sbi_hsm_init\n\n为 `struct sbi_hsm_data` 分配空间, 并初始化 SBI_HART_STARTING (当前 hartid), 其他的 hartid 为 SBI_HART_STOPPED  \n\n### sbi_platform_early_init\n\n平台早期初始化, 调用 plat->early_init, plat 为 scratch 里的 platform_addr 指向(sbi_platform 结构体, 该结构体由前面的 `fw_platform_init` 过程根据 fdt 设备树内容填充, 来自于 qemu), 而 platform_ops_addr 不是填充的, 而是初始的 Generic 设备的 platform_ops. 可以插桩或自定义实现平台相关的初始化代码. \n\n```c\nconst struct sbi_platform_operations platform_ops = {\n\t.early_init\t\t= generic_early_init,\n\t.final_init\t\t= generic_final_init,\n\t.early_exit\t\t= generic_early_exit,\n\t.final_exit\t\t= generic_final_exit,\n\t.domains_init\t\t= generic_domains_init,\n\t.console_putc\t\t= fdt_serial_putc,\n\t.console_getc\t\t= fdt_serial_getc,\n\t.console_init\t\t= fdt_serial_init,\n\t.irqchip_init\t\t= fdt_irqchip_init,\n\t.irqchip_exit\t\t= fdt_irqchip_exit,\n\t.ipi_send\t\t= fdt_ipi_send,\n\t.ipi_clear\t\t= fdt_ipi_clear,\n\t.ipi_init\t\t= fdt_ipi_init,\n\t.ipi_exit\t\t= fdt_ipi_exit,\n\t.get_tlbr_flush_limit\t= generic_tlbr_flush_limit,\n\t.timer_value\t\t= fdt_timer_value,\n\t.timer_event_stop\t= fdt_timer_event_stop,\n\t.timer_event_start\t= fdt_timer_event_start,\n\t.timer_init\t\t= fdt_timer_init,\n\t.timer_exit\t\t= fdt_timer_exit,\n\t.system_reset_check\t= generic_system_reset_check,\n\t.system_reset\t\t= generic_system_reset,\n};\n```\n\n### sbi_hart_init\n\n该核心线程协处理器相关初始化, 处理器支持的特性保存在 hart_features 结构体中, 在 scratch space 中为该结构体分配内存并初始化为0.  \n接下来需要判定处理器支持哪些 feature. \n\n- pmp 内存访问是否支持 \n- 是否支持 SCOUNTEREN\n- 是否支持 MCOUNTEREN\n- 是否支持 CSR_TIME\n\n如 misa_extension 含 'H', With H-extension so, MTVAL2 and MTINST CSRs available \n\n> 这个地方怎么判断处理器支持哪些 feature 的, 是通过强制写一些协处理器, 并将 mtvec 临时变为 `__sbi_expected_trap` 或 `__sbi_expected_trap_hext` (根据 H extension 的状态), 该异常入口会将 `mepc`, `mcause` 等寄存器状态保存到 sbi_trap_info 结构体的临时变量中(传递参数为 a3), 如果发生了异常, 对应的 cause 非0, 这种情况就表明不支持该 feature. 反之, 则表明支持这个 feature. \n\n#### mstatus_init\n\nmstatus 初始化\n\n- D|F enable FPU\n- V ENABLE VECTOR 向量扩展, 如支持, `对应位置1 (23|24)`, (如果对应位是0, 执行向量相关的指令或访问 v 寄存器会报异常)  \n  - Attempts to execute any vector instruction, or to access the vector CSRs, raise an illegal-instruction exception when the VS field is set to off.  \n- 启用性能计数器\n- 禁用中断\n- 禁用S模式mmu \n\n#### delegate_traps\n\nSend M-mode interrupts and most exceptions to S-mode\n设置 `CSR_MIDELEG` 和 `CSR_MEDELEG` 寄存器, 在S模式的陷阱中处理M模式的中断和大部分异常\n\n### sbi_console_init\n\n这之后, 就能从串口打印log, 还是调用的平台的插桩函数 plat->console_init\n\n### sbi_platform_irqchip_init\n\nirq中断初始化, Initialize the platform interrupt controller for current HART, 平台的插桩函数 plat->irqchip_init\n\n### sbi_ipi_init\n\n核间通信初始化\n\n- 为核间通信交换数据在 scratch space 中分配空间, 并初始化为0 \n- ipi 通信可能需要多种唤醒的事件, 如可约定多种核间通信的事件, 保存在 ipi_ops_array 数组中, `struct sbi_ipi_event_ops *ipi_ops_array[SBI_IPI_EVENT_MAX]`, 通过 `sbi_ipi_event_create` 创建一个事件, 可以创建多个事件, 最终都保存到 ipi_ops_array 数组中, 这里注册了 ipi_smode_ops 和 ipi_halt_ops 事件, 分别处理其他核发来的让该核处理 S 模式中断的事件(mip ssip pending 置1)和让该核暂停的事件 \n- 平台插桩代码, plat->ipi_init, 平台按需实现\n- 启用 M 模式中断 \n\n### sbi_tlb_init\n\nmmu的tlb表的初始化\n注册 tlb_ops 事件, 在 scratch space 中分配空间存放 `IPI_TLB_SYNC IPI_TLB_FIFO IPI_TLB_FIFO_MEM` 数据, 初始化 sbi_fifo \n\n```c\nstatic struct sbi_ipi_event_ops tlb_ops = {\n\t.name = \"IPI_TLB\",\n\t.update = sbi_tlb_update,\n\t.sync = sbi_tlb_sync,\n\t.process = sbi_tlb_process,\n};\n```\n\n### sbi_timer_init\n\ntimer 初始化, 在 scratch space 中分配空间存放 time_delta \n平台插桩函数 plat->timer_init, 平台按需实现\n如支持 timer, 注册 get_ticks 函数安装到 get_time_val, 否则由平台实现 plat->timer_value \n\n### sbi_ecall_init\n\necall 初始化, riscv 的系统调用都是 ecall, 如 linux 的 posix 接口在 riscv 上都是用 ecall 实现的, 由 U/S 模式发送 ecall 路由到 M 模式 \n调用 sbi_ecall_register_extension 注册相应的中断处理函数, 根据 extid_start extid_end 找到对应的 handler. 这个地方用到的频率非常高, 比较重要  \n\n### sbi_domain_finalize\n\n当前域(root 域)完成初始化\n\n- plat->domains_init (Initialize and populate domains for the platform) \n- 遍历 domidx_to_domain_table, 这个时候还只有 root domain, 所以只能遍历一次, 由于是coldboot, 最后只设置了scratch->next_addr, next_mode , next_arg1, 用于启动下一个镜像(这里应该是kernel)\n\n### sbi_hart_pmp_configure\n\n设置下一个镜像的pmp, 内存权限\n\n这里用到了前面设置过的 root_memregs\n\n```c\n\troot_memregs[ROOT_FW_REGION].order = log2roundup(scratch->fw_size);\n\troot_memregs[ROOT_FW_REGION].base = scratch->fw_start &\n\t\t\t\t~((1UL << root_memregs[0].order) - 1UL);\n\troot_memregs[ROOT_FW_REGION].flags = 0;\n\n\t/* Root domain allow everything memory region */\n\troot_memregs[ROOT_ALL_REGION].order = __riscv_xlen;\n\troot_memregs[ROOT_ALL_REGION].base = 0;\n\troot_memregs[ROOT_ALL_REGION].flags = (SBI_DOMAIN_MEMREGION_READABLE |\n\t\t\t\t\t\tSBI_DOMAIN_MEMREGION_WRITEABLE |\n\t\t\t\t\t\tSBI_DOMAIN_MEMREGION_EXECUTABLE);\n\n\t/* Root domain memory region end */\n\troot_memregs[ROOT_END_REGION].order = 0;\n```\n\n 其中 ROOT_ALL_REGION 就是为下一级镜像准备的, 这里flags是 rwx, order是64, 只占一个pmp entry, 权限为rwx\n\n```c\npmp_set(pmp_idx++, pmp_flags, reg->base, reg->order);\n```\n\n### sbi_platform_final_init\n\n插桩函数, plat->final_init , 平台按需实现\n\nPlatform final initialization should be last so that it sees correct domain assignment and PMP configuration.\n\ndomain设置完了, pmp也设置了, 这个地方平台的实现能看到这些了\n\n### sbi_boot_print_hart\n\n平台启动信息的打印\n\n```c\nBoot HART ID              : 0\nBoot HART Domain          : root\nBoot HART ISA             : rv64imafdcsu\nBoot HART Features        : scounteren,mcounteren,time\nBoot HART PMP Count       : 16\nBoot HART PMP Granularity : 4\nBoot HART PMP Address Bits: 54\nBoot HART MHPM Count      : 0\nBoot HART MHPM Count      : 0\nBoot HART MIDELEG         : 0x0000000000000222\nBoot HART MEDELEG         : 0x000000000000b109\n```\n\n### wake_coldboot_harts\n\n当前核启动完成, coldboot 完成, 告诉其他核 coldboot 完成了 \n\n### sbi_hsm_prepare_next_jump\n\n核状态 由`SBI_HART_STARTING` -> `SBI_HART_STARTED` \n\n### sbi_hart_switch_mode\n\n启动下一级镜像\n\n```c\n\tsbi_hart_switch_mode(hartid, scratch->next_arg1, scratch->next_addr,\n\t\t\t     scratch->next_mode, FALSE);\n```\n\n根据模式以及模式的支持情况( misa_extension 是否支持 S/U 模式), 选择启动到对应的模式, 如不支持则把核 hang 住 \nmstatus mpp 位置为对应的模式 mpie 置0 \nmepc 设置为 next_addr, ( 这个地方已经设置为了 kernel 的入口地址 0x82200000) \n如下一级为 S 模式, 则 stvec 设置为 next_addr, sscratch 置0 , sie 置0, sip 置0, satp 置0. \n传递next_args1 (a1), 0x82200000\nmret 跳转到 mepc 的位置, 正式启动到下一级镜像, 这里是 kernel \nprovisioning of roots [051](bookxnotepro://opennote/?nb={af27f419-aaf4-494d-b2a4-9f05f129b37d}&book=3f4f03b2bf8e973c33f1d9a004beb8bb&page=50&x=460&y=96&id=7)\n\n## opensbi 介绍\n\n### 背景\n\nRISC-V指令集的SBI标准规定了类Unix平台下，操作系统运行环境的规范。这个规范拥有多种实现，OpenSBI是它的一种实现.\n这个运行环境不仅将引导启动RISC-V下的操作系统， 还将常驻后台，为操作系统提供一系列二进制接口，以便其获取和操作硬件信息。 RISC-V给出了此类环境和二进制接口的规范，称为“操作系统二进制接口”，即“SBI”。\nSBI是在M模式下运行的特定于平台的固件，它将管理S、U等特权上的程序或通用的操作系统。\n\n#### RISCV 模式\n- 机器模式（Machine Mode）\n\t-  处理器内核被复位后，默认处于 Machine Mode\n\t- 在 Machine Mode 下，程序能够访问所有的 CSR 寄存器。\n\t- 在 Machine Mode 下，程序能够访问所有的物理地址区域\n- 监督者模式（Supervisor mode） \n- 用户模式（User Mode） \n\n-   Machine-Level ISA\n    -   machine mode 读写的寄存器，如 mhartid、mstatus、mtvec、mcause \n    -   machine 特权指令，如 ecall(所有模式)、mret、sret、wfi(所有模式、U 模式可选) \n    -   复位、NMI 发生后 hart 状态 \n    -   PMA 物理内存属性，原子、order、一致性 \n    -   PMP 物理内存保护机制和寄存器 \n-   Supervisor-Level ISA\n    -   Supervisor mode 读写的寄存器，如 sstaus、stvec、scause、satp \n    -   Supervisor 特权指令，如 ecal、sret、sfence.vma \n    -   Page-Based 32/39/48/57-bit Virtual-Memory Systems \n-   Hypervisor Extension\n    -   hypervisor 虚拟化读写的寄存器，如 hstatus、vstvec、vepc \n    -   hypervisor 特权指令，load/store、fence \n\n![[../Excalidraw/opensbi框架 2022-09-09 14.33.53.excalidraw]]\n\n- 为操作系统层(S-mode) 提供 sbi 接口的高特权级别的软件被称为sbi 实现或 特权执行环境(SEE).  sbi 实现或SEE工作在M层, 带H扩展的 Host S层 os 也可以实现相关的sbi 接口用来与Guest os 交互通信.\n\n![](../images/Pasted%20image%2020220909154542.png)\n![](../images/Pasted%20image%2020220909154558.png)\n### SBI 的作用\n- 可以为多个 os 提供公共 driver \n- 可以避免为每个不同 os 适配平台相关的功能, 将功能做到 sbi 层, 其他的各种 os 只需要 ecall 调用, 访问 sbi 层来实现平台的功能 \n- 在 S 层工作的 OS 可以通过 ecall sbi 来访问或修改受限在 M 层的硬件资源 \n- 多个 OS 之间的通信媒介,  限制不同 OS 的可以访问的硬件资源 (如 PMP 限制 os 可以使用哪些内存地址) \n\n- AEE: application execution environment\n- ABI: application binary interface\n -  The ABI includes the supported user-level ISA plus a set of ABI calls to interact with the AEE. The ABI hides details of the AEE from the application to allow greater flexibility in implementing the AEE.\n- SEE: supervisor execution environment\n- SBI: supervisor binary interface\n- HEE: hypervisor execution environment\n\t-  isolate the hypervisor from details of the hardware platform.\n- HBI: hypervisor binary interface\n\n\n![](../images/Pasted%20image%2020220909151943.png)\n\n\n所有硬件必须提供M-mode，因为它拥有访问整个机器的能力，最简单的RISC-V实现只有M-mode，但是不能抑制恶意APP。  \n未扩展前，不支持 hypervisor 模式   \n![](https://img2022.cnblogs.com/blog/1148192/202208/1148192-20220815160759991-799793992.png)\nhypervisor扩展模式，V标识当前hart是否处于虚拟化模式  \n![](https://img2022.cnblogs.com/blog/1148192/202208/1148192-20220815161001163-1222444423.png)\n![](../images/Pasted%20image%2020220909143229.png)\n![](../images/Pasted%20image%2020220909143242.png)\n\n\n#### SBI EXTENSION \n- 1. Base Extension (EID `#0x10`)\n- 2. Legacy Extensions (EIDs `#0x00` - `#0x0F`) \n- 3. Timer Extension (EID `#0x54494D45` \"TIME\") \n- 4. IPI Extension (EID `#0x735049` \"sPI: s-mode IPI\") \n- 5. RFENCE Extension (EID `#0x52464E43` \"RFNC\") \n- 6. Hart State Management Extension (EID `#0x48534D` \"HSM\") \n- 7. System Reset Extension (EID `#0x53525354` \"SRST\") \n- 8. Performance Monitoring Unit Extension (EID `#0x504D55` \"PMU\") \n- 9. Experimental SBI Extension Space (EIDs `#0x08000000` - `#0x08FFFFFF`) \n- 10. Vendor-Specific SBI Extension Space (EIDs `#0x09000000` - `#0x09FFFFFF`)\n- 11. Firmware Specific SBI Extension Space (EIDs `#0x0A000000` - `#0x0AFFFFFF`)\n\n#### 引导过程\n\nRISC-V芯片的启动流程演变历程:\n![](../images/Pasted%20image%2020220909162903.png)\n1.  **Zeroth Stage Boot Loader(ZSBL)**，安装在板载的ROM中，处于M-mode\n2.  **First Stage Boot Loader(FSBL)**，brings up PPLs and DDR, 处于M-mode\n3.  **Berkeley Boot Loader(BBL)**，adds emulation for soft instructions，处于M-mode\n4.  **User Payload**，包含软件，如Linux，处于S-mode或U-mode\n\n##### ZSBL（第0阶段Bootloader）\n\n处于M-mode的ZSBL保存在maskROM 中地址为0x1_0000的位置，它负责从GPT中加载更为复杂的FSBL（寻找uuid的GPT分区）。通过先加载GPT的头文件，然后一块一块（块大小为512bytes）的顺序地扫描GPT。加载过程结束后，FSBL被加载进地址为0x0800_0000的L2 LIM缓存中，随后，将执行FSBL阶段。\n\n#### FSBL（第1阶段Bootloader） \n处于M-mode的FSBL从L2 LIM地址为0x0800_0000的缓存上执行，它负责为在DDR上运行系统做准备，可大概分为如下的这些任务：\n\n- 配置芯片上的PLL 核心频率\n- 配置DDR PLL，PHY和DDR控制器\n- 外部PHY，重置\n- 从编号为uuid的GTP分区下载BBL\n- 扫描OTP获取的芯片序列号\n- 将DTB（硬件设备树）复制到DDR，填写FSBL版本，内存大小和MAC地址\n- 跳转到DDR上地址为0x8000_0000的位置, 启动BBL 或 opensbi\n\n#### BBL（第2阶段的Bootloader）\n处于M-mode的BBL从DDR上地址为0x8000_0000的位置执行。它负责为如SBI（Supervisor Binary Interface）等RISC-V需要的，但没有被芯片本身实现的指令。在进行写操作的时候，BBL通常包含一个嵌入的Linux内核负载，当SBI被初始化后，它将跳转的Linux内核。\n\n\nU-Boot属于一种bootloader，简单来说，其作用就是从flash中读出内核，随后加载在内存中，最终初始化并启动操作系统内核。\n具体来说，可以分为下述几个方面：\n1)U-Boot主要作用是用来启动[操作系统内核](https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)。体现在uboot最后一句代码就是启动内核。\n2)U-Boot还要负责部署操作系统内核。体现在uboot最后的传参。\n3)U-Boot中还有操作Flash等板子上硬件的驱动。例如串口要打印，ping网络，擦除、烧写flash等。提供烧写功能等\n4)U-Boot还得提供一个命令行界面供人来操作。如果kernel 起不来, uboot命令行可以提供操作界面, 让用户来手动加载kernel\n\n\n\n\nOpenSBI的初始化流程如下：\n\n（1）底层初始化：\n1.  判断 hart(Hardware Thread) id \n2.  代码重定位（判断 `_load_start` 与 `_start` 函数是否一致） \n3.  清除除保存设备树地址的寄存器的值\n4.  清除bss段\n5.  设置栈指针（预留栈空间）\n6.  读取设备树中的设备信息\n7.  设备树重定位，为U-Boot提供信息\n8.  至此，底层初始化结束，执行sbi_init，进行正式的初始化程序\n\n（2）设备初始化：\n 首先判断是通过 S-mode 还是 M-mode 启动 \n1. sbi_domain_init 初始化动态加载的镜像的模块 \n2. sbi_platform_early_init 平台的早期初始化\n3. sbi_console_init 控制台初始化，从这里开始，就可以使用串口输出了。\n4. sbi_platform_irqchip_init        irq中断初始化\n5. sbi_ipi_init    核间中断初始化\n6. sbi_tlb_init    mmu的tlb表的初始化\n7. sbi_timer_init    timer初始化\n8. sbi_hsm_prepare_next_jump   准备下一级的boot\n（3）二级boot跳转，如加载U-Boot或者Linux内核\n\n\n### ARM架构中的Hypervisor与OpenSBI的对比\n在 ARM 架构中，Hypervisor 层承担了虚拟化的作用，承担了如内存管理、设备模拟、设备分配、异常处理、指令捕获、虚拟异常管理、中断控制器管理、调度、上下文切换、内存转换、多个虚拟地址空间管理等非常多的功能。 \n相比之下，SBI在RISC-V架构中充当了BIOS和在操作系统运行时为上层提供底层抽象的作用，功能较少。不过SBI也在不断发展中，可能在将来SBI会去承担虚拟化的功能。\n![](../images/Pasted%20image%2020220909163134.png)\n\n\n\n","tags":["opensbi 调研"],"categories":["RISCV"]},{"title":"opensbi 介绍","url":"/2013/06/30/riscv/opensbi 介绍/","content":"\n#  opensbi 介绍\n\n## 背景\n\nRISC-V指令集的SBI标准规定了类Unix平台下，操作系统运行环境的规范。这个规范拥有多种实现，OpenSBI是它的一种实现.\n这个运行环境不仅将引导启动RISC-V下的操作系统， 还将常驻后台，为操作系统提供一系列二进制接口，以便其获取和操作硬件信息。 RISC-V给出了此类环境和二进制接口的规范，称为“操作系统二进制接口”，即“SBI”。\nSBI是在M模式下运行的特定于平台的固件，它将管理S、U等特权上的程序或通用的操作系统。\n\n### RISCV 模式\n\n- Machine-Level ISA\n    - 处理器内核被复位后，默认处于 Machine Mode\n    - machine mode读写的寄存器，如mhartid、mstatus、mtvec、mcause\n    - machine特权指令，如ecall(所有模式)、mret、sret、wfi(所有模式、U模式可选)\n    - 复位、NMI发生后hart状态\n    - PMA物理内存属性，原子、order、一致性\n    - PMP物理内存保护机制和寄存器\n\n- Supervisor-Level ISA\n    -   Supervisor mode读写的寄存器，如sstaus、stvec、scause、satp\n    -   Supervisor特权指令，如ecal、sret、sfence.vma\n    -   Page-Based 32/39/48/57-bit Virtual-Memory Systems\n- User-Level  ISA\n- Hypervisor Extension (扩展 H-extension)\n    -   hypervisor 虚拟化读写的寄存器，如hstatus、vstvec、vepc\n    -   hypervisor特权指令，load/store、fence\n\n### RISV 特权模式演进\n\n- AEE: application execution environment\n- ABI: application binary interface\n - The ABI includes the supported user-level ISA plus a set of ABI calls to interact with the AEE. The ABI hides details of the AEE from the application to allow greater flexibility in implementing the AEE.\n- SEE: supervisor execution environment\n- SBI: supervisor binary interface\n- HEE: hypervisor execution environment\n  -  isolate the hypervisor from details of the hardware platform.\n- HBI: hypervisor binary interface\n\n\n![](attachments/20220909164612.png)\n\n所有硬件必须提供M-mode，因为它拥有访问整个机器的能力，最简单的RISC-V实现只有M-mode，但是不能抑制恶意APP。  \n\n- 未扩展前，不支持hypervisor模式  \n  ![](attachments/1148192-20220815160759991-799793992.png)\n- hypervisor扩展模式，V标识当前hart是否处于虚拟化模式  \n  ![](attachments/1148192-20220815161001163-1222444423.png)\n\n\n![](attachments/20220909170244.svg)\n\n- 为操作系统层(S-mode) 提供 `SBI` 接口的高特权级别的软件被称为`SBI` 实现或 特权执行环境(`SEE`).  \n- SBI 实现或SEE工作在M层, 带H扩展的 Host S层 os 也可以实现相关的sbi 接口用来与Guest os 交互通信.\n\n![](attachments/20220909164614.png)\n\n​                                         1) 不带H 扩展的 RISCV 系统\n\n![](attachments/20220909164615.png)\n\n​\t\t\t\t\t\t\t       2) 带 H 扩展的 RISCV 系统\n\n#### MIPS 架构\n\n**Each Hart can host an application under the same or different guest OS**\n\nAllows efficient utilization of pipeline hardware and local cache\n\n**With RISC-V H-extension, each hart is a Virtual Machine**      (**`RV64GHC`**)\n\n![image-20220915113342870](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915113342870.png)\n\n##### MIPS UDI (User Defined Instructions)\n\n![image-20220915114512140](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915114512140.png)\n\n![image-20220915114428090](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915114428090.png)\n\n**MIPS (MIPS64r6) User Defined Instructions fills the gap**\n\n- Performance – Prefetch, Paired load/store\n- Coherency – Cache Maintenance\n- Multi-core, multi-cluster – Global Invalidates, Cache Maintenance\n- Diagnostic capabilities – Diagnostic Read/Write\n\n## SBI 的作用\n\n- 可以为多个os提供公共driver\n- 可以避免为每个不同os 适配平台相关的功能, 将功能做到sbi层, 其他的各种os 只需要ecall 调用, 访问sbi层来实现平台的功能\n- 在S层工作的OS 可以通过ecall sbi 来访问或修改受限在M层的硬件资源 (如只能m层访问的CSR)\n- 多个OS之间的通信媒介,  限制不同OS的可以访问的硬件资源 (如PMP限制os可以使用哪些内存地址)\n\n## SBI CALL EXTENSION\n\n- 1. Base Extension (EID `#0x10`)\n\n     ![image-20220909172228003](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172228003.png)\n\n     | Machine Implementation ID Register (mimpid) | 提供了处理器实现版本的唯一编码 |\n     | ------------------------------------------- | ------------------------------ |\n     | Machine Architecture ID Register (marchid)  | 处理器核架构编号               |\n     | Machine Vendor ID Register (mvendorid)      | 用于指示供应商 ID 的寄存器     |\n\n- 2. Legacy Extensions (EIDs `#0x00 - #0x0F`)\n\n     ![image-20220909172256304](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172256304.png)\n\n     ![image-20220909172309159](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172309159.png)\n\n- 3. Timer Extension (EID `#0x54494D45` \"TIME\")\n\n   ![image-20220909172416146](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172416146.png)\n\n- 4. IPI Extension (EID `#0x735049` \"sPI: s-mode IPI\")\n\n     ![image-20220909172449621](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172449621.png)\n\n- 5. RFENCE Extension (EID `#0x52464E43` \"RFNC\")\n\n     ![image-20220909172508242](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172508242.png)\n\n- 6. Hart State Management Extension (EID `#0x48534D` \"HSM\")\n\n     The Hart State Management (HSM) Extension introduces a set of hart states and a set of functions which allow the supervisor-mode software to request a hart state change.\n\n     ![image-20220909172529437](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172529437.png)\n\n     ![image-20220909172654319](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172654319.png)\n\n- 7. System Reset Extension (EID `#0x53525354` \"SRST\")\n\n     The System Reset Extension provides a function that allow the supervisor software to request system-level reboot or shutdown. \n\n     The term \"system\" refers to the world-view of supervisor software and the underlying SBI implementation could be machine mode firmware or hypervisor.\n\n     ![image-20220909172720658](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172720658.png)\n\n- 8. Performance Monitoring Unit Extension (EID `#0x504D55` \"PMU\")\n\n     ![image-20220909172749677](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220909172749677.png)\n\n- 9. Experimental SBI Extension Space (EIDs `#0x08000000` - `#0x08FFFFFF`)\n\n- 10. Vendor-Specific SBI Extension Space (EIDs `#0x09000000` - `#0x09FFFFFF`)\n\n- 11. Firmware Specific SBI Extension Space (EIDs `#0x0A000000` - `#0x0AFFFFFF`)\n\n  ![](attachments/20220909164616.png)\n\n### ecall 初始化过程及调用过程\n\n\n\n![opensbi_chart.drawio](attachments/opensbi_chart.drawio.svg)\n\nmtvec 寄存器用于配置m-mode 中断和异常处理程序的入口地址\n\nmscratch 寄存器用于 Machine Mode 下的程序临时保存某些数据\n\n![opensbi_trap.drawio](attachments/opensbi_trap.drawio.svg)\n\n## OPENSBI 集成模式\n\nOpenSBI提供了几种类型的参考固件, 都是平台相关的\n\n- FW_PAYLOAD: Firmware with the next booting stage as a payload\n- FW_JUMP: Firmware with static jump address to the next booting stage\n- FW_DYNAMIC: Firmware with dynamic information on the next booting stage\n\nvendor 厂商可以选择下面的策略定制opensbi:\n\n- 参考上面的三个模型里的一个定制M层 runtime SEE\n\n- 使用opensbi的静态库 弹性定制M-mode runtime SEE\n\n- 使用opensbi静态库扩展 M-mode 的spl\n\n### FW_PAYLOAD\n\n![image-20220915144648455](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915144648455.png)\n\n优点:\n\n- opensbi的前一级只需要加载opensbi\n- 允许opensbi 覆盖设备树\n\n缺点:\n\n- 每次下级镜像改动, 都需要重新编译opensbi\n- opensbi的前一级无法给opensbi的下一级传递参数\n\n### FW_JUMP\n\n![image-20220915145051827](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915145051827.png)\n\n优点:\n\n- opensbi不需要加载下一级镜像\n- opensbi的体积小, 下一级镜像变动时, 只要固定地址不变, 就不需要重新编译\n\n缺点:\n\n- opensbi的前一级需要同时加载opensbi 和 opensbi的下一级, 加载的地址也必须是固定的, opensbi需要提前知道这个固定地址\n- opensbi的前一级无法给opensbi传参\n\n### FW_DYNAMIC\n\n![image-20220915145516339](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915145516339.png)\n\n优点:\n\n- opensbi不需要加载下一级镜像\n- opensbi的前一级可以给opensbi传递参数\n- opensbi 的下一级变动后不需要重新编译\n\n缺点:\n\n- opensbi的前一级需要同时加载opensbi 和 opensbi的下一级\n\n![image-20220915145816145](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915145816145.png)\n\n### 使用opensbi 扩展spl\n\n![image-20220915145854140](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915145854140.png)\n\nM-mode spl 和 opensbi的静态库链接起来, spl承接SEE runtime\n\nex: open-source EDK2 (UEFI implementation) OpenSBI integration\n\n## 引导过程\n\nRISC-V芯片的启动流程演变历程:\n\n![](attachments/20220909164617.png)\n\n### ZSBL（第0阶段Bootloader）\n\n处于M-mode的ZSBL保存在bootrom中，它负责从GPT中加载更为复杂的spl（寻找uuid的GPT分区）。通过先加载GPT的头文件，然后一块一顺序地扫描GPT。加载过程结束后，spl被加载进地址为sram中，随后，将执行spl阶段。\n\n### SPL（第1阶段Bootloader）\n\n处于M-mode的SPL从SRAM上执行，它负责为在DDR上运行系统做准备，可大概分为如下的这些任务：\n\n- 配置芯片上的PLL 核心频率\n- 配置DDR PLL，PHY和DDR控制器\n- 外部PHY，重置\n- 从编号为uuid的GTP分区下载 SEE(opensbi 实现)\n- 扫描OTP获取的芯片序列号\n- 将DTB（硬件设备树）复制到DDR，填写SPL版本，内存大小和MAC地址\n- 跳转到DDR上, 启动SEE (opensbi 实现)\n\n### SEE (opensbi 实现)\n\nOpenSBI的初始化流程如下：\n\n（1）底层初始化：\n    1.  判断hart(Hardware Thread) id\n    2.  代码重定位（判断_load_start与_start函数是否一致）\n    3.  清除除保存设备树地址的寄存器的值\n    4.  清除bss段\n    5.  设置栈指针（预留栈空间）\n    6.  读取设备树中的设备信息\n    7.  设备树重定位，为U-Boot提供信息\n    8.  至此，底层初始化结束，执行sbi_init，进行正式的初始化程序\n\n（2）设备初始化：\n    1.  sbi_domain_init 初始化动态加载的镜像的模块\n    2. sbi_platform_early_init 平台的早期初始化\n    3. sbi_console_init 控制台初始化，从这里开始，就可以使用串口输出了。\n    4. sbi_platform_irqchip_init        irq中断初始化\n    5. sbi_ipi_init    核间中断初始化\n    6. sbi_tlb_init    mmu的tlb表的初始化\n    7. sbi_timer_init    timer初始化\n    8. sbi_hsm_prepare_next_jump   准备下一级的boot\n\n（3）二级boot跳转，跳转Uboot, PAYLOAD 模式中, uboot的代码会装载到 SEE的特定位置 (汇编中使用.incbin 实现), 跳转时, 不再需要从GPT 加载uboot, 只需要跳转到 uboot 起始地址即可\n\n### uboot（第2阶段的Bootloader）\n\nuboot 从gpt分区中加载kernel到DDR, 解压, 验证kernel, 跳转到kernel\n\nU-Boot属于一种bootloader，简单来说，其作用就是从flash中读出内核，随后加载在内存中，最终初始化并启动操作系统内核。\n具体来说，可以分为下述几个方面：\n\n1) U-Boot主要作用是用来启动[操作系统内核](https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)。体现在uboot最后一句代码就是启动内核。\n2) U-Boot还要负责部署操作系统内核。体现在uboot最后的传参。\n3) U-Boot中还有操作Flash等板子上硬件的驱动。例如串口要打印，ping网络，擦除、烧写flash等。提供烧写功能等\n4) U-Boot还得提供一个命令行界面供人来操作。如果kernel 起不来, uboot命令行可以提供操作界面, 让用户来手动加载kernel\n\n## opensbi 软件栈层级\n\n![image-20220915150631597](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915150631597.png)\n\n1. 通用平台抽象 libsbi.a\n\n   抽象出平台无关的feature 接口, 供外界组件使用, 生成libsbi.a, 外界组件link\n\n2. 平台相关实现 (硬件依赖驱动实现)   libplatsbi.a \n\n   实现特定平台特定硬件驱动的 sbi_platform 的hook\n\n   \n\n   libplatsbi.a = libsbi.a + struct sbi_platform instance\n\n   ![image-20220915152353528](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915152353528.png)\n\n3. 平台自定集成固件\n\n   厂商自定义添加ecall extension\n\n   ex: SBI_EXT_EXPERIMENTAL_KEYSTONE_ENCLAVE *0x*08424b45\n\n   ![image-20220915152730792](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915152730792.png)\n\n   ![image-20220915153005588](C:/Users/1/AppData/Roaming/Typora/typora-user-images/image-20220915153005588.png)\n\n## ARM架构中的Hypervisor与OpenSBI的对比\n\n在ARM架构中，Hypervisor层承担了虚拟化的作用，承担了如内存管理、设备模拟、设备分配、异常处理、指令捕获、虚拟异常管理、中断控制器管理、调度、上下文切换、内存转换、多个虚拟地址空间管理等非常多的功能。\n相比之下，SBI在RISC-V架构中充当了BIOS和在操作系统运行时为上层提供底层抽象的作用，功能较少。不过SBI也在不断发展中，可能在将来SBI会去承担虚拟化的功能。\n![](attachments/20220909164618.png)\n","tags":["opensbi"],"categories":["RISCV"]}]
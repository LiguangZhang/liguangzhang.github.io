<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="1. ADB处理的流程通过adb install命令安装指定apk时，会先将该apk上传到&#x2F;data&#x2F;local&#x2F;tmp或者&#x2F;sdcard&#x2F;tmp目录下，然后调用pm脚本，通过Binder通信，调用PackageManagerService的接口安装apk。通过PackageInstaller.apk安装指定apk时，最终也会调用PackageMa">
<meta property="og:type" content="article">
<meta property="og:title" content="通过adb install 安装apk">
<meta property="og:url" content="https://liguangzhang.github.io/2017/08/02/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/%E9%80%9A%E8%BF%87adb%20install%20%E5%AE%89%E8%A3%85apk/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="1. ADB处理的流程通过adb install命令安装指定apk时，会先将该apk上传到&#x2F;data&#x2F;local&#x2F;tmp或者&#x2F;sdcard&#x2F;tmp目录下，然后调用pm脚本，通过Binder通信，调用PackageManagerService的接口安装apk。通过PackageInstaller.apk安装指定apk时，最终也会调用PackageMa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liguangzhang.github.io/images/qianming.png">
<meta property="article:published_time" content="2017-08-02T05:47:23.000Z">
<meta property="article:modified_time" content="2024-04-15T09:59:59.487Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="AndroidN">
<meta property="article:tag" content="PackageManagerService">
<meta property="article:tag" content="adb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liguangzhang.github.io/images/qianming.png">

<link rel="canonical" href="https://liguangzhang.github.io/2017/08/02/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/%E9%80%9A%E8%BF%87adb%20install%20%E5%AE%89%E8%A3%85apk/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.6.0/style.css" />

  <title>通过adb install 安装apk | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2017/08/02/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/%E9%80%9A%E8%BF%87adb%20install%20%E5%AE%89%E8%A3%85apk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          通过adb install 安装apk
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-02 13:47:23" itemprop="dateCreated datePublished" datetime="2017-08-02T13:47:23+08:00">2017-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-15 17:59:59" itemprop="dateModified" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PackageManagerService/" itemprop="url" rel="index"><span itemprop="name">PackageManagerService</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-ADB处理的流程"><a href="#1-ADB处理的流程" class="headerlink" title="1. ADB处理的流程"></a>1. ADB处理的流程</h1><p>通过adb install命令安装指定apk时，会先将该apk上传到&#x2F;data&#x2F;local&#x2F;tmp或者&#x2F;sdcard&#x2F;tmp目录下，然后调用pm脚本，通过Binder通信，调用PackageManagerService的接口安装apk。<br>通过PackageInstaller.apk安装指定apk时，最终也会调用PackageManagerService的接口实现apk的安装。<br>以上两种情况最终都会发送INIT-COPY消息，由PackageManagerService启动过程中初始化的mHandler的handleMessage方法处理该消息，开始apk的安装。</p>
<h2 id="1-1-adb-拷贝流程分析"><a href="#1-1-adb-拷贝流程分析" class="headerlink" title="1.1. adb 拷贝流程分析"></a>1.1. adb 拷贝流程分析</h2><p>adb 安装apk支持的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;  adb install [-lrtsdg] &lt;file&gt;\n&quot;</span><br><span class="line">&quot;                               - push this package file to the device and install it\n&quot;</span><br><span class="line">&quot;                                 (-l: forward lock application)\n&quot;    // foward_lock</span><br><span class="line">&quot;                                 (-r: replace existing application)\n&quot;   // upgrade apk</span><br><span class="line">&quot;                                 (-t: allow test packages)\n&quot;</span><br><span class="line">&quot;                                 (-s: install application on sdcard)\n&quot;        // apptosd</span><br><span class="line">&quot;                                 (-d: allow version code downgrade (debuggable packages only))\n&quot;  // downgrade</span><br><span class="line">&quot;                                 (-g: grant all runtime permissions)\n&quot;   // 赋予所有的运行时权限</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">install_app_legacy</span><span class="params">(TransportType transport, <span class="type">const</span> <span class="type">char</span>* serial, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> DATA_DEST = <span class="string">&quot;/data/local/tmp/%s&quot;</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> SD_DEST = <span class="string">&quot;/sdcard/tmp/%s&quot;</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* where = DATA_DEST;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> sb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-s&quot;</span>)) &#123;</span><br><span class="line">          where = SD_DEST;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line">  std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; apk_file = &#123;argv[last_apk]&#125;;</span><br><span class="line">  std::string apk_dest = android::base::<span class="built_in">StringPrintf</span>(</span><br><span class="line">      where, <span class="built_in">adb_basename</span>(argv[last_apk]).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="comment">// adb 将pc上的apk包拷贝到手机上的 DATA_DEST/&lt;filename&gt;.apk  或 SD_DEST/&lt;filename&gt;.apk</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">do_sync_push</span>(apk_file, apk_dest.<span class="built_in">c_str</span>())) <span class="keyword">goto</span> cleanup_apk;</span><br><span class="line">  argv[last_apk] = apk_dest.<span class="built_in">c_str</span>(); <span class="comment">/* destination name, not source location */</span></span><br><span class="line">  <span class="comment">// 调用pm cmd 进行处理</span></span><br><span class="line">  result = <span class="built_in">pm_command</span>(transport, serial, argc, argv);</span><br><span class="line">  cleanup_apk:</span><br><span class="line">  <span class="comment">// 清理拷贝到手机目录上的apk</span></span><br><span class="line">  <span class="built_in">delete_file</span>(transport, serial, apk_dest);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送shell消息到终端, 使用pm install  <apk path> 命令安装对应的apk.期间,如果出现adb connect连接问题,则会进行重连.如果能够发送给终端执行对应的shell命令.等待执行的结果,并通过adb打印到电脑的控制台上.</p>
<h2 id="1-2-pm执行安装流程"><a href="#1-2-pm执行安装流程" class="headerlink" title="1.2. pm执行安装流程"></a>1.2. pm执行安装流程</h2><p>生成<code>system/bin/pm</code> 可执行文件</p>
<p>传入参数.执行 runInstall 函数</p>
<p>在runInstall函数中将shell传过来的pm命令进行解析,并添加到SessionParams的相应flag中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">runInstall</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 对参数进行转换, 初始化SessionParams</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InstallParams</span> <span class="variable">params</span> <span class="operator">=</span> makeInstallParams();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">inPath</span> <span class="operator">=</span> nextArg();</span><br><span class="line">    <span class="comment">// 创建 PackageInstallerSession 对象,并加到mSessions 以 sessionId加到集合中,同时更新/data/system/install_sessions.xml文件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sessionId</span> <span class="operator">=</span> doCreateSession(params.sessionParams,</span><br><span class="line">                                        params.installerPackageName, params.userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inPath == <span class="literal">null</span> &amp;&amp; params.sessionParams.sizeBytes == -<span class="number">1</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error: must either specify a package size or an APK file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从之前拷贝到的地址中  DATA_DEST|SD_DEST 拷贝到 /data/app/vml&lt;sessionid&gt;.tmp下|sd卡相关的mnt/secure/asec?? 下的base.apk中</span></span><br><span class="line">      <span class="keyword">if</span> (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, <span class="string">&quot;base.apk&quot;</span>,</span><br><span class="line">                         <span class="literal">false</span> <span class="comment">/*logSuccess*/</span>) != PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 提交sessionId 对应的 PackageInstaller.Session对象,通过session.commit层层传递,最终通过PKMS的installStage函数对apk进行安装</span></span><br><span class="line">      <span class="keyword">if</span> (doCommitSession(sessionId, <span class="literal">false</span> <span class="comment">/*logSuccess*/</span>)</span><br><span class="line">          != PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        mInstaller.abandonSession(sessionId);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InstallParams <span class="title function_">makeInstallParams</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化SessionParams和InstallParams,赋值相应参数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SessionParams</span> <span class="variable">sessionParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SessionParams</span>(SessionParams.MODE_FULL_INSTALL);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InstallParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstallParams</span>();</span><br><span class="line">        params.sessionParams = sessionParams;</span><br><span class="line">        String opt;</span><br><span class="line">        <span class="keyword">while</span> ((opt = nextOption()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-l&quot;</span>:</span><br><span class="line">                    sessionParams.installFlags |= PackageManager.INSTALL_FORWARD_LOCK;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-r&quot;</span>:</span><br><span class="line">                    sessionParams.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-s&quot;</span>:</span><br><span class="line">                    sessionParams.installFlags |= PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-f&quot;</span>:</span><br><span class="line">                    sessionParams.installFlags |= PackageManager.INSTALL_INTERNAL;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-g&quot;</span>:</span><br><span class="line">                    sessionParams.installFlags |= PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown option &quot;</span> + opt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;data&#x2F;system&#x2F;install_sessions.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sessions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session</span> <span class="attr">sessionId</span>=<span class="string">&quot;667330637&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;0&quot;</span> <span class="attr">installerUid</span>=<span class="string">&quot;0&quot;</span> <span class="attr">createdMillis</span>=<span class="string">&quot;1325393932643&quot;</span> <span class="attr">sessionStageDir</span>=<span class="string">&quot;/data/app/vmdl667330637.tmp&quot;</span> <span class="attr">prepared</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sealed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;1&quot;</span> <span class="attr">installFlags</span>=<span class="string">&quot;112&quot;</span> <span class="attr">installLocation</span>=<span class="string">&quot;1&quot;</span> <span class="attr">sizeBytes</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">originatingUid</span>=<span class="string">&quot;-1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sessions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下一步主要涉及到doCommitSession的处理</p>
<p>在PackageInstallerSession的commitLocked函数中,最终调到了PKMS的installStage方法进行应用的安装</p>
<span id="stage">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> OriginInfo origin;</span><br><span class="line"><span class="keyword">if</span> (stagedDir != <span class="literal">null</span>) &#123;</span><br><span class="line">  origin = OriginInfo.fromStagedFile(stagedDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  origin = OriginInfo.fromStagedContainer(stagedCid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(INIT_COPY);</span><br><span class="line"><span class="keyword">final</span> <span class="type">InstallParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstallParams</span>(origin, <span class="literal">null</span>, observer,</span><br><span class="line">        sessionParams.installFlags, installerPackageName <span class="comment">/*安装器*/</span>, sessionParams.volumeUuid,</span><br><span class="line">        verificationInfo, user, sessionParams.abiOverride,</span><br><span class="line">        sessionParams.grantedRuntimePermissions, certificates);</span><br><span class="line">mHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure>

<h1 id="2-安装流程"><a href="#2-安装流程" class="headerlink" title="2. 安装流程"></a>2. 安装流程</h1><h2 id="2-1-从INIT-COPY开始"><a href="#2-1-从INIT-COPY开始" class="headerlink" title="2.1. 从INIT_COPY开始"></a>2.1. 从INIT_COPY开始</h2><p>首先，获取消息的保存的InstallParams对，然后判断当前是否绑定到DefaultContainerService服务,</p>
<p>没有绑定时，调用mHandler.connectToService方法绑定：绑定失败，直接退出；成功，将安装请求信息添加到mHandler.mPendingInstalls（存储等待安装的apk请求信息）中，稍候会处理第一个安装请求。初次绑定并成功后，会调用PackageManageService.mDefContainerConn的回调方法onServiceConnected，获取服务代理对象，并发送一个MCS-BOUND消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">    <span class="type">HandlerParams</span> <span class="variable">params</span> <span class="operator">=</span> (HandlerParams) msg.obj;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> mPendingInstalls.size();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;init_copy idx=&quot;</span> + idx + <span class="string">&quot;: &quot;</span> + params);</span><br><span class="line">    <span class="comment">// If a bind was already initiated we dont really</span></span><br><span class="line">    <span class="comment">// need to do anything. The pending install</span></span><br><span class="line">    <span class="comment">// will be processed later on.</span></span><br><span class="line">    <span class="keyword">if</span> (!mBound) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;bindingMCS&quot;</span>,</span><br><span class="line">                System.identityHashCode(mHandler));</span><br><span class="line">        <span class="comment">// If this is the only one pending we might</span></span><br><span class="line">        <span class="comment">// have to bind to the service again.</span></span><br><span class="line">        <span class="keyword">if</span> (!connectToService()) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Failed to bind to media container service&quot;</span>);</span><br><span class="line">            params.serviceError();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Once we bind to the service, the first</span></span><br><span class="line">            <span class="comment">// pending request will be processed.</span></span><br><span class="line">            mPendingInstalls.add(idx, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mPendingInstalls.add(idx, params);</span><br><span class="line">      <span class="comment">// Already bound to the service. Just make</span></span><br><span class="line">      <span class="comment">// sure we trigger off processing the first request.</span></span><br><span class="line">      <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一个绑定的,需要发送MCS_BOUND消息</span></span><br><span class="line">        mHandler.sendEmptyMessage(MCS_BOUND消息);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">connectToService</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Intent</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>().setComponent(DEFAULT_CONTAINER_COMPONENT);</span><br><span class="line">      Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);</span><br><span class="line">      <span class="comment">// 绑定 DefaultContainerService服务</span></span><br><span class="line">      <span class="keyword">if</span> (mContext.bindServiceAsUser(service, mDefContainerConn,</span><br><span class="line">                                     Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        mBound = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">DefaultContainerConnection</span> <span class="variable">mDefContainerConn</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefaultContainerConnection</span>();</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DefaultContainerConnection</span> <span class="keyword">implements</span> <span class="title class_">ServiceConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">      <span class="type">IMediaContainerService</span> <span class="variable">imcs</span> <span class="operator">=</span></span><br><span class="line">        IMediaContainerService.Stub.asInterface(service);</span><br><span class="line">       <span class="comment">// 绑定成功,发送MCS_BOUND消息</span></span><br><span class="line">      mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  只有在没有绑定进行绑定时或已绑定且当前是第一个安装请求时才会发送MCS_BOUND空消息，接下来开始处理该消息。</p>
</blockquote>
<h2 id="2-2-处理MCS-BOUND消息"><a href="#2-2-处理MCS-BOUND消息" class="headerlink" title="2.2. 处理MCS_BOUND消息"></a>2.2. 处理MCS_BOUND消息</h2><p>首先要保存服务代理对象到PackageManagerService.mContainerService中。</p>
<blockquote>
<p>  如果是空消息，说明已经绑定服务，代理对象已保存,即msg.obj&#x3D;null的情况</p>
</blockquote>
<p>判断当前服务代理对象是否为null：如果为null，说明没有绑定服务，处理出错信息，清空所有安装请求；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MCS_BOUND: &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;mcs_bound&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (msg.obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        mContainerService = (IMediaContainerService) msg.obj;</span><br><span class="line">        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;bindingMCS&quot;</span>,</span><br><span class="line">                System.identityHashCode(mHandler));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContainerService == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound) &#123;</span><br><span class="line">            <span class="comment">// Something seriously wrong since we are not bound and we are not</span></span><br><span class="line">            <span class="comment">// waiting for connection. Bail out.</span></span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Cannot bind to media container service&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (HandlerParams params : mPendingInstalls) &#123;</span><br><span class="line">                <span class="comment">// Indicate service bind error</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空所有安装请求</span></span><br><span class="line">            mPendingInstalls.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Waiting to connect to media container service&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>已绑定，处理第一个安装请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">HandlerParams</span> <span class="variable">params</span> <span class="operator">=</span> mPendingInstalls.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用InstallParams.startCopy方法进行复制安装，复制安装成功后，继续以下两步；</span></span><br><span class="line">        <span class="keyword">if</span> (params.startCopy()) &#123;</span><br><span class="line">            <span class="comment">// We are done...  look for more work or to</span></span><br><span class="line">            <span class="comment">// go idle.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,</span><br><span class="line">                    <span class="string">&quot;Checking for more work or unbind...&quot;</span>);</span><br><span class="line">            <span class="comment">// Delete pending install</span></span><br><span class="line">            <span class="comment">// 从mHandler.mPendingInstalls中移除该安装请求信息；</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mPendingInstalls.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 判断是否还有安装请求：没有了，如果当前绑定服务，移除前一个安装请求的MCS_UNBOUND消息，然后重新发送一个10s的延时消息MCS_UNBOUND，</span></span><br><span class="line">          <span class="comment">// 用于解除服务绑定；如果还有安装请求，发送一个空的MCS_BOUND消息，用于处理下一个安装请求。</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingInstalls.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,</span><br><span class="line">                            <span class="string">&quot;Posting delayed MCS_UNBIND&quot;</span>);</span><br><span class="line">                    removeMessages(MCS_UNBIND);</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">ubmsg</span> <span class="operator">=</span> obtainMessage(MCS_UNBIND);</span><br><span class="line">                    <span class="comment">// Unbind after a little delay, to avoid</span></span><br><span class="line">                    <span class="comment">// continual thrashing.</span></span><br><span class="line">                    sendMessageDelayed(ubmsg, <span class="number">10000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// There are more pending requests in queue.</span></span><br><span class="line">                <span class="comment">// Just post MCS_BOUND message to trigger processing</span></span><br><span class="line">                <span class="comment">// of next pending install.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,</span><br><span class="line">                        <span class="string">&quot;Posting MCS_BOUND for next work&quot;</span>);</span><br><span class="line">                mHandler.sendEmptyMessage(MCS_BOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  1 只有当安装请求队列处理到最后，后面没有安装请求时，才会发送MCS_UNBOUND消息；</p>
<p>  2.当来了新的安装请求，而消息队列中还存在前一个安装请求的MCS_UNBOUND消息时，可能存在一种情况，就是在初始化安装时是存在绑定服务的，但是在安装过程中，由于前一个请求的MCS_UNBOUND消息，导致服务解绑，出现安装错误</p>
</blockquote>
<p>判断每个apk尝试安装的次数，每个apk最多尝试安装4次，均失败，发送MCS_GIVE_UP消息，返回false；否则调用InstallParams.handleStartCopy方法进行复制安装，复制安装成功返回true，若失败，抛出并处理RemoteException，发送MCS_RECONNECTION消息，重新尝试安装。最后调用InstallParams.handleReturnCode方法处理返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startCopy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> res;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++mRetries &gt; MAX_RETRIES) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Failed to invoke remote methods on default container service. Giving up&quot;</span>);</span><br><span class="line">            mHandler.sendEmptyMessage(MCS_GIVE_UP);</span><br><span class="line">            handleServiceError();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进行复制安装</span></span><br><span class="line">            handleStartCopy();</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;Posting install MCS_RECONNECT&quot;</span>);</span><br><span class="line">        mHandler.sendEmptyMessage(MCS_RECONNECT);</span><br><span class="line">        res = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handleReturnCode();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-调用InstallParams-handleStartCopy方法复制apk"><a href="#2-3-调用InstallParams-handleStartCopy方法复制apk" class="headerlink" title="2.3. 调用InstallParams.handleStartCopy方法复制apk"></a>2.3. 调用InstallParams.handleStartCopy方法复制apk</h2><p>该方法主要根据安装位置（默认installFlags既没指定onSd，也没指定onInt），复制资源文件到内部&#x2F;外部存储中，或者先验证包然后在CHECK_PENDING_VERIFICATION消息处理分支实现复制和安装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经缓存了文件, 根据stage的类型重新确定安装的标志</span></span><br><span class="line"><span class="keyword">if</span> (origin.staged) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.file != <span class="literal">null</span>) &#123;</span><br><span class="line">        installFlags |= PackageManager.INSTALL_INTERNAL;</span><br><span class="line">        installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin.cid != <span class="literal">null</span>) &#123;</span><br><span class="line">        installFlags |= PackageManager.INSTALL_EXTERNAL;</span><br><span class="line">        installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid stage location&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-计算推荐安装位置"><a href="#2-3-1-计算推荐安装位置" class="headerlink" title="2.3.1. 计算推荐安装位置"></a>2.3.1. 计算推荐安装位置</h3><p>如果安装位置标志既设置了内部标志又设置了外部标志，记录返回结果INSTALL_FAILED_INVALID_INSTALL_LOCATION到InstallParams.mRet中；</p>
<p>否则，根据指定安装位置（内部存储&#x2F;外部存储），调用mContainerService.getMinimalPackageInfo方法，解析AndroidManifest.xml文按，获取包名、installLocation、package-verifier等信息，并计算存储区域的推荐安装位置，将这些信息存储到PackageInfoLite结构中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 计算推荐安装位置</span></span><br><span class="line">    pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags,</span><br><span class="line">            packageAbiOverride);</span><br><span class="line">    <span class="comment">// 没有缓存文件的情况,需要计算缓存文件释放后空间是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (!origin.staged &amp;&amp; pkgLite.recommendedInstallLocation</span><br><span class="line">            == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> focus freeing disk space on the target device</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">StorageManager</span> <span class="variable">storage</span> <span class="operator">=</span> StorageManager.from(mContext);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lowThreshold</span> <span class="operator">=</span> storage.getStorageLowBytes(</span><br><span class="line">                Environment.getDataDirectory());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sizeBytes</span> <span class="operator">=</span> mContainerService.calculateInstalledSize(</span><br><span class="line">                origin.resolvedPath, isForwardLocked(), packageAbiOverride);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 清空/data/user/&lt;user_id&gt;/</span></span><br><span class="line">            <span class="comment">// /data/user_de/&lt;user_id&gt;</span></span><br><span class="line">            <span class="comment">// /data/media/&lt;user_id&gt;/Android/data/</span></span><br><span class="line">            <span class="comment">// cache code_cache 下的文件,直到删除到满足要求为止</span></span><br><span class="line">            mInstaller.freeCache(<span class="literal">null</span>, sizeBytes + lowThreshold);</span><br><span class="line">            <span class="comment">// 重新计算空间是否足够</span></span><br><span class="line">            pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,</span><br><span class="line">                    installFlags, packageAbiOverride);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Failed to free cache&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The cache free must have deleted the file we</span></span><br><span class="line"><span class="comment">         * downloaded to install.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> fix the &quot;freeCache&quot; call to not delete</span></span><br><span class="line"><span class="comment">         *       the file we care about.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pkgLite.recommendedInstallLocation</span><br><span class="line">                == PackageHelper.RECOMMEND_FAILED_INVALID_URI) &#123;</span><br><span class="line">            pkgLite.recommendedInstallLocation</span><br><span class="line">                = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有缓存文件时,因为要拷贝缓存文件到&#x2F;data&#x2F;app&#x2F;***下,所以需要计算所需的空间大小,算出来后,通过installd的freecache函数清除缓存文件来释放空间.释放完之后重新计算安装位置是否满足空间要求.</p>
<p>此处涉及到判断空间是否满足要求的判断标准,再此重新说明一下:</p>
<h3 id="2-3-2-空间不足的判断标准"><a href="#2-3-2-空间不足的判断标准" class="headerlink" title="2.3.2. 空间不足的判断标准"></a>2.3.2. 空间不足的判断标准</h3><p>对于内部存储,是通过fitsOnInternal函数进行判定的, 判定标准时 可用空间大小 &gt;&#x3D; sizeBytes + 默认1M</p>
<p>对于外部存储,是通过fitsOnExternal函数进行判定, 首先判断外部存储是否挂载,再进行判断  可用空间大小 &gt;&#x3D; sizeBytes + 默认1M</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeBytes是统计的apk的大小,如果forwardLock为true(code和resource分离?)需要计算解压后的大小.同时需要加上其关联的native库的大小</span></span><br><span class="line">sizeBytes = PackageHelper.calculateInstalledSize(pkg, isForwardLocked, abiOverride);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">fitsOnInternal</span><span class="params">(Context context, <span class="type">long</span> sizeBytes)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StorageManager</span> <span class="variable">storage</span> <span class="operator">=</span> context.getSystemService(StorageManager.class);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">target</span> <span class="operator">=</span> Environment.getDataDirectory();</span><br><span class="line">    <span class="comment">// 即为  path.getUsableSpace() &gt;=  getStorageFullBytes(path) + sizeBytes</span></span><br><span class="line">    <span class="keyword">return</span> (sizeBytes &lt;= storage.getStorageBytesUntilLow(target));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getStorageBytesUntilLow</span><span class="params">(File path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.getUsableSpace() - getStorageFullBytes(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getStorageFullBytes</span><span class="params">(File path)</span> &#123;</span><br><span class="line">  <span class="comment">// 此处默认定为1M大小</span></span><br><span class="line">  <span class="keyword">return</span> Settings.Global.getLong(mResolver, Settings.Global.SYS_STORAGE_FULL_THRESHOLD_BYTES,</span><br><span class="line">                                 DEFAULT_FULL_THRESHOLD_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可用大小可以通过df命令查看</p>
<p>文件系统可以通过指定uid\gid保护对空间进行保护,特权进程访问到的可使用空间比较多,而普通进程看到的可用空间比较少,用以对存储进行保护</p>
<h4 id="2-3-2-1-文件系统层对存储空间做的保护"><a href="#2-3-2-1-文件系统层对存储空间做的保护" class="headerlink" title="2.3.2.1. 文件系统层对存储空间做的保护"></a>2.3.2.1. 文件系统层对存储空间做的保护</h4><p>board 打开  BOARD_RESERVED_SPACE_ON 开关时</p>
<p>​       data分区  在init checkfs时会预留空间 10M大小(手机上block大小一般为512, 2560*512B&#x3D;10M)，预留给特定的uid gid的进程使用</p>
<p>​       tune2fs -r 2560  &#x2F;dev&#x2F;block&#x2F;platform&#x2F;..&#x2F;userdata</p>
<p>​	使用tune2fs -r 指定   固定值count （指定预留的  block count）</p>
<p>也可以通过   tune2fs -m  <percent>   指定预留block 占总 block 的百分比</p>
<p>查看文件系统的超级块信息：<br>dumpe2fs -h userdata.img 或  &#x2F;dev&#x2F;block&#x2F;..&#x2F;userdata</p>
<ul>
<li>Reserved block group size：（<code>resv_blocks</code>）  文件系统  free_block  该项必须配置，该项为系统预留值。一般通过make_ext4fs 制作img时配置。</li>
<li>Reserved block count：   （ <code>ext4_r_blocks_count</code> ）       该项为预留给 特殊进程使用的预留空间。</li>
</ul>
<p>特权进程调用stat 看到的及可使用的可用空间为  avail &#x3D; total - resv_blocks<br>普通进程调用stat看到的及可使用的可用空间为  avail  &#x3D; total - resv_blocks - ext4_r_blocks_count</p>
<p>resv_blocks 是 kernel 中进行指定:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resv_clusters = <span class="type">min_t</span>(<span class="type">ext4_fsblk_t</span>, resv_clusters, <span class="number">4096</span>);</span><br></pre></td></tr></table></figure>
<p>取的分区的  2% 或 16M的最小值</p>
<h3 id="2-3-3-根据推荐安装位置处理返回结果"><a href="#2-3-3-根据推荐安装位置处理返回结果" class="headerlink" title="2.3.3. 根据推荐安装位置处理返回结果"></a>2.3.3. 根据推荐安装位置处理返回结果</h3><p>当安装位置不冲突时，根据根据推荐安装位置返回值指定相应的返回结果。</p>
<p>存在一种情况，会调用installLocationPolicy进一步处理推荐安装位置，主要是为了防止系统级应用安装到sd卡上等操作，根据推荐安装位置更新安装位置标志</p>
<p>正常情况下,对于安装在内部&#x2F;外部存储上的应用,一般返回</p>
<p>PackageHelper.RECOMMEND_INSTALL_INTERNAL | PackageHelper.RECOMMEND_INSTALL_EXTERNAL</p>
<p>installLocationPolicy函数对应用的升级\降级情况进行了判断,如果是升级的情况下,升级的应用是system app,是不允许升级后安装到sd卡上的.</p>
<p>如果没有携带-r参数,且应用已经存在,即在PKMS.mPackages中能够查到,则返回应用已存在,跳出安装流程</p>
<h3 id="2-3-4-根据安装位置创建安装参数InstallArgs"><a href="#2-3-4-根据安装位置创建安装参数InstallArgs" class="headerlink" title="2.3.4. 根据安装位置创建安装参数InstallArgs"></a>2.3.4. 根据安装位置创建安装参数InstallArgs</h3><p>根据InstallParams.mInstallFlags安装位置标志，调用createInstallArgs方法创建InstallArgs：</p>
<ul>
<li>对于安装在sd卡（内和外sd卡）和FORWARD-LOCKED的apk，创建AsecInstallArgs类型</li>
<li>对于安装在手机内部存储区域的，创建FileInstallArgs类型。并存储到InstallParams.mArgs中。</li>
<li>移动应用的情况下(从内部存储移动到外部存储或反过来的情况), 创建MoveInstallArgs.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">InstallArgs</span> <span class="variable">args</span> <span class="operator">=</span> createInstallArgs(<span class="built_in">this</span>);</span><br><span class="line">mArgs = args;</span><br><span class="line"><span class="keyword">private</span> InstallArgs <span class="title function_">createInstallArgs</span><span class="params">(InstallParams params)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (params.move != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MoveInstallArgs</span>(params);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsecInstallArgs</span>(params);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInstallArgs</span>(params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-验证包-GMS情况下"><a href="#2-3-5-验证包-GMS情况下" class="headerlink" title="2.3.5. 验证包(GMS情况下)"></a>2.3.5. 验证包(GMS情况下)</h3><p>在PMS启动阶段最后，如果指定了验证包，可以用它来验证后续需要验证的apk。该包被授予android.Manifest.permission.<code>PACKAGE_VERIFICATION_AGENT</code>权限，它包含能处理Action为<code>ACTION_PACKAGE_NEEDS_VERIFICATION</code>的Intent的组件。将该包名存储到PackageManagerService.<code>mRequiredVerifierPackage</code>中，非GMS版本中一般不会指定该验证包。</p>
<p><a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms1/#bianliang">跳转</a></p>
<p>当所需要安装的apk需要验证时，将验证编号和验证状态存入PackageManagerService.mPendingVerification中。</p>
<p>构造验证包的Intent对象</p>
<p>传入验证包的地址, origin对象来自于<a href="#stage">installStage</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">verification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(</span><br><span class="line">        Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</span><br><span class="line">verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line"><span class="comment">// 传入验证包的地址, origin对象来自于installStage</span></span><br><span class="line">verification.setDataAndType(Uri.fromFile(<span class="keyword">new</span> <span class="title class_">File</span>(origin.resolvedPath)),</span><br><span class="line">        PACKAGE_MIME_TYPE);</span><br><span class="line">verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line"><span class="comment">// Query all live verifiers based on current user state</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ResolveInfo&gt; receivers = queryIntentReceiversInternal(verification,</span><br><span class="line">                                                                 PACKAGE_MIME_TYPE, <span class="number">0</span>, verifierUser.getIdentifier());</span><br></pre></td></tr></table></figure>

<p>根据该安装包解析到的验证包和receivers，查找匹配该安装包的用来验证的组件信息列表，并向这些组件发送广播；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sufficientVerifiers != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sufficientVerifiers.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Additional verifiers required, but none installed.&quot;</span>);</span><br><span class="line">        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ComponentName</span> <span class="variable">verifierComponent</span> <span class="operator">=</span> sufficientVerifiers.get(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">sufficientIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(verification);</span><br><span class="line">            sufficientIntent.setComponent(verifierComponent);</span><br><span class="line">            mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据系统指定验证包和receivers查找验证包中匹配的组件。在返回结果为成功安装的前提下，向该组件发送有序广播，该广播也包含接收目标组件广播的广播接收器，继而发送一个CHECK_PENDING_VERIFICATION的延时handler消息(默认为10s的延时消息)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ComponentName</span> <span class="variable">requiredVerifierComponent</span> <span class="operator">=</span> matchComponentForVerifier(</span><br><span class="line">        mRequiredVerifierPackage, receivers);</span><br><span class="line"><span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED</span><br><span class="line">        &amp;&amp; mRequiredVerifierPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">    Trace.asyncTraceBegin(</span><br><span class="line">            TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;verification&quot;</span>, verificationId);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Send the intent to the required verification agent,</span></span><br><span class="line"><span class="comment">     * but only start the verification timeout after the</span></span><br><span class="line"><span class="comment">     * target BroadcastReceivers have run.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    verification.setComponent(requiredVerifierComponent);</span><br><span class="line">    mContext.sendOrderedBroadcastAsUser(verification, verifierUser,</span><br><span class="line">            android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler</span><br><span class="line">                            .obtainMessage(CHECK_PENDING_VERIFICATION);</span><br><span class="line">                    msg.arg1 = verificationId;</span><br><span class="line">                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We don&#x27;t want the copy to proceed until verification</span></span><br><span class="line"><span class="comment">     * succeeds, so null out this field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 验证成功后,才进行拷贝安装的流程</span></span><br><span class="line">    mArgs = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将InstallParams.mArgs置为null，保证在验证完成之前不进行apk的复制。在CHECK_PENDING_VERIFICATION消息处理过程中，会发送相关广播，被PMS中定义的验证包接收，然后进行apk的复制和安装，最后会发送一个MCS_UNBOUND消息。</p>
<h3 id="2-3-6-复制apk和lib文件"><a href="#2-3-6-复制apk和lib文件" class="headerlink" title="2.3.6. 复制apk和lib文件"></a>2.3.6. 复制apk和lib文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = args.copyApk(mContainerService, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>根据安装参数args的具体类型，决定执行FIleInstallArgs还是AsecInstallArgs的copyApk方法实现apk复制。</p>
<h3 id="2-3-7-FileInstallArgs-copyApk方法"><a href="#2-3-7-FileInstallArgs-copyApk方法" class="headerlink" title="2.3.7. FileInstallArgs.copyApk方法"></a>2.3.7. FileInstallArgs.copyApk方法</h3><ul>
<li>文件已经存在即base.apk已经拷贝完成的情况下,直接跳过拷贝流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (origin.staged) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, origin.file + <span class="string">&quot; already staged; skipping copy&quot;</span>);</span><br><span class="line">    codeFile = origin.file;</span><br><span class="line">    resourceFile = origin.file;</span><br><span class="line">    <span class="keyword">return</span> PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>origin.staged为空时,创建临时目录,执行文件拷贝</li>
</ul>
<ol>
<li>复制apk文件：调用DefaultContainerService的copyPacakge方法，先对apk文件进行解析，然后将要安装的apk文件拷贝到&#x2F;data&#x2F;app&#x2F;vmdl&lt;随机整数&gt;.tmp&#x2F;base.apk中；如果包含分段的apk，将各个分段apk拷贝到相应的&#x2F;data&#x2F;app&#x2F;vmdl&lt;随机整数&gt;.tmp&#x2F;split_&lt;splitName[i]&gt;.apk中；</li>
<li>复制本地库文件：调用NativeLibrariesHelper.copyNativeBinariesWithOverride方法，将apk中的lib文件拷贝到&#x2F;data&#x2F;app&#x2F; vmdl&lt;随机整数&gt;.tmp&#x2F;lib&#x2F;,,,中；</li>
</ol>
<p>最终将结果返回，保存到InstallParams.mRet中，用于handleReturnCode方法对返回结果进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建临时目录   &quot;vmdl&quot; + sessionId + &quot;.tmp&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">File</span> <span class="variable">tempDir</span> <span class="operator">=</span></span><br><span class="line">        mInstallerService.allocateStageDirLegacy(volumeUuid, isEphemeral);</span><br><span class="line">codeFile = tempDir;</span><br><span class="line">resourceFile = tempDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">IParcelFileDescriptorFactory</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IParcelFileDescriptorFactory</span>.Stub() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">open</span><span class="params">(String name, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(codeFile, name);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> Os.open(file.getAbsolutePath(),</span><br><span class="line">                                        O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">      Os.chmod(file.getAbsolutePath(), <span class="number">0644</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>(fd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;Failed to open: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拷贝到base.apk 如果包含split app ,同时需要拷贝split app</span></span><br><span class="line">ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="type">File</span> <span class="variable">libraryRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(codeFile, LIB_DIR_NAME);</span><br><span class="line">NativeLibraryHelper.<span class="type">Handle</span> <span class="variable">handle</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  handle = NativeLibraryHelper.Handle.create(codeFile);</span><br><span class="line">  <span class="comment">// 根据架构集,拷贝对应的native lib</span></span><br><span class="line">  <span class="comment">// 如拷贝到  **/lib/arm目录下</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;armeabi&quot;, &quot;arm&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;armeabi-v7a&quot;, &quot;arm&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;mips&quot;, &quot;mips&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;mips64&quot;, &quot;mips64&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;x86&quot;, &quot;x86&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;x86_64&quot;, &quot;x86_64&quot;);</span></span><br><span class="line"><span class="comment">        ABI_TO_INSTRUCTION_SET_MAP.put(&quot;arm64-v8a&quot;, &quot;arm64&quot;);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,</span><br><span class="line">                                                           abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String sourcePath, IParcelFileDescriptorFactory target, String targetName)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, RemoteException &#123;</span><br><span class="line">  Slog.d(TAG, <span class="string">&quot;Copying &quot;</span> + sourcePath + <span class="string">&quot; to &quot;</span> + targetName);</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourcePath);</span><br><span class="line">    <span class="comment">// 前面创建了一个IParcelFileDescriptorFactory类型</span></span><br><span class="line">    <span class="comment">// 通过open函数返回一个ParcelFileDescriptor类型，用于跨进程的访问临时目录下的文件，实现apk文件复制；</span></span><br><span class="line">    out = <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>.AutoCloseOutputStream(</span><br><span class="line">      target.open(targetName, ParcelFileDescriptor.MODE_READ_WRITE));</span><br><span class="line">    Streams.copy(in, out);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IoUtils.closeQuietly(out);</span><br><span class="line">    IoUtils.closeQuietly(in);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-8-AsecInstallArgs-copyApk方法"><a href="#2-3-8-AsecInstallArgs-copyApk方法" class="headerlink" title="2.3.8. AsecInstallArgs.copyApk方法"></a>2.3.8. AsecInstallArgs.copyApk方法</h3><p>当apk安装到sd卡（注意是安装在sd卡，并不是apk文件所在的位置），或者apk为FOWARD_LOCKED类型时调用该类的方法进行apk复制。</p>
<p>首先，判断是否已经复制过，如果已复制，借助MountService获取复制目录信息，更新代码&#x2F;资源&#x2F;库路径，跳过后续复制流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (origin.staged &amp;&amp; origin.cid != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, origin.cid + <span class="string">&quot; already staged; skipping copy&quot;</span>);</span><br><span class="line">    cid = origin.cid;</span><br><span class="line">    setMountPath(PackageHelper.getSdDir(cid));</span><br><span class="line">    <span class="keyword">return</span> PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没复制，开始复制流程，复制流程与安装在内部流程一样，主要区别在于临时目录的路径不同（首次会先在手机中创建&#x2F;mnt目录，&#x2F;mnt&#x2F;secure&#x2F; smdl&lt;随机整数&gt;.tmp存放复制的apk和lib，&#x2F;mnt&#x2F;secure&#x2F;asec存放包名-num.asec），复制apk和库文件成功后，更新代码&#x2F;资源&#x2F;库路径信息（将smdl&lt;随机整数&gt;.tmp重命名为包名-num）。<br>到此，不管安装在外部还是内部存储区域的apk，复制操作完成，接下来根据复制过程的返回结果InstallParams.mRet以及InstallParams.mArgs调用InstallParams.handleReturnCode方法进行处理，实现apk的安装。</p>
<h3 id="2-3-9-InstallParams-handleReturnCode安装apk"><a href="#2-3-9-InstallParams-handleReturnCode安装apk" class="headerlink" title="2.3.9. InstallParams.handleReturnCode安装apk"></a>2.3.9. InstallParams.handleReturnCode安装apk</h3><p>在startCopy函数中,当handleStartCopy成功执行完毕后,执行handleReturnCode函数进行apk的安装.</p>
<p>首先，判断InstallParams.mArgs：若为null，说明MCS不可用&#x2F;进行的是包验证，不进行安装操作；否则，调用InstallParams.handleReturnCode方法进行安装：</p>
<span id="processPendingInstall">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handleReturnCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">        processPendingInstall(mArgs, mRet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于apk的安装是一个耗时操作，因此在processPendingInstall方法中，将安装放到消息队列中，然后在分发消息时，作为消息的回调方法，执行该Runnable，在新的线程中进行安装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mHandler.removeCallbacks(<span class="built_in">this</span>);</span><br><span class="line">         <span class="comment">// Result object to be returned</span></span><br><span class="line">        <span class="type">PackageInstalledInfo</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageInstalledInfo</span>();</span><br><span class="line">        res.setReturnCode(currentStatus);</span><br><span class="line">        res.uid = -<span class="number">1</span>;</span><br><span class="line">        res.pkg = <span class="literal">null</span>;</span><br><span class="line">        res.removedInfo = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            args.doPreInstall(res.returnCode);</span><br><span class="line">            <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                installPackageTracedLI(args, res);</span><br><span class="line">            &#125;</span><br><span class="line">            args.doPostInstall(res.returnCode, res.uid);</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，创建一个PackageInstalledInfo res结构，存储安装过程中的结果信息，当成功完成复制，进行安装，其中args.doPreInstall和args.doPostInstall方法只是判定当返回码不是PackageManagerINSTALL_SUCCEEDED时删除代码&#x2F;资源&#x2F;本地库文件，在正常安装时二者基本不做操作。真正的安装操作是在PackageManagerService.installPackageLI中完成的.</p>
<h3 id="2-3-10-installPackageLI函数执行应用的安装"><a href="#2-3-10-installPackageLI函数执行应用的安装" class="headerlink" title="2.3.10. installPackageLI函数执行应用的安装"></a>2.3.10. installPackageLI函数执行应用的安装</h3><p>以安装在内部存储为例,跟一下实际安装的流程</p>
<h4 id="2-3-10-1-installPackageLI-安装流程图"><a href="#2-3-10-1-installPackageLI-安装流程图" class="headerlink" title="2.3.10.1. installPackageLI  安装流程图"></a>2.3.10.1. installPackageLI  安装流程图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">PKMS-&gt; PKMS :installPackageTracedLI</span><br><span class="line">PKMS-&gt; PKMS : installPackageLI(args, res)</span><br><span class="line">PKMS -&gt; PackageParser: new PackageParser()</span><br><span class="line">PKMS -&gt; PackageParser: setSeparateProcesses(mSeparateProcesses)</span><br><span class="line">PKMS -&gt; PackageParser: setDisplayMetrics(mMetrics)</span><br><span class="line">PKMS -&gt; PackageParser: PackageParser.Package pkg = parsePackage(tmpPackageFile, parseFlags)</span><br><span class="line">opt args.certificates</span><br><span class="line">PKMS -&gt; PackageParser: populateCertificates(pkg, args.certificates)</span><br><span class="line">else</span><br><span class="line">PKMS -&gt; PackageParser: collectCertificates(pkg, parseFlags)</span><br><span class="line">end</span><br><span class="line">PKMS-&gt;PKMS : derivePackageAbi(pkg, new File(pkg.codePath), abiOverride , extract libs);  </span><br><span class="line">PKMS-&gt; PKMS : updateSharedLibrariesLPw(pkg, null)</span><br><span class="line">PKMS -&gt; PackageDexOptimizer : performDexOpt(pkg, pkg.usesLibraryFiles, REASON_INSTALL);</span><br><span class="line">PKMS -&gt; FileInstallArgs : doRename(res.returnCode, pkg, oldCodePath)</span><br><span class="line">PKMS-&gt;PKMS: startIntentFilterVerifications(userid, replace, pkg);</span><br><span class="line">PKMS-&gt;PKMS: freezePackageForInstall(pkgName, installFlags, reason:&quot;installPackageLI&quot;));</span><br><span class="line">opt replace</span><br><span class="line">PKMS-&gt;PKMS:replacePackageLIF(pkg, parseFlags, scanFlags| SCAN_REPLACING, ...)</span><br><span class="line">else</span><br><span class="line">PKMS-&gt; PKMS: installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, ...)</span><br><span class="line">PKMS -&gt; PKMS: scanPackageTracedLI(pkg, parseFlags, scanFlags,...)</span><br><span class="line">PKMS -&gt;PKMS: PackageParser.Package scannedPkg = scanPackageLI(childPkg, policyFlags, scanFlags..)</span><br><span class="line">PKMS -&gt;PKMS: scanPackageDirtyLI(pkg, policyFlags, scanFlags...)</span><br><span class="line">PKMS -&gt; PKMS: return scannedPkg</span><br><span class="line">PKMS -&gt; PKMS: updateSettingsLI(newPackage, installerPackageName)</span><br><span class="line">PKMS -&gt; PKMS: prepareAppDataAfterInstallLIF(newPackage)</span><br><span class="line">end</span><br><span class="line">PKMS-&gt;PackageSettingBase: res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds()</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>分解下安装流程,分成10个步骤:</p>
<h4 id="2-3-10-2-调用parsePackage方法解析AndroidManifest-xml文件"><a href="#2-3-10-2-调用parsePackage方法解析AndroidManifest-xml文件" class="headerlink" title="2.3.10.2. 调用parsePackage方法解析AndroidManifest.xml文件"></a>2.3.10.2. 调用parsePackage方法解析AndroidManifest.xml文件</h4><p>首先调用PackageParser.parsePackage方法解析AndroidManifest.xml文件，将解析结果存入Package pkg中，这部分内容在<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#parsepackage%E5%87%BD%E6%95%B0">扫描安装过程中,跳转此处</a>介绍过，此处略去。解析失败，结束安装，在res中存储返回码和返回信息，输出log。</p>
<h4 id="2-3-10-3-存入abiOverride，TEST-ONLY"><a href="#2-3-10-3-存入abiOverride，TEST-ONLY" class="headerlink" title="2.3.10.3. 存入abiOverride，TEST_ONLY"></a>2.3.10.3. 存入abiOverride，TEST_ONLY</h4><p>存入abiOverride，TEST_ONLY,  验证该APK是否只是用于测试，如果解析时该包只允许测试，而安装标志不允许测试，结束安装，在res中存储返回码和返回信息，输出log。</p>
<h4 id="2-3-10-4-证书验证"><a href="#2-3-10-4-证书验证" class="headerlink" title="2.3.10.4. 证书验证"></a>2.3.10.4. 证书验证</h4><p>如果安装参数中携带的certificates(install session中已经处理了签名)不为空,则执行populateCertificates方法,直接赋值签名</p>
<blockquote>
<p>  Populates the correct packages fields with the given certificates.This is useful when we’ve already processed the certificates [such as during package installation through an installer session]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pkg.mCertificates = certificates;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pkg.mSignatures = convertToSignatures(certificates);</span><br><span class="line">&#125; </span><br><span class="line">pkg.mSigningKeys = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;(certificates.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; certificates.length; i++) &#123;</span><br><span class="line">    Certificate[] signerCerts = certificates[i];</span><br><span class="line">    <span class="type">Certificate</span> <span class="variable">signerCert</span> <span class="operator">=</span> signerCerts[<span class="number">0</span>];</span><br><span class="line">    pkg.mSigningKeys.add(signerCert.getPublicKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果安装参数中没有携带签名,或者签名的过程中在 convertToSignatures 函数中处理出错,则执行<strong>collectCertificates</strong>方法从Apk中收集签名.<br>该方法进行证书验证和ManifestDigest验证（验证AndroidManifest.xml，存入pkg.manifestDigest）, 验证失败，结束安装，在res中存储返回码和返回信息，输出log. 系统包只校验AndroidManifest.xml文件,而其他包要校验所有文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collectCertificatesInternal(pkg, parseFlags);</span><br><span class="line">collectCertificates(pkg, <span class="keyword">new</span> <span class="title class_">File</span>(pkg.baseCodePath), parseFlags);</span><br></pre></td></tr></table></figure>

<p>证书验证部分在Android7.0 上新加了V2签名校验的方案,详细资料可参考<a target="_blank" rel="noopener" href="http://www.10tiao.com/html/223/201704/2651232457/1.html">这里</a>,以及<a target="_blank" rel="noopener" href="https://source.android.com/security/apksigning/v2.html">官方资料</a></p>
<p><img src="/images/qianming.png" alt="签名校验流程图"></p>
<h5 id="2-3-10-4-1-V2签名认证"><a href="#2-3-10-4-1-V2签名认证" class="headerlink" title="2.3.10.4.1. V2签名认证"></a>2.3.10.4.1. V2签名认证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;verifyV2&quot;</span>);</span><br><span class="line">    <span class="comment">// 所以是使用  ApkSignatureSchemeV2Verifier 的verify函数进行V2签名校验的</span></span><br><span class="line">    allSignersCerts = ApkSignatureSchemeV2Verifier.verify(apkPath);</span><br><span class="line">    signatures = convertToSignatures(allSignersCerts);</span><br><span class="line">    <span class="comment">// APK verified using APK Signature Scheme v2.</span></span><br><span class="line">    <span class="comment">// V2 签名验证通过,此处将verified标志位设置为true,</span></span><br><span class="line">    verified = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ApkSignatureSchemeV2Verifier.SignatureNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// No APK Signature Scheme v2 signature found</span></span><br><span class="line">    <span class="comment">// 没有使用V2签名时, 忽略后续的步骤</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// APK Signature Scheme v2 signature was found but did not verify</span></span><br><span class="line">    <span class="comment">// V2签名校验失败,则抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PackageParserException</span>(INSTALL_PARSE_FAILED_NO_CERTIFICATES,</span><br><span class="line">            <span class="string">&quot;Failed to collect certificates from &quot;</span> + apkPath</span><br><span class="line">                    + <span class="string">&quot; using APK Signature Scheme v2&quot;</span>,</span><br><span class="line">            e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (verified) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pkg.mCertificates == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 填充pkg的  mCertificates   mSignatures   mSigningKeys   字段</span></span><br><span class="line">    pkg.mCertificates = allSignersCerts;</span><br><span class="line">    pkg.mSignatures = signatures;</span><br><span class="line">    pkg.mSigningKeys = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;(allSignersCerts.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allSignersCerts.length; i++) &#123;</span><br><span class="line">      Certificate[] signerCerts = allSignersCerts[i];</span><br><span class="line">      <span class="type">Certificate</span> <span class="variable">signerCert</span> <span class="operator">=</span> signerCerts[<span class="number">0</span>];</span><br><span class="line">      pkg.mSigningKeys.add(signerCert.getPublicKey());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Not yet done, because we need to confirm that AndroidManifest.xml exists and,</span></span><br><span class="line">  <span class="comment">// if requested, that classes.dex exists.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>V2签名校验通过的情况下,不会再进行V1签名的校验; 如果存在V2签名,但校验没通过,会抛出异常,校验未通过.</p>
<h5 id="2-3-10-4-2-V1签名校验"><a href="#2-3-10-4-2-V1签名校验" class="headerlink" title="2.3.10.4.2. V1签名校验"></a>2.3.10.4.2. V1签名校验</h5><p>关于V1签名的资料请查看<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/a27783a713f2?from=juejinim">这里, Android APK V1 签名原理</a></p>
<p>首先创建StrictJarFile的类实例,用来初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">jarFile = <span class="keyword">new</span> <span class="title class_">StrictJarFile</span>(</span><br><span class="line">        apkPath,</span><br><span class="line">        !verified, <span class="comment">// whether to verify JAR signature</span></span><br><span class="line">        IsSprdPrebuiltApp ? <span class="literal">false</span> : signatureSchemeRollbackProtectionsEnforced);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StrictJarFile</span><span class="params">(String fileName,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> verify,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> signatureSchemeRollbackProtectionsEnforced)</span></span><br><span class="line">                    <span class="keyword">throws</span> IOException, SecurityException &#123;</span><br><span class="line">        <span class="comment">// 打开 apk文件, 解压apk文件</span></span><br><span class="line">        <span class="built_in">this</span>.nativeHandle = nativeOpenJarFile(fileName);</span><br><span class="line">        <span class="built_in">this</span>.raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(fileName, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// V2签名校验失败的情况</span></span><br><span class="line">            <span class="keyword">if</span> (verify) &#123;</span><br><span class="line">                HashMap&lt;String, <span class="type">byte</span>[]&gt; metaEntries = getMetaEntries();</span><br><span class="line">                <span class="comment">// 指定 MANIFEST.MF 文件,并读取其中记录的文件保存到entries中</span></span><br><span class="line">                <span class="built_in">this</span>.manifest = <span class="keyword">new</span> <span class="title class_">StrictJarManifest</span>(metaEntries.get(JarFile.MANIFEST_NAME), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 初始化校验器, 将manifest传入校验器</span></span><br><span class="line">                <span class="built_in">this</span>.verifier = <span class="keyword">new</span> <span class="title class_">StrictJarVerifier</span>(</span><br><span class="line">                                fileName,</span><br><span class="line">                                manifest,</span><br><span class="line">                                metaEntries,</span><br><span class="line">                                signatureSchemeRollbackProtectionsEnforced);</span><br><span class="line">                Set&lt;String&gt; files = manifest.getEntries().keySet();</span><br><span class="line">                <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">                    <span class="comment">//  MANIFEST.MF 中记录的文件没有在包中,抛出异常 </span></span><br><span class="line">                    <span class="keyword">if</span> (findEntry(file) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(fileName + <span class="string">&quot;: File &quot;</span> + file + <span class="string">&quot; in manifest does not exist&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 此处将CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改,比对是在其内部的verifyCertificate函数中</span></span><br><span class="line">                isSigned = verifier.readCertificates() &amp;&amp; verifier.isSignedJar();</span><br><span class="line">              <span class="comment">// V2 签名校验通过,此处置空,表示不再进行V1的签名校验</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isSigned = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">this</span>.manifest = <span class="literal">null</span>;</span><br><span class="line">                <span class="built_in">this</span>.verifier = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>├── META-INF<br>│   ├── ANDROID_.RSA<br>│   ├── ANDROID_.SF<br>│   └── MANIFEST.MF</p>
<p>.RSA 是 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/a27783a713f2?from=juejinim#fn_lemma_ref9">PKCS#7</a> 标准格式的文件，我们只关心它所保存的以下两种数据：</p>
<blockquote>
<p>  a. 用<code>私钥</code>对 .SF 文件<code>指纹</code>进行<code>非对称加密</code>后得到的 <strong>加密数据</strong><br>  b. 携带<code>公钥</code>以及各种身份信息的 <strong>数字证书</strong></p>
</blockquote>
<p> MANIFEST.MF、CERT.SF、CERT.RSA 如何各司其职构成了 APK 的签名：</p>
<blockquote>
<p>a. 解析出 CERT.RSA 文件中的证书、公钥，解密 CERT.RSA 中的加密数据<br>b. 解密结果和 CERT.SF 的指纹进行对比，保证 CERT.SF 没有被篡改<br>c. 而 CERT.SF 中的内容再和 MANIFEST.MF 指纹对比，保证 MANIFEST.MF 文件没有被篡改<br>d. MANIFEST.MF 中的内容和 APK 所有文件指纹逐一对比，<strong>保证 APK 没有被篡改</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要校验的包放在 toVerify 的列表中</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ZipEntry&gt; toVerify = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">toVerify.add(manifestEntry);</span><br></pre></td></tr></table></figure>

<p>使用loadCertificates函数进行校验:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ZipEntry entry : toVerify) &#123;</span><br><span class="line">  <span class="keyword">final</span> Certificate[][] entryCerts = loadCertificates(jarFile, entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Certificate[][] entryCerts = loadCertificates(jarFile, entry);</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Certificate[][] loadCertificates(StrictJarFile jarFile, ZipEntry entry) <span class="keyword">throws</span> PackageParserException &#123;     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回验证entry的压缩数据流</span></span><br><span class="line">            is = jarFile.getInputStream(entry);</span><br><span class="line">            <span class="comment">// 对每个待验证的entry进行校验</span></span><br><span class="line">            readFullyIgnoringContents(is);</span><br><span class="line">            <span class="keyword">return</span> jarFile.getCertificateChains(entry);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用getInputStream函数初始化VerifierEntry结构,并返回验证item的zip的压缩数据流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">(ZipEntry ze)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getZipInputStream(ze);</span><br><span class="line">    <span class="keyword">if</span> (isSigned) &#123;</span><br><span class="line">        StrictJarVerifier.<span class="type">VerifierEntry</span> <span class="variable">entry</span> <span class="operator">=</span> verifier.initEntry(ze.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JarFileInputStream</span>(is, ze.getSize(), entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line">VerifierEntry <span class="title function_">initEntry</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="comment">// 之前传入了MANIFEST.MF文件的句柄,即如果该文件中没有该验证item的记录,直接退出</span></span><br><span class="line">  Attributes  = manifest.getAttributes(name);</span><br><span class="line">  <span class="comment">// entry has no digest</span></span><br><span class="line">  <span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ArrayList&lt;Certificate[]&gt; certChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Certificate[]&gt;();</span><br><span class="line">  <span class="comment">// signatures保存的是 MANIFEST,MF文件中记录项的数据指纹的Base64值</span></span><br><span class="line">  <span class="comment">// 如果把 MANIFEST.MF 当做是对 APK 中各个文件的 hash 记录，那么 *.SF 就是 MANIFEST.MF 及其各个条目的 hash 记录。</span></span><br><span class="line">  Iterator&lt;Map.Entry&lt;String, HashMap&lt;String, Attributes&gt;&gt;&gt; it = signatures.entrySet().iterator();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, HashMap&lt;String, Attributes&gt;&gt; entry = it.next();</span><br><span class="line">    HashMap&lt;String, Attributes&gt; hm = entry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (hm.get(name) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Found an entry for entry name in .SF file</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">signatureFile</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">      Certificate[] certChain = certificates.get(signatureFile);</span><br><span class="line">      <span class="keyword">if</span> (certChain != <span class="literal">null</span>) &#123;</span><br><span class="line">        certChains.add(certChain);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// entry is not signed</span></span><br><span class="line">  <span class="keyword">if</span> (certChains.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Certificate[][] certChainsArray = certChains.toArray(<span class="keyword">new</span> <span class="title class_">Certificate</span>[certChains.size()][]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DIGEST_ALGORITHMS.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历算法, 目前是这几个 &quot;SHA-512&quot;, &quot;SHA-384&quot;, &quot;SHA-256&quot;, &quot;SHA1&quot;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> DIGEST_ALGORITHMS[i];</span><br><span class="line">    <span class="comment">// 清单文件中记录了采用的算法计算指纹信息(比较常用的是 SHA1-Digest),可打开MANIFEST.MF文件查看</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> attributes.getValue(algorithm + <span class="string">&quot;-Digest&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VerifierEntry</span>(name, MessageDigest.getInstance(algorithm), hashBytes,</span><br><span class="line">                               certChainsArray, verifiedEntries);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用readFullyIgnoringContents函数,读取待验证entry文件的数据流,对每个待验证entry进行校验,即和计算该文件的数字指纹和清单中记录的hash值进行比对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取完毕后,进行校验</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    entry.verify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">verify</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span>[] d = digest.digest();</span><br><span class="line">  <span class="keyword">if</span> (!MessageDigest.isEqual(d, Base64.decode(hash))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> invalidDigest(JarFile.MANIFEST_NAME, name, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 校验通过后,放进上一步初始化的VerifierEntry中,以entry的name为索引,name是验证文件的名称</span></span><br><span class="line">  verifiedEntries.put(name, certChains);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果校验失败,此时verifiedEntries为空,在loadCertificates后进行检查,为空时抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Certificate[][] entryCerts = loadCertificates(jarFile, entry);</span><br><span class="line"> <span class="keyword">if</span> (ArrayUtils.isEmpty(entryCerts)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PackageParserException</span>(INSTALL_PARSE_FAILED_NO_CERTIFICATES,</span><br><span class="line">             <span class="string">&quot;Package &quot;</span> + apkPath + <span class="string">&quot; has no certificates at entry &quot;</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-10-5-判断是应用升级的情况"><a href="#2-3-10-5-判断是应用升级的情况" class="headerlink" title="2.3.10.5. 判断是应用升级的情况"></a>2.3.10.5. 判断是应用升级的情况</h4><p>即installFlags携带INSTALL_REPLACE_EXISTING(adb 安装时指定了-r参数)</p>
<ol>
<li>在mSettings.mRenamedPackages中查找该包名,如果能够查找到返回旧的包名,再检查Package的mOriginalPackages,如果 pkg的 mOriginalPackages 包含该旧包名,且该旧包能在PKMS.mPackages中查到,则说明该包已经安装,此时为应用升级的情况.在这种情况下,需更新当前的包名为旧包的包名,以及更新其所属组件的关联的packageName名称,并将replace标记标为true.</li>
<li>直接在PKMS.mPackages查找到了该包,说明包已经安装,只需要将replace设置为true</li>
</ol>
<p>当replace为true时,检查版本号,在AndroidN版本上,如果新安装的包sdk小于22,而已安装的 &gt;&#x3D;22,跳出安装流程,不能从支持runtimepermission的跳到不支持的版本上</p>
<h4 id="2-3-10-6-当Packages-xml中存在package的记录时-比对签名"><a href="#2-3-10-6-当Packages-xml中存在package的记录时-比对签名" class="headerlink" title="2.3.10.6. 当Packages.xml中存在package的记录时,比对签名"></a>2.3.10.6. 当Packages.xml中存在package的记录时,比对签名</h4><blockquote>
<p>  Quick sanity check that we’re signed correctly if updating; we’ll check this again later when scanning, but we want to bail early here before tripping over redefined permissions.</p>
</blockquote>
<p>upgradeKeySets 这一项来自于解析AndroidManifest.xml节点的key-sets项,一般情况下,不会配置该项.</p>
<blockquote>
<p>  当旧包记录中keySetData不为空时,比对当前包中mSigningKeys是否包含这一项,包含则通过检查,没有包含,则设置错误提示退出安装.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 KeySetManagerService 查看是否使用了有效的 upgradeKeySets</span></span><br><span class="line"><span class="keyword">if</span> (shouldCheckUpgradeKeySetLP(ps, scanFlags)) &#123;</span><br><span class="line">    <span class="comment">// 比对签名未通过时,提示并退出安装</span></span><br><span class="line">    <span class="keyword">if</span> (!checkUpgradeKeySetLP(ps, pkg)) &#123;</span><br><span class="line">        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, <span class="string">&quot;Package &quot;</span></span><br><span class="line">                + pkg.packageName + <span class="string">&quot; upgrade keys do not match the &quot;</span></span><br><span class="line">                + <span class="string">&quot;previously installed version&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        verifySignaturesLP(ps, pkg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">        res.setError(e.error, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">shouldCheckUpgradeKeySetLP</span><span class="params">(PackageSetting oldPs, <span class="type">int</span> scanFlags)</span> &#123;</span><br><span class="line">  <span class="comment">// Can&#x27;t rotate keys during boot or if sharedUser.</span></span><br><span class="line">  <span class="comment">// olgPs为存在packages.xml中的记录, 如果其有shareUserId, 返回false</span></span><br><span class="line">  <span class="keyword">if</span> (oldPs == <span class="literal">null</span> || (scanFlags&amp;SCAN_INITIAL) != <span class="number">0</span> || oldPs.sharedUser != <span class="literal">null</span></span><br><span class="line">      || !oldPs.keySetData.isUsingUpgradeKeySets()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app is using upgradeKeySets; make sure all are valid</span></span><br><span class="line">  <span class="comment">// 使用 KeySetManagerService 查看是否使用了有效的 upgradeKeySets</span></span><br><span class="line">  <span class="type">KeySetManagerService</span> <span class="variable">ksms</span> <span class="operator">=</span> mSettings.mKeySetManagerService;</span><br><span class="line">  <span class="type">long</span>[] upgradeKeySets = oldPs.keySetData.getUpgradeKeySets();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; upgradeKeySets.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ksms.isIdValidKeySetId(upgradeKeySets[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo:  通过checkUpgradeKeySetLP函数比对当前包的mSigningKeys 中是否包含 记录中的 KeySet对应的 public-key项,校验失败设置错误提示,退出安装</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key-sets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key-set</span> <span class="attr">android:name</span>=<span class="string">&quot;AB&quot;</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">public-key</span> <span class="attr">android:name</span>=<span class="string">&quot;keyA&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:value</span>=<span class="string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwf5zJblvYSB7Ym7or/7GggAAu7mp7RrykPJsXhod8doFhVT5s7eF3A4MCE55vvANP7HvwMw2b+T6qx7Pq0VJtbbSDtlBHBtIc47Pjq0CsDg590BUcgKp7PdJ9J6UVgtzDnV6cGEpXmSag3sY+lqiW04ytPhCVwzYTWGdYe9+TIl47cBrveRfLOlGrcuFQe+zCTmDFqzBKCRHK9b7l5PDWvXXyg65Uu/MBUA/TZWO0fEqOlxZG/nn6DUKQLhPdmJRXWJ3WqMNMhJGD+nKtkmdX703xRqmg4h+6g0S7M9Y3IQ2NUGyw05AYzCguHB/Mv6uVIiW659wpbyb45TgKG3UhQIDAQAB&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">public-key</span> <span class="attr">android:name</span>=<span class="string">&quot;keyB&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:value</span>=<span class="string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoeFZqMqTbZiozFTXMkXtSKJRzn2qODZgvVXAAwKTi50xYcbPcHTfKxtif8+q7OCp/50JYDH32bg6wkUunn5+dEaHkxZY8d7uw46tQtl5dNGi+6cc4MezVLCS6nkqNDusAgdvgLU6Fl6SGi02KTp1vkt6CwLO977YJP7kt9ouDRTG7ASJiq3OyRRoOqYHhD9gpsbUq4w+1bXGfuuZujA1dXyovXtvrHUGOdFIEBYOVYGfCcwh3lXPmjNJMlHtKQkurq8/LH7a1B5ocoXCGsyR8YHdlWfrqRAfzgOB1KCnNNmWqskU9LOci3uQn9IDeMEFmAd8FqF8SwV+4Ludk/xWGQIDAQAB&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">key-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">upgrade-key-set</span> <span class="attr">android:name</span>=<span class="string">&quot;AB&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">key-sets</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  旧包中keySetData项为空, 可以查看Packages.xml文件,对应的标签为upgrade-keyset, 没有该项,则通过<code>verifySignaturesLP</code>函数进行签名比对</p>
</blockquote>
<h5 id="2-3-10-6-1-verifySignaturesLP-进行签名比对-新老安装包"><a href="#2-3-10-6-1-verifySignaturesLP-进行签名比对-新老安装包" class="headerlink" title="2.3.10.6.1. verifySignaturesLP 进行签名比对(新老安装包)"></a>2.3.10.6.1. verifySignaturesLP 进行签名比对(新老安装包)</h5><p>在mSettings.mPackages中存在该包, 需要比对该包的签名和现在解析的包的签名进行比对.签名不一致,退出安装.</p>
<blockquote>
<p>  关于databaseVersion项在<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms1/#settings%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8">启动篇</a>介绍过, 对于private volume. databaseVersion的值总是3,而public volume的值往往等于sdkVersion.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先记录中包的签名不为空</span></span><br><span class="line"><span class="keyword">if</span> (pkgSetting.signatures.mSignatures != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already existing package. Make sure signatures match</span></span><br><span class="line">    <span class="comment">// Make sure s2 contains all signatures in s1. 这个函数比较简单,只是简单的比对是否   s1 和 s2 完全相同</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures)</span><br><span class="line">            == PackageManager.SIGNATURE_MATCH;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">        <span class="comment">// 这个地方上来检测 pkg安装到的 volume 对应的databaseVersion是否小于2, 不小于2的情况下,直接退出.所以后面的流程都没走.</span></span><br><span class="line">        match = compareSignaturesCompat(pkgSetting.signatures, pkg)</span><br><span class="line">                == PackageManager.SIGNATURE_MATCH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">        <span class="comment">// 这个地方上来检测 pkg安装到的 volume 对应的databaseVersion是否小于3, 不小于3的情况下,直接退出.所以后面的流程都没走.</span></span><br><span class="line">        match = compareSignaturesRecover(pkgSetting.signatures, pkg)</span><br><span class="line">                == PackageManager.SIGNATURE_MATCH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PackageManagerException</span>(INSTALL_FAILED_UPDATE_INCOMPATIBLE, <span class="string">&quot;Package &quot;</span></span><br><span class="line">                + pkg.packageName + <span class="string">&quot; signatures do not match the &quot;</span></span><br><span class="line">                + <span class="string">&quot;previously installed version; ignoring!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来检测shareUser的签名,即如果应用指定了shareUserId项,可将指定shareUser的项看作同类的包,需要挨个检测签名是否一致,以出现的第一个包的签名为基准.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for shared user signatures</span></span><br><span class="line"><span class="keyword">if</span> (pkgSetting.sharedUser != <span class="literal">null</span> &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already existing package. Make sure signatures match</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,</span><br><span class="line">            pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以追溯pkgSetting.sharedUser.signatures.mSignatures第一次被赋值的地方.</p>
<p>在<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8C%85%E5%92%8C%E5%8C%85%E4%BF%A1%E6%81%AF">scanPackageDirtyLI函数处</a>调用了mSettings.insertPackageSettingLPw(pkgSetting, pkg) 函数,此处检测shareUser的签名如果为空,会更新为当前扫描包的签名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If this app defines a shared user id initialize</span></span><br><span class="line"><span class="comment">// the shared user signatures as well.</span></span><br><span class="line"><span class="keyword">if</span> (p.sharedUser != <span class="literal">null</span> &amp;&amp; p.sharedUser.signatures.mSignatures == <span class="literal">null</span>) &#123;</span><br><span class="line">    p.sharedUser.signatures.assignSignatures(pkg.mSignatures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-10-7-验证权限"><a href="#2-3-10-7-验证权限" class="headerlink" title="2.3.10.7. 验证权限"></a>2.3.10.7. 验证权限</h4><p>如果从apk中解析到的权限信息，在之前已经定义过，即mSettings.mPermissions包含该权限名，那么首先验证签名信息是否符合（升级包时，一般包），签名符合继续安装流程；签名不符合时，如果冲突的权限来自framework-res.apk，删除当前apk冲突的权限，继续安装流程，否则终止安装。</p>
<p>如果不是framework-res.apk包,需要其定义的权限是否为PROTECTION_DANGEROUS权限, 如果是dangerous权限,但已经存在的同名权限的类型为非dangerous的权限,则需要变更当前权限的protectionLevel为记录中的protectionLevel</p>
<p>原因是防止特权扩大,如某应用在其他应用组中添加了该权限,如果重新定义该权限名称为dangerous权限,则会导致之前的应用组的该权限被默认授权.??</p>
<h4 id="2-3-10-8-更新指令集以及拷贝本地库并执行dexopt优化"><a href="#2-3-10-8-更新指令集以及拷贝本地库并执行dexopt优化" class="headerlink" title="2.3.10.8. 更新指令集以及拷贝本地库并执行dexopt优化"></a>2.3.10.8. 更新指令集以及拷贝本地库并执行dexopt优化</h4><p>可以参考<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#%E5%A4%84%E7%90%86%E6%9C%AC%E5%9C%B0%E5%BA%93%E7%9B%AE%E5%BD%95">处理本地库目录</a>, 以及<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#%E4%B8%BA%E9%9D%9E%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0%E5%85%B1%E4%BA%AB%E5%BA%93%E4%BF%A1%E6%81%AF">为非系统应用更新共享库信息</a>. </p>
<p>由于本地库目录的变更, 一些应用可能使用到了此库,所以需要更新这些应用的usesLibraries项,更新路径信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123;</span><br><span class="line">    <span class="comment">// Enable SCAN_NO_DEX flag to skip dexopt at a later stage</span></span><br><span class="line">    scanFlags |= SCAN_NO_DEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">abiOverride</span> <span class="operator">=</span> (TextUtils.isEmpty(pkg.cpuAbiOverride) ?</span><br><span class="line">            args.abiOverride : pkg.cpuAbiOverride);</span><br><span class="line">        derivePackageAbi(pkg, <span class="keyword">new</span> <span class="title class_">File</span>(pkg.codePath), abiOverride,</span><br><span class="line">                <span class="literal">true</span> <span class="comment">/* extract libs */</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManagerException pme) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Error deriving application ABI&quot;</span>, pme);</span><br><span class="line">        res.setError(INSTALL_FAILED_INTERNAL_ERROR, <span class="string">&quot;Error deriving application ABI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shared libraries for the package need to be updated.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 更新pkg.usesLibraries项,更新路径信息</span></span><br><span class="line">            updateSharedLibrariesLPw(pkg, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;updateSharedLibrariesLPw failed: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">    <span class="comment">// Do not run PackageDexOptimizer through the local performDexOpt</span></span><br><span class="line">    <span class="comment">// method because `pkg` may not be in `mPackages` yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Also, don&#x27;t fail application installs if the dexopt step fails.  // 失败并不退出</span></span><br><span class="line">    mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* instructionSets */</span>, <span class="literal">false</span> <span class="comment">/* checkProfiles */</span>,</span><br><span class="line">            getCompilerFilterForReason(REASON_INSTALL));</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-10-9-目录更名"><a href="#2-3-10-9-目录更名" class="headerlink" title="2.3.10.9. 目录更名"></a>2.3.10.9. 目录更名</h4><p>调用FileInstallArgs.doRename方法，将&#x2F;data&#x2F;app&#x2F;vmdl&lt;随机整数&gt;.tmp目录更名为&#x2F;data&#x2F;app&#x2F;packageName-num，num的值在1和2之间循环取值，同时还要更新FileInstallArgs和Package pkg相关的路径信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">doRename</span><span class="params">(<span class="type">int</span> status, PackageParser.Package pkg, String oldCodePath)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">targetDir</span> <span class="operator">=</span> codeFile.getParentFile();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">beforeCodeFile</span> <span class="operator">=</span> codeFile;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">afterCodeFile</span> <span class="operator">=</span> getNextCodePath(targetDir, pkg.packageName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, <span class="string">&quot;Renaming &quot;</span> + beforeCodeFile + <span class="string">&quot; to &quot;</span> + afterCodeFile);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 重新设置Selinux上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!SELinux.restoreconRecursive(afterCodeFile)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed to restorecon&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflect the rename internally</span></span><br><span class="line">    codeFile = afterCodeFile;</span><br><span class="line">    resourceFile = afterCodeFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflect the rename in scanned details</span></span><br><span class="line">    pkg.setCodePath(afterCodeFile.getAbsolutePath());</span><br><span class="line">    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile,</span><br><span class="line">            afterCodeFile, pkg.baseCodePath));</span><br><span class="line">    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile,</span><br><span class="line">            afterCodeFile, pkg.splitCodePaths));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reflect the rename in app info</span></span><br><span class="line">    pkg.setApplicationVolumeUuid(pkg.volumeUuid);</span><br><span class="line">    pkg.setApplicationInfoCodePath(pkg.codePath);</span><br><span class="line">    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);</span><br><span class="line">    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);</span><br><span class="line">    pkg.setApplicationInfoResourcePath(pkg.codePath);</span><br><span class="line">    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);</span><br><span class="line">    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冻结应用,杀死进程.但如果安装参数中携带了INSTALL_DONT_KILL_APP标记时,不会杀掉该进程.</p>
<p>更名完毕后，根据是全新安装还是覆盖安装，执行<a href="#%E5%85%A8%E6%96%B0%E5%AE%89%E8%A3%85">全新安装installNewPackageLI</a>或<a href="#%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85">覆盖安装replacePackageLIF方法</a>。</p>
<h4 id="2-3-10-10-覆盖安装"><a href="#2-3-10-10-覆盖安装" class="headerlink" title="2.3.10.10. 覆盖安装"></a>2.3.10.10. 覆盖安装</h4><p>replacePackageLIF函数进行覆盖安装</p>
<p>首先，对于重复安装时先比对 新包和 已安装包的签名信息是否匹配，对于升级安装时验证新包是否包含旧包的所有签名密钥，失败直接返回，停止覆盖安装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// verify signatures are valid</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">ps</span> <span class="operator">=</span> mSettings.mPackages.get(pkgName);</span><br><span class="line"><span class="keyword">if</span> (shouldCheckUpgradeKeySetLP(ps, scanFlags)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkUpgradeKeySetLP(ps, pkg)) &#123;</span><br><span class="line">        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,</span><br><span class="line">                <span class="string">&quot;New package not signed by keys specified by upgrade-keysets: &quot;</span></span><br><span class="line">                        + pkgName);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default to original signature matching</span></span><br><span class="line">    <span class="keyword">if</span> (compareSignatures(oldPackage.mSignatures, pkg.mSignatures)</span><br><span class="line">            != PackageManager.SIGNATURE_MATCH) &#123;</span><br><span class="line">        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,</span><br><span class="line">                <span class="string">&quot;New package has a different signature: &quot;</span> + pkgName);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果旧包的restrictUpdateHash字段不为空,且旧包为system app时,需要对apk进行MD校验, 只有当apk的md值等于该restrictUpdateHash字段的值时,才允许升级.</p>
<p>该字段来自于解析apk的Manifest节点, restrict-update  : android:hash.</p>
<blockquote>
<p>  don’t allow a system upgrade unless the upgrade hash matches</p>
</blockquote>
<p>接下来检查新老包的shareUserid有没有发生变化,包括其parent和child包的也要一并检查.如果shareUserId变化了,提示错误,退出安装.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for shared user id changes</span></span><br><span class="line"><span class="type">String</span> <span class="variable">invalidPackageName</span> <span class="operator">=</span></span><br><span class="line">        getParentOrChildPackageChangedSharedUser(oldPackage, pkg);</span><br><span class="line"><span class="keyword">if</span> (invalidPackageName != <span class="literal">null</span>) &#123;</span><br><span class="line">    res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE,</span><br><span class="line">            <span class="string">&quot;Package &quot;</span> + invalidPackageName + <span class="string">&quot; tried to change user &quot;</span></span><br><span class="line">                    + oldPackage.mSharedUserId);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询为哪些用户安装了旧包,并保存起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installedUsers = ps.queryInstalledUsers(allUsers, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>更新PackageInstalledInfo.removedInfo信息</p>
<p><span id="removedInfo">对应于PackageRemovedInfo removedInfo类</p>
<p>最后根据apk的类型进行系统级&#x2F;非系统级替换安装：</p>
<h5 id="2-3-10-10-1-非系统级apk覆盖安装"><a href="#2-3-10-10-1-非系统级apk覆盖安装" class="headerlink" title="2.3.10.10.1. 非系统级apk覆盖安装"></a>2.3.10.10.1. 非系统级apk覆盖安装</h5><p>调用replaceNonSystemPackageLIF方法进行非系统级apk的覆盖安装，与全新安装的区别主要是，在安装前会先删除内部数据结构信息，从而可以进行扫描安装：</p>
<p>首先，调用deletePackageLI方法删除已安装apk的数据结构信息，但是保留数据目录。对于ForwardLocked&#x2F;External（是否忘记porting InternalSd）类型的apk，在杀死该应用前发送一个广播，使用户可以放弃资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;upgrading pkg &quot;</span> + deletedPackage + <span class="string">&quot; is ASEC-hosted -&gt; UNAVAILABLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] uidArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; deletedPackage.applicationInfo.uid &#125;;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; pkgList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">    pkgList.add(deletedPackage.applicationInfo.packageName);</span><br><span class="line">    <span class="comment">//  mediaStatus为false, 发送android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE的广播</span></span><br><span class="line">    sendResourcesChangedBroadcast(<span class="literal">false</span>, <span class="literal">true</span>, pkgList, uidArray, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<span id="clearAppDataLIF">clearAppDataLIF方法清除所有用户下的该应用的DE区和CE区的&#x2F;code_cache目录.(通过installd完成)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE</span><br><span class="line">        | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br></pre></td></tr></table></figure>

<p>调用<span id="clearAppProfilesLIF">clearAppProfilesLIF方法清除   &#x2F;data&#x2F;misc&#x2F;profiles&#x2F;ref&#x2F;<packageName>&#x2F;primary.prof 文件和</p>
<p>清除所有用户下的该文件    &#x2F;data&#x2F;misc&#x2F;profiles&#x2F;cur&#x2F;<userid>&#x2F;<packageName>&#x2F;primary.prof </p>
<p>接下来执行的步骤和全新安装流程基本相同, 即执行<span id="scanPackageTracedLI">scanPackageTracedLI进入<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#scanpackageli%E5%87%BD%E6%95%B0">scanPackageLI方法</a>扫描安装apk,调用updateSettingsLI方法(主要调用了updateSettingsInternalLI方法)，将新安装的apk信息更新到packages.xml中.<a href="#newinstall">跳转到此</a></p>
<p>但是需要更新新安装包PackageSetting的oldCodePaths字段(携带<code>SCAN_DONT_KILL_APP</code>标志时,即不杀应用时),该字段保存了旧包的安装包baseapk即splitapk的路径, 新安装包的子包的此字段也需要同步更新.</p>
<p>至此，非系统级apk覆盖安装结束，最终回到installPackageLI中。</p>
<h5 id="2-3-10-10-2-系统级apk覆盖安装"><a href="#2-3-10-10-2-系统级apk覆盖安装" class="headerlink" title="2.3.10.10.2. 系统级apk覆盖安装"></a>2.3.10.10.2. 系统级apk覆盖安装</h5><p>调用replaceSystemPackageLIF函数进行系统级apk的覆盖安装</p>
<blockquote>
<p>  首先需要调用removePackageLI方法清除旧包的数据结构信息:  从PackageManagerService.mPackages中清除已安装的系统包，接着调用<code>cleanPackageDataStructuresLILPw</code>从PackageManagerService.mProviders&#x2F;mServices&#x2F;mActivities等组件中清除旧包所包含的组件信息；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">removePackageLI(deletedPackage, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removePackageLI</span><span class="params">(PackageSetting ps, <span class="type">boolean</span> chatty)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">    mPackages.remove(ps.name);</span><br><span class="line">    <span class="keyword">final</span> PackageParser.<span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> ps.pkg;</span><br><span class="line">    <span class="keyword">if</span> (pkg != <span class="literal">null</span>) &#123;</span><br><span class="line">      cleanPackageDataStructuresLILPw(pkg, chatty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  接着，调用mSettings.<code>disableSystemPackageLPw</code>方法将已安装的包信息disabled：先根据包名查询mSettings.mDisabledSysPackages是否存在包信息，如果存在，直接返回false；不存在，更改标志为FLAG_UPDATED_SYSTEM_APP，将已安装的包信息添加到mSettings.mDisabledSysPackages中，并根据已安装的包信息创建一个新的备份，用这个备份来更替换mSettings.mPackages的包信息，以及替换共享用户的包信息&#x2F;mSettings.mUserIds或mSettings.mOtherUserIds（即，要保留原始安装包信息，只对备份修改）：</p>
</blockquote>
<p>省略了子包的相关操作….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将已安装的包信息disabled</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">disabled</span> <span class="operator">=</span> mSettings.disableSystemPackageLPw(oldPkg.packageName, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">disableSystemPackageLPw</span><span class="params">(String name, <span class="type">boolean</span> replaced)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">p</span> <span class="operator">=</span> mPackages.get(name);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">dp</span> <span class="operator">=</span> mDisabledSysPackages.get(name);</span><br><span class="line">        <span class="comment">// always make sure the system package code and resource paths dont change</span></span><br><span class="line">        <span class="comment">// !isUpdatedSystemApp   // 没有被标记为   FLAG_UPDATED_SYSTEM_APP 的情况下,  初始情况下,就是没有被标记的</span></span><br><span class="line">        <span class="keyword">if</span> (dp == <span class="literal">null</span> &amp;&amp; p.pkg != <span class="literal">null</span> &amp;&amp; p.pkg.isSystemApp() &amp;&amp; !p.pkg.isUpdatedSystemApp()) &#123;</span><br><span class="line">            <span class="comment">// 进入此条件的前提是当前替换的旧包在不在系统禁用包中,  即在mDisabledSysPackages中</span></span><br><span class="line">            <span class="keyword">if</span>((p.pkg != <span class="literal">null</span>) &amp;&amp; (p.pkg.applicationInfo != <span class="literal">null</span>)) &#123;</span><br><span class="line">                p.pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将旧包加入到系统禁用包中</span></span><br><span class="line">            mDisabledSysPackages.put(name, p);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replaced) &#123;</span><br><span class="line">                <span class="comment">// a little trick...  when we install the new package, we don&#x27;t</span></span><br><span class="line">                <span class="comment">// want to modify the existing PackageSetting for the built-in</span></span><br><span class="line">                <span class="comment">// version.  so at this point we need a new PackageSetting that</span></span><br><span class="line">                <span class="comment">// is okay to muck with.</span></span><br><span class="line">                <span class="comment">// 创建新的packageSetting, 因为升级的是系统包,不再使用之前的旧的PackageSetting</span></span><br><span class="line">                <span class="type">PackageSetting</span> <span class="variable">newp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageSetting</span>(p);</span><br><span class="line">                <span class="comment">// 将和name绑定的PackageSetting替换为现在新创建的PackageSetting</span></span><br><span class="line">                replacePackageLPw(name, newp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>旧包没在mDisabledSysPackages中时,说明原先的包是安装状态,需要填充PackageInstalledInfo.PackageRemovedInfo信息. 调用createInstallArgsForExisting方法生成这个信息,  We need to make sure to delete the older one’s .apk.</p>
<blockquote>
<p>  执行<a href="#clearAppDataLIF">clearAppDataLIF</a> 和 <a href="#clearAppProfilesLIF">clearAppProfilesLIF</a> 清除codecache和primary.prof 文件;</p>
<p>  设置ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志,通过isUpdatedSystemApp查询时返回true</p>
<p>  执行scanPackageTracedLI(#scanPackageTracedLI)函数进行安装.</p>
<p>  设置应用的<a href="#https://cototem.github.io/2017/08/02/pkms1/#firstInstallTime">安装时间和更新时间</a>firstInstallTime   lastUpdateTime, 还有子包的</p>
<p>  遍历当前包的所有子包,检查更新包的子包是否和旧包的子包相同. 旧包子包没有在更新包中,需要将该包删除(从mPackages中清除,并包括组件信息等),并清除数据(不止是codecache,没有<code>DELETE_KEEP_DATA</code>标志的前提下)</p>
<p>  调用updateSettingsLI方法(主要调用了<a href="#updateSettingsInternalLI">updateSettingsInternalLI</a>方法)，将新安装的apk信息更新到packages.xml中</p>
<p>  调用<a href="#prepareAppDataAfterInstallLIF">prepareAppDataAfterInstallLIF方法</a>为新安装的包准备数据目录</p>
</blockquote>
<p>如果安装失败，调用removeInstalledPackageLI删除新的包，扫描恢复旧的安装包，若是第一次更新从mSettings.mDisabledSysPackages删除旧的包信息，更新安装的包名，并再次更新packages.xml文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.returnCode != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">    <span class="comment">// Re installation failed. Restore old information</span></span><br><span class="line">    <span class="comment">// Remove new pkg information</span></span><br><span class="line">    <span class="keyword">if</span> (newPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">        removeInstalledPackageLI(newPackage, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add back the old system package</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新扫描旧包</span></span><br><span class="line">        scanPackageTracedLI(deletedPackage, policyFlags, SCAN_UPDATE_SIGNATURE, <span class="number">0</span>, user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Failed to restore original package: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// 此标志为true,说明是第一次更新时,上述步骤中将旧包禁用 (使用disableSystemPackageLPw方法禁用的,此时要重新启用回来)</span></span><br><span class="line">        <span class="keyword">if</span> (disabledSystem) &#123;</span><br><span class="line">            enableSystemPackageLPw(deletedPackage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the installer package name up to date</span></span><br><span class="line">        <span class="comment">// 设置应用的安装时间和更新时间firstInstallTime   lastUpdateTime, 还有子包的</span></span><br><span class="line">        setInstallerPackageNameLPw(deletedPackage, installerPackageName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update permissions for restored package</span></span><br><span class="line">        updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL);</span><br><span class="line">        <span class="comment">// 更新packages.xml文件</span></span><br><span class="line">        mSettings.writeLPr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，系统级apk覆盖安装完成，最终回到installPackageLI。</p>
<h4 id="2-3-10-11-全新安装"><a href="#2-3-10-11-全新安装" class="headerlink" title="2.3.10.11. 全新安装"></a>2.3.10.11. 全新安装</h4><p>调用PackageManagerService. installNewPackageLI方法执行全新安装。</p>
<p>如果当前包已安装过，即使是更名的，也结束installNewPackageLI安装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mSettings.mRenamedPackages.containsKey(pkgName)) &#123;</span><br><span class="line">    res.setError(INSTALL_FAILED_ALREADY_EXISTS, <span class="string">&quot;Attempt to re-install &quot;</span> + pkgName</span><br><span class="line">            + <span class="string">&quot; without first uninstalling package running as &quot;</span></span><br><span class="line">            + mSettings.mRenamedPackages.get(pkgName));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mPackages.containsKey(pkgName)) &#123;</span><br><span class="line">    res.setError(INSTALL_FAILED_ALREADY_EXISTS, <span class="string">&quot;Attempt to re-install &quot;</span> + pkgName</span><br><span class="line">            + <span class="string">&quot; without first uninstalling.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="newinstall">

<p>调用PackageManagerService.<a target="_blank" rel="noopener" href="https://cototem.github.io/2017/08/02/pkms2/#scanpackageli%E5%87%BD%E6%95%B0">scanPackageLI方法</a>扫描安装apk，创建数据目录，主要创建&#x2F;data&#x2F;data&#x2F;<pkgName>数据目录，和&#x2F;data&#x2F;data&#x2F;<pkgName>&#x2F;lib库文件目录，并将库目录链接到&#x2F;data&#x2F;app&#x2F;<pkgName-num>&#x2F;lib&#x2F;arm库文件目录；</p>
<p>然后调用updateSettingsLI方法(主要调用了<span id="updateSettingsInternalLI">updateSettingsInternalLI方法)，将新安装的apk信息更新到packages.xml中:</p>
<ul>
<li>首先，先更新packages.xml文件，此时该apk为安装未完成状态；</li>
<li>调用updatePermissionsLPW，为安装的apk分配权限，并将相应的gid号保存到PackageSettngs或SharedUserSetting的gids数组中；</li>
<li>更新安装状态为安装完成，和PackageInstalledInfo res的属性，重新更新packages.xml文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateSettingsInternalLI</span><span class="params">(PackageParser.Package newPackage,</span></span><br><span class="line"><span class="params">        String installerPackageName, <span class="type">int</span>[] allUsers, <span class="type">int</span>[] installedForUsers,</span></span><br><span class="line"><span class="params">        PackageInstalledInfo res, UserHandle user)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;updateSettings&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> newPackage.packageName;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// 指定安装未完成状态</span></span><br><span class="line">        mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_INCOMPLETE);</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;writeSettings&quot;</span>);</span><br><span class="line">        mSettings.writeLPr();</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, <span class="string">&quot;New package installed in &quot;</span> + newPackage.codePath);</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// 调用updatePermissionsLPW，为安装的apk分配权限，并将相应的gid号保存到PackageSettngs或SharedUserSetting的gids数组中；</span></span><br><span class="line">        updatePermissionsLPw(newPackage.packageName, newPackage,</span><br><span class="line">                UPDATE_PERMISSIONS_REPLACE_PKG | (newPackage.permissions.size() &gt; <span class="number">0</span></span><br><span class="line">                        ? UPDATE_PERMISSIONS_ALL : <span class="number">0</span>));</span><br><span class="line">        <span class="type">PackageSetting</span> <span class="variable">ps</span> <span class="operator">=</span> mSettings.mPackages.get(pkgName);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> user.getIdentifier();</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新安装的包为system app,需要重新启用之前可能禁用的组件, 因为该函数可被多个地方调用, 全新安装的情况下,是不会走到这里的</span></span><br><span class="line">            <span class="keyword">if</span> (isSystemApp(newPackage)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_INSTALL) &#123;</span><br><span class="line">                    Slog.d(TAG, <span class="string">&quot;Implicitly enabling system package on upgrade: &quot;</span> + pkgName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Enable system package for requested users</span></span><br><span class="line">                <span class="comment">// origUser不为空时,标明为覆盖安装?</span></span><br><span class="line">                <span class="keyword">if</span> (res.origUsers != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> origUserId : res.origUsers) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (userId == UserHandle.USER_ALL || userId == origUserId) &#123;</span><br><span class="line">                            ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT,</span><br><span class="line">                                    origUserId, installerPackageName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Also convey the prior install/uninstall state</span></span><br><span class="line">                <span class="keyword">if</span> (allUsers != <span class="literal">null</span> &amp;&amp; installedForUsers != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> currentUserId : allUsers) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">installed</span> <span class="operator">=</span> ArrayUtils.contains(</span><br><span class="line">                                installedForUsers, currentUserId);</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_INSTALL) &#123;</span><br><span class="line">                            Slog.d(TAG, <span class="string">&quot;    user &quot;</span> + currentUserId + <span class="string">&quot; =&gt; &quot;</span> + installed);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 重新指定安装状态, 只有installedForUsers的安装状态才为true</span></span><br><span class="line">                        ps.setInstalled(installed, currentUserId);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指定为某个用户安装, 仅为该用户安装</span></span><br><span class="line">            <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">                ps.setInstalled(<span class="literal">true</span>, userId);</span><br><span class="line">                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId, installerPackageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.name = pkgName;</span><br><span class="line">        res.uid = newPackage.applicationInfo.uid;</span><br><span class="line">        res.pkg = newPackage;</span><br><span class="line">       <span class="comment">// 更新为安装完成状态</span></span><br><span class="line">        mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_COMPLETE);</span><br><span class="line">        mSettings.setInstallerPackageName(pkgName, installerPackageName);</span><br><span class="line">        res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);</span><br><span class="line">        <span class="comment">//to update install status</span></span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;writeSettings&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新Packages.xml文件表示安装完成</span></span><br><span class="line">        mSettings.writeLPr();</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-10-11-1-准备数据目录"><a href="#2-3-10-11-1-准备数据目录" class="headerlink" title="2.3.10.11.1. 准备数据目录"></a>2.3.10.11.1. 准备数据目录</h5><p>调用prepareAppDataAfterInstallLIF<span id="prepareAppDataAfterInstallLIF">方法为新安装的包准备数据目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareAppDataAfterInstallLIF</span><span class="params">(PackageParser.Package pkg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> PackageSetting ps;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        ps = mSettings.mPackages.get(pkg.packageName);</span><br><span class="line">        <span class="comment">// 创建/config/sdcardfs/&lt;packageSetting.name&gt;/appid文件,里面写入 packageSetting.appid值</span></span><br><span class="line">        mSettings.writeKernelMappingLPr(ps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">UserManager</span> <span class="variable">um</span> <span class="operator">=</span> mContext.getSystemService(UserManager.class);</span><br><span class="line">    <span class="type">UserManagerInternal</span> <span class="variable">umInternal</span> <span class="operator">=</span> getUserManagerInternal();</span><br><span class="line">    <span class="keyword">for</span> (UserInfo user : um.getUsers()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> flags;</span><br><span class="line">        <span class="comment">// 查询用户是否解锁, 即Unlocking 或 Unlocked状态,  </span></span><br><span class="line">        <span class="keyword">if</span> (umInternal.isUserUnlockingOrUnlocked(user.id)) &#123;</span><br><span class="line">            flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (umInternal.isUserRunning(user.id)) &#123;</span><br><span class="line">            flags = StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该用户下安装了该apk, 则需要准备数据目录, 通过installd 创建目录</span></span><br><span class="line">        <span class="comment">// flag携带DE时, /data/user_de/&lt;userid&gt;/&lt;packageName&gt;/</span></span><br><span class="line">        <span class="comment">// 携带CE时, /data/user_ce/&lt;userid&gt;/&lt;packageName&gt;/</span></span><br><span class="line">        <span class="keyword">if</span> (ps.getInstalled(user.id)) &#123;</span><br><span class="line">            <span class="comment">// Whenever an app changes, force a restorecon of its data</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> when user data is locked, mark that we&#x27;re still dirty</span></span><br><span class="line">            prepareAppDataLIF(pkg, user.id, flags, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>installNewPackageLI方法完成，回到installPackageLI方法；</p>
<p>否则，调用deletePackageLI方法，删除安装的数据信息和数据&#x2F;缓存目录，除非这些目录在安装前已经存在，然后返回installPackageL方法：</p>
<h3 id="2-3-11-小结"><a href="#2-3-11-小结" class="headerlink" title="2.3.11. 小结"></a>2.3.11. 小结</h3><p>在安装完成后,更新已安装的用户id，保存到res的newUsers中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">ps</span> <span class="operator">=</span> mSettings.mPackages.get(pkgName);</span><br><span class="line"><span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">    res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，InstallPackageLI方法结束，回到<a href="#processPendingInstall">processPendingInstall</a>方法继续处理。</p>
<h3 id="2-3-12-processPendingInstall方法后续处理"><a href="#2-3-12-processPendingInstall方法后续处理" class="headerlink" title="2.3.12. processPendingInstall方法后续处理"></a>2.3.12. processPendingInstall方法后续处理</h3><p>installPackageLI安装完成后，首先调用args.doPostInstall方法，确保当安装失败时删除复制的apk、资源和库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A restore should be performed at this point if (a) the install</span></span><br><span class="line"><span class="comment">// succeeded, (b) the operation is not an update, and (c) the new</span></span><br><span class="line"><span class="comment">// package has not opted out of backup participation.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  根据之前的记录的<a href="#removedInfo">RemoveInfo</a>的信息, 覆盖安装的情况下,此信息才不为空.</p>
<p>  当removeinfo为空(全新安装的情况),且安装包对应的applicationinfo中有FLAG_ALLOW_BACKUP标记时(来自于Manifest),   doRestore为true</p>
</blockquote>
<p>doRestore为true时,连接BACKUP_SERVICE,执行BackupManagerService.restoreAtInstall方法, 最终执行到 PerformUnifiedRestoreTask 的execute方法, startRestore方法  ??  </p>
<p>接着，将安装次序和安装信息保存到PackageManangerService.mRunningInstalls中：（mNextInstallToken&gt;&#x3D;1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">token = mNextInstallToken++;</span><br><span class="line"><span class="type">PostInstallData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PostInstallData</span>(args, res);</span><br><span class="line">mRunningInstalls.put(token, data);      <span class="comment">//以安装次序为key 保存了 PostInstallData对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PostInstallData</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> InstallArgs args;</span><br><span class="line">        <span class="keyword">public</span> PackageInstalledInfo res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>doRestore为false的情况下,   即覆盖安装的情况下, 或者前面的restoreAtInstall方法执行错误的情况(可能是没有 BackupManagerService , 或连接不上时)</p>
<p>执行POST_INSTALL阶段</p>
<h3 id="2-3-13-POST-INSTALL阶段-处理POST-INSTALL消息"><a href="#2-3-13-POST-INSTALL阶段-处理POST-INSTALL消息" class="headerlink" title="2.3.13. POST_INSTALL阶段(处理POST_INSTALL消息)"></a>2.3.13. POST_INSTALL阶段(处理POST_INSTALL消息)</h3><p>这部分主要发送一些安装成功的广播，可以被launcher接收，在桌面添加图表等操作，并回调Observer安装成功的接口，具体处理流程如下：</p>
<p>从mRunningInstalls中取出之前保存的 PostInstallData对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PostInstallData</span> <span class="variable">data</span> <span class="operator">=</span> mRunningInstalls.get(msg.arg1);</span><br><span class="line"><span class="comment">// 此时传来的 arg2 参数为空</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">didRestore</span> <span class="operator">=</span> (msg.arg2 != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">InstallArgs</span> <span class="variable">args</span> <span class="operator">=</span> data.args;</span><br><span class="line">  <span class="type">PackageInstalledInfo</span> <span class="variable">parentRes</span> <span class="operator">=</span> data.res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">grantPermissions</span> <span class="operator">=</span> (args.installFlags</span><br><span class="line">                                    &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">killApp</span> <span class="operator">=</span> (args.installFlags</span><br><span class="line">                           &amp; PackageManager.INSTALL_DONT_KILL_APP) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> String[] grantedPermissions = args.installGrantPermissions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle the parent package</span></span><br><span class="line">  handlePackagePostInstall(parentRes, grantPermissions, killApp,</span><br><span class="line">                           grantedPermissions, didRestore, args.installerPackageName,</span><br><span class="line">                           args.observer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle the child packages</span></span><br><span class="line">   ... 省略子包的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-13-1-handlePackagePostInstall函数的处理"><a href="#2-3-13-1-handlePackagePostInstall函数的处理" class="headerlink" title="2.3.13.1. handlePackagePostInstall函数的处理"></a>2.3.13.1. handlePackagePostInstall函数的处理</h4><p>主要看handlePackagePostInstall的实现, 该函数中第一个参数为  PackageInstalledInfo ,   该参数为之前保存安装结果的result, 里面保存了错误类型,安装进度,removedinfo信息等.</p>
<blockquote>
<p>  如果其中removedInfo不为空,发送android.intent.action.PACKAGE_REMOVED的广播,提示旧包被删除,广播中携带参数killapp(是否杀掉相应进程)</p>
<p>  a. 如果对应的removedinfo中的dataRemoved为true, 且不是删除的system app, 则另外发送android.intent.action.PACKAGE_FULLY_REMOVED的广播</p>
<p>  如果对应的removedAppId&gt;&#x3D;0,发送android.intent.action.UID_REMOVED的广播,  在前面的步骤中,removedAppId赋值是在覆盖系统包时,如果系统包旧包含有子包的情况下,且旧包的某子包未在新安装的包的子包中时,会涉及到该种情况</p>
</blockquote>
<p>如果携带的参数中包含grantPermissions, 赋予运行时权限,并更新packages.list文件</p>
<p>如果其parent包不为空,查看parent包是否在mDisabledSysPackages 禁用包中, 且该包为特权包, 给其赋予申请的运行时权限</p>
<blockquote>
<p>  无论是否携带 grantPermissions对应的安装时参数时</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.pkg.parentPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        grantRuntimePermissionsGrantedToDisabledPrivSysPackageParentLPw(res.pkg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-13-1-1-设置用户集firstUsers和updateUsers"><a href="#2-3-13-1-1-设置用户集firstUsers和updateUsers" class="headerlink" title="2.3.13.1.1. 设置用户集firstUsers和updateUsers"></a>2.3.13.1.1. 设置用户集firstUsers和updateUsers</h5><p>设置第一次添加该包的用户集firstUsers和更新该包的用户集updateUsers：当res.origiUsers为空时，只设置发firstUsers为res.newUsers；当存在res.origiUsers时，将res.newUsers中不存在于res.origiUsers的用户存入firstUsers，其余的存入updateUsers中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine the set of users who are adding this package for</span></span><br><span class="line"><span class="comment">// the first time vs. those who are seeing an update.</span></span><br><span class="line"><span class="type">int</span>[] firstUsers = EMPTY_INT_ARRAY;</span><br><span class="line"><span class="type">int</span>[] updateUsers = EMPTY_INT_ARRAY;</span><br><span class="line"><span class="keyword">if</span> (res.origUsers == <span class="literal">null</span> || res.origUsers.length == <span class="number">0</span>) &#123;</span><br><span class="line">    firstUsers = res.newUsers;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> newUser : res.newUsers) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> origUser : res.origUsers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (origUser == newUser) &#123;</span><br><span class="line">                isNew = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">            firstUsers = ArrayUtils.appendInt(firstUsers, newUser);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该用户下已经安装,  需要将当前的安装的用户添加到updateUsers中</span></span><br><span class="line">            updateUsers = ArrayUtils.appendInt(updateUsers, newUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-13-1-2-向用户集发送包广播"><a href="#2-3-13-1-2-向用户集发送包广播" class="headerlink" title="2.3.13.1.2. 向用户集发送包广播"></a>2.3.13.1.2. 向用户集发送包广播</h5><p>然后，向firstUsers和updateUsers中的用户发送ACTION_PACKAGE_ADDED  “android.intent.action.PACKAGE_ADDED” 广播：</p>
<ul>
<li>对于覆盖安装的情况, 并向updateUsers的用户发送包替换  ACTION_PACKAGE_REPLACED (“android.intent.action.PACKAGE_REPLACED” ) 广播</li>
<li>对于全新安装的情况,  didRestore 为true,但此时传入的参数为null, 且非系统包的情况下,发送ACTION_PACKAGE_FIRST_LAUNCH的广播, 在这个安装场景下,这条是不符合条件的</li>
<li>并对FORWARD_LOCKED&#x2F;外置SD卡的包发送ACTION_EXTERNAL_APPLICATIONS_AVAILABLE的广播</li>
</ul>
<h5 id="2-3-13-1-3-为firstUsers-新安装用户集处理挂起的运行时权限申请请求"><a href="#2-3-13-1-3-为firstUsers-新安装用户集处理挂起的运行时权限申请请求" class="headerlink" title="2.3.13.1.3. 为firstUsers 新安装用户集处理挂起的运行时权限申请请求"></a>2.3.13.1.3. 为firstUsers 新安装用户集处理挂起的运行时权限申请请求</h5><p>在mRestoredUserGrants中取出挂起的权限申请请求,然后从其中找出当前包申请的权限,对其进行权限授予,更新flag,并更新&#x2F;data&#x2F;users&#x2F;<userid>&#x2F;runtime-permissions.xml文件 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> userId : firstUsers) &#123;</span><br><span class="line">    mSettings.applyPendingPermissionGrantsLPw(packageName, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-13-1-4-覆盖安装情况下删除旧包的相关文件"><a href="#2-3-13-1-4-覆盖安装情况下删除旧包的相关文件" class="headerlink" title="2.3.13.1.4. 覆盖安装情况下删除旧包的相关文件"></a>2.3.13.1.4. 覆盖安装情况下删除旧包的相关文件</h5><p>调用res.romovedInfo.args.doPostDeleteLI方法删除旧包的代码&#x2F;资源&#x2F;本地库&#x2F;dex文件等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">doPostDeleteLI</span><span class="params">(<span class="type">boolean</span> delete)</span> &#123;</span><br><span class="line">    <span class="comment">// XXX err, shouldn&#x27;t we respect the delete flag?</span></span><br><span class="line">    cleanUpResourcesLI();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-13-1-5-回调监听器的onPackageInstalled接口"><a href="#2-3-13-1-5-回调监听器的onPackageInstalled接口" class="headerlink" title="2.3.13.1.5. 回调监听器的onPackageInstalled接口"></a>2.3.13.1.5. 回调监听器的onPackageInstalled接口</h5><p>最后，当在PackageInstalled.apk安装时指定了包安装监听器，回调该监听器的onPackageInstalled接口，告知监听的应用包已经安装完成. Bundle在成功安装时为null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">extras</span> <span class="operator">=</span> extrasForInstallResult(res);</span><br><span class="line">installObserver.onPackageInstalled(res.name, res.returnCode,</span><br><span class="line">        res.returnMsg, extras);</span><br></pre></td></tr></table></figure>

<p>处理完后,安装结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.d(TAG, <span class="string">&quot;pms install end&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-4-剩余消息处理"><a href="#2-4-剩余消息处理" class="headerlink" title="2.4. 剩余消息处理"></a>2.4. 剩余消息处理</h2><ul>
<li>处理MCS_RECONNECT消息</li>
</ul>
<p>当在复制apk时抛出RemoteException，startCopy会发出MCS_RECONNECTION消息，尝试重新复制和安装：如果，当前绑定到MCS上，解除绑定；然后重新绑定该服务，如果绑定失败，处理所有安装请求的错误信息，并移除所有的安装请求</p>
<ul>
<li>处理MCS_GIVE_UP消息</li>
</ul>
<p>  当尝试4次复制apk，均失败时，在startCopy中发送该消息将此安装请求从队列中移除：</p>
<ul>
<li>处理MCS_UNBIND消息</li>
</ul>
<p>当前没有安装请求时，会解除与MCS服务的绑定；如果此时又来了安装请求，那么会再次发送一个MCS_BOUND的空消息，继续进行安装</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/AndroidN/" rel="tag"># AndroidN</a>
              <a href="/tags/PackageManagerService/" rel="tag"># PackageManagerService</a>
              <a href="/tags/adb/" rel="tag"># adb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/02/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/PackageManagerService%E5%90%AF%E5%8A%A8%E7%AF%87%E6%95%B4%E7%90%861/" rel="prev" title="PackageManagerService启动篇整理1">
      <i class="fa fa-chevron-left"></i> PackageManagerService启动篇整理1
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/02/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/Print%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/" rel="next" title="Print框架整理">
      Print框架整理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-ADB%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1. ADB处理的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-adb-%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. adb 拷贝流程分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-pm%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. pm执行安装流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 安装流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%BB%8EINIT-COPY%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 从INIT_COPY开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%A4%84%E7%90%86MCS-BOUND%E6%B6%88%E6%81%AF"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 处理MCS_BOUND消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%B0%83%E7%94%A8InstallParams-handleStartCopy%E6%96%B9%E6%B3%95%E5%A4%8D%E5%88%B6apk"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. 调用InstallParams.handleStartCopy方法复制apk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E8%AE%A1%E7%AE%97%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1. 计算推荐安装位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E7%9A%84%E5%88%A4%E6%96%AD%E6%A0%87%E5%87%86"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2. 空间不足的判断标准</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E5%AF%B9%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%81%9A%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">2.3.2.1. 文件系统层对存储空间做的保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E6%A0%B9%E6%8D%AE%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3. 根据推荐安装位置处理返回结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E6%A0%B9%E6%8D%AE%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE%E5%88%9B%E5%BB%BA%E5%AE%89%E8%A3%85%E5%8F%82%E6%95%B0InstallArgs"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4. 根据安装位置创建安装参数InstallArgs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E9%AA%8C%E8%AF%81%E5%8C%85-GMS%E6%83%85%E5%86%B5%E4%B8%8B"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5. 验证包(GMS情况下)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6-%E5%A4%8D%E5%88%B6apk%E5%92%8Clib%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6. 复制apk和lib文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-7-FileInstallArgs-copyApk%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.7.</span> <span class="nav-text">2.3.7. FileInstallArgs.copyApk方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-8-AsecInstallArgs-copyApk%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.8.</span> <span class="nav-text">2.3.8. AsecInstallArgs.copyApk方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-9-InstallParams-handleReturnCode%E5%AE%89%E8%A3%85apk"><span class="nav-number">2.3.9.</span> <span class="nav-text">2.3.9. InstallParams.handleReturnCode安装apk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-10-installPackageLI%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.3.10.</span> <span class="nav-text">2.3.10. installPackageLI函数执行应用的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-1-installPackageLI-%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.3.10.1.</span> <span class="nav-text">2.3.10.1. installPackageLI  安装流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-2-%E8%B0%83%E7%94%A8parsePackage%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90AndroidManifest-xml%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.10.2.</span> <span class="nav-text">2.3.10.2. 调用parsePackage方法解析AndroidManifest.xml文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-3-%E5%AD%98%E5%85%A5abiOverride%EF%BC%8CTEST-ONLY"><span class="nav-number">2.3.10.3.</span> <span class="nav-text">2.3.10.3. 存入abiOverride，TEST_ONLY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-4-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81"><span class="nav-number">2.3.10.4.</span> <span class="nav-text">2.3.10.4. 证书验证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-4-1-V2%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81"><span class="nav-number">2.3.10.4.1.</span> <span class="nav-text">2.3.10.4.1. V2签名认证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-4-2-V1%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.10.4.2.</span> <span class="nav-text">2.3.10.4.2. V1签名校验</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-5-%E5%88%A4%E6%96%AD%E6%98%AF%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.3.10.5.</span> <span class="nav-text">2.3.10.5. 判断是应用升级的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-6-%E5%BD%93Packages-xml%E4%B8%AD%E5%AD%98%E5%9C%A8package%E7%9A%84%E8%AE%B0%E5%BD%95%E6%97%B6-%E6%AF%94%E5%AF%B9%E7%AD%BE%E5%90%8D"><span class="nav-number">2.3.10.6.</span> <span class="nav-text">2.3.10.6. 当Packages.xml中存在package的记录时,比对签名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-6-1-verifySignaturesLP-%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D%E6%AF%94%E5%AF%B9-%E6%96%B0%E8%80%81%E5%AE%89%E8%A3%85%E5%8C%85"><span class="nav-number">2.3.10.6.1.</span> <span class="nav-text">2.3.10.6.1. verifySignaturesLP 进行签名比对(新老安装包)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-7-%E9%AA%8C%E8%AF%81%E6%9D%83%E9%99%90"><span class="nav-number">2.3.10.7.</span> <span class="nav-text">2.3.10.7. 验证权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-8-%E6%9B%B4%E6%96%B0%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%A5%E5%8F%8A%E6%8B%B7%E8%B4%9D%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%B9%B6%E6%89%A7%E8%A1%8Cdexopt%E4%BC%98%E5%8C%96"><span class="nav-number">2.3.10.8.</span> <span class="nav-text">2.3.10.8. 更新指令集以及拷贝本地库并执行dexopt优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-9-%E7%9B%AE%E5%BD%95%E6%9B%B4%E5%90%8D"><span class="nav-number">2.3.10.9.</span> <span class="nav-text">2.3.10.9. 目录更名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-10-%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85"><span class="nav-number">2.3.10.10.</span> <span class="nav-text">2.3.10.10. 覆盖安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-10-1-%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%BA%A7apk%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85"><span class="nav-number">2.3.10.10.1.</span> <span class="nav-text">2.3.10.10.1. 非系统级apk覆盖安装</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-10-2-%E7%B3%BB%E7%BB%9F%E7%BA%A7apk%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85"><span class="nav-number">2.3.10.10.2.</span> <span class="nav-text">2.3.10.10.2. 系统级apk覆盖安装</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-10-11-%E5%85%A8%E6%96%B0%E5%AE%89%E8%A3%85"><span class="nav-number">2.3.10.11.</span> <span class="nav-text">2.3.10.11. 全新安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-10-11-1-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="nav-number">2.3.10.11.1.</span> <span class="nav-text">2.3.10.11.1. 准备数据目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-11-%E5%B0%8F%E7%BB%93"><span class="nav-number">2.3.11.</span> <span class="nav-text">2.3.11. 小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-12-processPendingInstall%E6%96%B9%E6%B3%95%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86"><span class="nav-number">2.3.12.</span> <span class="nav-text">2.3.12. processPendingInstall方法后续处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-13-POST-INSTALL%E9%98%B6%E6%AE%B5-%E5%A4%84%E7%90%86POST-INSTALL%E6%B6%88%E6%81%AF"><span class="nav-number">2.3.13.</span> <span class="nav-text">2.3.13. POST_INSTALL阶段(处理POST_INSTALL消息)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-13-1-handlePackagePostInstall%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.3.13.1.</span> <span class="nav-text">2.3.13.1. handlePackagePostInstall函数的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-13-1-1-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E9%9B%86firstUsers%E5%92%8CupdateUsers"><span class="nav-number">2.3.13.1.1.</span> <span class="nav-text">2.3.13.1.1. 设置用户集firstUsers和updateUsers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-13-1-2-%E5%90%91%E7%94%A8%E6%88%B7%E9%9B%86%E5%8F%91%E9%80%81%E5%8C%85%E5%B9%BF%E6%92%AD"><span class="nav-number">2.3.13.1.2.</span> <span class="nav-text">2.3.13.1.2. 向用户集发送包广播</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-13-1-3-%E4%B8%BAfirstUsers-%E6%96%B0%E5%AE%89%E8%A3%85%E7%94%A8%E6%88%B7%E9%9B%86%E5%A4%84%E7%90%86%E6%8C%82%E8%B5%B7%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E8%AF%B7%E6%B1%82"><span class="nav-number">2.3.13.1.3.</span> <span class="nav-text">2.3.13.1.3. 为firstUsers 新安装用户集处理挂起的运行时权限申请请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-13-1-4-%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%A0%E9%99%A4%E6%97%A7%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.13.1.4.</span> <span class="nav-text">2.3.13.1.4. 覆盖安装情况下删除旧包的相关文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-13-1-5-%E5%9B%9E%E8%B0%83%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84onPackageInstalled%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.3.13.1.5.</span> <span class="nav-text">2.3.13.1.5. 回调监听器的onPackageInstalled接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%89%A9%E4%BD%99%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. 剩余消息处理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

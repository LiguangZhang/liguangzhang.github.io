<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="blog">
<meta property="og:url" content="https://liguangzhang.github.io/page/23/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liguang.zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liguangzhang.github.io/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/11/12/OTA%E7%9B%B8%E5%85%B3/%E4%BC%98%E5%8C%96cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/OTA%E7%9B%B8%E5%85%B3/%E4%BC%98%E5%8C%96cache/" class="post-title-link" itemprop="url">优化cache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-11-12T18:15:54+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:15:56" itemprop="dateModified" datetime="2024-04-16T15:15:56+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/cache-%E5%88%86%E5%8C%BA/" itemprop="url" rel="index"><span itemprop="name">cache 分区</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/cache-%E5%88%86%E5%8C%BA/recovery/" itemprop="url" rel="index"><span itemprop="name">recovery</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="优化cache"><a href="#优化cache" class="headerlink" title="优化cache"></a>优化cache</h1><h2 id="cache文件系统损坏问题"><a href="#cache文件系统损坏问题" class="headerlink" title="cache文件系统损坏问题"></a>cache文件系统损坏问题</h2><p>因文件系统损坏, 可能导致可用空间信息不准确, 或cache空间变成一半.<br>开机加入强制check cache, 可以解决可用空间错误的问题.</p>
<p><a target="_blank" rel="noopener" href="http://gerritlvs.pt.miui.com/#/c/641165/">http://gerritlvs.pt.miui.com/#/c/641165/</a></p>
<h3 id="原生方案"><a href="#原生方案" class="headerlink" title="原生方案"></a>原生方案</h3><p>没有强制check cache. 开机阶段对cache分区进行检查, 如果出现过异常关机的情况, 会对cache分区进行修复.</p>
<ul>
<li>fstab中options配置了<strong>check</strong></li>
<li>读取文件系统超级块信息时返回的状态是<strong>FS_STAT_UNCLEAN_SHUTDOWN</strong>或<strong>FS_STAT_QUOTA_ENABLED</strong></li>
</ul>
<blockquote>
<p>FS_STAT_UNCLEAN_SHUTDOWN状态可以理解完出现了异常关机</p>
<p>FS_STAT_QUOTA_ENABLED状态则是分区是否启用了磁盘配额机制</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_ext4_superblock</span>(blk_device, &amp;sb, &amp;fs_stat)</span><br><span class="line"><span class="comment">// fstab中options配置了check或者读取文件系统超级块信息时返回的状态是FS_STAT_UNCLEAN_SHUTDOWN或FS_STAT_QUOTA_ENABLED   </span></span><br><span class="line">    <span class="keyword">if</span> ((rec-&gt;fs_mgr_flags &amp; MF_CHECK) ||</span><br><span class="line">       (fs_stat &amp; (FS_STAT_UNCLEAN_SHUTDOWN | FS_STAT_QUOTA_ENABLED))) &#123;</span><br><span class="line">       <span class="built_in">check_fs</span>(blk_device, rec-&gt;fs_type, rec-&gt;mount_point, &amp;fs_stat, rec);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="因cache文件系统损坏导致的recovery无法更新成功问题"><a href="#因cache文件系统损坏导致的recovery无法更新成功问题" class="headerlink" title="因cache文件系统损坏导致的recovery无法更新成功问题"></a>因cache文件系统损坏导致的recovery无法更新成功问题</h5><p>解决方案: (适用于bootloader加锁的情况)</p>
<blockquote>
<p>执行“fastboot continue开机后， 长按power键+ 音量下，直接进fastboot , 然后fastboot continue开机”. </p>
</blockquote>
<p>目的是触发非正常关机, 再次开机时cache分区文件系统超级块检查后变为<strong>FS_STAT_UNCLEAN_SHUTDOWN</strong>, 触发check修复, 然后recovery更新所在的服务<strong>flash_recovery</strong>即可正常执行.</p>
<h3 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h3><p>我们的方案即在原生方案基础上在<strong>fstab</strong>中加入了check选项, 这样每次开机都会对cache进行check. 如在<em>ext4</em>上执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E2FSCK_BIN      <span class="string">&quot;/system/bin/e2fsck&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* e2fsck_forced_argv[] = &#123;E2FSCK_BIN, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;-y&quot;</span>, blk_device&#125;;</span><br></pre></td></tr></table></figure>

<p>对于cache空间变成一半的问题, 因当前还没有root-cause, 也没有dump出的现场的cache.img, 问题还需要继续跟踪.</p>
<blockquote>
<p>总空间变成一半的案例:  </p>
<p><a target="_blank" rel="noopener" href="https://jira.n.xiaomi.com/browse/HTH-60766">https://jira.n.xiaomi.com/browse/HTH-60766</a></p>
<p>cache损坏, 可用空间变成一半的案例  </p>
<p><a target="_blank" rel="noopener" href="https://jira.n.xiaomi.com/browse/MIUI-1605226">https://jira.n.xiaomi.com/browse/MIUI-1605226</a></p>
</blockquote>
<h2 id="因ota升级重启导致的cache缓存遗留问题"><a href="#因ota升级重启导致的cache缓存遗留问题" class="headerlink" title="因ota升级重启导致的cache缓存遗留问题"></a>因ota升级重启导致的cache缓存遗留问题</h2><p>在applypatch的代码中, 如果差分升级某些分区, 会有cache缓存残留.</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ol>
<li>ota升级过程中屏蔽power键功能, 保证ota升级过程中用户不能通过长按power键重启</li>
<li>在校验分区已经满足目标版本时, 删除对应的分区残留项.</li>
</ol>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>第一个方案正在对所有机型计划合入中, 依赖底层kernel中power节点的使能. </p>
<p>对应高通机型, <a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/648868/">http://gerrit.pt.miui.com/#/c/648868/</a>, 需要<strong>kpdpwr_reset</strong>节点使能即可.</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/665992/">http://gerrit.pt.miui.com/#/c/665992/</a>, 节点前的路径需要底层同事提供.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on property<span class="punctuation">:</span>vendor.kpdpwr.reset.enabled=<span class="number">0</span></span><br><span class="line">    write /sys/devices/platform/soc/c440000.qcom<span class="punctuation">,</span>spmi/spmi<span class="number">-0</span>/spmi0<span class="number">-00</span>/c440000.qcom<span class="punctuation">,</span>spmi\<span class="punctuation">:</span>qcom<span class="punctuation">,</span>pm660@<span class="number">0</span>\<span class="punctuation">:</span>qcom<span class="punctuation">,</span>power-on@<span class="number">800</span>/kpdpwr_reset <span class="number">0</span></span><br><span class="line"></span><br><span class="line">on property<span class="punctuation">:</span>vendor.kpdpwr.reset.enabled=<span class="number">1</span></span><br><span class="line">    write /sys/devices/platform/soc/c440000.qcom<span class="punctuation">,</span>spmi/spmi<span class="number">-0</span>/spmi0<span class="number">-00</span>/c440000.qcom<span class="punctuation">,</span>spmi\<span class="punctuation">:</span>qcom<span class="punctuation">,</span>pm660@<span class="number">0</span>\<span class="punctuation">:</span>qcom<span class="punctuation">,</span>power-on@<span class="number">800</span>/kpdpwr_reset <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对应mtk机型, 可以参考G7的修改.</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/665678/">http://gerrit.pt.miui.com/#/c/665678/</a></p>
<p><a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/664037/">http://gerrit.pt.miui.com/#/c/664037/</a></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>在校验分区已经满足目标版本时, 删除对应的分区残留项.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(source_file.sha1, target_sha1, SHA_DIGEST_LENGTH) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// The early-exit case: the patch was already applied, this file has the desired hash, nothing</span></span><br><span class="line">    <span class="comment">// for us to do.</span></span><br><span class="line">    <span class="comment">// cache/saved.file</span></span><br><span class="line">    <span class="type">size_t</span> cache_temp_source_size = <span class="built_in">GetFileSize</span>(CacheLocation::<span class="built_in">location</span>().<span class="built_in">cache_temp_source</span>());</span><br><span class="line">    <span class="keyword">if</span>(cache_temp_source_size != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">unlink</span>(CacheLocation::<span class="built_in">location</span>().<span class="built_in">cache_temp_source</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;already %s\n&quot;</span>, <span class="built_in">short_sha1</span>(target_sha1).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例: <a target="_blank" rel="noopener" href="https://jira.n.xiaomi.com/browse/HQ-43785">https://jira.n.xiaomi.com/browse/HQ-43785</a></p>
</blockquote>
<h2 id="尽可能删除cache下的文件"><a href="#尽可能删除cache下的文件" class="headerlink" title="尽可能删除cache下的文件"></a>尽可能删除cache下的文件</h2><p>在检查及清除cache下文件时, 尽可能删除cache下的文件.<br>在尽量保留recovery log的基础上对cache下的所有文件进行排序.<br>排序按照优先级, 大小的双重规则进行安排.<br>对log和升级相关的文件尽可能不删除, 对ota升级过程中的stash文件不做处理, 对其他文件优先按照文件大小进行排序, 逐个删除, 直到可用空间满足要求为止.</p>
<p>相关的修改参考:  <a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/646042/1/applypatch/freecache.cpp">http://gerrit.pt.miui.com/#/c/646042/1/applypatch/freecache.cpp</a></p>
<h4 id="原生方案-1"><a href="#原生方案-1" class="headerlink" title="原生方案"></a>原生方案</h4><p>androidP 只删除&#x2F;cache根目录下的文件, 还有*&#x2F;cache&#x2F;recovery&#x2F;otatest*目录下的文件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* dirs[2] = &#123;&quot;/cache&quot;, &quot;/cache/recovery/otatest&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>androidQ上只删除*&#x2F;cache<em>根目录下的文件和</em>&#x2F;cache&#x2F;recovery&#x2F;*下的log文件, 保留last_log和last_kmsg.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; dirs&#123; <span class="string">&quot;/cache&quot;</span>, Paths::<span class="built_in">Get</span>().<span class="built_in">cache_log_directory</span>() &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dirname : dirs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RemoveFilesInDirectory</span>(bytes, dirname, FreeSpaceForFile)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改进方案-1"><a href="#改进方案-1" class="headerlink" title="改进方案"></a>改进方案</h4><p>遍历cache目录, 对其下所有文件进行追踪, 记录其文件名, 大小, 和优先级.</p>
<p>优先级从高-&gt;低, 越大的越容易被删除. 同优先级的比较大小, 文件越大的越容易被删除. 同时定义了 **<code>CANNOT_DEL_PRI</code>**级别, 对应不能被删除的文件.</p>
<p>打印log, 给出了&#x2F;cache下最大的20个文件名.</p>
<h5 id="不能被删除的文件"><a href="#不能被删除的文件" class="headerlink" title="不能被删除的文件"></a>不能被删除的文件</h5><ul>
<li><em>&#x2F;cache&#x2F;recovery&#x2F;block.map</em></li>
<li><em>&#x2F;cache&#x2F;recovery&#x2F;last_log</em></li>
<li><em>&#x2F;cache&#x2F;recovery&#x2F;last_log.1</em></li>
<li>&#x3D;&#x3D;<em>&#x2F;cache&#x2F;saved.file</em>&#x3D;&#x3D;</li>
<li><code>/cache/recovery/&lt;dir_name&gt;/*</code></li>
<li>&#x2F;cache&#x2F; 下小于<strong>2k</strong>的小文件, 包含了&#x2F;cache&#x2F;recovery下升级相关的日志文件, 升级文件等.</li>
</ul>
<h5 id="优先级排序"><a href="#优先级排序" class="headerlink" title="优先级排序"></a>优先级排序</h5><blockquote>
<p>从上到下越容易被删除的程度</p>
</blockquote>
<ul>
<li>&#x2F;cache&#x2F;recovery&#x2F;<dir_name>&#x2F;*    主要是考虑升级时stash相关的文件, 没有固定文件名</li>
<li>&#x2F;cache&#x2F;recovery&#x2F;  保存了相关recovery的升级日志等.</li>
<li>&#x2F;cache&#x2F;mqsas&#x2F;</li>
<li>其他</li>
</ul>
<h2 id="applypatch优化"><a href="#applypatch优化" class="headerlink" title="applypatch优化"></a>applypatch优化</h2><p>在ota升级后, recovery更新时, 原生方案依赖<strong>cache分区的可用空间</strong>. 主要是***&#x2F;cache&#x2F;saved.file<em><em><em>的处理. 对于recovery更新的场景来说, 是使用</em>&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;boot</em> + <em>system&#x2F;recovery-from-boot.p</em> 文件, 生成recovery分区的镜像, 写入</em>&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;recovery*, 这个过程中原始文件boot不会被损坏, 所以是不需要缓存文件的.</p>
<p>applypatch可以用作使用别的分区升级当前分区, 如 boot-[recovery-from-boot.p]-&gt;new recovery </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applypatch  EMMC:/dev/block/bootdevice/by-name/boot:67108864:8c05fe713233ad8b5c85db717bfdae0cecdca5bc EMMC:/dev/block/bootdevice/by-name/recovery 870ddfcf72425a76f95899254a8df3b32ac2dad0 67108864 8c05fe713233ad8b5c85db717bfdae0cecdca5bc:/system/recovery-from-boot.p &amp;&amp; log -t recovery &quot;Installing new recovery image: succeeded&quot; || log -t recovery &quot;Installing new recovery image: failed&quot;</span><br></pre></td></tr></table></figure>

<p>使用当前分区内容升级当前的分区, 即<strong>自更新</strong>. boot-[boot.p]-&gt; new boot</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patch_partition(&quot;EMMC:/dev/block/bootdevice/by-name/boot:51242240:5d92bec9964000c0b11229cdc51470662feda96b&quot;,</span><br><span class="line">                &quot;EMMC:/dev/block/bootdevice/by-name/boot:50926848:07700e132a84e47c26380a7a7a0fc57f8164fa60&quot;,</span><br><span class="line">                package_extract_file(&quot;boot.img.p&quot;)) ||</span><br><span class="line">    abort(&quot;E3008: Failed to apply patch to EMMC:/dev/block/bootdevice/by-name/boot:50926848:07700e132a84e47c26380a7a7a0fc57f8164fa60&quot;);</span><br></pre></td></tr></table></figure>

<p>自更新是需要缓存的, 就是怕在更新过程中意外退出了, 那原始的分区也会被破坏. 使用缓存来作备份, 保存原始分区的内容.   </p>
<h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><p>recovery更新时调用applypatch不再需要缓存文件. 也就去除了对<code>cache</code>分区需要有可用空间的依赖.</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/646042/1/applypatch/applypatch.cpp">http://gerrit.pt.miui.com/#/c/646042/1/applypatch/applypatch.cpp</a></p>
<h2 id="ota打包时-能使用的最大的cache空间"><a href="#ota打包时-能使用的最大的cache空间" class="headerlink" title="ota打包时, 能使用的最大的cache空间"></a>ota打包时, 能使用的最大的cache空间</h2><p>原生行为, ota打包时,最大能够使用的cache空间为<strong>cache partition size</strong>的<strong>80%.</strong></p>
<h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><p>调整为<strong>cache文件系统</strong>总空间的<strong>80%</strong>. 和系统升级app端行为保持一致, (升级前先检查cache的使用量, 如果超过20%要求用户对其格式化)</p>
<blockquote>
<p>案例: <a target="_blank" rel="noopener" href="https://jira.n.xiaomi.com/browse/HTH-56790">https://jira.n.xiaomi.com/browse/HTH-56790</a></p>
</blockquote>
<p>相关change: <a target="_blank" rel="noopener" href="http://gerrit.pt.miui.com/#/c/661519/">http://gerrit.pt.miui.com/#/c/661519/</a></p>
<p>主要原理是在调用文件系统对应的打包脚本生成cache.img时, 截取used_blocks和total_blocks.</p>
<blockquote>
<p>文件系统-&gt; 打包脚本</p>
<ul>
<li>ext:         mkuserimg_mke2fs  </li>
<li>squash:  mksquashfsimage.sh  </li>
<li>f2fs:        mkf2fsuserimg.sh</li>
</ul>
</blockquote>
<p>当前cache是ext4的, 会输出下面的信息, 从中可以截取出used_blocks和total_blocks.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block_bytes_key = <span class="string">r&#x27;Creating journal\s\((\d+)\sblocks\).*&#x27;</span></span><br><span class="line">block_count_key = <span class="string">r&#x27;Created filesystem with[\s\/\d]+inodes\sand\s(\d+)\/(\d+)\sblocks&#x27;</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/11/12/OTA%E7%9B%B8%E5%85%B3/Q%20recovery%20fastboot%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/OTA%E7%9B%B8%E5%85%B3/Q%20recovery%20fastboot%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">Q动态分区 recovey fastbootd 调研</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-11-12T18:15:54+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:23:50" itemprop="dateModified" datetime="2024-04-16T15:23:50+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要先挂载fastboot</span></span><br><span class="line">mkdir /config/usb_gadget/g1/functions/ffs.fastboot</span><br><span class="line">mount -t functionfs fastboot /dev/usb-ffs/fastboot</span><br></pre></td></tr></table></figure>

<p>初步调试 清除数据wipe_data进 fastboot, 重启进adb模式</p>
<p>使用wireshark进行调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T:  Bus=01 Lev=01 Prnt=01 Port=08 Cnt=03 Dev#= 40 Spd=480  MxCh= 0</span><br><span class="line">D:  Ver= 2.00 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br><span class="line">P:  Vendor=18d1 ProdID=4ee0 Rev= 4.19</span><br><span class="line">S:  Manufacturer=Xiaomi</span><br><span class="line">S:  Product=Umi</span><br><span class="line">S:  SerialNumber=4e80ec52</span><br><span class="line">C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=500mA</span><br><span class="line">I:* If#= 0 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=42 Prot=03 Driver=(none)</span><br><span class="line">E:  Ad=01(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br><span class="line">E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打包recovery的ramdisk</span></span><br><span class="line">out/host/linux-x86/bin/mkbootfs -d out/target/product/umi/system out/target/product/umi/recovery/root | out/host/linux-x86/bin/minigzip &gt; out/target/product/umi/ramdisk-recovery.img</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打包recovery.img</span></span><br><span class="line">out/host/linux-x86/bin/mkbootfs -d out/target/product/umi/system out/target/product/umi/recovery/root | out/host/linux-x86/bin/minigzip &gt; out/target/product/umi/ramdisk-recovery.img &amp;&amp; out/host/linux-x86/bin/mkbootimg  --kernel out/target/product/umi/kernel  --ramdisk out/target/product/umi/ramdisk-recovery.img --cmdline &quot;console=ttyMSM0,115200n8 androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 video=vfb:640x400,bpp=32,memsize=3072000 msm_rtb.filter=0x237 service_locator.enable=1 androidboot.usbcontroller=a600000.dwc3 swiotlb=2048 loop.max_part=7 cgroup.memory=nokmem,nosocket reboot=panic_warm androidboot.selinux=permissive androidboot.usbconfigfs=true&quot; --base 0x00000000 --pagesize 4096 --recovery_dtbo out/target/product/umi/prebuilt_dtbo.img --dtb out/target/product/umi/dtb.img --os_version 10 --os_patch_level 2019-09-05 --header_version 2 --output  out/target/product/umi/recovery.img</span><br></pre></td></tr></table></figure>

<p>OTA测试环境OTA地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://husky.pt.miui.com/buildFile/miui_UMI_9.9.20_f2a2d4cc2d_10.0.zip</span><br></pre></td></tr></table></figure>

<h2 id="1-关于hidl-service"><a href="#1-关于hidl-service" class="headerlink" title="1. 关于hidl service"></a>1. 关于hidl service</h2><h3 id="1-1-hal简介"><a href="#1-1-hal简介" class="headerlink" title="1.1. hal简介"></a>1.1. hal简介</h3><p>HAL 接口定义语言（简称 HIDL，发音为“hide-l”）是用于指定 HAL 和其用户之间的接口的一种接口描述语言. 用于进程间通信.分为直通式(passthrough)和绑定式(binderized)</p>
<h3 id="1-2-hidl服务的调用流程"><a href="#1-2-hidl服务的调用流程" class="headerlink" title="1.2. hidl服务的调用流程"></a>1.2. hidl服务的调用流程</h3><p>以android.hardware.fastboot为例,  具体实现在default. defalut是默认实例,  最后编译为动态库</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">&quot;android.hardware.fastboot@1.0-impl-mock&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>在client端调用<strong>IFastboot::getService</strong>,  能编译通过的前提是client端引用了动态库 <em><a href="mailto:&#97;&#110;&#100;&#114;&#111;&#x69;&#x64;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#x66;&#97;&#115;&#x74;&#98;&#111;&#x6f;&#x74;&#64;&#49;&#46;&#x30;">&#97;&#110;&#100;&#114;&#111;&#x69;&#x64;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#x66;&#97;&#115;&#x74;&#98;&#111;&#x6f;&#x74;&#64;&#49;&#46;&#x30;</a></em></p>
<p>该库文件对应的代码是IFastboot.hal. 定义了相关IFastboot的接口.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[~/work_space/q9/hardware/interfaces/fastboot/1.0] - [日 9月 29, 14:54]</span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -git:(bsp-umi-q*)&gt; tree</span>                                                                </span><br><span class="line">.</span><br><span class="line">├── Android.bp</span><br><span class="line">├── IFastboot.hal</span><br><span class="line">└── types.hal</span><br></pre></td></tr></table></figure>

<p>由 update-makefiles.sh脚本对hal文件进行解析, 生成在<code>out/soong/.intermediates/hardware/interfaces/fastboot/1.0/android.hardware.fastboot@1.0_genc++_headers/gen/android/hardware/fastboot/1.0/IFastboot.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"><span class="keyword">namespace</span> fastboot &#123;</span><br><span class="line"><span class="keyword">namespace</span> V1_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">IFastboot</span> : <span class="keyword">public</span> ::android::hidl::base::V1_0::IBase &#123;</span><br><span class="line">        <span class="keyword">using</span> getPartitionType_cb = std::function&lt;<span class="built_in">void</span>(::android::hardware::fastboot::V1_0::FileSystemType type, <span class="type">const</span> ::android::hardware::fastboot::V1_0::Result&amp; result)&gt;;</span><br><span class="line">        <span class="type">static</span> ::<span class="function">android::sp&lt;IFastboot&gt; <span class="title">getService</span><span class="params">(<span class="type">const</span> std::string &amp;serviceName=<span class="string">&quot;default&quot;</span>, <span class="type">bool</span> getStub=<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ::android::<span class="function">hardware::Return&lt;<span class="type">void</span>&gt; <span class="title">getPartitionType</span><span class="params">(<span class="type">const</span> ::android::hardware::hidl_string&amp; partitionName, getPartitionType_cb _hidl_cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p><em><a href="mailto:&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#102;&#97;&#115;&#x74;&#x62;&#x6f;&#111;&#116;&#x40;&#49;&#x2e;&#x30;&#95;&#103;&#x65;&#110;&#x63;">&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#97;&#x72;&#x65;&#x2e;&#102;&#97;&#115;&#x74;&#x62;&#x6f;&#111;&#116;&#x40;&#49;&#x2e;&#x30;&#95;&#103;&#x65;&#110;&#x63;</a>++&#x2F;gen&#x2F;android&#x2F;hardware&#x2F;fastboot&#x2F;1.0&#x2F;FastbootAll.cpp</em></p>
<p>首先看下getService的相关实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">android::sp&lt;IFastboot&gt; <span class="title">IFastboot::getService</span><span class="params">(<span class="type">const</span> std::string &amp;serviceName, <span class="type">const</span> <span class="type">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::<span class="built_in">getServiceInternal</span>&lt;BpHwFastboot&gt;(serviceName, <span class="literal">true</span>, getStub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接下来会调用到libhidlbase.so里, 具体实现在<code>system/libhidl/transport/include/hidl/HidlTransportSupport.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BpType, <span class="keyword">typename</span> IType = <span class="keyword">typename</span> BpType::Pure,</span><br><span class="line">          <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;std::is_same&lt;i_tag, <span class="keyword">typename</span> IType::_hidl_tag&gt;::value&gt;,</span><br><span class="line">          <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;std::is_same&lt;bphw_tag, <span class="keyword">typename</span> BpType::_hidl_tag&gt;::value&gt;&gt;</span><br><span class="line">sp&lt;IType&gt; <span class="built_in">getServiceInternal</span>(<span class="type">const</span> std::string&amp; instance, <span class="type">bool</span> retry, <span class="type">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="built_in">getRawServiceInternal</span>(IType::descriptor, instance, retry, getStub);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;<span class="built_in">isRemote</span>()) &#123;</span><br><span class="line">        <span class="comment">// getRawServiceInternal guarantees we get the proper class</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sp</span>&lt;IType&gt;(<span class="keyword">new</span> <span class="built_in">BpType</span>(<span class="built_in">getOrCreateCachedBinder</span>(base.<span class="built_in">get</span>())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IType::<span class="built_in">castFrom</span>(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libhidlbase.so  &lt;--  (static_lib)-- libhidltransport-impl-internal</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system/libhidl/transport/ServiceManageMent.cpp</span></span><br><span class="line"><span class="function">sp&lt;::android::hidl::base::V1_0::IBase&gt; <span class="title">getRawServiceInternal</span><span class="params">(<span class="type">const</span> std::string&amp; descriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">const</span> std::string&amp; instance,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">bool</span> retry, <span class="type">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    Transport transport = Transport::EMPTY;</span><br><span class="line">    <span class="keyword">if</span> (kIsRecovery) &#123;</span><br><span class="line">        transport = Transport::PASSTHROUGH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1. waitForHwServiceManager();   一直等待hwservicemanager.ready变为true. 1s检查一次</span></span><br><span class="line">        <span class="comment">// 依赖hwservicemanager</span></span><br><span class="line">        sm = <span class="built_in">defaultServiceManager1_1</span>();</span><br><span class="line">        <span class="comment">// 2. 调用ServiceManager的getTransport函数,获取传入的hidl服务的接口类型.</span></span><br><span class="line">        <span class="comment">// getTransport函数逻辑较长, 另行分析.        </span></span><br><span class="line">        Return&lt;Transport&gt; transportRet = sm-&gt;<span class="built_in">getTransport</span>(descriptor, instance);</span><br><span class="line">        ...</span><br><span class="line">        transport = transportRet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 接口类型要么是hwbinder, 要么是passthrough, 要么是legacy的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line">    <span class="comment">// 4. 接口类型是hwbinder或者是legacy的. getStub false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; (vintfHwbinder || vintfLegacy); tries++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waiter == <span class="literal">nullptr</span> &amp;&amp; tries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            waiter = <span class="keyword">new</span> <span class="built_in">Waiter</span>(descriptor, instance, sm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (waiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            waiter-&gt;<span class="built_in">reset</span>();  <span class="comment">// don&#x27;t reorder this -- see comments on reset()</span></span><br><span class="line">        &#125;</span><br><span class="line">        Return&lt;sp&lt;IBase&gt;&gt; ret = sm-&gt;<span class="built_in">get</span>(descriptor, instance);</span><br><span class="line">        sp&lt;IBase&gt; base = ret;</span><br><span class="line">        <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Return&lt;<span class="type">bool</span>&gt; canCastRet =</span><br><span class="line">                details::<span class="built_in">canCastInterface</span>(base.<span class="built_in">get</span>(), descriptor.<span class="built_in">c_str</span>(), <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (canCastRet.<span class="built_in">isOk</span>() &amp;&amp; canCastRet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (waiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    waiter-&gt;<span class="built_in">done</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> base; <span class="comment">// still needs to be wrapped by Bp class.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">handleCastError</span>(canCastRet, descriptor, instance)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case of legacy or we were not asked to retry, don&#x27;t.</span></span><br><span class="line">        <span class="keyword">if</span> (vintfLegacy || !retry) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGI</span>(<span class="string">&quot;getService: Trying again for %s/%s...&quot;</span>, descriptor.<span class="built_in">c_str</span>(), instance.<span class="built_in">c_str</span>());</span><br><span class="line">            waiter-&gt;<span class="built_in">wait</span>(<span class="literal">true</span> <span class="comment">/* timeout */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        waiter-&gt;<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 5. 接口类型是passthrough的,</span></span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="comment">// 5.1 创建passThroughManager</span></span><br><span class="line">        <span class="type">const</span> sp&lt;IServiceManager&gt; pm = <span class="built_in">getPassthroughServiceManager</span>();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 5.2 getService</span></span><br><span class="line">            sp&lt;IBase&gt; base = pm-&gt;<span class="built_in">get</span>(descriptor, instance).<span class="built_in">withDefault</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span>(base==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGI</span>(<span class="string">&quot;base nullptr\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                base = <span class="built_in">wrapPassthrough</span>(base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-recovery中hidl环境"><a href="#1-3-recovery中hidl环境" class="headerlink" title="1.3. recovery中hidl环境"></a>1.3. recovery中hidl环境</h3><p>上面的代码中注意如果是recovery模式, 直接返回接口类型是passThrough的, 不再解析接口描述文件(manifest.xml), 直接创建passThroughManager.</p>
<p>这里我们先看下passthrough方式接入的后续流程:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.2 getService</span></span><br><span class="line">    Return&lt;sp&lt;IBase&gt;&gt; <span class="built_in">get</span>(<span class="type">const</span> hidl_string&amp; fqName,</span><br><span class="line">                          <span class="type">const</span> hidl_string&amp; name) <span class="keyword">override</span> &#123;</span><br><span class="line">        sp&lt;IBase&gt; ret = <span class="literal">nullptr</span>;</span><br><span class="line">       <span class="comment">// 通过openLibs函数查找相关的库文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">openLibs</span>(fqName, [&amp;](<span class="type">void</span>* handle, <span class="type">const</span> std::string &amp;lib, <span class="type">const</span> std::string &amp;sym) &#123;</span><br><span class="line">            IBase* (*generator)(<span class="type">const</span> <span class="type">char</span>* name);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">openLibs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; fqName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::function&lt;<span class="type">bool</span> <span class="comment">/* continue */</span> (<span class="type">void</span>* <span class="comment">/* handle */</span>, <span class="type">const</span> std::string&amp; <span class="comment">/* lib */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> std::string&amp; <span class="comment">/* sym */</span>)&gt;&amp; eachLib)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// /odm/lib64/hw/ /vendor/lib64/hw/ /system/lib64/vndk-sp%s/hw</span></span><br><span class="line">     <span class="comment">// recovery编译中没有定义__ANDROID_VNDK__, 所以多加了 /system/lib64/hw 项</span></span><br><span class="line">        <span class="type">static</span> std::string halLibPathVndkSp = android::base::<span class="built_in">StringPrintf</span>(</span><br><span class="line">            HAL_LIBRARY_PATH_VNDK_SP_FOR_VERSION, details::<span class="built_in">getVndkVersionStr</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        std::vector&lt;std::string&gt; paths = &#123;</span><br><span class="line">            HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, halLibPathVndkSp,</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ANDROID_VNDK__</span></span><br><span class="line">            HAL_LIBRARY_PATH_SYSTEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 查找规则, 传入android.hardware.fastboot@1.0::IFastboot</span></span><br><span class="line">        std::string packageAndVersion = fqName.<span class="built_in">substr</span>(<span class="number">0</span>, fqName.<span class="built_in">find</span>(<span class="string">&quot;::&quot;</span>));</span><br><span class="line">        std::string ifaceName = fqName.<span class="built_in">substr</span>(idx + <span class="built_in">strlen</span>(<span class="string">&quot;::&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::string&amp; path : paths) &#123;</span><br><span class="line">     		std::vector&lt;std::string&gt; libs = <span class="built_in">findFiles</span>(path, prefix, <span class="string">&quot;.so&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (kIsRecovery || path == HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                <span class="comment">// recovery中 dlopen 打开lib库</span></span><br><span class="line">                    handle = <span class="built_in">dlopen</span>(fullPath.<span class="built_in">c_str</span>(), dlMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__ANDROID_RECOVERY__)</span></span><br><span class="line">                    handle = <span class="built_in">android_load_sphal_library</span>(fullPath.<span class="built_in">c_str</span>(), dlMode);<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;            </span><br><span class="line">            <span class="comment">// 寻找HIDL_FETCH_IFastboot函数</span></span><br><span class="line">            *(<span class="type">void</span> **)(&amp;generator) = <span class="built_in">dlsym</span>(handle, sym.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">if</span>(!generator) &#123;</span><br><span class="line">                <span class="built_in">dlclose</span>(handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用HIDL_FETCH_IFastboot函数, 创建IFastboot对端的实例</span></span><br><span class="line">            ret = (*generator)(name.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;     </span><br></pre></td></tr></table></figure>

<p>IFastboot对端的实例提供了hal中定义的接口的实现.default(instance)下的实现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[~/work_space/q9/hardware/interfaces/fastboot/1.0/default] - [日 9月 29, 15:20]</span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -git:(bsp-umi-q*)&gt; tree</span></span><br><span class="line">.</span><br><span class="line">├── Android.bp</span><br><span class="line">├── Fastboot.cpp</span><br><span class="line">└── Fastboot.h</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fastboot.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">IFastboot* <span class="title">HIDL_FETCH_IFastboot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Fastboot</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1217适配方案中因keymaster的改动替换了libhidlbase.so库(recovery编译–&gt;主系统编译的, 丢失了kIsRecovery和__ANDROID_RECOVERY__ <strong>ANDROID_VNDK</strong>).  直接替换的方式会对recovery的运行环境产生了影响. 表现在如果未启动hwservicemanager.</p>
<p>只要在recovery的相关进程中执行了&lt;接口&gt;::getService, 会一直等待<strong>hwservicemanager.ready</strong>属性变为true, getService一直处于阻塞状态.</p>
<p>在调试fastbootd时, 执行<code>fastboot getvar all</code>命令无响应, 原因就是fastbootd初始化时, 加载fastboothal, 而调用了<code>IFastboot::getService</code>, 由于libhidlbase替换为主系统的, 又没执行hwservicemanager, 所以一直在等待hwservicemanager.ready&#x3D;true, 从而处于阻塞状态, fastbootd服务阻塞在构造函数中, 没有回发准备好的状态, 所以fastboot 客户端无法将命令传给对端, 阻塞在发包的地方.</p>
<h3 id="1-4-hidl接口描述-getTransport"><a href="#1-4-hidl接口描述-getTransport" class="headerlink" title="1.4. hidl接口描述(getTransport)"></a>1.4. hidl接口描述(getTransport)</h3><p>上面的流程中已大致了解了recovery下的hidl环境(主要是passthrough类型的怎么接入的), 下面主要介绍下非recovery模式下的hidl环境. 从<em>调用ServiceManager的getTransport函数,获取传入的hidl服务的接口类型</em>说起</p>
<p>首先是函数接口, 编译通过的前提.   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/libhidl/transport/manager/1.0/IServiceManager.hal   </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the transport of a service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param fqName     Fully-qualified interface name.</span></span><br><span class="line"><span class="comment">     * @param name       Instance name. Same as in IServiceManager::add</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return transport Transport of service if known.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">getTransport</span>(string fqName, string name) <span class="built_in">generates</span> (Transport transport);</span><br></pre></td></tr></table></figure>

<p>实现在hwservicemanager中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/hwservicemanager/ServiceManager.cpp</span></span><br><span class="line"><span class="function">Return&lt;ServiceManager::Transport&gt; <span class="title">ServiceManager::getTransport</span><span class="params">(<span class="type">const</span> hidl_string&amp; fqName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                               <span class="type">const</span> hidl_string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::getTransport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAcl.<span class="built_in">canGet</span>(fqName, <span class="built_in">getBinderCallingContext</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Transport::EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用到Vintf</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">getTransport</span>(fqName, name)) &#123;</span><br><span class="line">        <span class="keyword">case</span> vintf::Transport::HWBINDER:</span><br><span class="line">             <span class="keyword">return</span> Transport::HWBINDER;</span><br><span class="line">        <span class="keyword">case</span> vintf::Transport::PASSTHROUGH:</span><br><span class="line">             <span class="keyword">return</span> Transport::PASSTHROUGH;</span><br><span class="line">        <span class="keyword">case</span> vintf::Transport::EMPTY:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">return</span> Transport::EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system/hwservicemanager/Vintf.cpp</span></span><br><span class="line"><span class="function">vintf::Transport <span class="title">getTransport</span><span class="params">(<span class="type">const</span> std::string &amp;interfaceName, <span class="type">const</span> std::string &amp;instanceName)</span> </span>&#123;</span><br><span class="line">    FQName fqName;</span><br><span class="line">    <span class="comment">// 先调用GetFrameworkHalManifest加载xml文件, 再通过getTransportFromManifest查找manifest中是否有fqName,instance的描述</span></span><br><span class="line">    <span class="comment">// android.hardware.fastboot@1.0::IFastboot    default</span></span><br><span class="line">    vintf::Transport tr = <span class="built_in">getTransportFromManifest</span>(fqName, instanceName,</span><br><span class="line">            vintf::VintfObject::<span class="built_in">GetFrameworkHalManifest</span>());</span><br><span class="line">    <span class="keyword">if</span> (tr != vintf::Transport::EMPTY) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr;</span><br><span class="line">    &#125;</span><br><span class="line">    tr = <span class="built_in">getTransportFromManifest</span>(fqName, instanceName,</span><br><span class="line">            vintf::VintfObject::<span class="built_in">GetDeviceHalManifest</span>());</span><br><span class="line">    <span class="keyword">if</span> (tr != vintf::Transport::EMPTY) &#123;</span><br><span class="line">        <span class="keyword">return</span> tr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vintf::Transport::EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在framwork和device的hal manifest中查找, 主要的实现在libvintf.so库</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> HalManifest&gt; <span class="title">VintfObject::getFrameworkHalManifest</span><span class="params">(<span class="type">bool</span> skipCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过fetchedOnce 变量判断之前是否已经fetch过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Get</span>(&amp;mFrameworkManifest, skipCache,</span><br><span class="line">               std::<span class="built_in">bind</span>(&amp;VintfObject::fetchFrameworkHalManifest, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">VintfObject::fetchFrameworkHalManifest</span><span class="params">(HalManifest* out, std::string* error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// /system/etc/vintf/manifest.xml</span></span><br><span class="line">    <span class="keyword">auto</span> systemEtcStatus = <span class="built_in">fetchOneHalManifest</span>(kSystemManifest, out, error);</span><br><span class="line">    <span class="keyword">if</span> (systemEtcStatus == OK) &#123;</span><br><span class="line">        <span class="comment">// /system/etc/vintf/manifest/*.xml</span></span><br><span class="line">        <span class="keyword">auto</span> dirStatus = <span class="built_in">addDirectoryManifests</span>(kSystemManifestFragmentDir, out, error);</span><br><span class="line">        <span class="keyword">if</span> (dirStatus != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> dirStatus;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HalManifest productManifest;</span><br><span class="line">        <span class="comment">// /product/etc/vintf/manifest.xml</span></span><br><span class="line">        <span class="keyword">auto</span> productStatus = <span class="built_in">fetchOneHalManifest</span>(kProductManifest, &amp;productManifest, error);</span><br><span class="line">        <span class="keyword">if</span> (productStatus != OK &amp;&amp; productStatus != NAME_NOT_FOUND) &#123;</span><br><span class="line">            <span class="keyword">return</span> productStatus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (productStatus == OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!out-&gt;<span class="built_in">addAll</span>(&amp;productManifest, error)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    error-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;Cannot add &quot;</span> + kProductManifest + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// /product/etc/vintf/manifest/*</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">addDirectoryManifests</span>(kProductManifestFragmentDir, out, error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Cannot fetch &quot;</span> &lt;&lt; kSystemManifest &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">                     &lt;&lt; (error ? *error : <span class="built_in">strerror</span>(-systemEtcStatus));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// /system/manifest.xml</span></span><br><span class="line">    <span class="keyword">return</span> out-&gt;<span class="built_in">fetchAllInformation</span>(<span class="built_in">getFileSystem</span>().<span class="built_in">get</span>(), kSystemLegacyManifest, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述解析过程只是将相关manifest.xml的文件内容加载到内存中, 并解析. </p>
<blockquote>
<p>fetch的过程中不能出错, 任何一个目录或文件的加载出错, 都会返回error</p>
<p>&#x2F;system&#x2F;etc&#x2F;vintf&#x2F;manifest.xml和&#x2F;system&#x2F;manifest.xml文件只读取一个, 优先读etc下的, 如果etc下有, 就不会再读system&#x2F;manifest.xml</p>
</blockquote>
<p>fetch一个(加载到内存),  解析一个. 通过 HalManifestConverter 进行后续的解析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fetchAllInformation</span>(fileSystem, path, gHalManifestConverter, <span class="keyword">this</span>, error);</span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">fetchAllInformation</span><span class="params">(<span class="type">const</span> FileSystem* fileSystem, <span class="type">const</span> std::string&amp; path,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> XmlConverter&lt;T&gt;&amp; converter, T* outObject, std::string* error)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="type">status_t</span> result = fileSystem-&gt;<span class="built_in">fetch</span>(path, &amp;info, error);</span><br><span class="line">    <span class="type">bool</span> success = <span class="built_in">converter</span>(outObject, info, error); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fetchFrameworkHalManifest的结果为HalManifest指针, 通过其getTransport函数查找已经解析的manifest中是否有对应的hidl服务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getTransportFromManifest</span></span><br><span class="line">    vintf::Transport tr = <span class="built_in">getTransportFromManifest</span>(fqName, instanceName,</span><br><span class="line">            vintf::VintfObject::<span class="built_in">GetFrameworkHalManifest</span>());</span><br><span class="line">vm-&gt;<span class="built_in">getTransport</span>(fqName.<span class="built_in">package</span>(), fqName.<span class="built_in">getVersion</span>(), fqName.<span class="built_in">name</span>(), instanceName);</span><br><span class="line">HalManifest-&gt;<span class="built_in">getTransport</span>(fqName.<span class="built_in">package</span>(), fqName.<span class="built_in">getVersion</span>(), fqName.<span class="built_in">name</span>(), instanceName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配包名, 版本, instance</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HalManifest::forEachInstanceOfVersion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; package, <span class="type">const</span> Version&amp; expectVersion,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::function&lt;<span class="type">bool</span>(<span class="type">const</span> ManifestInstance&amp;)&gt;&amp; func)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> ManifestHal* hal : <span class="built_in">getHals</span>(package)) &#123;</span><br><span class="line">        <span class="type">bool</span> cont = hal-&gt;forEachInstance([&amp;](<span class="type">const</span> ManifestInstance&amp; manifestInstance) &#123;</span><br><span class="line">            <span class="keyword">if</span> (manifestInstance.<span class="built_in">version</span>().<span class="built_in">minorAtLeast</span>(expectVersion)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">func</span>(manifestInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!cont) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">transport = e.<span class="built_in">transport</span>();</span><br><span class="line"><span class="comment">// 返回匹配hidl服务的接口类型  hwbinder/passthrough/empty</span></span><br><span class="line"><span class="keyword">return</span> transport;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">&quot;hidl&quot;</span>&gt;</span></span><br><span class="line">    // packagename</span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>IServiceManager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fqname</span>&gt;</span>@1.2::IServiceManager/default<span class="tag">&lt;/<span class="name">fqname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-1-小结"><a href="#1-4-1-小结" class="headerlink" title="1.4.1. 小结"></a>1.4.1. 小结</h4><p>上面主要是getTransport的流程, 解析了system&#x2F;etc&#x2F;vintf和product&#x2F;etc&#x2F;vintf下的manifest xml文件. vendor和odm的流程是一致的, 注意解析的过程中不能出现解析错误 (目录错误, 文件打开错误, 文件损坏等), 出现错误后, 所有之前的解析结果全部作废.</p>
<h3 id="1-5-hwservicemanager中查询hidl服务"><a href="#1-5-hwservicemanager中查询hidl服务" class="headerlink" title="1.5. hwservicemanager中查询hidl服务"></a>1.5. hwservicemanager中查询hidl服务</h3><p>getStub为false时, 通过manifest解析transport类型.  以Keymaster为例, 了解下大概的查找流程.</p>
<p>keymaster的接口描述在<code>/vendor/etc/vintf/manifest.xml</code>中</p>
<p>这里通过sm-&gt;get(descriptor, instance)查询IKeymasterDevice这个hidl服务，得到IBase对象后，在通过IKeymasterDevice::castFrom转换为IKeymasterDevice对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;sp&lt;IBase&gt;&gt; ret = sm-&gt;<span class="built_in">get</span>(descriptor, instance);</span><br><span class="line">sp&lt;IBase&gt; base = ret;</span><br><span class="line">Return&lt;<span class="type">bool</span>&gt; canCastRet = details::<span class="built_in">canCastInterface</span>(base.<span class="built_in">get</span>(), descriptor.<span class="built_in">c_str</span>(), <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br></pre></td></tr></table></figure>

<p>sm对象来自</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hwservicemanager在初始化后, 会注册自己成为ContextManager   </span></span><br><span class="line"><span class="comment">//     ProcessState::self()-&gt;becomeContextManager(nullptr, nullptr);</span></span><br><span class="line"><span class="comment">// getContextObject(0) 就是拿的manager对象</span></span><br><span class="line"><span class="keyword">using</span> IServiceManager1_2 = android::hidl::manager::V1_2::IServiceManager;</span><br><span class="line">gDefaultServiceManager =</span><br><span class="line">                <span class="built_in">fromBinder</span>&lt;IServiceManager1_2, BpHwServiceManager, BnHwServiceManager&gt;(</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>sm-&gt;get的实现在<a href="mailto:&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#46;&#104;&#105;&#100;&#108;&#46;&#109;&#x61;&#x6e;&#97;&#x67;&#x65;&#x72;&#64;&#49;&#46;&#x32;">&#97;&#110;&#x64;&#x72;&#111;&#x69;&#100;&#46;&#104;&#105;&#100;&#108;&#46;&#109;&#x61;&#x6e;&#97;&#x67;&#x65;&#x72;&#64;&#49;&#46;&#x32;</a>中.</p>
<p><a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/system/libhidl/transport/manager/1.2/">system&#x2F;libhidl&#x2F;transport&#x2F;manager&#x2F;1.2&#x2F;</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//out/soong/.intermediates/system/libhidl/transport/manager/1.2/android.hidl.manager@1.2_genc++/gen/android/hidl/manager/1.2/ServiceManagerAll.cpp</span></span><br><span class="line"><span class="comment">// Methods from ::android::hidl::manager::V1_0::IServiceManager follow.</span></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::<span class="built_in">get</span>(<span class="type">const</span> ::android::hardware::hidl_string&amp; fqName, <span class="type">const</span> ::android::hardware::hidl_string&amp; name)&#123;</span><br><span class="line">    ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_get(<span class="keyword">this</span>, <span class="keyword">this</span>, fqName, name);</span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/11/12/OTA%E7%9B%B8%E5%85%B3/Q%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/OTA%E7%9B%B8%E5%85%B3/Q%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">Q动态分区调研</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-11-12T18:15:54+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:22:45" itemprop="dateModified" datetime="2024-04-16T15:22:45+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Q动态分区调研"><a href="#1-Q动态分区调研" class="headerlink" title="1. Q动态分区调研"></a>1. Q动态分区调研</h1><h2 id="1-1-相关文档"><a href="#1-1-相关文档" class="headerlink" title="1.1. 相关文档"></a>1.1. 相关文档</h2><p> [Android Bootcamp 2019 - Dynamic Partitions in Q (go_android-dynamic-partitions-slides).pdf](..&#x2F;..&#x2F;..&#x2F;google_document&#x2F;Android Bootcamp 2019 - Dynamic Partitions in Q (go_android-dynamic-partitions-slides).pdf) </p>
<p> <a href="../../../google_document/06._Dynamic_Partitions_-_LPC_Android_MC_v2.pdf">06.<em>Dynamic_Partitions</em>-_LPC_Android_MC_v2.pdf</a> </p>
<h2 id="1-2-代码路径"><a href="#1-2-代码路径" class="headerlink" title="1.2. 代码路径"></a>1.2. 代码路径</h2><p>bootable&#x2F;recovery&#x2F;updater&#x2F; <a href="../../../../work_space/q9/bootable/recovery/updater/dynamic_partitions.cpp">dynamic_partitions.cpp</a> </p>
<p>system&#x2F;core&#x2F;fs_mgr&#x2F; <a href="/home/mi/work_space/q9/system/core/fs_mgr/liblp">liblp</a></p>
<p>system&#x2F;core&#x2F;fastboot&#x2F;device  <a href="/home/mi/work_space/q9/system/core/fastboot/device">fastbootd</a></p>
<p>build&#x2F;core&#x2F;Makefile</p>
<h2 id="1-3-宏配置"><a href="#1-3-宏配置" class="headerlink" title="1.3. 宏配置"></a>1.3. 宏配置</h2><ul>
<li>PRODUCT_USE_DYNAMIC_PARTITIONS :&#x3D; true</li>
<li>BOARD_SUPER_PARTITION_SIZE :&#x3D; <size-in-bytes></li>
<li>BOARD_SUPER_PARTITION_GROUPS :&#x3D; group_oem</li>
<li>BOARD_GROUP_OEM_SIZE :&#x3D; <size-in-bytes></li>
<li>BOARD_GROUP_OEM_PARTITION_LIST :&#x3D; system vendor odm product</li>
<li>BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE</li>
</ul>
<blockquote>
<p># BOARD_SUPER_PARTITION_GROUPS defines a list of “updatable groups”. Each updatable group is a  group of partitions that share the same pool of free spaces.  For each group in BOARD_SUPER_PARTITION_GROUPS, a BOARD_{GROUP}<em>SIZE and BOARD</em>{GROUP}_PARTITION_PARTITION_LIST may be defined.  </p>
<ul>
<li><p>BOARD_{GROUP}_SIZE: The maximum sum of sizes of all partitions in the group. Must not be empty.</p>
</li>
<li><p>BOARD_{GROUP}_PARTITION_PARTITION_LIST: the list of partitions that belongs to this group. If empty, no partitions belong to this group, and the sum of sizes is effectively 0.</p>
</li>
</ul>
</blockquote>
<h2 id="1-4-刷机"><a href="#1-4-刷机" class="headerlink" title="1.4. 刷机"></a>1.4. 刷机</h2><p>对于动态分区的特有img, 可以直接通过fastboot 烧写super.img, super.img是包含所有设定为动态的分区的镜像的总和.</p>
<p>也可以进入用户空间的fastbootd, 烧写单独的动态的分区.</p>
<ul>
<li>fastboot reboot fastboot</li>
</ul>
<h3 id="1-4-1-fastbootd-commands"><a href="#1-4-1-fastbootd-commands" class="headerlink" title="1.4.1. fastbootd commands"></a>1.4.1. fastbootd commands</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
<th>Available when device is OEM locked</th>
</tr>
</thead>
<tbody><tr>
<td>getvar is-userspace</td>
<td>Return yes</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar<br/>is-logical:<partition></td>
<td>Return yes if the given partition is a<br/>logical partition, no otherwise</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar super-partition-name</td>
<td>MUST return super for a device<br/>launching with logical partitions</td>
<td>Yes</td>
</tr>
<tr>
<td>create-logical-partition<br/><partition> <size></td>
<td>Create a logical partition with the<br/>given name and size</td>
<td>No</td>
</tr>
<tr>
<td>delete-logical-partition<br/><partition></td>
<td>Delete the given logical partition</td>
<td>No</td>
</tr>
<tr>
<td>resize-logical-partition<br/><partition> <size></td>
<td>Resize the logical partition to the new<br/>size without changing its contents</td>
<td>No</td>
</tr>
<tr>
<td>update-super <partition></td>
<td>Similar to flash super, except rather<br/>than flashing raw data to the super<br/>partition, this will ensure that all<br/>partitions within the downloaded<br/>image are created</td>
<td>No</td>
</tr>
<tr>
<td>getvar max-download-size</td>
<td>Return the maximum size of an image<br/>that can be downloaded in bytes in<br/>hex</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar partition-type<br/><partition-name></td>
<td>Return file system type: ext4, f2fs,<br/>raw</td>
<td>Yes</td>
</tr>
<tr>
<td>flash <partition name> [<br/><filename> ]</td>
<td>Flash the partition through a series of<br/>download and flash fastboot<br/>protocol commands</td>
<td>No</td>
</tr>
<tr>
<td>reboot bootloader</td>
<td>Reboot into bootloader mode</td>
<td>Yes</td>
</tr>
<tr>
<td>reboot fastboot</td>
<td>Reboot back into fastbootd mode</td>
<td>Yes</td>
</tr>
</tbody></table>
<h2 id="1-5-super-partition-布局"><a href="#1-5-super-partition-布局" class="headerlink" title="1.5. super partition 布局"></a>1.5. super partition 布局</h2><p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145705297_155299023.png" alt="init"><br><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145723177_2107832549.png" alt="1568031243961"></p>
<h3 id="1-5-1-概要"><a href="#1-5-1-概要" class="headerlink" title="1.5.1. 概要"></a>1.5.1. 概要</h3><ul>
<li>所有动态大小的分区填充到一个有固定大小的super的镜像文件中(最终烧写到super 物理分区中)</li>
<li>super的镜像中包含这些可以调整大小的子分区的内容和一些描述信息.</li>
<li>可以调整大小的分区对应在实际的物理分区表中被super替代了</li>
<li>非只读分区不能配置进去</li>
</ul>
<h3 id="1-5-2-实现"><a href="#1-5-2-实现" class="headerlink" title="1.5.2. 实现"></a>1.5.2. 实现</h3><ul>
<li>super镜像文件中预留1M空间给动态分区表:<ul>
<li>动态分区名+块的索引</li>
<li>上述描述信息(metadata)的备份</li>
<li>AB系统的A&#x2F;B各自的描述信息</li>
</ul>
</li>
<li>描述信息(metadata)统一由liblp管理</li>
<li>liblp被集成在init&#x2F;updata_engine&#x2F;OTA updater&#x2F;fastbootd中</li>
<li>liblp是用户空间的, kernel bootloader访问不到</li>
</ul>
<h3 id="1-5-3-AB-non-ab-metadata的配置"><a href="#1-5-3-AB-non-ab-metadata的配置" class="headerlink" title="1.5.3. AB&#x2F;non_ab metadata的配置"></a>1.5.3. AB&#x2F;non_ab metadata的配置</h3><ul>
<li>AB系统, AB各一套metadata<ul>
<li>正在运行的系统读取另外一个未运行的系统的metadata</li>
<li>保证目标版本升级失败后仍能回退老的版本</li>
</ul>
</li>
<li>non_AB系统, 有一个备份的metadata, 防止在metadata进行update时意外断电引起的metadata损坏.</li>
</ul>
<h2 id="1-6-开机修改"><a href="#1-6-开机修改" class="headerlink" title="1.6. 开机修改"></a>1.6. 开机修改</h2><ul>
<li>boot里又加上ramdisk了</li>
<li>boot的ramdisk里包含了first-stage阶段的init和vendor的fstab<ul>
<li>init在first-stage阶段使用liblp解析super分区的metadata描述信息, 为super中包含的每一个可调大小的子分区创建对应的dm设备</li>
<li>上述这些子分区在fstab中标识first_stage_mount的首先挂载上</li>
</ul>
</li>
<li>system被挂载上后, boot的ramdisk被丢弃, 切换到second-stage阶段的init(system_root的ramdisk)</li>
</ul>
<h2 id="1-7-动态分区调整大小代码跟踪"><a href="#1-7-动态分区调整大小代码跟踪" class="headerlink" title="1.7. 动态分区调整大小代码跟踪"></a>1.7. 动态分区调整大小代码跟踪</h2><p>以增加分区大小为例, 跟踪下相关调用过程:</p>
<p>update_script</p>
<p>resize system <size></p>
<p>PerformOpResize</p>
<p>需要先构造builder, 从builder中找到partition, 再通过builder的ResizePartition接口调整相应的分区大小.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">auto</span> partition = params.builder-&gt;<span class="built_in">FindPartition</span>(partition_name);</span><br><span class="line"><span class="comment">// 调整分区前先要将对应的dm设备销毁</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">UnmapPartitionOnDeviceMapper</span>(partition_name)</span><br><span class="line"><span class="number">3.</span> builder-&gt;<span class="built_in">ResizePartition</span>(partition, size.<span class="built_in">value</span>());</span><br></pre></td></tr></table></figure>

<h3 id="1-7-1-构造builder-MetadataBuilder"><a href="#1-7-1-构造builder-MetadataBuilder" class="headerlink" title="1.7.1. 构造builder(MetadataBuilder)"></a>1.7.1. 构造builder(MetadataBuilder)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应super的block设备节点  </span></span><br><span class="line"><span class="keyword">auto</span> super_device = <span class="built_in">GetSuperDevice</span>();</span><br><span class="line"><span class="keyword">auto</span> builder = MetadataBuilder::<span class="built_in">New</span>(<span class="built_in">PartitionOpener</span>(), super_device, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>创建MetadataBuilder的实例前先需要读出super中的metadata信息(描述super中各个子分区的布局情况)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;LpMetadata&gt; metadata = <span class="built_in">ReadMetadata</span>(opener, super_partition, slot_number);</span><br></pre></td></tr></table></figure>

<h4 id="1-7-1-1-解析metadata过程涉及到的相关结构体"><a href="#1-7-1-1-解析metadata过程涉及到的相关结构体" class="headerlink" title="1.7.1.1. 解析metadata过程涉及到的相关结构体"></a>1.7.1.1. 解析metadata过程涉及到的相关结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//metadata信息在super中的配置信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataGeometry</span> &#123;</span><br><span class="line">    <span class="comment">/*  0: Magic signature (LP_METADATA_GEOMETRY_MAGIC). */</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;</span><br><span class="line">    <span class="comment">/*  4: Size of the LpMetadataGeometry struct. */</span></span><br><span class="line">    <span class="type">uint32_t</span> struct_size;</span><br><span class="line">    <span class="comment">/*  8: SHA256 checksum of this struct, with this field set to 0. */</span></span><br><span class="line">    <span class="type">uint8_t</span> checksum[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">/* 40: Maximum amount of space a single copy of the metadata can use. This</span></span><br><span class="line"><span class="comment">     * must be a multiple of LP_SECTOR_SIZE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> metadata_max_size;</span><br><span class="line">    <span class="comment">/* 44: Number of copies of the metadata to keep. For A/B devices, this</span></span><br><span class="line"><span class="comment">     * will be 2. For an A/B/C device, it would be 3, et cetera. For Non-A/B</span></span><br><span class="line"><span class="comment">     * it will be 1. A backup copy of each slot is kept, so if this is &quot;2&quot;,</span></span><br><span class="line"><span class="comment">     * there will be four copies total.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> metadata_slot_count;</span><br><span class="line">    <span class="comment">/* 48: Logical block size. This is the minimal alignment for partition and</span></span><br><span class="line"><span class="comment">     * extent sizes, and it must be a multiple of LP_SECTOR_SIZE. Note that</span></span><br><span class="line"><span class="comment">     * this must be equal across all LUNs that comprise the super partition,</span></span><br><span class="line"><span class="comment">     * and thus this field is stored in the geometry, not per-device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> logical_block_size;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataGeometry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The logical partition metadata has a number of tables; they are described</span></span><br><span class="line"><span class="comment"> * in the header via the following structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// LpMetaDataHeader中对partition/extent/group的描述信息, 用来offset偏移找到对应的数据段填充对应的结构体.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataTableDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">/*  0: Location of the table, relative to end of the metadata header. */</span></span><br><span class="line">    <span class="type">uint32_t</span> offset;</span><br><span class="line">    <span class="comment">// entry_size * num_entries = size of the table</span></span><br><span class="line">    <span class="comment">/*  4: Number of entries in the table. */</span></span><br><span class="line">    <span class="type">uint32_t</span> num_entries;</span><br><span class="line">    <span class="comment">/*  8: Size of each entry in the table, in bytes. */</span></span><br><span class="line">    <span class="type">uint32_t</span> entry_size;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataTableDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//metadata位于物理分区的描述头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataHeader</span> &#123;</span><br><span class="line">    <span class="comment">/*  0: Four bytes equal to LP_METADATA_HEADER_MAGIC. */</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  4: Version number required to read this metadata. If the version is not</span></span><br><span class="line"><span class="comment">     * equal to the library version, the metadata should be considered</span></span><br><span class="line"><span class="comment">     * incompatible.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> major_version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  6: Minor version. A library supporting newer features should be able to</span></span><br><span class="line"><span class="comment">     * read metadata with an older minor version. However, an older library</span></span><br><span class="line"><span class="comment">     * should not support reading metadata if its minor version is higher.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> minor_version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  8: The size of this header struct. */</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 12: SHA256 checksum of the header, up to |header_size| bytes, computed as</span></span><br><span class="line"><span class="comment">     * if this field were set to 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> header_checksum[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 44: The total size of all tables. This size is contiguous; tables may not</span></span><br><span class="line"><span class="comment">     * have gaps in between, and they immediately follow the header.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> tables_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 48: SHA256 checksum of all table contents. */</span></span><br><span class="line">    <span class="type">uint8_t</span> tables_checksum[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 80: Partition table descriptor. */</span></span><br><span class="line">    <span class="comment">// partitions表描述信息</span></span><br><span class="line">    LpMetadataTableDescriptor partitions;</span><br><span class="line">    <span class="comment">/* 92: Extent table descriptor. */</span></span><br><span class="line">    <span class="comment">// partition 区间块组描述信息</span></span><br><span class="line">    LpMetadataTableDescriptor extents;</span><br><span class="line">    <span class="comment">/* 104: Updateable group descriptor. */</span></span><br><span class="line">    <span class="comment">// parition group表描述信息</span></span><br><span class="line">    LpMetadataTableDescriptor groups;</span><br><span class="line">    <span class="comment">/* 116: Block device table. */</span></span><br><span class="line">    <span class="comment">// block_devices表描述信息, 第一个必须是super, 如super中包含system/vendor等,第2个是system</span></span><br><span class="line">    LpMetadataTableDescriptor block_devices;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各动态分区的描述信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataPartition</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="comment">/* 36: Attributes for the partition (see LP_PARTITION_ATTR_* flags above). */</span></span><br><span class="line">    <span class="type">uint32_t</span> attributes;</span><br><span class="line">    <span class="comment">/* 40: Index of the first extent owned by this partition. The extent will</span></span><br><span class="line"><span class="comment">     * start at logical sector 0. Gaps between extents are not allowed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> first_extent_index;</span><br><span class="line">    <span class="comment">/* 44: Number of extents in the partition. Every partition must have at</span></span><br><span class="line"><span class="comment">     * least one extent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> num_extents;</span><br><span class="line">    <span class="comment">/* 48: Group this partition belongs to. */</span></span><br><span class="line">    <span class="type">uint32_t</span> group_index;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataPartition;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This struct defines an extent entry in the extent table block. */</span></span><br><span class="line"><span class="comment">// 各动态分区的区间块的描述信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataExtent</span> &#123;</span><br><span class="line">    <span class="comment">/*  0: Length of this extent, in 512-byte sectors. */</span></span><br><span class="line">    <span class="type">uint64_t</span> num_sectors;</span><br><span class="line">    <span class="comment">/*  8: Target type for device-mapper (see LP_TARGET_TYPE_* values). */</span></span><br><span class="line">    <span class="type">uint32_t</span> target_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 12: Contents depends on target_type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * LINEAR: The sector on the physical partition that this extent maps onto.</span></span><br><span class="line"><span class="comment">     * ZERO: This field must be 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> target_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 20: Contents depends on target_type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * LINEAR: Must be an index into the block devices table.</span></span><br><span class="line"><span class="comment">     * ZERO: This field must be 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> target_source;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataExtent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataPartitionGroup</span> &#123;</span><br><span class="line">    <span class="comment">/*  0: Name of this group. Any unused characters must be 0. */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 36: Flags (see LP_GROUP_*). */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 40: Maximum size in bytes. If 0, the group has no maximum size. */</span></span><br><span class="line">    <span class="type">uint64_t</span> maximum_size;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataPartitionGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This struct defines an entry in the block_devices table. There must be at</span></span><br><span class="line"><span class="comment"> * least one device, and the first device must represent the partition holding</span></span><br><span class="line"><span class="comment"> * the super metadata.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LpMetadataBlockDevice</span> &#123;</span><br><span class="line">    <span class="comment">/* 0: First usable sector for allocating logical partitions. this will be</span></span><br><span class="line"><span class="comment">     * the first sector after the initial geometry blocks, followed by the</span></span><br><span class="line"><span class="comment">     * space consumed by metadata_max_size*metadata_slot_count*2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> first_logical_sector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8: Alignment for defining partitions or partition extents. For example,</span></span><br><span class="line"><span class="comment">     * an alignment of 1MiB will require that all partitions have a size evenly</span></span><br><span class="line"><span class="comment">     * divisible by 1MiB, and that the smallest unit the partition can grow by</span></span><br><span class="line"><span class="comment">     * is 1MiB.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alignment is normally determined at runtime when growing or adding</span></span><br><span class="line"><span class="comment">     * partitions. If for some reason the alignment cannot be determined, then</span></span><br><span class="line"><span class="comment">     * this predefined alignment in the geometry is used instead. By default</span></span><br><span class="line"><span class="comment">     * it is set to 1MiB.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> alignment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 12: Alignment offset for &quot;stacked&quot; devices. For example, if the &quot;super&quot;</span></span><br><span class="line"><span class="comment">     * partition itself is not aligned within the parent block device&#x27;s</span></span><br><span class="line"><span class="comment">     * partition table, then we adjust for this in deciding where to place</span></span><br><span class="line"><span class="comment">     * |first_logical_sector|.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Similar to |alignment|, this will be derived from the operating system.</span></span><br><span class="line"><span class="comment">     * If it cannot be determined, it is assumed to be 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> alignment_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 16: Block device size, as specified when the metadata was created. This</span></span><br><span class="line"><span class="comment">     * can be used to verify the geometry against a target device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 24: Partition name in the GPT. Any unused characters must be 0. */</span></span><br><span class="line">    <span class="type">char</span> partition_name[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 60: Flags (see LP_BLOCK_DEVICE_* flags below). */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">&#125; __attribute__((packed)) LpMetadataBlockDevice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// metadata结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LpMetadata</span> &#123;</span><br><span class="line">    LpMetadataGeometry geometry;</span><br><span class="line">    LpMetadataHeader header;</span><br><span class="line">    std::vector&lt;LpMetadataPartition&gt; partitions;</span><br><span class="line">    std::vector&lt;LpMetadataExtent&gt; extents;</span><br><span class="line">    std::vector&lt;LpMetadataPartitionGroup&gt; groups;</span><br><span class="line">    std::vector&lt;LpMetadataBlockDevice&gt; block_devices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-1-2-读取metadata配置信息"><a href="#1-7-1-2-读取metadata配置信息" class="headerlink" title="1.7.1.2. 读取metadata配置信息"></a>1.7.1.2. 读取metadata配置信息</h4><p>以非AB系统为例, slot_number在geometry中存储的信息为1</p>
<p>略过super的头4k, 读取第2个4K内容(primaryGeometry), 填充<strong>LpMetadataGeometry</strong>结构体.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read and validate geometry information from a block device that holds</span></span><br><span class="line"><span class="comment">// logical partitions. If the information is corrupted, this will attempt</span></span><br><span class="line"><span class="comment">// to read it from a secondary backup location.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReadLogicalPartitionGeometry</span><span class="params">(<span class="type">int</span> fd, LpMetadataGeometry* geometry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReadPrimaryGeometry</span>(fd, geometry)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReadBackupGeometry</span>(fd, geometry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReadPrimaryGeometry</span><span class="params">(<span class="type">int</span> fd, LpMetadataGeometry* geometry)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; buffer = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(LP_METADATA_GEOMETRY_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SeekFile64</span>(fd, <span class="built_in">GetPrimaryGeometryOffset</span>(), SEEK_SET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::<span class="built_in">ReadFully</span>(fd, buffer.<span class="built_in">get</span>(), LP_METADATA_GEOMETRY_SIZE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseGeometry</span>(buffer.<span class="built_in">get</span>(), geometry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(geometry, buffer, <span class="built_in">sizeof</span>(*geometry));</span><br></pre></td></tr></table></figure>

<p>读取第3个4K内容(backup_geometry), 填充到backup_geometry</p>
<p>从第4个4k开始, 读取geometry中配置的metadata大小, 填充到<strong>LpMetadata</strong>结构体, primary_metadata.</p>
<p>…</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse and validate all metadata at the current position in the given file</span></span><br><span class="line"><span class="comment">// descriptor.</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;LpMetadata&gt; <span class="title">ParseMetadata</span><span class="params">(<span class="type">const</span> LpMetadataGeometry&amp; geometry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 Reader* reader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 填充LpMetadataHeader, 包含了metadata的版本等</span></span><br><span class="line">    std::unique_ptr&lt;LpMetadata&gt; metadata = std::<span class="built_in">make_unique</span>&lt;LpMetadata&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!reader-&gt;<span class="built_in">ReadFully</span>(&amp;metadata-&gt;header, <span class="built_in">sizeof</span>(metadata-&gt;header))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidateMetadataHeader</span>(metadata-&gt;header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充LpMetadataGeometry</span></span><br><span class="line">    metadata-&gt;geometry = geometry;</span><br><span class="line">    LpMetadataHeader&amp; header = metadata-&gt;header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the metadata payload. Allocation is fallible in case the metadata is</span></span><br><span class="line">    <span class="comment">// corrupt and has some huge value.</span></span><br><span class="line">    <span class="comment">// 读取LpMetadata中LpMetaDataHeader外剩下的数据, 算一个checksum和header中的checksum比对, 必须是一致的</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">buffer</span><span class="params">(<span class="keyword">new</span> (std::nothrow) <span class="type">uint8_t</span>[header.tables_size])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!reader-&gt;<span class="built_in">ReadFully</span>(buffer.<span class="built_in">get</span>(), header.tables_size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint8_t</span> checksum[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">SHA256</span>(buffer.<span class="built_in">get</span>(), header.tables_size, checksum);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(checksum, header.tables_checksum, <span class="built_in">sizeof</span>(checksum)) != <span class="number">0</span>) &#123;</span><br><span class="line">        LERROR &lt;&lt; <span class="string">&quot;Logical partition metadata has invalid table checksum.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ValidateTableSize ensured that |cursor| is valid for the number of</span></span><br><span class="line">    <span class="comment">// entries in the table.</span></span><br><span class="line">    <span class="comment">// header中记录了partition 表的信息,包含了offset, 有几个分区,每个分区item的大小</span></span><br><span class="line">    <span class="type">uint8_t</span>* cursor = buffer.<span class="built_in">get</span>() + header.partitions.offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; header.partitions.num_entries; i++) &#123;</span><br><span class="line">        LpMetadataPartition partition;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;partition, cursor, <span class="built_in">sizeof</span>(partition));</span><br><span class="line">        <span class="comment">// 一共num_entries个partition, 遍历metadata的partition table, cursor记录了每个partition的头</span></span><br><span class="line">        cursor += header.partitions.entry_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// partion校验</span></span><br><span class="line">        <span class="keyword">if</span> (partition.attributes &amp; ~LP_PARTITION_ATTRIBUTE_MASK) &#123;</span><br><span class="line">            LERROR &lt;&lt; <span class="string">&quot;Logical partition has invalid attribute set.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 填充LpMetadata的partitions vector</span></span><br><span class="line">        metadata-&gt;partitions.<span class="built_in">push_back</span>(partition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor = buffer.<span class="built_in">get</span>() + header.extents.offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; header.extents.num_entries; i++) &#123;</span><br><span class="line">        LpMetadataExtent extent;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;extent, cursor, <span class="built_in">sizeof</span>(extent));</span><br><span class="line">        cursor += header.extents.entry_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extent.target_type == LP_TARGET_TYPE_LINEAR &amp;&amp;</span><br><span class="line">            extent.target_source &gt;= header.block_devices.num_entries) &#123;</span><br><span class="line">            LERROR &lt;&lt; <span class="string">&quot;Logical partition extent has invalid block device.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        metadata-&gt;extents.<span class="built_in">push_back</span>(extent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor = buffer.<span class="built_in">get</span>() + header.groups.offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; header.groups.num_entries; i++) &#123;</span><br><span class="line">        LpMetadataPartitionGroup group = &#123;&#125;;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;group, cursor, <span class="built_in">sizeof</span>(group));</span><br><span class="line">        cursor += header.groups.entry_size;</span><br><span class="line"></span><br><span class="line">        metadata-&gt;groups.<span class="built_in">push_back</span>(group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor = buffer.<span class="built_in">get</span>() + header.block_devices.offset;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; header.block_devices.num_entries; i++) &#123;</span><br><span class="line">        LpMetadataBlockDevice device = &#123;&#125;;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;device, cursor, <span class="built_in">sizeof</span>(device));</span><br><span class="line">        cursor += header.block_devices.entry_size;</span><br><span class="line"></span><br><span class="line">        metadata-&gt;block_devices.<span class="built_in">push_back</span>(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> LpMetadataBlockDevice* super_device = <span class="built_in">GetMetadataSuperBlockDevice</span>(*metadata.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (!super_device) &#123;</span><br><span class="line">        LERROR &lt;&lt; <span class="string">&quot;Metadata does not specify a super device.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145634636_712779062.png" alt="1568276907369"></p>
<h4 id="1-7-1-3-builder初始化"><a href="#1-7-1-3-builder初始化" class="headerlink" title="1.7.1.3. builder初始化"></a>1.7.1.3. builder初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;MetadataBuilder&gt; <span class="title">MetadataBuilder::New</span><span class="params">(<span class="type">const</span> LpMetadata&amp; metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> IPartitionOpener* opener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. builder构造函数</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;MetadataBuilder&gt; <span class="title">builder</span><span class="params">(<span class="keyword">new</span> MetadataBuilder())</span></span>;</span><br><span class="line">    <span class="comment">//2. builder init函数</span></span><br><span class="line">    <span class="keyword">if</span> (!builder-&gt;<span class="built_in">Init</span>(metadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetadataBuilder::<span class="built_in">MetadataBuilder</span>() : <span class="built_in">auto_slot_suffixing_</span>(<span class="literal">false</span>), <span class="built_in">ignore_slot_suffixing_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化geometry和header_ </span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;geometry_, <span class="number">0</span>, <span class="built_in">sizeof</span>(geometry_));</span><br><span class="line">    geometry_.magic = LP_METADATA_GEOMETRY_MAGIC;</span><br><span class="line">    geometry_.struct_size = <span class="built_in">sizeof</span>(geometry_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;header_, <span class="number">0</span>, <span class="built_in">sizeof</span>(header_));</span><br><span class="line">    header_.magic = LP_METADATA_HEADER_MAGIC;</span><br><span class="line">    header_.major_version = LP_METADATA_MAJOR_VERSION;</span><br><span class="line">    header_.minor_version = LP_METADATA_MINOR_VERSION;</span><br><span class="line">    header_.header_size = <span class="built_in">sizeof</span>(header_);</span><br><span class="line">    header_.partitions.entry_size = <span class="built_in">sizeof</span>(LpMetadataPartition);</span><br><span class="line">    header_.extents.entry_size = <span class="built_in">sizeof</span>(LpMetadataExtent);</span><br><span class="line">    header_.groups.entry_size = <span class="built_in">sizeof</span>(LpMetadataPartitionGroup);</span><br><span class="line">    header_.block_devices.entry_size = <span class="built_in">sizeof</span>(LpMetadataBlockDevice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前面解析出的metadata信息中初始化builder的成员变量.</span></span><br><span class="line"><span class="comment">// 执行AddGroup/AddPartition/ImportExtents函数, 初始化block_devices_ groups_ paritions_ extents_成员变量</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MetadataBuilder::Init</span><span class="params">(<span class="type">const</span> LpMetadata&amp; metadata)</span> </span>&#123;</span><br><span class="line">    geometry_ = metadata.geometry;</span><br><span class="line">    block_devices_ = metadata.block_devices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : metadata.groups) &#123;</span><br><span class="line">        std::string group_name = <span class="built_in">GetPartitionGroupName</span>(group);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">AddGroup</span>(group_name, group.maximum_size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; partition : metadata.partitions) &#123;</span><br><span class="line">        std::string group_name = <span class="built_in">GetPartitionGroupName</span>(metadata.groups[partition.group_index]);</span><br><span class="line">        Partition* builder =</span><br><span class="line">                <span class="built_in">AddPartition</span>(<span class="built_in">GetPartitionName</span>(partition), group_name, partition.attributes);</span><br><span class="line">        <span class="keyword">if</span> (!builder) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对某一特定的partition执行时, 会判断extent是否相邻, 如果是相邻的, 会进行合并</span></span><br><span class="line">        <span class="built_in">ImportExtents</span>(builder, metadata, partition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-2-builder-ResizePartition"><a href="#1-7-2-builder-ResizePartition" class="headerlink" title="1.7.2. builder-&gt;ResizePartition"></a>1.7.2. builder-&gt;ResizePartition</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">builder-&gt;<span class="built_in">ResizePartition</span>(partition, size.<span class="built_in">value</span>();</span><br><span class="line"><span class="type">bool</span> MetadataBuilder::<span class="built_in">ResizePartition</span>(Partition* partition, <span class="type">uint64_t</span> requested_size) &#123;</span><br><span class="line">    <span class="comment">// Align the space needed up to the nearest sector.</span></span><br><span class="line">    <span class="comment">// 先对新size进行对齐</span></span><br><span class="line">    <span class="type">uint64_t</span> aligned_size = <span class="built_in">AlignTo</span>(requested_size, geometry_.logical_block_size);</span><br><span class="line">    <span class="type">uint64_t</span> old_size = partition-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 1. 看下新size是否超出了可调整的范围</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidatePartitionSizeChange</span>(partition, old_size, aligned_size, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 分区增大了</span></span><br><span class="line">    <span class="keyword">if</span> (aligned_size &gt; old_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GrowPartition</span>(partition, aligned_size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分区较小了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aligned_size &lt; partition-&gt;<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">ShrinkPartition</span>(partition, aligned_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>怎么判断分区大小是否是合法的?</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MetadataBuilder::ValidatePartitionSizeChange</span><span class="params">(Partition* partition, <span class="type">uint64_t</span> old_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">uint64_t</span> new_size, <span class="type">bool</span> force_check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找partition所在的组</span></span><br><span class="line">    PartitionGroup* group = <span class="built_in">FindGroup</span>(partition-&gt;<span class="built_in">group_name</span>());</span><br><span class="line">    <span class="built_in">CHECK</span>(group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!force_check &amp;&amp; new_size &lt;= old_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out how much we need to allocate, and whether our group has</span></span><br><span class="line">    <span class="comment">// enough space remaining.</span></span><br><span class="line">    <span class="type">uint64_t</span> space_needed = new_size - old_size;</span><br><span class="line">    <span class="keyword">if</span> (group-&gt;<span class="built_in">maximum_size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分区组的已用空间</span></span><br><span class="line">        <span class="type">uint64_t</span> group_size = <span class="built_in">TotalSizeOfGroup</span>(group);</span><br><span class="line">        <span class="keyword">if</span> (group_size &gt;= group-&gt;<span class="built_in">maximum_size</span>() ||</span><br><span class="line">            <span class="comment">// 分区组的最大空间</span></span><br><span class="line">            group-&gt;<span class="built_in">maximum_size</span>() - group_size &lt; space_needed) &#123;</span><br><span class="line">            LERROR &lt;&lt; <span class="string">&quot;Partition &quot;</span> &lt;&lt; partition-&gt;<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; is part of group &quot;</span> &lt;&lt; group-&gt;<span class="built_in">name</span>()</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; which does not have enough space free (&quot;</span> &lt;&lt; space_needed &lt;&lt; <span class="string">&quot; requested, &quot;</span></span><br><span class="line">                   &lt;&lt; group_size &lt;&lt; <span class="string">&quot; used out of &quot;</span> &lt;&lt; group-&gt;<span class="built_in">maximum_size</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能看到分区能调整的大小受分区所在组最大空间的限制.</p>
<h4 id="1-7-2-1-调大分区"><a href="#1-7-2-1-调大分区" class="headerlink" title="1.7.2.1. 调大分区"></a>1.7.2.1. 调大分区</h4><p>找出空闲的extent, 加到当前待调整的partition的extents_中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MetadataBuilder::GrowPartition</span><span class="params">(Partition* partition, <span class="type">uint64_t</span> aligned_size)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> space_needed = aligned_size - partition-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">uint64_t</span> sectors_needed = space_needed / LP_SECTOR_SIZE;</span><br><span class="line">    <span class="comment">// 根据已有的extent, 做相邻extent的gap, gap有效即为free的</span></span><br><span class="line">    <span class="comment">//The new interval represents the free space starting at the end of</span></span><br><span class="line">        <span class="comment">//the previous interval, and ending at the start of the next interval.</span></span><br><span class="line">       <span class="comment">// free_regions-&gt;emplace_back(current.device_index, aligned, current.start);    </span></span><br><span class="line">    std::vector&lt;Interval&gt; free_regions = <span class="built_in">GetFreeRegions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> sectors_per_block = geometry_.logical_block_size / LP_SECTOR_SIZE;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;LinearExtent&gt;&gt; new_extents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the last extent in the partition has a size &lt; alignment, then the</span></span><br><span class="line">    <span class="comment">// difference is unallocatable due to being misaligned. We peek for that</span></span><br><span class="line">    <span class="comment">// case here to avoid wasting space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> extent = <span class="built_in">ExtendFinalExtent</span>(partition, free_regions, sectors_needed)) &#123;</span><br><span class="line">        sectors_needed -= extent-&gt;<span class="built_in">num_sectors</span>();</span><br><span class="line">        new_extents.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(extent));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从free_regions中查找可以空闲的extent, 给当前正在调整大小的partition使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; region : free_regions) &#123;</span><br><span class="line">        <span class="comment">// 分配够了就退出</span></span><br><span class="line">        <span class="keyword">if</span> (!sectors_needed) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">uint64_t</span> sectors = std::<span class="built_in">min</span>(sectors_needed, region.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">auto</span> extent = std::<span class="built_in">make_unique</span>&lt;LinearExtent&gt;(sectors, region.device_index, region.start);</span><br><span class="line">        new_extents.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(extent));</span><br><span class="line">        sectors_needed -= sectors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Everything succeeded, so commit the new extents.</span></span><br><span class="line">    <span class="comment">// 将新的extent加到partition对应的extents中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; extent : new_extents) &#123;</span><br><span class="line">        partition-&gt;<span class="built_in">AddExtent</span>(std::<span class="built_in">move</span>(extent));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-输出新的metadata更新到disk中"><a href="#1-7-3-输出新的metadata更新到disk中" class="headerlink" title="1.7.3. 输出新的metadata更新到disk中"></a>1.7.3. 输出新的metadata更新到disk中</h3><p>有分区变动后, 需要在内存中生成一份整体的变动后的metadata信息.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> metadata = builder-&gt;<span class="built_in">Export</span>();</span><br><span class="line"><span class="function">std::unique_ptr&lt;LpMetadata&gt; <span class="title">MetadataBuilder::Export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验group下的所有分区的空间总和小于group的最大空间</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidatePartitionGroups</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造一份新的metadata</span></span><br><span class="line">    std::unique_ptr&lt;LpMetadata&gt; metadata = std::<span class="built_in">make_unique</span>&lt;LpMetadata&gt;();</span><br><span class="line">    metadata-&gt;header = header_;</span><br><span class="line">    metadata-&gt;geometry = geometry_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign this early so the extent table can read it.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; block_device : block_devices_) &#123;</span><br><span class="line">        metadata-&gt;block_devices.<span class="built_in">emplace_back</span>(block_device);</span><br><span class="line">        <span class="keyword">if</span> (auto_slot_suffixing_) &#123;</span><br><span class="line">            metadata-&gt;block_devices.<span class="built_in">back</span>().flags |= LP_BLOCK_DEVICE_SLOT_SUFFIXED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::map&lt;std::string, <span class="type">size_t</span>&gt; group_indices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups_) &#123;</span><br><span class="line">        LpMetadataPartitionGroup out = &#123;&#125;;</span><br><span class="line">        <span class="built_in">strncpy</span>(out.name, group-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>(), <span class="built_in">sizeof</span>(out.name));</span><br><span class="line">        out.maximum_size = group-&gt;<span class="built_in">maximum_size</span>();</span><br><span class="line"></span><br><span class="line">        group_indices[group-&gt;<span class="built_in">name</span>()] = metadata-&gt;groups.<span class="built_in">size</span>();</span><br><span class="line">        metadata-&gt;groups.<span class="built_in">push_back</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flatten the partition and extent structures into an LpMetadata, which</span></span><br><span class="line">    <span class="comment">// makes it very easy to validate, serialize, or pass on to device-mapper.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; partition : partitions_) &#123;</span><br><span class="line">        LpMetadataPartition part;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;part, <span class="number">0</span>, <span class="built_in">sizeof</span>(part));</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">strncpy</span>(part.name, partition-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>(), <span class="built_in">sizeof</span>(part.name));</span><br><span class="line">        part.first_extent_index = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(metadata-&gt;extents.<span class="built_in">size</span>());</span><br><span class="line">        part.num_extents = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(partition-&gt;<span class="built_in">extents</span>().<span class="built_in">size</span>());</span><br><span class="line">        part.attributes = partition-&gt;<span class="built_in">attributes</span>();</span><br><span class="line">        <span class="keyword">if</span> (auto_slot_suffixing_) &#123;</span><br><span class="line">            part.attributes |= LP_PARTITION_ATTR_SLOT_SUFFIXED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> iter = group_indices.<span class="built_in">find</span>(partition-&gt;<span class="built_in">group_name</span>());</span><br><span class="line">        part.group_index = iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extent : partition-&gt;<span class="built_in">extents</span>()) &#123;</span><br><span class="line">            <span class="comment">// 保存到metadata的extents字段中</span></span><br><span class="line">            <span class="keyword">if</span> (!extent-&gt;<span class="built_in">AddTo</span>(metadata.<span class="built_in">get</span>())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        metadata-&gt;partitions.<span class="built_in">push_back</span>(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    metadata-&gt;header.partitions.num_entries = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(metadata-&gt;partitions.<span class="built_in">size</span>());</span><br><span class="line">    metadata-&gt;header.extents.num_entries = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(metadata-&gt;extents.<span class="built_in">size</span>());</span><br><span class="line">    metadata-&gt;header.groups.num_entries = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(metadata-&gt;groups.<span class="built_in">size</span>());</span><br><span class="line">    metadata-&gt;header.block_devices.num_entries =</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(metadata-&gt;block_devices.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将新的分区信息更新到对应的super的设备节点中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UpdatePartitionTable</span>(super_device, *metadata, <span class="number">0</span>) &#123;</span><br><span class="line">    android::base::unique_fd fd = opener.<span class="built_in">Open</span>(super_partition, O_RDWR | O_SYNC);</span><br><span class="line">    std::string blob;</span><br><span class="line">    <span class="comment">// 校验和序列化metadata数据, 如extents/partitions/block_devices字段是否是合法的.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ValidateAndSerializeMetadata</span>(opener, metadata, slot_suffix, &amp;blob)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较新老geometry的配置是否是一致的.  metadata_max_size/ metadata_slot_count / logical_block_size</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CompareGeometry</span>(geometry, old_geometry)) &#123;</span><br><span class="line">        LERROR &lt;&lt; <span class="string">&quot;Incompatible geometry in new logical partition metadata&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 往磁盘中更新primary和backup的metadata</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteMetadata</span>(fd, metadata, slot_number, blob, writer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-7-4-小结"><a href="#1-7-4-小结" class="headerlink" title="1.7.4. 小结"></a>1.7.4. 小结</h3><p>主要是对涉及到的数据结构的理解</p>
<p>对于非ab系统的(slot_count&#x3D;1)的, 可以简单看下其中涉及的结构</p>
<p>首先是geometry, 包括primary和backup的, 每个4k, 描述了metadata的配置信息.</p>
<p>其次是metadata, 包括primary和backup的, 大小信息被配置在geometry中, 描述了分区&#x2F;分区组&#x2F;分区的range块的信息.</p>
<h2 id="1-8-map-partition"><a href="#1-8-map-partition" class="headerlink" title="1.8. map partition"></a>1.8. map partition</h2><p>分区调整后, 如果当前修改的分区正在被使用中, 需要卸载unmap, 再重新map和挂载. 如果是系统分区卸载和unmap的操作会影响手机的运行, 因此手机需要重启才能重新map和挂载.</p>
<p>动态分区的调整需要重新map才能生效. 这里看下map的流程.</p>
<p>该过程与device-mapper的使用规范是紧密关联的, 只是在user space层多加了一个DeviceMapper实例对dm设备的创建查询销毁等操作进行托管.</p>
<h3 id="1-8-1-device-mapper"><a href="#1-8-1-device-mapper" class="headerlink" title="1.8.1. device-mapper"></a>1.8.1. device-mapper</h3><p><img src="/home/mi/Pictures/documents/dynamic_partition/data_analyze.zip" alt="图1 Device Mapper的内核体系架构"></p>
<p><img src="http://www.sysnote.org/2015/08/06/linux-io-stack/io-stack.png" alt="“linux storage stack”的图片搜索结果"></p>
<p>Device-mapper是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。</p>
<p>当前比较流行的 Linux 下的逻辑卷管理器如 <code>LVM2</code>（Linux Volume Manager 2 version)、<code>EVMS</code>(Enterprise Volume Management System)、<code>dmraid</code>(Device Mapper Raid Tool)等都是基于该机制实现的。</p>
<p> <code>Device Mapper</code> 工作在块级别（block），并不工作在文件级别（file）。<code>Device Mapper</code> 自 Linux 2.6.9 后编入 Linux 内核，所有基于 Linux 内核 2.6.9 以后的发行版都内置 <code>Device Mapper</code>.</p>
<p>Device mapper 在内核中作为一个块设备驱动被注册的，它包含三个重要的对象概念:</p>
<ul>
<li><p>mapped device </p>
<p>Mapped device 是一个逻辑抽象(dm-*)，可以理解成为内核向外提供的逻辑设备，它通过映射表描述的映射关系和 target device (super)建立映射。</p>
</li>
<li><p>映射表</p>
<p>是由用户空间创建，传递到内核空间。映射表里有映射设备逻辑的<code>起始地址</code>、<code>范围</code>、和表示在目标设备所在物理设备的<code>地址偏移量</code>以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到 128 的时候，其实表示的是 128*512&#x3D;64K）。</p>
</li>
<li><p>target device</p>
</li>
</ul>
<p>​       可以是真实的物理设备, 也可以是dm的虚拟设备. Device mapper 中这三个对象和 target driver 插件一起构成了一个可迭代的设备树.</p>
<p><img src="https://arkingc.github.io/img/in-post/post-linux-lvm/dm.png" alt="undefined"></p>
<p>映射驱动在内核空间是插件，<code>Device Mapper</code> 在内核中通过一个一个模块化的 <code>Target Driver</code> 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照、<code>线性映射</code>等，策略和机制分离.</p>
<p>Device mapper处理所有从<code>generic_make_request</code>和<code>submit_bio</code>接口中定向到<code>mapped device</code>的所有块读写I&#x2F;O请求。I&#x2F;O请求在device mapper的设备树中通过请求转发从上到下地进行处理. Device mapper本质功能就是根据映射关系和target driver描述的IO处理规则，将IO请求从逻辑设备mapped device转发相应的target device上</p>
<ul>
<li><strong>向下转发</strong>：当一个bio请求在设备树中的mapped deivce向下层转发时，一个或者多个bio的克隆被创建并发送给下层target device。然后相同的过程在设备树的每一个层次上重复，只要设备树足够大理论上这种转发过程可以无限进行下去</li>
<li><strong>向上返回事件</strong>：在设备树上某个层次中，target driver结束某个bio请求后，将表示结束该bio请求的事件上报给它上层的mapped device，该过程在各个层次上进行直到该事件最终上传到根mapped device的为止，然后device mapper结束根mapped device上原始bio请求，结束整个I&#x2F;O请求过程.</li>
</ul>
<h4 id="1-8-1-1-用户空间的操作规范："><a href="#1-8-1-1-用户空间的操作规范：" class="headerlink" title="1.8.1.1. 用户空间的操作规范："></a>1.8.1.1. 用户空间的操作规范：</h4><p>Device mapper库就是对ioctl、用户空间创建删除device mapper逻辑设备所需必要操作的封装，dmsetup是一个提供给用户直接可用的创建删除device mapper设备的命令行工具。用户空间主要负责如下工作：</p>
<ol>
<li>发现每个mapped device相关的target device；</li>
<li>根据配置信息创建映射表；</li>
<li>将用户空间构建好的映射表传入内核，让内核构建该mapped device对应的dm_table结构；</li>
<li>保存当前的映射信息，以便未来重新构建。</li>
</ol>
<p>dm设备举例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0    1024 linear /dev/sda 204</span><br><span class="line">1024 512  linear /dev/sdb 766</span><br><span class="line">1536 128  linear /dev/sdc 0</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/example.png" alt="undefined"></p>
<h4 id="1-8-1-2-Q上动态分区的映射"><a href="#1-8-1-2-Q上动态分区的映射" class="headerlink" title="1.8.1.2. Q上动态分区的映射"></a>1.8.1.2. Q上动态分区的映射</h4><ul>
<li>动态分区机制使用<code>dm-linear</code>设备驱动映射逻辑扇区到super中的system&#x2F;vendor等只读分区的物理扇区上.</li>
<li>通过修改大小, 动态分区可能变成片段化的</li>
</ul>
<p>&#x2F;dev&#x2F;block&#x2F;by-name&#x2F;super       super.img</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/by-name/dm-0 (system):</span><br><span class="line">	dm-linear super &lt;block range 1&gt;</span><br><span class="line">/dev/block/by-name/dm-1 (vendor):</span><br><span class="line">	dm-linear super &lt;block range 2&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145450363_1270541820.png" alt="resize partition"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/by-name/dm-0 (system):</span><br><span class="line">	dm-linear super &lt;block range 1&gt;</span><br><span class="line">	dm-linear super &lt;block range 3&gt;</span><br><span class="line">/dev/block/by-name/dm-1 (vendor):</span><br><span class="line">    dm-linear super &lt;block range 2&gt;</span><br><span class="line">    dm-linear super &lt;block range 4&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-1-3-DeviceMapper库创建-用户空间"><a href="#1-8-1-3-DeviceMapper库创建-用户空间" class="headerlink" title="1.8.1.3. DeviceMapper库创建(用户空间)"></a>1.8.1.3. DeviceMapper库创建(用户空间)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> state = DeviceMapper::<span class="built_in">Instance</span>().<span class="built_in">GetState</span>(partition_name);</span><br><span class="line"><span class="keyword">if</span> (state == DmDeviceState::INVALID) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateLogicalPartition</span>(<span class="built_in">GetSuperDevice</span>(), <span class="number">0</span> <span class="comment">/* metadata slot */</span>, partition_name,</span><br><span class="line">                                  <span class="literal">true</span> <span class="comment">/* force writable */</span>, kMapTimeout, path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">CreateLogicalPartition</span><span class="params">(<span class="type">const</span> LpMetadata&amp; metadata, <span class="type">const</span> LpMetadataPartition&amp; partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">bool</span> force_writable, <span class="type">const</span> std::chrono::milliseconds&amp; timeout_ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> std::string&amp; super_device, std::string* path)</span> </span>&#123;</span><br><span class="line">    DeviceMapper&amp; dm = DeviceMapper::<span class="built_in">Instance</span>();</span><br><span class="line"></span><br><span class="line">    DmTable table;</span><br><span class="line">    <span class="comment">// ---&gt; 1. 创建dm映射表</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateDmTable</span>(metadata, partition, super_device, &amp;table)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (force_writable) &#123;</span><br><span class="line">        table.<span class="built_in">set_readonly</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---&gt; 2. 根据映射表和target_device创建mapped_device</span></span><br><span class="line">    std::string name = <span class="built_in">GetPartitionName</span>(partition);</span><br><span class="line">    <span class="keyword">if</span> (!dm.<span class="built_in">CreateDevice</span>(name, table)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dm.<span class="built_in">GetDmDevicePathByName</span>(name, path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout_ms &gt; std::chrono::milliseconds::<span class="built_in">zero</span>()) &#123;</span><br><span class="line">    <span class="comment">// ---&gt; 3. 等待mapped_device创建完成, 超时销毁</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">fs_mgr_wait_for_file</span>(*path, timeout_ms, FileWaitMode::Exists)) &#123;</span><br><span class="line">            <span class="built_in">DestroyLogicalPartition</span>(name, &#123;&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----&gt; 1. 创建映射表</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">CreateDmTable</span><span class="params">(<span class="type">const</span> LpMetadata&amp; metadata, <span class="type">const</span> LpMetadataPartition&amp; partition,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::string&amp; super_device, DmTable* table)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> sector = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对应于一个子分区, 其中所属的extent range块已经被编排到metadata的extents段中, 是相连的. start是partition的first_extent_index, 往后num_extents个item都是属于该子分区的. 这个编排是在builder Init时通过ImportExtents函数做的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; partition.num_extents; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; extent = metadata.extents[partition.first_extent_index + i];</span><br><span class="line">        std::unique_ptr&lt;DmTarget&gt; target;</span><br><span class="line">        <span class="keyword">switch</span> (extent.target_type) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> LP_TARGET_TYPE_LINEAR: &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span>&amp; block_device = metadata.block_devices[extent.target_source];</span><br><span class="line">                std::string path;</span><br><span class="line">                <span class="built_in">GetPhysicalPartitionDevicePath</span>(metadata, block_device, super_device, &amp;path)</span><br><span class="line">                <span class="comment">// 对应每个extent range块,构造对应的target item(开始的扇区号,多少个扇区,block_device name, 映射的物理扇区的起始扇区号)</span></span><br><span class="line">                target = std::<span class="built_in">make_unique</span>&lt;DmTargetLinear&gt;(sector, extent.num_sectors, path,</span><br><span class="line">                                                          extent.target_data);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个extent range块构造的target item串联起来,放在table的targets下. target item的target_data是从小往大排的</span></span><br><span class="line">        <span class="keyword">if</span> (!table-&gt;<span class="built_in">AddTarget</span>(std::<span class="built_in">move</span>(target))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sector += extent.num_sectors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (partition.attributes &amp; LP_PARTITION_ATTR_READONLY) &#123;</span><br><span class="line">        table-&gt;<span class="built_in">set_readonly</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---&gt; 2. 根据映射表和target_device创建mapped_device</span></span><br><span class="line">dm.<span class="built_in">CreateDevice</span>(name, table)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_ioctl</span> io;</span><br><span class="line">    <span class="built_in">InitIo</span>(&amp;io, name);</span><br><span class="line">    <span class="comment">// 通过ioctl创建dm设备</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_, DM_DEV_CREATE, &amp;io)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">LoadTableAndActivate</span>(name, table) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">ioctl_buffer</span><span class="params">(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dm_ioctl), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// ==========&gt; 2.1 调用映射表的序列化函数将前面的target_序列化输出到ioctl_buffer中</span></span><br><span class="line">        ioctl_buffer += table.<span class="built_in">Serialize</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">dm_ioctl</span>* io = <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> dm_ioctl*&gt;(&amp;ioctl_buffer[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">InitIo</span>(io, name);</span><br><span class="line">        io-&gt;data_size = ioctl_buffer.<span class="built_in">size</span>();</span><br><span class="line">        io-&gt;data_start = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> dm_ioctl);</span><br><span class="line">        io-&gt;target_count = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(table.<span class="built_in">num_targets</span>());</span><br><span class="line">        <span class="keyword">if</span> (table.<span class="built_in">readonly</span>()) &#123;</span><br><span class="line">            io-&gt;flags |= DM_READONLY_FLAG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Load a table into the &#x27;inactive&#x27; slot for the device</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_, DM_TABLE_LOAD, io)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">InitIo</span>(io, name);</span><br><span class="line">        <span class="comment">// 设备处于就绪状态或resume状态, 根据上面传入的io的flag决定. 没有带DM_SUSPEND_FLAG的flag, 是走resume状态</span></span><br><span class="line">        <span class="comment">/*If a table is present in the &#x27;inactive&#x27;</span></span><br><span class="line"><span class="comment"> 		 * slot, it will be moved to the active slot, then the old table from the active slot will be               _destroyed_.  Finally the device is resumed.</span></span><br><span class="line"><span class="comment"> 		 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_, DM_DEV_SUSPEND, io)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">	<span class="comment">// 通过ioctl获取dm设备的状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ioctl</span>(fd_, DM_DEV_STATUS, &amp;io) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> dev_num = <span class="built_in">minor</span>(io.dev);</span><br><span class="line">    <span class="comment">//dm-&lt;minor&gt; 设备对应io-&gt;name(target_device)绑定的mapped_device</span></span><br><span class="line">    *path = <span class="string">&quot;/dev/block/dm-&quot;</span> + std::<span class="built_in">to_string</span>(dev_num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---&gt; 3. 等待mapped_device dm-&lt;minior&gt;创建完成, 超时销毁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面创建映射表并初始化dm设备的过程中, 最重要的参数是dmtarget的序列化做的工作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==========&gt; 2.1 调用映射表的序列化函数将前面的target_序列化输出到ioctl_buffer中</span></span><br><span class="line">ioctl_buffer += table.<span class="built_in">Serialize</span>();</span><br><span class="line"><span class="function">std::string <span class="title">DmTable::Serialize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::string table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; target : targets_) &#123;</span><br><span class="line">        table += target-&gt;<span class="built_in">Serialize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">DmTarget::Serialize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a string containing a dm_target_spec, parameter data, and an</span></span><br><span class="line">    <span class="comment">// explicit null terminator.</span></span><br><span class="line">    <span class="function">std::string <span class="title">data</span><span class="params">(<span class="keyword">sizeof</span>(dm_target_spec), <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//构造头部, block_device_ + &quot; &quot; + std::to_string(physical_sector_); // target_data</span></span><br><span class="line">    data += <span class="built_in">GetParameterString</span>();</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel expects each target to be 8-byte aligned.</span></span><br><span class="line">    <span class="type">size_t</span> padding = <span class="built_in">DM_ALIGN</span>(data.<span class="built_in">size</span>()) - data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; padding; i++) &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally fill in the dm_target_spec.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_target_spec</span>* spec = <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> dm_target_spec*&gt;(&amp;data[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 开始的扇区号</span></span><br><span class="line">    spec-&gt;sector_start = <span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">// 包含多少个扇区</span></span><br><span class="line">    spec-&gt;length = <span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 这里的name对应dm-linear的name即&quot;linear&quot;, device-mapper驱动是通过target-type转到对应的插件去处理的</span></span><br><span class="line">    <span class="built_in">snprintf</span>(spec-&gt;target_type, <span class="built_in">sizeof</span>(spec-&gt;target_type), <span class="string">&quot;%s&quot;</span>, <span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 将本段的大小偏移量作为下一段dm_target_spec的起始, 多个dm_target_spec item首尾相连</span></span><br><span class="line">    spec-&gt;next = (<span class="type">uint32_t</span>)data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户空间使用ioctl的步骤:</p>
<ul>
<li><p>先创建一个dm-ioctl和dm_target_spec对象</p>
</li>
<li><p>配置一下他们的参数</p>
</li>
<li><p>在<code>dm_target_spec</code>后面跟一个特定设备的特定参数(special param)</p>
<p>将三者结合到dm-ioctl上，通过调用一下命令就可以在device mapper中load一个dm设备了</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dm_target_spec</span> &#123;</span><br><span class="line">	__u64 sector_start;</span><br><span class="line">	__u64 length;</span><br><span class="line">	__s32 status;		<span class="comment">/* used when reading from kernel only */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Location of the next dm_target_spec.</span></span><br><span class="line"><span class="comment">	 * - When specifying targets on a DM_TABLE_LOAD command, this value is</span></span><br><span class="line"><span class="comment">	 *   the number of bytes from the start of the &quot;current&quot; dm_target_spec</span></span><br><span class="line"><span class="comment">	 *   to the start of the &quot;next&quot; dm_target_spec.</span></span><br><span class="line"><span class="comment">	 * - When retrieving targets on a DM_TABLE_STATUS command, this value</span></span><br><span class="line"><span class="comment">	 *   is the number of bytes from the start of the first dm_target_spec</span></span><br><span class="line"><span class="comment">	 *   (that follows the dm_ioctl struct) to the start of the &quot;next&quot;</span></span><br><span class="line"><span class="comment">	 *   dm_target_spec.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u32 next;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> target_type[DM_MAX_TYPE_NAME];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关ioctl源代码<a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/">kernel</a>&#x2F;<a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/">msm-4.19</a>&#x2F;<a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/">drivers</a>&#x2F;<a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/md/">md</a>&#x2F;<a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok2/xref/miui-q-umi-dev/kernel/msm-4.19/drivers/md/dm-ioctl.c">dm-ioctl.c</a></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20191121145257141_746207219.png" alt="device_map"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/11/12/OTA%E7%9B%B8%E5%85%B3/AB%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/OTA%E7%9B%B8%E5%85%B3/AB%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">AB调试笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-11-12T18:15:54+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 16:41:13" itemprop="dateModified" datetime="2024-04-16T16:41:13+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/OTA/" itemprop="url" rel="index"><span itemprop="name">OTA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AB调试笔记"><a href="#AB调试笔记" class="headerlink" title="AB调试笔记"></a>AB调试笔记</h1><p>基于androidP base.</p>
<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/ota/ab">AB官方文档</a></p>
<p>在启用了 A&#x2F;B 的设备上，可以在后台对应用进行编译，以更新到新的系统映像。如需在系统映像中选择性地加入编译脚本和二进制文件，请参阅在后台编译应用。</p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/dalvik/configure.html#other_odex">preopt相关</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/ota/ab_updates.html#compilation">AB 系统更新概括</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/ota/ab_implement.html">AB配置</a><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/ota/ab_implement.html">https://source.android.com/devices/tech/ota/ab_implement.html</a>)</p>
<h3 id="第三方文档"><a href="#第三方文档" class="headerlink" title="第三方文档"></a>第三方文档</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guyongqiangx/article/details/71334889">Android A&#x2F;B System OTA分析（一）概览</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guyongqiangx/article/details/71516768">Android A&#x2F;B System OTA分析（二）系统image的生成</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guyongqiangx/article/details/72480154">Android A&#x2F;B System OTA分析（三）主系统和bootloader的通信</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guyongqiangx/article/details/72604355">Android A&#x2F;B System OTA分析（四）系统的启动和升级</a></p>
<p>启用IBootControl服务(hidl相关配置)相关文档</p>
<p><a target="_blank" rel="noopener" href="http://hooltech.com/android-hidl.html#%E7%AE%80%E4%BB%8B">hidl配置简介</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/guyongqiangx/article/details/72604355">https://blog.csdn.net/guyongqiangx/article/details/72604355</a>)</p>
<h3 id="之前的项目文档"><a href="#之前的项目文档" class="headerlink" title="之前的项目文档"></a>之前的项目文档</h3><p><a target="_blank" rel="noopener" href="https://wiki.n.miui.com/pages/viewpage.action?pageId=33933409">A&#x2F;B系统升级功能点</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.n.miui.com/pages/viewpage.action?pageId=33930350">A&#x2F;B 系统升级（双分区系统升级）</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.n.miui.com/pages/viewpage.action?pageId=34968890">Android One A&#x2F;B OTA Updater</a></p>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><h3 id="设置编译变量"><a href="#设置编译变量" class="headerlink" title="设置编译变量"></a>设置编译变量</h3><p>支持 A&#x2F;B 更新的引导加载程序必须满足以下编译变量条件:</p>
<h4 id="必须针对-A-B-更新目标定义的变量"><a href="#必须针对-A-B-更新目标定义的变量" class="headerlink" title="必须针对 A&#x2F;B 更新目标定义的变量"></a>必须针对 A&#x2F;B 更新目标定义的变量</h4><ul>
<li>AB_OTA_UPDATER :&#x3D; true</li>
<li>AB_OTA_PARTITIONS :&#x3D; <br>boot <br>system <br>vendor</li>
<li>以及通过 update_engine 更新的其他分区（无线装置、引导加载程序等）。</li>
<li>BOARD_BUILD_SYSTEM_ROOT_IMAGE :&#x3D; true</li>
<li>TARGET_NO_RECOVERY :&#x3D; true</li>
<li>BOARD_USES_RECOVERY_AS_BOOT :&#x3D; true</li>
<li>PRODUCT_PACKAGES +&#x3D; <br>update_engine <br>update_verifier</li>
<li>要查看示例，请参阅 &#x2F;device&#x2F;google&#x2F;marlin&#x2F;+&#x2F;android-7.1.0_r1&#x2F;device-common.mk。 您可以选择执行编译中所述的安装后（但在重新启动前）dex2oat 步骤.</li>
</ul>
<h4 id="无法针对-A-B-目标定义的变量"><a href="#无法针对-A-B-目标定义的变量" class="headerlink" title="无法针对 A&#x2F;B 目标定义的变量:"></a>无法针对 A&#x2F;B 目标定义的变量:</h4><ul>
<li>BOARD_RECOVERYIMAGE_PARTITION_SIZE</li>
<li>BOARD_CACHEIMAGE_PARTITION_SIZE</li>
<li>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE</li>
</ul>
<h4 id="可选-针对调试版本定义的变量"><a href="#可选-针对调试版本定义的变量" class="headerlink" title="可选 针对调试版本定义的变量"></a>可选 针对调试版本定义的变量</h4><p>PRODUCT_PACKAGES_DEBUG +&#x3D; update_engine_client</p>
<h3 id="节选-非GMS版本需要客户端"><a href="#节选-非GMS版本需要客户端" class="headerlink" title="(节选) 非GMS版本需要客户端"></a>(节选) 非GMS版本需要客户端</h3><ul>
<li>GmsCore 起到什么作用？<br>在 Google 的 A&#x2F;B 实现中，平台 API 和 update_engine 负责提供机制，而 GmsCore 则负责提供政策。也就是说，平台知道如何应用 A&#x2F;B 更新，并且所有相应代码都位于 AOSP 中（如上所述），而 GmsCore 则负责确定应用哪些内容以及何时应用。<br>如果不使用 GmsCore，则可以使用<code>相同的平台 API</code> 编写自己的替代项。用于<code>控制 update_engine 的平台</code>.  Java API 是 android.os.UpdateEngine：<code>frameworks/base/core/java/android/os/UpdateEngine.java</code>。调用程序可以提供 <code>UpdateEngineCallback</code>，以便接收有关状态更新的通知：<code>frameworks/base/+/master/core/java/android/os/UpdateEngineCallback.java</code>。请参阅核心类的参考文件，了解如何使用相应接口。</li>
</ul>
<h2 id="空间对比"><a href="#空间对比" class="headerlink" title="空间对比"></a>空间对比</h2><table>
<thead>
<tr>
<th>abl_b</th>
<th>2048</th>
</tr>
</thead>
<tbody><tr>
<td>aop_b</td>
<td>512</td>
</tr>
<tr>
<td>bluetooth_b</td>
<td>1024</td>
</tr>
<tr>
<td>boot_b</td>
<td>131072</td>
</tr>
<tr>
<td>cmnlib64_b</td>
<td>1024</td>
</tr>
<tr>
<td>cmnlib_b</td>
<td>1024</td>
</tr>
<tr>
<td>devcfg_b</td>
<td>256</td>
</tr>
<tr>
<td>dsp_b</td>
<td>65536</td>
</tr>
<tr>
<td>dtbo_b</td>
<td>32768</td>
</tr>
<tr>
<td>hyp_b</td>
<td>8192</td>
</tr>
<tr>
<td>ifaa_b</td>
<td>65536</td>
</tr>
<tr>
<td>imagefv_b</td>
<td>2048</td>
</tr>
<tr>
<td>keymaster_b</td>
<td>1024</td>
</tr>
<tr>
<td>modem_b</td>
<td>327680</td>
</tr>
<tr>
<td>multiimgoem_b</td>
<td>32</td>
</tr>
<tr>
<td>qupfw_b</td>
<td>128</td>
</tr>
<tr>
<td>system_b</td>
<td>3670016</td>
</tr>
<tr>
<td>tz_b</td>
<td>4096</td>
</tr>
<tr>
<td>uefisecapp_b</td>
<td>2048</td>
</tr>
<tr>
<td>vbmeta_b</td>
<td>128</td>
</tr>
<tr>
<td>vendor_b</td>
<td>2097152</td>
</tr>
<tr>
<td>xbl_b</td>
<td>7168</td>
</tr>
<tr>
<td>xbl_config_b</td>
<td>512</td>
</tr>
<tr>
<td>total</td>
<td>6270.53125</td>
</tr>
</tbody></table>
<h2 id="升级包相关"><a href="#升级包相关" class="headerlink" title="升级包相关"></a>升级包相关</h2><p>升级包结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── care_map.txt</span><br><span class="line">├── compatibility.zip</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── CERT.RSA</span><br><span class="line">│   ├── CERT.SF</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── android</span><br><span class="line">│   │       ├── metadata</span><br><span class="line">│   │       └── otacert</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">├── payload.bin</span><br><span class="line">└── payload_properties.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要文件全在payload.bin中, 没有升级脚本</p>
<p>metadata文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ota-property-files=payload_metadata.bin:9649:149799,payload.bin:9649:1153246262,payload_properties.txt:1153255969:156,care_map.txt:752:239,compatibility.zip:1044:8558,metadata:69:635</span><br><span class="line">ota-required-cache=0</span><br><span class="line">ota-streaming-property-files=payload.bin:9649:1153246262,payload_properties.txt:1153255969:156,care_map.txt:752:239,compatibility.zip:1044:8558,metadata:69:635</span><br><span class="line">ota-type=AB</span><br><span class="line">post-build=xiaomi/jasmine/jasmine_sprout:9/PKQ1.180904.001/9.7.23:user/release-keys</span><br><span class="line">post-build-incremental=9.7.23</span><br><span class="line">post-sdk-level=28</span><br><span class="line">post-security-patch-level=2019-08-05</span><br><span class="line">post-timestamp=1563835614</span><br><span class="line">pre-device=jasmine_sprout</span><br></pre></td></tr></table></figure>

<ul>
<li>生成完整OTA<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./build/tools/releasetools/ota_from_target_files \</span><br><span class="line">  dist_output/tardis-target_files.zip ota_update.zip</span><br></pre></td></tr></table></figure>
-生成增量 OTA<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/tools/releasetools/ota_from_target_files \</span><br><span class="line">  -i PREVIOUS-tardis-target_files.zip \</span><br><span class="line">  dist_output/tardis-target_files.zip incremental_ota_update.zip</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="开机服务启动代码分析"><a href="#开机服务启动代码分析" class="headerlink" title="开机服务启动代码分析"></a>开机服务启动代码分析</h2><p>update_verifier</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vendor/etc/init/hw/init.target.rc</span><br><span class="line">on fs</span><br><span class="line">    mount_all /vendor/etc/fstab.qcom</span><br><span class="line"></span><br><span class="line">do_mount_all</span><br><span class="line">mount_fstab_return_code = mount_fstab(fstabfile, mount_mode);</span><br><span class="line">/* queue_fs_event will queue event based on mount_fstab return code</span><br><span class="line"> * and return processed return code*/</span><br><span class="line">auto queue_fs_result = queue_fs_event(*mount_fstab_return_code);</span><br><span class="line"></span><br><span class="line">else if (code == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123;</span><br><span class="line">        property_set(&quot;ro.crypto.state&quot;, &quot;encrypted&quot;);</span><br><span class="line">        property_set(&quot;ro.crypto.type&quot;, &quot;block&quot;);</span><br><span class="line">        ActionManager::GetInstance().QueueEventTrigger(&quot;defaultcrypto&quot;);</span><br><span class="line">        return Success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">on defaultcrypto</span><br><span class="line">    exec - root -- /system/bin/vdc --wait cryptfs mountdefaultencrypted</span><br><span class="line">    # vold will set vold.decrypt to trigger_restart_framework (default</span><br><span class="line">    # encryption) or trigger_restart_min_framework (other encryption)</span><br><span class="line"></span><br><span class="line">trigger_restart_min_framework</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt=trigger_post_fs_data</span><br><span class="line">    trigger post-fs-data</span><br><span class="line">    trigger zygote-start</span><br><span class="line"></span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br><span class="line">service update_verifier_nonencrypted /system/bin/update_verifier nonencrypted</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AB-升级过程调试"><a href="#AB-升级过程调试" class="headerlink" title="AB 升级过程调试"></a>AB 升级过程调试</h2><p>先制作ota升级包   make otapackage -j4<br>制作完成的升级包, 解压出payload.bin和payload_properties.txt<br>将升级包push到手机中, 执行命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=file://stroage/emulated/0/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">  FILE_HASH=kIOSRpbVFbtwlQcrTILsXvoY9kibUtgD44jsw2Xt/sU= \</span><br><span class="line">  FILE_SIZE=1387785336 \</span><br><span class="line">  METADATA_HASH=K+wAnG6HAjz8ogpJ6pYjyIUtS52evVp59Bwsiw5taHI= \</span><br><span class="line">  METADATA_SIZE=104537 \</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<p>logcat抓取update_engine的log, 发现报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">07-24 09:56:00.325  1045  1045 I update_engine: [0724/095600.325928:INFO:delta_performer.cc(1549)] Verifying payload using public key: /etc/update_engine/update-payload-key.pub.pem</span><br><span class="line">07-24 09:56:00.326  1045  1045 E update_engine: [0724/095600.325993:ERROR:delta_performer.cc(1563)] VerifyPayload failure: payload_hash_calculator_.raw_hash() == update_check_response_hash</span><br><span class="line">07-24 09:56:00.326  1045  1045 E update_engine: [0724/095600.326097:ERROR:download_action.cc(397)] Download of file://stroage/emulated/0/draco-ota-eng.mi.zip failed due to payload verification error.</span><br><span class="line">07-24 09:56:00.326  1045  1045 I update_engine: [0724/095600.326166:INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kPayloadHashMismatchError</span><br><span class="line">07-24 09:56:00.326  1045  1045 I update_engine: [0724/095600.326233:INFO:action_processor.cc(121)] ActionProcessor: Aborting processing due to failure.</span><br></pre></td></tr></table></figure>
<p>加log调试update_engine</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root;adb disable-verity;adb reboot;adb root;adb remount;</span><br><span class="line">adb push system/bin/update_engine  /system/bin/</span><br><span class="line">adb shell;</span><br><span class="line">stop update_engine; start update_engine;</span><br></pre></td></tr></table></figure>
<p>发现该处log比较奇怪:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">07-23 16:59:54.693  5879  5879 I update_engine: [0723/165954.693766:INFO:install_plan.cc(83)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file://stroage/emulated/0/payload.bin, payload: (size: 0, metadata_size: 0, metadata signature: , hash: , payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true</span><br></pre></td></tr></table></figure>
<p>dump的地方在<code>update_attempter_android.cc</code>文件中<code>install_plan_.Dump();</code></p>
<p>最后调试下来发现是参数格式不对, 正确的应该这样写:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=http://192.168.31.83:8000/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=HCN+qKtmcVpsRotGQCsi91Om+MqSg3NHQYJwn2yULVg=</span><br><span class="line">FILE_SIZE=2693182661</span><br><span class="line">METADATA_HASH=CUDPVlE0kWBn6+Ryaxta8lwvi03G4G9XK1vhRGPcm6U=</span><br><span class="line">METADATA_SIZE=165572</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意换行符的写入方式</p>
</blockquote>
<p>在上面的尝试后, 发现本地地址不能解析<br>需要在本地电脑上架设小型服务器, </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在升级包路径下执行</span></span><br><span class="line">python -mSimpleHTTPServer</span><br><span class="line">python -m http.server  #python3</span><br></pre></td></tr></table></figure>
<p>传入的参数为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--payload=http://192.168.31.83:8000/payload.bin</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=http://127.0.0.1/storage/emulated/0/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=kIOSRpbVFbtwlQcrTILsXvoY9kibUtgD44jsw2Xt/sU=</span><br><span class="line">FILE_SIZE=1387785336</span><br><span class="line">METADATA_HASH=K+wAnG6HAjz8ogpJ6pYjyIUtS52evVp59Bwsiw5taHI=</span><br><span class="line">METADATA_SIZE=104537</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<p>最后发现本地地址也是可以解析的, 只是路径名要写对:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--payload=file:///storage/emulated/0/payload.bin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意file:后面三个’&#x2F;‘, 前两个是file的scheme, 后一个代表的是手机的根路径</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/media/0/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=sMDMFWlA/r/RvD2xmbhT10ujGbd3ZDgbIoFsguZgFk0=</span><br><span class="line">FILE_SIZE=2706624429</span><br><span class="line">METADATA_HASH=5pBczs+nemH35uaJ6dyKEM14jLXG6yHLRHW2SA7E548=</span><br><span class="line">METADATA_SIZE=165921</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/media/0/miui_VENUS_20.8.19_d6f849fa6a_11.0.zip \</span><br><span class="line">--update \</span><br><span class="line">--offset=1146 \</span><br><span class="line">--size=2758439770 \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=rr3A+HtaJvZR9t6fy+Jb1+H/IkbeOWKHifx27a9ZQFU=</span><br><span class="line">FILE_SIZE=2758439770</span><br><span class="line">METADATA_HASH=eEzs5b5edkpltbmQdROP/k4t1UxfC/9XwRVIXZWvnmU=</span><br><span class="line">METADATA_SIZE=165216</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///sdcard/miui_VENUS_20.8.19_d6f849fa6a_11.0.zip \</span><br><span class="line">--offset=1187 \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=rr3A+HtaJvZR9t6fy+Jb1+H/IkbeOWKHifx27a9ZQFU=</span><br><span class="line">FILE_SIZE=2758439770</span><br><span class="line">METADATA_HASH=eEzs5b5edkpltbmQdROP/k4t1UxfC/9XwRVIXZWvnmU=</span><br><span class="line">METADATA_SIZE=165216</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=</span><br><span class="line">FILE_SIZE=2692532199</span><br><span class="line">METADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=</span><br><span class="line">METADATA_SIZE=165572</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///mnt/androidwritable/0/emulated/0/Download/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=</span><br><span class="line">FILE_SIZE=2692532199</span><br><span class="line">METADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=</span><br><span class="line">METADATA_SIZE=165572</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///storage/emulated/0/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=yU0BoWvLqOvJk19Qpmf4bHSUwaT0Ly3aNTlAlPTpNOo=</span><br><span class="line">FILE_SIZE=2692532199</span><br><span class="line">METADATA_HASH=XNNFmxx7ltGXUNshJa/sW7ulxs7aEiOMZxHwgZIcIo4=</span><br><span class="line">METADATA_SIZE=165572</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/miui-ota-venus-20.9.1.root-20.9.2.root-a6a89c0203-11.0.zip \</span><br><span class="line">--update \</span><br><span class="line">--offset=1414 \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=k6xH0maRm8TA3oiSUW3XaaVK7O1OXmVHuKl36ktTGYQ=</span><br><span class="line">FILE_SIZE=76627669</span><br><span class="line">METADATA_HASH=PsdtZ4XoOm6uBdfC9yS6PAPJ1LqPAu0dH/FMtoZcXGo=</span><br><span class="line">METADATA_SIZE=449549</span><br><span class="line">&quot;</span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=6Rp2NEldT3Hsvo3amsrFM3cVypJW+3Zz9mSjLRpoQ68=</span><br><span class="line">FILE_SIZE=76627710</span><br><span class="line">METADATA_HASH=/Ilv5kgPOpsDwdtG8TUBCt08LFndNHHy/UXQMmsp3Hk=</span><br><span class="line">METADATA_SIZE=450810</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=</span><br><span class="line">FILE_SIZE=181915047</span><br><span class="line">METADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=</span><br><span class="line">METADATA_SIZE=607150</span><br><span class="line">&quot;</span><br><span class="line">openssl pkcs8 -in build/make/target/product/security/testkey.pk8 -inform DER -nocrypt &gt; test/private_key</span><br><span class="line">sha256sum header.bin | xxd -r -p | tee sha256.file</span><br><span class="line">dd if=sha256.file of=sha256_32.bin bs=1 count=32</span><br><span class="line">openssl pkeyutl -sign -inkey private_key -pkeyopt digest:sha256 -in sha256_32.bin -out header_sign.bin</span><br><span class="line"></span><br><span class="line">ota_from_target_files.py cmd:  -i /tmp/tmp.miui.target_files_package.ota.l4f/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip</span><br><span class="line">build/tools/releasetools/ota_from_target_files  -i /tmp/tmp.miui.target_files_package.ota.l4f/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build/tools/releasetools/ota_from_target_files  -i  /tmp/tmp.miui.target_files_package.ota.l4f/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/root/ota_diff/ota-venus-20.9.6.root-20.9.9.root.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD: build/tools/releasetools/ota_from_target_files --block --payload_signer /home/builder/ota-tools/build/payload_signer.sh -i /tmp/tmp.miui.target_files_package.ota.Ds0/new-incremental-target-files.zip /tmp/tmp.miui.target_files_package.ota.Ds0/new-target-files.zip /home/work/venus-r-dev-temp/20.9.9/normal/ota_diff/blockota-venus-20.9.6-20.9.9.zip</span><br></pre></td></tr></table></figure>

<blockquote>
<p>算hash值的方法</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sha256sum</span> -t  signed_venus-target_files-20.9.1.root-11.0/RADIO/abl.elf | xxd -r -p | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure>

<h3 id="添加firmware分区"><a href="#添加firmware分区" class="headerlink" title="添加firmware分区"></a>添加firmware分区</h3><p>先看下target_files依赖的RADIO文件:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET_RADIO_FILES := xbl.elf xbl_config.elf imagefv.elf tz.mbn \</span><br><span class="line">                      devcfg.mbn storsec.mbn km4.mbn cmnlib.mbn \</span><br><span class="line">                      cmnlib64.mbn uefi_sec.mbn aop.mbn NON-HLOS.bin BTFM.bin dspso.bin \</span><br><span class="line">                      qupv3fw.elf multi_image.mbn hyp.mbn hypvm.mbn</span><br></pre></td></tr></table></figure>
<p>看下非AB升级的升级脚本:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package_extract_file(&quot;firmware-update/cmnlib64.mbn&quot;, &quot;/dev/block/bootdevice/by-name/cmnlib64&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/NON-HLOS.bin&quot;, &quot;/dev/block/bootdevice/by-name/modem&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/cmnlib.mbn&quot;, &quot;/dev/block/bootdevice/by-name/cmnlib&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/BTFM.bin&quot;, &quot;/dev/block/bootdevice/by-name/bluetooth&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/km4.mbn&quot;, &quot;/dev/block/bootdevice/by-name/keymaster&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/hypvm.mbn&quot;, &quot;/dev/block/bootdevice/by-name/hypbak&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/tz.mbn&quot;, &quot;/dev/block/bootdevice/by-name/tz&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/aop.mbn&quot;, &quot;/dev/block/bootdevice/by-name/aop&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/xbl_config.elf&quot;, &quot;/dev/block/bootdevice/by-name/xbl_config&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/storsec.mbn&quot;, &quot;/dev/block/bootdevice/by-name/storsec&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/uefi_sec.mbn&quot;, &quot;/dev/block/bootdevice/by-name/uefisecapp&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/imagefv.elf&quot;, &quot;/dev/block/bootdevice/by-name/imagefv&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/qupv3fw.elf&quot;, &quot;/dev/block/bootdevice/by-name/qupfw&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/abl.elf&quot;, &quot;/dev/block/bootdevice/by-name/abl&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/dspso.bin&quot;, &quot;/dev/block/bootdevice/by-name/dsp&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/devcfg.mbn&quot;, &quot;/dev/block/bootdevice/by-name/devcfg&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/xbl.elf&quot;, &quot;/dev/block/bootdevice/by-name/xbl&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/hyp.mbn&quot;, &quot;/dev/block/bootdevice/by-name/hyp&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/vbmeta.img&quot;, &quot;/dev/block/bootdevice/by-name/vbmeta&quot;);</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">package_extract_file(<span class="string">&quot;firmware-update/logo.img&quot;</span>, <span class="string">&quot;/dev/block/bootdevice/by-name/logo&quot;</span>);</span></span><br><span class="line">package_extract_file(&quot;firmware-update/ifaa.img&quot;, &quot;/dev/block/bootdevice/by-name/ifaa&quot;);</span><br><span class="line">package_extract_file(&quot;firmware-update/dtbo.img&quot;, &quot;/dev/block/bootdevice/by-name/dtbo&quot;);</span><br></pre></td></tr></table></figure>
<p>上面的分区和有b分区的比下来, 除了logo, 其他的都要升级, 注意跟多出来的b分区的对比, 少了一个分区是<code>multiimgoem</code>, 对应的镜像<code>multi_image.mbn</code></p>
<h4 id="原生打包的方式"><a href="#原生打包的方式" class="headerlink" title="原生打包的方式"></a>原生打包的方式</h4><p>先看下<code>AB_OTA_PARTITIONS</code>的作用范围<br>META&#x2F;ab_partitions.txt<br>现有逻辑是查device&#x2F;board下定义的AB_OTA_PARTITIONS, 将扫到的分区写到target-files的这个文件中<br>由<code>/system/update_engine/scripts/brillo_update_payload</code>的generate生成对应的payload.bin<br>该文件为shell脚本, 编译时会被拷贝到<code>/out/host/linux-x86/bin</code>下面<br>原生方式只识别后缀名为<code>.img</code>的镜像文件, 在<code>add_img_to_target_files</code>制作target-files时, 会将<code>RADIO</code>目录下的后缀为<code>.img</code>的镜像文件拷贝到<code>IMAGES</code>下.<br>由<code>brillo_update_payload</code>脚本根据<code>IMAGES</code>下的镜像文件和<code>ab_partitions.txt</code>文件中的升级分区生成对应的升级包</p>
<h4 id="firmware的相关修改"><a href="#firmware的相关修改" class="headerlink" title="firmware的相关修改"></a>firmware的相关修改</h4><p>将firmware加到升级序列时, 有下面几个问题要解决</p>
<p>a. firmware的大部分镜像都不是<code>img</code>后缀结尾的</p>
<p>b. 需要按board按需添加对应的firmware, 最好不要写死</p>
<p>c. firmware的镜像放在<code>RADIO</code>而非<code>IMAGES</code>下,  这点有正式签名的考虑.(正式包会在Makefile执行完成后, 对做出的target-files下的IMAGES目录下的文件进行删除, 重新生成并签上正式签名), 因此不宜将firmware的镜像仿照原生逻辑直接拷贝到<code>IMAGES</code>下</p>
<p>d. firmware的镜像大部分跟其对应的分区名称名字不是对应的.</p>
<p>综上几点, 考虑的修改方式为:</p>
<ol>
<li>复用Board下的filesmap文件, 该文件定义了firmware镜像跟分区名称的对应规则, 该文件已经被打包到<code>target-files</code>下的<code>RADIO</code>目录下</li>
<li>ab_partitions的firmware的添加规则和原生的区分, 原生的是在宏<code>AB_OTA_PARTITIONS</code>下添加的, firmware的加入时机直接在<code>add_img_to_target_files</code>中对AB的操作时触发. 因<code>RADIO</code>目录下的文件已经是按board需要添加的, 可以直接扫描<code>RADIO</code>目录的文件, 且与<code>filesmap</code>文件中对应的即为所要升级的分区. (主要排除掉没有b slot的分区), 追加到<code>META/ab_partitions.txt</code>文件中.</li>
<li>由于上面的<strong>d</strong>项, 分区名跟镜像名不对应, 这里复用<code>filesmap</code>文件, 添加分区名跟镜像名的映射map, 写入到<code>META/ab_partitions_map.txt</code>文件中</li>
<li><code>brillo_update_payload</code>脚本中修改, 将只从<code>IMAGES</code>中和分区名和镜像名严格匹配的规则修改, 变更为除去IMAGES中已知的分区, 其他按照<code>META/ab_partitions_map.txt</code>的对应规则从<code>RADIO</code>目录取镜像文件.</li>
</ol>
<p>相关修改:</p>
<p><a target="_blank" rel="noopener" href="http://gerritlvs.pt.miui.com/#/c/656495/">http://gerritlvs.pt.miui.com/#/c/656495/</a></p>
<p><a target="_blank" rel="noopener" href="http://gerritlvs.pt.miui.com/#/c/656506/">http://gerritlvs.pt.miui.com/#/c/656506/</a></p>
<h3 id="升级完成与切换slot"><a href="#升级完成与切换slot" class="headerlink" title="升级完成与切换slot"></a>升级完成与切换slot</h3><p>查看主系统中是否已经升级完了对应的slot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#升级plan``07-26 13``:``17``:``36.537  1120  1120 I update_engine``:` `[``0726/131736``.537426:``INFO``:``install_plan.cc(83)``]` `InstallPlan``:` `new_update``,` `version``:` `,` `source_slot``:` `A``,` `target_slot``:` `B``,` `url``:` `file``:``///storage/emulated/0/payload.bin``,` `payload``:` `(size``:` `2004454082``,` `metadata_size``:` `174654``,` `metadata signature``:` `,` `hash``:` `7FE331728BDC1F3ADB6CD99DB86E9B9C49613464A0B4CEDB996B2035AF58BC82``,` `payload type``:` `unknown)``,` `hash_checks_mandatory``:` `false``,` `powerwash_required``:` `false``,` `switch_slot_on_reboot``:` `true``,` `run_post_install``:` `true``#升级顺序及hash值``07-26 13``:``17``:``36.808  1120  1120 I update_engine``:` `[``0726/131736``.808861:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new boot sha256``:` `BaT0kJm5qUoDs+ZFvbl7PsbYrJdVLEJ4AO9yRubxVxA= size``:` `134217728``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809403:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new system sha256``:` `8iUdw5zmngS2Z19bJdjhyoinOuPf+jktNpsybrg+/As= size``:` `3758096384``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809555:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new vendor sha256``:` `yoK6GkBeRI140U9nC5PeOcoTIKvX9PytKJveI9W0NZI= size``:` `2134900736``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809695:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new cmnlib sha256``:` `L8grDzXzgCj2jmkywxgvC6WOESQbzcQWzC2XKDuAXCk= size``:` `393216``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809828:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new cmnlib64 sha256``:` `2kJkRo4mMiPlSXilsbdN8jrDnWHVpy0n+C72qnjxUXI= size``:` `512000``07-26 13``:``17``:``36.809  1120  1120 I update_engine``:` `[``0726/131736``.809953:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new xbl sha256``:` `0knDpqu+RIZDIFVQ+UfvIHdXd8itYU7kBZQjyFv3MSk= size``:` `3313664``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810078:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new tz sha256``:` `qJjCTAzUUP4QDtP5JpEIgyiucu2csyDMMqm3Sw82IJ4= size``:` `3149824``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810200:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new ifaa sha256``:` `jndrE4DvyUkcFkSlgGcdzT31y61NFbs0bK62w7RxZmc= size``:` `67108864``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810332:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new xbl_config sha256``:` `EuJt+caPn+p1pYml7BiLHwWS5qOHdsE9XWdDMTgYDn8= size``:` `126976``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810463:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new abl sha256``:` `AEWy9qn6ckS6oPuchaZTf3LLBKvu4rlVhCqjYuovjvo= size``:` `159744``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810605:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new keymaster sha256``:` `2EbjQReoWN2RJxiMTYDY0DyBhTSCj9EDMQY8nBNkrhM= size``:` `253952``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810735:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new bluetooth sha256``:` `QUIy2P5N0423Q9vfFStQ4gX7+93NNeNAP8/C1GMFRxs= size``:` `847872``07-26 13``:``17``:``36.810  1120  1120 I update_engine``:` `[``0726/131736``.810863:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new imagefv sha256``:` `s8nZ2bO3JQ1FhpHm5xl6JM0gaXD+R+bJXx/ao5n465c= size``:` `24576``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.810994:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new vbmeta sha256``:` `DS53zciAjgUcUu9bazzGzl8WSrXsTlyDh0qQdQrSzzg= size``:` `4096``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811124:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new qupfw sha256``:` `5b7DvDYxu52A7CkzLEn17FAUi9VjC4+hP1x1EHgVwn4= size``:` `73728``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811248:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new dtbo sha256``:` `x8LJxRjY6eyLtnFpCUjx0nm7KrPk5EWmbO1RoiGgdKA= size``:` `33554432``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811380:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new hyp sha256``:` `K+Lhh6fNlCzcZGO2sSQk4oX899HivC4ZYbQ00wCHJuk= size``:` `487424``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811501:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new aop sha256``:` `pbPjmwNuZ63U/yB3x6fWwHMFaWTaO7GRsvvmgtYeZY8= size``:` `204800``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811628:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new modem sha256``:` `U8mQP9s3QEIuQC6XjTtCK2FSv37BrFmz/8yanfrSag0= size``:` `254750720``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811752:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new dsp sha256``:` `/6W7ecrFfr/L/iQIyc31iyatytPv/Zh3ihPgkKCRogg= size``:` `67108864``07-26 13``:``17``:``36.811  1120  1120 I update_engine``:` `[``0726/131736``.811871:``INFO``:``delta_performer.cc(400)``]` `PartitionInfo new devcfg sha256``:` `op2nGXrz70xk67DA0MGvGxuPrWGEDS/zQHo8wzSSG3E= size``:` `57344``#写入分区``...``07-26 13``:``26``:``23.407  1120  1120 I update_engine``:` `[``0726/132623``.406974:``INFO``:``delta_performer.cc(386)``]` `Applying 32 operations to partition ``&quot;ifaa&quot;``07-26 13``:``26``:``25.604  1120  1120 I update_engine``:` `[``0726/132625``.604203:``INFO``:``delta_performer.cc(374)``]` `Opening /dev/block/bootdevice/by-name/xbl_config_b partition without O_DSYNC``07-26 13``:``26``:``25.609  1120  1120 I update_engine``:` `[``0726/132625``.609049:``INFO``:``delta_performer.cc(126)``]` `Caching writes.``07-26 13``:``26``:``25.609  1120  1120 I update_engine``:` `[``0726/132625``.609407:``INFO``:``delta_performer.cc(386)``]` `Applying 1 operations to partition ``&quot;xbl_config&quot;``07-26 13``:``26``:``25.638  1120  1120 I update_engine``:` `[``0726/132625``.638252:``INFO``:``delta_performer.cc(374)``]` `Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC``#分区写完后校验``07-26 13``:``27``:``40.528  1120  1120 I update_engine``:` `[``0726/132740``.528046:``INFO``:``filesystem_verifier_action.cc(108)``]` `Hashing partition 7 (ifaa) ``on` `device /dev/block/bootdevice/by-name/ifaa_b``07-26 13``:``27``:``40.870  1120  1120 I update_engine``:` `[``0726/132740``.870530:``INFO``:``filesystem_verifier_action.cc(199)``]` `Hash of ifaa``:` `jndrE4DvyUkcFkSlgGcdzT31y61NFbs0bK62w7RxZmc=``07-26 13``:``27``:``41.053  1120  1120 I update_engine``:` `[``0726/132741``.053396:``INFO``:``filesystem_verifier_action.cc(108)``]` `Hashing partition 8 (xbl_config) ``on` `device /dev/block/bootdevice/by-name/xbl_config_b``07-26 13``:``27``:``41.059  1120  1120 I update_engine``:` `[``0726/132741``.059842:``INFO``:``filesystem_verifier_action.cc(199)``]` `Hash of xbl_config``:` `EuJt+caPn+p1pYml7BiLHwWS5qOHdsE9XWdDMTgYDn8=``#升级完成``07-26 13``:``27``:``43.865  1120  1120 I update_engine``:` `[``0726/132743``.865773:``INFO``:``update_attempter_android.cc(439)``]` `Processing Done.``07-26 13``:``27``:``43.867  1120  1120 I update_engine``:` `[``0726/132743``.867692:``INFO``:``update_attempter_android.cc(447)``]` `Update successfully applied``,` `waiting to reboot.`</span><br></pre></td></tr></table></figure>

<p>重启手机查看是否切换了slot</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`fastboot getvar current-slot`</span><br></pre></td></tr></table></figure>

<p>fastboot 手动切换slot</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`fastboot set_active a|b`</span><br></pre></td></tr></table></figure>

<p>在主系统下查看是否已经切换了slot:</p>
<p>可以通过mount查看挂载的是否是对应slot的分区, 也可以重新执行update_engine_client查看source slot.</p>
<p>其他的fastboot相关命令和变量:</p>
<ul>
<li><code>has-slot:&lt;partition-base-name-without-suffix&gt;</code>：如果指定分区支持插槽，则返回“yes”，否则返回“no”。</li>
<li><code>current-slot</code>：返回接下来将从中启动的插槽后缀。</li>
<li><code>slot-count</code>：返回一个表示可用插槽数量的整数。目前支持两个插槽，因此该值为 <code>2</code>。</li>
<li><code>slot-successful:&lt;slot-suffix&gt;</code>：如果指定插槽已标记为成功启动，则返回“yes”，否则返回“no”。</li>
<li><code>slot-unbootable:&lt;slot-suffix&gt;</code>：如果指定插槽被标记为不可启动，则返回“yes”，否则返回“no”。</li>
<li><code>slot-retry-count</code>：启动指定插槽的剩余重试次数。</li>
</ul>
<h2 id="recovery升级X-slot"><a href="#recovery升级X-slot" class="headerlink" title="recovery升级X_slot"></a>recovery升级X_slot</h2><p>recovery借助update_engine_sideload进行AB系统的升级, 过程与主系统中的大体类似, 跳过hidl服务直连hal的静态库.</p>
<p>适配时需要将bootctl的hal的静态库接入update_engine_sideload.</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable update engine sideloading by including the static version of the</span></span><br><span class="line"><span class="comment"># boot_control HAL and its dependencies.</span></span><br><span class="line">PRODUCT_STATIC_BOOT_CONTROL_HAL := \</span><br><span class="line">    bootctrl.msmnile \</span><br><span class="line">    librecovery_updater_msm \</span><br><span class="line">    libz \</span><br><span class="line">    libcutils</span><br><span class="line"></span><br><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    update_engine_sideload</span><br></pre></td></tr></table></figure>

<p>qcom的bootctrl.msmnile库并没有静态版本, 将其改造成静态版本, 同时注意platform的binary不能访问vendor的静态库, 需要去掉vendor属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[  137.119886] [0118/071802.275869:INFO:update_attempter_android.cc(163)] headers dump: FILE_HASH:XY0N+WNwMUsufo4R2WhiVEZZysKndtGOs2U2eHI4vWY=</span><br><span class="line">[  137.119974] [0118/071802.275959:INFO:update_attempter_android.cc(163)] headers dump: FILE_SIZE:2172949036</span><br><span class="line">[  137.120064] [0118/071802.276047:INFO:update_attempter_android.cc(163)] headers dump: METADATA_HASH:tT9n0yD1oGTFh6CHfgFJ+SFDpGVDdM3MxU2Kj6J4xHk=</span><br><span class="line">[  137.120153] [0118/071802.276137:INFO:update_attempter_android.cc(163)] headers dump: METADATA_SIZE:201361</span><br><span class="line">[  137.314970] [0118/071802.470947:INFO:multi_range_http_fetcher.cc(74)] starting transfer of range 10118+2172949036</span><br></pre></td></tr></table></figure>

<p>sideload模式可以通过adb进行调试执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">update_engine_sideload  --payload=file:///tmp/&lt;&gt;.zip  --offset=10118 --headers=&quot;\</span><br><span class="line">FILE_HASH=XY0N+WNwMUsufo4R2WhiVEZZysKndtGOs2U2eHI4vWY=</span><br><span class="line">FILE_SIZE=2172949036</span><br><span class="line">METADATA_HASH=tT9n0yD1oGTFh6CHfgFJ+SFDpGVDdM3MxU2Kj6J4xHk=</span><br><span class="line">METADATA_SIZE=201361</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_sideload  --payload=file:///tmp/update.zip  --offset=1418 --headers=&quot;\</span><br><span class="line">FILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=</span><br><span class="line">FILE_SIZE=181915047</span><br><span class="line">METADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=</span><br><span class="line">METADATA_SIZE=607150</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_sideload   --payload=file:///tmp/miui_DRACO_1.1.1_3b6efde15f_9.0.zip  --offset=10137 --headers=&quot;\^JFILE_HASH=2RuZP+op3uy6movkIOlNaNoo8Fev+++ndUN56eo4WtY=^JFILE_SIZE=2180626971^JMETADATA_HASH=nW8R4zd7YIn/U3ybQ4U8e104hOlJ/8LBWBAlLaV4teY=^JMETADATA_SIZE=201406^J&quot; </span><br></pre></td></tr></table></figure>

<p>相关log, 注意后面的size</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">[0119/030730.113743:INFO:delta_performer.cc(1405)] Detected a &#x27;full&#x27; payload.</span><br><span class="line">[0119/030730.174037:INFO:delta_performer.cc(400)] PartitionInfo new boot sha256: EpKxremioCiMOtX/ll7vdGHgyPA6hkS+aEATJ1bTmvs= size: 134217728</span><br><span class="line">[0119/030730.174087:INFO:delta_performer.cc(400)] PartitionInfo new system sha256: a3cVb5cmEwvwXp9qRV7S/FHD88SUx5SdPdBL9vdtfdA= size: 4831838208</span><br><span class="line">[0119/030730.174108:INFO:delta_performer.cc(400)] PartitionInfo new vendor sha256: Hz4lmS/Ubd04ZcY3N2Z6Tn1hKcmYPjdeeHbyRCw3n6U= size: 2134900736</span><br><span class="line">[0119/030730.174124:INFO:delta_performer.cc(400)] PartitionInfo new cmnlib sha256: jobjLrtwvwr4lomr6gMHgT07CnYt+m2n9rimaAX8gmA= size: 393216</span><br><span class="line">[0119/030730.174142:INFO:delta_performer.cc(400)] PartitionInfo new hyp sha256: GBrSZwkKGzyPmjMln6hNqCs0MMdOnVNq+0xvPg9wEIo= size: 491520</span><br><span class="line">[0119/030730.174164:INFO:delta_performer.cc(400)] PartitionInfo new xbl sha256: Srhj/31G6kvceupG54iy2ATnvTrHaGDTNrXoQ9QoBQM= size: 3313664</span><br><span class="line">[0119/030730.174185:INFO:delta_performer.cc(400)] PartitionInfo new tz sha256: 6j6yJ6VEJP/eDEfVAfBTJsPeihIw8stgYx3IZYNUTjU= size: 3166208</span><br><span class="line">[0119/030730.174207:INFO:delta_performer.cc(400)] PartitionInfo new uefisecapp sha256: SsTDYAIGR57uuERCJVW4pYo7qliFTfFC0bjkeCdhuaA= size: 126976</span><br><span class="line">[0119/030730.174228:INFO:delta_performer.cc(400)] PartitionInfo new xbl_config sha256: PXsK2uY4CZHl9HTw4MNn2V2JKjf+tL5lF3Rsrxq/DlQ= size: 126976</span><br><span class="line">[0119/030730.174248:INFO:delta_performer.cc(400)] PartitionInfo new abl sha256: pTmXXhjn578lQoU4Ms2gevuE1u9lf6fkfKkeb2wErOc= size: 159744</span><br><span class="line">[0119/030730.174269:INFO:delta_performer.cc(400)] PartitionInfo new dsp sha256: kGaIexuCECjzYboVNAQWYgSk5+2ZDAreFTT+9Lae68I= size: 67108864</span><br><span class="line">[0119/030730.174290:INFO:delta_performer.cc(400)] PartitionInfo new bluetooth sha256: +o/xD1GaNQ+dXp3dI7cHLl/ecNQveGozZ5/+3mkysI0= size: 847872</span><br><span class="line">[0119/030730.174311:INFO:delta_performer.cc(400)] PartitionInfo new imagefv sha256: YtGPa6a7hx2vAUrQBMIID6821Cagh5hM7mfWvouDZjE= size: 24576</span><br><span class="line">[0119/030730.174332:INFO:delta_performer.cc(400)] PartitionInfo new vbmeta sha256: 8SxbQYbjPUCebXdmSJg7iJhcJbdkDKRbIozhlEfIly8= size: 4096</span><br><span class="line">[0119/030730.174353:INFO:delta_performer.cc(400)] PartitionInfo new qupfw sha256: QwIM5J4OBdFm+EJmlrp+443q7M7HHzGsyWp7/6a7rks= size: 73728</span><br><span class="line">[0119/030730.174374:INFO:delta_performer.cc(400)] PartitionInfo new keymaster sha256: QxPBL7CmuMS851FLt2IyJ1viO+NlEfrcLiVCveNrUZM= size: 258048</span><br><span class="line">[0119/030730.174394:INFO:delta_performer.cc(400)] PartitionInfo new dtbo sha256: J4XfTy8iKmEDrT2g3p/IFowpezxKk5O1eaT2SIt9siY= size: 33554432</span><br><span class="line">[0119/030730.174415:INFO:delta_performer.cc(400)] PartitionInfo new aop sha256: a/+FDfEjG5fT7d43Lt2kzG+Ij3hWIo9u5anzMHTctRU= size: 204800</span><br><span class="line">[0119/030730.174436:INFO:delta_performer.cc(400)] PartitionInfo new modem sha256: es49VhO5api6iwZjDt/DWLBqXA9DnJvRccmvEL5FK/Y= size: 250458112</span><br><span class="line">[0119/030730.174458:INFO:delta_performer.cc(400)] PartitionInfo new devcfg sha256: CNmqJR7BqkQgcJNdrtCYKCQrJVEgehBfe/eCQGm7/n8= size: 57344</span><br><span class="line">[0119/030730.174480:INFO:delta_performer.cc(400)] PartitionInfo new cmnlib64 sha256: CTW5va0C8mcZN2pg46xloHvD5tq1x61mHAMGoB7siqM= size: 512000</span><br><span class="line">[0119/030730.174508:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/boot_b partition without O_DSYNC</span><br><span class="line">[0119/030730.175562:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/030730.175616:INFO:delta_performer.cc(386)] Applying 64 operations to partition &quot;boot&quot;</span><br><span class="line">[0119/030730.175639:INFO:delta_performer.cc(601)] Starting to apply update payload operations</span><br><span class="line">[0119/030732.554195:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/system_b partition without O_DSYNC</span><br><span class="line">[0119/030732.555151:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/030732.555206:INFO:delta_performer.cc(386)] Applying 2304 operations to partition &quot;system&quot;</span><br><span class="line">[0119/030753.617572:INFO:delta_performer.cc(210)] Completed 356/3571 operations (9%), 260767744/2172949036 bytes downloaded (12%), overall progress 10%</span><br><span class="line">[0119/030809.120118:INFO:delta_performer.cc(210)] Completed 589/3571 operations (16%), 521519104/2172949036 bytes downloaded (24%), overall progress 20%</span><br><span class="line">[0119/030829.133342:INFO:delta_performer.cc(210)] Completed 858/3571 operations (24%), 814350336/2172949036 bytes downloaded (37%), overall progress 30%</span><br><span class="line">[0119/030847.818425:INFO:delta_performer.cc(210)] Completed 1132/3571 operations (31%), 1086488576/2172949036 bytes downloaded (50%), overall progress 40%</span><br><span class="line">[0119/030907.012157:INFO:delta_performer.cc(210)] Completed 1429/3571 operations (40%), 1329676288/2172949036 bytes downloaded (61%), overall progress 50%</span><br><span class="line">[0119/030914.390509:INFO:delta_performer.cc(210)] Completed 2072/3571 operations (58%), 1351565312/2172949036 bytes downloaded (62%), overall progress 60%</span><br><span class="line">[0119/030928.264078:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/vendor_b partition without O_DSYNC</span><br><span class="line">[0119/030928.265006:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/030928.265065:INFO:delta_performer.cc(386)] Applying 1018 operations to partition &quot;vendor&quot;</span><br><span class="line">[0119/030939.404319:INFO:delta_performer.cc(210)] Completed 2548/3571 operations (71%), 1521074176/2172949036 bytes downloaded (70%), overall progress 70%</span><br><span class="line">[0119/030959.073585:INFO:delta_performer.cc(210)] Completed 2786/3571 operations (78%), 1796096000/2172949036 bytes downloaded (82%), overall progress 80%</span><br><span class="line">[0119/031021.805564:INFO:delta_performer.cc(210)] Completed 3072/3571 operations (86%), 2056355840/2172949036 bytes downloaded (94%), overall progress 90%</span><br><span class="line">[0119/031031.406053:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/cmnlib_b partition without O_DSYNC</span><br><span class="line">[0119/031031.406953:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.407007:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;cmnlib&quot;</span><br><span class="line">[0119/031031.431870:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/hyp_b partition without O_DSYNC</span><br><span class="line">[0119/031031.432726:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.432780:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;hyp&quot;</span><br><span class="line">[0119/031031.457051:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/xbl_b partition without O_DSYNC</span><br><span class="line">[0119/031031.457909:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.457962:INFO:delta_performer.cc(386)] Applying 2 operations to partition &quot;xbl&quot;</span><br><span class="line">[0119/031031.619811:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/tz_b partition without O_DSYNC</span><br><span class="line">[0119/031031.620741:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.620795:INFO:delta_performer.cc(386)] Applying 2 operations to partition &quot;tz&quot;</span><br><span class="line">[0119/031031.728560:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/uefisecapp_b partition without O_DSYNC</span><br><span class="line">[0119/031031.729560:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.729619:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;uefisecapp&quot;</span><br><span class="line">[0119/031031.743096:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/xbl_config_b partition without O_DSYNC</span><br><span class="line">[0119/031031.743941:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.743991:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;xbl_config&quot;</span><br><span class="line">[0119/031031.755388:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC</span><br><span class="line">[0119/031031.756234:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.756286:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;abl&quot;</span><br><span class="line">[0119/031031.772838:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/dsp_b partition without O_DSYNC</span><br><span class="line">[0119/031031.773704:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031031.773756:INFO:delta_performer.cc(386)] Applying 32 operations to partition &quot;dsp&quot;</span><br><span class="line">[0119/031033.057947:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/bluetooth_b partition without O_DSYNC</span><br><span class="line">[0119/031033.058886:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.058940:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;bluetooth&quot;</span><br><span class="line">[0119/031033.087545:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/imagefv_b partition without O_DSYNC</span><br><span class="line">[0119/031033.088426:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.088481:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;imagefv&quot;</span><br><span class="line">[0119/031033.100948:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/vbmeta_b partition without O_DSYNC</span><br><span class="line">[0119/031033.101786:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.101837:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;vbmeta&quot;</span><br><span class="line">[0119/031033.104208:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/qupfw_b partition without O_DSYNC</span><br><span class="line">[0119/031033.105069:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.105116:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;qupfw&quot;</span><br><span class="line">[0119/031033.110129:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/keymaster_b partition without O_DSYNC</span><br><span class="line">[0119/031033.111036:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.111089:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;keymaster&quot;</span><br><span class="line">[0119/031033.125200:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/dtbo_b partition without O_DSYNC</span><br><span class="line">[0119/031033.126050:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.126100:INFO:delta_performer.cc(386)] Applying 16 operations to partition &quot;dtbo&quot;</span><br><span class="line">[0119/031033.477645:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/aop_b partition without O_DSYNC</span><br><span class="line">[0119/031033.478592:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.478647:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;aop&quot;</span><br><span class="line">[0119/031033.491181:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/modem_b partition without O_DSYNC</span><br><span class="line">[0119/031033.492024:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031033.492075:INFO:delta_performer.cc(386)] Applying 120 operations to partition &quot;modem&quot;</span><br><span class="line">[0119/031041.771315:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/devcfg_b partition without O_DSYNC</span><br><span class="line">[0119/031041.772240:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031041.772293:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;devcfg&quot;</span><br><span class="line">[0119/031041.777995:INFO:delta_performer.cc(374)] Opening /dev/block/bootdevice/by-name/cmnlib64_b partition without O_DSYNC</span><br><span class="line">[0119/031041.778853:INFO:delta_performer.cc(126)] Caching writes.</span><br><span class="line">[0119/031041.778905:INFO:delta_performer.cc(386)] Applying 1 operations to partition &quot;cmnlib64&quot;</span><br><span class="line">[0119/031041.799262:INFO:delta_performer.cc(210)] Completed 3571/3571 operations (100%), 2172949036/2172949036 bytes downloaded (100%), overall progress 100%</span><br><span class="line">[0119/031041.799333:INFO:delta_performer.cc(1370)] Extracted signature data of size 264 at 2172747147</span><br><span class="line">[0119/031041.799367:INFO:multi_range_http_fetcher.cc(112)] terminating transfer</span><br><span class="line">[0119/031041.799397:INFO:multi_range_http_fetcher.cc(173)] Received transfer terminated.</span><br><span class="line">[0119/031041.799416:INFO:multi_range_http_fetcher.cc(124)] TransferEnded w/ code 200</span><br><span class="line">[0119/031041.799438:INFO:multi_range_http_fetcher.cc(137)] bytes_received_this_range_2172949036 range.length 2172949036</span><br><span class="line">[0119/031041.799456:INFO:multi_range_http_fetcher.cc(159)] Done w/ all transfers</span><br><span class="line">[0119/031041.805089:INFO:download_action.cc(374)] VerifyPayload</span><br><span class="line">[0119/031041.805152:INFO:delta_performer.cc(1549)] Verifying payload using public key: /etc/update_engine/update-payload-key.pub.pem</span><br><span class="line">[0119/031041.805172:INFO:delta_performer.cc(1563)] payload_hash_calculator_.raw_hash() == update_check_response_hash</span><br><span class="line">[0119/031041.805196:INFO:delta_performer.cc(1593)] Payload hash matches value in payload.</span><br><span class="line">[0119/031041.805236:INFO:download_action.cc(397)] Collections of histograms for UpdateEngine.DownloadAction.</span><br><span class="line">Histogram: UpdateEngine.DownloadAction.InstallOperation::REPLACE.Duration recorded 3571 samples, mean = 46.2</span><br><span class="line">0    ------------------------------------------------------------------------O (1381 = 38.7%)</span><br><span class="line">10   ---O                                                                      (50 = 1.4%) &#123;38.7%&#125;</span><br><span class="line">18   ---------O                                                                (164 = 4.6%) &#123;40.1%&#125;</span><br><span class="line">32   -----------------------------------O                                      (667 = 18.7%) &#123;44.7%&#125;</span><br><span class="line">57   ------------------------------------------------O                         (923 = 25.8%) &#123;63.3%&#125;</span><br><span class="line">101  --------------------O                                                     (386 = 10.8%) &#123;89.2%&#125;</span><br><span class="line">179  ... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[0119/031041.805296:INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kSuccess</span><br><span class="line">[0119/031041.805312:INFO:action_processor.cc(143)] ActionProcessor: starting FilesystemVerifierAction</span><br><span class="line">[0119/031041.805334:INFO:filesystem_verifier_action.cc(108)] Hashing partition 0 (boot) on device /dev/block/bootdevice/by-name/boot_b</span><br><span class="line">[0119/031042.385142:INFO:filesystem_verifier_action.cc(199)] Hash of boot: EpKxremioCiMOtX/ll7vdGHgyPA6hkS+aEATJ1bTmvs=</span><br><span class="line">[0119/031042.483456:INFO:filesystem_verifier_action.cc(108)] Hashing partition 1 (system) on device /dev/block/bootdevice/by-name/system_b</span><br><span class="line">[0119/031103.269791:INFO:filesystem_verifier_action.cc(199)] Hash of system: a3cVb5cmEwvwXp9qRV7S/FHD88SUx5SdPdBL9vdtfdA=</span><br><span class="line">[0119/031106.812035:INFO:filesystem_verifier_action.cc(108)] Hashing partition 2 (vendor) on device /dev/block/bootdevice/by-name/vendor_b</span><br><span class="line">[0119/031116.011647:INFO:filesystem_verifier_action.cc(199)] Hash of vendor: Hz4lmS/Ubd04ZcY3N2Z6Tn1hKcmYPjdeeHbyRCw3n6U=</span><br><span class="line">[0119/031117.573949:INFO:filesystem_verifier_action.cc(108)] Hashing partition 3 (cmnlib) on device /dev/block/bootdevice/by-name/cmnlib_b</span><br><span class="line">[0119/031117.581216:INFO:filesystem_verifier_action.cc(199)] Hash of cmnlib: jobjLrtwvwr4lomr6gMHgT07CnYt+m2n9rimaAX8gmA=</span><br><span class="line">[0119/031117.582299:INFO:filesystem_verifier_action.cc(108)] Hashing partition 4 (hyp) on device /dev/block/bootdevice/by-name/hyp_b</span><br><span class="line">[0119/031117.586890:INFO:filesystem_verifier_action.cc(199)] Hash of hyp: GBrSZwkKGzyPmjMln6hNqCs0MMdOnVNq+0xvPg9wEIo=</span><br><span class="line">[0119/031117.589001:INFO:filesystem_verifier_action.cc(108)] Hashing partition 5 (xbl) on device /dev/block/bootdevice/by-name/xbl_b</span><br><span class="line">[0119/031117.605620:INFO:filesystem_verifier_action.cc(199)] Hash of xbl: Srhj/31G6kvceupG54iy2ATnvTrHaGDTNrXoQ9QoBQM=</span><br><span class="line">[0119/031117.608525:INFO:filesystem_verifier_action.cc(108)] Hashing partition 6 (tz) on device /dev/block/bootdevice/by-name/tz_b</span><br><span class="line">[0119/031117.624519:INFO:filesystem_verifier_action.cc(199)] Hash of tz: 6j6yJ6VEJP/eDEfVAfBTJsPeihIw8stgYx3IZYNUTjU=</span><br><span class="line">[0119/031117.627394:INFO:filesystem_verifier_action.cc(108)] Hashing partition 7 (uefisecapp) on device /dev/block/bootdevice/by-name/uefisecapp_b</span><br><span class="line">[0119/031117.630008:INFO:filesystem_verifier_action.cc(199)] Hash of uefisecapp: SsTDYAIGR57uuERCJVW4pYo7qliFTfFC0bjkeCdhuaA=</span><br><span class="line">[0119/031117.630216:INFO:filesystem_verifier_action.cc(108)] Hashing partition 8 (xbl_config) on device /dev/block/bootdevice/by-name/xbl_config_b</span><br><span class="line">[0119/031117.632794:INFO:filesystem_verifier_action.cc(199)] Hash of xbl_config: PXsK2uY4CZHl9HTw4MNn2V2JKjf+tL5lF3Rsrxq/DlQ=</span><br><span class="line">[0119/031117.632997:INFO:filesystem_verifier_action.cc(108)] Hashing partition 9 (abl) on device /dev/block/bootdevice/by-name/abl_b</span><br><span class="line">[0119/031117.635997:INFO:filesystem_verifier_action.cc(199)] Hash of abl: pTmXXhjn578lQoU4Ms2gevuE1u9lf6fkfKkeb2wErOc=</span><br><span class="line">[0119/031117.638910:INFO:filesystem_verifier_action.cc(108)] Hashing partition 10 (dsp) on device /dev/block/bootdevice/by-name/dsp_b</span><br><span class="line">[0119/031117.929656:INFO:filesystem_verifier_action.cc(199)] Hash of dsp: kGaIexuCECjzYboVNAQWYgSk5+2ZDAreFTT+9Lae68I=</span><br><span class="line">[0119/031117.978875:INFO:filesystem_verifier_action.cc(108)] Hashing partition 11 (bluetooth) on device /dev/block/bootdevice/by-name/bluetooth_b</span><br><span class="line">[0119/031117.986127:INFO:filesystem_verifier_action.cc(199)] Hash of bluetooth: +o/xD1GaNQ+dXp3dI7cHLl/ecNQveGozZ5/+3mkysI0=</span><br><span class="line">[0119/031117.986856:INFO:filesystem_verifier_action.cc(108)] Hashing partition 12 (imagefv) on device /dev/block/bootdevice/by-name/imagefv_b</span><br><span class="line">[0119/031117.988422:INFO:filesystem_verifier_action.cc(199)] Hash of imagefv: YtGPa6a7hx2vAUrQBMIID6821Cagh5hM7mfWvouDZjE=</span><br><span class="line">[0119/031117.988506:INFO:filesystem_verifier_action.cc(108)] Hashing partition 13 (vbmeta) on device /dev/block/bootdevice/by-name/vbmeta_b</span><br><span class="line">[0119/031117.989126:INFO:filesystem_verifier_action.cc(199)] Hash of vbmeta: 8SxbQYbjPUCebXdmSJg7iJhcJbdkDKRbIozhlEfIly8=</span><br><span class="line">[0119/031117.989176:INFO:filesystem_verifier_action.cc(108)] Hashing partition 14 (qupfw) on device /dev/block/bootdevice/by-name/qupfw_b</span><br><span class="line">[0119/031117.990481:INFO:filesystem_verifier_action.cc(199)] Hash of qupfw: QwIM5J4OBdFm+EJmlrp+443q7M7HHzGsyWp7/6a7rks=</span><br><span class="line">[0119/031117.990598:INFO:filesystem_verifier_action.cc(108)] Hashing partition 15 (keymaster) on device /dev/block/bootdevice/by-name/keymaster_b</span><br><span class="line">[0119/031117.993895:INFO:filesystem_verifier_action.cc(199)] Hash of keymaster: QxPBL7CmuMS851FLt2IyJ1viO+NlEfrcLiVCveNrUZM=</span><br><span class="line">[0119/031117.996472:INFO:filesystem_verifier_action.cc(108)] Hashing partition 16 (dtbo) on device /dev/block/bootdevice/by-name/dtbo_b</span><br><span class="line">[0119/031118.143676:INFO:filesystem_verifier_action.cc(199)] Hash of dtbo: J4XfTy8iKmEDrT2g3p/IFowpezxKk5O1eaT2SIt9siY=</span><br><span class="line">[0119/031118.168441:INFO:filesystem_verifier_action.cc(108)] Hashing partition 17 (aop) on device /dev/block/bootdevice/by-name/aop_b</span><br><span class="line">[0119/031118.171454:INFO:filesystem_verifier_action.cc(199)] Hash of aop: a/+FDfEjG5fT7d43Lt2kzG+Ij3hWIo9u5anzMHTctRU=</span><br><span class="line">[0119/031118.172903:INFO:filesystem_verifier_action.cc(108)] Hashing partition 18 (modem) on device /dev/block/bootdevice/by-name/modem_b</span><br><span class="line">[0119/031119.258618:INFO:filesystem_verifier_action.cc(199)] Hash of modem: es49VhO5api6iwZjDt/DWLBqXA9DnJvRccmvEL5FK/Y=</span><br><span class="line">[0119/031119.446663:INFO:filesystem_verifier_action.cc(108)] Hashing partition 19 (devcfg) on device /dev/block/bootdevice/by-name/devcfg_b</span><br><span class="line">[0119/031119.449470:INFO:filesystem_verifier_action.cc(199)] Hash of devcfg: CNmqJR7BqkQgcJNdrtCYKCQrJVEgehBfe/eCQGm7/n8=</span><br><span class="line">[0119/031119.449603:INFO:filesystem_verifier_action.cc(108)] Hashing partition 20 (cmnlib64) on device /dev/block/bootdevice/by-name/cmnlib64_b</span><br><span class="line">[0119/031119.455933:INFO:filesystem_verifier_action.cc(199)] Hash of cmnlib64: CTW5va0C8mcZN2pg46xloHvD5tq1x61mHAMGoB7siqM=</span><br><span class="line">[0119/031119.456733:INFO:action_processor.cc(116)] ActionProcessor: finished FilesystemVerifierAction with code ErrorCode::kSuccess</span><br><span class="line">[0119/031119.456762:INFO:action_processor.cc(143)] ActionProcessor: starting PostinstallRunnerAction</span><br><span class="line">gpt_utils_set_xbl_boot_partition: setting /dev/block/bootdevice/by-name/xbl_b lun as boot lun</span><br><span class="line">get_scsi_node_from_bootdevice:scsi generic node is :/dev/sg5:</span><br><span class="line">[0119/031119.489816:INFO:postinstall_runner_action.cc(363)] All post-install commands succeeded</span><br><span class="line">[0119/031119.489859:INFO:action_processor.cc(116)] ActionProcessor: finished last action PostinstallRunnerAction with code ErrorCode::kSuccess</span><br><span class="line">[0119/031119.489883:INFO:update_attempter_android.cc(439)] Processing Done.</span><br><span class="line">[0119/031119.489968:INFO:update_attempter_android.cc(447)] Update successfully applied, waiting to reboot.</span><br><span class="line">[0119/031119.490153:ERROR:prefs.cc(85)] storage_-&gt;DeleteKey(key) failed.</span><br><span class="line">[0119/031119.490176:INFO:metrics_utils.cc(353)] Updated Marker = 1/1/1970 0:23:57 GMT</span><br></pre></td></tr></table></figure>

<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/private/domain.te b/private/domain.te</span></span><br><span class="line"><span class="comment">index 3c1edc1..26bfd2c 100644</span></span><br><span class="line"><span class="comment">--- a/private/domain.te</span></span><br><span class="line"><span class="comment">+++ b/private/domain.te</span></span><br><span class="line"><span class="meta">@@ -312,6 +312,7 @@</span> define(`dac_override_allowed&#x27;, `&#123;</span><br><span class="line">   vold</span><br><span class="line">   vold_prepare_subdirs</span><br><span class="line">   zygote</span><br><span class="line"><span class="addition">+  update_engine</span></span><br><span class="line"> &#125;&#x27;)</span><br><span class="line"> neverallow ~dac_override_allowed self:global_capability_class_set dac_override;</span><br><span class="line"> # Since the kernel checks dac_read_search before dac_override, domains that</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="差量升级ota-log"><a href="#差量升级ota-log" class="headerlink" title="差量升级ota log"></a>差量升级ota log</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line">08-18 19:24:51.361  1471  1471 I update_engine: [INFO:update_attempter_android.cc(280)] Using this install plan:</span><br><span class="line">08-18 19:24:51.365  1471  1471 I update_engine: [INFO:install_plan.cc(91)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file:///data/ota_package/inc_test.zip, payload: (size: 280875113, metadata_size: 668528, metadata signature: , hash: 60B62E3DD97FB3D966AE7D44B25D7150197D23C3CF28453FC39C8D3FBD94E7DA, payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true, is_rollback: false, write_verity: true</span><br><span class="line">08-18 19:24:51.369  1471  1471 I update_engine: [INFO:metrics_utils.cc(363)] Number of Reboots during current update attempt = 0</span><br><span class="line">08-18 19:24:51.371  1471  1471 I update_engine: [INFO:metrics_utils.cc(371)] Payload Attempt Number = 1</span><br><span class="line">08-18 19:24:51.374  1471  1471 I update_engine: [INFO:metrics_utils.cc(388)] Update Monotonic Timestamp Start = 1/1/1970 0:04:02 GMT</span><br><span class="line">08-18 19:24:51.376  1471  1471 I update_engine: [INFO:metrics_utils.cc(397)] Update Boot Timestamp Start = 1/1/1970 0:04:02 GMT</span><br><span class="line">08-18 19:24:51.378  1471  1471 I update_engine: [INFO:update_attempter_android.cc(648)] Scheduling an action processor start.</span><br><span class="line">08-18 19:24:51.383  1471  1471 I update_engine: [INFO:action_processor.cc(51)] ActionProcessor: starting UpdateBootFlagsAction</span><br><span class="line">08-18 19:24:51.385  1471  1471 I update_engine: [INFO:update_boot_flags_action.cc(45)] Marking booted slot as good.</span><br><span class="line">08-18 19:24:51.412  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished UpdateBootFlagsAction with code ErrorCode::kSuccess</span><br><span class="line">08-18 19:24:51.414  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting CleanupPreviousUpdateAction</span><br><span class="line">08-18 19:24:51.416  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(82)] Starting/resuming CleanupPreviousUpdateAction</span><br><span class="line">08-18 19:24:51.417  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(137)] Boot completed, waiting on markBootSuccessful()</span><br><span class="line">08-18 19:24:51.420  1471  1471 I update_engine: EnsureMetadataMounted does nothing in Android mode.</span><br><span class="line">08-18 19:24:51.422  1471  1471 I update_engine: Read merge statistics file failed: No such file or directory</span><br><span class="line">08-18 19:24:51.424  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(206)] Waiting for any previous merge request to complete. This can take up to several minutes.</span><br><span class="line">08-18 19:24:51.426  1471  1471 E update_engine: [ERROR:cleanup_previous_update_action.cc(240)] Previous update has not been completed, not cleaning up</span><br><span class="line">08-18 19:24:51.428  1471  1471 I update_engine: [INFO:cleanup_previous_update_action.cc(397)] Not reporting merge stats because state is Initiated</span><br><span class="line">08-18 19:24:51.429  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished CleanupPreviousUpdateAction with code ErrorCode::kSuccess</span><br><span class="line">08-18 19:24:51.431  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting InstallPlanAction</span><br><span class="line">08-18 19:24:51.433  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished InstallPlanAction with code ErrorCode::kSuccess</span><br><span class="line">08-18 19:24:51.435  1471  1471 I update_engine: [INFO:action_processor.cc(143)] ActionProcessor: starting DownloadAction</span><br><span class="line">08-18 19:24:51.437  1471  1471 I update_engine: [INFO:install_plan.cc(91)] InstallPlan: new_update, version: , source_slot: A, target_slot: B, url: file:///data/ota_package/inc_test.zip, payload: (size: 280875113, metadata_size: 668528, metadata signature: , hash: 60B62E3DD97FB3D966AE7D44B25D7150197D23C3CF28453FC39C8D3FBD94E7DA, payload type: unknown), hash_checks_mandatory: true, powerwash_required: false, switch_slot_on_reboot: true, run_post_install: true, is_rollback: false, write_verity: true</span><br><span class="line">08-18 19:24:51.438  1471  1471 I update_engine: [INFO:download_action.cc(199)] Marking new slot as unbootable</span><br><span class="line">08-18 19:24:51.460  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(45)] starting first transfer</span><br><span class="line">08-18 19:24:51.463  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(74)] starting transfer of range 1427+280875113</span><br><span class="line">08-18 19:24:51.468  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 0/? operations, 16384/280875113 bytes downloaded (0%), overall progress 0%</span><br><span class="line">08-18 19:24:51.500  1471  1471 I update_engine: [INFO:delta_performer.cc(520)] Manifest size in payload matches expected value from Omaha</span><br><span class="line">08-18 19:24:51.502  1471  1471 I update_engine: [INFO:delta_performer.cc(1693)] Verifying using certificates: /system/etc/security/otacerts.zip</span><br><span class="line">08-18 19:24:51.508  1471  1471 I update_engine: [INFO:payload_verifier.cc(102)] signature blob size = 267</span><br><span class="line">08-18 19:24:51.510  1471  1471 I update_engine: [INFO:payload_verifier.cc(118)] Truncating the signature to its unpadded size: 256.</span><br><span class="line">08-18 19:24:51.512  1471  1471 I update_engine: [INFO:payload_verifier.cc(129)] Verified correct signature 1 out of 1 signatures.</span><br><span class="line">08-18 19:24:51.514  1471  1471 I update_engine: [INFO:payload_metadata.cc(224)] Metadata hash signature matches value in Omaha response.</span><br><span class="line">08-18 19:24:51.551  1471  1471 I update_engine: [INFO:delta_performer.cc(1728)] Detected a &#x27;delta&#x27; payload.</span><br><span class="line">08-18 19:24:51.575  1471  1471 I update_engine: [INFO:prefs.cc(122)] dynamic-partition-metadata-updated not present in /data/misc/update_engine/prefs</span><br><span class="line">08-18 19:24:51.580  1471  1471 I update_engine: [INFO:delta_performer.cc(985)] Preparing partitions for new update. last hash = , new hash = YLYuPdl/s9lmrn1Esl1xUBl9I8PPKEU/w5yNP72U59o=cwT0tXBzdXay7seGtMnnLLggDWo8d2VvGTwG3+iAGQA=</span><br><span class="line">08-18 19:24:51.586  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:51.590  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:51.607  1471  1471 I update_engine: type=1400 audit(0.0:1346): avc: denied &#123; search &#125; for name=&quot;/&quot; dev=&quot;sde6&quot; ino=1 scontext=u:r:update_engine:s0 tcontext=u:object_r:bt_firmware_file:s0 tclass=dir permissive=1</span><br><span class="line">08-18 19:24:51.611  1471  1471 I update_engine: EnsureMetadataMounted does nothing in Android mode.</span><br><span class="line">08-18 19:24:51.615  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(676)] Erasing AVB footer of system_other partition before update.</span><br><span class="line">08-18 19:24:51.619  1471  1471 E update_engine: [libfs_mgr]ReadFstabFromFile(): cannot open file: &#x27;/system/etc/fstab.postinstall&#x27;: No such file or directory</span><br><span class="line">08-18 19:24:51.621  1471  1471 W update_engine: [WARNING:dynamic_partition_control_android.cc(550)] Cannot read fstab from /system/etc/fstab.postinstall: No such file or directory (2)</span><br><span class="line">08-18 19:24:51.623  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(577)] AVB is not enabled on system_other. Skip erasing.</span><br><span class="line">08-18 19:24:51.625  1471  1471 I update_engine: Update has been initiated, now canceling</span><br><span class="line">08-18 19:24:51.627  1471  1471 I update_engine: Removing all update state.</span><br><span class="line">08-18 19:24:51.629  1471  1471 W update_engine: Cannot read /metadata/ota/snapshot-boot: No such file or directory</span><br><span class="line">08-18 19:24:51.630  1471  1471 W update_engine: Failed to get flashing status</span><br><span class="line">08-18 19:24:51.632  1471  1471 W update_engine: Cannot read /metadata/ota/snapshot-boot: No such file or directory</span><br><span class="line">08-18 19:24:52.644  1471  1471 I update_engine: Successfully unmapped snapshot system_b</span><br><span class="line">08-18 19:24:52.654  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b</span><br><span class="line">08-18 19:24:52.766  1471  1471 I update_engine: Successfully unmapped snapshot product_b</span><br><span class="line">08-18 19:24:52.776  1471  1471 I update_engine: Successfully unmapped snapshot odm_b</span><br><span class="line">08-18 19:24:52.837  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:52.858  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:52.883  1471  1471 I update_engine: [liblp]Partition odm_b will resize from 1286144 bytes to 1089536 bytes</span><br><span class="line">08-18 19:24:52.885  1471  1471 I update_engine: [liblp]Partition system_b will resize from 3553296384 bytes to 3517079552 bytes</span><br><span class="line">08-18 19:24:52.886  1471  1471 I update_engine: [liblp]Partition product_b will resize from 310919168 bytes to 328949760 bytes</span><br><span class="line">08-18 19:24:52.888  1471  1471 I update_engine: [liblp]Partition vendor_b will resize from 1469992960 bytes to 1523589120 bytes</span><br><span class="line">08-18 19:24:52.889  1471  1471 I update_engine: Remaining free space for COW: 3753377792 bytes</span><br><span class="line">08-18 19:24:52.934  1471  1471 I update_engine: For partition system_b, device size = 3517079552, snapshot size = 3517079552, cow partition size = 3530821632, cow file size = 0</span><br><span class="line">08-18 19:24:52.941  1471  1471 I update_engine: [liblp]Partition system_b-cow will resize from 0 bytes to 3530821632 bytes</span><br><span class="line">08-18 19:24:52.943  1471  1471 I update_engine: Successfully created snapshot partition for system_b</span><br><span class="line">08-18 19:24:52.945  1471  1471 I update_engine: Remaining free space for COW: 222298112 bytes</span><br><span class="line">08-18 19:24:52.951  1471  1471 I update_engine: For partition product_b, device size = 328949760, snapshot size = 328949760, cow partition size = 222298112, cow file size = 107937792</span><br><span class="line">08-18 19:24:52.954  1471  1471 I update_engine: [liblp]Partition product_b-cow will resize from 0 bytes to 222298112 bytes</span><br><span class="line">08-18 19:24:52.956  1471  1471 I update_engine: Successfully created snapshot partition for product_b</span><br><span class="line">08-18 19:24:52.958  1471  1471 I update_engine: Remaining free space for COW: 0 bytes</span><br><span class="line">08-18 19:24:52.976  1471  1471 I update_engine: For partition vendor_b, device size = 1523589120, snapshot size = 1523589120, cow partition size = 0, cow file size = 1529540608</span><br><span class="line">08-18 19:24:52.982  1471  1471 I update_engine: Successfully created snapshot partition for vendor_b</span><br><span class="line">08-18 19:24:52.986  1471  1471 I update_engine: Remaining free space for COW: 0 bytes</span><br><span class="line">08-18 19:24:52.988  1471  1471 I update_engine: For partition odm_b, device size = 1089536, snapshot size = 1089536, cow partition size = 0, cow file size = 1044480</span><br><span class="line">08-18 19:24:52.990  1471  1471 I update_engine: Successfully created snapshot partition for odm_b</span><br><span class="line">08-18 19:24:52.992  1471  1471 I update_engine: Allocating CoW images.</span><br><span class="line">08-18 19:24:53.006  1471  1471 I update_engine: Successfully created snapshot for odm_b</span><br><span class="line">08-18 19:24:53.104  1471  1471 I update_engine: Successfully created snapshot for product_b</span><br><span class="line">08-18 19:24:53.126  1471  1471 I update_engine: Successfully created snapshot for system_b</span><br><span class="line">08-18 19:24:53.621  1471  1471 I update_engine: Successfully created snapshot for vendor_b</span><br><span class="line">08-18 19:24:53.625  1471  1471 I update_engine: Successfully unmapped snapshot system_b</span><br><span class="line">08-18 19:24:53.661  1471  1471 I update_engine: Mapped COW device for system_b at /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.666  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.708  1471  1471 I update_engine: Successfully unmapped snapshot product_b</span><br><span class="line">08-18 19:24:53.740  1471  1471 I update_engine: Mapped product_b-cow-img to /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.769  1471  1471 I update_engine: Mapped COW device for product_b at /dev/block/dm-10</span><br><span class="line">08-18 19:24:53.775  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-10</span><br><span class="line">08-18 19:24:53.835  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b</span><br><span class="line">08-18 19:24:53.862  1471  1471 I update_engine: Mapped vendor_b-cow-img to /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.865  1471  1471 I update_engine: Mapped COW image for vendor_b at vendor_b-cow-img</span><br><span class="line">08-18 19:24:53.868  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.900  1471  1471 I update_engine: Successfully unmapped snapshot odm_b</span><br><span class="line">08-18 19:24:53.930  1471  1471 I update_engine: Mapped odm_b-cow-img to /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.933  1471  1471 I update_engine: Mapped COW image for odm_b at odm_b-cow-img</span><br><span class="line">08-18 19:24:53.935  1471  1471 I update_engine: Zero-filling COW device: /dev/block/dm-9</span><br><span class="line">08-18 19:24:53.968  1471  1471 I update_engine: [liblp]Updated logical partition table at slot 1 on device super</span><br><span class="line">08-18 19:24:53.970  1471  1471 I update_engine: Successfully created all snapshots for target slot _b</span><br><span class="line">08-18 19:24:53.973  1471  1471 I update_engine: [INFO:delta_performer.cc(1002)] PreparePartitionsForUpdate done.</span><br><span class="line">08-18 19:24:53.999  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.002  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.004  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.006  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] abl_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.008  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.011  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.013  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.016  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.018  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] abl_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.020  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.022  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.025  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.027  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.029  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] aop_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.031  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.033  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.035  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.038  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.039  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] aop_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.041  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.043  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.045  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.048  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.049  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] bluetooth_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.051  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.053  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.056  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.059  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.060  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] bluetooth_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.062  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.064  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.067  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.069  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.071  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] boot_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.072  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.075  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.077  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.079  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.081  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] boot_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.083  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.085  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.088  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.090  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.091  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] cpucp_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.094  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.096  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.098  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.100  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.102  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] cpucp_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.104  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.107  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.109  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.111  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.113  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] devcfg_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.115  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.117  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.119  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.121  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.122  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] devcfg_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.125  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.127  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.129  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.131  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.133  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dsp_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.135  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.137  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.139  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.142  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.144  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dsp_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.146  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.148  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.150  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.152  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.154  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dtbo_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.156  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.158  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.161  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.163  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.164  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] dtbo_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.166  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.169  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.171  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.174  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.175  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] featenabler_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.177  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.179  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.182  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.184  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.185  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] featenabler_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.188  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.190  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.193  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.195  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.197  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] hyp_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.200  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.202  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.205  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.208  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.210  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] hyp_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.212  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.214  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.217  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.220  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.221  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] imagefv_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.224  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.226  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.229  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.231  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.233  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] imagefv_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.235  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.238  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.241  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.243  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.244  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] keymaster_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.246  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.249  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.251  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.253  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.255  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] keymaster_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.257  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.259  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.262  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.264  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.265  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] modem_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.267  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.269  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.272  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.274  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.276  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] modem_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.278  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.280  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.282  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.285  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.286  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] odm_a is mapped on device mapper: /dev/block/dm-3</span><br><span class="line">08-18 19:24:54.288  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.291  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.293  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.295  1471  1471 I update_engine: Successfully unmapped snapshot odm_b</span><br><span class="line">08-18 19:24:54.328  1471  1471 I update_engine: [libfs_mgr]Created logical partition odm_b-base on device /dev/block/dm-9</span><br><span class="line">08-18 19:24:54.358  1471  1471 I update_engine: Mapped odm_b-cow-img to /dev/block/dm-10</span><br><span class="line">08-18 19:24:54.361  1471  1471 I update_engine: Mapped COW image for odm_b at odm_b-cow-img</span><br><span class="line">08-18 19:24:54.420  1471  1471 I update_engine: Mapped odm_b as snapshot device at /dev/block/dm-11</span><br><span class="line">08-18 19:24:54.422  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped odm_b to device mapper (force_writable = 1); device path at /dev/block/dm-11</span><br><span class="line">08-18 19:24:54.426  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.429  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.432  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.433  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] product_a is mapped on device mapper: /dev/block/dm-1</span><br><span class="line">08-18 19:24:54.435  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.438  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.440  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.441  1471  1471 I update_engine: Successfully unmapped snapshot product_b</span><br><span class="line">08-18 19:24:54.472  1471  1471 I update_engine: [libfs_mgr]Created logical partition product_b-base on device /dev/block/dm-12</span><br><span class="line">08-18 19:24:54.503  1471  1471 I update_engine: Mapped product_b-cow-img to /dev/block/dm-13</span><br><span class="line">08-18 19:24:54.536  1471  1471 I update_engine: Mapped COW device for product_b at /dev/block/dm-14</span><br><span class="line">08-18 19:24:54.557  1471  1471 I update_engine: Mapped product_b as snapshot device at /dev/block/dm-15</span><br><span class="line">08-18 19:24:54.561  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped product_b to device mapper (force_writable = 1); device path at /dev/block/dm-15</span><br><span class="line">08-18 19:24:54.564  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.567  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.569  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.571  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] qupfw_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.573  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.576  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.579  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.582  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.584  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] qupfw_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.586  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.588  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.591  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.593  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.595  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] shrm_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.597  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.599  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.602  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.604  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.605  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] shrm_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.607  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.610  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.612  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.614  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.616  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] system_a is mapped on device mapper: /dev/block/dm-0</span><br><span class="line">08-18 19:24:54.618  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.621  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.623  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.625  1471  1471 I update_engine: Successfully unmapped snapshot system_b</span><br><span class="line">08-18 19:24:54.656  1471  1471 I update_engine: [libfs_mgr]Created logical partition system_b-base on device /dev/block/dm-16</span><br><span class="line">08-18 19:24:54.691  1471  1471 I update_engine: Mapped COW device for system_b at /dev/block/dm-17</span><br><span class="line">08-18 19:24:54.712  1471  1471 I update_engine: Mapped system_b as snapshot device at /dev/block/dm-18</span><br><span class="line">08-18 19:24:54.715  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped system_b to device mapper (force_writable = 1); device path at /dev/block/dm-18</span><br><span class="line">08-18 19:24:54.718  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.721  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.724  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.726  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] tz_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.728  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.730  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.733  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.735  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.737  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] tz_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.739  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.742  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.744  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.746  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.748  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] uefisecapp_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.750  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.752  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.755  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.757  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.759  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] uefisecapp_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.761  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.764  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.767  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.769  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.771  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.773  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.775  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.778  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.780  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.782  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.784  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.786  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.789  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.792  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.793  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_system_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.796  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.798  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.801  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.804  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.806  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vbmeta_system_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.808  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.811  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.814  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.817  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.819  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(957)] vendor_a is mapped on device mapper: /dev/block/dm-2</span><br><span class="line">08-18 19:24:54.821  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.824  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.826  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.828  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b</span><br><span class="line">08-18 19:24:54.861  1471  1471 I update_engine: [libfs_mgr]Created logical partition vendor_b-base on device /dev/block/dm-19</span><br><span class="line">08-18 19:24:54.889  1471  1471 I update_engine: Mapped vendor_b-cow-img to /dev/block/dm-20</span><br><span class="line">08-18 19:24:54.893  1471  1471 I update_engine: Mapped COW image for vendor_b at vendor_b-cow-img</span><br><span class="line">08-18 19:24:54.913  1471  1471 I update_engine: Mapped vendor_b as snapshot device at /dev/block/dm-21</span><br><span class="line">08-18 19:24:54.920  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(173)] Succesfully mapped vendor_b to device mapper (force_writable = 1); device path at /dev/block/dm-21</span><br><span class="line">08-18 19:24:54.924  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.927  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.930  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.932  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vendor_boot_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.935  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.938  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.941  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.944  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.946  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vendor_boot_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.948  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.950  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.953  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.955  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.957  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vm-bootsys_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.959  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.962  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.965  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.967  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.969  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] vm-bootsys_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.972  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.974  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.977  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.979  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.981  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.983  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.985  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.988  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:54.990  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.992  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:54.994  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:54.996  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:54.999  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:55.001  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:55.003  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_config_a is not in super partition metadata.</span><br><span class="line">08-18 19:24:55.005  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:55.007  1471  1471 I update_engine: [libfs_mgr]dt_fstab: Skip disabled entry for partition vendor</span><br><span class="line">08-18 19:24:55.010  1471  1471 I update_engine: Skip mounting partition: /system_ext</span><br><span class="line">08-18 19:24:55.013  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot B in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:55.015  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(938)] xbl_config_b is not in super partition metadata.</span><br><span class="line">08-18 19:24:55.017  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(319)] Loaded metadata from slot A in /dev/block/bootdevice/by-name/super</span><br><span class="line">08-18 19:24:55.019  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old abl sha256: LKUfY1q5mz+KuU4Rmg+MrNqlzBahrYzBU4kOiE8Ooj8= size: 208896</span><br><span class="line">08-18 19:24:55.021  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new abl sha256: hS8rXeEII9MtiJhBaUCxxPfQOUUPeyrxsAU4NxmRr5E= size: 208896</span><br><span class="line">08-18 19:24:55.023  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old aop sha256: +xi8aAv0b4LPhA7kt/VRZ4AqEFxl2IkVj9bOULKDU/M= size: 237568</span><br><span class="line">08-18 19:24:55.025  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new aop sha256: e9o49HW8O1Fu5AwhkPiNrF3tF3vDjG4Ae0RIyoFdXM0= size: 241664</span><br><span class="line">08-18 19:24:55.027  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old bluetooth sha256: c+6BjIunasEsCvK6Jr5m7BzCGJq3tyDHhL3pvQkqVgI= size: 880640</span><br><span class="line">08-18 19:24:55.029  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new bluetooth sha256: zgQ+DFP0LI3nyFOPLQsHE0ZiWrWhaf6+kqmXXBOtIYs= size: 880640</span><br><span class="line">08-18 19:24:55.030  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old boot sha256: i8WwddePQv4qv2Jgtu06Mc5KUAfliUZOJfuzeVROKZU= size: 201326592</span><br><span class="line">08-18 19:24:55.032  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new boot sha256: BCPYki46J+9B7L2Qw0dyqjT4tIgs32GNWP9LPXsB67c= size: 201326592</span><br><span class="line">08-18 19:24:55.034  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old cpucp sha256: Iopy3jwBtH34WvG7QE8hV1VjUptSy6ZdNcqGR0bwPLw= size: 94208</span><br><span class="line">08-18 19:24:55.035  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new cpucp sha256: uaQ7Vd67d7OZbqQijAqsMi8EUJr92PkfPWRCXRY8A3I= size: 98304</span><br><span class="line">08-18 19:24:55.037  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old devcfg sha256: R3UrDvSUGAYyk6z6AGSr6NJ1jv2m1J4ED79aXIyrlhA= size: 49152</span><br><span class="line">08-18 19:24:55.039  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new devcfg sha256: XEZTYY+qC/x3ReEZoJworSGR4/46+PrVrPwSDSslv00= size: 53248</span><br><span class="line">08-18 19:24:55.040  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old dsp sha256: suWGN67jBTosAj9AnqkLIMWJ1ltQ23+u2m907aThq6I= size: 67108864</span><br><span class="line">08-18 19:24:55.042  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new dsp sha256: suWGN67jBTosAj9AnqkLIMWJ1ltQ23+u2m907aThq6I= size: 67108864</span><br><span class="line">08-18 19:24:55.043  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old dtbo sha256: 8pO250Kv+c0lantXJRsH5nuyJIldedl4TZ3DSgjqsgs= size: 8388608</span><br><span class="line">08-18 19:24:55.045  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new dtbo sha256: z9EcMQ0GeM/EUjGJufNOyezldChHx9F9YygkgMdMbKI= size: 8388608</span><br><span class="line">08-18 19:24:55.046  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old featenabler sha256: lG3p43ZOZvarWcTxWX8EE4SFMnxpjL3GsnfjBSOxrWc= size: 86016</span><br><span class="line">08-18 19:24:55.048  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new featenabler sha256: IhmZnJ3dWkolqEJy41s5We3Cr0tQIiXZPWTKmBBirBc= size: 90112</span><br><span class="line">08-18 19:24:55.050  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old hyp sha256: 85Xh+KcpkrrqsHRsagKvIAPrsOONgz/4Dnb4bzpRZ8k= size: 3395584</span><br><span class="line">08-18 19:24:55.051  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new hyp sha256: ywlIjYFGmFdsPZwFBCZ0opfEvdERJzGPzDrGzVlWWZ8= size: 3399680</span><br><span class="line">08-18 19:24:55.053  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old imagefv sha256: Km9PNGzyje+WR5TLaZk3129bHLCuz2cJJ8g+cKe+6Qk= size: 28672</span><br><span class="line">08-18 19:24:55.055  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new imagefv sha256: /2kScNnnNSZXg4v4siLy2+Aew4Y4XzrJUaJSWzULYeA= size: 28672</span><br><span class="line">08-18 19:24:55.056  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old keymaster sha256: 4KHtQoMQb5u7nRY3HiIOk5TOcQuowNNHzIqgLIOjpzU= size: 258048</span><br><span class="line">08-18 19:24:55.058  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new keymaster sha256: MA6O6lkgd8OUfaIdudxGnfYDL2x8hzmakyZHi0Rkvag= size: 262144</span><br><span class="line">08-18 19:24:55.059  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old modem sha256: ko9BWvXMob/IoCy8A+uvq6GwVeBDwswUlqNIAhLaWZY= size: 192884736</span><br><span class="line">08-18 19:24:55.061  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new modem sha256: z9drl26xsoafKek/73PdmdczM5bJOw1X4zRVCvL9Mog= size: 193671168</span><br><span class="line">08-18 19:24:55.062  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old odm sha256: 2Y1fxITkZW1c4hFYBgC7RyAX2dAzHJtnV7ELApEMSCE= size: 1286144</span><br><span class="line">08-18 19:24:55.064  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new odm sha256: l/oIDspqyiDykR4mjk2GPh6zmheHo5f03U9XI1Dfzyg= size: 1089536</span><br><span class="line">08-18 19:24:55.065  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old product sha256: rBOR7K0r7PjpLCPkZI585l0ru8YFtd58Uia9td+7WTY= size: 310919168</span><br><span class="line">08-18 19:24:55.067  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new product sha256: 6TYZ3vLg5bXchP2xAAp3dZrK9r7pY2rbjyD6G+sjk8Y= size: 328949760</span><br><span class="line">08-18 19:24:55.069  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old qupfw sha256: tTsWZkkP/F9TZZ+uWYwLLb7frJ3H/y5XJbxvQmUjIqg= size: 53248</span><br><span class="line">08-18 19:24:55.070  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new qupfw sha256: 3jpnlnLyamrF6hrpPoJ+nOl5tIXKKqbDaOtL1+rgu3s= size: 57344</span><br><span class="line">08-18 19:24:55.072  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old shrm sha256: KrVggLqd3q6VS4C33hRMfWs9vnJX0r+LI23bKLWZ+2E= size: 40960</span><br><span class="line">08-18 19:24:55.073  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new shrm sha256: OYFDe2zcvXDWyPGIyEPOCvtFa9z9MxJ3kro2VzQLWPI= size: 45056</span><br><span class="line">08-18 19:24:55.075  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old system sha256: LhRpM2Co250bUcefZesGxf9sWsi4Iv4GmwLW+gi10EI= size: 3553296384</span><br><span class="line">08-18 19:24:55.076  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new system sha256: cd3Ps088SC1Pe+STTyQvVrK8+cmLLpoCvQlHBle7/io= size: 3517079552</span><br><span class="line">08-18 19:24:55.078  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old tz sha256: 7eBsfC6w41AYS3xI6L0IM78LWLzakupzq0pCPIKVf6s= size: 3624960</span><br><span class="line">08-18 19:24:55.080  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new tz sha256: XJ0GRq1SOmNjs+wlCaH23g6BnYsArLmtRTno9F8B3Aw= size: 3629056</span><br><span class="line">08-18 19:24:55.081  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old uefisecapp sha256: Rw22/udqIRoIpmnH8XXmXXgTIVkRBgSZ+EBf1S/vfPs= size: 122880</span><br><span class="line">08-18 19:24:55.083  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new uefisecapp sha256: Fz8/c9AKTBw0mU48AHyVN8EFPLZdBt6On5w6+giUOXU= size: 126976</span><br><span class="line">08-18 19:24:55.085  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vbmeta sha256: +1lHFFhEHNNXkoGzV+UepcA2ACn52gpr4wcZIFjK3Os= size: 8192</span><br><span class="line">08-18 19:24:55.086  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vbmeta sha256: TgLJLUIKbeSmTd5XCQnyDJKiuQCh32sV2acdW3+V8xc= size: 8192</span><br><span class="line">08-18 19:24:55.088  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vbmeta_system sha256: oCfE/MmDj/oFNutvF8323jQmMOUSZyxWZ967xwIyP/M= size: 4096</span><br><span class="line">08-18 19:24:55.090  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vbmeta_system sha256: 9iscNy39AWU0lXaikuLtSmFQtSqgudkmYhfotwiEHHQ= size: 4096</span><br><span class="line">08-18 19:24:55.091  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vendor sha256: Bnecgyti7gGs/uXInom7bpl3PUJ8bpAGJqL9OTMWUWs= size: 1469992960</span><br><span class="line">08-18 19:24:55.093  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vendor sha256: KbMKhjjPPUb6ew38BtauoenktJzeXsAyIAQo1Suj+pI= size: 1523589120</span><br><span class="line">08-18 19:24:55.094  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vendor_boot sha256: DLiSM4l+ydJE9BAY1xn5W6PD4fnAdGrNx83GwTszUVI= size: 100663296</span><br><span class="line">08-18 19:24:55.096  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vendor_boot sha256: TZ8xsevkXAMLUAoliRXRrS5V2KXwgz+12bSKqSDH8oM= size: 100663296</span><br><span class="line">08-18 19:24:55.097  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old vm-bootsys sha256: eLgXQJ1Qc8shx8H2kpN7i9S7enKAPXcIyf7dB6Dnh9E= size: 229998592</span><br><span class="line">08-18 19:24:55.099  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new vm-bootsys sha256: PvhkY00YGb0Pz8F/NW3NR9KCkULkaMGlv5pPd2pjAlM= size: 229998592</span><br><span class="line">08-18 19:24:55.101  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old xbl sha256: 8s3zMMejgPFQVTda+PL8/oMWZ8TuQI+iANRg/uci02c= size: 3637248</span><br><span class="line">08-18 19:24:55.102  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new xbl sha256: X6ni5/bFuI4xVs0pX4b7Nnp/76s0p6vc03t8pa1+WLc= size: 3641344</span><br><span class="line">08-18 19:24:55.104  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo old xbl_config sha256: WxnRMP2xzZxmwabirIbkVhcC4Sq1V83/JwoB5kRwWsY= size: 212992</span><br><span class="line">08-18 19:24:55.105  1471  1471 I update_engine: [INFO:delta_performer.cc(451)] PartitionInfo new xbl_config sha256: 62UgiqGTFSnz9HN2uM6fwh0vkU91uTbK3xzmHAOizt0= size: 217088</span><br><span class="line">08-18 19:24:55.107  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/abl_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:55.112  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:55.114  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition &quot;abl&quot;</span><br><span class="line">08-18 19:24:55.116  1471  1471 I update_engine: [INFO:delta_performer.cc(657)] Starting to apply update payload operations</span><br><span class="line">08-18 19:24:55.159  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/aop_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:55.164  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:55.167  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 9 operations to partition &quot;aop&quot;</span><br><span class="line">08-18 19:24:55.225  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/bluetooth_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:55.230  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:55.233  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 90 operations to partition &quot;bluetooth&quot;</span><br><span class="line">08-18 19:24:55.509  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/boot_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:55.514  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:55.516  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 115 operations to partition &quot;boot&quot;</span><br><span class="line">08-18 19:24:58.794  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/cpucp_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:58.799  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:58.801  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;cpucp&quot;</span><br><span class="line">08-18 19:24:58.828  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/devcfg_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:58.833  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:58.835  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition &quot;devcfg&quot;</span><br><span class="line">08-18 19:24:58.872  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/dsp_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:58.877  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:58.879  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 62 operations to partition &quot;dsp&quot;</span><br><span class="line">08-18 19:24:59.368  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/dtbo_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.374  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.376  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 4 operations to partition &quot;dtbo&quot;</span><br><span class="line">08-18 19:24:59.436  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/featenabler_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.441  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.444  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;featenabler&quot;</span><br><span class="line">08-18 19:24:59.467  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/hyp_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.471  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.473  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 7 operations to partition &quot;hyp&quot;</span><br><span class="line">08-18 19:24:59.598  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/imagefv_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.603  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.605  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;imagefv&quot;</span><br><span class="line">08-18 19:24:59.631  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/keymaster_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.636  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.639  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;keymaster&quot;</span><br><span class="line">08-18 19:24:59.669  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/modem_b partition without O_DSYNC</span><br><span class="line">08-18 19:24:59.673  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:24:59.675  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 2307 operations to partition &quot;modem&quot;</span><br><span class="line">08-18 19:25:00.036  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 310/10273 operations (3%), 50561024/280875113 bytes downloaded (18%), overall progress 10%</span><br><span class="line">08-18 19:25:06.425  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 2261/10273 operations (22%), 53575680/280875113 bytes downloaded (19%), overall progress 20%</span><br><span class="line">08-18 19:25:07.544  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-11 partition without O_DSYNC</span><br><span class="line">08-18 19:25:07.551  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:25:07.553  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 10 operations to partition &quot;odm&quot;</span><br><span class="line">08-18 19:25:07.654  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-15 partition without O_DSYNC</span><br><span class="line">08-18 19:25:07.659  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:25:07.662  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 280 operations to partition &quot;product&quot;</span><br><span class="line">08-18 19:25:14.019  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/qupfw_b partition without O_DSYNC</span><br><span class="line">08-18 19:25:14.025  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:25:14.028  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;qupfw&quot;</span><br><span class="line">08-18 19:25:14.049  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/shrm_b partition without O_DSYNC</span><br><span class="line">08-18 19:25:14.054  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:25:14.056  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 3 operations to partition &quot;shrm&quot;</span><br><span class="line">08-18 19:25:14.099  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-18 partition without O_DSYNC</span><br><span class="line">08-18 19:25:14.103  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:25:14.106  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 4847 operations to partition &quot;system&quot;</span><br><span class="line">08-18 19:25:19.109  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 3493/10273 operations (34%), 76431360/280875113 bytes downloaded (27%), overall progress 30%</span><br><span class="line">08-18 19:25:34.556  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 4449/10273 operations (43%), 106741760/280875113 bytes downloaded (38%), overall progress 40%</span><br><span class="line">08-18 19:25:40.412  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 4490/10273 operations (43%), 162922496/280875113 bytes downloaded (58%), overall progress 50%</span><br><span class="line">08-18 19:25:52.807  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 5548/10273 operations (54%), 187367424/280875113 bytes downloaded (66%), overall progress 60%</span><br><span class="line">08-18 19:26:01.516  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 6275/10273 operations (61%), 224706560/280875113 bytes downloaded (80%), overall progress 70%</span><br><span class="line">08-18 19:26:16.267  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 7603/10273 operations (74%), 244678656/280875113 bytes downloaded (87%), overall progress 80%</span><br><span class="line">08-18 19:26:20.298  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/tz_b partition without O_DSYNC</span><br><span class="line">08-18 19:26:20.305  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:20.307  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 29 operations to partition &quot;tz&quot;</span><br><span class="line">08-18 19:26:20.444  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/uefisecapp_b partition without O_DSYNC</span><br><span class="line">08-18 19:26:20.450  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:20.452  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 5 operations to partition &quot;uefisecapp&quot;</span><br><span class="line">08-18 19:26:20.486  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vbmeta_b partition without O_DSYNC</span><br><span class="line">08-18 19:26:20.491  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:20.493  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1 operations to partition &quot;vbmeta&quot;</span><br><span class="line">08-18 19:26:20.506  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vbmeta_system_b partition without O_DSYNC</span><br><span class="line">08-18 19:26:20.510  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:20.512  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1 operations to partition &quot;vbmeta_system&quot;</span><br><span class="line">08-18 19:26:20.527  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/dm-21 partition without O_DSYNC</span><br><span class="line">08-18 19:26:20.531  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:20.533  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 1853 operations to partition &quot;vendor&quot;</span><br><span class="line">08-18 19:26:34.562  1471  1471 I update_engine: [INFO:delta_performer.cc(209)] Completed 9041/10273 operations (88%), 260440064/280875113 bytes downloaded (92%), overall progress 90%</span><br><span class="line">08-18 19:26:46.100  1471  1471 I update_engine: [INFO:delta_performer.cc(385)] Opening /dev/block/bootdevice/by-name/vendor_boot_b partition without O_DSYNC</span><br><span class="line">08-18 19:26:46.106  1471  1471 I update_engine: [INFO:delta_performer.cc(128)] Caching writes.</span><br><span class="line">08-18 19:26:46.108  1471  1471 I update_engine: [INFO:delta_performer.cc(397)] Applying 51 operations to partition &quot;vendor_boot&quot;</span><br><span class="line">08-18 19:26:46.150  1471  1471 E update_engine: [ERROR:delta_performer.cc(431)] Unable to open ECC source partition vendor_boot on slot A, file /dev/block/bootdevice/by-name/vendor_boot_a: Success (0)</span><br><span class="line">08-18 19:26:46.155  1471  1471 E update_engine: [ERROR:delta_performer.cc(1158)] The hash of the source data on disk for this operation doesn&#x27;t match the expected value. This could mean that the delta update payload was targeted for another version, or that the source partition was modified after it was installed, for example, by mounting a filesystem.</span><br><span class="line">08-18 19:26:46.157  1471  1471 E update_engine: [ERROR:delta_performer.cc(1163)] Expected:   sha256|hex = 84CBC3930817F59F08D6BAE4E64F40452AEEE007C8B2D74439358BD56446DF6C</span><br><span class="line">08-18 19:26:46.159  1471  1471 E update_engine: [ERROR:delta_performer.cc(1166)] Calculated: sha256|hex = CE99046C8D163FBD1490314FA7582269045D8A1B2B2DDF14EC6B3DF8961D5176</span><br><span class="line">08-18 19:26:46.161  1471  1471 E update_engine: [ERROR:delta_performer.cc(1177)] Operation source (offset:size) in blocks: 0:741,24575:1</span><br><span class="line">08-18 19:26:46.164  1471  1471 E update_engine: [ERROR:delta_performer.cc(1498)] source_fd != nullptr failed.</span><br><span class="line">08-18 19:26:46.166  1471  1471 E update_engine: [ERROR:delta_performer.cc(297)] Failed to perform BROTLI_BSDIFF operation 9648, which is the operation 0 in partition &quot;vendor_boot&quot;</span><br><span class="line">08-18 19:26:46.168  1471  1471 E update_engine: [ERROR:download_action.cc(336)] Error ErrorCode::kDownloadStateInitializationError (20) in DeltaPerformer&#x27;s Write method when processing the received payload -- Terminating processing</span><br><span class="line">08-18 19:26:46.172  1471  1471 I update_engine: [INFO:delta_performer.cc(314)] Discarding 287 unused downloaded bytes</span><br><span class="line">08-18 19:26:46.174  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(177)] Received transfer terminated.</span><br><span class="line">08-18 19:26:46.176  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(129)] TransferEnded w/ code 200</span><br><span class="line">08-18 19:26:46.177  1471  1471 I update_engine: [INFO:multi_range_http_fetcher.cc(131)] Terminating.</span><br><span class="line">08-18 19:26:46.236  1471  1471 I update_engine: [INFO:action_processor.cc(116)] ActionProcessor: finished DownloadAction with code ErrorCode::kDownloadStateInitializationError</span><br><span class="line">08-18 19:26:46.240  1471  1471 I update_engine: [INFO:action_processor.cc(121)] ActionProcessor: Aborting processing due to failure.</span><br><span class="line">08-18 19:26:46.242  1471  1471 I update_engine: [INFO:update_attempter_android.cc(522)] Processing Done.</span><br><span class="line">08-18 19:26:46.245  1471  1471 I update_engine: [INFO:delta_performer.cc(1997)] Resetting recorded hash for prepared partitions.</span><br><span class="line">08-18 19:26:46.248  1471  1471 I update_engine: [INFO:update_attempter_android.cc(546)] Resetting update progress.</span><br><span class="line">08-18 19:26:46.250  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(263)] Destroying [odm_b, product_b, system_b, vendor_b] from device mapper</span><br><span class="line">08-18 19:26:46.278  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition odm_b</span><br><span class="line">08-18 19:26:46.354  1471  1471 I update_engine: Successfully unmapped snapshot odm_b</span><br><span class="line">08-18 19:26:46.359  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped odm_b from device mapper.</span><br><span class="line">08-18 19:26:46.386  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition product_b</span><br><span class="line">08-18 19:26:46.471  1471  1471 I update_engine: Successfully unmapped snapshot product_b</span><br><span class="line">08-18 19:26:46.477  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped product_b from device mapper.</span><br><span class="line">08-18 19:26:46.506  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition system_b</span><br><span class="line">08-18 19:26:46.587  1471  1471 I update_engine: Successfully unmapped snapshot system_b</span><br><span class="line">08-18 19:26:46.592  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped system_b from device mapper.</span><br><span class="line">08-18 19:26:46.689  1471  1471 I update_engine: [libfs_mgr]Unmapped logical partition vendor_b</span><br><span class="line">08-18 19:26:46.742  1471  1471 I update_engine: Successfully unmapped snapshot vendor_b</span><br><span class="line">08-18 19:26:46.746  1471  1471 I update_engine: [INFO:dynamic_partition_control_android.cc(249)] Successfully unmapped vendor_b from device mapper.</span><br><span class="line">08-18 19:26:46.759  1471  1471 I update_engine: [INFO:metrics_reporter_android.cc(131)] Current update attempt downloads 262 bytes data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="r-上virtual-ab的适配"><a href="#r-上virtual-ab的适配" class="headerlink" title="r 上virtual ab的适配"></a>r 上virtual ab的适配</h1><h2 id="recovery上的修改"><a href="#recovery上的修改" class="headerlink" title="recovery上的修改"></a>recovery上的修改</h2><h3 id="升级过程调试"><a href="#升级过程调试" class="headerlink" title="升级过程调试"></a>升级过程调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb push otacerts.zip /system/etc/security/</span><br><span class="line">update_engine_sideload  --payload=file:///tmp/update.zip  --offset=1418 --headers=&quot;\</span><br><span class="line">FILE_HASH=fhPRX5CaUAmedhRy1E8Ee9lAib+pb9uMd1cb+fzx638=</span><br><span class="line">FILE_SIZE=181915047</span><br><span class="line">METADATA_HASH=tUuwjykp1KDc2C1ME+YOZn9tOnHhDzP2ukNFqKVf/tQ=</span><br><span class="line">METADATA_SIZE=607150</span><br><span class="line">&quot;</span><br><span class="line">update_engine_sideload  --payload=file:///tmp/update.zip  --offset=1324 --headers=&quot;\</span><br><span class="line">FILE_HASH=76gLVcAOp24qvgZC0iigNmi+27SwESfR003JZSzJ5C8=</span><br><span class="line">FILE_SIZE=3650338089</span><br><span class="line">METADATA_HASH=h83AZLcrxwdYTK2kr/fajBovPRqOGcmBu1gy6IqEtUI=</span><br><span class="line">METADATA_SIZE=210289</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>算offset的方法:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">&#x27;/home/mi/Downloads/miui-blockota-venus-20.9.24.root-20.9.27.root-f8ff8484a9-11.0.zip&#x27;</span>) <span class="keyword">as</span> input_zip:</span><br><span class="line">  a = input_zip.getinfo(<span class="string">&#x27;payload_properties.txt&#x27;</span>)</span><br><span class="line">  c = input_zip.getinfo(<span class="string">&#x27;payload.bin&#x27;</span>)</span><br><span class="line">  b = a.header_offset - c.file_size</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=micJIkMGwvRYI01GT3ESWtE3O6drypDdWHrAj7mbHJE=</span><br><span class="line">FILE_SIZE=171868736</span><br><span class="line">METADATA_HASH=AnZQNNsMgBsqA0z8asH14haURnuJ35GVvc8HqY2gRbQ=</span><br><span class="line">METADATA_SIZE=1014574</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">update_engine_client \</span><br><span class="line">--payload=file:///data/ota_package/payload.bin \</span><br><span class="line">--update \</span><br><span class="line">--headers=&quot;\</span><br><span class="line">FILE_HASH=GmmYrTs4n1u+a52W7cHE0MQ59sw/qrPAvsuR7JgB2B0=</span><br><span class="line">FILE_SIZE=3618079575</span><br><span class="line">METADATA_HASH=HpGq2D4TNzkkdxlbfoMzbCvKKht4LRDD5kqlHAnbOxg=</span><br><span class="line">METADATA_SIZE=210965</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>



<h2 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h2><p>data report:</p>
<p>fullOTA:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">target_file size</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.10.16-11.0.zip</span></span><br><span class="line">-rw-rw-r-- 1 mi mi 8331428868 10月 16 12:10 signed_venus_global-target_files-20.10.16-11.0.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">images <span class="keyword">in</span> target_file</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.10.16-11.0/IMAGES</span></span><br><span class="line">-rw-rw-r--  1 mi mi  100663296 1月   1  2009 boot-gki.img</span><br><span class="line">-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img</span><br><span class="line">-rw-rw-r--  1 mi mi    1065072 1月   1  2009 odm.img</span><br><span class="line">-rw-rw-r--  1 mi mi        677 1月   1  2009 odm.map</span><br><span class="line">-rw-rw-r--  1 mi mi 1048531236 1月   1  2009 product.img</span><br><span class="line">-rw-rw-r--  1 mi mi      43776 1月   1  2009 product.map</span><br><span class="line">-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img</span><br><span class="line">-rw-rw-r--  1 mi mi  403837100 1月   1  2009 system_ext.img</span><br><span class="line">-rw-rw-r--  1 mi mi      78781 1月   1  2009 system_ext.map</span><br><span class="line">-rw-rw-r--  1 mi mi 2908402304 1月   1  2009 system.img</span><br><span class="line">-rw-rw-r--  1 mi mi     302171 1月   1  2009 system.map</span><br><span class="line">-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img</span><br><span class="line">-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta.img</span><br><span class="line">-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img</span><br><span class="line">-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi 2033811940 1月   1  2009 vendor.img</span><br><span class="line">-rw-rw-r--  1 mi mi     303801 1月   1  2009 vendor.map</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">full ota size</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll miui_VENUSGlobal_20.10.16_aefb58d7af_11.0.zip</span>     </span><br><span class="line">-rw-rw-r-- 1 mi mi 2925387044 10月 16 12:11 miui_VENUSGlobal_20.10.16_aefb58d7af_11.0.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">estimate result</span></span><br><span class="line">out/host/linux-x86/bin/estimate_cow_from_nonab_ota -ota_tf /home/mi/Downloads/signed_venus_global-target_files-20.10.16-11.0</span><br><span class="line">Unsparsing IMAGES/vendor.img ...</span><br><span class="line">Analyzing vendor ...</span><br><span class="line">Unsparsing IMAGES/product.img ...</span><br><span class="line">Analyzing product ...</span><br><span class="line">Unsparsing IMAGES/odm.img ...</span><br><span class="line">Analyzing odm ...</span><br><span class="line">Unsparsing IMAGES/system_ext.img ...</span><br><span class="line">Analyzing system_ext ...</span><br><span class="line">Unsparsing IMAGES/system.img ...</span><br><span class="line">Analyzing system ...</span><br><span class="line">Estimated COW size: 3718300499 (3546MiB)</span><br></pre></td></tr></table></figure>

<p>incOTA:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src target_file</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.9.24-11.0.zip</span></span><br><span class="line">-rw-rw-r-- 1 mi mi 7912365948 10月 16 12:09 signed_venus_global-target_files-20.9.24-11.0.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">images <span class="keyword">in</span> src target_file</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.9.24-11.0/IMAGES</span></span><br><span class="line">-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img</span><br><span class="line">-rw-rw-r--  1 mi mi    1020016 1月   1  2009 odm.img</span><br><span class="line">-rw-rw-r--  1 mi mi        381 1月   1  2009 odm.map</span><br><span class="line">-rw-rw-r--  1 mi mi 1044939068 1月   1  2009 product.img</span><br><span class="line">-rw-rw-r--  1 mi mi      43382 1月   1  2009 product.map</span><br><span class="line">-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img</span><br><span class="line">-rw-rw-r--  1 mi mi  371994820 1月   1  2009 system_ext.img</span><br><span class="line">-rw-rw-r--  1 mi mi      79300 1月   1  2009 system_ext.map</span><br><span class="line">-rw-rw-r--  1 mi mi 2706129500 1月   1  2009 system.img</span><br><span class="line">-rw-rw-r--  1 mi mi     296543 1月   1  2009 system.map</span><br><span class="line">-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img</span><br><span class="line">-rw-rw-r--  1 mi mi       8192 1月   1  2009 vbmeta.img</span><br><span class="line">-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img</span><br><span class="line">-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi 1891361204 1月   1  2009 vendor.img</span><br><span class="line">-rw-rw-r--  1 mi mi     279594 1月   1  2009 vendor.map</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">target_file size</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.10.16-11.0.zip</span></span><br><span class="line">-rw-rw-r-- 1 mi mi 8331428868 10月 16 12:10 signed_venus_global-target_files-20.10.16-11.0.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">images <span class="keyword">in</span> target_file</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll signed_venus_global-target_files-20.10.16-11.0/IMAGES</span></span><br><span class="line">-rw-rw-r--  1 mi mi  100663296 1月   1  2009 boot-gki.img</span><br><span class="line">-rw-rw-r--  1 mi mi  201326592 1月   1  2009 boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi    8388608 1月   1  2009 dtbo.img</span><br><span class="line">-rw-rw-r--  1 mi mi    1065072 1月   1  2009 odm.img</span><br><span class="line">-rw-rw-r--  1 mi mi        677 1月   1  2009 odm.map</span><br><span class="line">-rw-rw-r--  1 mi mi 1048531236 1月   1  2009 product.img</span><br><span class="line">-rw-rw-r--  1 mi mi      43776 1月   1  2009 product.map</span><br><span class="line">-rw-rw-r--  1 mi mi       5080 1月   1  2009 super_empty.img</span><br><span class="line">-rw-rw-r--  1 mi mi  403837100 1月   1  2009 system_ext.img</span><br><span class="line">-rw-rw-r--  1 mi mi      78781 1月   1  2009 system_ext.map</span><br><span class="line">-rw-rw-r--  1 mi mi 2908402304 1月   1  2009 system.img</span><br><span class="line">-rw-rw-r--  1 mi mi     302171 1月   1  2009 system.map</span><br><span class="line">-rw-rw-r--  1 mi mi    2695444 1月   1  2009 userdata.img</span><br><span class="line">-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta.img</span><br><span class="line">-rw-rw-r--  1 mi mi       4096 1月   1  2009 vbmeta_system.img</span><br><span class="line">-rw-rw-r--  1 mi mi  100663296 1月   1  2009 vendor_boot.img</span><br><span class="line">-rw-rw-r--  1 mi mi 2033811940 1月   1  2009 vendor.img</span><br><span class="line">-rw-rw-r--  1 mi mi     303801 1月   1  2009 vendor.map</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">inc ota size</span></span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll miui-blockota-venus_global-20.9.24-20.10.16-958988d114-11.0.zip</span></span><br><span class="line">-rw-rw-r-- 1 mi mi 418387975 10月 16 12:05 miui-blockota-venus_global-20.9.24-20.10.16-958988d114-11.0.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">estimate result</span></span><br><span class="line">out/host/linux-x86/bin/estimate_cow_from_nonab_ota -source_tf ~/Downloads/signed_venus_global-target_files-20.9.24-11.0/ -ota_tf /home/mi/Downloads/signed_venus_global-target_files-20.10.16-11.0</span><br><span class="line"></span><br><span class="line">Unsparsing IMAGES/vendor.img ...</span><br><span class="line">Unsparsing IMAGES/vendor.img ...</span><br><span class="line">Hashing blocks for vendor...</span><br><span class="line">Analyzing vendor ...</span><br><span class="line">Unsparsing IMAGES/product.img ...</span><br><span class="line">Unsparsing IMAGES/product.img ...</span><br><span class="line">Hashing blocks for product...</span><br><span class="line">Analyzing product ...</span><br><span class="line">Unsparsing IMAGES/odm.img ...</span><br><span class="line">Unsparsing IMAGES/odm.img ...</span><br><span class="line">Hashing blocks for odm...</span><br><span class="line">Analyzing odm ...</span><br><span class="line">Unsparsing IMAGES/system_ext.img ...</span><br><span class="line">Unsparsing IMAGES/system_ext.img ...</span><br><span class="line">Hashing blocks for system_ext...</span><br><span class="line">Analyzing system_ext ...</span><br><span class="line">Unsparsing IMAGES/system.img ...</span><br><span class="line">Unsparsing IMAGES/system.img ...</span><br><span class="line">Hashing blocks for system...</span><br><span class="line">Analyzing system ...</span><br><span class="line">Estimated COW size: 1509347450 (1439MiB)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/10/12/OTA%E7%9B%B8%E5%85%B3/keymaster%E8%A7%A3%E5%AF%86%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/OTA%E7%9B%B8%E5%85%B3/keymaster%E8%A7%A3%E5%AF%86%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">设备bootloader上锁状态下1217无法工作问题分析1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-10-12T18:15:54+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:20:28" itemprop="dateModified" datetime="2024-04-16T15:20:28+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%8A%A0%E5%AF%86/" itemprop="url" rel="index"><span itemprop="name">加密</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设备bootloader上锁状态下1217无法工作问题分析"><a href="#设备bootloader上锁状态下1217无法工作问题分析" class="headerlink" title="设备bootloader上锁状态下1217无法工作问题分析"></a>设备bootloader上锁状态下1217无法工作问题分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前面讲到r上6月份升级基线后, 因KM TA date support的升级导致recovery下无法正常使用解密服务.</p>
<p>当时的方案是配置recovery vbmeta区域的 prop <code>--prop com.android.build.boot.security_patch:2020-06-05 </code></p>
<p>从而在bootimg_hdr不支持识别date 信息的情况下, 可以在reocovery模式下bootloader能够读到天的信息, 并传给KM TA.</p>
<h2 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h2><p>最近测试在复测该问题时, 发现手机bootloader上锁状态下, 无法执行1217功能. 因此需要重新分析下这个问题的原因.</p>
<h2 id="locked-状态下的调试"><a href="#locked-状态下的调试" class="headerlink" title="locked 状态下的调试"></a>locked 状态下的调试</h2><h3 id="debug-abl的方法"><a href="#debug-abl的方法" class="headerlink" title="debug abl的方法"></a>debug abl的方法</h3><h4 id="locked状态下的限制"><a href="#locked状态下的限制" class="headerlink" title="locked状态下的限制"></a>locked状态下的限制</h4><p>首先, 小米机器locked 状态有如下限制:</p>
<ol>
<li>不能使用fastboot烧录新的img, 即fastboot flash <partition> &lt;partition.img&gt; 是不被允许的</li>
<li>不能使用fastboot erase 分区, 像<code>fastboot erase misc</code> 无法执行</li>
<li>locked状态切到unlocked状态, unlocked状态切到locked状态, 都会reboot 进recovery, 清除数据.</li>
</ol>
<p>上述限制或功能必须被禁用掉, 因为调试这个问题时, 本地打的调试(带logcat 和 adb shell)功能的在locked状态肯定会报<code>system has destroyed</code>, 其次经常需要debug abl, 烧分区的限制肯定要禁用掉, 不然每次烧录新的abl 都需要使用9008模式烧机, 非常麻烦. locked 切 unlocked状态, 或反之的情况清除数据的功能肯定要拿掉, 因为1217测的就是解主系统加密过的userdata分区, 如果在切换过程中把userdata擦了, 那就破坏了测试的前提. 第二条清misc也是必须的, 因为recovery如果无法正常启动, 出现<code>system has destroyed</code>, 可以通过清misc, 启动到主系统把recovery恢复回来.</p>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>去除locked状态下对fastboot flash &#x2F; fastboot erase 和 切换locked unlocked 对userdata数据的操作</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/#/c/22341/">http://gerrit.bsp.xiaomi.srv/#/c/22341/</a></p>
<h3 id="locked状态下让avb校验失败的recovery成功启动起来"><a href="#locked状态下让avb校验失败的recovery成功启动起来" class="headerlink" title="locked状态下让avb校验失败的recovery成功启动起来"></a>locked状态下让avb校验失败的recovery成功启动起来</h3><blockquote>
<p>注意不能修改avb校验完的状态, 保持最小变量原则</p>
</blockquote>
<h4 id="change-1"><a href="#change-1" class="headerlink" title="change"></a>change</h4><p>即将导向<code>system has destroyed</code>的入口破坏掉</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/22334">http://gerrit.bsp.xiaomi.srv/22334</a> </p>
<h4 id="本地recovery调试1217的方法"><a href="#本地recovery调试1217的方法" class="headerlink" title="本地recovery调试1217的方法"></a>本地recovery调试1217的方法</h4><p>本地编译userdebug版本的recovery即可. </p>
<ol>
<li>将上述change合入后, 编译abl, make aboot或者使用ninja, 注意最后abl一定要通过secureboot签名</li>
<li>locked上锁状态可以先使用解锁工具解锁, 再通过fastboot flash abl abl.elf 烧录locked 状态修改过的abl, 然后再使用fastboot oem lock上锁.</li>
<li>上锁完后, fastboot flash recovery 本地的recovery.img.</li>
<li>fastboot reboot recovery</li>
<li>使用下面的命令, 查看df -h的结果中是否有userdata, vold的输出的log是什么, 如果begin操作报错, 说明keymaster 返回了错误</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root; adb shell mv /system/bin/recovery  /tmp/; adb shell touch /system/bin/recovery; adb shell /tmp/recovery --factory_test_reset&amp;; sleep 6; adb shell df -h; adb logcat -s vold;</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过之前修改recovery 打包写入avb prop的方法已经可以使recovery在unlocked模式下1217正常工作. 而locked状态下却不行. 变量只有一个就是locked状态和unlocked状态.</p>
<p>先根据log定位下初步原因, 测试开始提供的log中只有recovery打出的部分信息:</p>
<p>recovery 重启, reason&#x3D; fs_mgr_mount_all</p>
<p>根据串口log的信息, 首先可以判定是如下情形:</p>
<ol>
<li>主系统bcb (reason –factory_test_reset) -&gt;2.  recovery启动(模式为1217)-&gt; 3. recovery重启(模式变为fs_mgr_mount_all)</li>
</ol>
<p>在第2步1217的执行步骤中触发了 RebootRecovery(fs_mgr_mount_all)的命令, 查看代码, 最终定位到</p>
<p><code>mount_all miui_factoryreset.fstab --late</code>时 init 在执行<code>vdc mountFstab /dev/block/bootdevice/by-name/userdata /data</code>失败后执行了上述命令, 所以需要进一步的log判断为什么这个vdc 的操作失败了.</p>
<p>根据前面debug locked 状态下recovery的方法, 最终可以在locked状态下启动本地带调试版本的recovery</p>
<p>得到的log如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">01-01 01:10:19.148   630   630 D vold    : metadata_key_dir/key: /metadata/vold/metadata_encryption/key</span><br><span class="line">01-01 01:10:19.149   630   630 I vold    : List of Keymaster HALs found:</span><br><span class="line">01-01 01:10:19.149   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.150   630   630 D vold    : Computing HMAC with params &#123; (seed: 54483455460602eb1254138a502eea6249c665fd8feebff883464d797d9f, nonce: 3f7f4c10a7eaf94e91f869e10f3f1ca1d576596d8291933b9c5305dfd90) &#125;</span><br><span class="line">01-01 01:10:19.150   630   630 D vold    : Computing HMAC for Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.152   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.154   630   630 D vold    : Key exists, using: /metadata/vold/metadata_encryption/key</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : List of Keymaster HALs found:</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: Begin send cmd failed</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: ret: 0</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: resp-&gt;status: -33</span><br><span class="line">01-01 01:10:19.161   630   630 E vold    : begin failed, code -33</span><br><span class="line">01-01 01:10:19.148     0     0 D vdc     : Waited 0ms for vold</span><br><span class="line">01-01 01:10:19.161     0     0 E vdc     : Command: cryptfs mountFstab /dev/block/bootdevice/by-name/userdata /data Failed: Status(-8, EX_SERVICE_SPECIFIC): &#x27;0: &#x27;</span><br></pre></td></tr></table></figure>

<p>keymaster返回-33的错误导致了这样的表现.</p>
<p>根据之前对abl的分析, 这个大概率与abl传给KM TA的参数有关.</p>
<p>搜索代码, 最终定位到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set Boot State */</span></span><br><span class="line">BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;</span><br><span class="line">BootStateReq.Version = <span class="number">0</span>;</span><br><span class="line">BootStateReq.Size = <span class="keyword">sizeof</span> (BootStateReq.BootState);</span><br><span class="line">BootStateReq.Offset =</span><br><span class="line">    (UINT8 *)&amp;BootStateReq.BootState - (UINT8 *)&amp;BootStateReq;</span><br><span class="line">BootStateReq.BootState.Color = BootState-&gt;Color;</span><br><span class="line">BootStateReq.BootState.IsUnlocked = BootState-&gt;IsUnlocked;</span><br><span class="line">BootStateReq.BootState.SystemSecurityLevel = BootState-&gt;SystemSecurityLevel;</span><br><span class="line">BootStateReq.BootState.SystemVersion = BootState-&gt;SystemVersion;</span><br><span class="line">CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,</span><br><span class="line">         AVB_SHA256_DIGEST_SIZE);</span><br><span class="line"></span><br><span class="line">DEBUG ((EFI_D_ERROR, <span class="string">&quot;KeyMasterStartApp: bootstate digest: &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s\n&quot;</span>, BootStateDigest));</span><br><span class="line"></span><br><span class="line">Status = Handle.QseeComProtocol-&gt;QseecomSendCmd (</span><br><span class="line">    Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&amp;BootStateReq,</span><br><span class="line">    <span class="keyword">sizeof</span> (BootStateReq), (UINT8 *)&amp;BootStateRsp, <span class="keyword">sizeof</span> (BootStateRsp));</span><br></pre></td></tr></table></figure>

<p>debug分析这一过程发现locked状态下, 只有color是orange时可以让recovery在调用keymaster begin解密经主系统加密的userdata时可以正常返回.</p>
<p>而如果userdata没有通过主系统的加密, 即在recovery下先恢复出厂设置, 再对userdata加密时, color是green情况下, 也可以正常调用keymaster,没有返回错误, 而在recovery下加密userdata完成后, 再启动到主系统, 主系统会报fs_mgr_mount_all的错误.</p>
<p>通过上述现象, 可以推测 加密userdata相当于上层keymaster初始化, 使用当时的环境去加密的数据, 而换了环境之后, 再去解密, 由于环境的变化, 导致keymaster无法校验成功, 所以begin返回了invalid blob(-33), 而这个<code>环境</code>是什么, 通过分析BootState的字段在recovery和主系统下的区别, 只有<code>BootStateDigest</code>是值得怀疑的.</p>
<h2 id="BootStateDigest即UserData-PublicKey的分析"><a href="#BootStateDigest即UserData-PublicKey的分析" class="headerlink" title="BootStateDigest即UserData-&gt;PublicKey的分析"></a>BootStateDigest即UserData-&gt;PublicKey的分析</h2><p>上一步怀疑这个字段有问题后, 需要分析recovery模式和主系统下这个字段的数据来源.</p>
<p>最终发现新基线升级后, recovery的avb校验模式变成了只校验recovery分区自己, 而主系统是校验 vbmeta boot dtbo vbmeta_system. 而主系统这个字段最终来自vbmeta分区的public key. 而recovery的这个字段并没有赋值.</p>
<p>recovery模式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( (!Info-&gt;MultiSlotBoot) ||</span><br><span class="line">         IsDynamicPartitionSupport ()) &amp;&amp;</span><br><span class="line">         (Info-&gt;BootIntoRecovery &amp;&amp;</span><br><span class="line">         !IsBuildUseRecoveryAsBoot ())) &#123;</span><br><span class="line">    <span class="comment">// 非ab机型</span></span><br><span class="line">  <span class="keyword">if</span> (!Info-&gt;MultiSlotBoot) &#123;</span><br><span class="line">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;flag AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION\n&quot;</span>));</span><br><span class="line">      VerifyFlags = VerifyFlags | AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只加载recovery分区</span></span><br><span class="line">  AddRequestedPartition (RequestedPartitionAll, IMG_RECOVERY);</span><br><span class="line">  NumRequestedPartition += <span class="number">1</span>;</span><br><span class="line">  Result = avb_slot_verify (Ops, (CONST CHAR8 *CONST *)RequestedPartition,</span><br><span class="line">             SlotSuffix, VerifyFlags, VerityFlags, &amp;SlotData);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>上面怀疑recovery模式和主系统下abl传给KM TA的摘要是不同的, 那可以想到将vbmeta的public key 填充到 UserData-&gt;PublicKey, 下发给KM TA 是否可以解决locked状态下recovery无法使用keymaster解密经主系统加密的数据.</p>
<p>方案如下:</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/#/c/22338/">http://gerrit.bsp.xiaomi.srv/#/c/22338/</a></p>
<p>只有非ab机型进入recovery情况下, 即<code>AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION</code> flag的作用范围内, 在avb verify完recovery分区后, 再avb verify下vbmeta分区, 目的是为了让其覆盖<code>ops-&gt;user_data</code>段, 而传进<code>load_and_verify_vbmeta</code>的参数需要重新设定, 因为原先的参数很多都是全局或影响avb verify recovery结果的指针, 我们这里只能覆盖<code>ops-&gt;user_data</code>段, 不能对其他段产生影响. 同时还需要对flag 重新置位, 绕开vbmeta相关的检查, 使得可以成功load vbmeta的public key, 并将其赋给<code>ops-&gt;user_data</code>段.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BOOLEAN IsUserKey;</span><br><span class="line">    BOOLEAN IsMultiSlot;</span><br><span class="line">    UINTN PublicKeyLen;</span><br><span class="line">    CHAR8 PublicKey[MAX_USER_KEY_SIZE];</span><br><span class="line">&#125; AvbOpsUserData;</span><br></pre></td></tr></table></figure>

<p>重新测试后, 上述patch有效, locked下recovery中可以正常进行1217功能.</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>locked状态下, 主系统开机后, 执行1217, 正常reboot到recovery中进行清数据的操作, 重启回主系统下, &#x2F;data&#x2F;miui&#x2F;app下内容保留</li>
<li>locked状态下, fastboot flash 本地编的recovery, fastboot reboot recovery后, 应该报<code>system has destroyed</code></li>
<li>unlocked 状态下, 无论是本地编的recovery还是线刷包版本的recovery, 都可以正常进行1217功能</li>
</ol>
<blockquote>
<p>验证时, unlocked状态切换到locked状态, 或反之的情况, 切换过程中都需要进recovery wipe data, 擦完重新开机进主系统, 保证数据要重新经主系统初始化加密一次.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%9C%BA%E5%9E%8Bfastbootd%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%9C%BA%E5%9E%8Bfastbootd%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">vab机型fastbootd使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-10-12T18:15:54+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:08:39" itemprop="dateModified" datetime="2024-04-16T15:08:39+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vnote_backup_file_826537664 &#x2F;home&#x2F;mi&#x2F;Documents&#x2F;backup&#x2F;VnoteBook&#x2F;OTA相关&#x2F;动态分区机型fastbootd使用.md</p>
<h1 id="动态分区机型fastbootd使用"><a href="#动态分区机型fastbootd使用" class="headerlink" title="动态分区机型fastbootd使用"></a>动态分区机型fastbootd使用</h1><h2 id="fastbootd简介"><a href="#fastbootd简介" class="headerlink" title="fastbootd简介"></a>fastbootd简介</h2><p>在动态分区机型上bootloader的fastboot不能烧写动态分区的镜像, 需要使用<strong>recovery子系统</strong>下的fastbootd来进行用户空间的烧写镜像的工作</p>
<p>fastbootd是recovery子系统下的一个native进程, 由init fork出来. 具体实现方式类似于adbd.<br>包括进程创建, 驱动通道, 与init的协作都与adbd一致, 是属于借助usb的config配置实现的功能.<br>因此不能同时启用adb和fastboot模式, 因为这两个独占同一个通道.</p>
<h2 id="fastbootd命令"><a href="#fastbootd命令" class="headerlink" title="fastbootd命令"></a>fastbootd命令</h2><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
<th>Available when device is OEM locked</th>
</tr>
</thead>
<tbody><tr>
<td>getvar is-userspace</td>
<td>Return yes</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar<br/>is-logical:<partition></td>
<td>Return yes if the given partition is a<br/>logical partition, no otherwise</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar super-partition-name</td>
<td>MUST return super for a device<br/>launching with logical partitions</td>
<td>Yes</td>
</tr>
<tr>
<td>create-logical-partition<br/><partition> <size></td>
<td>Create a logical partition with the<br/>given name and size</td>
<td>No</td>
</tr>
<tr>
<td>delete-logical-partition<br/><partition></td>
<td>Delete the given logical partition</td>
<td>No</td>
</tr>
<tr>
<td>resize-logical-partition<br/><partition> <size></td>
<td>Resize the logical partition to the new<br/>size without changing its contents</td>
<td>No</td>
</tr>
<tr>
<td>update-super <partition></td>
<td>Similar to flash super, except rather<br/>than flashing raw data to the super<br/>partition, this will ensure that all<br/>partitions within the downloaded<br/>image are created</td>
<td>No</td>
</tr>
<tr>
<td>getvar max-download-size</td>
<td>Return the maximum size of an image<br/>that can be downloaded in bytes in<br/>hex</td>
<td>Yes</td>
</tr>
<tr>
<td>getvar partition-type<br/><partition-name></td>
<td>Return file system type: ext4, f2fs,<br/>raw</td>
<td>Yes</td>
</tr>
<tr>
<td>flash <em>partition_name</em> filename</td>
<td>Flash the partition through a series of<br/>download and flash fastboot<br/>protocol commands</td>
<td>No</td>
</tr>
<tr>
<td>reboot bootloader</td>
<td>Reboot into bootloader mode</td>
<td>Yes</td>
</tr>
<tr>
<td>reboot fastboot</td>
<td>Reboot back into fastbootd mode</td>
<td>Yes</td>
</tr>
</tbody></table>
<h2 id="安装最新的fastboot工具"><a href="#安装最新的fastboot工具" class="headerlink" title="安装最新的fastboot工具"></a>安装最新的fastboot工具</h2><p>在<a target="_blank" rel="noopener" href="https://developer.android.com/studio/releases/platform-tools">platform-tools</a>获取最新的fastboot和adb的工具</p>
<ul>
<li>linux下替换<br>解压后得到platform-tools 目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export $PATH=&lt;platform-tools目录&gt;:$PATH</span><br></pre></td></tr></table></figure>
<ul>
<li>windows下替换<br>打开资源管理器explorer, 右键<em>此电脑</em>  -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 用户变量 -&gt;Path下添加解压platform-tools的目录<br>注销, 重新登录生效.</li>
</ul>
<p>fastboot devices查看是否有设备号输出, 如果没有, 需要配置端口或更新驱动</p>
<p>win下, 通过设备管理器 -&gt; 其他设备 (未识别的!设备)-&gt; 右键更新驱动 -&gt; 自动搜索驱动</p>
<p>linux下, lsusb 设备号, 将识别出的设备号按照adb 配置设备的方式进行配置, 这里不再赘述</p>
<h2 id="从super-img分离出包含的动态分区"><a href="#从super-img分离出包含的动态分区" class="headerlink" title="从super img分离出包含的动态分区"></a>从super img分离出包含的动态分区</h2><h3 id="转换super-img为原始镜像"><a href="#转换super-img为原始镜像" class="headerlink" title="转换super img为原始镜像"></a>转换super img为原始镜像</h3><p>动态分区线刷包中是super.img，格式是sparse image，要查看super.img首先需要使用simg2img进行转化。若转化后为super_ext4.</p>
<h4 id="Android-Sparse-Image"><a href="#Android-Sparse-Image" class="headerlink" title="Android Sparse Image"></a><code>Android Sparse Image</code></h4><p>为了缩小镜像大小，Android会以稀疏格式生成system.img，vendor.img userdata.img和cache.img。镜像被拆分为4K字节倍数的块。<br>任何不包含有用数据的块都将标记为<code>Don&#39;t Care</code></p>
<p><img src="http://2net.co.uk/images/boot-sparse-image.png" alt="sparse"><br><a target="_blank" rel="noopener" href="http://opengrok.pt.xiaomi.com/opengrok/xref/v10-p-tucana-dev/system/core/libsparse/sparse_format.h">header</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">system/core/libsparse/simg_dump.py   -v  cache.img</span><br><span class="line">cache.img: Total of 98304 4096-byte output blocks in 10 input chunks.</span><br><span class="line">            input_bytes      output_blocks</span><br><span class="line">chunk    offset     number  offset  number</span><br><span class="line">   1         40     114688       0      28 Raw data           </span><br><span class="line">   2     114740          0      28    2047 Don&#x27;t care         </span><br><span class="line">   3     114752      24576    2075       6 Raw data           </span><br><span class="line">   4     139340          0    2081   30687 Don&#x27;t care         </span><br><span class="line">   5     139352       8192   32768       2 Raw data           </span><br><span class="line">   6     147556          0   32770   32766 Don&#x27;t care         </span><br><span class="line">   7     147568       4096   65536       1 Raw data           </span><br><span class="line">   8     151676          0   65537    2049 Don&#x27;t care         </span><br><span class="line">   9     151688       4096   67586       1 Raw data           </span><br><span class="line">  10     155796          0   67587   30717 Don&#x27;t care         </span><br><span class="line">         155796              98304         End</span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll cache.img  cache.img_ext4</span> </span><br><span class="line">-rw-rw-r-- 1 mi mi    155796 11月 14 08:12 cache.img</span><br><span class="line">-rw-rw-r-- 1 mi mi 402653184 11月 19 14:15 cache.img_ext4</span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simg2img ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img    ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4</span><br></pre></td></tr></table></figure>




<h3 id="dump-super-img"><a href="#dump-super-img" class="headerlink" title="dump super img"></a>dump super img</h3><p>如果需要查看super.img里包含哪些img, 其格式是怎样的, 可以使用lpdump工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ./lpdump ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4</span></span><br><span class="line">Metadata version: 10.0</span><br><span class="line">Metadata size: 592 bytes</span><br><span class="line">Metadata max size: 65536 bytes</span><br><span class="line">Metadata slot count: 2</span><br><span class="line">Partition table:</span><br><span class="line">------------------------</span><br><span class="line">  Name: system</span><br><span class="line">  Group: qti_dynamic_partitions</span><br><span class="line">  Attributes: readonly</span><br><span class="line">  Extents:</span><br><span class="line">    0 .. 5716647 linear super 2048</span><br><span class="line">------------------------</span><br><span class="line">  Name: product</span><br><span class="line">  Group: qti_dynamic_partitions</span><br><span class="line">  Attributes: readonly</span><br><span class="line">  Extents:</span><br><span class="line">    0 .. 916055 linear super 5720064</span><br><span class="line">------------------------</span><br><span class="line">  Name: vendor</span><br><span class="line">  Group: qti_dynamic_partitions</span><br><span class="line">  Attributes: readonly</span><br><span class="line">  Extents:</span><br><span class="line">    0 .. 2410687 linear super 6637568</span><br><span class="line">...</span><br><span class="line">------------------------</span><br><span class="line">Block device table:</span><br><span class="line">------------------------</span><br><span class="line">  Partition name: super</span><br><span class="line">  First sector: 2048</span><br><span class="line">  Size: 9126805504 bytes</span><br><span class="line">  Flags: none</span><br><span class="line">------------------------</span><br><span class="line">Group table:</span><br><span class="line">------------------------</span><br><span class="line">  Name: default</span><br><span class="line">  Maximum size: 0 bytes</span><br><span class="line">  Flags: none</span><br><span class="line">------------------------</span><br><span class="line">  Name: qti_dynamic_partitions</span><br><span class="line">  Maximum size: 9126805504 bytes</span><br><span class="line">  Flags: none</span><br></pre></td></tr></table></figure>

<p>如果需要从super.img中解出其包含的分区镜像, 可以使用lpunpack工具</p>
<ul>
<li>lpunpack [-p partition_name] SUPER_IMAGE [OUTPPUT_DIR]， -p后面跟要取出的分区名，若不指定，都会取出*</li>
</ul>
<h3 id="解出system-img"><a href="#解出system-img" class="headerlink" title="解出system.img"></a>解出system.img</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./lpunpack -p system ~/Downloads/umi_images_1.2.2_20191021.0000.00_10.0_cn/images/super.img_ext4   unpack</span><br><span class="line">[~/work_space/v10-q-umi/out/host/linux-x86/bin/unpack] - [五 11月 15, 12:51]</span><br><span class="line"><span class="meta prompt_">[$</span><span class="language-bash">] -&gt; ll</span></span><br><span class="line">总用量 2845812</span><br><span class="line">drwxrwxr-x 2 mi mi       4096 11月 15 12:50 .</span><br><span class="line">drwxrwxr-x 3 mi mi       4096 11月 15 12:50 ..</span><br><span class="line">-rw-r--r-- 1 mi mi 2926923776 11月 15 12:51 system.img</span><br></pre></td></tr></table></figure>
<p>解出的system.img即为原始的带文件系统的镜像, 可以直接挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看system.img镜像的文件系统类型</span></span><br><span class="line">file system.img</span><br><span class="line">mkdir system</span><br><span class="line">sudo mount -t &lt;文件系统类型&gt; system.img system</span><br></pre></td></tr></table></figure>





<h3 id="如上提到的工具"><a href="#如上提到的工具" class="headerlink" title="如上提到的工具"></a>如上提到的工具</h3><p>可以直接在打开动态分区的机型上编译对应的工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make simg2img lpdump lpunpack</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用ninja编译</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成目录</span></span><br><span class="line">out/host/linux-x86/bin</span><br></pre></td></tr></table></figure>

<p>也可以直接下载我这里编译好的(64位的)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E8%AE%BE%E5%A4%87%E4%B8%8A%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8B1217%E6%97%A0%E6%B3%95%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E8%AE%BE%E5%A4%87%E4%B8%8A%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8B1217%E6%97%A0%E6%B3%95%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">设备bootloader上锁状态下1217无法工作问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-10-12T18:15:54+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:10:37" itemprop="dateModified" datetime="2024-04-16T15:10:37+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%8A%A0%E5%AF%86/" itemprop="url" rel="index"><span itemprop="name">加密</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设备bootloader上锁状态下1217无法工作问题分析"><a href="#设备bootloader上锁状态下1217无法工作问题分析" class="headerlink" title="设备bootloader上锁状态下1217无法工作问题分析"></a>设备bootloader上锁状态下1217无法工作问题分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前面讲到r上6月份升级基线后, 因KM TA date support的升级导致recovery下无法正常使用解密服务.</p>
<p>当时的方案是配置recovery vbmeta区域的 prop <code>--prop com.android.build.boot.security_patch:2020-06-05</code><br>从而在bootimg_hdr不支持识别date 信息的情况下, 可以在reocovery模式下bootloader能够读到天的信息, 并传给KM TA.</p>
<h2 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h2><p>最近测试在复测该问题时, 发现手机bootloader上锁状态下, 无法执行1217功能. 因此需要重新分析下这个问题的原因.</p>
<h2 id="locked-状态下的调试"><a href="#locked-状态下的调试" class="headerlink" title="locked 状态下的调试"></a>locked 状态下的调试</h2><h3 id="debug-abl的方法"><a href="#debug-abl的方法" class="headerlink" title="debug abl的方法"></a>debug abl的方法</h3><h4 id="locked状态下的限制"><a href="#locked状态下的限制" class="headerlink" title="locked状态下的限制"></a>locked状态下的限制</h4><p>首先, 小米机器locked 状态有如下限制:</p>
<ol>
<li>不能使用fastboot烧录新的img, 即fastboot flash  &lt;partition.img&gt; 是不被允许的</li>
<li>不能使用fastboot erase 分区, 像<code>fastboot erase misc</code> 无法执行</li>
<li>locked状态切到unlocked状态, unlocked状态切到locked状态, 都会reboot 进recovery, 清除数据.</li>
</ol>
<p>上述限制或功能必须被禁用掉, 因为调试这个问题时, 本地打的调试(带logcat 和 adb shell)功能的在locked状态肯定会报<code>system has destroyed</code>, 其次经常需要debug abl, 烧分区的限制肯定要禁用掉, 不然每次烧录新的abl 都需要使用9008模式烧机, 非常麻烦. locked 切 unlocked状态, 或反之的情况清除数据的功能肯定要拿掉, 因为1217测的就是解主系统加密过的userdata分区, 如果在切换过程中把userdata擦了, 那就破坏了测试的前提. 第二条清misc也是必须的, 因为recovery如果无法正常启动, 出现<code>system has destroyed</code>, 可以通过清misc, 启动到主系统把recovery恢复回来.</p>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>去除locked状态下对fastboot flash &#x2F; fastboot erase 和 切换locked unlocked 对userdata数据的操作</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/#/c/22341/">http://gerrit.bsp.xiaomi.srv/#/c/22341/</a></p>
<h3 id="locked状态下让avb校验失败的recovery成功启动起来"><a href="#locked状态下让avb校验失败的recovery成功启动起来" class="headerlink" title="locked状态下让avb校验失败的recovery成功启动起来"></a>locked状态下让avb校验失败的recovery成功启动起来</h3><blockquote>
<p>注意不能修改avb校验完的状态, 保持最小变量原则</p>
</blockquote>
<h4 id="change-1"><a href="#change-1" class="headerlink" title="change"></a>change</h4><p>即将导向<code>system has destroyed</code>的入口破坏掉</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/22334">http://gerrit.bsp.xiaomi.srv/22334</a></p>
<h4 id="本地recovery调试1217的方法"><a href="#本地recovery调试1217的方法" class="headerlink" title="本地recovery调试1217的方法"></a>本地recovery调试1217的方法</h4><p>本地编译userdebug版本的recovery即可.</p>
<ol>
<li>将上述change合入后, 编译abl, make aboot或者使用ninja, 注意最后abl一定要通过secureboot签名</li>
<li>locked上锁状态可以先使用解锁工具解锁, 再通过fastboot flash abl abl.elf 烧录locked 状态修改过的abl, 然后再使用fastboot oem lock上锁.</li>
<li>上锁完后, fastboot flash recovery 本地的recovery.img.</li>
<li>fastboot reboot recovery</li>
<li>使用下面的命令, 查看df -h的结果中是否有userdata, vold的输出的log是什么, 如果begin操作报错, 说明keymaster 返回了错误</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root; adb shell mv /system/bin/recovery  /tmp/; adb shell touch /system/bin/recovery; adb shell /tmp/recovery --factory_test_reset&amp;; sleep 6; adb shell df -h; adb logcat -s vold;</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过之前修改recovery 打包写入avb prop的方法已经可以使recovery在unlocked模式下1217正常工作. 而locked状态下却不行. 变量只有一个就是locked状态和unlocked状态.</p>
<p>先根据log定位下初步原因, 测试开始提供的log中只有recovery打出的部分信息:</p>
<p>recovery 重启, reason&#x3D; fs_mgr_mount_all</p>
<p>根据串口log的信息, 首先可以判定是如下情形:</p>
<ol>
<li>主系统bcb (reason –factory_test_reset) -&gt;2.  recovery启动(模式为1217)-&gt; 3. recovery重启(模式变为fs_mgr_mount_all)</li>
</ol>
<p>在第2步1217的执行步骤中触发了 RebootRecovery(fs_mgr_mount_all)的命令, 查看代码, 最终定位到</p>
<p><code>mount_all miui_factoryreset.fstab --late</code>时 init 在执行<code>vdc mountFstab /dev/block/bootdevice/by-name/userdata /data</code>失败后执行了上述命令, 所以需要进一步的log判断为什么这个vdc 的操作失败了.</p>
<p>根据前面debug locked 状态下recovery的方法, 最终可以在locked状态下启动本地带调试版本的recovery</p>
<p>得到的log如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">01-01 01:10:19.148   630   630 D vold    : metadata_key_dir/key: /metadata/vold/metadata_encryption/key</span><br><span class="line">01-01 01:10:19.149   630   630 I vold    : List of Keymaster HALs found:</span><br><span class="line">01-01 01:10:19.149   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.150   630   630 D vold    : Computing HMAC with params &#123; (seed: 54483455460602eb1254138a502eea6249c665fd8feebff883464d797d9f, nonce: 3f7f4c10a7eaf94e91f869e10f3f1ca1d576596d8291933b9c5305dfd90) &#125;</span><br><span class="line">01-01 01:10:19.150   630   630 D vold    : Computing HMAC for Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.152   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.154   630   630 D vold    : Key exists, using: /metadata/vold/metadata_encryption/key</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : List of Keymaster HALs found:</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : Keymaster HAL #1: Keymaster HAL: 4 from QTI SecurityLevel: TRUSTED_ENVIRONMENT HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.156   630   630 I vold    : Using Keymaster HAL: 4 from QTI for encryption.  Security level: TRUSTED_ENVIRONMENT, HAL: android.hardware.keymaster@4.1::IKeymasterDevice/default</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: Begin send cmd failed</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: ret: 0</span><br><span class="line">01-01 01:10:19.161   637   637 E KeyMasterHalDevice: resp-&gt;status: -33</span><br><span class="line">01-01 01:10:19.161   630   630 E vold    : begin failed, code -33</span><br><span class="line">01-01 01:10:19.148     0     0 D vdc     : Waited 0ms for vold</span><br><span class="line">01-01 01:10:19.161     0     0 E vdc     : Command: cryptfs mountFstab /dev/block/bootdevice/by-name/userdata /data Failed: Status(-8, EX_SERVICE_SPECIFIC): &#x27;0: &#x27;</span><br></pre></td></tr></table></figure>

<p>keymaster返回-33的错误导致了这样的表现.</p>
<p>根据之前对abl的分析, 这个大概率与abl传给KM TA的参数有关.</p>
<p>搜索代码, 最终定位到</p>
<p>1. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set Boot State */</span></span><br><span class="line">BootStateReq.CmdId = KEYMASTER_SET_BOOT_STATE;</span><br><span class="line">BootStateReq.Version = <span class="number">0</span>;</span><br><span class="line">BootStateReq.Size = <span class="keyword">sizeof</span> (BootStateReq.BootState);</span><br><span class="line">BootStateReq.Offset =</span><br><span class="line">    (UINT8 *)&amp;BootStateReq.BootState - (UINT8 *)&amp;BootStateReq;</span><br><span class="line">BootStateReq.BootState.Color = BootState-&gt;Color;</span><br><span class="line">BootStateReq.BootState.IsUnlocked = BootState-&gt;IsUnlocked;</span><br><span class="line">BootStateReq.BootState.SystemSecurityLevel = BootState-&gt;SystemSecurityLevel;</span><br><span class="line">BootStateReq.BootState.SystemVersion = BootState-&gt;SystemVersion;</span><br><span class="line">CopyMem (BootStateReq.BootState.PublicKey, BootStateDigest,</span><br><span class="line">         AVB_SHA256_DIGEST_SIZE);</span><br><span class="line"></span><br><span class="line">DEBUG ((EFI_D_ERROR, <span class="string">&quot;KeyMasterStartApp: bootstate digest: &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s\n&quot;</span>, BootStateDigest));</span><br><span class="line"></span><br><span class="line">Status = Handle.QseeComProtocol-&gt;QseecomSendCmd (</span><br><span class="line">    Handle.QseeComProtocol, Handle.AppId, (UINT8 *)&amp;BootStateReq,</span><br><span class="line">    <span class="keyword">sizeof</span> (BootStateReq), (UINT8 *)&amp;BootStateRsp, <span class="keyword">sizeof</span> (BootStateRsp));</span><br></pre></td></tr></table></figure>

<p>debug分析这一过程发现locked状态下, 只有color是orange时可以让recovery在调用keymaster begin解密经主系统加密的userdata时可以正常返回.</p>
<p>而如果userdata没有通过主系统的加密, 即在recovery下先恢复出厂设置, 再对userdata加密时, color是green情况下, 也可以正常调用keymaster,没有返回错误, 而在recovery下加密userdata完成后, 再启动到主系统, 主系统会报fs_mgr_mount_all的错误.</p>
<p>通过上述现象, 可以推测 加密userdata相当于上层keymaster初始化, 使用当时的环境去加密的数据, 而换了环境之后, 再去解密, 由于环境的变化, 导致keymaster无法校验成功, 所以begin返回了invalid blob(-33), 而这个<code>环境</code>是什么, 通过分析BootState的字段在recovery和主系统下的区别, 只有<code>BootStateDigest</code>是值得怀疑的.</p>
<h2 id="BootStateDigest即UserData-PublicKey的分析"><a href="#BootStateDigest即UserData-PublicKey的分析" class="headerlink" title="BootStateDigest即UserData-&gt;PublicKey的分析"></a>BootStateDigest即UserData-&gt;PublicKey的分析</h2><p>上一步怀疑这个字段有问题后, 需要分析recovery模式和主系统下这个字段的数据来源.</p>
<p>最终发现新基线升级后, recovery的avb校验模式变成了只校验recovery分区自己, 而主系统是校验 vbmeta boot dtbo vbmeta_system. 而主系统这个字段最终来自vbmeta分区的public key. 而recovery的这个字段并没有赋值.</p>
<p>recovery模式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( (!Info-&gt;MultiSlotBoot) ||</span><br><span class="line">         IsDynamicPartitionSupport ()) &amp;&amp;</span><br><span class="line">         (Info-&gt;BootIntoRecovery &amp;&amp;</span><br><span class="line">         !IsBuildUseRecoveryAsBoot ())) &#123;</span><br><span class="line">    <span class="comment">// 非ab机型</span></span><br><span class="line">  <span class="keyword">if</span> (!Info-&gt;MultiSlotBoot) &#123;</span><br><span class="line">      DEBUG ((EFI_D_ERROR, <span class="string">&quot;flag AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION\n&quot;</span>));</span><br><span class="line">      VerifyFlags = VerifyFlags | AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只加载recovery分区</span></span><br><span class="line">  AddRequestedPartition (RequestedPartitionAll, IMG_RECOVERY);</span><br><span class="line">  NumRequestedPartition += <span class="number">1</span>;</span><br><span class="line">  Result = avb_slot_verify (Ops, (CONST CHAR8 *CONST *)RequestedPartition,</span><br><span class="line">             SlotSuffix, VerifyFlags, VerityFlags, &amp;SlotData);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>上面怀疑recovery模式和主系统下abl传给KM TA的摘要是不同的, 那可以想到将vbmeta的public key 填充到 UserData-&gt;PublicKey, 下发给KM TA 是否可以解决locked状态下recovery无法使用keymaster解密经主系统加密的数据.</p>
<p>方案如下:</p>
<p><a target="_blank" rel="noopener" href="http://gerrit.bsp.xiaomi.srv/#/c/22338/">http://gerrit.bsp.xiaomi.srv/#/c/22338/</a></p>
<p>只有非ab机型进入recovery情况下, 即<code>AVB_SLOT_VERIFY_FLAGS_NO_VBMETA_PARTITION</code> flag的作用范围内, 在avb verify完recovery分区后, 再avb verify下vbmeta分区, 目的是为了让其覆盖<code>ops-&gt;user_data</code>段, 而传进<code>load_and_verify_vbmeta</code>的参数需要重新设定, 因为原先的参数很多都是全局或影响avb verify recovery结果的指针, 我们这里只能覆盖<code>ops-&gt;user_data</code>段, 不能对其他段产生影响. 同时还需要对flag 重新置位, 绕开vbmeta相关的检查, 使得可以成功load vbmeta的public key, 并将其赋给<code>ops-&gt;user_data</code>段.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BOOLEAN IsUserKey;</span><br><span class="line">    BOOLEAN IsMultiSlot;</span><br><span class="line">    UINTN PublicKeyLen;</span><br><span class="line">    CHAR8 PublicKey[MAX_USER_KEY_SIZE];</span><br><span class="line">&#125; AvbOpsUserData;</span><br></pre></td></tr></table></figure>

<p>重新测试后, 上述patch有效, locked下recovery中可以正常进行1217功能.</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>locked状态下, 主系统开机后, 执行1217, 正常reboot到recovery中进行清数据的操作, 重启回主系统下, &#x2F;data&#x2F;miui&#x2F;app下内容保留</li>
<li>locked状态下, fastboot flash 本地编的recovery, fastboot reboot recovery后, 应该报<code>system has destroyed</code></li>
<li>unlocked 状态下, 无论是本地编的recovery还是线刷包版本的recovery, 都可以正常进行1217功能</li>
</ol>
<blockquote>
<p>验证时, unlocked状态切换到locked状态, 或反之的情况, 切换过程中都需要进recovery wipe data, 擦完重新开机进主系统, 保证数据要重新经主系统初始化加密一次.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/OTA%E7%9B%B8%E5%85%B3/%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Android 加密方案整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-10-12T18:15:54+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:09:26" itemprop="dateModified" datetime="2024-04-16T15:09:26+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%8A%A0%E5%AF%86/" itemprop="url" rel="index"><span itemprop="name">加密</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-加密方案整理"><a href="#1-加密方案整理" class="headerlink" title="1. 加密方案整理"></a>1. 加密方案整理</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h2><p>Android上加密方案分为全磁盘加密(<code>FDE</code>)&#x2F;文件加密(<code>FBE</code>)&#x2F;元数据加密(<code>METADATA</code>)<br>均是针对userdata分区进行加密, 与其他分区并无关系.<br>本篇主要介绍下这三种加密方式硬件加密的实现框架</p>
<h2 id="1-2-判断机器采用何种加密方式"><a href="#1-2-判断机器采用何种加密方式" class="headerlink" title="1.2. 判断机器采用何种加密方式"></a>1.2. 判断机器采用何种加密方式</h2><p>最直观的方式是可以通过分区表<code>fstab</code>来区分<br>未加密&#x2F;fde加密&#x2F;fbe加密&#x2F;metadata加密</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,data=ordered,noauto_da_alloc     wait,check,encryptable=footer</span><br><span class="line">/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard latemount,wait,check,fileencryption=ice,wrappedkey,quota,reservedsize=128M</span><br><span class="line">/dev/block/bootdevice/by-name/userdata     /data           ext4    noatime,nosuid,nodev,barrier=1,noauto_da_alloc,discard latemount,wait,check,fileencryption=ice,wrappedkey,keydirectory=/metadata/vold/metadata_encryption,quota,reservedsize=128M</span><br></pre></td></tr></table></figure>

<p>当前版本中最常见的是fbe加密的机型.</p>
<p>代码中判断是否加密:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StorageManager.isEncrypted()</span><br><span class="line">StorageManager.isFileEncryptedNativeOnly()</span><br><span class="line">StorageManager.isBlockEncrypted()</span><br></pre></td></tr></table></figure>

<p>native 层多是通过FstabEntry来判断是何种加密方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">should_use_metadata_encryption</span><span class="params">(<span class="type">const</span> FstabEntry&amp; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !entry.key_dir.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">           (entry.fs_mgr_flags.file_encryption || entry.fs_mgr_flags.force_fde_or_fbe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬件加密的启用, 其中fbe机型和metadata机型是用<code>fileencryption=ice</code>控制的(限于高通产品), 而fbe和metadata加密方式的不同是看<code>keydirectory=</code>是否为空</p>
<h2 id="1-3-硬件加密实现策略"><a href="#1-3-硬件加密实现策略" class="headerlink" title="1.3. 硬件加密实现策略"></a>1.3. 硬件加密实现策略</h2><p>首先跟着<code>fileencryption=ice</code>往下看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">autoactivate on</span><br><span class="line">init-&gt;vold: initUser0</span><br><span class="line">vold-&gt;vold: fscrypt_init_user0</span><br><span class="line">vold-&gt;vold: fscrypt_prepare_user_storage</span><br><span class="line">vold-&gt;vold: get_data_file_encryption_modes(&amp;de_ref|&amp;ce_ref);</span><br><span class="line">note down: key_ref-&gt;contents_mode = entry-&gt;file_contents_mode;</span><br><span class="line">vold--&gt;init: return init_user0</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">autoactivate on</span><br><span class="line">StorageManagerService-&gt;vold: prepareUserStorage</span><br><span class="line">vold-&gt;vold: fscrypt_prepare_user_storage</span><br><span class="line">vold-&gt;vold: get_data_file_encryption_modes(&amp;de_ref|&amp;ce_ref);</span><br><span class="line">note right: key_ref-&gt;contents_mode = entry-&gt;file_contents_mode;</span><br><span class="line">vold--&gt;StorageManagerService: return prepareUserStorage</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>对于FBE方案来说, Android标准方案使用<code>ice</code>来控制是否是硬件加密</p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/security/encryption/file-based">文件加密 android developer</a><br><a target="_blank" rel="noopener" href="https://source.android.com/security/encryption/metadata">metadata加密 android developer</a></p>
<blockquote>
<p>为了支持当前的元数据加密，您的硬件必须支持使用内嵌加密引擎进行文件级加密。fstab.hardware 中的用户数据分区的 <code>fileencryption=ice</code> 指令指明了这一点。</p>
</blockquote>
<blockquote>
<p>通过将 fileencryption&#x3D;contents_encryption_mode[:filenames_encryption_mode] 标记添加到 userdata 分区最后一列的 fstab 行中，可以启用 FBE。contents_encryption_mode 参数定义用于文件内容加密的算法，filenames_encryption_mode 参数定义用于文件名加密的算法。 contents_encryption_mode 只能是 aes-256-xts。 filenames_encryption_mode 有两个可能的值：aes-256-cts 和 aes-256-heh。如果未指定 filenames_encryption_mode，则使用 aes-256-cts 值。</p>
</blockquote>
<p>^61db89</p>
<h2 id="1-4-硬件加密底层实现"><a href="#1-4-硬件加密底层实现" class="headerlink" title="1.4. 硬件加密底层实现"></a>1.4. 硬件加密底层实现</h2><h3 id="1-4-1-qcom实现"><a href="#1-4-1-qcom实现" class="headerlink" title="1.4.1. qcom实现"></a>1.4.1. qcom实现</h3><p>先看下metadata加密, metadata加密方案相对FBE来说, 在fbe的基础上又对文件系统的元数据进行了加密</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_KEY_TARGET_TYPE <span class="string">&quot;default-key&quot;</span></span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">read_key</span>(*data_rec, needs_encrypt, &amp;key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">get_number_of_sectors</span>(data_rec-&gt;blk_device, &amp;nr_sec)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">create_crypto_blk_dev</span>(kDmNameUserdata, nr_sec, DEFAULT_KEY_TARGET_TYPE,</span><br><span class="line">                               <span class="built_in">default_key_params</span>(blk_device, key), &amp;crypto_blkdev))</span><br></pre></td></tr></table></figure>

<p>上述创建dm设备时, 传入的tgt-&gt;target_type是<code>default-key</code>, 对应于device-mapper框架来说, 最终找到的插件实现是<code>dm-default-key.c</code></p>
<p>该层的代码在kernel md层<br>kernel&#x2F;msm-4.14&#x2F;drivers&#x2F;md&#x2F;dm-default-key.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">target_type</span> <span class="title">default_key_target</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;default-key&quot;</span>,</span><br><span class="line">    .version = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    .module = THIS_MODULE,</span><br><span class="line">    .ctr    = default_key_ctr,</span><br><span class="line">    .dtr    = default_key_dtr,</span><br><span class="line">    .<span class="built_in">map</span>    = default_key_map,</span><br><span class="line">    .status = default_key_status,</span><br><span class="line">    .prepare_ioctl = default_key_prepare_ioctl,</span><br><span class="line">    .iterate_devices = default_key_iterate_devices,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于dm设备的转发, 这里不再详细分析. 感兴趣的可以再跟着流程看下.<br>这里重点说下map函数, 在设置好dm规则后, 用户空间命令通过ioctl调用table_load函数，该函数根据用户空间传来的参数构建指定mapped device的映射表和所映射的target device。该函数先构建相应的dm_table、dm_target结构，再调用dm-table.c中的dm_table_add_target(populate_table—&gt;dm_table_add_target)函数根据用户传入的参数初始化这些结构，并且根据参数所指定的target类型，调用相应的target类型的构建函数ctr在内存中构建target device对应的结构，然后再根据所建立的dm_target结构更新dm_table中维护的B树。上述过程完毕后，再将建立好的dm_table添加到mapped device的全局hash表对应的hash_cell结构中。</p>
<p>设置io转发, 一个是通过dm create 时初始设置的<code>dm_wq_work</code>后台线程执行的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ioctl</span>(dm_fd.<span class="built_in">get</span>(), DM_DEV_CREATE, io)</span><br><span class="line">dev_create -&gt; <span class="built_in">dm_create</span>(minor, **result) -&gt; <span class="built_in">alloc_dev</span>(minor) -&gt;</span><br><span class="line"><span class="built_in">INIT_WORK</span>(&amp;md-&gt;work, dm_wq_work);</span><br></pre></td></tr></table></figure>

<p>write_back时, 调用queue_io, 或dm设备处于suspend时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">queue_io</span><span class="params">(<span class="keyword">struct</span> mapped_device *md, <span class="keyword">struct</span> bio *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;md-&gt;deferred_lock, flags);</span><br><span class="line">    <span class="built_in">bio_list_add</span>(&amp;md-&gt;deferred, bio);</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;md-&gt;deferred_lock, flags);</span><br><span class="line">    <span class="built_in">queue_work</span>(md-&gt;wq, &amp;md-&gt;work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一条路径是通过 <code>dm_setup_md_queue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> DM_TYPE_BIO_BASED:</span><br><span class="line">    <span class="keyword">case</span> DM_TYPE_DAX_BIO_BASED:</span><br><span class="line">        <span class="built_in">dm_init_normal_md_queue</span>(md);</span><br><span class="line">        <span class="built_in">blk_queue_make_request</span>(md-&gt;queue, dm_make_request);</span><br><span class="line">dm_make_request-&gt; __dm_make_request(q, bio, __split_and_process_bio); -&gt; __send_empty_flush | __split_and_process_non_flush </span><br><span class="line">-&gt; __clone_and_map_data_bio | __send_duplicate_bios -&gt; __map_bio</span><br></pre></td></tr></table></figure>

<p>其中 <code>__split_and_process_bio</code>可以了解一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapped_device指向 映射的dm设备, map为映射规则</span></span><br><span class="line"><span class="comment">// split a bio into clones and submit them to the targets</span></span><br><span class="line"><span class="type">static</span> <span class="type">blk_qc_t</span> __split_and_process_bio(<span class="keyword">struct</span> mapped_device *md,</span><br><span class="line">                    <span class="keyword">struct</span> dm_table *map, <span class="keyword">struct</span> bio *bio)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">clone_info</span> ci;</span><br><span class="line">    <span class="type">blk_qc_t</span> ret = BLK_QC_T_NONE;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">blk_queue_split</span>(md-&gt;queue, &amp;bio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_clone_info</span>(&amp;ci, md, map, bio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bio-&gt;bi_opf &amp; REQ_PREFLUSH) &#123;</span><br><span class="line">        ci.bio = &amp;ci.io-&gt;md-&gt;flush_bio;</span><br><span class="line">        ci.sector_count = <span class="number">0</span>;</span><br><span class="line">        error = __send_empty_flush(&amp;ci);</span><br><span class="line">        <span class="comment">/* dec_pending submits any data associated with flush */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">bio_op</span>(bio) == REQ_OP_ZONE_RESET) &#123;</span><br><span class="line">        ci.bio = bio;</span><br><span class="line">        ci.sector_count = <span class="number">0</span>;</span><br><span class="line">        error = __split_and_process_non_flush(&amp;ci);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ci.bio = bio;</span><br><span class="line">        ci.sector_count = <span class="built_in">bio_sectors</span>(bio);</span><br><span class="line">        <span class="keyword">while</span> (ci.sector_count &amp;&amp; !error) &#123;</span><br><span class="line">            error = __split_and_process_non_flush(&amp;ci);</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;bio_list &amp;&amp; ci.sector_count &amp;&amp; !error) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">bio</span> *b = <span class="built_in">bio_split</span>(bio, <span class="built_in">bio_sectors</span>(bio) - ci.sector_count,</span><br><span class="line">                              GFP_NOIO, &amp;md-&gt;queue-&gt;bio_split);</span><br><span class="line">                ci.io-&gt;orig_bio = b;</span><br><span class="line">                <span class="built_in">bio_chain</span>(b, bio);</span><br><span class="line">                ret = <span class="built_in">generic_make_request</span>(bio);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* drop the extra reference count */</span></span><br><span class="line">    <span class="built_in">dec_pending</span>(ci.io, <span class="built_in">errno_to_blk_status</span>(error));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Select the correct strategy for processing a non-flush bio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __split_and_process_non_flush(<span class="keyword">struct</span> clone_info *ci)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bio</span> *bio = ci-&gt;bio;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_target</span> *ti;</span><br><span class="line">    <span class="type">unsigned</span> len;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"><span class="comment">// 找到target_device</span></span><br><span class="line">    ti = <span class="built_in">dm_table_find_target</span>(ci-&gt;map, ci-&gt;sector);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dm_target_is_valid</span>(ti))</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(__process_abnormal_io(ci, ti, &amp;r)))</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bio_op</span>(bio) == REQ_OP_ZONE_REPORT)</span><br><span class="line">        len = ci-&gt;sector_count;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = <span class="built_in">min_t</span>(<span class="type">sector_t</span>, <span class="built_in">max_io_len</span>(ci-&gt;sector, ti),</span><br><span class="line">                ci-&gt;sector_count);</span><br><span class="line"></span><br><span class="line">    r = __clone_and_map_data_bio(ci, ti, ci-&gt;sector, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    ci-&gt;sector += len;</span><br><span class="line">    ci-&gt;sector_count -= len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __clone_and_map_data_bio(<span class="keyword">struct</span> clone_info *ci, <span class="keyword">struct</span> dm_target *ti,</span><br><span class="line">                    <span class="type">sector_t</span> sector, <span class="type">unsigned</span> *len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bio</span> *bio = ci-&gt;bio;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_target_io</span> *tio;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    tio = <span class="built_in">alloc_tio</span>(ci, ti, <span class="number">0</span>, GFP_NOIO);</span><br><span class="line">    tio-&gt;len_ptr = len;</span><br><span class="line">    r = <span class="built_in">clone_bio</span>(tio, bio, sector, *len);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free_tio</span>(tio);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>) __map_bio(tio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">blk_qc_t</span> __map_bio(<span class="keyword">struct</span> dm_target_io *tio)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">sector_t</span> sector;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bio</span> *clone = &amp;tio-&gt;clone;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_io</span> *io = tio-&gt;io;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mapped_device</span> *md = io-&gt;md;</span><br><span class="line">    <span class="comment">// 取出上面封装的target_device的结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dm_target</span> *ti = tio-&gt;ti;</span><br><span class="line">    <span class="type">blk_qc_t</span> ret = BLK_QC_T_NONE;</span><br><span class="line"></span><br><span class="line">    clone-&gt;bi_end_io = clone_endio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Map the clone.  If r == 0 we don&#x27;t need to do</span></span><br><span class="line"><span class="comment">     * anything, the target has assumed ownership of</span></span><br><span class="line"><span class="comment">     * this io.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;io-&gt;io_count);</span><br><span class="line">    sector = clone-&gt;bi_iter.bi_sector;</span><br><span class="line">    <span class="comment">// 调用插件的map函数. ti为dm_target, clone为复制的bio</span></span><br><span class="line">    r = ti-&gt;type-&gt;<span class="built_in">map</span>(ti, clone);</span><br><span class="line">    <span class="keyword">switch</span> (r) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// map正常执行的话, 返回DM_MAPIO_REMAPPED</span></span><br><span class="line">    <span class="keyword">case</span> DM_MAPIO_REMAPPED:</span><br><span class="line">        <span class="comment">/* the bio has been remapped so dispatch it */</span></span><br><span class="line">        <span class="built_in">trace_block_bio_remap</span>(clone-&gt;bi_disk-&gt;queue, clone,</span><br><span class="line">                      <span class="built_in">bio_dev</span>(io-&gt;orig_bio), sector);</span><br><span class="line">        <span class="keyword">if</span> (md-&gt;type == DM_TYPE_NVME_BIO_BASED)</span><br><span class="line">            ret = <span class="built_in">direct_make_request</span>(clone);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 往下层转发</span></span><br><span class="line">            ret = <span class="built_in">generic_make_request</span>(clone);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述调用, 最终起到封装bio的目的. 复制了一份bio到clone中, 找到dm-target的type(插件), 用其注册的map函数封装clone, clone为指针, map函数会修改其值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ti封装的private为其初始化时填入的值</span></span><br><span class="line"><span class="comment">// Construct a default-key mapping: &lt;mode&gt; &lt;key&gt; &lt;dev_path&gt; &lt;start&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">default_key_ctr</span><span class="params">(<span class="keyword">struct</span> dm_target *ti, <span class="type">unsigned</span> <span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ti-&gt;<span class="keyword">private</span> = dkc;</span><br><span class="line">    <span class="built_in">hex2bin</span>(dkc-&gt;key.raw, argv[<span class="number">1</span>], key_size);</span><br><span class="line">    <span class="comment">// 根据传入的path 找到其 target_device, 就是往dkc的dev里填入 bdev, 最后ti-&gt;private准备完成</span></span><br><span class="line">    <span class="built_in">dm_get_device</span>(ti, argv[<span class="number">2</span>], <span class="built_in">dm_table_get_mode</span>(ti-&gt;table),</span><br><span class="line">                &amp;dkc-&gt;dev);</span><br><span class="line">    <span class="built_in">sscanf</span>(argv[<span class="number">3</span>], <span class="string">&quot;%llu%c&quot;</span>, &amp;tmp, &amp;dummy)</span><br><span class="line">    dkc-&gt;start = tmp;</span><br><span class="line">    <span class="comment">// 必须支持硬件加密?</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">blk_queue_inlinecrypt</span>(<span class="built_in">bdev_get_queue</span>(dkc-&gt;dev-&gt;bdev))) &#123;</span><br><span class="line">        ti-&gt;error = <span class="string">&quot;Device does not support inline encryption&quot;</span>;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">default_key_map</span><span class="params">(<span class="keyword">struct</span> dm_target *ti, <span class="keyword">struct</span> bio *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">default_key_c</span> *dkc = ti-&gt;<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">// 设置clone的block_device(target_device), 最后通过generic_make_request 往下层转发</span></span><br><span class="line">    <span class="built_in">bio_set_dev</span>(bio, dkc-&gt;dev-&gt;bdev);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bio_sectors</span>(bio)) &#123;</span><br><span class="line">        <span class="comment">// bio来自于mapped_device需要根据映射关系转换成target_device的真实的扇区号</span></span><br><span class="line">        bio-&gt;bi_iter.bi_sector = dkc-&gt;start +</span><br><span class="line">            <span class="built_in">dm_target_offset</span>(ti, bio-&gt;bi_iter.bi_sector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bio-&gt;bi_crypt_key &amp;&amp; !bio-&gt;bi_crypt_skip)</span><br><span class="line">        <span class="comment">// 最重要的信息, 为bio带上了密钥信息</span></span><br><span class="line">        bio-&gt;bi_crypt_key = &amp;dkc-&gt;key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DM_MAPIO_REMAPPED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见metadata加密使用dm设备的目的, 就是为bio加上密钥信息, 那这个密钥信息是在哪里用的呢, 而且<code>dm-default-key.c</code>里的实现里明确提示了需要硬件支持.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">default_key_iterate_devices</span><span class="params">(<span class="keyword">struct</span> dm_target *ti,</span></span></span><br><span class="line"><span class="params"><span class="function">                       iterate_devices_callout_fn fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">default_key_c</span> *dkc = ti-&gt;<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">// fn为queue_supports_inline_encryption函数, 所以最终是通过找到target_device查看是否支持硬件加密</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn</span>(ti, dkc-&gt;dev, dkc-&gt;start, ti-&gt;len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">queue_supports_inline_encryption</span><span class="params">(<span class="keyword">struct</span> dm_target *ti,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">struct</span> dm_dev *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">sector_t</span> start, <span class="type">sector_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">request_queue</span> *q = <span class="built_in">bdev_get_queue</span>(dev-&gt;bdev);</span><br><span class="line">    <span class="keyword">return</span> q &amp;&amp; <span class="built_in">blk_queue_inlinecrypt</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否支持硬件加密是在初始化时指定的, 绕到block层了  对应于emmc和ufs, 分别走的mmc framework和scsi架构</span></span><br><span class="line"><span class="comment">// mmc core的实现  是在mmc_blk_alloc_req时做的</span></span><br><span class="line">    <span class="keyword">if</span> (host-&gt;inlinecrypt_support)</span><br><span class="line">        <span class="built_in">queue_flag_set_unlocked</span>(QUEUE_FLAG_INLINECRYPT, mq-&gt;queue);</span><br><span class="line"><span class="comment">// scsi中的实现</span></span><br><span class="line">    <span class="keyword">if</span> (shost-&gt;inlinecrypt_support)</span><br><span class="line">        <span class="built_in">queue_flag_set_unlocked</span>(QUEUE_FLAG_INLINECRYPT, q);</span><br></pre></td></tr></table></figure>

<p>所以上述硬件加密的信息应该是做在mmc框架层, 通过mmc框架与存储器件通信, 进行硬件加密</p>
<h3 id="1-4-2-scsi架构探寻"><a href="#1-4-2-scsi架构探寻" class="headerlink" title="1.4.2. scsi架构探寻"></a>1.4.2. scsi架构探寻</h3><h4 id="1-4-2-1-软件架构"><a href="#1-4-2-1-软件架构" class="headerlink" title="1.4.2.1. 软件架构"></a>1.4.2.1. 软件架构</h4><p>Linux kernel的驱动框架有两个要点:</p>
<ul>
<li>抽象硬件（硬件架构是什么样子，驱动框架就应该是什么样子）。</li>
<li>向“客户”提供使用该硬件的API（之前我们提到最多的客户是“用户空间的Application”，不过也有其它“客户”，例如内核空间的其它driver、其它framework）。</li>
</ul>
<p>先看kconfig</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">config SCSI_UFSHCD</span><br><span class="line">    tristate <span class="string">&quot;Universal Flash Storage Controller Driver Core&quot;</span></span><br><span class="line">    depends on SCSI &amp;&amp; SCSI_DMA</span><br><span class="line">    select PM_DEVFREQ</span><br><span class="line">    select DEVFREQ_GOV_SIMPLE_ONDEMAND</span><br><span class="line">    select NLS</span><br><span class="line">    ---help---</span><br><span class="line">    This selects the support <span class="keyword">for</span> UFS devices in Linux, <span class="function">say Y <span class="keyword">and</span> make</span></span><br><span class="line"><span class="function">      sure that you know the name of your UFS host <span class="title">adapter</span> <span class="params">(the card</span></span></span><br><span class="line"><span class="params"><span class="function">      inside your computer that <span class="string">&quot;speaks&quot;</span> the UFS protocol, also</span></span></span><br><span class="line"><span class="params"><span class="function">      called UFS Host Controller)</span>, because you will be asked <span class="keyword">for</span> it.</span></span><br><span class="line"><span class="function">      The <span class="keyword">module</span> will be called ufshcd.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      To compile <span class="keyword">this</span> driver as a <span class="keyword">module</span>, choose M here <span class="keyword">and</span> read</span></span><br><span class="line"><span class="function">      &lt;file:Documentation/scsi/ufs.txt&gt;.</span></span><br><span class="line"><span class="function">      However, do not compile this as a module if your root file system</span></span><br><span class="line"><span class="function">      (the one containing the directory /) is located on a UFS device.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">config SCSI_UFSHCD_PLATFORM</span></span><br><span class="line"><span class="function">    tristate <span class="string">&quot;Platform bus based UFS Controller support&quot;</span></span></span><br><span class="line"><span class="function">    depends on SCSI_UFSHCD</span></span><br><span class="line"><span class="function">    ---help---</span></span><br><span class="line"><span class="function">    This selects the UFS host controller support. Select this if</span></span><br><span class="line"><span class="function">    you have an UFS controller on Platform bus</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">config CRYPTO_DEV_QCOM_ICE</span></span><br><span class="line"><span class="function">    tristate <span class="string">&quot;Inline Crypto Module&quot;</span></span></span><br><span class="line"><span class="function">    default n</span></span><br><span class="line"><span class="function">    depends on BLK_DEV_DM</span></span><br><span class="line"><span class="function">    help</span></span><br><span class="line"><span class="function">      This driver supports Inline Crypto Engine for QTI chipsets, MSM8994</span></span><br><span class="line"><span class="function">      and later, to accelerate crypto operations for storage needs.</span></span><br><span class="line"><span class="function">      To compile this driver as a module, choose M here: the</span></span><br><span class="line"><span class="function">      module will be called ice.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">config SCSI_UFS_QCOM</span></span><br><span class="line"><span class="function">    tristate <span class="string">&quot;QCOM specific hooks to UFS controller platform driver&quot;</span></span></span><br><span class="line"><span class="function">    depends on SCSI_UFSHCD_PLATFORM &amp;&amp; ARCH_QCOM</span></span><br><span class="line"><span class="function">    select PHY_QCOM_UFS</span></span><br><span class="line"><span class="function">    select EXTCON</span></span><br><span class="line"><span class="function">    select EXTCON_STORAGE_CD_GPIO</span></span><br><span class="line"><span class="function">    help</span></span><br><span class="line"><span class="function">      This selects the QCOM specific additions to UFSHCD platform driver.</span></span><br><span class="line"><span class="function">      UFS host on QCOM needs some vendor specific configuration before</span></span><br><span class="line"><span class="function">      accessing the hardware which includes PHY configuration and vendor</span></span><br><span class="line"><span class="function">      specific registers.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      Select this if you have UFS controller on QCOM chipset.</span></span><br><span class="line"><span class="function">      If unsure, say N.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">config SCSI_UFS_QCOM_ICE</span></span><br><span class="line"><span class="function">    bool <span class="string">&quot;QCOM specific hooks to Inline Crypto Engine for UFS driver&quot;</span></span></span><br><span class="line"><span class="function">    depends on SCSI_UFS_QCOM &amp;&amp; CRYPTO_DEV_QCOM_ICE</span></span><br><span class="line"><span class="function">    help</span></span><br><span class="line"><span class="function">      This selects the QCOM specific additions to support Inline Crypto</span></span><br><span class="line"><span class="function">      Engine (ICE).</span></span><br><span class="line"><span class="function">      ICE accelerates the crypto operations and maintains the high UFS</span></span><br><span class="line"><span class="function">      performance.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      Select this if you have ICE supported for UFS on QCOM chipset.</span></span><br><span class="line"><span class="function">      If unsure, say N.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_ARCH_QCOM)</span>            += pfe/</span><br><span class="line">obj-<span class="variable">$(CONFIG_SCSI_UFSHCD)</span> += ufshcd-core.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SCSI_UFSHCD_PLATFORM)</span> += ufshcd-pltfrm.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_CRYPTO_DEV_QCOM_ICE)</span> += ice.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SCSI_UFS_QCOM_ICE)</span> += ufs-qcom-ice.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SCSI_UFS_QCOM)</span> += ufs-qcom.o</span><br></pre></td></tr></table></figure>

<p>从上述的依赖条件看, 主要是涉及到<code>ufs-qcom.c</code> 和  <code>ufs-qcom-ice.c</code>文件的分析</p>
<p>platform driver 是什么？<br>一个现实的Linux设备和驱动通常挂接在一种总线上，对于本身依附于PCI、USB、I2C、SPI等的设备而言，这自然不是问题，但是在<code>嵌入式系统</code>里面，SoC系统中<code>集成的独立的外设控制器</code>、挂接在<code>SoC内存空间的外设</code>等却不依附于此类总线。基于这个背景，Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform device,驱动称为platform driver。<br><strong>注意</strong>platform device并不是和字符设备，块设备和网络设备并列的概念，而是实现它们的一种方式。通过这种方式实现的就称为platform device。</p>
<p>platform 是一个虚拟的地址总线，相比 PCI、USB，它主要用于描述SOC上的片上资源。platform 所描述的资源有一个共同点：在CPU 的总线上直接取址。平台设备会分到一个名称（用在驱动绑定中）以及一系列诸如地址和中断请求号（IRQ）之类的资源。 ^39c29c</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanhe156/article/details/79062868">platform_driver开发</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> ufs_qcom_pltform = &#123;</span><br><span class="line">    .probe    = ufs_qcom_probe,</span><br><span class="line">    .remove    = ufs_qcom_remove,</span><br><span class="line">    .shutdown = ufshcd_pltfrm_shutdown,</span><br><span class="line">    .driver    = &#123;</span><br><span class="line">        .name    = <span class="string">&quot;ufshcd-qcom&quot;</span>,</span><br><span class="line">        .pm    = &amp;ufs_qcom_pm_ops,</span><br><span class="line">        <span class="comment">// 从设备数获取  &#123; .compatible = &quot;qcom,ufshc&quot;&#125;,</span></span><br><span class="line">        .of_match_table = <span class="built_in">of_match_ptr</span>(ufs_qcom_of_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module_platform_driver</span>(ufs_qcom_pltform);</span><br></pre></td></tr></table></figure>

<p>platform device的.prob函数中执行的是大致为四步：</p>
<ol>
<li>申请设备号</li>
<li>实体设备(如果是字符设备，就是cdev)初始化注册，添加填充好的file_operation</li>
<li>从pdev读出硬件资源</li>
<li>对硬件资源初始化，ioremap() ,request_irq()等操作</li>
</ol>
<p>platform device的.remove函数实现的是注销分配的各种资源。</p>
<p>driver的绑定是通过driver core自动完成的，完成driver和device的匹配后以后会自动执行<code>probe()</code>函数，如果函数执行成功，则driver和device就绑定在一起了，drvier和device匹配的方法有3种： ^a36448</p>
<ul>
<li><p>当一个设备注册的时候，他会在总线上寻找匹配的driver，platform device一般在系统启动很早的时候就注册了</p>
</li>
<li><p>当一个驱动注册[platform_driver_register()]的时候，他会<code>遍历所有总线上的设备来寻找匹配</code>，在启动的过程驱动的注册一般比较晚，或者在模块载入的时候<br> ^2bbbb2</p>
</li>
<li><p>当一个驱动注册[platform_driver_probe()]的时候， 功能上和使用platform_driver_register()是一样的，唯一的区别是它不能被以后其他的device probe了，也就是说这个driver只能和一个device绑定。</p>
<p>Platform device 和 Platform driver实际上是cpu总线可以直接寻址的设备和驱动，他们挂载在一个虚拟的总线platform_bus_type上，是一种bus-specific设备和驱动。与其他bus-specific驱动比如pci是一样的。他们都是将device和device_driver加了一个warpper产生，仔细看看platform_device就可以看到它必然包含一个device dev，而platform_driver也一样，它必然包含一个device_driver driver。<br>所有的设备通过bus_id挂在总线上，多个device可以共用一个driver，但是一个device不可以对应多个driver。驱动去注册时候会根据设备名寻找设备，没有设备会注册失败，注册的过程会通过probe来进行相应资源的申请，以及硬件的初始化，如果probe执行成功，则device和driver的绑定就成功了。设备注册的时候同样会在总线上寻找相应的驱动，如果找到他也会试图绑定，绑定的过程同样是执行probe。</p>
</li>
</ul>
<p>这里先带着问题看一下注册的过程:  (前面说到metadata加密必须支持硬件加密才可以)</p>
<p><code>shost-&gt;inlinecrypt_support</code>   这个赋值是哪来的呢?</p>
<p>搜了下代码, 是在这里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ufs_qcom_init</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba)</span> </span>&#123;</span><br><span class="line"><span class="comment">// err为0, 即支持硬件加密</span></span><br><span class="line">    err = <span class="built_in">ufs_qcom_ice_get_dev</span>(host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着ufs_qcom_init的初始化过程, 看下ufs_hba来自哪里<br>ufs_qcom_probe -&gt; ufshcd_pltfrm_init(pdev, &amp;ufs_hba_qcom_variant) -&gt; ufshcd_alloc_host(dev, &amp;hba) -&gt; host &#x3D; scsi_host_alloc(&amp;ufshcd_driver_template, sizeof(struct ufs_hba));</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ufshcd_alloc_host</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> ufs_hba **hba_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Scsi_Host</span> *host;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ufs_hba</span> *hba;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    host = <span class="built_in">scsi_host_alloc</span>(&amp;ufshcd_driver_template,</span><br><span class="line">                <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ufs_hba));</span><br><span class="line">    hba = <span class="built_in">shost_priv</span>(host);</span><br><span class="line">    hba-&gt;host = host;</span><br><span class="line">    hba-&gt;dev = dev;</span><br><span class="line">    *hba_handle = hba;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;hba-&gt;clk_list_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个调用直接跑到了scsi&#x2F;hosts.c中的<code>scsi_host_alloc</code>函数中. register a scsi host adapter instance. 这个函数的作用就是分配host端.<br>在scsi架构中,  系统初始化时会扫描platform总线，因此挂载其上的SCSI host adapter会被扫描到，并生成一个platform device。<br>扫描软件会为该platform device加载相应的驱动程序。加载SCSI host驱动时，其探测函数会初始化SCSI host，注册中断处理函数，最后调用scsi_scan_host函数扫描scsi host adapter所管理的所有scsi总线。<br>通常情况下，HBA驱动在系统中以模块形式加载。从而允许模块被卸载并重新加载，在该过程中SCSI扫描函数得以调用。通常，在卸载HBA驱动之前，SCSI设备的所有I&#x2F;O都应该停止，卸载文件系统，多路径服务应用也需停止。如果有代理或HBA应用帮助模块，也应当中止。<br>&#x2F;proc文件系统提供了可用SCSI设备的列表。如果系统中SCSI设备重新配置，那么所有这些改变通过echo &#x2F;proc接口反映到SCSI设备中。添加一个设备，主机，channel，target ID，以及磁盘设备的LUN编号会被添加到&#x2F;proc&#x2F;scsi&#x2F;，需指定scsi编号。</p>
<p>可见这里是将host纳入了scsi架构中, 后续只要访问到对应的host adapter, 可以通过host adapter与其匹配的driver进行通信.</p>
<p>这里列举一个加密过程的路径:<br>ufshcd_resume-&gt;ufshcd_reset_and_restore-&gt;ufshcd_detect_device-&gt;ufshcd_host_reset_and_restore-&gt;ufshcd_complete_requests-&gt;ufshcd_transfer_req_compl-&gt;__ufshcd_transfer_req_compl-&gt;ufshcd_vops_crypto_engine_cfg_end<br>ufshcd_pltfrm_init-&gt;ufshcd_init-&gt;INIT_DELAYED_WORK(&amp;hba-&gt;card_detect_work, ufshcd_card_detect_handler)-&gt;ufshcd_detect_device…</p>
<p><img src="/images/20191204223850725_1481056787.jpg" alt="v2-33d57d1aac13ec6a4e7f917e0a47bb69_1200x500"><br><img src="http://www.sysnote.org/2015/08/06/linux-io-stack/io-stack.png" alt="&quot;linux storage stack&quot;的图片搜索结果"><br>从之前的调度上看, 下发bio经过了device_mapper层, 通用块层即block层进行io调度, 使用各类调度算法合并bio到rq中, 最后下发bio到达scsi层, 在这一层有<code>single-queue layer</code>和<code>multi-queue layer</code>的区分.<br>其中<code>single-queue layer</code>是使用的<code>scsi_request_fn</code>进行io下发的, 而支持<code>multi-queue layer</code>的则是通过<code>blk_mq_ops</code>结构实现了11个函数, 提供了支持超时，轮询完成，请求初始化的命令, 而io的下发是通过<code>queue_rq</code>函数执行.<br>而ufs是支持<code>multi-queue layer</code>的, 这里可以大致了解下<code>mq_ops</code>的结构的使用过程</p>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/738449/">io流程</a></p>
<p>对于多队列结果, rq需要提前分配, 可以看下scsi_alloc_sdev函数, 这里涉及到一个<code>Disk Array Controller</code>,  gdth看起来是负责这块的.</p>
<blockquote>
<p>A disk array controller is a device which manages the physical disk drives and presents them to the computer as logical units.</p>
</blockquote>
<p>The disk array controller is made of up 3 important parts which play a key role in the controllers functioning and also show us indicators of storage I&#x2F;O bottlenecks. These are:</p>
<p>CPU that processes the data sent to the controller<br>I&#x2F;O port that includes:</p>
<ul>
<li>Back-end interface to establish communication with the storage disks</li>
<li>Front-end interface to <em>communicate with a computer’s host adapter</em></li>
<li>Software executed by the controller’s processor which also consumes the processor resources</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gdth_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filep)</span></span><br><span class="line">&#123;</span><br><span class="line">    gdth_ha_str *ha;</span><br><span class="line">    list_for_each_entry(ha, &amp;gdth_instances, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ha-&gt;sdev)</span><br><span class="line">            ha-&gt;sdev = scsi_get_host_dev(ha-&gt;shost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有ufshcd_init过程,<br>ufshcd_pltfrm_init -&gt; ufshcd_init -&gt; async_schedule(ufshcd_async_scan, hba); -&gt; ufshcd_async_scan -&gt; ufshcd_probe_hba(hba); -&gt; scsi_scan_host(hba-&gt;host); -&gt; async_schedule(do_scan_async, data); -&gt; do_scsi_scan_host -&gt; scsi_scan_host_selected -&gt; scsi_scan_channel -&gt; __scsi_scan_target -&gt; scsi_probe_and_add_lun -&gt; sdev &#x3D; scsi_alloc_sdev(starget, lun, hostdata); -&gt; sdev-&gt;request_queue &#x3D; scsi_mq_alloc_queue(sdev); | sdev-&gt;request_queue &#x3D; scsi_old_alloc_queue(sdev);</p>
<blockquote>
<p>定义了 <code>CONFIG_SCSI_MQ_DEFAULT</code>才走多队列模式</p>
</blockquote>
<p>这里还是看单队列模式  sdev-&gt;request_queue &#x3D; scsi_old_alloc_queue(sdev);<br>scsi_old_alloc_queue中绑定了rq相关的处理函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;request_fn = scsi_request_fn;</span><br></pre></td></tr></table></figure>

<p>读取一个文件的时候，陷入系统调用，先检查数据是否在缓存中，如果没有则触发一次读盘操作，然后等待磁盘上的数据被更新到缓存中。</p>
<p>读取磁盘过程：调用文件系统层的readpages函数，使用各种文件系统层的get_block函数获取磁盘物理地址，存放到<code>bh</code>里(即<code>buffer_head</code>)，使用<code>bh</code>构造<code>bio</code>，然后<code>提交bio</code>(一般使用<code>submit_bio</code>函数将数据bio提交到<code>io的块设备层</code>)。函数<code>generic_make_request</code>转发bio，generic_make_request是一个循环，通过<code>generic_make_request</code>提交请求给I&#x2F;O调度层，这个函数最后调用到<code>q-&gt;make_request_fn(q, bio)</code>，那么对于这个函数的调用就是I&#x2F;O调度层的入口点(ps: Generic_make_request的执行上下文可能有两种，一种是用户上下文，另一种为pdflush.)</p>
<p>q-&gt;make_request_fn调用的是<code>blk_queue_bio</code>函数(早期版本是__make_request)，在blk_init_allocated_queue里注册。blk_queue_bio函数是Linux提供的块设备请求处理函数，实现IO Schedule。在该函数中试图将转发过来的bio merge到一个已经存在的request中，如果可以合并，那么将新的bio请求挂载到一个已经存在request中。如果不能合并，那么分配一个新的request，然后将bio添加到其中。</p>
<p>blk_queue_bio里分为plug和unplug机制，在plug下就直接把request存到plug list(例如dio就是依赖于plug机制)。unplug下就直接调用queue的<code>request_fn</code>方法把request提交给磁盘驱动进行真正的处理了。当然，我们现在使用的是unplug机制。</p>
<p>然后<code>q-&gt;request_fn</code>调用queue队列的request_fn方法<code>scsi_request_fn</code>函数(我们这里选择sda，sdb之类scsi设备)，<br>在scsi_request_fn函数中会扫描request队列，通过<code>blk_peek_request</code>(原先版本是：elv_next_request)函数从队列中获取一个request。在<code>blk_peek_request</code>函数中通过scsi总线层注册的q-&gt;prep_rq_fn（scsi层注册为<code>scsi_prep_fn``blk_queue_prep_rq(q, scsi_prep_fn);</code>）函数将具体的request转换成scsi驱动所能认识的<em>scsi command</em>。获取一个request之后，scsi_request_fn函数直接调用<code>scsi_dispatch_cmd</code>函数将scsi command发送给一个具体的scsi host。</p>
<p>到这一步，在scsi_dispatch_cmd函数中，通过scsi host的接口方法<code>queuecommand</code>(<code>.queuecommand= ufshcd_queuecommand</code>,)将scsi command发送给scsi host。通常scsi host的queuecommand方法会将接收到的scsi command挂到自己维护的队列中，然后再启动DMA过程将scsi command中的<code>数据发送给具体的磁盘</code>。DMA完毕之后，DMA控制器中断CPU，告诉CPU DMA过程结束，并且在中断上下文中设置DMA结束的中断下半部。DMA中断服务程序返回之后触发软中断，执行SCSI中断下半部。</p>
<p>在SCSi中断下半部中，调用scsi command结束的回调函数，这个函数往往为scsi_done，在scsi_done函数调用blk_complete_request函数结束请求request，每个请求维护了一个bio链，所以在结束请求过程中回调每个请求中的bio回调函数，结束具体的bio。Bio又有文件系统的buffer head生成，所以在结束bio时，回调buffer_head的回调处理函数bio-&gt;bi_end_io（注册为end_bio_bh_io_sync）。自此，由中断引发的一系列回调过程结束，总结一下回调过程如下：scsi_done-&gt;end_request-&gt;end_bio-&gt;end_bufferhead。</p>
<p>那什么时候知道数据已经在缓存里了呢?<br>do_generic_file_read –&gt; PageUptodate(page)即检查PG_uptodate标志位。</p>
<p>注意点是上述<code>queuecommand ufshcd_queuecommand</code>下发磁盘时, qcom的硬件加密流程正处于这个位置, 而scsi中断下半部中, 在scsi done前, 触发了<code>ufshcd_vops_crypto_engine_cfg_end</code><br>devm_request_irq(dev, irq, ufshcd_intr, IRQF_SHARED,<br>                dev_name(dev), hba)-&gt;ufshcd_intr-&gt;ufshcd_sl_intr-&gt;ufshcd_transfer_req_compl-&gt;__ufshcd_transfer_req_compl-&gt;ufshcd_vops_crypto_engine_cfg_end</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">err = ufshcd_vops_crypto_engine_cfg_start(hba, tag);</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ufshcd_vops_crypto_engine_cfg_start</span><span class="params">(<span class="keyword">struct</span> ufs_hba *hba,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> task_tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hba-&gt;var &amp;&amp; hba-&gt;var-&gt;crypto_vops &amp;&amp;</span><br><span class="line">        hba-&gt;var-&gt;crypto_vops-&gt;crypto_engine_cfg_start)</span><br><span class="line">        <span class="keyword">return</span> hba-&gt;var-&gt;crypto_vops-&gt;crypto_engine_cfg_start</span><br><span class="line">                (hba, task_tag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">qcom_host-&gt;ice.vops-&gt;config_start(qcom_host-&gt;ice.pdev, req, &amp;ice_set, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// qcom硬件加密的方案全在这个函数中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">qcom_ice_config_start</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> request *req,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> ice_data_setting *setting, <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ice_crypto_setting</span> <span class="title">pfk_crypto_data</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ice_crypto_setting</span> <span class="title">ice_data</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> is_pfe = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec_end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">sector_t</span> data_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ice_device</span> *<span class="title">ice_dev</span>;</span></span><br><span class="line"></span><br><span class="line">    ice_dev = platform_get_drvdata(pdev);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * It is not an error to have a request with no  bio</span></span><br><span class="line"><span class="comment">     * Such requests must bypass ICE. So first set bypass and then</span></span><br><span class="line"><span class="comment">     * return if bio is not available in request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (setting) &#123;</span><br><span class="line">        setting-&gt;encr_bypass = <span class="literal">true</span>;</span><br><span class="line">        setting-&gt;decr_bypass = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是pfe模式, fbe加密和metadata加密的实现都是pfe的.</span></span><br><span class="line">    ret = pfk_load_key_start(req-&gt;bio, ice_dev, &amp;pfk_crypto_data,</span><br><span class="line">            &amp;is_pfe, async);</span><br><span class="line">    <span class="keyword">if</span> (is_pfe) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret != -EBUSY &amp;&amp; ret != -EAGAIN)</span><br><span class="line">                pr_err(<span class="string">&quot;%s error %d while configuring ice key for PFE\n&quot;</span>,</span><br><span class="line">                        __func__, ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> qti_ice_setting_config(req, ice_dev,</span><br><span class="line">                &amp;pfk_crypto_data, setting, ICE_CRYPTO_CXT_FBE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是fde模式且是userdata分区</span></span><br><span class="line">    <span class="keyword">if</span> (ice_fde_flag &amp;&amp; req-&gt;part &amp;&amp; req-&gt;part-&gt;info</span><br><span class="line">                &amp;&amp; req-&gt;part-&gt;info-&gt;volname[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(req-&gt;part-&gt;info-&gt;volname, <span class="string">&quot;userdata&quot;</span>)) &#123;</span><br><span class="line">            sec_end = req-&gt;part-&gt;start_sect + req-&gt;part-&gt;nr_sects -</span><br><span class="line">                    QCOM_UD_FOOTER_SECS;</span><br><span class="line">            <span class="keyword">if</span> ((req-&gt;__sector &gt;= req-&gt;part-&gt;start_sect) &amp;&amp;</span><br><span class="line">                (req-&gt;__sector &lt; sec_end)) &#123;</span><br><span class="line">                data_size = req-&gt;__data_len /</span><br><span class="line">                        QCOM_SECT_LEN_IN_BYTE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((req-&gt;__sector + data_size) &gt; sec_end)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> qti_ice_setting_config(req,</span><br><span class="line">                        ice_dev, &amp;ice_data, setting,</span><br><span class="line">                        ICE_CRYPTO_CXT_FDE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pfk_load_key_start</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bio *bio, <span class="keyword">struct</span> ice_device *ice_dev,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> ice_crypto_setting *ice_setting, <span class="type">bool</span> *is_pfe,</span></span><br><span class="line"><span class="params">        <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pfk_key_info</span> <span class="title">key_info</span> =</span> &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ice_cryto_algo_mode</span> <span class="title">algo_mode</span> =</span> ICE_CRYPTO_ALGO_MODE_AES_XTS;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ice_crpto_key_size</span> <span class="title">key_size_type</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data_unit = <span class="number">1</span> &lt;&lt; ICE_CRYPTO_DATA_UNIT_512_B;</span><br><span class="line">    u32 key_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * only a few errors below can indicate that</span></span><br><span class="line"><span class="comment">     * this function was not invoked within PFE context,</span></span><br><span class="line"><span class="comment">     * otherwise we will consider it PFE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// is_pfe默认为true</span></span><br><span class="line">    *is_pfe = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pfk_is_ready())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从bio中获取key的信息</span></span><br><span class="line"></span><br><span class="line">    ret = pfk_get_key_for_bio(bio, &amp;key_info, &amp;algo_mode, is_pfe,</span><br><span class="line">                    &amp;data_unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pfk_key_size_to_key_type(key_info.key_size, &amp;key_size_type);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pfk_kc_load_key_start(key_info.key, key_info.key_size,</span><br><span class="line">            key_info.salt, key_info.salt_size, &amp;key_index, async,</span><br><span class="line">            data_unit, ice_dev);</span><br><span class="line"></span><br><span class="line">    ice_setting-&gt;key_size = key_size_type;</span><br><span class="line">    ice_setting-&gt;algo_mode = algo_mode;</span><br><span class="line">    <span class="comment">/* hardcoded for now */</span></span><br><span class="line">    ice_setting-&gt;key_mode = ICE_CRYPTO_USE_LUT_SW_KEY;</span><br><span class="line">    ice_setting-&gt;key_index = key_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pfk_get_key_for_bio</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bio *bio,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> pfk_key_info *key_info,</span></span><br><span class="line"><span class="params">        <span class="keyword">enum</span> ice_cryto_algo_mode *algo_mode,</span></span><br><span class="line"><span class="params">        <span class="type">bool</span> *is_pfe, <span class="type">unsigned</span> <span class="type">int</span> *data_unit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pfe_type</span> <span class="title">which_pfe</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_encryption_key</span> *<span class="title">key</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *s_type = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从bio中获取inode信息</span></span><br><span class="line">    inode = pfk_bio_get_inode(bio);</span><br><span class="line">    which_pfe = pfk_get_pfe_type(inode);</span><br><span class="line">    <span class="comment">// 判断inode文件系统类型</span></span><br><span class="line">    s_type = (<span class="type">char</span> *)pfk_kc_get_storage_type();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Update dun based on storage type.</span></span><br><span class="line"><span class="comment">     * 512 byte dun - For ext4 emmc</span></span><br><span class="line"><span class="comment">     * 4K dun - For ext4 ufs, f2fs ufs and f2fs emmc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data_unit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bio_dun(bio) &amp;&amp; !<span class="built_in">memcmp</span>(s_type, <span class="string">&quot;sdcc&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;sdcc&quot;</span>)))</span><br><span class="line">            *data_unit = <span class="number">1</span> &lt;&lt; ICE_CRYPTO_DATA_UNIT_512_B;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *data_unit = <span class="number">1</span> &lt;&lt; ICE_CRYPTO_DATA_UNIT_4_KB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于metadata元数据信息来说, 并没有inode信息, 所以which_pfe是INVAILD_PFE.</span></span><br><span class="line">    <span class="keyword">if</span> (which_pfe != INVALID_PFE) &#123;</span><br><span class="line">        <span class="comment">/* Encrypted file; override -&gt;bi_crypt_key */</span></span><br><span class="line">        pr_debug(<span class="string">&quot;parsing inode %lu with PFE type %d\n&quot;</span>,</span><br><span class="line">             inode-&gt;i_ino, which_pfe);</span><br><span class="line">        <span class="keyword">return</span> (*(pfk_parse_inode_ftable[which_pfe]))</span><br><span class="line">                (bio, inode, key_info, algo_mode, is_pfe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bio is not for an encrypted file.  Use -&gt;bi_crypt_key if it was set.</span></span><br><span class="line"><span class="comment">     * Otherwise, don&#x27;t encrypt/decrypt the bio.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// metadata加密继续走这里, 这个bio是dm-default-key转发过来的, 所以是带有bi_crypt_key信息的, 能找到key, is_pfe即为true</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM_DEFAULT_KEY</span></span><br><span class="line">    key = bio-&gt;bi_crypt_key;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        *is_pfe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key_info-&gt;key = &amp;key-&gt;raw[<span class="number">0</span>];</span><br><span class="line">    key_info-&gt;key_size = PFK_SUPPORTED_KEY_SIZE;</span><br><span class="line">    key_info-&gt;salt = &amp;key-&gt;raw[PFK_SUPPORTED_KEY_SIZE];</span><br><span class="line">    key_info-&gt;salt_size = PFK_SUPPORTED_SALT_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (algo_mode)</span><br><span class="line">        *algo_mode = ICE_CRYPTO_ALGO_MODE_AES_XTS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-总结"><a href="#1-4-3-总结" class="headerlink" title="1.4.3. 总结"></a>1.4.3. 总结</h3><p>qcom的硬件加密方案是按照google 规范写的, 先在fstab的userdata的表里加入了fileencryption&#x3D;ice, 文件系统判断是硬件加密方案不再对page cache做额外的加解密处理.<br>而metadata加密方案通过dm-default-key的插件在文件系统层下为元数据的bio挂上了加密密钥信息,而非文件系统元数据对应的目录或文件的inode(以及data block)则使用ensure_policy时对目录层级采用的加密策略.<br>保证了me加密方案不会对元数据或文件inode单独的加密要求, 而在通用块层之下的scsi架构中插桩, 通用块层请求下来后, bio merge到requeset后, 对request下发到ufs device之前(queuecommand时)由scsi host adapter为request挂上了加密信息, 而加密信息来自于文件系统inode或元数据挂上的密钥信息. 保证了再下发到device后, 通过硬件器件对request进行加解密.</p>
<p>Linux scsi设备读写流程：<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29634482-id-5127267.html">http://blog.chinaunix.net/uid-29634482-id-5127267.html</a><br>块设备读写流程：<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-25052030-">http://blog.chinaunix.net/uid-25052030-</a> id-58337.html<br>usb驱动学习笔记：<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-25627207-id-3341609.html">http://blog.chinaunix.net/uid-25627207-id-3341609.html</a><br>plug&#x2F;unplug机制：<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/xmlrpc.php?r=">http://blog.chinaunix.net/xmlrpc.php?r=</a> blog&#x2F;article&amp;uid&#x3D;14528823&amp;id&#x3D;4778396</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cherishui/p/3878678.html">Linux SCSI回调IO的分析</a></p>
<p><img src="/images/20191205212746016_750728522.png" alt="scsi驱动"><br><img src="/images/20191205212906116_454506309.png" alt="scsi三层驱动模型"><br>在scsi middle level定义了scsi device的数据结构，用于描述一个scsi的具体功能单元，其在scsi host中通过channel、id、lun进行寻址。<br>　　在scsi host中可以存在多个channel，每个channel是一条完整的scsi总线，在scsi总线上可以连接多个scsi节点，每个节点采用id进行编号，编号的大小与具体的scsi specification相关，与总线层的驱动能力等因素相关。每个节点可以根据功能划分成多个lun，每个lun才是我们通常所说的scsi设备。<br>　　<img src="/images/20191205213052693_1193147772.png" alt="channel lun"><br>　　scsi host的语义很清晰，其描述了一个scsi总线控制器。在很多实际的系统中，scsi host为一块基于PCI总线的HBA或者为一个SCSI控制器芯片。每个scsi host可以存在多个channel，一个channel实际扩展了一条SCSI总线。每个channel可以连接多个scsi节点，具体连接的数量与scsi总线带载能力有关.<br>　　在scsi总线probe的过程中，scsi middle level会为每个lun抽象成scsi device，实现的核心函数为scsi_probe_and_add_lun()<br>　　scsi target对scsi总线上的scsi 节点进行了抽象。每个scsi target可能拥有多个lun，即多个scsi devie
　　</p>
<h4 id="1-4-3-1-low-level接口方法——scsi-host-template"><a href="#1-4-3-1-low-level接口方法——scsi-host-template" class="headerlink" title="1.4.3.1. low-level接口方法——scsi_host_template"></a>1.4.3.1. low-level接口方法——scsi_host_template</h4><p>　　scsi middle level通过scsi_host_template接口调用scsi host的具体方法。在scsi host driver向middle level注册host对象的同时需要注册scsi_host_template方法，该方法被注册到scsi host对象中。<br>　　scsi middle level层提供了scsi host扫描函数，在设备枚举过程中scsi host可以调用该函数对scsi总线适配器进行扫描，当然host驱动也可以调用更加底层的函数对scsi总线进行扫描。scsi_scsn_host函数实现流程如下：<br>　　<img src="/images/20191205213731280_1559005815.png" alt="扫描channel"></p>
<p>scsi host作为 platform 设备会被platform总线驱动层扫描到，扫描到scsi host之后，操作系统开始加载scsi host的驱动，scsi host driver就是上面说所的low level driver。scsi host driver初始化scsi控制器， 分配硬件资源，注册中断服务。最后开始扫描通过scsi控制器扩展出来的下一级总线——scsi bus。<br>　　scsi bus的扫描通过scsi middle level提供的服务完成。scsi host driver可以调用scsi middle level提供的扫描算法完成scsi总线设备的扫描<br>在scsi总线扫描过程中用到了scsi middle level层的如下重要函数：<br>　　1、scsi_scan_host：对scsi host设备进行扫描。<br>       2、scsi_add_device：探测具体的device，并且将其加入系统。<br>　　3、scsi_probe_and_add_lun：探测具体指定的lun，并且将其加入系统。<br>　　4、scsi_probe_lun：采用INQUIRY命令对lun节点进行探测。<br>　　5、scsi_add_lun：加入lun节点并且初始化SCSI设备。<br>　　scsi总线scan过程中的函数调用情况如下图所示：<br>　　<img src="/images/20191205214309678_1411751880.png" alt="scsi扫描过程"></p>
<h2 id="1-5-scsi设备读写过程"><a href="#1-5-scsi设备读写过程" class="headerlink" title="1.5. scsi设备读写过程"></a>1.5. scsi设备读写过程</h2><p>在此给出一个scsi设备的读写数据流程，通过该例子，读者可以方便查找Linux<br>源代码，并且能够理清繁杂的代码结构。假设读写的scsi设备为scsi disk设备，数据首先通过文件系统，进入到文件系统的Cache。文件系统的pdflush daemon会将Cache住的数据刷新到磁盘，其根据buffer head的内容构造bio，然后调用块设备接口（submit_bio）将请求发送给块设备层。bio在块设备层多次转发，最后被merge到块设备的请求队列中。请求可能会在请求队列滞留一段时间，然后在软中断或者用户上下文中调用request_fn去处理请求队列。在scsi middle level驱动层，块设备的请求被转换成scsi command，然后通过queuecommand函数接口将scsi command提交给scsi host，通常scsi host会发起DMA操作将数据传输给具体的设备。至此，数据从应用程序转移到了scsi设备，当然上述过程还没有涉及到回调过程，实际的回调会在中断上下文、软中断上下文中完成，在请求发送的每一层都保存了相应的回调上下文。整个数据流的过程中，涉及到的函数如下：<br><img src="/images/20191205214506707_1559031982.png" alt="读写过程"><br>对scsi总线层有个提纲挈领的效果。在分析scsi middle level的过程中，有如下几点感想：<br>　　1、  scsi驱动采用了规范的分层设计思想，其一共分为三层，分层之后使得设计分工更加明确，而且在逻辑上也更加清晰，设计工作也更加简单。<br>　　2、  scsi驱动中比较固定的层次为scsi middle level，该层可以称之为scsi通用中间层，或者为总线驱动层。该层向上和向下都需要提供接口，所以上层驱动开发时需要注册相关接口函数，下层驱动工作时也需要注册接口函数，只有这样中间层才可以很灵活的进行上下层数据传输。<br>　　scsi middle level主要实现了scsi总线扫描算法，scsi命令转换算法，scsi出错处理等机制，这些东西都是scsi的核心所在。</p>
<h3 id="1-5-1-card层"><a href="#1-5-1-card层" class="headerlink" title="1.5.1. card层"></a>1.5.1. card层</h3><p>设备接口层:<br>     提供scsi设备的使用接口<br>     scsi&#x2F;sd.c:<br>        实现scsi硬盘接口，通过硬盘注册接口，将scsi硬盘注册到块设备系统，使得系统可以通过通用块设备接口来使用scsi硬盘，在scsi&#x2F;sd.c里面实现。</p>
<p>scsi host driver在初始化时，会调用scsi_scan_host来扫描host。扫描整个host以为着扫描host所对应的channel,target和lun。因此，它分别调用scsi_scan_channel，__scsi_scan_target，scsi_probe_and_add_lun来每个target及其lun。其中，在scsi_probe_and_add_lun中会分配代表每个lun即scsi设备的scsi_device结构:<br> scsi_scan_host-&gt;do_scsi_scan_host-&gt;scsi_scan_host_selected-&gt;scsi_scan_channel-&gt;__scsi_scan_target-&gt;scsi_probe_and_add_lun:<br>sdev &#x3D; scsi_alloc_sdev(starget, lun, hostdata);<br>scsi_scan_host-&gt;do_scsi_scan_host-&gt;scsi_scan_host_selected-&gt;scsi_scan_channel-&gt;__scsi_scan_target-&gt;scsi_probe_and_add_lun-&gt;scsi_probe_lun</p>
<p>分配好scsi_device结构以后，调用scsi_probe_lun来发送<code>INQUIRY</code>命令，探测制定的lun。scsi设备返回的<code>inquiry data</code>将保存在result参数中，以备scsi_add_lun使用。其中包括了设备的信息，包括设备的种类type等。<br>scsi_scan_host-&gt;do_scsi_scan_host-&gt;scsi_scan_host_selected-&gt;scsi_scan_channel-&gt;__scsi_scan_target-&gt;scsi_probe_and_add_lun-&gt;scsi_add_lun<br>如果scsi_probe_lun成功，则调用scsi_add_lun来添加lun。在scsi_add_lun中，先根据inquiry data来初始化scsi_device中的一些属性，包括其type属性（在这儿为TYPE_DISK）。<br>scsi_scan_host-&gt;do_scsi_scan_host-&gt;scsi_scan_host_selected-&gt;scsi_scan_channel-&gt;__scsi_scan_target-&gt;scsi_probe_and_add_lun-&gt;scsi_add_lun-&gt;<code>scsi_sysfs_add_sdev</code></p>
<p>之后调用scsi_sysfs_add_sdev来添加scsi_device。这儿与device_driver的注册类似，调用device_attach来对扫描bus上所有的driver，调用这些driver的probe方法来探测自身的device。如果此时，sd没有初始话，即bus上没有相应的驱动，则不会调用probe方法。即不会生成lun对应的gend。并且，sd_probe中，会检测scsi_device的具体类型，只有自己支持的才回去探测。</p>
<p>通过上述两个过程，device_driver和device联系在了一起。总之，对于每个lun的加入，sd_probe都会执行一次。只不过sd_probe的触发，要么是通过sd驱动<code>scsi_register_driver</code>，要么是通过LLD <code>scsi_scan_host</code>。<br>sd_probe调用栈（由scsi_scan_host触发）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0 sd_probe (dev=0xc714a4b0) at drivers/scsi/sd.c:1597</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1 0xc018df10 <span class="keyword">in</span> driver_probe_device (drv=0xc0335df8, dev=0xc714a4b0) at drivers/base/dd.c:121</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2 0xc018dfd8 <span class="keyword">in</span> __device_attach (drv=0xc714a4b0, data=0x0) at drivers/base/dd.c:207</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 0xc018d110 <span class="keyword">in</span> bus_for_each_drv (bus=, start=, data=0x0, fn=0xc018dfc8 &lt;__device_attach&gt;) at drivers/base/bus.c:349</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 0xc018e078 <span class="keyword">in</span> device_attach (dev=0x1) at drivers/base/dd.c:238</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 0xc018d070 <span class="keyword">in</span> bus_attach_device (dev=0xc714a4b0) at drivers/base/bus.c:492</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6 0xc018be64 <span class="keyword">in</span> device_add (dev=0xc714a4b0) at drivers/base/core.c:781</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7 0xc019fc84 <span class="keyword">in</span> scsi_sysfs_add_sdev (sdev=0xc714a400) at drivers/scsi/scsi_sysfs.c:783</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8 0xc019d9b8 <span class="keyword">in</span> scsi_probe_and_add_lun (starget=0xc76d9000, lun=, bflagsp=, sdevp=0x0, rescan=0, hostdata=0x0) at drivers/scsi/scsi_scan.c:914</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9 0xc019e088 <span class="keyword">in</span> __scsi_scan_target (parent=0xc715e8d8, channel=0, <span class="built_in">id</span>=0, lun=4294967295, rescan=0) at drivers/scsi/scsi_scan.c:1550</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0xc019e538 <span class="keyword">in</span> scsi_scan_channel (shost=0xc715e800, channel=0, <span class="built_in">id</span>=0, lun=4294967295, rescan=0) at drivers/scsi/scsi_scan.c:1626</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0xc019e608 <span class="keyword">in</span> scsi_scan_host_selected (shost=0xc714a4b0, channel=1, <span class="built_in">id</span>=1, lun=3222995532, rescan=0) at drivers/scsi/scsi_scan.c:1654</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0xc019e6e8 <span class="keyword">in</span> do_scsi_scan_host (shost=0xc715e800) ---Type to <span class="built_in">continue</span>, or q to quit--- at drivers/scsi/scsi_scan.c:1786</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 0xc019eb50 <span class="keyword">in</span> scsi_scan_host (shost=0xc715e800) at drivers/scsi/scsi_scan.c:1813</span></span><br></pre></td></tr></table></figure>

<p>UL初始化时准备device_driver结构，其中包括probe方法。而LLD（准确地说，应该是middle layer）准备device结构。二者都把其bus初始化为scsi_bus_type，并挂入该总线。之后，如果是UL初始化，则调用自身的probe方法，去探测bus上的所有device，从而把device_driver绑定倒device。而如果是LLD初始化，则调用bus上所有的device_driver的probe方法来探测自身的device。因此，无论是UL先初始化还是LLD先初始化，二者都能取得联系。</p>
<p>这里推荐一个博客, 里面有关于scsi里许多流程的介绍<br><a target="_blank" rel="noopener" href="http://chinaunix.net/uid/709830/list/1.html?cid=36085">scsi介绍多篇</a></p>
<h2 id="1-6-对总线的理解"><a href="#1-6-对总线的理解" class="headerlink" title="1.6. 对总线的理解"></a>1.6. 对总线的理解</h2><p><img src="/images/20191206200431808_1301015981.jpg" alt="pc桥"><br>所谓的桥，就是Bridge，桥接的意思。以前的老式电脑中，CPU是通过南桥和北桥连接其它设备的。其中北桥连接高速设备和南桥，南桥连接低速设备。<br>例如：<br>CPU——北桥——内存<br>CPU——北桥——显卡<br>CPU——北桥——南桥——硬盘<br>CPU——北桥——南桥——网卡<br>CPU——北桥——南桥——PS&#x2F;2键鼠<br>CPU——北桥——南桥——USB设备<br>Intel从SandyBridge开始，CPU整合内存控制器和PCI-E控制器、DMI通道，相当于是把原来北桥的功能集成在CPU内部了，北桥自然就消失了。南桥换了个称呼叫<code>IO Hub</code></p>
<h3 id="1-6-1-ARM-SOC上-总线协议"><a href="#1-6-1-ARM-SOC上-总线协议" class="headerlink" title="1.6.1. ARM SOC上 总线协议"></a>1.6.1. ARM SOC上 总线协议</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/feipeng8848/p/8484367.html">AMBA总线</a></p>
<p> AHB总线的强大之处在于它可以将微控制器（CPU）、高带宽的片上RAM、高带宽的外部存储器接口、DMA总线master、各种拥有AHB接口的控制器等等连接起来构成一个独立的完整的SOC系统，不仅如此，还可以通过<code>AHB-APB桥</code>来连接APB总线系统。AHB可以成为一个完整独立的SOC芯片的骨架。<br> <img src="/images/20191206203755941_65819257.png" alt="AMBA"></p>
<p>AXI总线替代AHB APB总线<br><img src="/images/20191206213558324_298683154.png" alt="ufs 2.1"></p>
<p>The IP for UFS 2.1 Host Controller allows for highlysecured applications by employing AES encryption. The data encryption and decryption is done seamlessly by the<br>controller as data is written to or read from the UFS 2.1 device.</p>
<p>高通平台上UFS是通过<code>AXI/AHB总线</code>连接到cpu的.</p>
<p>回到platform driver上, 看高通的实现, ufs driver是注册在platform总线上的, 这个platform总线和AHB&#x2F;AXI的关系应该怎样理解呢?</p>
<p>这里引用一篇问答:</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33414159/answer/56558491">https://www.zhihu.com/question/33414159/answer/56558491</a></p>
<p>bus上有driver和device，一个driver可以对应多个device，一个device只能有一个driver。比如pcie是一种总线，intel的82574网卡是一种pcie设备，e1000e.c 是网卡驱动。因为操作系统要支持外设，必须先要知道当前计算机有哪些设备，以及这些设备的访问方式、访问地址、中断号、中断触发方式等。这些资源信息假如写死在driver代码里，普通用户就无法DIY PC了。比如把硬盘换一个sata口，显卡换一个pcie插槽，控制这些设备的地址和中断就变了，用户就得自己改改驱动代码编译一下，没法玩嘛。这样就需要把当前计算机有哪些设备，以及这些设备的访问方式、访问地址、中断号、中断触发方式等 这些资源信息单独剥离出来，封进一个一个xxxx_device这样的结构体里。这样xxx_driver也更容易实现 一次编写，管你x86、arm、powerpc 到处运行。运行时，每当注册一个新的xxx_device或者xxx_driver到一条xxx_bus上，linux就尝试在xxx_bus给这个新加入的xxx_device或者xxx_driver配对（probe），device和driver配对成功了，xxx_driver就能利用xxx_device的内容去控制xxx设备了。综上，bus， device 和driver是一个清晰的树状结构，一种好的设计。可以在&#x2F;sys&#x2F;bus目录下用ls 、tree命令列出来这个树。<br>终于能回到题目，platform 是一种虚拟的bus；而char driver 和 block driver，只是driver的细分。它们并不是并列的关系。那为什么要有platform 这条虚拟的总线呢？还是上面说的，操作系统要支持外设，必须先要知道当前计算机有哪些设备。要做到这一点，要么<code>硬件本身能自动探测出来当前bus上有哪些device</code>，要么就由程序员<code>事先把device资源信息写在代码或者dts这类配置文件里</code>。pci&#x2F;pcie 总线是x86架构的脊椎，且拥有探测pci&#x2F;pcie 设备的能力。PC上的usb总线控制器，对上是一个pcie设备，对下则是usb总线的控制器。等于<code>pcie总线下扩展出了新的usb总线</code>。usb总线也是有硬件探测能力的。个人电脑几乎所有重要的外设：硬盘、u盘、键盘、鼠标、声卡、显卡，都是pcie或者usb设备。再加上BIOS的帮助，普通pc的内核几乎不需要程序员手动注册一个设备信息，自己就能探测就出来当前计算机插了哪些设备。但是手机、平板等大量使用SOC的非X86架构计算机，它自己的usb控制器、i2c控制器、声卡控制器、lcd驱动器、存储控制器（一般是flash控制器，个别SOC也有sata控制器）等，都不再是X86架构下的pci设备了，<code>靠硬件自己是无法探测的</code>。此时就需要程序员自己手动写代码或者配置文件，来注册这些device的信息。假如是i2c 设备、spi设备，硬件也没有探测设备属性的能力，程序员手动注册device就注册了吧，起码知道是要注册到那条bus上去。。可偏偏<code>这些SOC外设并没有一个统一的总线名称</code>，ARM上叫<code>AHB、 APB</code> ，powerpc上叫CCB，甚至隔个几年又会发明新的叫法。platform 这条虚拟的bus，就是用来统一维护此类device的bus。</p>
<p>linux上把这种SOC内部bus下的设备（不一定全都是子总线控制器如usb控制器、i2c控制器，也可以是音频、视频控制器这种设备控制器），都注册到platform这条虚拟bus上。<br>软件对于这种bus下的设备的访问倒很简单统一，按照芯片手册给的物理地址去访问即可。因为是SOC内部的设备，自然是SOC的厂家自己写这些设备的driver。这种driver一般注册到platform bus。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/10/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%9C%BAlog%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/%E5%BC%80%E6%9C%BAlog%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">小米开机log相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-01T00:00:00+08:00">2019-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-15 18:49:09" itemprop="dateModified" datetime="2024-04-15T18:49:09+08:00">2024-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/log/" itemprop="url" rel="index"><span itemprop="name">log</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-开机log相关"><a href="#1-开机log相关" class="headerlink" title="1. 开机log相关"></a>1. 开机log相关</h1><h2 id="1-1-抓取log的方式"><a href="#1-1-抓取log的方式" class="headerlink" title="1.1. 抓取log的方式"></a>1.1. 抓取log的方式</h2><h3 id="1-1-1-通过rec-overy抓取ota的log"><a href="#1-1-1-通过rec-overy抓取ota的log" class="headerlink" title="1.1.1. 通过rec overy抓取ota的log"></a>1.1.1. 通过rec overy抓取ota的log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">-设置</span><br><span class="line">-系统更新</span><br><span class="line">-菜单(重启到recovery)</span><br><span class="line">note right</span><br><span class="line">稳定版本需要连续点击logo</span><br><span class="line">才会出现菜单项</span><br><span class="line">end note</span><br><span class="line">-系统重启到recovery模式</span><br><span class="line">-选择连接小米助手</span><br><span class="line">- pc端执行 adb pull /cache/ .</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-1-抓取的log分析"><a href="#1-1-1-1-抓取的log分析" class="headerlink" title="1.1.1.1. 抓取的log分析"></a>1.1.1.1. 抓取的log分析</h4><p><code>/cache/recovery/</code>下面是ota升级相关的log日志<br><code>/cache/mqsas</code>下是重启到recovery模式前主系统最后保存的日志</p>
<h3 id="1-1-2-主系统的日志"><a href="#1-1-2-主系统的日志" class="headerlink" title="1.1.2. 主系统的日志"></a>1.1.2. 主系统的日志</h3><p>如果adb 可以连接, 可查看的log信息<br>&#96;adblog</p>
<p>&#96;cat</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/09/20/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/20/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/github/" class="post-title-link" itemprop="url">github 加速</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-20 10:00:01" itemprop="dateCreated datePublished" datetime="2019-09-20T10:00:01+08:00">2019-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-15 18:55:47" itemprop="dateModified" datetime="2024-04-15T18:55:47+08:00">2024-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug/" itemprop="url" rel="index"><span itemprop="name">debug</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="github-加速"><a href="#github-加速" class="headerlink" title="github 加速"></a>github 加速</h1><p>git 仓库地址中的<code>github.com</code>变成<span style="color: green"><code>github.com.cnpmjs.org</code></span></p>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com.cnpmjs.org/SpencerPark/IJava.git">https://github.com.cnpmjs.org/SpencerPark/IJava.git</a></p>
<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;https://github.com.cnpmjs.org/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">269</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>

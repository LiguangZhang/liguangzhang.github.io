<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="blog">
<meta property="og:url" content="https://liguangzhang.github.io/page/13/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liguang.zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liguangzhang.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%20gdb%E8%84%9A%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%20gdb%E8%84%9A%E6%9C%AC/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">external/scudo/standalone/checksum.cpp:</span><br><span class="line"><span class="number">25</span>:	scudo::Checksum scudo::HashAlgorithm;</span><br><span class="line">external/scudo/standalone/chunk.h:</span><br><span class="line"><span class="number">78</span>:	<span class="type">static</span> <span class="type">const</span> scudo::uptr scudo::Chunk::ClassIdMask;</span><br><span class="line"><span class="number">82</span>:	<span class="type">static</span> <span class="type">const</span> scudo::uptr scudo::Chunk::OffsetMask;</span><br><span class="line"><span class="number">80</span>:	<span class="type">static</span> <span class="type">const</span> scudo::u8 scudo::Chunk::OriginMask;</span><br><span class="line"><span class="number">81</span>:	<span class="type">static</span> <span class="type">const</span> scudo::uptr scudo::Chunk::SizeOrUnusedBytesMask;</span><br><span class="line">external/scudo/standalone/combined.h:</span><br><span class="line"><span class="number">712</span>:	<span class="type">const</span> scudo::u32 scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::BlockMarker;</span><br><span class="line"><span class="number">702</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::MaxAlignment;</span><br><span class="line"><span class="number">700</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::MaxAlignmentLog;</span><br><span class="line"><span class="number">703</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::MaxAllowedMallocSize;</span><br><span class="line"><span class="number">701</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::MinAlignment;</span><br><span class="line"><span class="number">699</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::MinAlignmentLog;</span><br><span class="line"><span class="number">712</span>:	<span class="type">const</span> scudo::u32 scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::BlockMarker;</span><br><span class="line"><span class="number">702</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::MaxAlignment;</span><br><span class="line"><span class="number">700</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::MaxAlignmentLog;</span><br><span class="line"><span class="number">703</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::MaxAllowedMallocSize;</span><br><span class="line"><span class="number">701</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::MinAlignment;</span><br><span class="line"><span class="number">699</span>:	<span class="type">const</span> scudo::uptr scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt;::MinAlignmentLog;</span><br><span class="line">external/scudo/standalone/common.h:</span><br><span class="line"><span class="number">138</span>:	<span class="type">static</span> <span class="type">const</span> scudo::uptr scudo::MaxRandomLength;</span><br><span class="line">external/scudo/standalone/flags_parser.cpp:</span><br><span class="line"><span class="number">19</span>:	<span class="type">const</span> scudo::u32 scudo::UnknownFlagsRegistry::MaxUnknownFlags;</span><br><span class="line"><span class="number">39</span>:	<span class="type">static</span> scudo::UnknownFlagsRegistry scudo::UnknownFlags;</span><br><span class="line">external/scudo/standalone/flags_parser.h:</span><br><span class="line"><span class="number">32</span>:	<span class="type">const</span> scudo::u32 scudo::FlagParser::MaxFlags;</span><br><span class="line">external/scudo/standalone/linux.h:</span><br><span class="line"><span class="number">58</span>:	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> scudo::TLS_SLOT_SANITIZER;</span><br><span class="line">external/scudo/standalone/local_cache.h:</span><br><span class="line"><span class="number">122</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocatorLocalCache&lt;scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt; &gt;::NumClasses;</span><br><span class="line"><span class="number">22</span>:	<span class="type">const</span> scudo::u32 scudo::SizeClassAllocatorLocalCache&lt;scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt; &gt;::TransferBatch::MaxNumCached;</span><br><span class="line"><span class="number">122</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocatorLocalCache&lt;scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt; &gt;::NumClasses;</span><br><span class="line"><span class="number">22</span>:	<span class="type">const</span> scudo::u32 scudo::SizeClassAllocatorLocalCache&lt;scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt; &gt;::TransferBatch::MaxNumCached;</span><br><span class="line">external/scudo/standalone/mutex.h:</span><br><span class="line"><span class="number">47</span>:	<span class="type">const</span> scudo::u8 scudo::HybridMutex::NumberOfTries;</span><br><span class="line"><span class="number">48</span>:	<span class="type">const</span> scudo::u8 scudo::HybridMutex::NumberOfYields;</span><br><span class="line">external/scudo/standalone/primary64.h:</span><br><span class="line"><span class="number">218</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::MapSizeIncrement;</span><br><span class="line"><span class="number">220</span>:	<span class="type">const</span> scudo::u32 scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::MaxNumBatches;</span><br><span class="line"><span class="number">214</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::NumClasses;</span><br><span class="line"><span class="number">215</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::PrimarySize;</span><br><span class="line"><span class="number">213</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::RegionSize;</span><br><span class="line"><span class="number">55</span>:	<span class="type">const</span> <span class="type">bool</span> scudo::SizeClassAllocator64&lt;scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;, <span class="number">27</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">false</span>&gt;::SupportsMemoryTagging;</span><br><span class="line"><span class="number">218</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::MapSizeIncrement;</span><br><span class="line"><span class="number">220</span>:	<span class="type">const</span> scudo::u32 scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::MaxNumBatches;</span><br><span class="line"><span class="number">214</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::NumClasses;</span><br><span class="line"><span class="number">215</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::PrimarySize;</span><br><span class="line"><span class="number">213</span>:	<span class="type">const</span> scudo::uptr scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::RegionSize;</span><br><span class="line"><span class="number">55</span>:	<span class="type">const</span> <span class="type">bool</span> scudo::SizeClassAllocator64&lt;scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;, <span class="number">28</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="literal">true</span>&gt;::SupportsMemoryTagging;</span><br><span class="line">external/scudo/standalone/quarantine.h:</span><br><span class="line"><span class="number">21</span>:	<span class="type">const</span> scudo::u32 scudo::QuarantineBatch::MaxCount;</span><br><span class="line">external/scudo/standalone/release.h:</span><br><span class="line"><span class="number">139</span>:	scudo::HybridMutex scudo::PackedCounterArray::Mutex;</span><br><span class="line"><span class="number">140</span>:	scudo::uptr scudo::PackedCounterArray::StaticBuffer[<span class="number">2048</span>];</span><br><span class="line"><span class="number">125</span>:	<span class="type">const</span> scudo::uptr scudo::PackedCounterArray::StaticBufferCount;</span><br><span class="line">external/scudo/standalone/size_class_map.h:</span><br><span class="line"><span class="number">180</span>:	<span class="type">const</span> scudo::u32 scudo::AndroidSizeClassConfig::Classes[<span class="number">38</span>];</span><br><span class="line"><span class="number">178</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::MaxBytesCachedLog;</span><br><span class="line"><span class="number">177</span>:	<span class="type">const</span> scudo::u32 scudo::AndroidSizeClassConfig::MaxNumCachedHint;</span><br><span class="line"><span class="number">176</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::MaxSizeLog;</span><br><span class="line"><span class="number">175</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::MidSizeLog;</span><br><span class="line"><span class="number">174</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::MinSizeLog;</span><br><span class="line"><span class="number">173</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::NumBits;</span><br><span class="line"><span class="number">187</span>:	<span class="type">const</span> scudo::uptr scudo::AndroidSizeClassConfig::SizeDelta;</span><br><span class="line"><span class="number">77</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::BatchClassId;</span><br><span class="line"><span class="number">76</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::LargestClassId;</span><br><span class="line"><span class="number">65</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::M;</span><br><span class="line"><span class="number">70</span>:	<span class="type">const</span> scudo::u32 scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::MaxNumCachedHint;</span><br><span class="line"><span class="number">72</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::MaxSize;</span><br><span class="line"><span class="number">63</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::MidClass;</span><br><span class="line"><span class="number">62</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::MidSize;</span><br><span class="line"><span class="number">61</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::MinSize;</span><br><span class="line"><span class="number">73</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::NumClasses;</span><br><span class="line"><span class="number">64</span>:	<span class="type">const</span> scudo::u8 scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::S;</span><br><span class="line"><span class="number">67</span>:	<span class="type">const</span> scudo::uptr scudo::FixedSizeClassMap&lt;scudo::SvelteSizeClassConfig&gt;::SizeDelta;</span><br><span class="line"><span class="number">230</span>:	<span class="type">const</span> scudo::uptr scudo::SvelteSizeClassConfig::MaxBytesCachedLog;</span><br><span class="line"><span class="number">229</span>:	<span class="type">const</span> scudo::u32 scudo::SvelteSizeClassConfig::MaxNumCachedHint;</span><br><span class="line"><span class="number">228</span>:	<span class="type">const</span> scudo::uptr scudo::SvelteSizeClassConfig::MaxSizeLog;</span><br><span class="line"><span class="number">227</span>:	<span class="type">const</span> scudo::uptr scudo::SvelteSizeClassConfig::MidSizeLog;</span><br><span class="line"><span class="number">226</span>:	<span class="type">const</span> scudo::uptr scudo::SvelteSizeClassConfig::MinSizeLog;</span><br><span class="line"><span class="number">225</span>:	<span class="type">const</span> scudo::uptr scudo::SvelteSizeClassConfig::NumBits;</span><br><span class="line"><span class="number">148</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::BatchClassId;</span><br><span class="line"><span class="number">110</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::ClassesSize;</span><br><span class="line"><span class="number">147</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::LargestClassId;</span><br><span class="line"><span class="number">109</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::M;</span><br><span class="line"><span class="number">143</span>:	<span class="type">const</span> scudo::u32 scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::MaxNumCachedHint;</span><br><span class="line"><span class="number">149</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::MaxSize;</span><br><span class="line"><span class="number">145</span>:	<span class="type">const</span> scudo::uptr scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::NumClasses;</span><br><span class="line"><span class="number">108</span>:	<span class="type">const</span> scudo::u8 scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::S;</span><br><span class="line"><span class="number">140</span>:	<span class="type">const</span> scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::SizeTable scudo::TableSizeClassMap&lt;scudo::AndroidSizeClassConfig&gt;::Table;</span><br><span class="line">external/scudo/standalone/wrappers_c_bionic.cpp:</span><br><span class="line"><span class="number">27</span>:	<span class="type">static</span> scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt; Allocator;</span><br><span class="line"><span class="number">41</span>:	<span class="type">static</span> scudo::Allocator&lt;scudo::AndroidSvelteConfig, &amp;scudo_svelte_malloc_postinit&gt; SvelteAllocator;</span><br><span class="line"><span class="number">0x0000007ff6a890f8</span>  scudo::reportCheckFailed(<span class="type">char</span> <span class="type">const</span>*, <span class="type">int</span>, <span class="type">char</span> <span class="type">const</span>*, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)::NumberOfCalls</span><br><span class="line"><span class="number">0x0000007ff6a890fc</span>  scudo::Allocator&lt;scudo::AndroidConfig, &amp;scudo_malloc_postinit&gt;::callPostInitCallback()::OnceControl</span><br><span class="line"><span class="number">0x0000007ff6a895dc</span>  scudo::getFlags()::F</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /home/mi/program/shadow/check_symbol.py</span><br><span class="line">source /home/mi/program/shadow/gdb_scudo_driver.py</span><br></pre></td></tr></table></figure>

<h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GlobalStats Stats;</span><br><span class="line">TSDRegistryT TSDRegistry;</span><br><span class="line">PrimaryT Primary;</span><br><span class="line">SecondaryT Secondary;</span><br><span class="line">QuarantineT Quarantine;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CacheT Cache;</span><br><span class="line">DoublyLinkedList&lt;LargeBlock::Header&gt; InUseBlocks;</span><br><span class="line">uptr AllocatedBytes;</span><br><span class="line">uptr FreedBytes;</span><br><span class="line">uptr LargestSize;</span><br><span class="line">u32 NumberOfAllocs;</span><br><span class="line">u32 NumberOfFrees;</span><br><span class="line">LocalStats Stats;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/20201222212504.svg" alt="scudo_allocate.drawio"></p>
<p>下面的参考数据仅是指64位程序的, 32位的配置和64位不同.</p>
<ul>
<li><p>M_TSDS_COUNT_MAX</p>
<p>设置线程局部存储(TSL)相关的TSD的数目, M_TSDS_COUNT_MAX设置为8后, 如小于等于8个线程, 每个线程会绑定一个TSD.</p>
<p>在每个线程中 使用malloc  free时, 会根据线程状态寄存器查找到其绑定的TSD缓存池.</p>
<p>​     scudo没有外部配置的情况下, 只有两个TSD缓存池, 在配置<code>M_TSDS_COUNT_MAX</code>后, 会产生最多<code>M_TSDS_COUNT_MAX</code>个缓存池, 该值会影响 small(primary) 分配器. 在TSD缓存池少的情况下, 会出现多个线程共用一个TSD缓存池的情况, 分配释放内存时需要等锁.</p>
<blockquote>
<p>Secondary 分配器没有绑定TSD(不是线程私有), 是所有线程共用同一块缓存池, 分配释放需要加锁等锁.</p>
<p>jemalloc5 中 在sz index(36-45范围内的), 当前的配置字节在(14336- 65536)) 使用的缓存是绑定tcache的(线程私有). </p>
</blockquote>
</li>
<li><p>M_CACHE_COUNT_MAX</p>
<p>option-&gt;MaxCacheEntriesCount</p>
<p>   large(Secondary) 分配器在分配释放内存时, 所有线程共用的<code>缓存池的容量</code>, 每次free 时, 会先将该内存单元放到缓存池中, 下次malloc时, 会优先根据分配的size 在缓存池中查找是否有匹配的缓存内存单元, 如果有则直接把该内存单元的地址返回给调用方. </p>
<p>   large(Secondary)的缓存池在满了以后, 下一次free时, 会重置清空缓存池</p>
<blockquote>
<p>该值对应上图的 <code>EntriesArraySize</code>, 默认值为32,  最大只能设置到256, 如果超过256, 会设置失败, 用默认值.</p>
</blockquote>
</li>
<li><p>M_CACHE_SIZE_MAX</p>
<p>option-&gt;MaxCacheEntrySize</p>
<p>在free时, large(Secondary) 分配器并不是将所有大于small分配器的内存单元全部放到缓存池中,  而是在 <code>0x40010</code>-<code>M_CACHE_SIZE_MAX</code>范围内的会在free时放到缓存池中(small的范围<code>0-0x40010</code>),  malloc时会优先从缓存池中查找. 而大于<code>M_CACHE_SIZE_MAX</code>的malloc则直接走mmap, free走<code>unmap</code>. </p>
<blockquote>
<p>该值对应上图的 <code>MaxEntrySize</code>, 默认值是2M</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/SignConfig%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/SignConfig%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Signed config service. This is not an Android Service, but just owns a broadcast receiver for<br>receiving package install and update notifications from the package manager.</p>
<h1 id="1-commit-id"><a href="#1-commit-id" class="headerlink" title="1. commit id"></a>1. commit id</h1><p>4e2ed6a90ba32bec7c67cf4260d65bf40430dcf9<br>b0b51c326e06db55931b57a23afcf1b73cdf8b80<br>96c419f90686ea7f16cde37cf1a137ae6cddf4c6<br>b375be55453abd78aa4c6bebe53d6883b0da9e03</p>
<h1 id="2-modi-files"><a href="#2-modi-files" class="headerlink" title="2. modi files"></a>2. modi files</h1><pre><code>New receiver for signed config.

A new receiver is added when the system server is created. It receives
broadcasts and pulls out the config &amp; signature, but doesn&#39;t yet do
anything with it.

go/serverless-config-design
</code></pre>
<p>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignedConfigApplicator.java<br>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignedConfigService.java</p>
<pre><code>Parser for signed configuration.

Signed configuration is stored an JSON inside APK meta-data. The format
of the JSON is as follows:
&#123;
  &quot;version&quot;: n,
  &quot;config&quot;: [
    &#123;
      &quot;minSdk&quot;: n,
      &quot;maxSdk&quot;: n,
      &quot;values&quot;: [
        &#123;
          &quot;key&quot;: &quot;global settings key&quot;,
          &quot;value&quot;: &quot;value for key&quot;
        &#125;,
    ...
      ],
      ...
    &#125;
  ]
&#125;

Test: atest SignedConfigTest
</code></pre>
<p>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;InvalidConfigException.java<br>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignedConfig.java<br>services&#x2F;tests&#x2F;servicestests&#x2F;src&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignedConfigTest.java</p>
<pre><code>Implement signature check.

Currently, we just have debug keys, and always fail verification on
user builds. Production keys will be added later.

This CL also includes some helper scripts:
- Used to generate debug keys, for the record
- To sign data using the debug keys
- To verify base64 encoded data, used for debugging

Test: atest CtsSignedConfigHostTestCases
Note: The test also relies on some other changes going in too; it has
been verified with all relevant change in place, but will not pass at
HEAD quite yet.
</code></pre>
<p>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignatureVerifier.java<br>services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;signedconfig&#x2F;SignedConfigApplicator.java<br>tools&#x2F;signedconfig&#x2F;</p>
<h1 id="3-改动解析"><a href="#3-改动解析" class="headerlink" title="3. 改动解析"></a>3. 改动解析</h1><p>SystemServer启动注册监听, 在监听到<code>PackageAdd</code>或<code>ACTION_PACKAGE_REPLACED</code>广播后,启动<code>SignedConfigService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traceBeginAndSlog(<span class="string">&quot;SignedConfigService&quot;</span>);</span><br><span class="line">SignedConfigService.registerUpdateReceiver(mSystemContext);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SignedConfigService</span>(context).handlePackageBroadcast(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package MetaData:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> n<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;minSdk&quot;</span><span class="punctuation">:</span> n<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;maxSdk&quot;</span><span class="punctuation">:</span> n<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;global settings key&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value for key&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>解析<code>KEY_GLOBAL_SETTINGS</code>和<code>KEY_GLOBAL_SETTINGS_SIGNATURE</code>, 调用applyConfig, key为config, value为signature.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyConfig</span><span class="params">(String configStr, String signature)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkSignature(configStr, signature)) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Signature check on global settings in package &quot;</span> + mSourcePackage</span><br><span class="line">                + <span class="string">&quot; failed; ignoring&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SignedConfig config;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        config = SignedConfig.parse(configStr, ALLOWED_KEYS, KEY_VALUE_MAPPERS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidConfigException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Failed to parse global settings from package &quot;</span> + mSourcePackage, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentVersion</span> <span class="operator">=</span> getCurrentConfigVersion();</span><br><span class="line">    <span class="keyword">if</span> (currentVersion &gt;= config.version) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Global settings from package &quot;</span> + mSourcePackage</span><br><span class="line">                + <span class="string">&quot; is older than existing: &quot;</span> + config.version + <span class="string">&quot;&lt;=&quot;</span> + currentVersion);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We have new config!</span></span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Got new global settings from package &quot;</span> + mSourcePackage + <span class="string">&quot;: version &quot;</span></span><br><span class="line">            + config.version + <span class="string">&quot; replacing existing version &quot;</span> + currentVersion);</span><br><span class="line">    SignedConfig.<span class="type">PerSdkConfig</span> <span class="variable">matchedConfig</span> <span class="operator">=</span></span><br><span class="line">            config.getMatchingConfig(Build.VERSION.SDK_INT);</span><br><span class="line">    <span class="keyword">if</span> (matchedConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Settings is not applicable to current SDK version; ignoring&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Updating global settings to version &quot;</span> + config.version);</span><br><span class="line">    updateCurrentConfig(config.version, matchedConfig.values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/test/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作量评估:</p>
<h2 id="1-需求实现变更评估"><a href="#1-需求实现变更评估" class="headerlink" title="1. 需求实现变更评估"></a>1. 需求实现变更评估</h2><h3 id="1-1-原android4-4平台ums功能实现："><a href="#1-1-原android4-4平台ums功能实现：" class="headerlink" title="1.1. 原android4.4平台ums功能实现："></a>1.1. 原android4.4平台ums功能实现：</h3><ol>
<li>首先对应切换usb模式为mass_storage的功能：<br>上层setting中在usb连接界面中切换usb function，切换usb function为mass_storage后，由fw-usb层执行切换，设置usb的属性，init接收到属性变更后，触发usb driver切换usb工作方式变更到mass_storage</li>
<li>usb 模式切换为mass_storage后, 需要将sd卡设备地址给到pc端.<br>fw-usb层收到mass_storage模式的CONFIGURED事件上报后, 发送广播,上层setting app接收到广播后, 向fw-MountService发送启用ums的工作. MountService查询需要设置为ums工作模式的存储卷, 将该存储卷卸载, 卸载动作是通过socket发送给native vold服务. 在将存储卷执行pc-share, 也是通过socket发送给vold, 由vold执行.最终将sd卡的设备地址写到usb driver提供好的share地址上. share成功后, fw-mountService接收回调状态, 然后设置卷的状态变更广播, fw-usb接收到状态广播后, 发送通知.</li>
<li>对应关闭ums模式的工作<br>拔线或者在Setting中切换usb模式为其他, fw-usb层收到Disconneted事件后,发送广播,Setting接收到广播后,向fw-MountService发送关闭ums的工作. MountService查询处于shared状态的存储卷,通过socket向vold发送unshare命令, vold端执行unshare,清空usb driver的相对应路径, 再由MountService向vold发送mount命令, vold接收到后将存储卷挂载回手机上.</li>
</ol>
<h3 id="1-2-需求变更工作量评估"><a href="#1-2-需求变更工作量评估" class="headerlink" title="1.2. 需求变更工作量评估"></a>1.2. 需求变更工作量评估</h3><p>由于裁剪掉了fw&#x2F;app, 所以上述功能中的<code>fw-usb</code>&#x2F;<code>fw-MountService</code>&#x2F;<code>setting</code>的工作都不能work了, 需要将其中的工作转移到vold中实现. </p>
<ol>
<li>设置usb默认模式为mass_storage, adb. 并需要研发测试同事帮忙测下该模式的usb 连接稳定性.  1人&#x2F;天</li>
<li>vold接收USB的uevent事件, 接收到事件后对sd卡的share&#x2F;unshare功能. 2人&#x2F;天</li>
<li>公司内部严禁sd卡挂载到pc上使用, 因此需要向IT申请pc上sd卡挂载拷贝读写权限.   0.5人&#x2F;天</li>
<li>稳定性测试，连续插拔线场景电脑重启休眠等场景对pc／手机端来回挂载的稳定性。并进行debug 调试.  3人&#x2F;天</li>
<li>如果sd卡固化在机箱内部，不用考虑sd卡热插拔场景的适配。如果sd卡不是固化的，需要支持ums热插拔，2人&#x2F;天</li>
<li>该项目要求连usb线即启用ums功能, 故需要将usb模式固定为mass_storage, 不可变更. 封死usb模式切换功能. 2人&#x2F;天</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/vx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/vx/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          {"created_time":"2021-11-03T06:03:52Z","files":[{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"308","modified_time":"2021-11-03T06:03:52Z","name":"Android parcel 机制.md","signature":"45335015728712","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"309","modified_time":"2021-11-03T06:03:52Z","name":"Android权限管理.md","signature":"14750553613896","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"310","modified_time":"2021-11-03T06:03:52Z","name":"c++11语法.md","signature":"71079049700936","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"311","modified_time":"2021-11-03T06:03:52Z","name":"c++调试头文件.md","signature":"31960487568968","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"312","modified_time":"2021-11-03T06:03:52Z","name":"cts 跑测使用方法.md","signature":"40855364838984","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"313","modified_time":"2021-11-03T06:03:52Z","name":"debugfs.md","signature":"129473425057352","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"314","modified_time":"2021-11-03T06:03:52Z","name":"fde加密与解锁.md","signature":"77568745285192","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"315","modified_time":"2021-11-03T06:03:52Z","name":"fingerprint方案.md","signature":"93279735653960","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"316","modified_time":"2021-11-03T06:03:52Z","name":"gfm语法.md","signature":"16120648181320","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"317","modified_time":"2021-11-03T06:03:52Z","name":"incremental fs.md","signature":"69318113109576","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"318","modified_time":"2021-11-03T06:03:52Z","name":"Jni 基础学习文档.md","signature":"53358014637640","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"319","modified_time":"2021-11-03T06:03:52Z","name":"linux日记.md","signature":"69919408531016","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"320","modified_time":"2021-11-03T06:03:52Z","name":"PackageManagerService启动篇整理1.md","signature":"111653605746248","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"321","modified_time":"2021-11-03T06:03:52Z","name":"PackageManagerService启动篇整理2.md","signature":"71671755187784","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"322","modified_time":"2021-11-03T06:03:52Z","name":"Print框架整理.md","signature":"53813281171016","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"323","modified_time":"2021-11-03T06:03:52Z","name":"SignConfig服务.md","signature":"96848853476936","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"324","modified_time":"2021-11-03T06:03:52Z","name":"test.md","signature":"74892980659784","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"325","modified_time":"2021-11-03T06:03:52Z","name":"test1.md","signature":"85325456221768","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"326","modified_time":"2021-11-03T06:03:52Z","name":"并发编程笔记.md","signature":"55617167435336","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"327","modified_time":"2021-11-03T06:03:52Z","name":"文件IO测试.md","signature":"830564607560","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"328","modified_time":"2021-11-03T06:03:52Z","name":"文件加密.md","signature":"99623402350152","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"329","modified_time":"2021-11-03T06:03:52Z","name":"文件系统理解.md","signature":"14162143094344","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"330","modified_time":"2021-11-03T06:03:52Z","name":"文件系统知识1.md","signature":"87687688234568","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"331","modified_time":"2021-11-03T06:03:52Z","name":"设置中统一搜索接口实现.md","signature":"121489080854088","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"332","modified_time":"2021-11-03T06:03:52Z","name":"软件设计.md","signature":"69172084221512","tags":[]},{"attachment_folder":"","created_time":"2021-11-03T06:03:52Z","id":"333","modified_time":"2021-11-03T06:03:52Z","name":"通过adb install 安装apk.md","signature":"105176795063880","tags":[]}],"folders":[],"id":"307","modified_time":"2021-11-03T06:03:52Z","signature":"92021310236232","version":2}
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/Android%20parcel%20%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/Android%20parcel%20%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android parcel 机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android parcel 机制</p>
<h1 id="1-Serialize-说起"><a href="#1-Serialize-说起" class="headerlink" title="1. Serialize 说起"></a>1. Serialize 说起</h1><p>Java中的Serialize机制, 串行化机制,效率较慢:</p>
<ul>
<li>使用的反射机制</li>
<li>会生成很多临时文件,造成了垃圾回收</li>
</ul>
<p>将数据对象存入字节流中,在需要时重新生成对象.应用外部存储器保存对象状态,以及通过网络传输对象等.</p>
<blockquote>
<p>  串行化: 将对象转化成字节流,保存在存储设备\内存或二进制方式通过网络传输. 之后通过反串行化从连续的字节数据重新构建一个原始对象状态相同的对象.</p>
</blockquote>
<h1 id="2-Parcel-简介"><a href="#2-Parcel-简介" class="headerlink" title="2. Parcel 简介"></a>2. Parcel 简介</h1><p>Android工程师新设计了Parcel机制, 定位于轻量级的高效串行化和反串行化. 字节流主要保存在内存中, 用于IPC通信.</p>
<h1 id="3-Parcel-机制详解"><a href="#3-Parcel-机制详解" class="headerlink" title="3. Parcel 机制详解"></a>3. Parcel 机制详解</h1><h2 id="3-1-源码位置"><a href="#3-1-源码位置" class="headerlink" title="3.1. 源码位置"></a>3.1. 源码位置</h2><p>Frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Parcel.java<br>Frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp<br>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;Parcel.cpp</p>
<h3 id="3-1-1-Parcel-java"><a href="#3-1-1-Parcel-java" class="headerlink" title="3.1.1. Parcel.java"></a>3.1.1. Parcel.java</h3><ul>
<li>obtain() 获得一个新的parcel对象，相当于java中new一个对象</li>
</ul>
<p>从parcel池中拿出一个parcel. pool size 为6.取出不为空的parcel后, 将 pool池中的该对象设置为空. 如果池中都为空, 则新建一个parcel对象.</p>
<p>obtain的参数为内存的指针. </p>
<ul>
<li>recyle() 清空并回收parcel对象所占内存</li>
</ul>
<p>清空当前Parcel对象, 回收Parcel占用内存. 同时将该parcel对象重新放入parcel 池中. 调用完该方法后, 不能再使用该对象.</p>
<ul>
<li>dataSize() 得到当前parcel对象的实际存储空间 </li>
<li>dataCapacity() 得到当前parcel对象的已分配的存储空间,该值大于或等于dataSize()返回值 。</li>
<li>dataPostion() 获得当前parcel对象的偏移量(类似于文件流指针的偏移量) </li>
<li>setDataPosition() 设置偏移量（类似于移动指针到特定位置）</li>
<li>writeXXX（）方法表示写于一个XXX类型的数</li>
<li>readXXX（）方法表示读取一个XXX类型的数</li>
</ul>
<p>比如：writeInt(int) 写入一个整数；readInt（）读取一个整数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Android权限管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 10:23:47" itemprop="dateModified" datetime="2024-04-16T10:23:47+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Android权限管理"><a href="#1-Android权限管理" class="headerlink" title="1. Android权限管理"></a>1. Android权限管理</h1><blockquote>
<p>  原作者： xiaoguang.dong</p>
</blockquote>
<h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1. 基本概念"></a>1.1. 基本概念</h2><h3 id="1-1-1-AndroidManifest权限相关标签"><a href="#1-1-1-AndroidManifest权限相关标签" class="headerlink" title="1.1.1. AndroidManifest权限相关标签"></a>1.1.1. AndroidManifest权限相关标签</h3><p><img src="/../images/permissionimage9.png" alt="permissionimage9"></p>
<h4 id="1-1-1-1-permission-标签"><a href="#1-1-1-1-permission-标签" class="headerlink" title="1.1.1.1. permission 标签"></a>1.1.1.1. permission 标签</h4><p><img src="/images/permissionimage10.png" alt="permissionimage10"></p>
<blockquote>
<ul>
<li><code>permission</code>标签用于声明一个权限</li>
<li><code>android:name</code> 指定权限名称</li>
<li><code>android:protectionLevel</code>指定权限的保护级别</li>
<li><code>android:protectionLevel</code>指定权限的保护级别</li>
</ul>
</blockquote>
<p><img src="/images/permissionimage11.png" alt="permissionimage11"></p>
<h4 id="1-1-1-2-uses-permission标签"><a href="#1-1-1-2-uses-permission标签" class="headerlink" title="1.1.1.2. uses-permission标签"></a>1.1.1.2. uses-permission标签</h4><p><img src="/images/permissionimage12.png" alt="permissionimage12"></p>
<ul>
<li><code>&lt;uses-permission&gt;</code>用于申请特定权限</li>
<li><code>android:name</code>指定申请的权限名称</li>
<li><code>android:maxSdkVersion</code>用于指定可被授权的最高的<code>API level</code></li>
</ul>
<blockquote>
<p>在4.4平台(API level 19)之前，使用某个接口依赖于权限A；但是在4.4平台上A权限已经被废弃或者该接口已经不依赖于A权限，那么可以做如下配置：<code>&lt;uses-permission android:name=“A” android:maxSdkVersion=“18”/&gt;</code>那么在4.4平台之后，系统将不会授予应用A权限</p>
</blockquote>
<h4 id="1-1-1-3-permission-group标签"><a href="#1-1-1-3-permission-group标签" class="headerlink" title="1.1.1.3. permission-group标签"></a>1.1.1.3. permission-group标签</h4><p><img src="/images/permissionimage13.png" alt="permissionimage13"></p>
<ul>
<li><code>&lt;permission-group&gt;</code>用于标记权限的逻辑分组。</li>
<li><code>android:name</code>用于指定权限组的名称。</li>
<li><code>android:label</code>用于指定权限组的标签。</li>
<li><code>android:descriptiopn</code>用于指定权限组的描述信息。</li>
<li><code>android:icon</code>用于指定权限组的图标。</li>
</ul>
<blockquote>
<p>  如果权限有<code>Permission-group</code>属性，用户在<code>Setting</code>权限界面看到的就是permission-<code>group</code>的<code>label</code>和<code>description</code>，否则使用<code>permission</code>本身的<code>label</code>和<code>description</code>。</p>
</blockquote>
<p><img src="/images/permissionimage14.png" alt="permissionimage14"></p>
<h4 id="1-1-1-4-permission-tree标签"><a href="#1-1-1-4-permission-tree标签" class="headerlink" title="1.1.1.4. permission-tree标签"></a>1.1.1.4. permission-tree标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission-tree</span> <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span> ]</span></span><br><span class="line"><span class="tag">                 <span class="attr">android:name</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  注意这个元素自身不声明一个权限，只是一个名字空间，更多的权限可以被放置在它里面。</p>
</blockquote>
<ul>
<li><code>&lt;permission-tree&gt;</code>用于定义一组权限的命名空间。作用是可以使程序在运行时动态声明权限。</li>
<li><code>android:name</code>用于指定权限树根节点的名称。</li>
<li><code>android:label</code> 组的用户可读名称, 标签可以直接设置为一个原始字符串， 使它可以像用户界面中的其它字符串那样被本地化。</li>
</ul>
<blockquote>
<p>  如果某个应用使用了<code>&lt;permission-tree&gt;</code>标签，可以通过调用<code>PackageManager.addPermission()</code>方法来动态声明新权限。假如根节点的名称是<code>com.sprd.core</code>，则可以声明如下权限： <code>com.sprd.core.CONTACTS </code>       <code>com.sprd.core.MMS</code>…</p>
</blockquote>
<h3 id="1-1-2-权限控制"><a href="#1-1-2-权限控制" class="headerlink" title="1.1.2. 权限控制"></a>1.1.2. 权限控制</h3><h4 id="1-1-2-1-四大组件权限检查"><a href="#1-1-2-1-四大组件权限检查" class="headerlink" title="1.1.2.1. 四大组件权限检查"></a>1.1.2.1. 四大组件权限检查</h4><p><img src="/images/permissionimage16.png" alt="permissionimage16"></p>
<ul>
<li><code>android:permission</code>适用于<code>activity</code>&#x2F;<code>service</code>&#x2F;<code>provider</code>&#x2F;<code>receiver</code>标签。</li>
</ul>
<blockquote>
<p>  以<code>activity</code>为例，假如服务端<code>activity</code>配置了<code>android:permission</code>属性，客户端在调用 <code>startActivity()</code> 或<code>startActivityForResult()</code>启动服务端<code>activity</code>时，如果没有被授予指定权限，其 <code>Intent</code> 将不会传递给服务端<code>Activity</code>。如果未设置该属性，则对 <code>Activity</code> 应用 <code>&lt;application&gt;</code> 元素的 <code>permission</code> 属性设置的权限。 如果这两个属性均未设置，则 <code>Activity</code> 不受权限保护。</p>
</blockquote>
<h4 id="1-1-2-2-shareUserId-属性"><a href="#1-1-2-2-shareUserId-属性" class="headerlink" title="1.1.2.2. shareUserId 属性"></a>1.1.2.2. shareUserId 属性</h4><p><img src="/images/permissionimage17.png" alt="permissionimage17"></p>
<p><img src="/images/permissionimage18.png" alt="permissionimage18"></p>
<ul>
<li><code>android:SharedUserId</code>指定与其它应用共享一个<code>UID</code>，只有两个使用相同证书签名（并且请求相同的 <code>sharedUserId</code>）的应用才被分配同一<code>UID</code>。通过共享<code>UID</code>，不同的<code>APK</code>之间可以实现数据共享。</li>
</ul>
<blockquote>
<p>  <code>PackageManager</code>初始化时默认提供<code>6</code>个系统级<code>sharedUserId</code>，均使用<code>platform</code>证书验证。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android.uid.system</span><br><span class="line">android.uid.phone</span><br><span class="line">android.uid.log</span><br><span class="line">android.uid.shell</span><br><span class="line">android.uid.nfc</span><br><span class="line">android.uid.bluetooth</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-3-权限级别-ProtectionLevel"><a href="#1-1-2-3-权限级别-ProtectionLevel" class="headerlink" title="1.1.2.3. 权限级别&#x2F;ProtectionLevel"></a>1.1.2.3. 权限级别&#x2F;ProtectionLevel</h4><h5 id="1-1-2-3-1-normal"><a href="#1-1-2-3-1-normal" class="headerlink" title="1.1.2.3.1. normal"></a>1.1.2.3.1. normal</h5><p>低风险权限，只要申请了就可以使用（在AndroidManifest.xml中添加uses-permission标签），安装时不需要用户确认</p>
<h5 id="1-1-2-3-2-Dangerous"><a href="#1-1-2-3-2-Dangerous" class="headerlink" title="1.1.2.3.2. Dangerous"></a>1.1.2.3.2. Dangerous</h5><p>高风险权限，需要用户的确认才可被授权</p>
<h5 id="1-1-2-3-3-Signature"><a href="#1-1-2-3-3-Signature" class="headerlink" title="1.1.2.3.3. Signature"></a>1.1.2.3.3. Signature</h5><p>当申请权限的APK与声明此权限的APK的使用的签名证书相同时，才能被授权</p>
<h5 id="1-1-2-3-4-SignatureOrSystem"><a href="#1-1-2-3-4-SignatureOrSystem" class="headerlink" title="1.1.2.3.4. SignatureOrSystem"></a>1.1.2.3.4. SignatureOrSystem</h5><ol>
<li>当申请权限的APK与声明此权限的APK的使用的签名证书相同时，才能被授权。</li>
<li>申请权限的应用为系统应用</li>
</ol>
<h4 id="1-1-2-4-Signature-vs-SignatureOrSystem"><a href="#1-1-2-4-Signature-vs-SignatureOrSystem" class="headerlink" title="1.1.2.4. Signature vs SignatureOrSystem"></a>1.1.2.4. Signature vs SignatureOrSystem</h4><ul>
<li>针对<code>ProtectionLevel</code>中<code>signatureOrSystem</code>的应用，有如下应用场景：如果有多个不同的厂商同时在<code>system/app</code>下预制了多个不同的<code>APK</code>，每个<code>APK</code>签名使用的证书是不同的。但是这些<code>APK</code>之间彼此还希望访问对方的一些数据。此时就可以使用<code>signatureOrSystem</code>权限来保护应用数据。</li>
<li>与之而来的问题在于，所有<code>/system/app</code>下的应用都可以访问用<code>signatureOrSystem</code>访问的数据，虽然可以用<code>getCallingUid</code>,<code>getCallingPackage</code>来确认访问者的身份。但是这里是存在隐患的。</li>
<li>添加<code>priva-app</code>目录解决了这个问题。在<code>4.4</code>以后<code>SignatureOrSystem</code>级别的权限只有具有相同签名，或者预制在<code>priv-app</code>下的应用才被授权。</li>
<li>默认情况下预制在<code>priv-app</code>下的应用必须<code>Google</code>原生应用或是<code>OEM</code>厂商确保安全的第三方应用。</li>
</ul>
<h4 id="1-1-2-5-定义权限作用？怎样通过权限实现应用数据和资源的保护？"><a href="#1-1-2-5-定义权限作用？怎样通过权限实现应用数据和资源的保护？" class="headerlink" title="1.1.2.5. 定义权限作用？怎样通过权限实现应用数据和资源的保护？"></a>1.1.2.5. 定义权限作用？怎样通过权限实现应用数据和资源的保护？</h4><ul>
<li>程序的基础是<code>代码</code>和<code>数据</code>，所以定义权限的两个目的就是控制<code>代码执行流程</code>和<code>保护数据/文件</code>。</li>
<li>针对<code>AndroidManifest</code>中定义的各种权限，其权限的授权状态都会存储在<code>PackageManagerService</code>中，<code>系统/APP</code>可以通过<code>PackageManager</code>相关接口来检查调用端进程<code>UID</code>是否具有特定权限，进而决定是否允许其进一步执行代码或者访问数据&#x2F;文件。可以将<code>PackageManager</code>看做一个权限管理的中转站。</li>
</ul>
<p><img src="/images/permissionimage19.png" alt="permissionimage19"></p>
<h4 id="1-1-2-6-Native层的权限控制"><a href="#1-1-2-6-Native层的权限控制" class="headerlink" title="1.1.2.6. Native层的权限控制"></a>1.1.2.6. Native层的权限控制</h4><p>Native层的权限控制建立在Linux已有的uid&#x2F;gid&#x2F;gids基础上的。</p>
<ul>
<li><code>UID</code>: <code>Android</code> 每安装一个应用程序，就会为它分配一个 <code>uid</code> 。其中普通 <code>Android</code> 应用程序的 <code>uid</code> 是从 <code>10000</code> 开始分配 （<code>Process.FIRST_APPLICATION_UID </code>）， <code>10000</code> 以下是系统应用预留的 <code>uid</code> </li>
<li><code>GID</code>: 对于普通应用程序来说， <code>gid</code> 等于 <code>uid</code> 。</li>
<li>由于每个应用程序的 <code>uid</code> 和 <code>gid</code> 都不相同， 因此不管是 <code>native</code> 层还是 <code>java</code> 层都能够达到保护私有数据的作用。</li>
<li><code>GIDS</code>: 在 <code>Apk</code>安装过程中生成，与申请的具体权限相关。 如果APK某个申请的<code>permission</code> 被 <code>granted</code> ，而且这个权限在<code>/system/etc/permisions/*xml</code>中有对应的 <code>gid</code>， 那么 这个 Apk对应的进程<code>gids</code>中将 包含<code>xml</code>中配置的<code>gid</code>。</li>
</ul>
<p><code>Eg</code>: 在<code>Android5.1</code>平台上，应用申请了如下权限：<code>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;  </code>，同时在<code>frameworks\base\data\etc\Platform.xml</code>中由如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">gid</span>=<span class="string">&quot;sdcard_rw&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">permission</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>对于申请<code>WRITE_EXTERNAL_STORAGE</code>特权的应用，进程的<code>gids</code>就包含了<code>sdcard_rw</code>，就可以对<code>sd</code>卡中的文件进行操作。</p>
<h2 id="1-2-运行时权限"><a href="#1-2-运行时权限" class="headerlink" title="1.2. 运行时权限"></a>1.2. 运行时权限</h2><ul>
<li><code>normal</code>&#x2F;<code>signature</code>&#x2F;<code>signatureOrSystem</code>会在<code>App</code>安装时判断是否授权，可以看做是安装时权限。</li>
<li>从<code>AndroidM</code>开始，<code>Google</code>提出了运行时权限(<code>runtime permission</code>)的概念。针对<code>protectionLevle</code>为<code>dangerous</code>的权限，在安装时默认不授权，而是在运行时由用户动态授权。</li>
<li>对于运行时权限，要求App在代码中做一定的适配，在运行时动态向用户请求相关权限。</li>
<li>在多用户模式下，所有用户共享安装时权限，独占运行时权限。</li>
</ul>
<p><code>Android</code>定义的Runtime权限一览共9组25个：</p>
<p><img src="/images/permissionimage20.png" alt="permissionimage20"></p>
<p><img src="/images/permissionimage21.png" alt="permissionimage21"></p>
<p><img src="/images/permissionimage22.png" alt="permissionimage22"></p>
<p><img src="/images/permissionimage23.png" alt="permissionimage23"></p>
<p><img src="/images/permissionimage24.png" alt="permissionimage24"></p>
<p><img src="/images/permissionimage25.png" alt="permissionimage25"></p>
<h3 id="1-2-1-注意事项"><a href="#1-2-1-注意事项" class="headerlink" title="1.2.1. 注意事项"></a>1.2.1. 注意事项</h3><blockquote>
<ol>
<li>如果应用开发时使用的<code>targetSDK</code>低于<code>23</code>，在安装到<code>M</code>和以上平台时，考虑到不支持动态权限相关的接口。系统会默认授予所有权限。</li>
<li>同一组的任何一个权限被授权了，其他权限也自动被授权。不需要重复申请。</li>
<li>只申请需要的权限，需要的时候再申请权限；每次权限申请，都会弹出权限申请窗口，打断用户的操作。建议只申请你需要的权限。</li>
<li><code>Setting</code>中动态关闭权限会导致进程被<code>Kill</code>。</li>
<li>权限请求需要弹出<code>Dialog</code>，因此请求代码要添加到<code>Activity</code>或<code>Fragment</code>中</li>
<li>尽可能避免在<code>Service</code>中申请权限。如果确实需要，要做一个<code>work around</code>。比如弹出一个<code>Notification</code>，提醒用户缺少相关权限。当用户点击<code>Notification</code>在弹出权限申请框，继续权限申请流程。</li>
</ol>
</blockquote>
<h2 id="1-3-默认授权机制"><a href="#1-3-默认授权机制" class="headerlink" title="1.3. 默认授权机制"></a>1.3. 默认授权机制</h2><ul>
<li>为了确保<code>Android</code>原生应用，或者<code>GMS</code>包中的应用在开机后具有必需的权限。比如<code>CameraApp</code>默认授予<code>Camera Group</code>相关权限，<code>Contacts</code>默认授予<code>Contacts Group</code>相关权限….</li>
<li><code>PackageManager</code>默认在首次开机&#x2F;恢复出厂设置后，对一部分系统应用默认授予一些必需的权限。</li>
</ul>
<h3 id="1-3-1-首次开机时默认授权的应用"><a href="#1-3-1-首次开机时默认授权的应用" class="headerlink" title="1.3.1. 首次开机时默认授权的应用"></a>1.3.1. 首次开机时默认授权的应用</h3><p>应用使用<code>requestPermissions</code>接口申请运行时权限，首次开机时，满足下列条件时，会对相应的权限进行授予：</p>
<ul>
<li><code>UID</code> &lt; <code>10000</code>的应用</li>
<li>同时满足如下条件的应用：<ol>
<li>预制在<code>/system/priv-app</code>下。</li>
<li><code>Application</code>标签中配置了<code>android:persistence=“true”</code>。</li>
<li>使用<code>Platform</code>证书签名。</li>
</ol>
</li>
<li>通过<code>Intent</code>匹配查询出的默认应用，为其授予合适分组的权限。<ul>
<li>以<code>Music</code>为例，代码中会自动匹配如下<code>Intent</code>对应的<code>component</code>：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">musicIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW);</span><br><span class="line">musicIntent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">musicIntent.setDataAndType(Uri.fromFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;foo.mp3&quot;</span>)), AUDIO_MIME_TYPE);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  默认情况下，<code>6.0</code>和<code>7.0</code>下匹配结果是不一致的。如果有多个同类型的应用，在<code>6.0</code>上会根据返回结果取第一个元素进行授权；在<code>7.0</code>上则会进行一系列比较，选出<em>优先级最高</em>的那个进行授权。<em>如果前两个元素的优先级相同，则不会对任何一个匹配到的元素授权</em>。</p>
</blockquote>
<ul>
<li>对于首次开机授权的应用，有一部分权限是<em><strong>系统固定</strong></em>的，用户无法修改。在<code>Setting-&gt;APP</code>中也看不到对应的权限状态。</li>
<li>修改<strong>默认授权</strong>的逻辑会导致<code>GTS CASE</code>失败。</li>
</ul>
<h3 id="1-3-2-查看Package当前的权限状态"><a href="#1-3-2-查看Package当前的权限状态" class="headerlink" title="1.3.2. 查看Package当前的权限状态"></a>1.3.2. 查看Package当前的权限状态</h3><p>通过<code>adb shell dumpsys package </code>可以查看某个Package当前的权限状态：</p>
<p><img src="/images/permissionimage26.png" alt="permissionimage26"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/c++%E8%B0%83%E8%AF%95%E5%A4%B4%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/c++%E8%B0%83%E8%AF%95%E5%A4%B4%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Effective Modern C++ 11 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-15 17:59:59 / 修改时间：19:03:42" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug/" itemprop="url" rel="index"><span itemprop="name">debug</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-本地调试使用C-相关"><a href="#1-本地调试使用C-相关" class="headerlink" title="1. 本地调试使用C++相关"></a>1. 本地调试使用C++相关</h1><p><code>strstr strcmp strcpy</code>的头文件在&lt;string.h&gt;中<br><code>std::string</code>的头文件在<string>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>编译时需要使用如下命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -lstdc++ &lt;abc.cpp&gt;</span><br></pre></td></tr></table></figure>

<p>选择c++11编译的命令为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std=c++11 &lt;abc.cpp&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/linux%E6%97%A5%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/linux%E6%97%A5%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 17:59:59" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-重置软件包"><a href="#1-重置软件包" class="headerlink" title="1. 重置软件包"></a>1. 重置软件包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --configure -a</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt --fix-broken install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">build相关的包重新安装</span></span><br><span class="line">sudo apt-get install --reinstall build-essential</span><br></pre></td></tr></table></figure>
<h1 id="2-查找软件包"><a href="#2-查找软件包" class="headerlink" title="2. 查找软件包"></a>2. 查找软件包</h1><p>apt-cache search    &lt;module名&gt; 如XML::Simple</p>
<h1 id="3-c-链接"><a href="#3-c-链接" class="headerlink" title="3. c++ 链接"></a>3. c++ 链接</h1><p>C&#x2F;C++程序在linux下被编译和连接时，GCC&#x2F;G++会查找系统默认的include和link的路径，以及自己在编译命令中指定的路径。自己指定的路径就不说了，这里说明一下系统自动搜索的路径。</p>
<h2 id="3-1-include头文件路径"><a href="#3-1-include头文件路径" class="headerlink" title="3.1. include头文件路径"></a>3.1. include头文件路径</h2><p>除了默认的&#x2F;usr&#x2F;include, &#x2F;usr&#x2F;local&#x2F;include等include路径外，还可以通过设置环境变量来添加系统include的路径：<br>    # C<br>    export C_INCLUDE_PATH&#x3D;XXXX:$C_INCLUDE_PATH<br>    # CPP<br>    export CPLUS_INCLUDE_PATH&#x3D;XXX:$CPLUS_INCLUDE_PATH</p>
<p>以上修改可以直接命令行输入（一次性），可以在&#x2F;etc&#x2F;profile中完成（对所有用户生效），也可以在用户home目录下的.bashrc或.bash_profile中添加（针对某个用户生效），修改完后重新登录即生效。</p>
<h2 id="3-2-link链接库文件路径"><a href="#3-2-link链接库文件路径" class="headerlink" title="3.2. link链接库文件路径"></a>3.2. link链接库文件路径</h2><pre><code>链接库文件在连接（静态库和共享库）和运行（仅限于使用共享库的程序）时被使用，其搜索路径是在系统中进行设置的（也可以在编译命令中通过 -l  -L 来指定，这里讲的是使用系统默认搜索路径）。
一般 Linux 系统把 /lib  /usr/lib  /usr/local/lib 作为默认的库搜索路径，所以使用这几个目录中的链接库文件可直接被搜索到（不需要专门指定链接库路径）。对于默认搜索路径之外的库，则需要将其所在路径添加到gcc/g++的搜索路径之中。
链接库文件的搜索路径指定有两种方式：
1）修改/etc/so.ld.conf
2）修改环境变量，在其中添加自己的路径
</code></pre>
<ol>
<li><p>在环境变量中添加<br>动态链接库搜索路径：</p>
<p>export LD_LIBRARY_PATH&#x3D;XXX:$LD_LIBRARY_PATH<br>静态链接库搜索路径：<br>export LIBRARY_PATH&#x3D;XXX:$LIBRARY_PATH<br>以上修改可以直接命令行输入（一次性），可以在&#x2F;etc&#x2F;profile中完成（对所有用户生效），也可以在用户home目录下的.bashrc或.bash_profile中添加（针对某个用户生效）,修改完后重新登录即生效。</p>
</li>
<li><p>在&#x2F;etc&#x2F;ld.so.conf 中添加指定的链接库搜索路径（需要root权限），然后运行 &#x2F;sbin&#x2F;ldconfig，以达到刷新 &#x2F;etc&#x2F;ld.so.cache的效果。</p>
<p> 以上两种方式均可以达到指定链接库搜索路径的效果。</p>
</li>
</ol>
<h1 id="4-TensorFlow"><a href="#4-TensorFlow" class="headerlink" title="4. TensorFlow"></a>4. TensorFlow</h1><p>The script tensorboard is installed in ‘&#x2F;home&#x2F;local&#x2F;SPREADTRUM&#x2F;liguang.zhang&#x2F;.local&#x2F;bin’ which is not on PATH.</p>
<p>tensorboard  –logdir&#x3D;’&#x2F;tmp&#x2F;tensorflow&#x2F;mnist&#x2F;logs&#x2F;mnist_with_summaries’</p>
<h1 id="5-python环境"><a href="#5-python环境" class="headerlink" title="5. python环境"></a>5. python环境</h1><p>python 中文</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#coding=GBK?</span></span><br></pre></td></tr></table></figure>
<p>python 安装软件包</p>
<blockquote>
<p>pip3 install matplotlib –user  -i <a target="_blank" rel="noopener" href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p>
</blockquote>
<h1 id="6-手机shell环境"><a href="#6-手机shell环境" class="headerlink" title="6. 手机shell环境"></a>6. 手机shell环境</h1><p>执行的命令都在&#x2F;system&#x2F;bin下或vendor&#x2F;bin下<br>通常是以链接的方式挂到toolbox或toybox下.<br>对于android环境相关的具体命令, 如不清楚使用规则, 可以使用<cmd> –help的方式查看手册</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br><span class="line">ps --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>不要只会从网上查, 查手册的方式往往更加方便<br>如<code>ls -ln</code> 将uid&#x2F;gid以number的方式列出, 更加直观.</p>
<h2 id="6-1-抓文件变化的脚本"><a href="#6-1-抓文件变化的脚本" class="headerlink" title="6.1. 抓文件变化的脚本"></a>6.1. 抓文件变化的脚本</h2><p>将文件push到手机中, 后面跟目录, 就可以抓出某个目录下文件的变化:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line">path=<span class="variable">$1</span></span><br><span class="line">inotifywait -mr --timefmt <span class="string">&#x27;%d/%m/%y/%H:%M:%S&#x27;</span> --format <span class="string">&#x27;%e %T %w %f&#x27;</span> -e modify,delete,create,attrib <span class="variable">$path</span></span><br></pre></td></tr></table></figure>
<p>监听事件为-e后面的, 根据情况修改监听类型即可</p>
<h1 id="7-安装rime输入法"><a href="#7-安装rime输入法" class="headerlink" title="7. 安装rime输入法"></a>7. 安装rime输入法</h1><p>ibus-rime<br>和 fcitx-rime</p>
<h1 id="8-安装albert"><a href="#8-安装albert" class="headerlink" title="8. 安装albert"></a>8. 安装albert</h1><p>源码安装歩骤:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/albertlauncher/albert.git</span><br><span class="line">mkdir albert-build</span><br><span class="line">cd albert-build</span><br><span class="line">cmake ../albert -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>依赖QT5.5, C++14<br>qt可以安装qt5.7版本,  安装完成后需要设置相关的环境变量.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> QTDIR=/opt/Qt5.7.1/5.7/gcc_64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$QTDIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> MANPATH=<span class="variable">$QTDIR</span>/man:<span class="variable">$MANPATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$QTDIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
<p>c++14需要把g++版本替换为g++5<br>安装依赖c++14, 安装过程中Qcharts项不好使, 直接在cmake中禁用即可<br>在startup中加albert加到开机项中.</p>
<p>window_swither启用窗口切换控件, 需要安装wmctrl</p>
<h1 id="9-linux-shell"><a href="#9-linux-shell" class="headerlink" title="9. linux shell"></a>9. linux shell</h1><p>考虑用rsync替代cp和scp.<br>rsync可以显示进度条</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -a --stats --progress /home/tim/stuff /home/tim/documents</span><br></pre></td></tr></table></figure>
<p>可以替代scp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -a --stats --progress /home/tim/stuff    tim@foo.example.com:/home/tim/</span><br><span class="line">rsync -a --stats --progress tim@foo.example.com:/home/tim/stuff     /home/tim/</span><br></pre></td></tr></table></figure>
<p>scp不能拷贝链接, rsync可以正常拷贝<br>rsync为增量拷贝,  有更新的文件才进行拷贝</p>
<h1 id="10-android-测试框架"><a href="#10-android-测试框架" class="headerlink" title="10. android 测试框架"></a>10. android 测试框架</h1><p>执行测试命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am instrument -w -r   -e debug false -e class &#x27;org.greenrobot.eventbus.EventBusTestDemo#testRegister&#x27; org.greenrobot.eventbus.eventbustestdemo/android.support.test.runner.AndroidJUnitRunner</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/c++11%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/15/%E5%85%B6%E4%BB%96%E8%B0%83%E7%A0%94/c++11%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Effective Modern C++ 11 笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-15 17:59:59 / 修改时间：19:03:04" itemprop="dateCreated datePublished" datetime="2024-04-15T17:59:59+08:00">2024-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Effective Modern C++ 11 笔记</p>
</blockquote>
<h1 id="1-型别推导"><a href="#1-型别推导" class="headerlink" title="1. 型别推导"></a>1. 型别推导</h1><h2 id="1-1-条款1-理解模型型别推导"><a href="#1-1-条款1-理解模型型别推导" class="headerlink" title="1.1. 条款1 理解模型型别推导"></a>1.1. 条款1 理解模型型别推导</h2><blockquote>
<p>理解 auto 和 decltype</p>
</blockquote>
<p>伪代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(expr); <span class="comment">//以表达式调用f</span></span><br></pre></td></tr></table></figure>
<p>编译期间, 编译器通过expr推导两个型别: T 和 ParamType<br>T的型别推导结果, 不仅仅依赖表达式<code>expr</code>的型别, 还依赖ParamType的形式, 分下面三种情况:</p>
<ul>
<li>ParamType具有指针或引用型别, 但不是万能引用(条款24)</li>
<li>ParmaType 是万能引用</li>
<li>ParamType 非指针也非引用</li>
</ul>
<h3 id="1-1-1-ParamType具有指针或引用型别"><a href="#1-1-1-ParamType具有指针或引用型别" class="headerlink" title="1.1.1. ParamType具有指针或引用型别"></a>1.1.1. ParamType具有指针或引用型别</h3><ol>
<li>expr 具有引用类型, 先将引用忽略</li>
<li>执行模式匹配, 决定T的型别</li>
</ol>
<p>ParamType 引用类型<br>ex:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(T&amp; param);</span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;    <span class="comment">//T-&gt;const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;   <span class="comment">//T-&gt;const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(x);     <span class="comment">//T-&gt;int        ParamType-&gt;int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);    <span class="comment">//T-&gt;const int  ParamType-&gt;const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);    <span class="comment">//T-&gt;const int  ParamType-&gt;const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>ParamType指针类型<br>ex:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *px = &amp;x;     px-&gt;<span class="function"><span class="type">const</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(&amp;x)</span></span>;            <span class="comment">// int, int*</span></span><br><span class="line"><span class="built_in">f</span>(px);            <span class="comment">//   const int, const int *</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-ParamType-是万能引用"><a href="#1-1-2-ParamType-是万能引用" class="headerlink" title="1.1.2. ParamType 是万能引用"></a>1.1.2. ParamType 是万能引用</h3><blockquote>
<p>万能引用 T&amp;&amp;</p>
</blockquote>
<ul>
<li>如<code>expr</code>是左值, T和ParamType都为左值引用</li>
<li><code>expr</code>是右值, 符合情况1中的规则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;    <span class="comment">//T-&gt;const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;   <span class="comment">//T-&gt;const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(x);     <span class="comment">//int&amp;, int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);    <span class="comment">//const int&amp;, const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);    <span class="comment">//const int&amp;, const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);       <span class="comment">// 27是右值, T变为int, ParamType为int&amp;&amp;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-3-ParamType非指针也非引用"><a href="#1-1-3-ParamType非指针也非引用" class="headerlink" title="1.1.3. ParamType非指针也非引用"></a>1.1.3. ParamType非指针也非引用</h3><blockquote>
<p>按值传递, 形参是原对象的一份拷贝</p>
</blockquote>
<ul>
<li><code>expr</code>如具有引用, 则忽略</li>
<li>忽略后, 若还是const, 也忽略.若是volatile, 也忽略<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(x);</span><br><span class="line"><span class="built_in">f</span>(cx);      都是<span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(rx)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = <span class="string">&quot;abc&quot;</span>;    <span class="comment">//p-&gt;const char* const</span></span><br><span class="line"><span class="built_in">f</span>(p);                             <span class="comment">//推导为const char*    指针指向的内容不能更改, 但指针可以指向其他的地方</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-4-数组实参"><a href="#1-1-4-数组实参" class="headerlink" title="1.1.4. 数组实参"></a>1.1.4. 数组实参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;who&quot;</span>;    <span class="comment">//const char [4]</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pname = name      <span class="comment">// pname-&gt; const char* 退化为指针</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(T param);</span><br><span class="line"><span class="built_in">f</span>(name);                 <span class="comment">// const char*  退化为指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;       <span class="comment">//没有退化, ParamType const char (&amp;)[4]</span></span><br></pre></td></tr></table></figure>
<p>可以通过编译器常量形式返回数组尺寸</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> nameCopy[<span class="built_in">arraySize</span>(name)];</span><br></pre></td></tr></table></figure>
<h3 id="1-1-5-函数实参"><a href="#1-1-5-函数实参" class="headerlink" title="1.1.5. 函数实参"></a>1.1.5. 函数实参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;           <span class="comment">// 按值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;          <span class="comment">// 按引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>*)</span></span>;       <span class="built_in">void</span>(<span class="type">int</span>, <span class="type">char</span>*)</span><br><span class="line"><span class="built_in">f</span>(someFunc);                     <span class="comment">// void (*)(int, char*)  退化成指针</span></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                    <span class="comment">// void (&amp;)(int, char*)</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-6-要点速记"><a href="#1-1-6-要点速记" class="headerlink" title="1.1.6. 要点速记"></a>1.1.6. 要点速记</h3><ul>
<li>在模板性别推导过程中, 具有引用型别的实参会被当成非引用型别来处理, 引用性被忽略</li>
<li>对万能引用形参, 左值实参会进行特殊处理</li>
<li>按值传递的形参, 是拷贝复制, const 和 volatile被丢弃</li>
<li>数组或函数型的实参会退化成对应的指针, 除非被用来初始化引用</li>
</ul>
<h2 id="1-2-条款2-理解auto型别推导"><a href="#1-2-条款2-理解auto型别推导" class="headerlink" title="1.2. 条款2 理解auto型别推导"></a>1.2. 条款2 理解auto型别推导</h2><blockquote>
<p>和模板型别推导类似, 修饰的左值的类型极为模板型别推导中的ParamType<br>ex:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x= <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = cx;      <span class="comment">// rx的类型为ParamType   const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x; <span class="comment">//万能引用,形参为左值 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = rx;   <span class="comment">// const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>;    <span class="comment">// 形参为右值, int&amp;&amp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> s=name;     <span class="comment">//退化为指针, 不同于按值传递   const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; s1=name; <span class="comment">//const char (&amp;)[4]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = someFunc;  <span class="comment">// 退化为指针, void (*)(int, char*)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; f1 = someFunc; <span class="comment">//void (&amp;)(int, char*)</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-1-跟模板不同的例外情况"><a href="#1-2-1-跟模板不同的例外情况" class="headerlink" title="1.2.1. 跟模板不同的例外情况:"></a>1.2.1. 跟模板不同的例外情况:</h3><p>当采用auto声明的变量使用{}初始化表达式来进行初始化时, 得到的型别是<code>std::initializer_list</code>, 而模板推导不出来, 编译错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);   <span class="comment">//error</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">auto</span> retV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newVal) &#123;v = newVal;&#125;;</span><br><span class="line"><span class="built_in">retV</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用auto {}统一初始化时注意std::initializer_list的情况<br>lambda表达式的形参中使用auto, 是使用模板型别推导而非auto型别推导, 传递{}表达式实参会有编译报错的情况</p>
</blockquote>
<h3 id="1-2-2-要点速记"><a href="#1-2-2-要点速记" class="headerlink" title="1.2.2. 要点速记"></a>1.2.2. 要点速记</h3><ul>
<li>一般情况下, auto型别推导 &#x3D; 模板型别推导, 但使用{}初始化表达式会产生<code>std::initializer_list</code>, 而模板会报错</li>
<li>在函数返回值中或lambda表达式的形参中使用auto, 不能传递{}表达式实参.</li>
</ul>
<h2 id="1-3-条款3-理解decltype"><a href="#1-3-条款3-理解decltype" class="headerlink" title="1.3. 条款3 理解decltype"></a>1.3. 条款3 理解decltype</h2><p>decltype返回给定的名字或表达式的确切类型</p>
<blockquote>
<p>主要用于声明那些返回值型别依赖于形参型别的函数模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(c[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数含有型别T对象的容器的operator []会返回T&amp;, 但在模型型别推导中, 初始化表达式的引用会被丢弃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;   <span class="comment">//编译error, 引用性被丢弃</span></span><br></pre></td></tr></table></figure>
<p>最终版本, 使用万能引用, 这样上面直接作为左值就可以编译通过了. 可以进行赋值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> -&gt; <span class="title">decltype</span><span class="params">(std::forward&lt;Container&gt;(c)[i])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-要点速记"><a href="#1-3-1-要点速记" class="headerlink" title="1.3.1. 要点速记"></a>1.3.1. 要点速记</h3><ul>
<li>绝大多数情况下, decltype会得出变量或表达式的型别而不做任何修改</li>
<li>对于T的左值表达式, 除非该表达式仅有一个名字, deletype总是得出型别T&amp;</li>
<li>C++14支持decltype(auto), 会从初始化表达式推导型别, 使用decltype的规则</li>
</ul>
<h2 id="1-4-条款4-查看型别推导的结果的方法"><a href="#1-4-条款4-查看型别推导的结果的方法" class="headerlink" title="1.4. 条款4 查看型别推导的结果的方法"></a>1.4. 条款4 查看型别推导的结果的方法</h2><ul>
<li>IDE查看, 作用有限</li>
<li>编译器诊断信息, 导致编译错误<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> x = s;</span><br><span class="line"><span class="comment">// 输出错误</span></span><br><span class="line">x = <span class="string">&quot;error&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>运行时输出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会做一些特殊处理, 同时结果因为使用了按值传递, 会丢弃一些信息</span></span><br><span class="line"><span class="built_in">typeid</span>(param).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure>
使用Boost.TypeIndex来产生精确的型别识别信息<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> boost:typeindex:type_id_with_cvr;</span><br><span class="line"><span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>();</span><br><span class="line"><span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-1-要点速记"><a href="#1-4-1-要点速记" class="headerlink" title="1.4.1. 要点速记"></a>1.4.1. 要点速记</h3><ul>
<li>利用IDE编辑器\编译器错误消息和Boost.TypeIndex库能查到推导的类型</li>
<li>有些工具产生的结果无用或不准确, 理解是必要的</li>
</ul>
<h1 id="2-auto"><a href="#2-auto" class="headerlink" title="2. auto"></a>2. auto</h1><h2 id="2-1-条款5-优选使用auto-而非显示型别声明"><a href="#2-1-条款5-优选使用auto-而非显示型别声明" class="headerlink" title="2.1. 条款5 优选使用auto, 而非显示型别声明"></a>2.1. 条款5 优选使用auto, 而非显示型别声明</h2><blockquote>
<p>使用auto必须初始化, 避免了变量未初始化引起的错误;<br>auto可以直接表示函数指针, 比std::function使用的内存更少<br>避免隐式类型转换, 避免无谓的内存开销</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> std::pair&lt;std::string,<span class="type">int</span>&gt;&amp;p:m)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::unordered_map的键值部分是const, 遍历时应该是<code>std::pair&lt;const std::string,int&gt;</code>而不是<code>std::pair&lt;std::string,int&gt;</code><br>每循环一次, 都会发生一次隐式转换,  p也指向的临时对象, 每次迭代结束, 临时对象需要析构.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;p:m)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-1-要点速记"><a href="#2-1-1-要点速记" class="headerlink" title="2.1.1. 要点速记"></a>2.1.1. 要点速记</h3><ul>
<li>auto变量必须初始化, 基本上对会导致兼容性和效率问题的型别不匹配现象免疫, 还可以简化重构流程</li>
<li>auto型别的变量有条款2和条款6的毛病</li>
</ul>
<h2 id="2-2-条款-6-当auto推导型别不符合要求时-使用-强制类型转换-显示型别的初始化习惯用法"><a href="#2-2-条款-6-当auto推导型别不符合要求时-使用-强制类型转换-显示型别的初始化习惯用法" class="headerlink" title="2.2. 条款 6 当auto推导型别不符合要求时, 使用(强制类型转换)显示型别的初始化习惯用法"></a>2.2. 条款 6 当auto推导型别不符合要求时, 使用(强制类型转换)显示型别的初始化习惯用法</h2><blockquote>
<p><code>std::vector&lt;bool&gt;</code>类型[]返回值不能用auto, 返回的不是bool类型. 而是<code>std::vector&lt;bool&gt;::reference</code>, 它是std::vector<bool>的代理类<br>由上面的规则推导出普遍规律: 隐形代理类和auto无法和平共处. 防止写出<code>auto var = &quot;隐形&quot;代理型别表达式</code><br>对于上面的隐形代理类, 使用强制类型转换来使用auto</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt; features &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> feture1 = <span class="keyword">static_cast</span>&lt;<span class="type">bool</span>&gt;features[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// feature2 auto 指向返回隐士代理, 离开作用域后, 变成野指针</span></span><br><span class="line"><span class="keyword">auto</span> feature2 = features[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用static_cast强制类型转换, 可以表明我是故意这样转换的, 比如降低精度, double-&gt;float double-&gt;int等.</p>
</blockquote>
<h3 id="2-2-1-要点速记"><a href="#2-2-1-要点速记" class="headerlink" title="2.2.1. 要点速记"></a>2.2.1. 要点速记</h3><ul>
<li>隐形的代理型别可以导致auto根据初始化表达式推导出错误的型别</li>
<li>带显示型别的初始化习惯用法强制auto推倒想要的类型(强制类型转换)</li>
</ul>
<h1 id="3-转向现代C"><a href="#3-转向现代C" class="headerlink" title="3. 转向现代C++"></a>3. 转向现代C++</h1><h2 id="3-1-条款7-创建对象时区分-和"><a href="#3-1-条款7-创建对象时区分-和" class="headerlink" title="3.1. 条款7 创建对象时区分() 和 {}"></a>3.1. 条款7 创建对象时区分() 和 {}</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>;</span><br><span class="line">D d1;    <span class="comment">//调用默认构造函数</span></span><br><span class="line">D d2 = d1;  <span class="comment">// 并非赋值, 调用复制构造函数</span></span><br><span class="line">d1 = d2;    <span class="comment">// 并非复制, 调用复制赋值运算符  =</span></span><br></pre></td></tr></table></figure>
<p>C++ 11引入了统一初始化</p>
<blockquote>
<p>{}初始化禁止内建类型之间进行隐式窄化类型转换<br><code>缺陷</code>:<br>伴随意外行为<br>std::initializer_list, 见条款2<br>如果类中的构造函数重载了以<code>std::initializer_list</code>作为参数的构造函数, 使用{}初始化会优先使用该构造函数进行初始化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> i, <span class="type">bool</span> b);</span><br><span class="line">    <span class="built_in">D</span>(std::initializer_list&lt;<span class="type">long</span>, <span class="type">double</span>&gt; l);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用initializer_list的构造函数, 10, true被强制转换</span></span><br><span class="line">D d1&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>只有找不到实参可以转换为initializer_list中的形参类型的情况下, 才会去找别的构造函数</p>
<blockquote>
<p><code>std::vector</code>中就使用了这样的构造方法, 所以一定要注意vector构造时使用()还是{}进行初始化.<br>{}初始化会进行auto的型别推导</p>
</blockquote>
<h3 id="3-1-1-要点速记"><a href="#3-1-1-要点速记" class="headerlink" title="3.1.1. 要点速记"></a>3.1.1. 要点速记</h3><ul>
<li>{}初始化可以应用的语境最为广泛, 可以阻止隐式窄化转换, 对函数表达不带形参的()初始化免疫</li>
<li>在构造函数重载决议期间, 只要有任何可能, {}初始化就会与带有<code>std::initializer_list</code>型别的形参相匹配,即使其他重载版本有更加匹配的形参表</li>
<li>使用()还是{}, 最后的结果可能不一样, 如vector对象的初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vx</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vd&#123;<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; p : vx) &#123;</span><br><span class="line">	cout&lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; p : vd) &#123;</span><br><span class="line">	cout&lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在模板内容进行对象创建时, 到底使用()还是{}会成为一个棘手的问题</li>
</ul>
<h2 id="3-2-条款8-优先使用nullptr-而非NULL或0"><a href="#3-2-条款8-优先使用nullptr-而非NULL或0" class="headerlink" title="3.2. 条款8 优先使用nullptr, 而非NULL或0"></a>3.2. 条款8 优先使用nullptr, 而非NULL或0</h2><p>在只能使用指针的语境中使用0, 会被勉强解释为空指针.</p>
<blockquote>
<p>0和NULL都不具体有指针型别, nullptr不具备整形型别.<br>f(NULL)的不确定性, 在函数重载时, 调用出错.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f(void *);</span><br><span class="line">void f(int);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nullptr可以隐式转换为所有的裸指针型别.<br>使用auto声明变量时, 如果还是用0或NULL, 如返回值返回0或NULL, auto声明变量的类型会推导出错.<br>错误的用法:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">findRecord</span><span class="params">(<span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">findRecord</span>(key);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="literal">NULL</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nullptr在有函数模板的前提下表现最亮眼</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(std::shared_ptr&lt;D&gt; ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(std::unique_ptr&lt;D&gt; ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(D* ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, Functype, <span class="keyword">typename</span> MuxType, <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lockAndCall</span><span class="params">(Functype func, MutxtType&amp; mutex, PtrType ptr)</span></span></span><br><span class="line"><span class="function">-&gt;<span class="title">decltype</span><span class="params">(func(ptr))</span> </span>&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">lockAndCall</span>(f3, f3m, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>上述的函数模板可以编译通过, 如果使用NULL或0就不可以.</p>
<h3 id="3-2-1-要点速记"><a href="#3-2-1-要点速记" class="headerlink" title="3.2.1. 要点速记"></a>3.2.1. 要点速记</h3><ul>
<li>想对于0或NULL, 优先使用nullptr</li>
<li>避免在整形和指针型别之间重载</li>
</ul>
<h2 id="3-3-条款9-优先使用别名声明-而非typedef"><a href="#3-3-条款9-优先使用别名声明-而非typedef" class="headerlink" title="3.3. 条款9 优先使用别名声明, 而非typedef"></a>3.3. 条款9 优先使用别名声明, 而非typedef</h2><blockquote>
<p>别名声明可以模板化, typedef就不行</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">//使用别名后, 就能使用 MyAlloc&lt;T&gt;了</span></span><br><span class="line">MyAllocList&lt;D&gt; ld;  <span class="comment">//客户代码,使用api</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MyAlloc&lt;T&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typedef 的写法需要加上 typename 和 ::type</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-要点速记"><a href="#3-3-1-要点速记" class="headerlink" title="3.3.1. 要点速记"></a>3.3.1. 要点速记</h3><ul>
<li>typedef 不支持模版化，但别名声明支持</li>
<li>别名模板可以免写::type后缀,并且在模板内, 对于内嵌typedef的引用经常要求加上typename前缀</li>
</ul>
<h2 id="3-4-条款10-优先使用限定作用域的枚举类型"><a href="#3-4-条款10-优先使用限定作用域的枚举类型" class="headerlink" title="3.4. 条款10 优先使用限定作用域的枚举类型"></a>3.4. 条款10 优先使用限定作用域的枚举类型</h2><blockquote>
<p>通用规则, 如果在{}内声明一个名字,则改名字的可见性就被限定在{}内<br>上面的规则不适用于枚举量, 此作用域内不能有其他实体去相同名字. 即存在<code>名字污染</code>问题<br>不限范围的枚举类型可以隐式转换为整数型别, 限定的就不可以, 如果确实需要转换为int, 可以使用<code>static_cast</code>强转.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;black, white, red&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-1-要点速记"><a href="#3-4-1-要点速记" class="headerlink" title="3.4.1. 要点速记"></a>3.4.1. 要点速记</h3><ul>
<li>c++ 98风格的枚举类型, 称为不限范围的枚举类型</li>
<li>限定作用域的枚举类型仅在枚举型别内可见, 只能通过强制类型转换转到其他型别</li>
<li>限定作用域的枚举型别和不限制范围的都支持底层型别指定. 限定的默认是int, 不限定的没有默认</li>
<li>限定作用域的枚举型别可以前置声明, 而不限的在指定了默认底层型别的前提下才可以.</li>
</ul>
<h2 id="3-5-条款11-优先使用删除函数-而非private未定义函数"><a href="#3-5-条款11-优先使用删除函数-而非private未定义函数" class="headerlink" title="3.5. 条款11 优先使用删除函数, 而非private未定义函数"></a>3.5. 条款11 优先使用删除函数, 而非private未定义函数</h2><blockquote>
<p>压制某函数,  不让别人用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C&amp;) = <span class="keyword">delete</span>;     <span class="comment">//复制构造函数</span></span><br><span class="line">    C&amp; oprator=(<span class="type">const</span> C&amp;) = <span class="keyword">delete</span>;    <span class="comment">//复制赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果客户代码访问了delete的函数, 会在编译阶段就报错.<br>成员函数和友元函数也会无法访问<br>任何函数都可以成为删除函数<br>可以删除某些有些转换后能够变成重载的形参的函数的特定版本</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span> number)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">isLucky</span>(<span class="number">3.5f</span>); <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>阻止不应该进行的模板具现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-1-要点速记"><a href="#3-5-1-要点速记" class="headerlink" title="3.5.1. 要点速记"></a>3.5.1. 要点速记</h3><ul>
<li>优先使用删除函数, 而非private未定义函数</li>
<li>任何函数都可以删除, 包括非成员函数和模板具现</li>
</ul>
<h2 id="3-6-条款12-为改写的函数添加override声明"><a href="#3-6-条款12-为改写的函数添加override声明" class="headerlink" title="3.6. 条款12 为改写的函数添加override声明"></a>3.6. 条款12 为改写的函数添加override声明</h2><p>改写(override), 重载(overload)<br>好处:</p>
<ul>
<li>编译器在你想要改写的函数实际上并未改写是提示</li>
<li>如果派生类都写了override生命,则改函数签名时可以知道有多少派生类被影响到了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dp</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> overide</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>; <span class="comment">//仅在*this是左值时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>; <span class="comment">//仅在*this是右值时调用</span></span><br><span class="line">&#125;</span><br><span class="line">Dp dp;</span><br><span class="line">dp.<span class="built_in">doWork</span>();        <span class="comment">//以左值调用doWork</span></span><br><span class="line"><span class="built_in">makeDp</span>().<span class="built_in">doWork</span>();   <span class="comment">// 以右值调用doWork</span></span><br></pre></td></tr></table></figure>
区分返回左值版本还是右值版本</li>
</ul>
<h3 id="3-6-1-要点速记"><a href="#3-6-1-要点速记" class="headerlink" title="3.6.1. 要点速记"></a>3.6.1. 要点速记</h3><ul>
<li>为在意改写的函数添加override声明</li>
<li>成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分</li>
</ul>
<h2 id="3-7-条款13-优先使用const-iterator-而不是iterator"><a href="#3-7-条款13-优先使用const-iterator-而不是iterator" class="headerlink" title="3.7. 条款13 优先使用const_iterator, 而不是iterator"></a>3.7. 条款13 优先使用const_iterator, 而不是iterator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"><span class="keyword">auto</span> it=std::<span class="built_in">find</span>(values,<span class="built_in">cbegin</span>(), values,<span class="built_in">cend</span>(), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>
<p>容器的cbegin, cend返回const_iterator.<br>STL成员函数若要取用指示位置的迭代器, 也要求使用const_iterator型别<br>如果容器的成员函数未提供cbegin, cend.<br>非成员函数版本cbegin的一个实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span> -&gt; <span class="title">decltype</span><span class="params">(std::begin(container)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">return</span> std::begin(container);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-1-要点速记"><a href="#3-7-1-要点速记" class="headerlink" title="3.7.1. 要点速记"></a>3.7.1. 要点速记</h3><ul>
<li>优先使用const_iterator, 而不是iterator</li>
<li>在最通用的代码中, 优先使用非成员函数版本的begin, end, rbegin等</li>
</ul>
<h2 id="3-8-条款14-只要函数不发生异常-加上noexcept声明"><a href="#3-8-条款14-只要函数不发生异常-加上noexcept声明" class="headerlink" title="3.8. 条款14 只要函数不发生异常, 加上noexcept声明"></a>3.8. 条款14 只要函数不发生异常, 加上noexcept声明</h2><h3 id="3-8-1-要点速记"><a href="#3-8-1-要点速记" class="headerlink" title="3.8.1. 要点速记"></a>3.8.1. 要点速记</h3><ul>
<li>noexcept声明是函数接口的组成部分, 调用方可能对它有依赖</li>
<li>想对于不带noexcept声明的函数, 带有的有可能得到优化</li>
<li>noexcept性质对于移动操作&#x2F;swap&#x2F;内存释放函数&#x2F;和析构函数最有价值</li>
<li>大多数函数都是异常中立的, 不具备noexcept性质</li>
</ul>
<h2 id="3-9-条款15-优先使用constexpr"><a href="#3-9-条款15-优先使用constexpr" class="headerlink" title="3.9. 条款15 优先使用constexpr"></a>3.9. 条款15 优先使用constexpr</h2><ul>
<li>所有的constexpr对象都是const对象</li>
<li>并非所有的const对象都是constexpr</li>
<li>constexpr可以保证编译期可知</li>
<li>constexpr函数可以用在编译期常量的语境中.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span>)? <span class="number">1</span>: base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> exp = <span class="number">5</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, pow(3, exp)&gt; results;</span><br></pre></td></tr></table></figure>
即base和exp都是编译期常量, pow的返回结果就可以当成编译期常量使用<br>如果base和exp有一个不是编译期常量, 则pow的返回结果就是执行期量.<blockquote>
<p>constexpr的函数实现因为需要保证在编译期能返回编译期结果, 因此需要对函数实现添加限制</p>
</blockquote>
</li>
<li>只能有一条return语句.<br>可以通过条件表达式或者递归的方式实现.<br>用户自定义型别同样可能是字面型别, 因它的构造函数和其他成员函数可能也是constexpr函数</li>
<li>constexpr函数除了void, 其他的内建型别都支持, 另外不允许有io语句</li>
</ul>
<h3 id="3-9-1-要点速记"><a href="#3-9-1-要点速记" class="headerlink" title="3.9.1. 要点速记"></a>3.9.1. 要点速记</h3><ul>
<li>constexpr对象都具备const属性, 并由编译期已知的值完成初始化</li>
<li>constexpr函数在调用时若传入的实参是编译期已知的, 则会产生编译期结果</li>
<li>比起非constexpr对象或constexpr函数而言, constexpr对象或函数都可以用在作用域更广的语境中</li>
</ul>
<h2 id="3-10-条款16-保证const成员函数的线程安全性"><a href="#3-10-条款16-保证const成员函数的线程安全性" class="headerlink" title="3.10. 条款16 保证const成员函数的线程安全性"></a>3.10. 条款16 保证const成员函数的线程安全性</h2><h3 id="3-10-1-要点速记"><a href="#3-10-1-要点速记" class="headerlink" title="3.10.1. 要点速记"></a>3.10.1. 要点速记</h3><ul>
<li>保证const成员函数的线程安全性, 除非可以确认它们不会用在并发语境下</li>
<li>运用std::atomic型别的变量会比运用互斥量提供更好的性能 , 但前者仅仅适用于单个变量或内存区域的操作</li>
</ul>
<h2 id="3-11-条款17-理解特种成员函数的生成机制"><a href="#3-11-条款17-理解特种成员函数的生成机制" class="headerlink" title="3.11. 条款17 理解特种成员函数的生成机制"></a>3.11. 条款17 理解特种成员函数的生成机制</h2><blockquote>
<p>特种成员函数是指从c++自动生成的成员函数<br>默认构造函数. 析构函数 复制构造函数. 复制赋值运算符函数<br>C++11中, 加入了两个新成员:<br>移动构造函数和移动赋值运算符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; rhs)；<span class="comment">//移动构造函数</span></span><br><span class="line">    D&amp; <span class="keyword">operator</span>=(D&amp;&amp; rhs); <span class="comment">//移动赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种移动操作不是独立的, 声明了其中一个, 会阻止生成另一个.</p>
<ul>
<li>按成员移动由两部分构成:</li>
</ul>
<ol>
<li>支持移动操作的成员上执行的移动操作</li>
<li>不支持…<br>复制操作和移动操作一般来说也不是独立的, 一旦声明了移动操作, 就废弃了复制操作.<br>大三律:<br>声明了复制构造函数&#x2F;复制赋值运算符或析构函数的任一个, 就需要同时声明这三个</li>
</ol>
<p>大三律的推论:<br>如果声明了析构函数, 复制操作就不应该自动生成, 因为自动生成的行为一定不正确.<br>如声明了析构函数, 就不会生成移动操作</p>
<p>移动操作的生成条件(自动生成, 按需生成), 仅当以下三者同时成立的条件下:</p>
<ul>
<li>该类未声明任何复制操作</li>
<li>该类未声明任何析构函数</li>
<li>该类未声明任何移动操作</li>
</ul>
<p>如果不想让上述规则生效, 需要添加 <code>=default</code>来显示的表达我就想用某操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">D</span>();</span><br><span class="line">        D&amp; oprator=(constD&amp; ) = <span class="keyword">default</span>; <span class="comment">//默认复制赋值运算符的行为是正确的</span></span><br><span class="line">        <span class="built_in">D</span>(D&amp;&amp; rhs) = <span class="keyword">default</span>;   <span class="comment">// 提供移动操作的支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>特种函数名称</th>
<th>机制</th>
</tr>
</thead>
<tbody><tr>
<td>默认构造函数</td>
<td>仅仅当类中不包含用户声明的构造函数时才生成</td>
</tr>
<tr>
<td>析构函数</td>
<td>默认为noexecpt, 仅当基类的是虚的, 派生类的才是虚的</td>
</tr>
<tr>
<td>复制构造函数</td>
<td>仅当类中不包含用户声明的复制构造函数时才生成, 如果声明了移动操作, 则复制构造会被删除.在已经存在复制赋值运算符或析构函数的条件下,不会生成复制构造函数</td>
</tr>
<tr>
<td>复制赋值运算符</td>
<td>如果声明了移动操作, 复制赋值运算符将被移除,在已经存在了复制构造或析构函数的条件下,废弃</td>
</tr>
<tr>
<td>移动构造函数和移动赋值运算符</td>
<td>类中不包含用户声明的复制操作&#x2F;移动操作&#x2F;析构函数时才生成</td>
</tr>
<tr>
<td>特例:</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>成员函数模板的存在不会阻止编译器生成任何特种成员函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">D</span><span class="params">(<span class="type">const</span> T&amp; rhs)</span></span>;</span><br><span class="line">    D&amp; oprator=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会始终自动生成D的复制和移动操作, 即使这些模板具现了复制或复制赋值运算符的函数签名(T为D也会生成)</p>
<h3 id="3-11-1-要点速记"><a href="#3-11-1-要点速记" class="headerlink" title="3.11.1. 要点速记"></a>3.11.1. 要点速记</h3><ul>
<li>特种成员函数是指那些C++自行生成的成员函数, 默认构造 析构函数 复制操作 移动操作</li>
<li>移动操作仅当类中未包含用户显示声明的复制 移动 析构时才生成</li>
<li>复制构造仅当类中不包含显示声明的复制构造时才生成.如声明了移动操作, 则复制构造会被废弃; 复制赋值仅当类中不包含显示声明的复制赋值时才生成, 如果声明了移动操作,会废弃;已经存在显示析构的条件下, 生成复制操作会被废弃</li>
<li>成员函数模板在任何情况下都不会抑制特种成员函数的生成</li>
</ul>
<h1 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h1><blockquote>
<p>关于裸指针</p>
</blockquote>
<ol>
<li>裸指针在声明中没有指出指到的是单个对象还是一个数组</li>
<li>裸指针在生命中也没有提示在使用完指的对象后, 是否需要被析构.从声明中看不出指针是否指到了对象</li>
<li>即使知道需要析构指针所指的对象, 也不要知道如果适当析构, 是使用delelte, 还是专门的析构函数</li>
<li>即使知道了使用delete, 会是不知道是指单个对象还是数组, 是使用delelte还是delelte []</li>
<li>即使知道delelte的形式, 也不能保证析构在所有代码路径上都仅执行一次(包括异常导致的代码路径).只要少在一路上执行, 就会导致资源泄漏,执行多了会出现未定义行为</li>
<li>没有任何正规的方式能检测出指针是否空悬<br>在上面裸指针的种种问题下, 请优先使用智能指针, 保证在合适的时机下析构</li>
</ol>
<ul>
<li><code>std::auto_ptr</code><br>C++ 98残留,后来变成了unique_ptr,不再建议使用</li>
<li><code>std::unique_ptr</code><br>在C++11中用来代替auto_ptr的</li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
<h2 id="4-1-条款18-使用std-unique-ptr管理专属所有权的资源"><a href="#4-1-条款18-使用std-unique-ptr管理专属所有权的资源" class="headerlink" title="4.1. 条款18 使用std::unique_ptr管理专属所有权的资源"></a>4.1. 条款18 使用<code>std::unique_ptr</code>管理专属所有权的资源</h2><p>考虑使用智能指针时, 优先使用unique_ptr, 和裸指针的代价差不多, 实现专属所有权语义.<br><code>std::unique_ptr</code>是只移动型别,资源的析构是通过对其内部的裸指针实施delete完成<br>常见用法是在对象继承谱系中作为工厂函数的返回类型, 调用者需要对工厂函数返回的资源负责, 属于专属所有权</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>:</span><br><span class="line">    <span class="keyword">public</span> Investment &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bond</span>:</span><br><span class="line">    <span class="keyword">public</span> Investment &#123;...&#125;;</span><br><span class="line"><span class="comment">//调用者通过工厂函数创建对象, 工厂函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">makeInvestmnet</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br><span class="line"><span class="comment">//客户代码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> pInvestment = <span class="built_in">makeInvestment</span>(arguments);</span><br><span class="line">&#125;  <span class="comment">//*pInvestment在此析构</span></span><br></pre></td></tr></table></figure>
<p>如果所有权链由于异常或其他非典型控制流(如函数提早返回)而中断时, 有托管资源所有权的std::unique_ptr最终将调用该资源的析构函数. 其托管资源最终被析构<br>在析构过程中, 可以设定自定义析构器.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">    <span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*创建stock型别对象*/</span>) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::<span class="built_in">foward</span>&lt;Ts&gt;(params)...)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>() &#123;</span><br><span class="line">        pInv.<span class="built_in">rest</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义析构器接受一个型别为Investment* 的形参, 终究会在lambda表达式中作为一个Investment* 对象被删除,意味着我们会通过基类指针删除一个派生类对象.<br>基类必须具备一个虚析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//必须有&#123;&#125;, 否则会链接出错</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Investment</span>()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以这样定义工厂函数的返回值, 使用函数作为自定义析构器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delInvmt2</span><span class="params">(Investmt* pInv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(pInv);</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">void</span><span class="params">(*)</span><span class="params">(Investment*)</span>&gt; <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>lambda表达式的方案更好.<br>std::unique_ptr以两种方式提供, 一种是单个对象, (std::unique_ptr<T>), 另一个是数组(std::unique_ptr&lt;T[]&gt;). 数组方式不推荐使用, 建议使用容器类.</p>
<ul>
<li>std::unique_ptr可以更加高效的转换为std::shared_ptr;</li>
</ul>
<h3 id="4-1-1-要点速记"><a href="#4-1-1-要点速记" class="headerlink" title="4.1.1. 要点速记"></a>4.1.1. 要点速记</h3><ul>
<li>std::unique_ptr是小巧&#x2F;高速的&#x2F;具备只移型别的智能指针, 对托管资源实施专属所有权语义.</li>
<li>默认采用delete运算实现, 但可以指定自定义删除器.有状态的删除器和采用函数指针实现的删除器会增加该型别的大小.</li>
<li>std::unique_ptr可以很容易的转换为<code>std::shared_ptr</code></li>
</ul>
<h2 id="4-2-条款19-使用std-shared-ptr管理具备共享所有权的资源"><a href="#4-2-条款19-使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="4.2. 条款19 使用std::shared_ptr管理具备共享所有权的资源"></a>4.2. 条款19 使用std::shared_ptr管理具备共享所有权的资源</h2><blockquote>
<p>采用共享所有权来管理生存期,当最后一个指到该对象的指针不再指它时, 该std::shared_ptr会析构所指的对象<br>std::shared_ptr的复制赋值动作会执行两种操作:<br><code>sp1 = sp2</code></p>
</blockquote>
<ul>
<li>最初sp1所指的对象的引用技数递减, 如减到0, 资源析构</li>
<li>sp2所指对象的引用计数递增<br>引用计数的存在会带来一些性能影响:</li>
<li>尺寸是裸指针的两倍, 一个指到裸指针, 一个指到引用计数</li>
<li>引用计数的内存必须动态分配</li>
<li>引用计数的递增和递减必须是原子操作<br>移动构造函数, 会将源std::shared_ptr悬空, 原来的指针不再指到资源<br>自定义析构器的型别不是std::shared_ptr指针的一部分, 而unique_ptr是<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmet)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Investment, delInvmet)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Investment, delInvmet)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> cd1 = [](Investment* p) &#123;...&#125;;</span><br><span class="line"><span class="keyword">auto</span> cd2 = [](Investment* p) &#123;...&#125;;</span><br><span class="line"><span class="comment">//std::shared_ptr的设计更有弹性</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Investment, cd1)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Investment&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Investment, cd1)</span></span>;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Investment&gt;&gt; vpw&#123;spw1, spw1&#125;;</span><br></pre></td></tr></table></figure>
相对unique_ptr, shared_ptr的设计更有弹性<br>shared_ptr的尺寸永远是裸指针的两倍, 不随析构器的尺寸发生变化<br>尽可能避免将裸指针传递给一个std::shared_ptr的构造函数,常用的替换手法是使用<code>std::make_shared</code><br>如果必须将裸指针传递给std::shared_ptr的构造函数, 请在构造函数中直接new<br>反面教材:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> D;</span><br><span class="line"><span class="function">std::shared_ptr&lt;D&gt; <span class="title">spw1</span><span class="params">(pw, cd1)</span></span>;        <span class="comment">//not ok</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;D&gt; <span class="title">spw3</span><span class="params">(<span class="keyword">new</span> D, cd1)</span></span>;  <span class="comment">//ok</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;D&gt; <span class="title">spw2</span><span class="params">(pw, cd2)</span></span>;        <span class="comment">// not ok</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;D&gt; <span class="title">spw4</span><span class="params">(spw3)</span>  <span class="comment">//ok</span></span></span><br></pre></td></tr></table></figure>
std::make_shared总是创建一个控制块</li>
</ul>
<h3 id="4-2-1-要点速记"><a href="#4-2-1-要点速记" class="headerlink" title="4.2.1. 要点速记"></a>4.2.1. 要点速记</h3><ul>
<li>std::shared_ptr提供方便的手段, 实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收机制</li>
<li>与unique_ptr相比, 其尺寸通常是裸指针的两倍, 还带来了控制块的开销, 并要求原子引用计数</li>
<li>默认的资源析构是delete, 同时支持定制自定义析构器, 自定义析构器不影响shared_ptr的型别</li>
<li>避免使用裸指针型别的变量创建shared_ptr指针, 直接通过传入形参构造的方式.</li>
</ul>
<h2 id="4-3-条款20-对于类似std-shared-ptr但有可能悬空的指针使用std-weak-ptr"><a href="#4-3-条款20-对于类似std-shared-ptr但有可能悬空的指针使用std-weak-ptr" class="headerlink" title="4.3. 条款20 对于类似std::shared_ptr但有可能悬空的指针使用std::weak_ptr"></a>4.3. 条款20 对于类似std::shared_ptr但有可能悬空的指针使用std::weak_ptr</h2><p>这种指针像std::shared_ptr那样运作,但又不影响其所指对象的引用计数,真正的智能指针, 能够跟踪何时指针空悬.<br>std::weak_ptr是std::shared_ptr的一种扩充<br>一般是通过shared_ptr来创建的,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">make_shared</span>&lt;D&gt;();</span><br><span class="line"><span class="function">std::weak_ptr&lt;D&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>;     <span class="comment">//wpw和spw指向同一个D</span></span><br><span class="line">spw = <span class="literal">nullptr</span>;     <span class="comment">//引用计数变为0, D对象被析构, wpw空悬,也被成为失效</span></span><br><span class="line"><span class="keyword">if</span>(wpw.<span class="built_in">expired</span>())   <span class="comment">//wpw失效</span></span><br><span class="line"><span class="keyword">auto</span>  spw2 = wpw.<span class="built_in">lock</span>() <span class="comment">//若wpw失效, spw2指针为空</span></span><br></pre></td></tr></table></figure>
<p>在非严格继承谱系的数据结构中, 以及缓存和观察者的列表实现等情况下, std::weak_ptr非常适用</p>
<h3 id="4-3-1-要点速记"><a href="#4-3-1-要点速记" class="headerlink" title="4.3.1. 要点速记"></a>4.3.1. 要点速记</h3><ul>
<li>使用std::weak_ptr来代替可能空悬的shared_ptr</li>
<li>weak_ptr可能的用武之地包括缓存&#x2F;观察者列表以及避免std::shared_ptr指针回路</li>
</ul>
<h2 id="4-4-条款21-优先选用make-shared和std-make-unique-而非直接使用new"><a href="#4-4-条款21-优先选用make-shared和std-make-unique-而非直接使用new" class="headerlink" title="4.4. 条款21 优先选用make_shared和std::make_unique, 而非直接使用new"></a>4.4. 条款21 优先选用make_shared和std::make_unique, 而非直接使用new</h2><p>make_unique是C++ 14中的.<br>make系列函数会把一个任意实参集合完美转发给动态分配的内存对象的构造函数,并返回一个指到该对象的智能指针.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先使用make系列与异常安全有关,性能有关<br>但使用make系列无法自定义析构器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;D&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;D&gt; <span class="title">d1</span><span class="params">(<span class="keyword">new</span> D)</span></span>;</span><br><span class="line"><span class="built_in">processD</span>(std::<span class="built_in">shared_ptr</span>&lt;D&gt;(<span class="keyword">new</span> D), computePriority); <span class="comment">//潜在的资源泄漏</span></span><br><span class="line"><span class="built_in">processD</span>(std::<span class="built_in">make_shared</span>&lt;D&gt;(), computePriority);     <span class="comment">//没有发生潜在资源泄漏的情况</span></span><br><span class="line"><span class="built_in">processD</span>(d1, computePriority);  <span class="comment">//也不会发生资源泄漏</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-1-要点速记"><a href="#4-4-1-要点速记" class="headerlink" title="4.4.1. 要点速记"></a>4.4.1. 要点速记</h3><ul>
<li>相比直接使用new表达式, make系列消除了重复代码, 引进了异常安全性, 并且对于std::make_shared和std::allocate_shared而言, 生成的目标代码会尺寸更小&#x2F;速度更快</li>
<li>不适用make系列函数的场景包括自定义析构器,以及期望直接传递{}初始物</li>
<li>对于std::shared_ptr, 不建议使用make的额外场景包括:1.  自定义内存管理的类, 2. 内存紧张的系统&#x2F;非常大的对象,以及存在比指到相同shared_ptr对象生存期更久的weak_ptr</li>
</ul>
<h2 id="4-5-条款22-使用Pimpl习惯用法时-将特殊成员函数的定义放到实现文件中"><a href="#4-5-条款22-使用Pimpl习惯用法时-将特殊成员函数的定义放到实现文件中" class="headerlink" title="4.5. 条款22 使用Pimpl习惯用法时, 将特殊成员函数的定义放到实现文件中"></a>4.5. 条款22 使用Pimpl习惯用法时, 将特殊成员函数的定义放到实现文件中</h2><h3 id="4-5-1-要点速记"><a href="#4-5-1-要点速记" class="headerlink" title="4.5.1. 要点速记"></a>4.5.1. 要点速记</h3><ul>
<li>Pimpl惯用法通过降低类的客户和类实现者之间的依赖性, 减少了构建遍数</li>
<li>对于采用unique_ptr来实现的pImpl指针, 须在类的头文件中声明特种成员函数, 但需要在实现文件中实现他们</li>
<li>上述建议使用与unique_ptr, 不适用与shared_ptr</li>
</ul>
<h1 id="5-右值引用-移动语义和完美转发"><a href="#5-右值引用-移动语义和完美转发" class="headerlink" title="5. 右值引用 移动语义和完美转发"></a>5. 右值引用 移动语义和完美转发</h1><blockquote>
<p>移动语义: 以代价比较小的移动操作代替昂贵的复制操作,移动构造函数和移动复制赋值运算符函数也给了移动语义的能力<br>完美转发:使得可以任意撰写接受任意实参的函数模板, 并将其转发给其他函数, 目标函数会接受到与转发函数完全相同的实参.<br>注意点: 形参总是左值, 即使其型别是右值引用</p>
</blockquote>
<h2 id="5-1-理解std-move和std-forward"><a href="#5-1-理解std-move和std-forward" class="headerlink" title="5.1. 理解std::move和std::forward"></a>5.1. 理解std::move和std::forward</h2><p>std::move无条件的将实参转换为右值, std::forward则仅在某个条件下才执行强制转换<br>std::move做的是强制类型转换, 不做的是移动, 转换为右值后, 表明其具备了可移动的条件<br>经验:</p>
<ul>
<li>如果想取得对某个对象执行移动操作的能力, 不要将其声明为常量, 以为针对常量对象执行的移动操作将一声不吭的变换为复制操作</li>
<li>std::move不仅不实际移动, 甚至不保证转换后的对象具有可移动的能力, 唯一可以确定的是转换后, 会变为右值</li>
<li>std::move 执行了移动构造函数， 移动的原目标的值会被清空。其内容移动给了新的目标。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> D&amp; d1)</span>  <span class="comment">//处理左值</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(D&amp;&amp; d1)</span>  <span class="comment">//处理右值</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">makeLogEntry</span>(<span class="string">&quot;calling process&quot;</span>, now);</span><br><span class="line">    <span class="comment">//进行转发</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line">D d;   <span class="comment">//左值</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(d);</span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(d));     <span class="comment">//调用时转换为右值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-1-1-要点速记"><a href="#5-1-1-要点速记" class="headerlink" title="5.1.1. 要点速记"></a>5.1.1. 要点速记</h3><ul>
<li>std::move实施的是无条件的转换为右值, 对其本身而言, 不会执行移动</li>
<li>仅当传入的实参被绑定为右值时, std::forward才会针对该实参实施转换为右值, 实现的是转发语义</li>
<li>在运行期间, std::move和std::forward不执行任何操作</li>
</ul>
<h2 id="5-2-条款24-区分万能引用和右值引用"><a href="#5-2-条款24-区分万能引用和右值引用" class="headerlink" title="5.2. 条款24 区分万能引用和右值引用"></a>5.2. 条款24 区分万能引用和右值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(D&amp;&amp; param)</span></span>;       右值引用</span><br><span class="line">D&amp;&amp; d = <span class="built_in">D</span>();             右值引用</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; d2 = d；          非右值引用</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(std::vector&lt;T&gt;&amp;&amp; param)   右值引用</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(T&amp;&amp; param)                非右值引用</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(<span class="type">const</span> T&amp;&amp; param)          右值引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>T&amp;&amp; 为右值引用, 主要的理由是能识别出可移对象<br>不涉及型别推导, 就是右值引用<br>必须指定为T&amp;&amp;的模式. 加上修饰符也不行</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span>   <span class="comment">//右值引用</span></span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; v</span>;</span><br><span class="line"><span class="built_in">f</span>(v)   <span class="comment">//编译出错, 无法绑定到右值, 传入的是左值</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-条款25-针对右值引用实施std-move-针对万能引用实施std-forward"><a href="#5-3-条款25-针对右值引用实施std-move-针对万能引用实施std-forward" class="headerlink" title="5.3. 条款25 针对右值引用实施std::move, 针对万能引用实施std::forward"></a>5.3. 条款25 针对右值引用实施std::move, 针对万能引用实施std::forward</h2><p>这里只给出一个错误示范:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">        <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">            name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getDname</span><span class="params">()</span></span>;</span><br><span class="line">D d;</span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getDname</span>();</span><br><span class="line">d.<span class="built_in">setName</span>(n);   <span class="comment">//将n移入了d中</span></span><br><span class="line"><span class="comment">//n将变成未知的.</span></span><br></pre></td></tr></table></figure>
<p>std::move将引用形参无条件的强制转换为右值, n的值就被移入d.name中.<br>返回值优化:</p>
<ul>
<li>局部对象型别和函数返回值型别形同</li>
<li>返回的就是局部对象本身</li>
</ul>
<h3 id="5-3-1-要点速记"><a href="#5-3-1-要点速记" class="headerlink" title="5.3.1. 要点速记"></a>5.3.1. 要点速记</h3><ul>
<li>针对右值引用的最后一次实施std::move, 针对万能引用的最后一次实施std::forward</li>
<li>若局部对象可能适用于返回值优化, 则请勿针对其实施std::move或std::forward</li>
</ul>
<h3 id="5-3-2-要点速记"><a href="#5-3-2-要点速记" class="headerlink" title="5.3.2. 要点速记"></a>5.3.2. 要点速记</h3><p>避免使用万能引用进行函数重载</p>
<ul>
<li>把万能引用作为重载候选型别, 几乎总会让该重载版本在始料未及的情况下被调用到</li>
<li>完美转发构造函数的问题尤其严重, 因为对于非常量的左值型别, 他们一般都会形成想对于复制构造函数的更佳匹配.并且还会劫持派生类中对基类的复制和移动构造函数的调用</li>
</ul>
<h2 id="5-4-条款27-熟悉万能引用作为函数重载方案的替代方案"><a href="#5-4-条款27-熟悉万能引用作为函数重载方案的替代方案" class="headerlink" title="5.4. 条款27 熟悉万能引用作为函数重载方案的替代方案"></a>5.4. 条款27 熟悉万能引用作为函数重载方案的替代方案</h2><ul>
<li>传递const T&amp; 型别的形参</li>
<li>传值<br>将传递的形参从引用型替换为值型别<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span>:name(std::move(n))&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span>:name(nameFromIdx(idx))&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>标签分类<br>传递左值常量还是传值, 都不支持完美转发, 标签分类支持完美转发, 标签值决定了调用了哪个重载版本<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAddImpl</span>(std::forward&lt;T&gt;(name),</span><br><span class="line">    std::is_illegal&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = ...</span><br><span class="line">    log...</span><br><span class="line">    names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对接受万能引用的模板施加限制<br>完美转发构造函数使用标签分类的方式并不能保证自动生成的特种函数一定会经过标签分派设计.<br>完美转发的效率更高, 但写起来非常麻烦, 而且当客户代码传递了非法形参时, 编译信息的可理解性非常差</li>
</ul>
<h3 id="5-4-1-要点速记"><a href="#5-4-1-要点速记" class="headerlink" title="5.4.1. 要点速记"></a>5.4.1. 要点速记</h3><ul>
<li>如果不能使用万能引用和重载的组合, 则替代方案包括使用彼此不同的函数名字&#x2F;传值&#x2F;传递const T&amp;型别的形参,和标签分类</li>
<li>万能引用形参通常在性能方面有优势, 但在易用性方面非常劣势</li>
</ul>
<h2 id="5-5-条款28-理解引用折叠"><a href="#5-5-条款28-理解引用折叠" class="headerlink" title="5.5. 条款28 理解引用折叠"></a>5.5. 条款28 理解引用折叠</h2><p>引用的引用是非法的, 编译器会报错.<br>但是在模板推导过程中和auto型别推导过程中,如果遇到引用的引用,即&amp;&amp;, 会进行引用折叠<br>引用合成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; &amp; =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp; =&gt; T&amp;</span><br><span class="line">T&amp; &amp;&amp; =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-1-要点速记"><a href="#5-5-1-要点速记" class="headerlink" title="5.5.1. 要点速记"></a>5.5.1. 要点速记</h3><ul>
<li>引用折叠会在四种语境中发生, 模板实例化 auto型别生成 创建和运用typedef和别名声明以及decltype</li>
</ul>
<h2 id="5-6-条款29-假设移动操作不存在-成本高-未使用"><a href="#5-6-条款29-假设移动操作不存在-成本高-未使用" class="headerlink" title="5.6. 条款29 假设移动操作不存在,成本高,未使用"></a>5.6. 条款29 假设移动操作不存在,成本高,未使用</h2><p>整个C++98标准库都已经被C++11彻底翻修过, 但还是有很多库未进行过修改.如果不支持移动操作, 就没有任何区别<br>即使支持移动操作, 也不一定代价小<br>在这样几种场景下, C++11的移动语义不会带来什么好处:</p>
<ol>
<li><strong>没有移动操作</strong>: 待移动的对象未能提供移动操作</li>
<li><strong>移动未能更快</strong>:虽然有移动, 但并不比复制更快</li>
<li><strong>移动不可用</strong>:移动可以发生的语境下, 要求移动不可发生异常,但该操作未加上noexcept声明<br>对于那些型别或对于移动语义的支持情况已知的代码,则无需上述假定</li>
</ol>
<h2 id="5-7-条款30-熟悉完美转发的失败情形"><a href="#5-7-条款30-熟悉完美转发的失败情形" class="headerlink" title="5.7. 条款30 熟悉完美转发的失败情形"></a>5.7. 条款30 熟悉完美转发的失败情形</h2><p>转发函数天然就是泛型的, 接受<strong>可变长形参</strong>模板, 从而能够接受任意数量的实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);  <span class="comment">//转发所有实参到f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>(expr)      <span class="comment">//执行某种操作</span></span><br><span class="line"><span class="built_in">fwd</span>(expr)    <span class="comment">//如果执行了另外一种操作,则转发失败, fwd完美转发expr到f失败</span></span><br></pre></td></tr></table></figure>
<p><strong>会导致完美转发失败的实参种类</strong>有分为下面几种情况:</p>
<ol>
<li>{}初始化expr<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//error</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>编译器无法为一个或多个fwd的形参推导出型别结果</li>
<li>编译器为一个或多个fwd的形参推导出了错误的型别</li>
</ul>
<ol start="2">
<li>0和NULL用作空指针<br>不能推倒出指针, 用nullptr代替</li>
<li>仅有声明的整形static const成员变量<br><code>static const std::size_t MinVals = 28;</code> 仅给出了声明, 并没有定义.</li>
<li>重载的函数名字和模板名字</li>
<li>位域<br>非const引用不能绑定到位域<br>只能进行复制,再转发<br>万能引用的作用机制是引用, 在硬件级别, 引用就是指针的提领</li>
</ol>
<h3 id="5-7-1-要点速记"><a href="#5-7-1-要点速记" class="headerlink" title="5.7.1. 要点速记"></a>5.7.1. 要点速记</h3><ul>
<li>完美转发的失败情形, 源于模板型别推导失败, 或推导结果是错误的型别</li>
<li>会导致完美转发失败的实参种类有…, 见上面</li>
</ul>
<h1 id="6-lambda表达式"><a href="#6-lambda表达式" class="headerlink" title="6. lambda表达式"></a>6. lambda表达式</h1><p>用法:</p>
<ul>
<li>自定义析构器, shared_ptr unique_ptr </li>
<li>标准库 std::find_of remove_if count_if等</li>
<li>制作回调函数,接口适配函数或语境相关的特化版本等<br>闭包可以复制</li>
</ul>
<h2 id="6-1-条款31-避免默认捕获模式"><a href="#6-1-条款31-避免默认捕获模式" class="headerlink" title="6.1. 条款31 避免默认捕获模式"></a>6.1. 条款31 避免默认捕获模式</h2><p>默认捕获模式:</p>
<ul>
<li>按引用捕获<br>会导致闭包包含指到局部变量的引用, 一旦超出作用域, 闭包内引用可能空悬<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(cal1, cal2);</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [&amp;](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面例子中filters可能为全局变量, 但其加入的lamda表达式中的divisor在离开了addDivisorFilter函数作用域后,就不存在了<br>解决这个问题的一个办法是对<code>divisor</code>采用按值的默认捕获模式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>([=](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value%divisor==<span class="number">0</span>;&#125;);</span><br></pre></td></tr></table></figure>
捕获只能对创建lamda式内的作用域内<code>可见的非静态局部变量进行捕获, 如果是成员变量等, 不能进行捕获</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [=](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value%divisor == <span class="number">0</span>;&#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面这个成员函数中lamda等同于下面这个<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [p](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value%p-&gt;divisor == <span class="number">0</span>;&#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
被捕获的实际是D的this指针而不是divisor, 因此在离开D对象作用域后, 生命周期结束后, 会导致指针空悬<br>可以通过复制解决,<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> devisor1 = devisor;</span><br><span class="line">        filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">            [devisor1](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value%divisor1 == <span class="number">0</span>;&#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用默认捕获模式的另一个缺点是与闭包外的变化绝缘<br>不能捕获静态变量, 依赖于静态变量存储期, 会引起代码误读<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> divisor = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    divisor++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value % divisor == <span class="number">0</span>;&#125;   <span class="comment">//未捕获任何东西, 但会指到静态变量上, 静态变量可能变化, 导致该表达式的含义变化</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-1-1-要点速记"><a href="#6-1-1-要点速记" class="headerlink" title="6.1.1. 要点速记"></a>6.1.1. 要点速记</h3><ul>
<li>按引用的默认捕获会导致空悬指针问题</li>
<li>按值的默认捕获易受空悬指针影响, 并且容易引起代码误读</li>
</ul>
<h2 id="6-2-条款32-使用初始化捕获将对象移入闭包"><a href="#6-2-条款32-使用初始化捕获将对象移入闭包" class="headerlink" title="6.2. 条款32 使用初始化捕获将对象移入闭包"></a>6.2. 条款32 使用初始化捕获将对象移入闭包</h2><p>C++11 不支持初始化捕获, c++14 支持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw=std::<span class="built_in">move</span>(pw)] &#123;<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>();&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的[]内的即为初始化表达式, &#x3D;两侧的作用域不同.<br>也称为广义lamda捕获模式<br>C++ 11中需要使用std::bind, 按移动捕获</p>
<ul>
<li>把需要捕获的对象移动到std::bind产生的函数对象中</li>
<li>给到lambda一个指到捕获对象的引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"><span class="keyword">auto</span> func=std::<span class="built_in">bind</span>([](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data)&#123;<span class="comment">/*对data进行操作*/</span>&#125;, std::<span class="built_in">move</span>(data));</span><br></pre></td></tr></table></figure>
std::bind返回的函数对象为绑定对象, 第一个实参是可调用对象, 接下来的所有实参是传给该对象的值<br>绑定对象被调用时,采用了右值的实参传给了std::bind绑定的lambda式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func=std::<span class="built_in">bind</span>([<span class="type">const</span> std::unique_ptr&lt;D&gt;&amp; d]&#123;<span class="keyword">return</span> d-&gt;<span class="built_in">isValidate</span>();&#125;, std::<span class="built_in">make_unique</span>&lt;D&gt;());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-1-要点速记"><a href="#6-2-1-要点速记" class="headerlink" title="6.2.1. 要点速记"></a>6.2.1. 要点速记</h3><ul>
<li>使用C++14的初始化捕获将对象移入闭包</li>
<li>在C++11中, 经由手工实现的类或std::bind去模拟初始化捕获</li>
</ul>
<h2 id="6-3-条款33-对auto-型别的形参使用decltype-以std-foward之"><a href="#6-3-条款33-对auto-型别的形参使用decltype-以std-foward之" class="headerlink" title="6.3. 条款33 对auto&amp;&amp; 型别的形参使用decltype, 以std::foward之"></a>6.3. 条款33 对auto&amp;&amp; 型别的形参使用decltype, 以std::foward之</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[](<span class="keyword">auto</span>&amp;&amp; param) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(param)&gt;(param)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-条款34-优先使用lambda表达式-而非std-bind"><a href="#6-4-条款34-优先使用lambda表达式-而非std-bind" class="headerlink" title="6.4. 条款34 优先使用lambda表达式, 而非std::bind"></a>6.4. 条款34 优先使用lambda表达式, 而非std::bind</h2><h3 id="6-4-1-要点速记"><a href="#6-4-1-要点速记" class="headerlink" title="6.4.1. 要点速记"></a>6.4.1. 要点速记</h3><ul>
<li>lambda表达式比起使用std::bind而言, 可读性更好,表达力更强, 运行效率更高</li>
<li>仅在C++11中, std::bind在实现移动捕获或是绑定到具备模版化的函数调用运算符的对象的场合中,可有余热. 见条款32</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">269</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>

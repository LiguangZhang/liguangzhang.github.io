<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW WenKai:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="zMIPS体系结构采用的是 精确异常 处理模式这是什么意思呢？下面来看从“See MIPS Run”一书中的摘录：  “In a precise-exception CPU, on any exception we get pointed at one instruction(the exception victim). All instructions preceding the excepti">
<meta property="og:type" content="article">
<meta property="og:title" content="mips 异常">
<meta property="og:url" content="https://liguangzhang.github.io/2020/09/25/hxd_new/mips%E5%BC%82%E5%B8%B8/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="zMIPS体系结构采用的是 精确异常 处理模式这是什么意思呢？下面来看从“See MIPS Run”一书中的摘录：  “In a precise-exception CPU, on any exception we get pointed at one instruction(the exception victim). All instructions preceding the excepti">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095208249.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309522679.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309524297.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095314509.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095330737.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180313095342474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2h1em0wOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095405537.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095418835.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095429595.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095440571.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20210519193356380.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095511786.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD.png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(1).png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(2).png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(3).png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(4).png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(5).png">
<meta property="og:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(6).png">
<meta property="article:published_time" content="2020-09-25T10:15:54.000Z">
<meta property="article:modified_time" content="2024-04-16T07:00:45.257Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="异常">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095208249.png">

<link rel="canonical" href="https://liguangzhang.github.io/2020/09/25/hxd_new/mips%E5%BC%82%E5%B8%B8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'" />

  <title>mips 异常 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2020/09/25/hxd_new/mips%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mips 异常
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 18:15:54" itemprop="dateCreated datePublished" datetime="2020-09-25T18:15:54+08:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:00:45" itemprop="dateModified" datetime="2024-04-16T15:00:45+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIPS/" itemprop="url" rel="index"><span itemprop="name">MIPS</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/25/hxd_new/mips%E5%BC%82%E5%B8%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/25/hxd_new/mips%E5%BC%82%E5%B8%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>zMIPS体系结构采用的是 <code>精确异常</code> 处理模式<br>这是什么意思呢？下面来看从“See MIPS Run”一书中的摘录：</p>
<blockquote>
<p>“In a precise-exception CPU, on any exception we get pointed at one instruction(the exception victim). All instructions preceding the exception victim in execution sequence are complete; any work done on the victim and on any subsequent instructions (BNN NOTE: pipeline effects) has no side effects that the software need worry about. The software that handles exceptions can ignore all the timing effects of the CPU’s implementations”</p>
</blockquote>
<p>上面的意思其实很简单：在发生这个异常之前的一切计算行为会完整的结束并体现效果。 在发生这个异常之后的一切计算行为（包含当前这条指令）将不会产生任何效果。<br>另外一种解释是：</p>
<blockquote>
<p>A precise exception is one in which the EPC (CP0, Register 14, Select 0) can be used to identify the instruction that caused the exception. For imprecise exceptions, the instruction that caused the exception cannot be identified. Most exceptions are precise. Bus error exceptions may be imprecise.</p>
</blockquote>
<h2 id="异常处理的一般过程"><a href="#异常处理的一般过程" class="headerlink" title="异常处理的一般过程"></a>异常处理的一般过程</h2><p>With the exception of Reset, Soft Reset, NMI, and Debug exceptions, which have their own special processing as described below, exceptions have the same basic processing flow:<br>• If the EXL bit in the <code>Status register</code> is cleared, theEPC  register is loaded with the PC at which execution will be restarted and the BD bit is set appropriately in the<code>Cause register</code>.  If the instruction is not in the delay slot of a branch, the BD bit inCausewill be cleared and the value loaded into theEPCregister is the current PC. If the instruction is in the delay slot of a branch, the BD bit inCauseis set andEPCis loaded with PC-4.If the EXL bit in theStatus register is set, theEPCregister is not loaded and the BD bit is not changed in theCauseregister.<br>• The <code>CE</code> and <code>ExcCode</code> fields of the Cause registers are loaded with the values appropriate to the exception. The CE field is loaded, but not defined, for any exception type other than a coprocessor unusable exception.<br>• The EXL bit is set in the Status register.<br>• The processor is started at the exception vector.<br>The value loaded into EPC represents the restart address for the exception and need not be modified by exception handler software in the normal case. Software need not look at the BD bit in the Cause register unless is wishes to identify the address of the instruction that actually caused the exception. Note that individual  exception types may load additional information into other registers. This is noted in the description of each exception type below.</p>
<p><code>EPC</code>中存放的是异常发生时执行的指令地址，或者分支延时发生异常，则存放的是分支的指令地址，不管怎么样，<code>异常处理函数返回都从EPC开始恢复执行</code>，如果在<code>分支延时指令发生异常</code>，则需要<code>在cause寄存器中存放相应标志</code>，这样就可以准确的知道发生异常的指令地址了。</p>
<p>Operation:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ifStatus EXL= 0 then</span><br><span class="line"> if InstructionInBranchDelaySlot then</span><br><span class="line">  EPC &lt;- PC - 4</span><br><span class="line">  Cause BD&lt;- 1</span><br><span class="line"> else</span><br><span class="line">  EPC &lt;- PC</span><br><span class="line">  Cause BD&lt;- 0</span><br><span class="line"> endif</span><br><span class="line"> if ExceptionType = TLBRefill then</span><br><span class="line">  vectorOffset &lt;- 0x000</span><br><span class="line"> elseif (ExceptionType = Interrupt) and</span><br><span class="line">  (Cause IV= 1) then</span><br><span class="line">  vectorOffset &lt;- 0x200</span><br><span class="line"> else</span><br><span class="line">  vectorOffset &lt;- 0x180</span><br><span class="line"> endif</span><br><span class="line">else</span><br><span class="line"> vectorOffset &lt;- 0x180</span><br><span class="line">endif</span><br><span class="line">Cause CE&lt;- FaultingCoprocessorNumber</span><br><span class="line">Cause ExcCode&lt;- ExceptionType</span><br><span class="line">Status EXL&lt;- 1</span><br><span class="line">if Status BEV= 1 then</span><br><span class="line"> PC &lt;- 0xBFC0_0200 + vectorOffset</span><br><span class="line">else</span><br><span class="line"> PC &lt;- 0x8000_0000 + vectorOffset</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>As with any procedure, the exception handler must save any registers it may modify, and then restore them before returning control to the interrupted program. Saving registers in memory poses a problem in MIPS:<br>addressing the memory requires a register (the base register) in which the address is formed. This means that  a register must be modified before any register can be saved!  The MIPS register usage convention (see Laboratory 4) reserves registers $26 and $27( <code>$k0</code>and<code>$k1</code> ) for the use of the interrupt handler. This means that the interrupt handler can use these registers without having to save them first.  <code>A user program that uses these registers may find them unexpectedly changed.</code>The CPU operates in one of the two possible modes,userandkernel.User programs run in user mode.   <code>The CPU enters the kernel mode when an exception happens</code>. Coprocessor 0 can only be used in kernel mode.</p>
<p>说明：为何分支延时槽中的指令发生异常要从分支指令<code>重新</code>执行呢，这是因为mips的指令执行是流水线结构，分析指令的执行结果不会影响到延时槽中指令的执行，也就是说不管分支指令往哪里跳，<code>延时槽的指令都会执行</code>，如果EPC保存延时指令地址，则分析指令执行的结果将会丢失，这样异常处理结束后恢复执行的结果就不正确</p>
<h2 id="异常入口（向量）"><a href="#异常入口（向量）" class="headerlink" title="异常入口（向量）"></a>异常入口（向量）</h2><p>The <code>Reset</code> ,<code>Soft Reset</code> , and<code>NMI exceptions</code> are always vectored to location <code>0xBFC0_0000</code>. Debug exceptions are vectored to location <code>0xBFC0_0480</code> or to location <code>0xFF20_0200</code> if the ProbTrap bit is 0 or 1, respectively, in the <code>EJTAG Control register</code> (ECR). </p>
<blockquote>
<p>如果在’ EJTAG控制寄存器’ (ECR)中<code>ProbTrap</code>位分别为0或1，则调试异常被指向位置’ 0xBFC0_0480 ‘或位置’ 0xFF20_0200 ‘。</p>
</blockquote>
<p>Addresses for<code>all other exceptions</code>are a combination of a vector offset and a base address .</p>
<p>Table4-2  gives the base address as a function of the exception and whether the BEV bit is set in theStatus register.</p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095208249.png" alt="img">  </p>
<p>Table 4-3  gives the offsets from the base address as a function of the exception.</p>
<p> <img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309522679.png" alt="img">  </p>
<p>CauseIV:    将<code>CP0 CauseIV</code>位设置为<code>1</code>会导致中断异常使用专用的异常向量偏移量(0x200), 而不是使用一般的异常向量偏移量(0x180)。 </p>
<p>Table 4-4combines these two tables into one that contains all possible vector addresses as a function of the state that can affect the vector selection.</p>
<blockquote>
<p>将这两个表合并为一个表，其中包含所有可能的向量地址，作为可能影响向量选择的状态函数。</p>
</blockquote>
<p> <img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/2018031309524297.png" alt="img">  </p>
<p>In MIPS32® Release 2 and higher architectures, software is allowed to specify the vector base address via the  <code>CP0 Ebase</code>register for exceptions that occur when CP0 Status BEV equals 0.</p>
<ul>
<li>StatusBEV&#x3D; 1:  Exceptions vector to an uncached entry point in KSEG1: 0xBFC00xxx</li>
<li>StatusBEV&#x3D; 0:  Exceptions vector to cached entry points in KSEG0:  <code>defined by CP0 Ebase register</code>, plus someoffset</li>
</ul>
<p>Note:StatusBEV &#x3D; 1 at reset. IfEbaseis to be changed, it must be done with StatusBEV&#x3D; 1(i.e. at system boot). The operation of the CPU isUNDEFINEDifEbaseis written whenStatusBEV&#x3D; 0. TheEbasedefault is 0x8000_0000 after reset. </p>
<blockquote>
<p>EBase寄存器是一个可读写寄存器，包含例外向量基地址和一个只读的CPU号。</p>
</blockquote>
<p> <img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095314509.png" alt="img"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095330737.png" alt="img"><img src="https://img-blog.csdn.net/20180313095342474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2h1em0wOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>对<code>Cache Error</code>这个特殊的异常来说，需要给他安排一个任何时候都是Uncached的基地址了。因为发生这个异常时Cache已经不可靠了，在处理它是就不能使用它了。</p>
<p>因此这个异常的入口基地址为：  </p>
<p>BEV &#x3D; 1 : BFC0,0300 （系统启动地址空间 : kseg1）</p>
<p>BEV &#x3D; 0 :[SP]:  A000,0000 （物理内存地址 :  kseg1）</p>
<p>[MP]:  EBASE[31.30] || 1 || EBASE[28…12] || 0x000  （物理内存地址 :  kseg1)</p>
<p>上面的总结一下： <code>Reset ,Soft Reset和NMI</code>： 不受任何配置的影响，异常向量位置总是在<code>0XBFC0_0000</code> </p>
<p>General Exception：异常向量在<code>0xBFC0_0200 + 0x180</code>  或 <code>Ebase + 0x180</code> </p>
<p>Interrupt： IV 表示是否使用专用的异常处理向量， IV&#x3D;0，采用General Exception中断向量， IV&#x3D;1，则采用int专用的中断向量 </p>
<p>TLB refill： EXL为0时，采用TLB refill专用的异常处理向量，EXL为1时，采用General Exception中断向量  </p>
<h2 id="异常优先级"><a href="#异常优先级" class="headerlink" title="异常优先级"></a>异常优先级</h2><p>所谓的优先级是指：当在某个时刻，同时多个异常或中断出现时，CPU将会按照上述的优先级来处理。</p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095405537.png" alt="img"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095418835.png" alt="img"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095429595.png" alt="img"></p>
<p>前面一列为exception的编号，后面一列为改异常的描述  </p>
<h2 id="异常相关寄存器"><a href="#异常相关寄存器" class="headerlink" title="异常相关寄存器"></a>异常相关寄存器</h2><p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095440571.png" alt="img">  </p>
<ul>
<li>The BadVAddr register</li>
</ul>
<p>This register (its name stands for Bad Virtual Address) will contain the memory address where the exception has occurred. </p>
<p>An unaligned memory access, for instance, will generate an exception and <code>the address where the access was attempted</code> will be stored in BadVAddr.</p>
<h3 id="SR-Status-Register，状态寄存器"><a href="#SR-Status-Register，状态寄存器" class="headerlink" title="SR(Status Register，状态寄存器)"></a>SR(Status Register，状态寄存器)</h3><p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/image-20210519193356380.png" alt="image-20210519193356380"></p>
<ol>
<li><strong>EXL Exception Level</strong> ; set by the processor when any exception other than Reset, Soft Reset, NMI, or Cache Error exception are taken.</li>
</ol>
<p>​      0: normal 1: exception </p>
<p>当EXL被置位时， 中断是被禁止的。 换句话说，这时SR[IE]位是不管用了，相当于<code>所有的中断都被屏蔽了</code>。 </p>
<ul>
<li>TLB Refill异常将会使用<code>General Exception Vector</code>而不是缺省的TLB Refill Vector. </li>
<li>如果再次发生异常，<code>EPC将不会被自动更新</code>。这一点要非常注意。如果想支持嵌套异常，要在异常处理例程中清EXL位。当然要先保存EPC的值。另外要注意的：MIPS当陷 入Exception&#x2F;Interrupt时，并不改变SR[UX],SR[KX]或SR[SX]的值。SR[EXL]为1自动的将CPU mode运行在核心模式下。这一点要注意。</li>
</ul>
<ol start="2">
<li><strong>ERL Error Level</strong> ; set by the processor when <code>Reset, Soft Reset, NMI, or Cache Error exception</code> are taken.</li>
</ol>
<p>​     0: normal 1: error </p>
<p>   当ERL被置位时，中断被禁止. 中断返回<code>ERET</code>使用的是<code>ErrorEPC</code>而不是EPC。需要非常注意这个区别。 </p>
<p>Kuseg和xkuseg 被认为是没有映射(Mapped)的和没有缓存（Un-Cached）。</p>
<p>可以这样理解，MIPS CPU只有在这个时刻才是一种实模式(real mode)，可以不需要TLB的映射， 就直接使用<code>kuseg</code>的地址空间。 </p>
<blockquote>
<p> The ERET instruction to return from exception is used for returning from exception level (Status.EXL) and error level (Status.ERL). If both bits are set however we should be returning from ERL first, as ERL can interrupt EXL, for example when an NMI is taken. </p>
</blockquote>
<p>都是通过eret返回的，如果<strong>EXL和ERL同时设置了</strong>，<code>则应该首先从ERL返回</code>，<strong>PC设置为ErrorPC, 清除ERL，注意这时不会清除EXL。</strong></p>
<p>ERET指令用模拟器实现的代码大致如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kvm_read_c0_guest_status(cop0) &amp; ST0_ERL) &#123;</span><br><span class="line">      kvm_clear_c0_guest_status(cop0, ST0_ERL);</span><br><span class="line">      vcpu-&gt;arch.pc = kvm_read_c0_guest_errorepc(cop0);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (kvm_read_c0_guest_status(cop0) &amp; ST0_EXL) &#123;</span><br><span class="line">     kvm_clear_c0_guest_status(cop0, ST0_EXL);</span><br><span class="line">     vcpu-&gt;arch.pc = kvm_read_c0_guest_epc(cop0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>IE</strong>   Interrupt Enable 0: disable interrupts 1: enable interrupts。请记住： 当SR[EXL]或SR[ERL]被SET时，SR[<code>IE</code>]是无效的。 </p>
</li>
<li><p><strong>BEV</strong>  Normal&#x2F;Bootstrap exception vectors location </p>
<p>BEV&#x3D;1 ：非缓存异常处理入口固定定位于非缓存的、启动安全的 kseg1 内存区域</p>
<p>BEV&#x3D;0 ：异常处理入口不固定，通过 EBase 寄存器可以编程移动，系统正常运行时为 0, 由EBASE 指定</p>
</li>
<li><p><strong>SR</strong> Soft Reset,  如果是soft reset，该位置1，表明是软件复位 </p>
</li>
<li><p><strong>NMI</strong> 如果是NMI，该位置1，表明是不可屏蔽中断 </p>
</li>
<li><p><strong>IM</strong>[7:0] Interrupt Mask</p>
</li>
<li><p><strong>UM</strong> Kernel&#x2F;User Mode， UM&#x3D;1用户模式，中断发生时不改变该bit的值 </p>
<p>UM:ERL:EXL Mode</p>
<p>100:              User</p>
<p>000:              Kernel</p>
<p>x10:              Kernel (exception handling)</p>
<p>x01:              Kernel (error handling)</p>
</li>
</ol>
<h3 id="Cause"><a href="#Cause" class="headerlink" title="Cause"></a>Cause</h3><p>在处理器异常发生时， 这个寄存器标识了异常的原因。其中最重要的是2-6位，5个bit的exception code位。它们标识了引起异常的原因，具体数值代表的异常类型</p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png" alt="img"></p>
<ol>
<li><p><strong>BD</strong>: Exception happened in a branch delay slot </p>
</li>
<li><p><strong>IV</strong>: <code>Use general vs special interrupt vector</code>  打开iv 后， interrupt 走0x200的vector offset（vector base 为0xbfc00200或者ebase）</p>
</li>
<li><p><strong>IP</strong>[7:0]: Interrupt(s) pending </p>
</li>
<li><p><strong>Exc Code</strong>: Exception code</p>
</li>
</ol>
<p> <img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095511786.png" alt="img">  </p>
<h3 id="EPC存放返回地址"><a href="#EPC存放返回地址" class="headerlink" title="EPC存放返回地址"></a>EPC存放返回地址</h3><p>  这个寄存器的作用很简单， 就是保存异常发生时的指令地址。从这个地方可以找到异常发生的指令，再结合<code>BadVaddr</code> <code>sp</code> 等寄存器，就可以推导出异常时的程序调用关系，从而定位问题的根因</p>
<h3 id="WatchLo、WatchHi"><a href="#WatchLo、WatchHi" class="headerlink" title="WatchLo、WatchHi"></a>WatchLo、WatchHi</h3><p>这一对寄存器用来设定<code>内存硬件断点</code>，也就是对指定点的内存进行检测。当访问的内存地址和这两个寄存器地址一致时，会发生一个异常。 应该是不同于gdb的watch指令，后面可以试一下。</p>
<h2 id="CP0相关"><a href="#CP0相关" class="headerlink" title="CP0相关"></a>CP0相关</h2><h3 id="CP0-主要操作"><a href="#CP0-主要操作" class="headerlink" title="CP0 主要操作"></a>CP0 主要操作</h3><p>mfc0 rt,rd 将cp0的rd寄存器内容传输到rt通用寄存器</p>
<p>mtc0 rt, rd 将rd通用寄存器的内容传输到CP0中寄存器rd</p>
<p>mfhi&#x2F;mflo rt 将CP0 的hi、lo 寄存器的内容传输到rt通用寄存器中</p>
<p>mthi&#x2F;mtlo rt 将rt通用寄存器的内容传输到CP0的hi、lo 寄存器中</p>
<h3 id="CP0-冒险现象"><a href="#CP0-冒险现象" class="headerlink" title="CP0 冒险现象"></a>CP0 冒险现象</h3><p>mips体系结构是一个无互锁，高度流水的五级pipeline架构，这就意味着，前一条指令如果尚未执行完，后一条指令可能已经进入了取指令、译码阶段。这样可能发生CP0 冒险（CP0 Hazard）现象。mfc和mtc的指令执行速度是比较慢的，开始执行完下一条指令时， 有可能CP0寄存器的值尚未最后传输到指定的目标通用寄存器中。此时，如果读取该通用寄存器，有可能未能得到正确的值。这就是所谓的CP0 冒险现象。</p>
<p>为避免CP0 冒险， 我们在编程时需要在CP0 操作指令的后面加入一条与前一条指令的目的通用寄存器无关的指令，也就是所谓的延迟槽（delay slot）， 如果对性能不敏感，可以考虑用nop填充延迟槽</p>
<h2 id="MIPS-cpu中断机制"><a href="#MIPS-cpu中断机制" class="headerlink" title="MIPS cpu中断机制"></a>MIPS cpu中断机制</h2><h3 id="mips-异常"><a href="#mips-异常" class="headerlink" title="mips 异常"></a>mips 异常</h3><p>在mips中，中断 陷阱trap 系统调用和任何可以中断程序正常执行流的情况都称之为异常</p>
<p><strong>精确异常</strong>： 在引发异常的指令执行时，后面一条指令已经完成了读取和译码的预备工作，当异常产生时，<code>这些预备工作被废弃</code>，CPU从异常中返回时，再重新做读取和译码的工作。</p>
<p>Mips 对异常的处理是给异常分配一些类型，然后由软件给它们定义一些优先级，然后由<code>同一个入口</code>进入异常分配程序，在分配程序中根据类型及<code>优先级</code>确定该执行哪个对应的函数</p>
<p>CP0中的epc寄存器用于指向异常发生时指令跳转前的执行位置，一般是被中断指令地址。当异常时，是返回这个地址继续执行，但如果被中断指令是在分支延迟槽中，则会硬件自动处理使epc往回指一条指令（pc-4），即分支指令。在重新执行分支指令时，分支延迟槽中的指令会被再执行一次。</p>
<h3 id="mips异常处理步骤"><a href="#mips异常处理步骤" class="headerlink" title="mips异常处理步骤"></a>mips异常处理步骤</h3><ol>
<li>设置epc，指向返回位置</li>
<li>设置status寄存器，exl位迫使cpu进入内核模式，并且<code>禁用中断</code>，即exl位置1</li>
<li>设置cause 寄存器， 使得软件能看见异常原因， 地址异常时，也要设置<code>BadVAddr</code>寄存器，存储管理系统异常还要设置一些mmu寄存器</li>
<li>cpu从异常入口点取指令执行</li>
</ol>
<h3 id="mips异常处理例子"><a href="#mips异常处理例子" class="headerlink" title="mips异常处理例子"></a>mips异常处理例子</h3><ol>
<li>保护现场：在异常处理例程入口，需要保护被中断的程序的现场，存储寄存器的状态，保证关键状态不被覆盖</li>
<li>处理异常： 根据cause exccode确定发生了什么类型的异常，完成想要做的任何事情</li>
<li>准备返回： 恢复线程，修改SR，设置成安全模式（内核态，禁止异常）exl置1，也就是异常发生后的模式</li>
<li>从异常返回：指令<code>eret</code>， 即清除SR：exl位， exl置0， 将控制权返回给存储在epc中的地址</li>
</ol>
<h3 id="中断寄存器相关"><a href="#中断寄存器相关" class="headerlink" title="中断寄存器相关"></a>中断寄存器相关</h3><p>cpu核<code>外部</code>的事件，即从一些真正的<code>硬件连线</code>过来的输入信号（外中断或硬中断）</p>
<p>Cause：exccode编码为00000中断，这些中断使cpu转向某外部事件，mips cpu有8个独立终端位(在Cause: IP7-2 和 IP 1-0段), 其中6个(IP7-2)为外部中断，2个(IP 1-0)为内部中断(可用软件访问), 片上的时钟计数&#x2F;定时器都会连接到一个硬件中断位上。</p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/20180313095459446.png" alt="img"></p>
<p>mips 对中断的支持涉及到 SR 和 Cause 寄存器</p>
<ol>
<li><p>使能全局中断(IE: interupt enable)： 要想使能中断，SR的IE位必须置1</p>
</li>
<li><p>中断使能屏蔽（IM： interupt mask） SR[15-8]为中断屏蔽位，对应IM[7-0]， 这8个bit决定了<code>哪些中断源有请求时可以触发一个异常。实际上是对中断信号的使能开关。</code> 8个中断源中的6个 IM[7-2]对应cause IP[7-2]， 用于外部设备硬件中断，其余2个IM[1-0]对应cause ip[1-0]， 为软件中断屏蔽位，所谓中断源就是产生硬中断信号的PIC外接设备或软中断。</p>
</li>
<li><p>异常级别（EXL ： exception level）：异常发生后， cpu立即设置SR EXL置1， 进入异常模式， 异常模式强制cpu进入内核特权级模式并屏蔽中断， 而不会理会SR其他位的值。 EXL位在已经设置的情况下，还没有真正准备好调用主内核的例程（中断恢复或者中断钩子的处理？）。<strong>在这种状态下，系统不能处理其他异常</strong>， <code>保持EXL 足够的时间保存现场，使软件决定cpu新的特权级别和中断屏蔽位应该如何设置</code></p>
</li>
<li><p>异常类型（EXCcode： Exception Code） ： PIC每个输入引脚上的有效（相应的IM位 1， 未被屏蔽）， 输入每个周期都会采样， 如果使能，则引起一个异常。异常处理程序检查到Cause （exccode &#x3D;0）说明发生的异常是<code>中断</code>， 此时进入通用中断程序</p>
</li>
<li><p>中断请求寄存器（IP： interupt pending）： Cause[15-8]位为中断挂起状态位，用于指示哪些设备发生了中断，具体来说是识别PIC的哪个接入引脚对应的设备发来了中断信号，IP[7-2]随着CPU 硬件输入引脚上的信号而变化，而IP1-0为软件中断位，可读可写并存储最后写入的值。当SR：IM[7-0]某些位使能，且硬中断或软中断触发时，cause：IP[7-2]上的pending位，确定是哪个设备发生了中断</p>
<h3 id="中断处理步骤："><a href="#中断处理步骤：" class="headerlink" title="中断处理步骤："></a>中断处理步骤：</h3><blockquote>
<p>注意和异常的区别, 异常很有可能是不可恢复异常，中断处理要麻烦一些，因为要恢复现场。</p>
</blockquote>
<p> 中断是异常的一种，所以中断处理只是异常处理的一条分流，经过上一层异常处理处理后，处理步骤如下：</p>
<ol>
<li>将cause：IP与SR：IM进行逻辑与运算，获得一个或多个使能的中断请求</li>
<li>选择一个使能的中断来处理，优先处理最高优先级的中断</li>
<li>存储SR： IM中的中断屏蔽位，改变SR：IM 以保证<code>禁止当前中断</code>以及所有优先级小于等于本中断的中断在处理时发生</li>
<li><code>对于嵌套异常， 此时需要保护现场</code></li>
<li>修改cpu到合适的状态以适应中断处理程序的高层部分，这时通常允许一些嵌套中断或异常。设置全局中断使能SR：IE位，以允许处理高优先级的中断。还需要改变cpu特权级域（SR：<code>KSU</code>），使CPU处于内核态，清除SR：EXL离开异常模式，并把这些改动反映到状态寄存器中</li>
<li>执行中断处理程序，完成要做的事情</li>
<li>恢复现场，恢复相关寄存器， 返回被中断的指令（返回被中断程序）</li>
</ol>
</li>
</ol>
<h2 id="常见的异常处理"><a href="#常见的异常处理" class="headerlink" title="常见的异常处理"></a>常见的异常处理</h2><h3 id="Reset-Exception"><a href="#Reset-Exception" class="headerlink" title="Reset Exception"></a>Reset Exception</h3><p>A reset exception occurs when the  <em><code>SI_ColdReset</code></em>  signal is asserted to the processor. This exception is not maskable. When a Reset exception occurs, the processor performs a full reset initialization , including aborting state machines, establishing critical state, and generally placing the processor in a state in which it can <code>execute instructions from uncached, unmapped address space</code>. On a Reset exception, the state of the processor in not defined, with the following exceptions:</p>
<p>对于Reset和Soft Reset异常来说，当发生此类异常时，<code>ErrorEPC</code>是否准确记录了发生异常时执行的指令地址，这需要根据特定处理器的手册决定。它依赖于具体处理器的实现。而且，似乎在Reset时也没有必要去记录处理器正在执行的指令</p>
<ul>
<li><p>The  <em>Random</em>  register is initialized to the number of TLB entries - 1 (4Kc core).</p>
</li>
<li><p>The  <em>Wired</em>  register is initialized to zero (4Kc core).</p>
</li>
<li><p>The  <em>Config</em>  register is initialized with its boot state.</p>
</li>
<li><p>The RP, BEV, TS, SR, NMI, and ERL fields of the  <em>Status</em>  register are initialized to a specified state.</p>
</li>
<li><p>The I, R, and W fields of the  <em>WatchLo</em>  register are initialized to 0.</p>
</li>
<li><p>The  <em>ErrorEPC</em>  register is loaded with <code>pc-4</code> if the state of the processor indicates that it was executing an instruction in the <code>delay slot of a branch.</code> Otherwise, the  <em>ErrorEPC</em>  register is loaded with pc.  Note that this value may or may not be predictable.</p>
</li>
<li><p>PC is loaded with <code>0xBFC0_0000</code> </p>
</li>
<li><p>Cause Register ExcCode Value: None</p>
</li>
<li><p>Additional State Saved:  None </p>
</li>
<li><p>Entry Vector Used:  Reset (0xBFC0_0000)</p>
</li>
</ul>
<p><strong>Operation</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Random &lt;- TLBEntries - <span class="number">1</span></span><br><span class="line">Wired &lt;- <span class="number">0</span></span><br><span class="line">Config &lt;- ConfigurationState</span><br><span class="line">Status RP  &lt;- <span class="number">0</span></span><br><span class="line">Status BEV  &lt;- <span class="number">1</span></span><br><span class="line">Status TS  &lt;- <span class="number">0</span></span><br><span class="line">Status SR  &lt;- <span class="number">0</span></span><br><span class="line">Status NMI  &lt;- <span class="number">0</span></span><br><span class="line">Status ERL  &lt;- <span class="number">1</span></span><br><span class="line">WatchLo I  &lt;- <span class="number">0</span></span><br><span class="line">WatchLo R  &lt;- <span class="number">0</span></span><br><span class="line">WatchLo W  &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> InstructionInBranchDelaySlot then</span><br><span class="line">ErrorEPC &lt;- PC - <span class="number">4</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ErrorEPC &lt;- PC</span><br><span class="line">endif</span><br><span class="line">PC &lt;- <span class="number">0xBFC0</span>_0000</span><br></pre></td></tr></table></figure>

<h3 id="Non-Maskable-Interrupt-NMI-Exception"><a href="#Non-Maskable-Interrupt-NMI-Exception" class="headerlink" title="Non-Maskable Interrupt (NMI) Exception"></a><strong>Non-Maskable Interrupt (NMI) Exception</strong></h3><p>A  non-maskable  interrupt exception occurs when the  <em><code>SI_NMI</code></em>  signal is asserted to the processor.  <em>SI_NMI</em>  is an edge sensitive signal - <code>only one NMI exception will be taken each time it is asserted</code>. An NMI exception occurs only at instruction boundaries,  so it does not cause any reset or other hardware initialization. The state of the cache, memory, and other processor states are consistent and all registers are preserved , with the following exceptions:</p>
<ul>
<li><p>The BEV, TS, SR, NMI, and ERL fields of the  <em>Status</em>  register are initialized to a specified state.</p>
</li>
<li><p>The  <em>ErrorEPC</em>  register is loaded with PC-4 if the state of the processor indicates that it was executing an instruction in the delay slot of a branch. Otherwise, the  <em>ErrorEPC</em>  register is loaded with PC.</p>
</li>
<li><p>PC is loaded with 0xBFC0_0000.</p>
</li>
<li><p><em>Cause</em>  Register ExcCode Value:  None</p>
</li>
<li><p>Additional State Saved: None</p>
</li>
<li><p>Entry Vector Used: Reset (0xBFC0_0000)</p>
</li>
</ul>
<p>Operation:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status BEV   &lt;- 1</span><br><span class="line">Status TS   &lt;- 0</span><br><span class="line">Status SR   &lt;- 0</span><br><span class="line">Status NMI   &lt;- 1</span><br><span class="line">Status ERL   &lt;- 1</span><br><span class="line">if InstructionInBranchDelaySlot then</span><br><span class="line">ErrorEPC &lt;- PC - 4</span><br><span class="line">else</span><br><span class="line">ErrorEPC &lt;- PC</span><br><span class="line">endif</span><br><span class="line">PC &lt;- 0xBFC0_0000</span><br></pre></td></tr></table></figure>

<h3 id="Machine-Check-Exception-4Kc-core"><a href="#Machine-Check-Exception-4Kc-core" class="headerlink" title="Machine Check Exception (4Kc core)"></a><strong>Machine Check Exception (4Kc core)</strong></h3><p>A machine check exception occurs when the processor detects an <code>internal inconsistency</code>. The following condition causes a machine check exception;</p>
<p><em>Cause</em>  Register ExcCode Value:  MCheck</p>
<p>Additional State Saved:  None</p>
<p>Entry Vector Used:   <code>General exception vector</code> (offset 0x180)</p>
<h3 id="Interrupt-Exception"><a href="#Interrupt-Exception" class="headerlink" title="Interrupt Exception"></a><strong>Interrupt Exception</strong></h3><p>外部中断。它是唯一一个异步发生的异常。之所以说中断是异步发生的，是因为相对于其他异常来说，从时序上看，中断的发生是不可预料的，无法确定中断的发生是在流水线的哪一个阶段。MIPS的五级流水线设计如下：</p>
<blockquote>
<p>IF, RD, ALU, MEM, WB。MIPS处理器的中断控制部分有这样的设计：在中断发生时，如果该指令已经完成了MEM阶段的操作，则保证该指令执行完毕。反之，则丢弃流水线对这条指令的工作。除NMI外，所有的内部或外部硬件中断(Hardware Interrupt)均共用这一个异常向量(Exception Vector)。前面提到的CP0中的Counter&#x2F;Compare这一对计数寄存器，当Counter计数值和Compare门限值相等时，即触发一个硬件中断。</p>
</blockquote>
<p>The interrupt exception occurs when one or more of the eight interrupt requests is enabled by the  <em>Status</em>  register and the interrupt input is asserted. The delay from assertion of an unmasked interrupt to fetch of the first instructions at the exception vector is a minimum of 5 clock cycles. More may be needed if a committed instruction has to complete before the exception can be taken. A SYNC instruction which has already started flushing the cache and write buffers must wait until this is completed before the interrupt exception can be taken.</p>
<ul>
<li>Register ExcCode Value: Int</li>
<li>Additional State Saved: </li>
<li>Entry Vector Used:</li>
</ul>
<p>General exception vector (<code>offset 0x180</code>) if the IV bit in the  <em>Cause</em>  register is 0;  interrupt vector (<code>offset 0x200</code>) if the IV bit in the  <em>Cause</em>  register is 1.</p>
<h3 id="TLB-Refill-Exception"><a href="#TLB-Refill-Exception" class="headerlink" title="TLB Refill Exception"></a>TLB Refill Exception</h3><blockquote>
<p><strong>Instruction Fetch or Data Access (4Kc core)</strong></p>
</blockquote>
<p>TLB Miss Load&#x2F;Write，如果试图访问<code>没有在MMU的TLB中映射的内存地址</code>，会触发这个异常。在支持虚拟内存的操作系统中，这会触发内存的页面倒换，系统的Exception Handler会将所需要的内存页从虚拟内存中调入物理内存，并更新相应的TLB表项。</p>
<p>During an instruction fetch or data access, a TLB refill exception occurs when  <strong>no TLB entry  in a TLB-based MMU matches a reference to a mapped address space and  the EXL bit is 0  in the  <em>Status</em>  register.</strong> Note that this is distinct from the case in which an entry matches but has the valid bit off. In that case, a <strong>TLB Invalid exception</strong> occurs.</p>
<p>*<strong>Cause*</strong>  <strong>Register ExcCode Value:</strong></p>
<p>TLBL: Reference was a load or an instruction fetch</p>
<p>TLBS: Reference was a store</p>
<p><strong>Additional State Saved:</strong></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD.png" alt="下载"></p>
<p><strong>Entry Vector Used:</strong></p>
<p>TLB refill vector (<code>offset 0x000</code>) if Status EXL  &#x3D; 0 at the time of exception; general exception vector (<code>offset 0x180</code>) if Status EXL  &#x3D; 1 at the time of exception</p>
<h3 id="TLB-Invalid-Exception-—-Instruction-Fetch-or-Data-Access-4Kc-core"><a href="#TLB-Invalid-Exception-—-Instruction-Fetch-or-Data-Access-4Kc-core" class="headerlink" title="TLB Invalid Exception — Instruction Fetch or Data Access (4Kc core)"></a><strong>TLB Invalid Exception — Instruction Fetch or Data Access (4Kc core)</strong></h3><p>During an instruction fetch or data access, a TLB invalid exception occurs in one of the following cases:</p>
<p>•  No TLB entry  in a TLB-based MMU matches a reference to a mapped address space;  and <code>the EXL bit is 1</code>  in the<em>Status</em>  register.</p>
<p>• A TLB entry in a TLB-based MMU matches a reference to a mapped address space, but the matched entry has the valid bit off .</p>
<p><strong><em>Cause</em>  Register ExcCode Value</strong>:</p>
<p>TLBL: Reference was a load or an instruction fetch</p>
<p>TLBS: Reference was a store</p>
<p><strong>Additional State Saved</strong>:</p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(1).png" alt="下载 (1)"></p>
<p><strong>Entry Vector Used:</strong> </p>
<p>General exception vector (offset 0x180)</p>
<h3 id="Bus-Error-Exception-—-Instruction-Fetch-or-Data-Access"><a href="#Bus-Error-Exception-—-Instruction-Fetch-or-Data-Access" class="headerlink" title="Bus Error Exception — Instruction Fetch or Data Access"></a><strong>Bus Error Exception — Instruction Fetch or Data Access</strong></h3><p>一般地原因是Cache尚未初始化的时候访问了Cached的内存空间所致。因此，要注意在系统上电后，Cache初始化之前，只访问Uncached的地址空间，也就是<code>0xA0000000-0xBFFFFFFF</code>这一段。默认地，上电初始化的入口点<code>0xBFC00000</code>就位于这一段。(某些MIPS实现中可以通过外部硬线连接修改入口点地址，但为了不引发无法预料的问题，<code>不要将入口点地址修改为Uncached段以外的地址</code>)</p>
<p>A bus error exception occurs when an instruction or data access makes a bus request (due to a cache miss or an uncacheable reference) and that request terminates in an error. The bus error exception can occur on either an instruction fetch or a data access. Bus error exceptions that occur on an instruction fetch have a higher priority than bus error exceptions that occur on a data access.</p>
<p>Bus errors taken on the requested (critical) word of an instruction fetch or data load are precise. Other bus errors, such as stores or non-critical words of a burst read, can be imprecise. These errors are taken when the EB_RBErr or EB_WBErr signals are asserted and may occur on an instruction that was not the source of the offending bus cycle.</p>
<blockquote>
<p>在指令获取或数据加载的请求(关键)字上接收的总线错误是精确的。 其他总线错误，如存储或突发读取的非关键字，可能是不精确的。 这些错误是在断言EB_RBErr或EB_WBErr信号时发生的，可能发生在一个指令上，而该指令不是发生故障的总线周期的来源。  </p>
</blockquote>
<p><strong><em>Cause</em>  Register ExcCode Value</strong>:</p>
<p>IBE: Error on an instruction reference</p>
<p>DBE: Error on a data reference</p>
<p><strong>Additional State Saved</strong>: None</p>
<p><strong>Entry Vector Used:</strong></p>
<p>General exception vector (offset 0x180)</p>
<h2 id="详细异常处理流程图"><a href="#详细异常处理流程图" class="headerlink" title="详细异常处理流程图"></a>详细异常处理流程图</h2><p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(2).png" alt="下载 (2)"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(3).png" alt="下载 (3)"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(4).png" alt="下载 (4)"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(5).png" alt="下载 (5)"></p>
<p><img src="https://gitee.com/zhangliguang1/tuchuang/raw/master/img/%E4%B8%8B%E8%BD%BD%20(6).png" alt="下载 (6)"></p>
<h2 id="异常的嵌套"><a href="#异常的嵌套" class="headerlink" title="异常的嵌套"></a>异常的嵌套</h2><p>在有的情况下，希望在异常或中断中，系统可以继续处理其他的异常或中断。 这需要系统软件处理如下事情：</p>
<p>进入处理程序后，保存Context, EPC, status, cause等寄存器的值到内存栈中，然后设置UM&#x3D;0， 设置CPU模式为核心态，（异常并不会改status中UM的值，<code>EXL=1， ERL=1，UM=0</code>，任意一个条件成立都是内核态，为何要设置为内核态呢，因为只有在内核态才能访问cp0的特权资源），然后清除SR[EXL], 从而支持EPC会被更新，从而支持嵌套处理。但是当还没来得及清除SR[EXL]，另外一个异常立即就来了怎么办呢（中断不可能来，只可能是执行异常），那么所有寄存器的值都不会更新，直接跳转到异常向量处开始执行</p>
<p>在任何情况下，reset， softreset，NMI，都会无条件响应，并且设置ERL&#x3D;1，也就是说错误处理可以无条件相应，当然错误处理也是可以嵌套的。</p>
<p>在ERL&#x3D;1时，禁止任何中断和异常，除了reset， softreset，NMI</p>
<p>*SR[IE]是一个很重要的位来处理嵌套异常。值得注意的，或容易犯错的一点是：</p>
<p>在做恢复上下文时，要避免重入问题。比如，要用eret返回时， 要建立EPC的值。在此之 前，一定要先关闭中断<code>disable interrupt</code>. 否 则，EPC可能被冲掉。</p>
<p>下面是一段异常中断返回的例子代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* 读取SR的当前值*/</span><br><span class="line">mfc0 t0,C0[SR]</span><br><span class="line">/*加一个delay slot指令 */</span><br><span class="line">nop</span><br><span class="line">/* 清除SR[IE]，关闭中断 */</span><br><span class="line">li t1,~SR[IE]</span><br><span class="line">and t0,t0,t1</span><br><span class="line">mtc0 t0,C0[SR]</span><br><span class="line">nop</span><br><span class="line">/* 可以安全的恢复EPC的值*/</span><br><span class="line">ld t1,R_EPC(sp)</span><br><span class="line">mtc0 t1,C0[EPC]</span><br><span class="line">nop</span><br><span class="line">lhu k1, /* 恢复老的中断屏蔽码，被暂时保留在k1里*/</span><br><span class="line">or t0,t0,k1</span><br><span class="line">/*从新对SR[EXL]置位。ERET会自动将其清除。一定要理解，为什么中断例程要在前面要清除 EXL。如果不的话。就不能支持嵌套异常。为什么，希望读者能思考并回答。并且，在清EXL之前，我们一定要先把CPU模式变为核心模式。*/</span><br><span class="line">ori t0,t0,SR[EXL]</span><br><span class="line">/*一切就绪，恢复中断屏蔽码和对EXL置位*/</span><br><span class="line">mtc0 t0,C0[SR]</span><br><span class="line">nop</span><br><span class="line">ori t0,t0,SR[IE]</span><br><span class="line">/* 置为IE */</span><br><span class="line">ori t0,t0,SR[IMASK7 ]</span><br><span class="line">mtc0 t0,C0[SR ]</span><br><span class="line">nop</span><br><span class="line">/*恢复CPU模式 */</span><br><span class="line">ori t0, t0,SR[USERMODE]</span><br><span class="line">mtc0, t0, C0[SR]</span><br><span class="line">eret</span><br><span class="line">/* eret将对EXL清零 。所以要注意，如果你在处理程序中改变了CPU的模式，一定要确保，在重新设置EXL位后，恢复CPU的原来模式，否则用户进程将会在核心态下运行。</span><br></pre></td></tr></table></figure>

<h2 id="代码实例分析"><a href="#代码实例分析" class="headerlink" title="代码实例分析"></a>代码实例分析</h2><p>cfe中的异常处理  fsbl部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LEAF( do_chip_init )</span><br><span class="line">    move    s0, ra</span><br><span class="line">    li    t0, INITIAL_SR               //#define INITIAL_SR      ((/*CP0_STATUS_SR_MASK |*/ CP0_STATUS_CU1_MASK | CP0_STATUS_BEV_MASK | CP0_STATUS_IE_MASK) &amp; ~( CP0_STATUS_ERL_MASK | CP0_STATUS_EXL_MASK))</span><br><span class="line">    mtc0  t0, CP0_STATUS</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    mtc0  zero, CP0_CAUSE           # clear software interrupts</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br></pre></td></tr></table></figure>

<p>在这里将ERL和EXL都清除掉了，并且使能了中断</p>
<p>#define    CP0_STATUS_KSU_MASK              _MM_MAKEMASK(2,3)</p>
<p>#define    CP0_STATUS_KSU_SHIFT            (3)</p>
<p>复位后，处在内核态，并且cfe中一直处在内核态中，没有发生cpu模块的转换</p>
<h3 id="ssbl部分："><a href="#ssbl部分：" class="headerlink" title="ssbl部分："></a>ssbl部分：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">void cfe_main(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * Set up the exception vectors</span><br><span class="line">     */</span><br><span class="line">    cfe_setup_exceptions();</span><br><span class="line">&#125;</span><br><span class="line">void cfe_setup_exceptions(void)</span><br><span class="line">&#123;</span><br><span class="line">    _exc_setvector(XTYPE_TLBFILL,  (void *)   cfe_exception );</span><br><span class="line">    _exc_setvector(XTYPE_XTLBFILL, (void *) cfe_exception);</span><br><span class="line">    _exc_setvector(XTYPE_CACHEERR, (void *) _exc_cache_crash_sim);</span><br><span class="line">    _exc_setvector(XTYPE_EXCEPTION,(void *) cfe_exception);</span><br><span class="line">    _exc_setvector(XTYPE_INTERRUPT,(void *) cfe_exception);</span><br><span class="line">    _exc_setvector(XTYPE_EJTAG,    (void *) cfe_exception);</span><br><span class="line">    exc_handler.catch_exc = 0;</span><br><span class="line">    q_init( &amp;(exc_handler.jmpbuf_stack));</span><br><span class="line">#if (!CFG_BOOTRAM) &amp;&amp; (CFG_RUNFROMKSEG0)</span><br><span class="line">    /*</span><br><span class="line">     * Install RAM vectors, and clear the BEV bit in the status</span><br><span class="line">     * register.  Don&#x27;t do this if we&#x27;re running from PromICE RAM</span><br><span class="line">     */</span><br><span class="line">    exc_install_ram_vectors();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line">#define XTYPE_RESET    0</span><br><span class="line">#define XTYPE_TLBFILL    8</span><br><span class="line">#define XTYPE_XTLBFILL    16</span><br><span class="line">#define XTYPE_CACHEERR    24</span><br><span class="line">#define XTYPE_EXCEPTION    32</span><br><span class="line">#define XTYPE_INTERRUPT    40</span><br><span class="line">#define XTYPE_EJTAG    48</span><br><span class="line"></span><br><span class="line">        .globl    _exc_vectab</span><br><span class="line">_exc_vectab:    _LONG_    0        # XTYPE_RESET</span><br><span class="line">        _LONG_    0        # XTYPE_TLBFILL  (not used)        </span><br><span class="line">        _LONG_    0        # XTYPE_XTLBFILL</span><br><span class="line">        _LONG_    0        # XTYPE_CACHEERR (not used)</span><br><span class="line">        _LONG_    0        # XTYPE_EXCEPTION</span><br><span class="line">        _LONG_    0        # XTYPE_INTERRUPT</span><br><span class="line">        _LONG_    0        # XTYPE_EJTAG</span><br><span class="line">LEAF(_exc_setvector)</span><br><span class="line"></span><br><span class="line">        la    v0,_exc_vectab</span><br><span class="line">        srl    a0,3        /* convert 8-byte index to array index */</span><br><span class="line">        sll    a0,BPWSIZE    /* convert back to index appropriate for word size */</span><br><span class="line">        add    v0,a0</span><br><span class="line">        SR    a1,(v0)</span><br><span class="line">        j    ra</span><br><span class="line"></span><br><span class="line">END(_exc_setvector)</span><br><span class="line"></span><br><span class="line">void cfe_exception(int code,uint64_t *info)</span><br><span class="line">&#123;</span><br><span class="line">    int idx;</span><br><span class="line">    if(exc_handler.catch_exc == 1) &#123;      //允许异常处理被捕获</span><br><span class="line">        /*Deal with exception without restarting CFE.*/</span><br><span class="line">        /*Clear relevant SR bits*/</span><br><span class="line">        _exc_clear_sr_exl();</span><br><span class="line">        _exc_clear_sr_erl();</span><br><span class="line">        /*Reset flag*/</span><br><span class="line">        exc_handler.catch_exc = 0;</span><br><span class="line">        exc_longjmp_handler();       </span><br><span class="line">    &#125;</span><br><span class="line">    //仅仅打印异常引起异常的原因和信息</span><br><span class="line">    xprintf(&quot;**Exception %d: EPC=%08X, Cause=%08X, VAddr=%08X\n&quot;,</span><br><span class="line">        code,(uint32_t)info[XCP0_EPC],</span><br><span class="line">        (uint32_t)info[XCP0_CAUSE],(uint32_t)info[XCP0_VADDR]);</span><br><span class="line">    xprintf(&quot;RA=%08X, PRID=%08X\n&quot;,</span><br><span class="line">        (uint32_t)info[XGR_RA],(uint32_t)info[XCP0_PRID]);</span><br><span class="line">    xprintf(&quot;\n&quot;);</span><br><span class="line">    for (idx = 0;idx &lt; 32; idx+= 2) &#123;</span><br><span class="line">    xprintf(&quot;%2s ($%2d) = %08X %2s ($%2d) = %08X\n&quot;,</span><br><span class="line">        regnames+(idx*2),</span><br><span class="line">        idx,(uint32_t)info[XGR_ZERO+idx],</span><br><span class="line">        regnames+((idx+1)*2),</span><br><span class="line">        idx+1,(uint32_t)info[XGR_ZERO+idx+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    xprintf(&quot;\n&quot;);</span><br><span class="line">    xprintf(&quot;\n*** Waiting for system reset ***\n&quot;);    //直接挂机</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将异常向量保存在_exc_vectab这个表中，那么这个表由谁去调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">LEAF( _exc_entry )</span><br><span class="line">        .set noreorder</span><br><span class="line">        .set noat</span><br><span class="line">        subu    k1,sp,EXCEPTION_SIZE</span><br><span class="line">        SRL    k1,3</span><br><span class="line">        SLL    k1,3</span><br><span class="line"></span><br><span class="line">        SREG    zero,XGR_ZERO(k1)                #保存现场  #define SREG     sw</span><br><span class="line">        SREG     AT,XGR_AT(k1)</span><br><span class="line"></span><br><span class="line">        SREG    v0,XGR_V0(k1)</span><br><span class="line">        SREG    v1,XGR_V1(k1)</span><br><span class="line"></span><br><span class="line">        SREG    a0,XGR_A0(k1)</span><br><span class="line">        SREG    a1,XGR_A1(k1)</span><br><span class="line">        SREG    a2,XGR_A2(k1)</span><br><span class="line">        SREG    a3,XGR_A3(k1)</span><br><span class="line"></span><br><span class="line">        SREG    t0,XGR_T0(k1)</span><br><span class="line">        SREG    t1,XGR_T1(k1)</span><br><span class="line">        SREG    t2,XGR_T2(k1)</span><br><span class="line">        SREG    t3,XGR_T3(k1)</span><br><span class="line">        SREG    t4,XGR_T4(k1)</span><br><span class="line">        SREG    t5,XGR_T5(k1)</span><br><span class="line">        SREG    t6,XGR_T6(k1)</span><br><span class="line">        SREG    t7,XGR_T7(k1)</span><br><span class="line"></span><br><span class="line">        SREG    s0,XGR_S0(k1)</span><br><span class="line">        SREG    s1,XGR_S1(k1)</span><br><span class="line">        SREG    s2,XGR_S2(k1)</span><br><span class="line">        SREG    s3,XGR_S3(k1)</span><br><span class="line">        SREG    s4,XGR_S4(k1)</span><br><span class="line">        SREG    s5,XGR_S5(k1)</span><br><span class="line">        SREG    s6,XGR_S6(k1)</span><br><span class="line">        SREG    s7,XGR_S7(k1)</span><br><span class="line"></span><br><span class="line">        SREG    t8,XGR_T8(k1)</span><br><span class="line">        SREG    t9,XGR_T9(k1)</span><br><span class="line"></span><br><span class="line">        SREG    gp,XGR_GP(k1)</span><br><span class="line">        SREG    sp,XGR_SP(k1)</span><br><span class="line">        SREG    fp,XGR_FP(k1)</span><br><span class="line">        SREG    ra,XGR_RA(k1)</span><br><span class="line"></span><br><span class="line">        mfc0    t0,C0_CAUSE</span><br><span class="line">        mfc0    t1,C0_SR</span><br><span class="line">        mfc0    t2,C0_BADVADDR</span><br><span class="line">        mfc0    t3,C0_EPC</span><br><span class="line">        mfc0    t4,C0_PRID</span><br><span class="line">        mflo    t5</span><br><span class="line">        mfhi    t6    </span><br><span class="line">        SREG    t0,XCP0_CAUSE(k1)</span><br><span class="line">        SREG    t1,XCP0_SR(k1)</span><br><span class="line">        SREG    t2,XCP0_VADDR(k1)</span><br><span class="line">        SREG    t3,XCP0_EPC(k1)</span><br><span class="line">        SREG    t4,XCP0_PRID(k1)</span><br><span class="line">        SREG    t5,XGR_LO(k1)</span><br><span class="line">        SREG    t6,XGR_HI(k1)</span><br><span class="line"></span><br><span class="line">#if CFG_EMBEDDED_PIC</span><br><span class="line">        la        gp,PHYS_TO_K0(CFE_LOCORE_GLOBAL_GP)</span><br><span class="line">        LR        gp,0(gp)        # get our GP handle from low memory vector</span><br><span class="line">#else</span><br><span class="line">        la        gp,_gp            # Load up GP, not relocated so it&#x27;s easy</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /* Exception occurred in CFE */</span><br><span class="line">        move    a0,k0            # Pass exception type</span><br><span class="line">        move    a1,k1            # Pass frame to exception handler</span><br><span class="line">        la        t0, _exc_vectab         # get base of exception vectors</span><br><span class="line">        srl        k0,3            # convert 8-byte index to array index</span><br><span class="line">        sll        k0,BPWSIZE        # convert back to index appropriate for word size</span><br><span class="line">        addu    t0,k0            # get vector address</span><br><span class="line">        LR        t0,(t0)            # to call handler</span><br><span class="line"></span><br><span class="line">        move    sp,k1            # &quot;C&quot; gets fresh stack area</span><br><span class="line">        jalr    t0            # Call exception handler</span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">        move    k1, sp</span><br><span class="line">        LREG      AT,XGR_AT(k1)</span><br><span class="line"></span><br><span class="line">        LREG    t0,XGR_LO(k1)</span><br><span class="line">        LREG    t1,XGR_HI(k1)</span><br><span class="line">        mtlo    t0</span><br><span class="line">        mthi    t1</span><br><span class="line"></span><br><span class="line">        LREG    a0,XGR_A0(k1)</span><br><span class="line">        LREG    a1,XGR_A1(k1)</span><br><span class="line">        LREG    a2,XGR_A2(k1)</span><br><span class="line">        LREG    a3,XGR_A3(k1)</span><br><span class="line"></span><br><span class="line">        LREG    t0,XGR_T0(k1)</span><br><span class="line">        LREG    t1,XGR_T1(k1)</span><br><span class="line">        LREG    t2,XGR_T2(k1)</span><br><span class="line">        LREG    t3,XGR_T3(k1)</span><br><span class="line">        LREG    t4,XGR_T4(k1)</span><br><span class="line">        LREG    t5,XGR_T5(k1)</span><br><span class="line">        LREG    t6,XGR_T6(k1)</span><br><span class="line">        LREG    t7,XGR_T7(k1)</span><br><span class="line"></span><br><span class="line">        LREG    s0,XGR_S0(k1)</span><br><span class="line">        LREG    s1,XGR_S1(k1)</span><br><span class="line">        LREG    s2,XGR_S2(k1)</span><br><span class="line">        LREG    s3,XGR_S3(k1)</span><br><span class="line">        LREG    s4,XGR_S4(k1)</span><br><span class="line">        LREG    s5,XGR_S5(k1)</span><br><span class="line">        LREG    s6,XGR_S6(k1)</span><br><span class="line">        LREG    s7,XGR_S7(k1)</span><br><span class="line"></span><br><span class="line">        LREG    t8,XGR_T8(k1)</span><br><span class="line">        LREG    t9,XGR_T9(k1)</span><br><span class="line"></span><br><span class="line">        LREG    gp,XGR_GP(k1)</span><br><span class="line">        LREG    sp,XGR_SP(k1)</span><br><span class="line">        LREG    fp,XGR_FP(k1)</span><br><span class="line">        LREG    ra,XGR_RA(k1)</span><br><span class="line"></span><br><span class="line">/* do any CP0 cleanup here */</span><br><span class="line"></span><br><span class="line">        LREG    v0,XGR_V0(k1)</span><br><span class="line">        LREG    v1,XGR_V1(k1)</span><br><span class="line">    </span><br><span class="line">        ERET</span><br><span class="line"></span><br><span class="line">        .set at</span><br><span class="line">        .set reorder</span><br><span class="line"></span><br><span class="line">END(_exc_entry)</span><br></pre></td></tr></table></figure>

<p>那么 _exc_entry又是怎么调用的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exc_install_ram_vectors</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ptr;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="comment">/* Debug: blow away the vector area so we can see what we did */</span></span><br><span class="line">    ptr = (<span class="type">uint32_t</span> *) PHYS_TO_K0(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="number">0x1000</span>/<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>); idx++) *ptr++ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the vectors.  The cache error handler is set up</span></span><br><span class="line"><span class="comment">     * specially.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    exc_setup_hw_vector(MIPS_RAM_VEC_TLBFILL,  CPUCFG_TLBHANDLER,XTYPE_TLBFILL);</span><br><span class="line">    exc_setup_hw_vector(MIPS_RAM_VEC_XTLBFILL,   _exc_entry ,XTYPE_XTLBFILL);</span><br><span class="line">    exc_setup_hw_vector(MIPS_RAM_VEC_CACHEERR, _exc_entry,XTYPE_CACHEERR);</span><br><span class="line">    exc_setup_hw_vector(MIPS_RAM_VEC_EXCEPTION,_exc_entry,XTYPE_EXCEPTION);</span><br><span class="line">    exc_setup_hw_vector(MIPS_RAM_VEC_INTERRUPT,_exc_entry,XTYPE_INTERRUPT);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flush the D-cache and invalidate the I-cache so we can start</span></span><br><span class="line"><span class="comment">     * using these vectors.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cfe_flushcache(CFE_CACHE_FLUSH_D | CFE_CACHE_INVAL_I,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Write the handle into our low memory space.  If we need to save</span></span><br><span class="line"><span class="comment">     * other stuff down there, this is a good place to do it.</span></span><br><span class="line"><span class="comment">     * This call uses uncached writes - we have not touched the</span></span><br><span class="line"><span class="comment">     * memory in the handlers just yet, so they should not be</span></span><br><span class="line"><span class="comment">     * in our caches.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _exc_setup_locore((<span class="type">intptr_t</span>) CPUCFG_CERRHANDLER);  <span class="comment">//重新设置cache 错误异常处理向量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, clear BEV so we&#x27;ll use the vectors in RAM.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    _setstatus(_getstatus() &amp; ~M_SR_BEV);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * XXX There&#x27;s a hazard here, but we&#x27;re not going to worry about</span></span><br><span class="line"><span class="comment">     * XXX it.  It is unlikely we&#x27;ll use the vectors any time soon.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清掉BEV标志，因此除了reset， soft reset，NMI外，所有其他的中断向量都在RAM中<code>0X8000_0000</code>开始处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_RESET    0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_TLBFILL    0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_XTLBFILL    0x0280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_CACHEERR    0x0300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_EXCEPTION    0x0380</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_INTERRUPT    0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_ROM_VEC_EJTAG    0x0480</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_TLBFILL    0x0000                       <span class="comment">//EXL=0时TLB异常入口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_XTLBFILL    0x0080                      <span class="comment">//EXL=1时TLB异常入口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_CACHEERR    0x0100                  <span class="comment">//cache 错误异常入口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_EXCEPTION    0x0180                  <span class="comment">//通用异常入口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_INTERRUPT    0x0200                  <span class="comment">//中断入口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_RAM_VEC_END    0x0300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPUCFG_TLBHANDLER        bcmcore_tlbhandler</span></span><br></pre></td></tr></table></figure>

<p>TLB异常为何要在分EXL处理呢，主要是为了处理更高效，因为EXL&#x3D;0时，TLB发生异常的频率很高，所以单独搞个专用的TLB异常向量，可以极大的提升系统性能，因为通用异常处理向量要根据异常码分开处理，效率不高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> _exc_setup_locore((intptr_t) CPUCFG_CERRHANDLER);  //重新设置cache 错误异常处理向量，这个函数</span><br><span class="line">        li    t0,PHYS_TO_K1(CFE_LOCORE_GLOBAL_CERRH)</span><br><span class="line">        SR    a0,0(t0)</span><br><span class="line">#把正常的异常处理向量保存在CFE_LOCORE_GLOBAL_CERRH内存中，然后</span><br><span class="line">        li    t0,PHYS_TO_K1(MIPS_RAM_VEC_CACHEERR)</span><br><span class="line"></span><br><span class="line">        LOADREL(t1,_exc_cerr_htable)</span><br><span class="line">        LR    t2,R_EXC_CERR_TEMPLATE_END(t1)</span><br><span class="line">        LR    t1,R_EXC_CERR_TEMPLATE(t1)</span><br><span class="line">#将_exc_cerr_htable中存放的异常处理函数拷贝覆盖到    exc_setup_hw_vector(MIPS_RAM_VEC_CACHEERR, _exc_entry,XTYPE_CACHEERR);已经安装的内存中，也就是0x0100的内存中</span><br><span class="line">_exc_cerr_htable:</span><br><span class="line">        _LONG_    _exc_cerr_template</span><br><span class="line">        _LONG_    _exc_cerr_template_end</span><br><span class="line"></span><br><span class="line">LEAF(_exc_cerr_template)</span><br><span class="line">        LR    k0,CFE_LOCORE_GLOBAL_CERRH(zero)</span><br><span class="line">        jal    k0</span><br><span class="line">         nop</span><br><span class="line">#取出保存的异常向量地址</span><br><span class="line">/*</span><br><span class="line">* Temporary until all our CPU packages support a cache error handler</span><br><span class="line">*/</span><br><span class="line">#ifndef CPUCFG_CERRHANDLER</span><br><span class="line">#define CPUCFG_CERRHANDLER 0xBFC00000</span><br><span class="line">#else</span><br><span class="line">extern void CPUCFG_CERRHANDLER(void);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里实际上是没有定义 CPUCFG_CERRHANDLER的，因此在cfe中cache错误将导致直接重启</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exc_setup_hw_vector</span><span class="params">(<span class="type">uint32_t</span> vecoffset,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *target,</span></span><br><span class="line"><span class="params">                  <span class="type">uint32_t</span> k0code)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *vec;</span><br><span class="line">    <span class="type">uint32_t</span> new;</span><br><span class="line">    <span class="type">uint32_t</span> lower,upper;</span><br><span class="line">    new = (<span class="type">uint32_t</span>) (<span class="type">intptr_t</span>) target;    <span class="comment">/* warning: assumes compatibility addresses! */</span></span><br><span class="line">    lower = new &amp; <span class="number">0xffff</span>;</span><br><span class="line">    upper = (new &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">    <span class="keyword">if</span> ((lower &amp; <span class="number">0x8000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    upper++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a KSEG0 version of the vector offset.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vec = (<span class="type">uint32_t</span> *) PHYS_TO_K0(vecoffset);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Patch in the vector.  Note that we have to flush</span></span><br><span class="line"><span class="comment">     * the L1 Dcache and invalidate the L1 Icache before</span></span><br><span class="line"><span class="comment">     * we can use this.  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vec[<span class="number">0</span>] = <span class="number">0x3c1b0000</span> | upper;   <span class="comment">/* lui   k1, HIGH(new)     */</span></span><br><span class="line">    vec[<span class="number">1</span>] = <span class="number">0x277b0000</span> | lower;   <span class="comment">/* addiu k1, k1, LOW(new)  */</span></span><br><span class="line">    vec[<span class="number">2</span>] = <span class="number">0x03600008</span>;           <span class="comment">/* jr    k1                */</span></span><br><span class="line">    vec[<span class="number">3</span>] = <span class="number">0x241a0000</span> | k0code;  <span class="comment">/*  li   k0, code          */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kernel中的异常处理</p>
<p><strong>处理程序什么时候安装?</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">traps_init(arch/mips/kernel/traps.c,setup_arch之后start_kernel调用)</span><br><span class="line"><span class="comment">/* Copy the generic exception handler code to it&#x27;s final destination. */</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG0 + <span class="number">0x80</span>), &amp;except_vec1_generic, <span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG0 + <span class="number">0x100</span>), &amp;except_vec2_generic, <span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG0 + <span class="number">0x180</span>), &amp;except_vec3_generic, <span class="number">0x80</span>);</span><br><span class="line">flush_icache_range(KSEG0 + <span class="number">0x80</span>, KSEG0 + <span class="number">0x200</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Setup default vectors</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; i++)</span><br><span class="line">set_except_vector(i, handle_reserved);</span><br></pre></td></tr></table></figure>

<p><strong>装的什么?</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">except_vec3_generic(head.S) #(除了TLB refill例外都用这个入口): /* General exception vector R4000 version. */</span><br><span class="line">NESTED(except_vec3_r4000, 0, sp)</span><br><span class="line">.set noat</span><br><span class="line">mfc0 k1, CP_CAUSE</span><br><span class="line">andi k1, k1, 0x7c /* 从cause寄存器取出异常号 */</span><br><span class="line">li k0, 31&lt;&lt;2 beq k1, k0, handle_vced /* 如果是vced,处理之*/</span><br><span class="line">li k0, 14&gt;&lt;&lt;2 beq k1, k0, handle_vcei /* 如果是vcei,处理之*/</span><br><span class="line">/* 这两个异常是和cache相关的,cache出了问题,不能再在这个cached的位置处理啦 */</span><br><span class="line">la k0, exception_handlers /* 取出异常处理程序表 */</span><br><span class="line">addu k0, k0, k1 lw k0, (k0) /*处理函数*/</span><br><span class="line">nop jr k0 /*运行异常处理函数*/</span><br><span class="line">nop</span><br></pre></td></tr></table></figure>

<p><strong>那个异常处理程序表是如何初始化的呢?</strong></p>
<p>在traps_init中,大家会看到<code>set_exception_vector</code>(i,handler)这样的代码, 填的就是这张表啦.可是,如果你用souce insigh之类的东西去找那个handler,往往就落空了,??怎么没有handle_ri,handle_tlbl…_?不着急,只不过是一个小trick, 还记得x86中断处理的handler代码吗? 它们是用宏生成的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry.S</span><br><span class="line">#define BUILD_HANDLER(exception,handler,clear,verbose)</span><br><span class="line">.align 5;</span><br><span class="line">NESTED(handle_##exception, PT_SIZE, sp);</span><br><span class="line">.set noat;</span><br><span class="line">SAVE_ALL; /* 保存现场,切换栈(如必要)*/</span><br><span class="line">__BUILD_clear_##clear(exception); /*关中断?*/</span><br><span class="line">.set at;</span><br><span class="line">__BUILD_##verbose(exception);</span><br><span class="line">jal do_##handler; /*干活*/</span><br><span class="line">move a0, sp;</span><br><span class="line">ret_from_exception; /*回去*/</span><br><span class="line">nop;</span><br><span class="line">END(handle_##exception) /*生成处理函数*/</span><br><span class="line">BUILD_HANDLER(adel,ade,ade,silent) /* #4 */</span><br><span class="line">BUILD_HANDLER(ades,ade,ade,silent) /* #5 */</span><br><span class="line">BUILD_HANDLER(ibe,ibe,cli,verbose) /* #6 */</span><br><span class="line">BUILD_HANDLER(dbe,dbe,cli,silent) /* #7 */</span><br><span class="line">BUILD_HANDLER(bp,bp,sti,silent) /* #9 */</span><br></pre></td></tr></table></figure>

<p>认真追究下去,这里的一些宏是很重要的,象SAVE_ALL(include&#x2F;asm&#x2F;stackframe.h), 异常处理要高效,正确,这里要非常小心.这是因为硬件做的事情实在太少了.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag"># 异常</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/20/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E8%B0%83%E7%A0%94/" rel="prev" title="scudo 内存分配器调研">
      <i class="fa fa-chevron-left"></i> scudo 内存分配器调研
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/25/hxd_new/mips%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8/" rel="next" title="mips cp0">
      mips cp0 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">异常处理的一般过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%85%A5%E5%8F%A3%EF%BC%88%E5%90%91%E9%87%8F%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">异常入口（向量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.</span> <span class="nav-text">异常优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">异常相关寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SR-Status-Register%EF%BC%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">SR(Status Register，状态寄存器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cause"><span class="nav-number">4.2.</span> <span class="nav-text">Cause</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPC%E5%AD%98%E6%94%BE%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">4.3.</span> <span class="nav-text">EPC存放返回地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WatchLo%E3%80%81WatchHi"><span class="nav-number">4.4.</span> <span class="nav-text">WatchLo、WatchHi</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CP0%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">CP0相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CP0-%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.</span> <span class="nav-text">CP0 主要操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CP0-%E5%86%92%E9%99%A9%E7%8E%B0%E8%B1%A1"><span class="nav-number">5.2.</span> <span class="nav-text">CP0 冒险现象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MIPS-cpu%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">MIPS cpu中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mips-%E5%BC%82%E5%B8%B8"><span class="nav-number">6.1.</span> <span class="nav-text">mips 异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mips%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.2.</span> <span class="nav-text">mips异常处理步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mips%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BE%8B%E5%AD%90"><span class="nav-number">6.3.</span> <span class="nav-text">mips异常处理例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">6.4.</span> <span class="nav-text">中断寄存器相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">6.5.</span> <span class="nav-text">中断处理步骤：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">常见的异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reset-Exception"><span class="nav-number">7.1.</span> <span class="nav-text">Reset Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Non-Maskable-Interrupt-NMI-Exception"><span class="nav-number">7.2.</span> <span class="nav-text">Non-Maskable Interrupt (NMI) Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Machine-Check-Exception-4Kc-core"><span class="nav-number">7.3.</span> <span class="nav-text">Machine Check Exception (4Kc core)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt-Exception"><span class="nav-number">7.4.</span> <span class="nav-text">Interrupt Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB-Refill-Exception"><span class="nav-number">7.5.</span> <span class="nav-text">TLB Refill Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB-Invalid-Exception-%E2%80%94-Instruction-Fetch-or-Data-Access-4Kc-core"><span class="nav-number">7.6.</span> <span class="nav-text">TLB Invalid Exception — Instruction Fetch or Data Access (4Kc core)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bus-Error-Exception-%E2%80%94-Instruction-Fetch-or-Data-Access"><span class="nav-number">7.7.</span> <span class="nav-text">Bus Error Exception — Instruction Fetch or Data Access</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">详细异常处理流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">9.</span> <span class="nav-text">异常的嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">10.</span> <span class="nav-text">代码实例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ssbl%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">10.1.</span> <span class="nav-text">ssbl部分：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">93</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VrGRp2q7WwXjxsCNmlDIZYbC-gzGzoHsz',
      appKey     : 'JgMXmmB7yKQf2zm80TaBp3JT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

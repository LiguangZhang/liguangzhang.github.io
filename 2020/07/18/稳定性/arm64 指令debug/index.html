<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW WenKai:300,300italic,400,400italic,700,700italic|LXGW WenKai Mono, Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="1. arm64 寄存器和指令1.1. 寄存器arm64 有34个寄存器, 包含31个通用寄存器, SP PC CPSR  寄存器中可以存地址, 也可以存值.     寄存器 位数 描述    x0-x30 64 通用寄存器, 可以作 位使用: w0-w30 (访问寄存器的低位)   x0-x7 64 用于子程序调用时参数传递(形参), x0 还用于返回值传递   FP(x29) 64 当前栈帧的">
<meta property="og:type" content="article">
<meta property="og:title" content="arm gdb 调试">
<meta property="og:url" content="https://liguangzhang.github.io/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/arm64%20%E6%8C%87%E4%BB%A4debug/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="1. arm64 寄存器和指令1.1. 寄存器arm64 有34个寄存器, 包含31个通用寄存器, SP PC CPSR  寄存器中可以存地址, 也可以存值.     寄存器 位数 描述    x0-x30 64 通用寄存器, 可以作 位使用: w0-w30 (访问寄存器的低位)   x0-x7 64 用于子程序调用时参数传递(形参), x0 还用于返回值传递   FP(x29) 64 当前栈帧的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liguangzhang.github.io/images/20200902165648.png">
<meta property="article:published_time" content="2020-07-18T10:15:54.000Z">
<meta property="article:modified_time" content="2024-05-06T05:58:04.133Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="arm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liguangzhang.github.io/images/20200902165648.png">

<link rel="canonical" href="https://liguangzhang.github.io/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/arm64%20%E6%8C%87%E4%BB%A4debug/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'" />

  <title>arm gdb 调试 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/arm64%20%E6%8C%87%E4%BB%A4debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          arm gdb 调试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-18 18:15:54" itemprop="dateCreated datePublished" datetime="2020-07-18T18:15:54+08:00">2020-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 13:58:04" itemprop="dateModified" datetime="2024-05-06T13:58:04+08:00">2024-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%B3%E5%AE%9A%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">稳定性</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/arm64%20%E6%8C%87%E4%BB%A4debug/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/arm64%20%E6%8C%87%E4%BB%A4debug/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-arm64-寄存器和指令"><a href="#1-arm64-寄存器和指令" class="headerlink" title="1. arm64 寄存器和指令"></a>1. arm64 寄存器和指令</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1. 寄存器"></a>1.1. 寄存器</h2><p>arm64 有34个寄存器, 包含31个通用寄存器, SP PC CPSR</p>
<blockquote>
<p>寄存器中可以存地址, 也可以存值.</p>
</blockquote>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>位数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x0-x30</td>
<td>64</td>
<td>通用寄存器, 可以作 位使用: w0-w30 (访问寄存器的低位)</td>
</tr>
<tr>
<td>x0-x7</td>
<td>64</td>
<td>用于子程序调用时参数传递(形参), x0 还用于返回值传递</td>
</tr>
<tr>
<td>FP(x29)</td>
<td>64</td>
<td>当前栈帧的栈底 (android上 向上增长), 栈顶地址 &lt; 栈底</td>
</tr>
<tr>
<td>LR(x30)</td>
<td>64</td>
<td>程序链接寄存器, 保存子程序结束后需要执行的下一条指令. <span style="color: green">即谁调用了当前函数.</span></td>
</tr>
<tr>
<td>SP</td>
<td>64</td>
<td>保存栈指针, 使用SP&#x2F;WSP来进行对栈寄存器的访问</td>
</tr>
<tr>
<td>PC</td>
<td>64</td>
<td>程序计数器, 俗称PC指针, 总是指向即将执行的下一条指令, 在arm64中, 软件不能修改pc寄存器</td>
</tr>
<tr>
<td>CPSR</td>
<td>64</td>
<td>状态寄存器,    NZCV是状态寄存器的条件标志位，分别代表运算过程中产生的状态</td>
</tr>
</tbody></table>
<blockquote>
<p>我们可以根据FP和SP寄存器回溯函数调用过程，通过这两个值，我们可以知道函数的栈起始地址（也就是FP寄存器的值）， 以及栈顶（也就是SP寄存器的值）。得到了m函数的栈帧，就很容易从里面提取LR寄存器的值了（FP向下偏移8个字节即为LR），也就知道了谁调用了当前函数。以此类推，可以得到一个完整的函数调用链（一般回溯到 main函数或者线程入口函数就没必要继续了）。实际上，回溯过程中我们并不需要知道栈顶SP，只要FP就够了</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903923719864333">https://juejin.im/post/6844903923719864333</a></p>
<h3 id="1-1-1-arm64-约定"><a href="#1-1-1-arm64-约定" class="headerlink" title="1.1.1. arm64 约定"></a>1.1.1. arm64 约定</h3><ul>
<li><code>x0 ~ x7</code> 分别会存放方法的前 8 个参数；如果参数个数超过了8个，多余的参数会存在栈上，新方法会通过栈来读取。</li>
<li>方法的返回值一般都在 <code>x0</code> 上；如果方法返回值是一个较大的数据结构时，结果会存在 <code>x8</code> 执行的地址上。</li>
</ul>
<h2 id="1-2-虚存地址与elf-段地虚址"><a href="#1-2-虚存地址与elf-段地虚址" class="headerlink" title="1.2. 虚存地址与elf 段地虚址"></a>1.2. 虚存地址与elf 段地虚址</h2><p>cat &#x2F;proc&#x2F;pid&#x2F;maps 查看用户空间的虚存映射, 栈空间自[stack] 起, 查看pc 值可确定代码当前的运行位置. 程序代码段[.text] 位于maps 的映射的 本elf 文件的映射地址</p>
<p>![[Drawing 2022-04-11 01.04.40.excalidraw]]</p>
<h2 id="1-3-小端序和大端序"><a href="#1-3-小端序和大端序" class="headerlink" title="1.3. 小端序和大端序"></a>1.3. 小端序和大端序</h2><p>**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)**。</p>
<p>字节序分为两类：Big-Endian 和 Little-Endian，引用标准的 Big-Endian 和 Little-Endian 的定义如下：</p>
<ul>
<li>Little-Endian：就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>Big-Endian：就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
<li>网络字节序：TCP&#x2F;IP各层协议将字节序定义为 Big-Endian（这与主机序相反），因此TCP&#x2F;IP协议中使用的字节序通常称之为网络字节序。</li>
</ul>
<blockquote>
<p> android 中是小端序, 低位字节排放在内存的低地址端，高位字节排放在内存的高地址端, 所以读字时, 字节间 <code>应该从右往左读</code>, 每个字节的读取还是<code>从左往右</code>读</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://itimetraveler.github.io/2018/01/18/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADCPU%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/#%E5%B8%B8%E8%A7%81CPU%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F">常见CPU字节序</a></p>
<h2 id="1-4-寻址空间"><a href="#1-4-寻址空间" class="headerlink" title="1.4. 寻址空间"></a>1.4. 寻址空间</h2><p>android上采用 39位寻址+3级页表</p>
<p><img src="/images/20200902165648.png" alt="FA36326B-AB85-4E2E-A170-B5091504CECE"></p>
<h3 id="1-4-1-查看elf-各段的地址及确认初始化段区域"><a href="#1-4-1-查看elf-各段的地址及确认初始化段区域" class="headerlink" title="1.4.1. 查看elf 各段的地址及确认初始化段区域"></a>1.4.1. 查看elf 各段的地址及确认初始化段区域</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-android-objdump -h native_test</span><br></pre></td></tr></table></figure>

<ul>
<li>BSS段 （bss segment）通常是指用来存放程序中<code>未初始化的全局变量</code>和<code>初始化为0的全局变量</code>的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。</li>
<li>data段 该段用于存储<code>初始化非0的全局变量</code>和静态局部变量，<code>初始化为0的全局变量</code>出于编译优化的策略还是被保存在BSS段</li>
<li>rodata段     常量区，用于存放常量数据，ro就是Read Only之意。但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：<ul>
<li>有些立即数与指令编译在一起直接放在代码段。</li>
<li>对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份</li>
<li>用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。</li>
<li>有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率</li>
</ul>
</li>
<li>text段    text段是用于存放程序代码的，编译时确定,只读。更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器链接各个目标文件并解决各个源文件之间函数的引用，与此同时，还得将所有目标文件中的.text段合在一起，但不是简单的将它们“堆”在一起就完事，还需要处理各个段之间的函数引用问题。</li>
<li>stack段   也就是栈段，常说的堆栈段之一，是由系统负责申请释放，其操作方式类似stack，用于存储参数变量及局部变量，其实函数的执行也是stack的方式，所以才有了递归</li>
<li>heap段    也就是俗称的堆，它由用户申请和释放，申请时至少分配虚存，当真正存储数据时才分配相应的实存，释放时也并非立即释放实存，而是可能被重复利用</li>
<li>dynamic 段 外部符号表区, gdb调试时可以看到一些符号表信息, 库函数外部可见时, 相关符号表会在该段中</li>
<li>sym_tab 段, 外部+内部符号表区, 内部可见(如static 定义的函数), 相关符号在该段中.</li>
</ul>
<h4 id="1-4-1-1-hexdump打印常量等段的内容"><a href="#1-4-1-1-hexdump打印常量等段的内容" class="headerlink" title="1.4.1.1. hexdump打印常量等段的内容"></a>1.4.1.1. hexdump打印常量等段的内容</h4><p>找到基址和偏移 大小后 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11 .rodata       00000134  0000000000000dc8  0000000000000dc8  00000dc8  2**2</span><br><span class="line">                 CONTENTS, ALLOC, LOAD, READONLY, DAT</span><br><span class="line">hexdump native_test -s 0x00000dc8 -n 308  -C</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意一定要使用<code>0x</code>覆盖地址, 不然是打印的10进制的偏移</p>
</blockquote>
<h2 id="1-5-arm64-指令"><a href="#1-5-arm64-指令" class="headerlink" title="1.5. arm64 指令"></a>1.5. arm64 指令</h2><p><a target="_blank" rel="noopener" href="https://wiki.n.miui.com/pages/viewpage.action?pageId=340834589">https://wiki.n.miui.com/pages/viewpage.action?pageId=340834589</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903816362459144">https://juejin.im/post/6844903816362459144</a></p>
<blockquote>
<p> <code>[]</code>的意思是取地址的值, 不要跟地址弄混了</p>
</blockquote>
<h3 id="1-5-1-stp-ldp-str-ldr-stur-ldur指令"><a href="#1-5-1-stp-ldp-str-ldr-stur-ldur指令" class="headerlink" title="1.5.1. stp ldp str ldr stur ldur指令"></a>1.5.1. stp ldp str ldr stur ldur指令</h3><p>压栈入栈指令, 对于一个64位地址, 将64位地址值压入栈中, 需要有8个字节来存储.<span style="color: red">一个地址只能存一个字节, 与位长度没有关系</span> , stp 两个寄存器则需要16个字节. 打印寄存器的值时是按照<code>字</code>来打印的, 64位上一个<code>字</code>是8个字节</p>
<p><code>str w9, [sp, #0x8]</code> ; 将寄存器 w9 中的值保存到栈内存 [sp + 0x8] - [sp + 0x8 + 0x4 ] 处</p>
<p><code>stp x29, x30, [sp, #0x10]</code> ; 将 x29, x30 的值存入 [sp + 0x10] - [sp + 0x10 + 0x10] 字节的位置</p>
<p>stur： 同 str 将寄存器中的值写入到内存中（一般用于 负 地址运算中），如：<code>stur w10, [x29, #-0x4]</code> ; 将寄存器 w10 中的值保存到栈内存 [x29 - 0x04] 处 </p>
<p>ldur： 同 ldr 将内存中的值读取到寄存器中（一般用于 负 地址运算中），如：<code>ldur w8, [x29, #-0x4]</code> ; 将栈内存 [x29 - 0x04] 处的值读取到 w8 寄存器中 </p>
<h3 id="1-5-2-ldrsw"><a href="#1-5-2-ldrsw" class="headerlink" title="1.5.2. ldrsw"></a>1.5.2. ldrsw</h3><p>读取内存地址的值给寄存器。</p>
<p>LDRSW x9 ,[x8 ,x9 ,lsl #2] 为将以x8寄存器为基地址加上x9寄存器向左偏移两个单位的值后取其地址的值给x9寄存器。</p>
<h3 id="1-5-3-adrp"><a href="#1-5-3-adrp" class="headerlink" title="1.5.3. adrp"></a>1.5.3. adrp</h3><p>范围寻址, 通俗来讲，ADRP指令就是先进行PC+imm（偏移值）然后找到lable所在的一个4KB的页，然后取得label的基址，再进行偏移去寻址</p>
<p>offset 左移12位(4K对齐), PC的低12位抹0 + offset 4k对齐的结果, 得到一个基址.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1118</span>:    f0ffffe8     <span class="keyword">adrp</span>    <span class="built_in">x8</span>, <span class="number">0</span> &lt;abitag-<span class="number">0x2c0</span>&gt;</span><br><span class="line"><span class="number">111</span>c:    <span class="number">91123108</span>     <span class="keyword">add</span>    <span class="built_in">x8</span>, <span class="built_in">x8</span>, <span class="number">#0x48c</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-指令列表附录"><a href="#1-5-4-指令列表附录" class="headerlink" title="1.5.4. 指令列表附录"></a>1.5.4. 指令列表附录</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ADC</td>
<td>带进位的位数加法</td>
</tr>
<tr>
<td>ADD</td>
<td>位数相加</td>
</tr>
<tr>
<td>SUB</td>
<td>位减法</td>
</tr>
<tr>
<td>AND</td>
<td>位数的逻辑与</td>
</tr>
<tr>
<td>B</td>
<td>在M空间内的相对跳转指令</td>
</tr>
<tr>
<td>BR</td>
<td>跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。</td>
</tr>
<tr>
<td>brk</td>
<td>可以理解为跳转指令特殊的一种</td>
</tr>
<tr>
<td>BKPT</td>
<td>断点指令</td>
</tr>
<tr>
<td>BL</td>
<td>带链接的相对跳转指令-(1) 将下一条指令的地址放入lr(x30)寄存器，(2)转到标号出执行指令</td>
</tr>
<tr>
<td>BLX</td>
<td>带链接的切换跳转</td>
</tr>
<tr>
<td>BX</td>
<td>切换跳转</td>
</tr>
<tr>
<td>BEQ</td>
<td>相等则跳转（Branch if EQual）</td>
</tr>
<tr>
<td>BNE</td>
<td>不相等则跳转（Branch if Not Equal）</td>
</tr>
<tr>
<td>BGE</td>
<td>大于或等于跳转（Branch if Greater than or Equa）</td>
</tr>
<tr>
<td>BGT</td>
<td>大于跳转（Branch if Greater Than）</td>
</tr>
<tr>
<td>BIC</td>
<td>位数的逻辑位清零</td>
</tr>
<tr>
<td>RET</td>
<td>默认使用lr(x30)寄存器的值通过底层指令提示CPU此处作为下条指令地址（ARM64平台的特色指</td>
</tr>
<tr>
<td>BLE</td>
<td>小于或等于跳转（Branch if Less than or Equal）</td>
</tr>
<tr>
<td>BLEQ</td>
<td>带链接等于跳转（Branch with Link if EQual）</td>
</tr>
<tr>
<td>BLLT</td>
<td>带链接小于跳转（Branch with Link if Less Than）</td>
</tr>
<tr>
<td>BLTt</td>
<td>小于跳转（Branch if Less Than）</td>
</tr>
<tr>
<td>CDP CDP2</td>
<td>协处理器数据处理操作</td>
</tr>
<tr>
<td>CLZ</td>
<td>零计数</td>
</tr>
<tr>
<td>CMN</td>
<td>比较两个数的相反数</td>
</tr>
<tr>
<td>CMP</td>
<td>位数比较</td>
</tr>
<tr>
<td>EOR</td>
<td>位逻辑异或</td>
</tr>
<tr>
<td>LDC LDC2</td>
<td>从协处理器取一个或多个位值</td>
</tr>
<tr>
<td>LDM</td>
<td>从内存送多个位字到ARM寄存器</td>
</tr>
<tr>
<td>STUR</td>
<td>把寄存器的值(位)存到一个内存的虚地址内间(一般等同str)</td>
</tr>
<tr>
<td>STR</td>
<td>把寄存器的值(128位&#x2F;64位)存到一个内存的虚地址内间</td>
</tr>
<tr>
<td>LDP</td>
<td>str的变种，可以同时操作两个寄存器</td>
</tr>
<tr>
<td>LDR（load register）</td>
<td>从内存地址取一个单个的位值加载入通用寄存器</td>
</tr>
<tr>
<td>STD</td>
<td>ldr的变种，可以同时操作两个寄存器</td>
</tr>
<tr>
<td>DLP（load register）</td>
<td>从内存地址取一个单个的64位值加载入通用寄存器</td>
</tr>
<tr>
<td>MCR MCR2 MCRR</td>
<td>从寄存器送数据到协处理器</td>
</tr>
<tr>
<td>MLA</td>
<td>位乘累加</td>
</tr>
<tr>
<td>MOV</td>
<td>传送一个位数到寄存器</td>
</tr>
<tr>
<td>MRC MRC2 MRRC</td>
<td>从协处理器传送数据到寄存器</td>
</tr>
<tr>
<td>MRS</td>
<td>把状态寄存器的值送到通用寄存器</td>
</tr>
<tr>
<td>MSR</td>
<td>把通用寄存器的值传送到状态寄存器</td>
</tr>
<tr>
<td>MUL</td>
<td>位乘</td>
</tr>
<tr>
<td>MVN</td>
<td>把一个位数的逻辑“非”送到寄存器</td>
</tr>
<tr>
<td>ORR</td>
<td>位逻辑或</td>
</tr>
<tr>
<td>PLD</td>
<td>预装载提示指令</td>
</tr>
<tr>
<td>QADD</td>
<td>有符号位饱和加</td>
</tr>
<tr>
<td>QDADD</td>
<td>有符号双位饱和加</td>
</tr>
<tr>
<td>QSUB</td>
<td>有符号位饱和减</td>
</tr>
<tr>
<td>QDSUB</td>
<td>有符号双位饱和减</td>
</tr>
<tr>
<td>RSB</td>
<td>逆向位减法</td>
</tr>
<tr>
<td>RSC</td>
<td>带进位的逆向法减法</td>
</tr>
<tr>
<td>SBC</td>
<td>带进位的位减法</td>
</tr>
<tr>
<td>SMLAxy</td>
<td>有符号乘累加(16位*16位)+位&#x3D;位</td>
</tr>
<tr>
<td>SMLAL</td>
<td>64位有符号乘累加((位*位)+64位&#x3D;64位)</td>
</tr>
<tr>
<td>SMALxy</td>
<td>64位有符号乘累加((位*位)+64位&#x3D;64位)</td>
</tr>
<tr>
<td>SMLAWy</td>
<td>号乘累加((位*16位)&gt;&gt;16位)+位&#x3D;位</td>
</tr>
<tr>
<td>SMULL</td>
<td>64位有符号乘累加(位*位)&#x3D;64位</td>
</tr>
<tr>
<td>SMULxy</td>
<td>有符号乘(16位*16位&#x3D;位)</td>
</tr>
<tr>
<td>SMULWy</td>
<td>有符号乘(位*16位&gt;&gt;16位&#x3D;位)</td>
</tr>
<tr>
<td>STC STC2</td>
<td>从协处理器中把一个或多个位值存到内存</td>
</tr>
<tr>
<td>STM</td>
<td>把多个位的寄存器值存放到内存</td>
</tr>
<tr>
<td>SWI</td>
<td>软中断</td>
</tr>
<tr>
<td>SWP</td>
<td>把一个字或者一个字节和一个寄存器值交换</td>
</tr>
<tr>
<td>TEQ</td>
<td>等值测试</td>
</tr>
<tr>
<td>TST</td>
<td>位测试</td>
</tr>
<tr>
<td>UMLAL</td>
<td>64位无符号乘累加((位*位)+64位&#x3D;64位)</td>
</tr>
<tr>
<td>UMULL</td>
<td>64位无符号乘累加(位*位)&#x3D;64位</td>
</tr>
<tr>
<td>B.LE</td>
<td>标号：小于等于（if判断）</td>
</tr>
<tr>
<td>B.LT</td>
<td>标号：小于等于（do while）</td>
</tr>
<tr>
<td>B.GT</td>
<td>标号：小于等于（while do）</td>
</tr>
<tr>
<td>B.GE</td>
<td>标号：大于等于（for）</td>
</tr>
<tr>
<td>B.EQ</td>
<td>标号：比较结果是等于，执行标号，否则不跳转</td>
</tr>
<tr>
<td>B.HI</td>
<td>标号：比较结果是无符号大于，执行标号，否则不跳转</td>
</tr>
</tbody></table>
<h2 id="1-6-gdb调试命令表"><a href="#1-6-gdb调试命令表" class="headerlink" title="1.6. gdb调试命令表"></a>1.6. gdb调试命令表</h2><h3 id="1-6-1-初始化"><a href="#1-6-1-初始化" class="headerlink" title="1.6.1. 初始化"></a>1.6.1. 初始化</h3><p>为了使 gdb 正常工作, 必须使你的程序在编译时包含调试信息，编译时尽量要加上-g参数, 关闭O2优化</p>
<h3 id="1-6-2-暂停程序"><a href="#1-6-2-暂停程序" class="headerlink" title="1.6.2. 暂停程序"></a>1.6.2. 暂停程序</h3><h4 id="1-6-2-1-设置断点"><a href="#1-6-2-1-设置断点" class="headerlink" title="1.6.2.1. 设置断点"></a>1.6.2.1. 设置断点</h4><p>break命令（可以简写为b）可以用来在调试的程序中设置断点，该命令有如下四种形式： </p>
<ul>
<li><p>break line-number 使程序恰好在执行给定行之前停止。</p>
</li>
<li><p>break function-name 使程序恰好在进入指定的函数之前停止。</p>
</li>
<li><p>break line-or-function if condition 如果condition（条件）是真，程序到达指定行或函数时停止。</p>
<p>要想设置一个条件断点，可以利用break if命令，如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break line-or-function if expr</span><br><span class="line">例：break 46 if testsize==100</span><br></pre></td></tr></table></figure>
</li>
<li><p>break routine-name 在指定例程的入口处设置断点</p>
</li>
<li><p>break *address 在程序运行的内存地址处停住。</p>
</li>
</ul>
<p>如果该程序是由很多原文件构成的，你可以在各个原文件中设置断点，而不是在当前的原文件中设置断点，其方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break filename:line-number</span><br><span class="line">break filename:function-name</span><br></pre></td></tr></table></figure>

<p>从断点继续运行：countinue 命令 <code>c</code></p>
<h4 id="1-6-2-2-线程中断"><a href="#1-6-2-2-线程中断" class="headerlink" title="1.6.2.2. 线程中断"></a>1.6.2.2. 线程中断</h4><p>break [linespec] thread [threadno] [if …]<br>       linespec 断点设置所在的源代码的行号。如: test.c:12表示文件为test.c中的第12行设置一个断点。<br>       threadno 线程的ID。是GDB分配的，通过输入<code>info threads</code>来查看正在运行中程序的线程信息。<br>       if …  设置中断条件。</p>
<h4 id="1-6-2-3-断点管理"><a href="#1-6-2-3-断点管理" class="headerlink" title="1.6.2.3. 断点管理"></a>1.6.2.3. 断点管理</h4><p>显示所有断点信息: <code>i b</code></p>
<ol>
<li><p>删除指定的某个断点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete breakpoint 1</span><br></pre></td></tr></table></figure>

<p>该命令将会删除编号为1的断点，如果不带编号参数，将<code>删除所有的断点</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete breakpoint</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止使用某个断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable breakpoint 1</span><br></pre></td></tr></table></figure>

<p>该命令将禁止断点 1,同时断点信息的 (Enb)域将变为 n</p>
</li>
<li><p>允许使用某个断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable breakpoint 1</span><br></pre></td></tr></table></figure>

<p>该命令将允许断点 1,同时断点信息的 (Enb)域将变为 y</p>
</li>
<li><p>清除原文件中某一代码行上的所有断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean number</span><br></pre></td></tr></table></figure>

<p>注：number 为原文件的某个代码行的行号</p>
</li>
</ol>
<h4 id="1-6-2-4-单步调试"><a href="#1-6-2-4-单步调试" class="headerlink" title="1.6.2.4. 单步调试"></a>1.6.2.4. 单步调试</h4><ul>
<li>step   进入的单步执行如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令<code>finish</code></li>
<li>next  不进入的单步执行</li>
<li><em><code>ni</code> <code>si</code></em> 汇编单步执行(不进入 进入)</li>
</ul>
<h4 id="1-6-2-5-函数调用"><a href="#1-6-2-5-函数调用" class="headerlink" title="1.6.2.5. 函数调用"></a>1.6.2.5. 函数调用</h4><ul>
<li><p>call name 调用和执行一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call <span class="title function_">gen_and_sork</span><span class="params">( <span class="number">1234</span>,<span class="number">1</span>,<span class="number">0</span> )</span></span><br><span class="line"><span class="params">(gdb)</span> call <span class="title function_">printf</span><span class="params">(“abcd”)</span>$1=<span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>finish 结束执行当前函数，显示其返回值（如果有的话）</p>
</li>
</ul>
<h4 id="1-6-2-6-添加观察-watcher-设置观察点"><a href="#1-6-2-6-添加观察-watcher-设置观察点" class="headerlink" title="1.6.2.6. 添加观察 watcher&#x2F; 设置观察点"></a>1.6.2.6. 添加观察 watcher&#x2F; 设置观察点</h4><p>设置观察点：</p>
<ul>
<li>watch + [变量][表达式] 当变量或表达式值改变时即停住程序。</li>
<li>rwatch + [变量][表达式] 当变量或表达式被<code>读</code>时，停住程序。</li>
<li>awatch + [变量][表达式] 当变量或表达式<code>被读或被写</code>时，停住程序。</li>
</ul>
<h4 id="1-6-2-7-设置捕捉点"><a href="#1-6-2-7-设置捕捉点" class="headerlink" title="1.6.2.7. 设置捕捉点"></a>1.6.2.7. 设置捕捉点</h4><p>catch + event 当event发生时，停住程序。event可以是下面的内容：</p>
<ul>
<li>throw 一个C++抛出的异常。（throw为关键字）</li>
<li>catch 一个C++捕捉到的异常。（catch为关键字）</li>
<li>exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li>
<li>fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li>
<li>vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li>
<li>load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li>
<li>unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li>
</ul>
<h4 id="1-6-2-8-捕捉信号"><a href="#1-6-2-8-捕捉信号" class="headerlink" title="1.6.2.8. 捕捉信号"></a>1.6.2.8. 捕捉信号</h4><p><code>handle + [argu] + signals</code></p>
<ul>
<li><p>signals：是Linux&#x2F;Unix定义的信号</p>
<ul>
<li>SIGINT表示中断字符信号，也就是Ctrl+C的信号，</li>
<li>SIGBUS表示硬件故障的信号</li>
<li>SIGCHLD表示子进程状态改变信号</li>
<li>SIGKILL表示终止程序运行的信号，等等。</li>
</ul>
</li>
</ul>
<ul>
<li><p>argu：</p>
<ul>
<li>nostop  当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号</li>
<li>stop   当被调试的程序收到信号时，GDB会停住你的程序</li>
<li>print  当被调试的程序收到信号时，GDB会显示出一条信息</li>
<li>noprint 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息</li>
<li>pass or noignore  当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。</li>
<li>nopass or ignore   当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</li>
</ul>
</li>
</ul>
<h3 id="1-6-3-查看信息"><a href="#1-6-3-查看信息" class="headerlink" title="1.6.3. 查看信息"></a>1.6.3. 查看信息</h3><h4 id="1-6-3-1-查看值-查看数据"><a href="#1-6-3-1-查看值-查看数据" class="headerlink" title="1.6.3.1. 查看值&#x2F;查看数据"></a>1.6.3.1. 查看值&#x2F;查看数据</h4><p>print variable    查看变量<br>       print *array@len   查看数组（array是数组指针，len是需要数据长度）<br>       可以通过添加参数来设置输出格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/x 按十六进制格式显示变量。</span><br><span class="line">/d 按十进制格式显示变量。</span><br><span class="line">/u 按十六进制格式显示无符号整型。</span><br><span class="line">/o 按八进制格式显示变量。</span><br><span class="line">/t 按二进制格式显示变量。</span><br><span class="line">/a 按十六进制格式显示变量。</span><br><span class="line">/c 按字符格式显示变量。</span><br><span class="line">/s 按字符串格式显示变量 遇到\0 截止</span><br><span class="line">/f 按浮点数格式显示变量。</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-6-查看内存地址"><a href="#1-6-2-6-查看内存地址" class="headerlink" title="1.6.2.6. 查看内存地址"></a>1.6.2.6. 查看内存地址</h4><p>examine &#x2F;n f u + 内存地址（指针变量）<br>       n 表示显示内存长度<br>       f 表示输出格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/x 按十六进制格式显示变量。</span><br><span class="line">/d 按十进制格式显示变量。</span><br><span class="line">/u 按十六进制格式显示无符号整型。</span><br><span class="line">/o 按八进制格式显示变量。</span><br><span class="line">/t 按二进制格式显示变量。</span><br><span class="line">/a 按十六进制格式显示变量。</span><br><span class="line">/c 按字符格式显示变量。</span><br><span class="line">/s 按字符串格式显示变量 遇到\0 截止</span><br><span class="line">/f 按浮点数格式显示变量。</span><br></pre></td></tr></table></figure>

<p>​       u 表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节）<br>​       如：<br>​            x &#x2F;10cw pFilePath （pFilePath为一个字符串指针，指针占4字节）</p>
<blockquote>
<p>x 为examine命令的简写</p>
</blockquote>
<h4 id="1-6-2-7-查看栈信息-堆栈"><a href="#1-6-2-7-查看栈信息-堆栈" class="headerlink" title="1.6.2.7. 查看栈信息 堆栈"></a>1.6.2.7. 查看栈信息 堆栈</h4><p>backtrace -n n</p>
<p> n 表示只打印栈顶上n层的栈信息</p>
<p>-n 表示只打印栈底上n层的栈信息。</p>
<p>不加参数，表示打印所有栈信息。</p>
<h4 id="1-6-2-8-变量的检查和赋值"><a href="#1-6-2-8-变量的检查和赋值" class="headerlink" title="1.6.2.8. 变量的检查和赋值"></a>1.6.2.8. 变量的检查和赋值</h4><ul>
<li>whatis:识别数组或变量的类型</li>
<li>ptype:比whatis的功能更强，他可以提供一个结构的定义</li>
<li>set variable:将值赋予变量</li>
<li>print 除了显示一个变量的值外，还可以用来赋值</li>
</ul>
<h4 id="1-6-2-9-info"><a href="#1-6-2-9-info" class="headerlink" title="1.6.2.9. info"></a>1.6.2.9. info</h4><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>info address</td>
<td>Describe where symbol SYM is stored</td>
</tr>
<tr>
<td>info all-registers</td>
<td>List of all registers and their contents</td>
</tr>
<tr>
<td>info args</td>
<td>Argument variables of current stack frame</td>
</tr>
<tr>
<td>info auxv</td>
<td>Display the inferior’s auxiliary vector</td>
</tr>
<tr>
<td>info breakpoints</td>
<td>Status of user-settable breakpoints</td>
</tr>
<tr>
<td>info catch</td>
<td>Exceptions that can be caught in the current stack frame</td>
</tr>
<tr>
<td>info checkpoints</td>
<td>IDs of currently known forks&#x2F;checkpoints</td>
</tr>
<tr>
<td>info classes</td>
<td>All Objective-C classes</td>
</tr>
<tr>
<td>info common</td>
<td>Print out the values contained in a Fortran COMMON block</td>
</tr>
<tr>
<td>info copying</td>
<td>Conditions for redistributing copies of GDB</td>
</tr>
<tr>
<td>info dcache</td>
<td>Print information on the dcache performance</td>
</tr>
<tr>
<td>info display</td>
<td>Expressions to display when program stops</td>
</tr>
<tr>
<td>info extensions</td>
<td>All filename extensions associated with a source language</td>
</tr>
<tr>
<td>info files</td>
<td>Names of targets and files being debugged</td>
</tr>
<tr>
<td>info float</td>
<td>Print the status of the floating point unit</td>
</tr>
<tr>
<td>info forks</td>
<td>IDs of currently known forks&#x2F;checkpoints</td>
</tr>
<tr>
<td>info frame</td>
<td>All about selected stack frame</td>
</tr>
<tr>
<td>info functions</td>
<td>All function names</td>
</tr>
<tr>
<td>info handle</td>
<td>What debugger does when program gets various signals</td>
</tr>
<tr>
<td><code>info line</code></td>
<td>Core addresses of the code for a source line</td>
</tr>
<tr>
<td>info linkmap</td>
<td>Display the inferior’s linkmap</td>
</tr>
<tr>
<td><code>info locals</code></td>
<td>Local variables of current stack frame</td>
</tr>
<tr>
<td>info macro</td>
<td>Show the definition of MACRO</td>
</tr>
<tr>
<td>info mem</td>
<td>Memory region attributes</td>
</tr>
<tr>
<td>info proc</td>
<td>Show &#x2F;proc process information about any running process</td>
</tr>
<tr>
<td>info program</td>
<td>Execution status of the program</td>
</tr>
<tr>
<td><code>info registers</code></td>
<td>List of integer registers and their contents</td>
</tr>
<tr>
<td>info scope</td>
<td>List the variables local to a scope</td>
</tr>
<tr>
<td>info selectors</td>
<td>All Objective-C selectors</td>
</tr>
<tr>
<td>info set</td>
<td>Show all GDB settings</td>
</tr>
<tr>
<td><code>info sharedlibrary</code></td>
<td>Status of loaded shared object libraries</td>
</tr>
<tr>
<td>info signals</td>
<td>What debugger does when program gets various signals</td>
</tr>
<tr>
<td>info source</td>
<td>Information about the current source file</td>
</tr>
<tr>
<td>info sources</td>
<td>Source files in the program</td>
</tr>
<tr>
<td><code>info stack</code></td>
<td>Backtrace of the stack</td>
</tr>
<tr>
<td>info symbol</td>
<td>Describe what symbol is at location ADDR</td>
</tr>
<tr>
<td>info target</td>
<td>Names of targets and files being debugged</td>
</tr>
<tr>
<td>info terminal</td>
<td>Print inferior’s saved terminal status</td>
</tr>
<tr>
<td><code>info threads</code></td>
<td>IDs of currently known threads</td>
</tr>
<tr>
<td>info tracepoints</td>
<td>Status of tracepoints</td>
</tr>
<tr>
<td>info types</td>
<td>All type names</td>
</tr>
<tr>
<td>info variables</td>
<td>All global and static variable names</td>
</tr>
<tr>
<td>info vector</td>
<td>Print the status of the vector unit</td>
</tr>
<tr>
<td>info warranty</td>
<td>Various kinds of warranty you do not have</td>
</tr>
<tr>
<td><code>info watchpoints</code></td>
<td>Synonym for <code>info breakpoints</code></td>
</tr>
<tr>
<td>info win</td>
<td>List of all displayed windows</td>
</tr>
</tbody></table>
<h2 id="1-7-基本gdb命令"><a href="#1-7-基本gdb命令" class="headerlink" title="1.7. 基本gdb命令"></a>1.7. 基本gdb命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td></td>
<td>装入想要调试的可执行文件.</td>
</tr>
<tr>
<td>kill</td>
<td>k</td>
<td>终止正在调试的程序.</td>
</tr>
<tr>
<td>list</td>
<td>l</td>
<td>列出产生执行文件的源代码的一部分.</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行一行源代码但不进入函数内部.</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>执行一行源代码而且进入函数内部.</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续执行程序，直至下一中断或者程序结束。</td>
</tr>
<tr>
<td>run</td>
<td>r</td>
<td>执行当前被调试的程序.</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>终止 gdb.</td>
</tr>
<tr>
<td>watch</td>
<td></td>
<td>使你能监视一个变量的值而不管它何时被改变.</td>
</tr>
<tr>
<td>catch</td>
<td></td>
<td>设置捕捉点.</td>
</tr>
<tr>
<td>thread</td>
<td>t</td>
<td>查看当前运行程序的线程信息.</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>在代码里设置断点, 这将使程序执行到这里时被挂起.</td>
</tr>
<tr>
<td>make</td>
<td></td>
<td>使你能不退出 gdb 就可以重新产生可执行文件.</td>
</tr>
<tr>
<td>shell</td>
<td></td>
<td>使你能不离开 gdb 就执行 UNIX shell 命令. <code>CTRL+D</code>退回到gdb</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印数据内容。</td>
</tr>
<tr>
<td>examine</td>
<td>x</td>
<td>打印内存内容。</td>
</tr>
<tr>
<td>backtrace</td>
<td>bt</td>
<td>查看函数调用栈的所有信息。</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/arm/" rel="tag"># arm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/18/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc5%20%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0/" rel="prev" title="jemalloc5 脚本实现.md">
      <i class="fa fa-chevron-left"></i> jemalloc5 脚本实现.md
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/" rel="next" title="jemalloc调研">
      jemalloc调研 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-arm64-%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">1. arm64 寄存器和指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-arm64-%E7%BA%A6%E5%AE%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1. arm64 约定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%99%9A%E5%AD%98%E5%9C%B0%E5%9D%80%E4%B8%8Eelf-%E6%AE%B5%E5%9C%B0%E8%99%9A%E5%9D%80"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 虚存地址与elf 段地虚址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%B0%8F%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%A4%A7%E7%AB%AF%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 小端序和大端序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. 寻址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E6%9F%A5%E7%9C%8Belf-%E5%90%84%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%8A%E7%A1%AE%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AE%B5%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. 查看elf 各段的地址及确认初始化段区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-1-hexdump%E6%89%93%E5%8D%B0%E5%B8%B8%E9%87%8F%E7%AD%89%E6%AE%B5%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.4.1.1. hexdump打印常量等段的内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-arm64-%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. arm64 指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-stp-ldp-str-ldr-stur-ldur%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. stp ldp str ldr stur ldur指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-ldrsw"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. ldrsw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-adrp"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. adrp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4-%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8%E9%99%84%E5%BD%95"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4. 指令列表附录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-gdb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. gdb调试命令表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E6%9A%82%E5%81%9C%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 暂停程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-1-%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1.6.2.1. 设置断点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">1.6.2.2. 线程中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-3-%E6%96%AD%E7%82%B9%E7%AE%A1%E7%90%86"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">1.6.2.3. 断点管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-4-%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">1.6.2.4. 单步调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">1.6.2.5. 函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-6-%E6%B7%BB%E5%8A%A0%E8%A7%82%E5%AF%9F-watcher-%E8%AE%BE%E7%BD%AE%E8%A7%82%E5%AF%9F%E7%82%B9"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">1.6.2.6. 添加观察 watcher&#x2F; 设置观察点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-7-%E8%AE%BE%E7%BD%AE%E6%8D%95%E6%8D%89%E7%82%B9"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">1.6.2.7. 设置捕捉点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-8-%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.6.2.8.</span> <span class="nav-text">1.6.2.8. 捕捉信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. 查看信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-1-%E6%9F%A5%E7%9C%8B%E5%80%BC-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">1.6.3.1. 查看值&#x2F;查看数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-6-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">1.6.2.6. 查看内存地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-7-%E6%9F%A5%E7%9C%8B%E6%A0%88%E4%BF%A1%E6%81%AF-%E5%A0%86%E6%A0%88"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">1.6.2.7. 查看栈信息 堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-8-%E5%8F%98%E9%87%8F%E7%9A%84%E6%A3%80%E6%9F%A5%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">1.6.2.8. 变量的检查和赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-9-info"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">1.6.2.9. info</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E5%9F%BA%E6%9C%ACgdb%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. 基本gdb命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">131</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VrGRp2q7WwXjxsCNmlDIZYbC-gzGzoHsz',
      appKey     : 'JgMXmmB7yKQf2zm80TaBp3JT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

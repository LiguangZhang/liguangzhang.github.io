<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="以SIGSEGV为例详解信号处理(与栈回溯)信号是内核提供的向用户态进程发送信息的机制, 常见的有使用SIGUSR1唤醒用户进程执行子程序或发生段错误时使用SIGSEGV保存用户错误现场. 本文以SIGSEGV为例, 详细分析信号使用方法, 内核信号的发送与接收机制. 信号处理例程以下是一个SiGEGV处理例程, 主程序注册一个信号量并创建一个线程, 线程中故意访问空指针, 引发段错误. 在信号回">
<meta property="og:type" content="article">
<meta property="og:title" content="android sigev 信号追踪">
<meta property="og:url" content="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/sigev%20%E8%BF%BD%E8%B8%AA/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="以SIGSEGV为例详解信号处理(与栈回溯)信号是内核提供的向用户态进程发送信息的机制, 常见的有使用SIGUSR1唤醒用户进程执行子程序或发生段错误时使用SIGSEGV保存用户错误现场. 本文以SIGSEGV为例, 详细分析信号使用方法, 内核信号的发送与接收机制. 信号处理例程以下是一个SiGEGV处理例程, 主程序注册一个信号量并创建一个线程, 线程中故意访问空指针, 引发段错误. 在信号回">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-19T10:15:54.000Z">
<meta property="article:modified_time" content="2024-04-16T07:57:46.834Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="signal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/sigev%20%E8%BF%BD%E8%B8%AA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>android sigev 信号追踪 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/sigev%20%E8%BF%BD%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          android sigev 信号追踪
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 18:15:54" itemprop="dateCreated datePublished" datetime="2020-07-19T18:15:54+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:57:46" itemprop="dateModified" datetime="2024-04-16T15:57:46+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%A8%B3%E5%AE%9A%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">稳定性</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="以SIGSEGV为例详解信号处理-与栈回溯"><a href="#以SIGSEGV为例详解信号处理-与栈回溯" class="headerlink" title="以SIGSEGV为例详解信号处理(与栈回溯)"></a>以SIGSEGV为例详解信号处理(与栈回溯)</h1><p>信号是内核提供的向用户态进程发送信息的机制, 常见的有使用SIGUSR1唤醒用户进程执行子程序或发生段错误时使用<code>SIGSEGV</code>保存用户错误现场. 本文以SIGSEGV为例, 详细分析信号使用方法, 内核信号的发送与接收机制.</p>
<h2 id="信号处理例程"><a href="#信号处理例程" class="headerlink" title="信号处理例程"></a>信号处理例程</h2><p>以下是一个<code>SiGEGV</code>处理例程, 主程序注册一个信号量并创建一个线程, 线程中故意访问空指针, 引发段错误. 在信号回调中会回溯堆栈, 保存出错的地址.<br>回溯堆栈的原理在分析完整个信号处理流程后再分析, 首先我们先来分析如何使用信号.</p>
<p> <code>sigaction</code>()用于向内核注册一个信号(参数1), 使用参数2(如果非空)作为注册信号的回调, 内核会将之前的信号回调返回在参数3中(如果非空). 如果父进程或程序之前阻塞了该信号则需先调用<code>sigprocmask</code>()取消阻塞.<br>在回调处理结束时需手动退出进程(<code>exit</code>()), 否则<strong>内核会不断触发该信号(重新执行异常指令再次引起崩溃)</strong>, glibc对SIGSEGV有默认的回调, 所以默认情况下也会正常退出.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POPCNT(data)                            do &#123;        \</span></span><br><span class="line"><span class="meta">        data = (data &amp; 0x55555555) + ((data &gt;&gt; 1) &amp; 0x55555555);    \</span></span><br><span class="line"><span class="meta">        data = (data &amp; 0x33333333) + ((data &gt;&gt; 2) &amp; 0x33333333);    \</span></span><br><span class="line"><span class="meta">        data = (data &amp; 0x0F0F0F0F) + ((data &gt;&gt; 4) &amp; 0x0F0F0F0F);    \</span></span><br><span class="line"><span class="meta">        data = (data &amp; 0x00FF00FF) + ((data &gt;&gt; 8) &amp; 0x00FF00FF);    \</span></span><br><span class="line"><span class="meta">        data = (data &amp; 0x0000FFFF) + ((data &gt;&gt; 16) &amp; 0x0000FFFF);    \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * we only calculate sp decrease which is static confirm in compile time</span></span><br><span class="line"><span class="comment"> * that is sub immediate &amp; push instruction(and return when we find push)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace_stack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> **pppc, <span class="type">unsigned</span> <span class="type">int</span> **ppsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *ppc_last = *pppc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *psp = *ppsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> decrease = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        INS_SUB_IMM = <span class="number">0</span>,</span><br><span class="line">        INS_STM1,</span><br><span class="line">        INS_STR_LR,</span><br><span class="line">        INS_STR_FP,</span><br><span class="line">        INS_BUTT</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//see ARM reference manual for more detail</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ins_map</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ins;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ins_map</span> map[INS_BUTT] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">0xFFEFF000</span>, <span class="number">0xE24DD000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFFFF4000</span>, <span class="number">0xE92D4000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFFFFFFFF</span>, <span class="number">0xE52DE004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFFFFFFFF</span>, <span class="number">0xE52DB004</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">again:</span><br><span class="line">    ppc_last--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INS_BUTT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[i].ins == (*ppc_last &amp;map[i].mask))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INS_SUB_IMM:</span><br><span class="line">        <span class="comment">//sub sp, sp, imm</span></span><br><span class="line">        decrease = (*ppc_last &amp; <span class="number">0xFF</span>) &lt;&lt; ((<span class="number">32</span> - <span class="number">2</span> * (*ppc_last &amp; <span class="number">0xF00</span>)) % <span class="number">32</span>);</span><br><span class="line">        psp += decrease / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INS_STM1:</span><br><span class="line">        <span class="comment">//push lr, ...</span></span><br><span class="line">        decrease = *ppc_last &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="built_in">POPCNT</span>(decrease);</span><br><span class="line">        psp += decrease;</span><br><span class="line">        *pppc = *(psp - <span class="number">1</span>);</span><br><span class="line">        *ppsp = psp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> INS_STR_LR:</span><br><span class="line">        <span class="comment">//push lr</span></span><br><span class="line">        psp += <span class="number">1</span>;</span><br><span class="line">        *pppc = *(psp - <span class="number">1</span>);</span><br><span class="line">        *ppsp = psp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> INS_STR_FP:</span><br><span class="line">        <span class="comment">//push fp</span></span><br><span class="line">        psp += <span class="number">1</span>;</span><br><span class="line">        *ppsp = psp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * process stack when catch a sigsegv:</span></span><br><span class="line"><span class="comment"> * ------------   stack top</span></span><br><span class="line"><span class="comment"> * | ......</span></span><br><span class="line"><span class="comment"> * | fault addr   sp position when memory fault happen</span></span><br><span class="line"><span class="comment"> * | sigframe     kernel use to resotre context DO NOT MODIFY(same to data)</span></span><br><span class="line"><span class="comment"> * | siginfo      glibc push this struct into stack(same to siginfo)</span></span><br><span class="line"><span class="comment"> * | current sp   sp position when enter signal handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sighandle</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *siginfo, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//data point to sigframe which is not seen to user</span></span><br><span class="line">    <span class="comment">//search struct ucontext in kernel for more detail</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *psp = ((<span class="type">unsigned</span> <span class="type">int</span> *)data) + <span class="number">21</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *plr = ((<span class="type">unsigned</span> <span class="type">int</span> *)data) + <span class="number">22</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *ppc = ((<span class="type">unsigned</span> <span class="type">int</span> *)data) + <span class="number">23</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pc_val[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sp_val[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> **ppstr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get signal %u addr %x\n&quot;</span>, siginfo-&gt;si_signo, siginfo-&gt;si_addr);</span><br><span class="line">    pc_val[<span class="number">0</span>] = *ppc;</span><br><span class="line">    sp_val[<span class="number">0</span>] = *psp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pc_val[i] = pc_val[i - <span class="number">1</span>];</span><br><span class="line">        sp_val[i] = sp_val[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">backtrace_stack</span>((<span class="type">unsigned</span> <span class="type">int</span> **)(&amp;pc_val[i]), (<span class="type">unsigned</span> <span class="type">int</span> **)(&amp;sp_val[i]));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * for subroutine use push &#123;fp&#125; instruction, we can&#x27;t get it&#x27;s caller pc</span></span><br><span class="line"><span class="comment">         * so we use last lr as pc and hope program won&#x27;t push &#123;fp&#125; twice</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span> (pc_val[i] == pc_val[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            pc_val[i] = *plr;</span><br><span class="line">        &#125;</span><br><span class="line">        pc_val[i] -= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ppstr = <span class="built_in">backtrace_symbols</span>((<span class="type">void</span> **)pc_val, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: pc[0x%08x] sp[0x%08x] %s\n&quot;</span>, i, pc_val[i], sp_val[i], ppstr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fault_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fault_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="built_in">fault_func3</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fault_func1</span><span class="params">(<span class="type">void</span> *pvoid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="built_in">fault_func2</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sigact;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sigact, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">    sigact.sa_sigaction = sighandle;</span><br><span class="line">    sigact.sa_flags = SA_SIGINFO | SA_RESTART;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGSEGV, &amp;sigact, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">getc</span>(stdin);</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, fault_func1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内核信号量数据结构与系统调用"><a href="#内核信号量数据结构与系统调用" class="headerlink" title="内核信号量数据结构与系统调用"></a>内核信号量数据结构与系统调用</h2><p>虽然用户调用的sig*接口都是glibc的接口, 但实际上glibc还是通过系统调用实现的.<br>与信号量相关的数据结构有:<br><code>task_struct</code>(负责保存信号处理句柄, 阻塞与挂起的信号队列)<br><code>sighand_struct</code>(每个信号处理 handler句柄, 保护信号的自旋锁)<br><code>signal_struct</code>(信号量结构, 大部分参数都在该结构中)<br><code>sigpending</code>(挂起队列, 用于索引挂起的信号)<br>作为一种信息传递机制, 信号量代码本身并不复杂, 即使是信号发送接口__send_signal()(分析见下).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">  <span class="comment">//信号处理句柄, 包括每个信号的action, 锁与等待队列</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line">  <span class="comment">//该task阻塞的信号</span></span><br><span class="line">  <span class="type">sigset_t</span> blocked, real_blocked;</span><br><span class="line">  <span class="type">sigset_t</span> saved_sigmask;</span><br><span class="line">  <span class="comment">//该task挂起信号的结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> &#123;</span></span><br><span class="line">  <span class="type">atomic_t</span> count;</span><br><span class="line">  <span class="comment">//保存信号处理句柄的数组</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">action</span>[_<span class="title">NSIG</span>];</span></span><br><span class="line">  <span class="comment">//自旋锁, 不仅保护该结构同时还保护task_struct.signal</span></span><br><span class="line">  <span class="type">spinlock_t</span> siglock;</span><br><span class="line">  <span class="type">wait_queue_head_t</span> signalfd_wqh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* signal_struct自身没有锁</span></span><br><span class="line"><span class="comment"> \* 因为一个共享的signal_struct往往对饮一个共享的sighand_struct</span></span><br><span class="line"><span class="comment"> \* 即使用sighand_struct的锁是signal_struct的超集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> &#123;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//进程的信号挂起队列, 与task_struct.pending区别是所有线程共享</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">shared_pending</span>;</span></span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述挂起信号的结构体</span></span><br><span class="line"><span class="comment">//成员list为进程所有挂起信号的双线链表的头</span></span><br><span class="line"><span class="comment">//成员signal为进程挂起信号量的位图, 挂起的信号对应的位置位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line">  <span class="comment">//sigqueue链表头</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="comment">//当前挂起的信号量位图</span></span><br><span class="line">  <span class="type">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述一个挂起信号的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line">  <span class="comment">//sigqueue链表节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="comment">//该挂起信号的信息</span></span><br><span class="line">  <span class="type">siginfo_t</span> info;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述信号相关信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> si_signo;</span><br><span class="line">  <span class="type">int</span> si_errno;</span><br><span class="line">  <span class="type">int</span> si_code;</span><br><span class="line">  ......</span><br><span class="line">&#125; __ARCH_SI_ATTRIBUTES <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义见kernel/signal.c</span></span><br><span class="line"><span class="comment"> * 获取或修改拦截的信号</span></span><br><span class="line"><span class="comment"> * @how: 为SIG_BLOCK / SIG_UNBLOCK / SIG_SETMASK的一种</span></span><br><span class="line"><span class="comment"> * @nset: 如果非空为增加或移除的信号</span></span><br><span class="line"><span class="comment"> * @oset: 如果非空为之前的信号</span></span><br><span class="line"><span class="comment"> * note: sigprocmask系统调用任务很简单, 用新值修改current-&gt;blocked并将旧值传回用户态</span></span><br><span class="line"><span class="comment"> *       调用set_current_blocked中会先剔除SIGKILL与SIGSTOP, 用户传递这两个值是无效的</span></span><br><span class="line"><span class="comment"> *       之后还会判断task是否已经pending及是否有线程, 如果有还需对每个线程单独处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">SYSCALL_DEFINE3(sigprocmask, <span class="type">int</span>, how, \</span><br><span class="line">    <span class="type">old_sigset_t</span> __user *, nset, \</span><br><span class="line">    <span class="type">old_sigset_t</span> __user *, oset);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义见kernel/signal.c</span></span><br><span class="line"><span class="comment"> * 获取或修改拦截信号的action</span></span><br><span class="line"><span class="comment"> * @sig: 为拦截的信号</span></span><br><span class="line"><span class="comment"> * @act: 如果非空为信号sig的action</span></span><br><span class="line"><span class="comment"> * @oact: 如果非空为返回之前信号sig的action</span></span><br><span class="line"><span class="comment"> * note: 如果传入未定义信号或SIGKILL与SIGSTOP会直接返回EINVAL</span></span><br><span class="line"><span class="comment"> *       如果act非空则将其赋值给进程task_struct.sighand-&gt;action[i]中</span></span><br><span class="line"><span class="comment"> *       然后检测所拦截的信号是否挂起, 如果有挂起则将其从队列中删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">SYSCALL_DEFINE3(sigaction, <span class="type">int</span>, sig, \</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> old_sigaction __user *, act, \</span><br><span class="line">    <span class="keyword">struct</span> old_sigaction __user *, oact);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义见kernel/signal.c</span></span><br><span class="line"><span class="comment"> * 以下两接口为发送信号的接口, 实际调用send_signal</span></span><br><span class="line"><span class="comment"> * send_signal()调用__send_signal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_send_sig_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> siginfo *info, \</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> group)</span>;</span><br><span class="line"><span class="type">int</span> __group_send_sig_info(<span class="type">int</span> sig, \</span><br><span class="line">    <span class="keyword">struct</span> siginfo *info, <span class="keyword">struct</span> task_struct *p);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义见kernel/signal.c</span></span><br><span class="line"><span class="comment"> * 实际发送信号的函数, 本接口未加锁, 需外部保证锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __send_signal(<span class="type">int</span> sig, <span class="keyword">struct</span> siginfo *info, \</span><br><span class="line">    <span class="keyword">struct</span> task_struct *t, <span class="type">int</span> group, <span class="type">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检测是否已锁, 此处使用sighand的锁是因为sighand_struct与signal_struct往往一一对应</span></span><br><span class="line">    assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="comment">//调用prepare_signal判断信号是否需要发送及做其它准备情况</span></span><br><span class="line">    <span class="comment">//主要是处理SIGSTOP/SIGCONT, 对于SIGCONT立即发生, 对于SIGSTOP则不是立刻停止</span></span><br><span class="line">    <span class="comment">//1. 对于即将退出的进程, 除SIGKILL外都不发送信号</span></span><br><span class="line">    <span class="comment">//2. 如果是停止信号, 需先将进程挂起的SIGCONT移出挂起队列</span></span><br><span class="line">    <span class="comment">//3. 如果是SIGCONT信号, 需先将所有停止信号都移出挂起队列同时清除线程标记位</span></span><br><span class="line">    <span class="comment">//4. 判断信号是否需要忽略, 阻塞的信号不忽略, 忽略处理句柄为空与内核认为需要忽略信号</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_signal(sig, t, from_ancestor_ns || (info == SEND_SIG_FORCED)))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    pending = group   &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">    <span class="comment">//对于已挂起信号不再处理, 确保每种信号在队列中仅存在一个</span></span><br><span class="line">    <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    <span class="comment">//对于内核内部信号如SIGSTOP或SIGKILL走捷径</span></span><br><span class="line">    <span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line">        <span class="keyword">goto</span> out_set;</span><br><span class="line">    <span class="comment">//实时信号必须通过sigqueue或其它实时机制入队列</span></span><br><span class="line">    <span class="comment">//但考虑到内存不足时kill不允许失败所以保证至少一个信号可以传递</span></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        override_rlimit = <span class="number">0</span>;</span><br><span class="line">    q = __sigqueue_alloc(sig, t, \</span><br><span class="line">        GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE, override_rlimit);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">switch</span> ((<span class="type">unsigned</span> <span class="type">long</span>) info) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_USER;</span><br><span class="line">            q-&gt;info.si_pid = task_tgid_nr_ns(current, task_active_pid_ns(t));</span><br><span class="line">            q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_PRIV:</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">            q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">            <span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">                q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        userns_fixup_signal_uid(&amp;q-&gt;info, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">            <span class="comment">//信号队列溢出, 放弃</span></span><br><span class="line">            result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">            <span class="keyword">goto</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//继续传递信号, 但info信息丢失</span></span><br><span class="line">            result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out_set:</span><br><span class="line">    signalfd_notify(t, sig);</span><br><span class="line">    <span class="comment">//挂起队列位图对应位置位</span></span><br><span class="line">    sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">    complete_signal(sig, t, group);</span><br><span class="line">ret:</span><br><span class="line">    <span class="comment">//跟踪信号生成, 该接口直接搜索不存在</span></span><br><span class="line">    <span class="comment">//在include/trace/events/signal.h中宏定义</span></span><br><span class="line">    <span class="comment">//其中TRACE_EVENT定义见include/linux/tracepoint.h</span></span><br><span class="line">    trace_signal_generate(sig, info, t, group, result);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">complete_signal</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> group)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//寻找可唤醒的线程</span></span><br><span class="line">    <span class="comment">//如果信号阻塞, 进程处于退出状态, task处于停止或跟踪状态无需信号</span></span><br><span class="line">    <span class="comment">//如果信号为SIGKILL, task必须接收该信号</span></span><br><span class="line">    <span class="comment">//如果task运行在当前cpu上或task无信号挂起也接收信号</span></span><br><span class="line">    <span class="keyword">if</span> (wants_signal(sig, p))</span><br><span class="line">        t = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!group || thread_group_empty(p))</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * There is just one thread and it does not need to be woken.</span></span><br><span class="line"><span class="comment">        * It will dequeue unblocked signals before it runs again.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//仅一个线程无需唤醒, 自动在运行前去除未阻塞信号</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        t = signal-&gt;curr_target;</span><br><span class="line">        <span class="keyword">while</span> (!wants_signal(sig, t)) &#123;</span><br><span class="line">            t = next_thread(t);</span><br><span class="line">            <span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line">                <span class="comment">//遍历所有线程, 没有线程需要唤醒</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        signal-&gt;curr_target = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找可杀死的线程</span></span><br><span class="line">    <span class="keyword">if</span> (sig_fatal(p, sig) &amp;&amp;</span><br><span class="line">        !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;</span><br><span class="line">        !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;</span><br><span class="line">        (sig == SIGKILL || !t-&gt;ptrace)) &#123;</span><br><span class="line">            <span class="comment">//唤醒整个线程组</span></span><br><span class="line">            <span class="keyword">if</span> (!sig_kernel_coredump(sig)) &#123;</span><br><span class="line">            signal-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">            signal-&gt;group_exit_code = sig;</span><br><span class="line">            signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">            t = p;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);</span><br><span class="line">                sigaddset(&amp;t-&gt;pending.signal, SIGKILL);</span><br><span class="line">                signal_wake_up(t, <span class="number">1</span>);</span><br><span class="line">            &#125; while_each_thread(p, t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒线程去队列中获取信号</span></span><br><span class="line">    signal_wake_up(t, sig == SIGKILL);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="信号处理流程"><a href="#信号处理流程" class="headerlink" title="信号处理流程"></a>信号处理流程</h2><p>信号处理涉及内核最底层代码, 需了解芯片架构在内各类知识, 相对晦涩难懂.<br>一般对现代芯片而言当进程访问一个非法地址后<code>MMU</code>会修改寄存器引起内核进入异常, 在异常处理时内核会分辨非法地址产生的原因(是真的非法地址还是没有映射页表)并作出不同处理. 对于处理失败的情况内核在异常处理结束时会向引起异常的task发送<code>SIGSEGV</code>, 在异常结束后执行调度时会首先判断该task是否有挂起信号, 如果存在则执行信号处理. 信号处理的复杂之处主要在于内核需要调用用户态程序并在程序结束后恢复内核现场. 接下来我们以Hi3536(ARMv7)平台具体分析信号处理流程(使用3.10内核).</p>
<p>arm一共有7种异常处理模式, reset, und, swi, pabt, dabt, irq, fiq(reference manual A2-13).<br>其中与内存访问相关的有两种prefetch abort与data abort, 前者为取指令异常, <code>后者为数据异常</code>.<br>异常向量表定义在arch&#x2F;arm&#x2F;kernel&#x2F;entry-armv.S, __stubs_start到__stubs_end即整个异常向量表.<br>在内核初始化时调用early_trap_init拷贝向量表(低地址空间是用户态, 所以需搬移到0xFFFF0000).<br>向量表中每类异常的起始地址都是vector_stub宏, 后面跟着不同异常向量处理函数.<br>以dabt为例, 先看下该宏:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.macro vector_stub, name, mode, correction=0</span><br><span class="line">    .align 5</span><br><span class="line">    vector_\name:</span><br><span class="line">    .if \correction</span><br><span class="line">    sub lr, lr, #\correction</span><br><span class="line">    .endif</span><br><span class="line">    @</span><br><span class="line">    @ Save r0, lr_&lt;exception&gt; (parent PC) and spsr_&lt;exception&gt;</span><br><span class="line">    @ (parent CPSR)</span><br><span class="line">    @</span><br><span class="line">    stmia sp, &#123;r0, lr&#125;  @ save r0, lr</span><br><span class="line">    mrs lr, spsr</span><br><span class="line">    str lr, [sp, #8]    @ save spsr</span><br><span class="line">    @</span><br><span class="line">    @ Prepare for SVC32 mode.  IRQs remain disabled.</span><br><span class="line">    @</span><br><span class="line">    mrs r0, cpsr</span><br><span class="line">    eor r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)</span><br><span class="line">    msr spsr_cxsf, r0</span><br><span class="line">    @</span><br><span class="line">    @ the branch table must immediately follow this code</span><br><span class="line">    @</span><br><span class="line">    and lr, lr, #0x0f</span><br><span class="line">    THUMB(adr r0, 1f)</span><br><span class="line">    THUMB(ldr lr, [r0, lr, lsl #2])</span><br><span class="line">    mov r0, sp</span><br><span class="line">    ARM( ldr lr, [pc, lr, lsl #2])</span><br><span class="line">    movs pc, lr         @ branch to handler in SVC mode</span><br><span class="line">ENDPROC(vector_\name)</span><br></pre></td></tr></table></figure>

<p>进入异常后第一件事是保存异常模式下寄存器(如果发生嵌套异常又不保存寄存器则无法恢复异常环境).<br>即保存 <code>lr_exception</code> 与 <code>spsr_exception</code>, 由于使用 r0传递 sp 还需保存 r0, 将 cpsr 设置为 svc 模式.<br>保存现场后第二件事是跳转到对应的异常处理函数, 由于未定义THUMB2_KERNEL, 内核全部使用ARM指令.<br>通过读cpsr寄存器低4位得知(通过mrs读取到lr中再位与0xF)进入异常前的运行模式.<br>异常向量表是连续的4字节数组, 紧跟在该代码后, 通过pc + mode * 4得到异常向量地址.<br>仍以dabt为例, 用户访问空指针引起abort异常, 用户模式mode bits为0, 此时即ldr lr, [pc].<br>由于arm架构三级流水线, pc领先实际执行两个指令, 即lr为__dabt_usr, 最后跳转到__dabt_usr执行.<br>如果内核访问空指针引起abort异常, 内核模式mode bits为3, 即跳转到__dabt_svc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector_stub dabt, ABT_MODE, 8 </span><br><span class="line">.long __dabt_usr       @  0  (USR_26 / USR_32) </span><br><span class="line">.long __dabt_invalid   @  1  (FIQ_26 / FIQ_32) </span><br><span class="line">.long __dabt_invalid   @  2  (IRQ_26 / IRQ_32) </span><br><span class="line">.long __dabt_svc       @  3  (SVC_26 / SVC_32) </span><br></pre></td></tr></table></figure>

<p>接下来进入具体异常处理函数, 我们以__dabt_usr为例具体分析.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__dabt_usr:</span><br><span class="line">    usr_entry</span><br><span class="line">    kuser_cmpxchg_check</span><br><span class="line">    mov r2, sp</span><br><span class="line">    dabt_helper</span><br><span class="line">    b ret_from_exception</span><br><span class="line">    UNWIND(.fnend)</span><br><span class="line">ENDPROC(__dabt_usr)</span><br></pre></td></tr></table></figure>

<p> 进入异常处理函数后第一件事是保存现场, 之前已保存了部分寄存器, usr_entry用来保存全部寄存器.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.macro usr_entry</span><br><span class="line">    UNWIND(.fnstart)</span><br><span class="line">    UNWIND(.cantunwind)             @ don&#x27;t unwind the user space</span><br><span class="line">    sub sp, sp, #S_FRAME_SIZE</span><br><span class="line">    ARM( stmib sp, &#123;r1 - r12&#125;)</span><br><span class="line">    THUMB( stmia sp, &#123;r0 - r12&#125;)</span><br><span class="line">    ldmia r0, &#123;r3 - r5&#125;</span><br><span class="line">    add r0, sp, #S_PC               @ here for interlock avoidance</span><br><span class="line">    mov r6, #-1</span><br><span class="line">    str r3, [sp]                    @ save the &quot;real&quot; r0 copied</span><br><span class="line">                                    @ from the exception stack</span><br><span class="line">    @</span><br><span class="line">    @ We are now ready to fill in the remaining blanks on the stack:</span><br><span class="line">    @</span><br><span class="line">    @  r4 - lr_&lt;exception&gt;, already fixed up for correct return/restart</span><br><span class="line">    @  r5 - spsr_&lt;exception&gt;</span><br><span class="line">    @  r6 - orig_r0 (see pt_regs definition in ptrace.h)</span><br><span class="line">    @</span><br><span class="line">    @ Also, separately save sp_usr and lr_usr</span><br><span class="line">    @</span><br><span class="line">    stmia r0, &#123;r4 - r6&#125;</span><br><span class="line">    ARM( stmdb r0, &#123;sp, lr&#125;^)</span><br><span class="line">    THUMB( store_user_sp_lr r0, r1, S_SP - S_PC)</span><br><span class="line">    @</span><br><span class="line">    @ Enable the alignment trap while in kernel mode</span><br><span class="line">    @</span><br><span class="line">    alignment_trap r0</span><br><span class="line">    @</span><br><span class="line">    @ Clear FP to mark the first stack frame</span><br><span class="line">    @</span><br><span class="line">    zero_fp</span><br><span class="line">#ifdef CONFIG_IRQSOFF_TRACER</span><br><span class="line">    bl trace_hardirqs_off</span><br><span class="line">#endif</span><br><span class="line">    ct_user_exit save = 0</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>首先将r1-r12压栈, 注意此处没有使用push而是sp先减少再使用stmib反向压栈.<br>原因是这些寄存器后面将以pt_regs形式访问, 数组排列是从低到高, 与栈增长相反.<br>另外r0, pc, cpsr, orig_r0是压栈传入的, 原因分别如下.<br>r0需作为栈地址参数传入异常处理函数, 其原始值被修改, 所以通过栈传入.<br>由于pt_regs是指用户异常现场, pc与cpsr应保存异常发生时值, 但进入异常时使用影子寄存器.<br>所以使用压栈的 <code>lr_exception</code> 与 <code>spsr_exception</code> (reference manual A2-13).<br>最后orig_r0是什么鬼? 想不清楚它的用处.</p>
<p>保存完用户现场后开始真正异常处理, dabt_helper的注释是调用指定的abort handler.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.macro dabt_helper</span><br><span class="line">    @</span><br><span class="line">    @ Call the processor-specific abort handler:</span><br><span class="line">    @</span><br><span class="line">    @  r2 - pt_regs</span><br><span class="line">    @  r4 - aborted context pc</span><br><span class="line">    @  r5 - aborted context psr</span><br><span class="line">    @</span><br><span class="line">    @ The abort handler must return the aborted address in r0, and</span><br><span class="line">    @ the fault status register in r1.  r9 must be preserved.</span><br><span class="line">    @</span><br><span class="line">#ifdef MULTI_DABORT</span><br><span class="line">    ldr ip, .LCprocfns</span><br><span class="line">    mov lr, pc</span><br><span class="line">    ldr pc, [ip, #PROCESSOR_DABT_FUNC]</span><br><span class="line">#else</span><br><span class="line">    bl CPU_DABORT_HANDLER</span><br><span class="line">#endif</span><br><span class="line">.endm</span><br><span class="line">#ifdef MULTI_DABORT</span><br><span class="line">.LCprocfns:</span><br><span class="line">    .word processor</span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

<p>其中pt_regs保存在r2中, abort时的pc指针保存在r4中, abort时的cpsr保存在r5中.<br>handler返回时abort地址保存在r0中, 错误状态寄存器(fsr)保存在r1中, r9保留.<br>宏MULTI_DABORT定义见arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;glue-df.h, 由不同架构决定, ARMv7架构定义了该宏.<br>对于定义MULTI_DABORT宏的架构, ldr pc, [ip, <code>#PROCESSOR_DABT_FUNC</code>]是跳转的关键.<br>.LCprocfns段存放的是全局变量processor, 其定义在arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;proc-fns.h.<br>PROCESSOR_DABT_FUNC定义见arch&#x2F;arm&#x2F;kernel&#x2F;asm-offsets.c, 即指向processor._data_abort.</p>
<p>全局变量processor是如何初始化的? 答案见setup_processor(defined in arch&#x2F;arm&#x2F;kernel&#x2F;setup.c).<br>在setup_processor中会调用lookup_processor_type(defined in arch&#x2F;arm&#x2F;kernel&#x2F;head-common.S):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lookup_processor_type)</span><br><span class="line">    stmfd sp!, &#123;r4 - r6, r9, lr&#125;</span><br><span class="line">    mov r9, r0</span><br><span class="line">    bl __lookup_processor_type</span><br><span class="line">    mov r0, r5</span><br><span class="line">    ldmfd sp!, &#123;r4 - r6, r9, pc&#125;</span><br><span class="line">ENDPROC(lookup_processor_type)</span><br><span class="line">__lookup_processor_type:</span><br><span class="line">    adr r3, __lookup_processor_type_data</span><br><span class="line">    ldmia r3, &#123;r4 - r6&#125;</span><br><span class="line">    sub r3, r3, r4             @ get offset between virt&amp;phys</span><br><span class="line">    add r5, r5, r3             @ convert virt addresses to</span><br><span class="line">    add r6, r6, r3             @ physical address space</span><br><span class="line">1:  ldmia r5, &#123;r3, r4&#125;         @ value, mask</span><br><span class="line">    and r4, r4, r9             @ mask wanted bits</span><br><span class="line">    teq r3, r4</span><br><span class="line">    beq 2f</span><br><span class="line">    add r5, r5, #PROC_INFO_SZ  @ sizeof(proc_info_list)</span><br><span class="line">    cmp r5, r6</span><br><span class="line">    blo 1b</span><br><span class="line">    mov r5, #0                 @ unknown processor</span><br><span class="line">2:  mov pc, lr</span><br><span class="line">ENDPROC(__lookup_processor_type)</span><br></pre></td></tr></table></figure>



<p>__lookup_processor_type的注释解释了代码意图: 从CP15读取处理器id并从链接时建立的数组中查找.<br>由于此时未开启MMU因此无法使用绝对地址索引proc_info, 需根据偏移来计算.<br>lookup_processor_type首先将cpuid保存在r9, 然后获取程序装载地址的偏移.<br>__lookup_processor_type_data是数据段对象, 其包含两个数据__proc_info_begin与__proc_info_end.<br>通过arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds.S可以得知该地址区间保存.proc.info.init数据.<br>r3是编译时的程序地址, r4是运行时的实际地址.<br>r3与r4相减即无MMU时程序加载地址相对程序文件地址的偏移.<br>r5与r6分别为__lookup_processor_type_data数据段的起始地址与结束地址.<br>将r5地址前两个成员(cpu_val与cpu_mask)保存在r3与r4, 将其与cpuid比较, 如果符合则跳出循环.<br>如果不符合则取r5下一个元素地址与r6比较, 溢出说明数组越界r5设为0, 否则重复上一步比较.</p>
<p>在分析了processor的初始化后, 我们再来看下.proc.info.init数组是如何定义的.<br>此处代码与架构强相关, 每个芯片都有差异, 仅以基于ARMv7架构为例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.macro __v7_proc initfunc, mm_mmuflags = 0, io_mmuflags = 0, hwcaps = 0, proc_fns = v7_processor_functions</span><br><span class="line">    ALT_SMP(.long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line">        PMD_SECT_AF | PMD_FLAGS_SMP | \mm_mmuflags)</span><br><span class="line">    ALT_UP(.long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line">        PMD_SECT_AF | PMD_FLAGS_UP | \mm_mmuflags)</span><br><span class="line">    .long PMD_TYPE_SECT | PMD_SECT_AP_WRITE | \</span><br><span class="line">        PMD_SECT_AP_READ | PMD_SECT_AF | \io_mmuflags</span><br><span class="line">    W(b) \initfunc</span><br><span class="line">    .long cpu_arch_nam</span><br><span class="line">    .long cpu_elf_name</span><br><span class="line">    .long HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \</span><br><span class="line">        HWCAP_EDSP | HWCAP_TLS | \hwcaps</span><br><span class="line">    .long cpu_v7_name</span><br><span class="line">    .long \proc_fns</span><br><span class="line">    .long v7wbi_tlb_fns</span><br><span class="line">    .long v6_user_fns</span><br><span class="line">    .long v7_cache_fns</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<p>宏__v7_proc(defined in arch&#x2F;arm&#x2F;mm&#x2F;proc-v7.S)作用是生成一个struct proc_info_list实例.<br>在arch&#x2F;arm&#x2F;mm&#x2F;proc-v7.S中有多个用该宏定义的实例, 这些实例都放在.proc.info.init段中.<br>每个实例对应一类芯片, __v7_proc_info是大部分ARMv7处理器对应的struct proc_info_list的实例.<br>__v7_proc_info的processor成员是v7_processor_functions, 再来看看该成员.<br>直接搜索该名字找不到定义的, 因为它是通过宏定义的生成的(烦不烦- -!).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.macro define_processor_functions name:req, dabort:req, pabort:req, nommu=0, suspend=0</span><br><span class="line">    .type \name\()_processor_functions, #object</span><br><span class="line">    .align 2</span><br><span class="line">ENTRY(\name\()_processor_functions)</span><br><span class="line">    .word \dabort</span><br><span class="line">    .word \pabort</span><br><span class="line">    .word cpu_\name\()_proc_init</span><br><span class="line">    .word cpu_\name\()_proc_fin</span><br><span class="line">    .word cpu_\name\()_reset</span><br><span class="line">    .word cpu_\name\()_do_idle</span><br><span class="line">    .word cpu_\name\()_dcache_clean_area</span><br><span class="line">    .word cpu_\name\()_switch_mm</span><br><span class="line">    .if \nommu</span><br><span class="line">    .word 0</span><br><span class="line">    .else</span><br><span class="line">    .word cpu_\name\()_set_pte_ext</span><br><span class="line">    .endif</span><br><span class="line">    .if \suspend</span><br><span class="line">    .word cpu_\name\()_suspend_size</span><br><span class="line">#ifdef CONFIG_PM_SLEEP</span><br><span class="line">    .word cpu_\name\()_do_suspend</span><br><span class="line">    .word cpu_\name\()_do_resume</span><br><span class="line">#else</span><br><span class="line">    .word 0</span><br><span class="line">    .word 0</span><br><span class="line">#endif</span><br><span class="line">    .else</span><br><span class="line">    .word 0</span><br><span class="line">    .word 0</span><br><span class="line">    .word 0</span><br><span class="line">    .endif</span><br><span class="line">    .size \name\()_processor_functions, . - \name\()_processor_functions</span><br><span class="line">.endm</span><br><span class="line">define_processor_functions v7, dabort=v7_early_abort, pabort=v7_pabort, suspend=1</span><br></pre></td></tr></table></figure>



<p>宏define_processor_functions(defined in arch&#x2F;arm&#x2F;mm&#x2F;proc-macro.S).<br>该宏作用是生成一个struct processor实例, 联系对该宏的调用终于可以摸索出我们想要的回调了.<br>在lookup_processor_type返回后r0保存着proc_info_list地址, 对ARMv7架构而言.<br>返回的proc_info_list为__v7_proc_info(defined in arch&#x2F;arm&#x2F;mm&#x2F;proc-v7.S).<br>其processor成员为v7_processor_functions, 它是由宏展开的, 其_data_abort成员为v7_early_abort.</p>
<p>再来看v7_early_abort(defined in arch&#x2F;arm&#x2F;mm&#x2F;abort-ev7.S):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(v7_early_abort)</span><br><span class="line">    /*</span><br><span class="line">     * The effect of data aborts on on the exclusive access monitor are</span><br><span class="line">     * UNPREDICTABLE. Do a CLREX to clear the state</span><br><span class="line">     */</span><br><span class="line">    clrex</span><br><span class="line">    mrc p15, 0, r1, c5, c0, 0         @ get FSR</span><br><span class="line">    mrc p15, 0, r0, c6, c0, 0         @ get FAR</span><br><span class="line">    /*</span><br><span class="line">     * V6 code adjusts the returned DFSR.</span><br><span class="line">     * New designs should not need to patch up faults.</span><br><span class="line">     */</span><br><span class="line">#if defined(CONFIG_VERIFY_PERMISSION_FAULT)</span><br><span class="line">    /*</span><br><span class="line">     * Detect erroneous permission failures and fix</span><br><span class="line">     */</span><br><span class="line">    ldr r3, =0x40d               @ On permission fault</span><br><span class="line">    and r3, r1, r3</span><br><span class="line">    cmp r3, #0x0d</span><br><span class="line">    bne do_DataAbort</span><br><span class="line">    mcr p15, 0, r0, c7, c8, 0    @ Retranslate FAR</span><br><span class="line">    isb</span><br><span class="line">    mrc p15, 0, ip, c7, c4, 0    @ Read the PAR</span><br><span class="line">    and r3, ip, #0x7b            @ On translation fault</span><br><span class="line">    cmp r3, #0x0b</span><br><span class="line">    bne do_DataAbort</span><br><span class="line">    bic r1, r1, #0xf             @ Fix up FSR FS[5:0]</span><br><span class="line">    and ip, ip, #0x7e</span><br><span class="line">    orr r1, r1, ip, LSR #1</span><br><span class="line">#endif</span><br><span class="line">    b do_DataAbort</span><br><span class="line">ENDPROC(v7_early_abort)</span><br></pre></td></tr></table></figure>



<p>v7_early_abort很简单, 先对FSR与FAR的处理(reference manual B3-18), 然后调用do_DataAbort.<br>使用r0保存FAR(fault address register), 使用r1保存FSR(fault status register), 后面会用到.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __exception</span><br><span class="line"><span class="title function_">do_DataAbort</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> fsr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fsr_info</span> *<span class="title">inf</span> =</span> fsr_info + fsr_fs(fsr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!inf-&gt;fn(addr, fsr &amp; ~FSR_LNX_PF, regs))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Unhandled fault: %s (0x%03x) at 0x%08lx\n&quot;</span>,</span><br><span class="line">        inf-&gt;name, fsr, addr);</span><br><span class="line">    info.si_signo = inf-&gt;sig;</span><br><span class="line">    info.si_errno = <span class="number">0</span>;</span><br><span class="line">    info.si_code  = inf-&gt;code;</span><br><span class="line">    info.si_addr  = (<span class="type">void</span> __user *)addr;</span><br><span class="line">    arm_notify_die(<span class="string">&quot;&quot;</span>, regs, &amp;info, fsr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsr_info</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*fn)(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> fsr, <span class="keyword">struct</span> pt_regs *regs);</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* FSR definition */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_LPAE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fsr-3level.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fsr-2level.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>do_DataAbort也很简单, 调用fsr_info数组某个元素的回调, 返回后根据结果向进程发送信号.<br>由于未开启ARM_LPAE(ARM large page support), 此处使用fsr-2level.c的数组(太大了不拷贝).<br>.<br>以page fault为例, 调用do_page_fault, 当找不到页表时会调用__do_user_fault向用户进程发送信号.<br>回到__dabt_usr, 在abort handler返回后调用ret_from_exception退出异常.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_exception)</span><br><span class="line">    UNWIND(.fnstart)</span><br><span class="line">    UNWIND(.cantunwind)</span><br><span class="line">    get_thread_info tsk</span><br><span class="line">    mov why, #0</span><br><span class="line">    b ret_to_user</span><br><span class="line">    UNWIND(.fnend)</span><br><span class="line">ENDPROC(__pabt_usr)</span><br><span class="line">ENDPROC(ret_from_exception)</span><br><span class="line">ENTRY(ret_to_user)</span><br><span class="line">ret_slow_syscall:</span><br><span class="line">    disable_irq                   @ disable interrupts</span><br><span class="line">ENTRY(ret_to_user_from_irq)</span><br><span class="line">    ldr r1, [tsk, #TI_FLAGS]</span><br><span class="line">    tst r1, #_TIF_WORK_MASK</span><br><span class="line">    bne work_pending</span><br><span class="line">    no_work_pending:</span><br><span class="line">    asm_trace_hardirqs_on</span><br><span class="line">    /* perform architecture specific actions before user return */</span><br><span class="line">    arch_ret_to_user r1, lr</span><br><span class="line">    ct_user_enter save = 0</span><br><span class="line">    restore_user_regs fast = 0, offset = 0</span><br><span class="line">ENDPROC(ret_to_user_from_irq)</span><br><span class="line">ENDPROC(ret_to_user)</span><br></pre></td></tr></table></figure>



<p>ret_to_user首先会关中断, 检查thread_info-&gt;flags.<br>如发现需要调度的标记执行work_pending(defined in arch&#x2F;arm&#x2F;kernel&#x2F;entry-common.S).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">work_pending:</span><br><span class="line">    mov r0, sp    @ &#x27;regs&#x27;</span><br><span class="line">    mov r2, why    @ &#x27;syscall&#x27;</span><br><span class="line">    bl do_work_pending</span><br><span class="line">    cmp r0, #0</span><br><span class="line">    beq no_work_pending</span><br><span class="line">    movlt scno, #(__NR_restart_syscall - __NR_SYSCALL_BASE)</span><br><span class="line">    ldmia sp, &#123;r0 - r6&#125;   @ have to reload r0 - r6</span><br><span class="line">    b local_restart   @ ... and off we go</span><br></pre></td></tr></table></figure>



<p>do_work_pending(defined in arch&#x2F;arm&#x2F;kernel&#x2F;signal.c)的作用是判断是否需要调度或信号处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">int</span> <span class="title function_">do_work_pending</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, \</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> thread_flags, <span class="type">int</span> syscall)</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ret_to_user_from_irq中已将r1赋值为thread_info-&gt;flags, 即此处thread_flags</span></span><br><span class="line"><span class="comment">         * 同样regs值为态sp, syscall值为why</span></span><br><span class="line"><span class="comment">         * thread_flags可能有多个位置位, 按顺序依次处理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span> (likely(thread_flags &amp; _TIF_NEED_RESCHED)) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果CPSR模式位不在用户态, 即之前程序就工作在内核态</span></span><br><span class="line"><span class="comment">             * 被高优先级的任务抢占(比如系统调用时被中断打断)</span></span><br><span class="line"><span class="comment">             * 那么此时直接返回继续之前任务</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(!user_mode(regs)))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            local_irq_enable();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 判断是否有信号挂起</span></span><br><span class="line"><span class="comment">             * 该标记位在signal_wake_up_state与recalc_sigpending_tsk设置</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">if</span> (thread_flags &amp; _TIF_SIGPENDING) &#123;</span><br><span class="line">                <span class="comment">//do_signal(defined in arch/arm/kernel/signal.c)定义见下</span></span><br><span class="line">                <span class="type">int</span> restart = do_signal(regs, syscall);</span><br><span class="line">                <span class="keyword">if</span> (unlikely(restart)) &#123;</span><br><span class="line">                    <span class="comment">//处理失败直接返回, 不调用回调</span></span><br><span class="line">                    <span class="keyword">return</span> restart;</span><br><span class="line">                &#125;</span><br><span class="line">                syscall = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">                tracehook_notify_resume(regs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_irq_disable();</span><br><span class="line">        thread_flags = current_thread_info()-&gt;flags;</span><br><span class="line">    &#125; <span class="keyword">while</span> (thread_flags &amp; _TIF_WORK_MASK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_signal作用是处理挂起信号, 保存内核寄存器状态, 为内核执行用户态回调做准备.<br>保存数据的原因: 内核态与用户态共用一套寄存器.<br>当用户回调返回时内核寄存器状态已被破坏, 因此需要在用户态保存内核寄存器状态.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> syscall)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际调用get_signal_to_deliver(defined in kernel/signal.c)</span></span><br><span class="line"><span class="comment">     * get_signal_to_deliver中调用dequeue_signal先从task_struct-&gt;pending获取信号</span></span><br><span class="line"><span class="comment">     * 获取失败再从task_struct-&gt;signal-&gt;shared_pending获取信号</span></span><br><span class="line"><span class="comment">     * 还有很多判断, 先忽略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在执行信号回调句柄前准备工作, 在用户态栈保存内核数据</span></span><br><span class="line"><span class="comment">         * handle_signal实际调用setup_frame或setup_rt_frame(如果为rt信号)</span></span><br><span class="line"><span class="comment">         * 以setup_frame为例:</span></span><br><span class="line"><span class="comment">         * 1. 首先调用get_sigframe获取用户态栈地址, 对齐并确认可写</span></span><br><span class="line"><span class="comment">         *    注意sigframe结构体的排布, 在用户态获取lr时会用到该结构</span></span><br><span class="line"><span class="comment">         * 2. 设置uc.uc_flags为0x5a3c3c5a</span></span><br><span class="line"><span class="comment">         * 3. 调用setup_sigframe填充sigframe结构</span></span><br><span class="line"><span class="comment">         * 4. 调用setup_return设置回调接口返回(设置pt_regs)</span></span><br><span class="line"><span class="comment">         *    注意此时pt_regs仍在栈上:</span></span><br><span class="line"><span class="comment">         *    pt_regs-&gt;pc设置为信号回调句柄</span></span><br><span class="line"><span class="comment">         *    pt_regs-&gt;r0设置为signo</span></span><br><span class="line"><span class="comment">         *    pt_regs-&gt;lr被修改为retcode</span></span><br><span class="line"><span class="comment">         *    pt_regs-&gt;sp被修改为frame(frame是结构体起始地址, 与栈方向相反, 所以是栈底!)</span></span><br><span class="line"><span class="comment">         * 在栈帧建立后调用signal_setup_done恢复阻塞的信号</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        handle_signal(&amp;ksig, regs);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回到work_pending, 当do_work_pending返回时会检查函数返回值(r0).<br>如果返回成功则跳转到no_work_pending标签, 此时开始准备进入用户态.<br>其中arch_ret_to_user宏是架构相关宏, ARM上无定义; ct_user_enter是跟踪上下文宏, 忽略.<br>重点在restore_user_regs(defined in arch&#x2F;arm&#x2F;kernel&#x2F;entry-header.S).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.macro restore_user_regs, fast = 0, offset = 0</span><br><span class="line">    clrex                                  @ clear the exclusive monitor</span><br><span class="line">    mov r2, sp</span><br><span class="line">    load_user_sp_lr r2, r3, \offset + S_SP @ calling sp, lr</span><br><span class="line">    ldr r1, [sp, #\offset + S_PSR]         @ get calling cpsr</span><br><span class="line">    ldr lr, [sp, #\offset + S_PC]          @ get pc</span><br><span class="line">    add sp, sp, #\offset + S_SP</span><br><span class="line">    msr spsr_cxsf, r1                      @ save in spsr_svc</span><br><span class="line">    .if \fast</span><br><span class="line">    ldmdb sp, &#123;r1 - r12&#125;                   @ get calling r1 - r12</span><br><span class="line">    .else</span><br><span class="line">    ldmdb sp, &#123;r0 - r12&#125;                   @ get calling r0 - r12</span><br><span class="line">    .endif</span><br><span class="line">    add sp, sp, #S_FRAME_SIZE - S_SP</span><br><span class="line">    movs pc, lr                            @ return &amp; move spsr_svc into cpsr</span><br><span class="line">.endm</span><br><span class="line">.macro load_user_sp_lr, rd, rtemp, offset = 0</span><br><span class="line">    mrs \rtemp, cpsr</span><br><span class="line">    eor \rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)</span><br><span class="line">    msr cpsr_c, \rtemp                     @ switch to the SYS mode</span><br><span class="line">    ldr sp, [\rd, #\offset]                @ load sp_usr</span><br><span class="line">    ldr lr, [\rd, #\offset + 4]            @ load lr_usr</span><br><span class="line">    eor \rtemp, \rtemp, #(SVC_MODE ^ SYSTEM_MODE)</span><br><span class="line">    msr cpsr_c, \rtemp                     @ switch back to the SVC mode</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>



<p>clrex用于清除本地cpu独占访问某块内存区域的标记.<br>S_SP定义见arch&#x2F;arm&#x2F;kernel&#x2F;asm-offsets.c, 是ARM_sp在pt_regs的偏移.<br>对sp与lr的保存需额外切换到系统模式后处理, 是因为SVC模式下使用sp_svc与lr_svc.<br>而系统模式与用户模式使用同一套寄存器, 仅权限不同.<br>再根据是否为fast_path恢复用户寄存器, 同时恢复sp(此处sp为SVC模式的sp).<br>最后将lr拷贝给pc, 此指令会自动恢复cpsr, 不要问我为什么reference manual就是这么写的.<br>至此开始用户子程的执行.</p>
<h2 id="用户进程回溯堆栈"><a href="#用户进程回溯堆栈" class="headerlink" title="用户进程回溯堆栈"></a>用户进程回溯堆栈</h2><p>回到第一部分, 如何在信号回调中回溯堆栈? 回顾之前的流程, 当用户进程访问非法地址时立即触发异常, 程序跳转到异常向量, 处理器模式进入异常模式使用异常模式下sp与lr, 当执行完异常处理后cpu恢复到特权模式处理, 此时使用特权模式下sp与lr, 为保证程序在执行完信号回调后能正常恢复特权模式现场, 需要在用户态保存现场, 即do_signal中的sigframe(在用户态即信号回调的参数3), 回到用户态进程还需要入栈一个siginfo结构, 因此用户进程栈结构为:<br>栈顶<br>…<br>异常发生时栈地址<br>sigframe<br>siginfo<br>信号回调地址<br>通过sigframe我们可以获取异常发生时寄存器列表, 即获取异常时sp, pc, lr, 进一步回溯整个堆栈.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/signal/" rel="tag"># signal</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/" rel="prev" title="jemalloc调研">
      <i class="fa fa-chevron-left"></i> jemalloc调研
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/20/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E8%B0%83%E7%A0%94/" rel="next" title="scudo 内存分配器调研">
      scudo 内存分配器调研 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A5SIGSEGV%E4%B8%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E4%B8%8E%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="nav-number">1.</span> <span class="nav-text">以SIGSEGV为例详解信号处理(与栈回溯)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%BE%8B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">信号处理例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">内核信号量数据结构与系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">信号处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%BA%AF%E5%A0%86%E6%A0%88"><span class="nav-number">1.4.</span> <span class="nav-text">用户进程回溯堆栈</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">269</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

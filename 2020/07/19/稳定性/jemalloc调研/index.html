<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW WenKai:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="jemalloc中提供的malloc函数叫做je_malloc, 释放的函数是je_free. jemalloc基础知识size_class每个 size_class 代表 jemalloc 分配的内存大小，共有 NSIZES（232）?个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：  small_class（小内存）">
<meta property="og:type" content="article">
<meta property="og:title" content="jemalloc调研">
<meta property="og:url" content="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="jemalloc中提供的malloc函数叫做je_malloc, 释放的函数是je_free. jemalloc基础知识size_class每个 size_class 代表 jemalloc 分配的内存大小，共有 NSIZES（232）?个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：  small_class（小内存）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liguangzhang.github.io/images/20201130111643.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/20201214115523.svg">
<meta property="og:image" content="https://liguangzhang.github.io/images/20201203174939.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/20201204103839.svg">
<meta property="article:published_time" content="2020-07-19T10:15:54.000Z">
<meta property="article:modified_time" content="2024-04-16T08:03:21.272Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="jemalloc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liguangzhang.github.io/images/20201130111643.jpg">

<link rel="canonical" href="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'" />

  <title>jemalloc调研 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jemalloc调研
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 18:15:54" itemprop="dateCreated datePublished" datetime="2020-07-19T18:15:54+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 16:03:21" itemprop="dateModified" datetime="2024-04-16T16:03:21+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%A8%B3%E5%AE%9A%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">稳定性</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/jemalloc%E8%B0%83%E7%A0%94/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>jemalloc中提供的malloc函数叫做<code>je_malloc</code>, 释放的函数是<code>je_free</code>.</p>
<h2 id="jemalloc基础知识"><a href="#jemalloc基础知识" class="headerlink" title="jemalloc基础知识"></a>jemalloc基础知识</h2><h3 id="size-class"><a href="#size-class" class="headerlink" title="size_class"></a>size_class</h3><p>每个 <code>size_class</code> 代表 jemalloc 分配的内存大小，共有 NSIZES（232）?个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：</p>
<ul>
<li><code>small_class</code>（<em>小内存</em>） : 对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, …, 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂，比如如果没有48字节，那当申请33字节时，分配64字节显然会造成约50%的外部碎片</li>
<li><code>large_class</code>（<em>大内存</em>）: 对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, …, 1mb, 2mb, 4mb等</li>
<li><code>size_index</code> : size 位于 <code>size_class</code> 中的索引号，区间为 [0，231]?，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当 size 是 <code>small_class</code> 时，<code>size_index</code> 也称作 <code>binind</code></li>
</ul>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Associated arena&#x27;s index within the arenas array. */</span></span><br><span class="line">	<span class="type">unsigned</span>	ind;</span><br><span class="line">	<span class="comment">/* User-configurable extent hook functions.  Points to an extent_hooks_t. */</span>  extent分配回收等相关的函数指针</span><br><span class="line">	<span class="type">atomic_p_t</span>	extent_hooks;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Protects base_alloc() and base_stats_get() operations. */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>	mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Using THP when true (metadata_thp auto mode). */</span></span><br><span class="line">	<span class="type">bool</span>		auto_thp_switched;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Most recent size class in the series of increasingly large base</span></span><br><span class="line"><span class="comment">	 * extents.  Logarithmic spacing between subsequent allocations ensures</span></span><br><span class="line"><span class="comment">	 * that the total number of distinct mappings remains small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pszind_t</span>	pind_last;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Serial number generation state. */</span>   下一个extent的sn号</span><br><span class="line">	<span class="type">size_t</span>		extent_sn_next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Chain of all blocks associated with base. */</span> blocks链表</span><br><span class="line">	<span class="type">base_block_t</span>	*blocks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Heap of extents that track unused trailing space within blocks. */</span> extent堆的root节点[NSIZES]</span><br><span class="line">	<span class="type">extent_heap_t</span>	avail[NSIZES];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stats, only maintained if config_stats. */</span>  统计信息相关</span><br><span class="line">	<span class="type">size_t</span>		allocated;</span><br><span class="line">	<span class="type">size_t</span>		resident;</span><br><span class="line">	<span class="type">size_t</span>		mapped;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Embedded at the beginning of every block of base-managed virtual memory. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">base_block_s</span> <span class="title">base_block_t</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Total size of block&#x27;s virtual memory mapping. */</span> </span><br><span class="line">	<span class="type">size_t</span>		size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Next block in list of base&#x27;s blocks. */</span></span><br><span class="line">	<span class="type">base_block_t</span>	*next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tracks unused trailing space. */</span>  保存extent的元数据信息</span><br><span class="line">	<span class="type">extent_t</span>	extent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用于分配 jemalloc <code>元数据内存</code>的结构</p>
<ul>
<li><code>base.blocks.extent</code> : 存放每个 <code>size_class</code> 的 <code>extent</code> 元数据</li>
<li>base.blocks是一个链表, 通过其next可以找到当前<code>ind</code>维护的所有的extent元数据信息</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bin_s</span> <span class="title">bin_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* All operations on bin_t fields require lock ownership. */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		lock;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current slab being used to service allocations of this bin&#x27;s size</span></span><br><span class="line"><span class="comment">	 * class.  slabcur is independent of slabs_&#123;nonfull,full&#125;; whenever</span></span><br><span class="line"><span class="comment">	 * slabcur is reassigned, the previous slab must be deallocated or</span></span><br><span class="line"><span class="comment">	 * inserted into slabs_&#123;nonfull,full&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">extent_t</span>		*slabcur;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Heap of non-full slabs.  This heap is used to assure that new</span></span><br><span class="line"><span class="comment">	 * allocations come from the non-full slab that is oldest/lowest in</span></span><br><span class="line"><span class="comment">	 * memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">extent_heap_t</span>		slabs_nonfull;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List used to track full slabs. */</span></span><br><span class="line">	<span class="type">extent_list_t</span>		slabs_full;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bin statistics. */</span></span><br><span class="line">	<span class="type">bin_stats_t</span>	stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>管理正在使用中的 <code>slab</code>（即用于小内存分配的 <code>extent</code>） 的集合，每个 <code>bin</code> 对应一个 <code>size_class</code></p>
<ul>
<li><code>bin.slabcur</code> : 当前使用中的 <code>slab</code></li>
<li><code>bin.slabs_nonfull</code> : 有空闲内存块的 <code>slab</code></li>
</ul>
<h3 id="bin-infos-binind"><a href="#bin-infos-binind" class="headerlink" title="bin_infos[binind]"></a>bin_infos[binind]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bin_info_s</span> <span class="title">bin_info_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_info_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Size of regions in a slab for this bin&#x27;s size class. */</span>   region占了多少内存</span><br><span class="line">	<span class="type">size_t</span>			reg_size;</span><br><span class="line">	<span class="comment">/* Total size of a slab for this bin&#x27;s size class. */</span>        slab 即 extent占了多少内存</span><br><span class="line">	<span class="type">size_t</span>			slab_size;</span><br><span class="line">	<span class="comment">/* Total number of regions in a slab for this bin&#x27;s size class. */</span>  一个slab内有多少个 region</span><br><span class="line">	<span class="type">uint32_t</span>		nregs;</span><br><span class="line"><span class="comment">/* Metadata used to manipulate bitmaps for slabs associated with this bin. */</span> 和extent-&gt;e_slab_data的bitmap信息配合, 查看region的使用情况</span><br><span class="line">	<span class="type">bitmap_info_t</span>		bitmap_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmap_info_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Logical number of bits in bitmap (stored at bottom level). */</span></span><br><span class="line">	<span class="type">size_t</span> nbits;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BITMAP_USE_TREE</span></span><br><span class="line">	<span class="comment">/* Number of levels necessary for nbits. */</span></span><br><span class="line">	<span class="type">unsigned</span> nlevels;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only the first (nlevels+1) elements are used, and levels are ordered</span></span><br><span class="line"><span class="comment">	 * bottom to top (e.g. the bottom level is stored in levels[0]).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bitmap_level_t</span> levels[BITMAP_MAX_LEVELS+<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* BITMAP_USE_TREE */</span></span></span><br><span class="line">	<span class="comment">/* Number of groups necessary for nbits. */</span></span><br><span class="line">	<span class="type">size_t</span> ngroups;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* BITMAP_USE_TREE */</span></span></span><br><span class="line">&#125; <span class="type">bitmap_info_t</span>;</span><br></pre></td></tr></table></figure>

<p>管理相同<code>binind</code> 的所有bin的信息,  注意不是维护bin的链表, 只是存bin所属的相关<code>sizeclass</code>的相关信息,  从<code>bitmap_info</code>中获取regions组的信息(在使用TREE的情况下,  获取TREE深度信息)</p>
<h3 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h3><p> 管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是 <code>N * page_size(4kb)</code>（N &gt;&#x3D; 1）。每个 extent 有一个序列号（serial number）。</p>
<p>一个 <code>extent</code> 可以用来分配一次 <code>large_class</code> 的内存申请，但可以用来分配<code>多次 small_class</code> 的内存申请。</p>
<ul>
<li><code>extent.e_bits</code> : 8字节长，记录<code>多种信息</code></li>
<li><code>extent.e_addr</code> : 管理的内存块的起始地址</li>
<li><code>extent.e_slab_data</code> : 位图bitmap，当此 <code>extent</code> 用于分配 <code>small_class</code> 内存时，用来记录这个 <code>extent</code> 的分配情况，此时每个 <code>extent</code> 内的小内存称为 <code>region</code>, 和bin_infos中的bitmap_info 配合使用,  每个region是否被使用占一个bit, 一个bitmap在64位上可以管理64个region. 查使用遍历每个bitmap, 64位上没有使用TREE结构, 即查看bitmap内从右边开始第一个非0的bit位,  在该bit位前的一个位置(未使用的), 是可以使用的region.</li>
</ul>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>当 extent 用于分配 <code>small_class</code> 内存时，称其为 <code>slab</code>。一个 <code>extent</code> 可以被用来处理多个同一 <code>size_class</code> 的内存申请。</p>
<h3 id="extents"><a href="#extents" class="headerlink" title="extents"></a>extents</h3><p>管理 <code>extent</code> 的集合。</p>
<ul>
<li><code>extents.heaps[NPSIZES+1]</code> : 各种 <code>page(4kb)</code> 倍数大小的 <code>extent</code></li>
<li><code>extents.lru</code> : 存放所有 <code>extent</code> 的双向链表</li>
<li><code>extents.delay_coalesce</code> : 是否延迟 <code>extent</code> 的合并</li>
</ul>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *   0: Application allocation.</span></span><br><span class="line"><span class="comment">	 *   1: Internal metadata allocation.	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_u_t</span>		nthreads[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When percpu_arena is enabled, to amortize the cost of reading /</span></span><br><span class="line"><span class="comment">	 * updating the current CPU id, track the most recent thread accessing</span></span><br><span class="line"><span class="comment">	 * this arena, and only read CPU if there is a mismatch.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">tsdn_t</span>		*last_thd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Synchronization: internal. */</span></span><br><span class="line">	<span class="type">arena_stats_t</span>		stats;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lists of tcaches and cache_bin_array_descriptors for extant threads</span></span><br><span class="line"><span class="comment">	 * associated with this arena.  Stats from these are merged</span></span><br><span class="line"><span class="comment">	 * incrementally, and at exit if opt_stats_print is enabled.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: tcache_ql_mtx.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ql_head(<span class="type">tcache_t</span>)			tcache_ql;</span><br><span class="line">	ql_head(<span class="type">cache_bin_array_descriptor_t</span>)	cache_bin_array_descriptor_ql;</span><br><span class="line">	<span class="type">malloc_mutex_t</span>				tcache_ql_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Synchronization: internal. */</span></span><br><span class="line">	<span class="type">prof_accum_t</span>		prof_accum;</span><br><span class="line">	<span class="type">uint64_t</span>		prof_accumbytes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Extent serial number generator state.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_zu_t</span>		extent_sn_next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Extant large allocations.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: large_mtx.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">extent_list_t</span>		large;</span><br><span class="line">	<span class="comment">/* Synchronizes all large allocation/update/deallocation. */</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		large_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Collections of extents that were previously allocated.  These are</span></span><br><span class="line"><span class="comment">	 * used when allocating extents, in an attempt to re-use address space.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: internal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">extents_t</span>		extents_dirty;</span><br><span class="line">	<span class="type">extents_t</span>		extents_muzzy;</span><br><span class="line">	<span class="type">extents_t</span>		extents_retained;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Decay-based purging state, responsible for scheduling extent state</span></span><br><span class="line"><span class="comment">	 * transitions.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: internal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">arena_decay_t</span>		decay_dirty; <span class="comment">/* dirty --&gt; muzzy */</span></span><br><span class="line">	<span class="type">arena_decay_t</span>		decay_muzzy; <span class="comment">/* muzzy --&gt; retained */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Next extent size class in a growing series to use when satisfying a</span></span><br><span class="line"><span class="comment">	 * request via the extent hooks (only if opt_retain).  This limits the</span></span><br><span class="line"><span class="comment">	 * number of disjoint virtual memory ranges so that extent merging can</span></span><br><span class="line"><span class="comment">	 * be effective even if multiple arenas&#x27; extent allocation requests are</span></span><br><span class="line"><span class="comment">	 * highly interleaved.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * retain_grow_limit is the max allowed size ind to expand (unless the</span></span><br><span class="line"><span class="comment">	 * required size is greater).  Default is no limit, and controlled</span></span><br><span class="line"><span class="comment">	 * through mallctl only.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Synchronization: extent_grow_mtx</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pszind_t</span>		extent_grow_next;</span><br><span class="line">	<span class="type">pszind_t</span>		retain_grow_limit;</span><br><span class="line">	<span class="type">malloc_mutex_t</span>		extent_grow_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Available extent structures that were allocated via</span></span><br><span class="line"><span class="comment">	 * base_alloc_extent().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">extent_tree_t</span>		extent_avail;</span><br><span class="line">	<span class="type">malloc_mutex_t</span>		extent_avail_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * bins is used to store heaps of free regions.</span></span><br><span class="line"><span class="comment">	 * Synchronization: internal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bin_t</span>			bins[NBINS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Base allocator, from which arena metadata are allocated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">base_t</span>			*base;</span><br><span class="line">	<span class="comment">/* Used to determine uptime.  Read-only after initialization. */</span></span><br><span class="line">	<span class="type">nstime_t</span>		create_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>挂到arenas[ind]下,  struct arena_s</p>
<p>用于分配&amp;回收 <code>extent</code> 的结构，每个用户线程会被绑定到一个 <code>arena</code> 上，默认每个逻辑 CPU 会有 4 个 <code>arena</code> 来减少锁的竞争，各个 arena 所管理的内存相互独立。</p>
<ul>
<li><code>arena.extents_dirty</code> : 刚被释放后空闲 <code>extent</code> 位于的地方</li>
<li><code>arena.extents_muzzy</code> : <code>extents_dirty</code> 进行 lazy purge 后位于的地方，<code>dirty -&gt; muzzy</code></li>
<li><code>arena.extents_retained</code> : <code>extents_muzzy</code> 进行 decommit 或 force purge 后 <code>extent</code> 位于的地方，<code>muzzy -&gt; retained</code></li>
<li><code>arena.large</code> : 存放 <code>large extent</code> 的 <code>extents</code></li>
<li><code>arena.extent_avail</code> : heap，存放可用的 <code>extent</code> 元数据</li>
<li><code>arena.bins[NBINS]</code> : 所以用于分配小内存的 <code>bin</code></li>
<li><code>arena.base</code> : 用于分配元数据的 <code>base</code>, base中有base_blocks管理所有当前ind的blocks链表, 而arena由areans[ind] 管理</li>
</ul>
<p><img src="/images/20201130111643.jpg" alt="img"></p>
<h3 id="rtree"><a href="#rtree" class="headerlink" title="rtree"></a>rtree</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtree_ctx_s</span> <span class="title">rtree_ctx_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtree_ctx_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Direct mapped cache. */</span></span><br><span class="line">	<span class="type">rtree_ctx_cache_elm_t</span>	cache[RTREE_CTX_NCACHE];</span><br><span class="line">	<span class="comment">/* L2 LRU cache. */</span></span><br><span class="line">	<span class="type">rtree_ctx_cache_elm_t</span>	l2_cache[RTREE_CTX_NCACHE_L2];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtree_ctx_cache_elm_s</span> <span class="title">rtree_ctx_cache_elm_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtree_ctx_cache_elm_s</span> &#123;</span></span><br><span class="line">	<span class="type">uintptr_t</span>		 leafkey;</span><br><span class="line">	<span class="type">rtree_leaf_elm_t</span>	*leaf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtree_s</span> &#123;</span></span><br><span class="line">	<span class="type">malloc_mutex_t</span>		init_lock;</span><br><span class="line">	<span class="type">rtree_leaf_elm_t</span>	root[<span class="number">1U</span> &lt;&lt; (RTREE_NSB/RTREE_HEIGHT)];</span><br><span class="line">&#125;;</span><br><span class="line">RTREE_HEIGHT = <span class="number">2</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">rtree_level_t</span> rtree_levels[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> RTREE_HEIGHT == 2</span></span><br><span class="line">	&#123;RTREE_NSB/<span class="number">2</span>, RTREE_NHIB + RTREE_NSB/<span class="number">2</span>&#125;,                <span class="comment">// &#123;18, 34&#125;</span></span><br><span class="line">	&#123;RTREE_NSB/<span class="number">2</span> + RTREE_NSB%<span class="number">2</span>, RTREE_NHIB + RTREE_NSB&#125;     <span class="comment">// &#123;18, 52&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leafkey 即是取 后34 位 注意leafkey 与 全局tree的遍历无关, 不要与rtree_subkey弄混了</span></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">uintptr_t</span></span><br><span class="line">rtree_leafkey(<span class="type">uintptr_t</span> key) &#123;</span><br><span class="line">	<span class="type">unsigned</span> ptrbits = ZU(<span class="number">1</span>) &lt;&lt; (<span class="number">3</span>+<span class="number">3</span>) = <span class="number">64</span>;</span><br><span class="line">	<span class="type">unsigned</span> cumbits = (rtree_levels[<span class="number">1</span>].cumbits -</span><br><span class="line">	    rtree_levels[<span class="number">1</span>].bits);</span><br><span class="line">	<span class="type">unsigned</span> maskbits = <span class="number">64</span> - (<span class="number">48</span><span class="number">-18</span>) = <span class="number">34</span>;</span><br><span class="line">	<span class="type">uintptr_t</span> mask = ~((ZU(<span class="number">1</span>) &lt;&lt; maskbits) - <span class="number">1</span>) = <span class="number">1</span> &lt;&lt; <span class="number">34</span> - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> (key &amp; mask);  (key &amp; <span class="number">1</span> &lt;&lt; <span class="number">34</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里tree的深度是2 level只能等于0 或 1, 在确定root数组长度时, level = 0</span></span><br><span class="line">--&gt;	<span class="keyword">if</span> (RTREE_HEIGHT &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		RTREE_GET_CHILD(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subkey 即是取 中间的18位[30-47]</span></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">uintptr_t</span></span><br><span class="line"><span class="title function_">rtree_subkey</span><span class="params">(<span class="type">uintptr_t</span> key, <span class="type">unsigned</span> level)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> ptrbits = ZU(<span class="number">1</span>) &lt;&lt; (LG_SIZEOF_PTR+<span class="number">3</span>) = <span class="number">64</span>;</span><br><span class="line">	<span class="type">unsigned</span> cumbits = rtree_levels[level].cumbits = <span class="number">34</span>;</span><br><span class="line">	<span class="type">unsigned</span> shiftbits = ptrbits - cumbits = <span class="number">30</span>;</span><br><span class="line">	<span class="type">unsigned</span> maskbits = rtree_levels[level].bits = <span class="number">18</span>;</span><br><span class="line">	<span class="type">uintptr_t</span> mask = (ZU(<span class="number">1</span>) &lt;&lt; maskbits) - <span class="number">1</span> = <span class="number">1</span> &lt;&lt; <span class="number">18</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ((key &gt;&gt; shiftbits) &amp; mask) = (key &gt;&gt; <span class="number">30</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">18</span> <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在确定 root的子节点对应的数组长度时, level = 1</span></span><br><span class="line"><span class="comment">// subkey 即是取 18位 [12-30]</span></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="type">uintptr_t</span></span><br><span class="line"><span class="title function_">rtree_subkey</span><span class="params">(<span class="type">uintptr_t</span> key, <span class="type">unsigned</span> level)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> ptrbits = ZU(<span class="number">1</span>) &lt;&lt; (LG_SIZEOF_PTR+<span class="number">3</span>) = <span class="number">64</span>;</span><br><span class="line">	<span class="type">unsigned</span> cumbits = rtree_levels[level].cumbits = <span class="number">52</span>;</span><br><span class="line">	<span class="type">unsigned</span> shiftbits = ptrbits - cumbits = <span class="number">12</span>;</span><br><span class="line">	<span class="type">unsigned</span> maskbits = rtree_levels[level].bits = <span class="number">18</span>;</span><br><span class="line">	<span class="type">uintptr_t</span> mask = (ZU(<span class="number">1</span>) &lt;&lt; maskbits) - <span class="number">1</span> = <span class="number">1</span> &lt;&lt; <span class="number">18</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ((key &gt;&gt; shiftbits) &amp; mask) = (key &gt;&gt; <span class="number">12</span>) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">18</span> <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<p>全局唯一的存放每个 <code>extent</code> 信息的 Radix Tree，以 <strong><code>extent-&gt;e_addr</code></strong> 即 <code>uintptr_t</code> 为 key，如uintptr_t<code> 为64位（8字节)</code>, rtree 的高度为2</p>
<p><img src="/images/20201214115523.svg" alt="jemalloc_tree.drawio"></p>
<h3 id="cache-bin"><a href="#cache-bin" class="headerlink" title="cache_bin"></a>cache_bin</h3><p><img src="/images/20201203174939.jpg" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_bin_s</span> <span class="title">cache_bin_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_bin_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Min # cached since last GC. */</span></span><br><span class="line">	<span class="type">cache_bin_sz_t</span> low_water;</span><br><span class="line">	<span class="comment">/* # of cached objects. */</span></span><br><span class="line">	<span class="type">cache_bin_sz_t</span> ncached;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stack of available objects.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * To make use of adjacent cacheline prefetch, the items in the avail</span></span><br><span class="line"><span class="comment">	 * stack goes to higher address for newer allocations.  avail points</span></span><br><span class="line"><span class="comment">	 * just above the available space, which means that</span></span><br><span class="line"><span class="comment">	 * avail[-ncached, ... -1] are available items and the lowest item will</span></span><br><span class="line"><span class="comment">	 * be allocated first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> **avail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个线程独有的用于分配小内存的缓存</p>
<ul>
<li><code>low_water</code> : 上一次 gc 后剩余的缓存数量</li>
<li><code>cache_bin.ncached</code> : 当前 <code>cache_bin</code> 存放的缓存数量</li>
<li><code>cache_bin.avail</code> : 可直接用于分配的内存，从左往右依次分配（注意这里的寻址方式）</li>
</ul>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Drives incremental GC. */</span></span><br><span class="line">	<span class="type">ticker_t</span>	gc_ticker;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pointer stacks associated with bins follow as a contiguous array.</span></span><br><span class="line"><span class="comment">	 * During tcache initialization, the avail pointer in each element of</span></span><br><span class="line"><span class="comment">	 * tbins is initialized to point to the proper offset within this array.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">cache_bin_t</span>	bins_small[NBINS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This data is less hot; we can be a little less careful with our</span></span><br><span class="line"><span class="comment">	 * footprint here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Lets us track all the tcaches in an arena. */</span></span><br><span class="line">	ql_elm(<span class="type">tcache_t</span>) link;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The descriptor lets the arena find our cache bins without seeing the</span></span><br><span class="line"><span class="comment">	 * tcache definition.  This enables arenas to aggregate stats across</span></span><br><span class="line"><span class="comment">	 * tcaches without having a tcache dependency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">cache_bin_array_descriptor_t</span> cache_bin_array_descriptor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The arena this tcache is associated with. */</span></span><br><span class="line">	<span class="type">arena_t</span>		*arena;</span><br><span class="line">	<span class="comment">/* Next bin to GC. */</span></span><br><span class="line">	<span class="type">szind_t</span>		next_gc_bin;</span><br><span class="line">	<span class="comment">/* For small bins, fill (ncached_max &gt;&gt; lg_fill_div). */</span></span><br><span class="line">	<span class="type">uint8_t</span>		lg_fill_div[NBINS];</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We put the cache bins for large size classes at the end of the</span></span><br><span class="line"><span class="comment">	 * struct, since some of them might not get used.  This might end up</span></span><br><span class="line"><span class="comment">	 * letting us avoid touching an extra page if we don&#x27;t have to.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">cache_bin_t</span>	bins_large[NSIZES-NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个线程独有的缓存（Thread Cache），大多数内存申请都可以在 <code>tcache</code> 中直接得到，从而避免加锁</p>
<ul>
<li><code>tcache.bins_small[NBINS]</code> : 小内存的 <code>cache_bin</code></li>
<li><code>tcache.bins_large[NSIZES - NBINS]</code>: 大内存的<code>cache_bin</code></li>
</ul>
<h3 id="tsd"><a href="#tsd" class="headerlink" title="tsd"></a>tsd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsd_s</span> &#123;</span></span><br><span class="line">	<span class="type">tsd_state_t</span>	state;</span><br><span class="line">    <span class="type">bool</span> ...tcache_enabled;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">rtree_ctx_t</span> ...rtree_ctx;    </span><br><span class="line">    <span class="type">arena_t</span>* ...arena;</span><br><span class="line">    <span class="type">tcache_t</span> ...tcache;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Thread Specific Data，每个线程独有，用于存放与这个线程相关的结构</p>
<ul>
<li><code>tsd.rtree_ctx</code> : 当前线程的 rtree context，用于快速访问 <code>extent</code> 信息</li>
<li><code>tsd.arena</code> : 当前线程绑定的 <code>arena</code></li>
<li><code>tsd.tcache</code> : 当前线程的 <code>tcache</code></li>
</ul>
<h2 id="je初始化及内存申请"><a href="#je初始化及内存申请" class="headerlink" title="je初始化及内存申请"></a>je初始化及内存申请</h2><p>进行内存申请时, 需要先进行初始化</p>
<h3 id="1-1-初始化参数"><a href="#1-1-初始化参数" class="headerlink" title="1.1 初始化参数"></a>1.1 初始化参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--&gt; <span class="number">1.1</span> 初始化参数</span><br><span class="line">sopts.bump_empty_alloc = <span class="literal">true</span>;</span><br><span class="line">sopts.null_out_result_on_error = <span class="literal">true</span>;</span><br><span class="line">sopts.set_errno_on_error = <span class="literal">true</span>;</span><br><span class="line">sopts.oom_string = <span class="string">&quot;&lt;jemalloc&gt;: Error in malloc(): out of memory\n&quot;</span>; <span class="comment">// 申请失败时返回的消息</span></span><br><span class="line">dynamic_opts-&gt;item_size = <span class="number">0</span>;</span><br><span class="line">dynamic_opts-&gt;alignment = <span class="number">0</span>; <span class="comment">// 不对齐</span></span><br><span class="line">dynamic_opts-&gt;zero = <span class="literal">false</span>;</span><br><span class="line">dynamic_opts-&gt;tcache_ind = TCACHE_IND_AUTOMATIC;</span><br><span class="line">dynamic_opts-&gt;arena_ind = ARENA_IND_AUTOMATIC;</span><br><span class="line">dopts.result = &amp;ret;</span><br><span class="line">dopts.num_items = <span class="number">1</span>;  <span class="comment">// 申请的内存个数</span></span><br><span class="line">dopts.item_size = size;  <span class="comment">// 申请的size</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-extent默认的处理函数"><a href="#1-2-extent默认的处理函数" class="headerlink" title="1.2 extent默认的处理函数"></a>1.2 extent默认的处理函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--&gt; <span class="number">1.2</span> extent默认的处理函数, 没贴的函数就是没打开宏的</span><br><span class="line">    <span class="comment">// eg: extent_hooks-&gt;alloc()    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extent_hooks_s</span> &#123;</span></span><br><span class="line">	<span class="type">extent_alloc_t</span>		*alloc;</span><br><span class="line">	<span class="type">extent_dalloc_t</span>		*dalloc;</span><br><span class="line">	<span class="type">extent_destroy_t</span>	*destroy;</span><br><span class="line">	<span class="type">extent_commit_t</span>		*commit;</span><br><span class="line">	<span class="type">extent_decommit_t</span>	*decommit;</span><br><span class="line">	<span class="type">extent_purge_t</span>		*purge_lazy;  <span class="comment">// not supported</span></span><br><span class="line">	<span class="type">extent_purge_t</span>		*purge_forced;</span><br><span class="line">	<span class="type">extent_split_t</span>		*split;</span><br><span class="line">	<span class="type">extent_merge_t</span>		*merge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">extent_hooks_t</span>	extent_hooks_default = &#123;</span><br><span class="line">	extent_alloc_default,</span><br><span class="line">	extent_dalloc_default,</span><br><span class="line">	extent_destroy_default,</span><br><span class="line">	extent_commit_default,</span><br><span class="line">	extent_decommit_default</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	extent_purge_forced_default,</span><br><span class="line">	extent_split_default,</span><br><span class="line">	extent_merge_default</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-SIZE-CLASSES定义"><a href="#1-3-SIZE-CLASSES定义" class="headerlink" title="1.3 SIZE_CLASSES定义"></a>1.3 SIZE_CLASSES定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--&gt; <span class="number">1.3</span> 宏展开</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> sz_pind2sz_tab[NPSIZES+<span class="number">1</span>] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSZ_yes(lg_grp, ndelta, lg_delta)				\</span></span><br><span class="line"><span class="meta">	(((ZU(1)&lt;&lt;lg_grp) + (ZU(ndelta)&lt;&lt;lg_delta))),</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSZ_no(lg_grp, ndelta, lg_delta)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SC(index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup) \</span></span><br><span class="line"><span class="meta">	PSZ_##psz(lg_grp, ndelta, lg_delta)</span></span><br><span class="line">	SIZE_CLASSES</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PSZ_yes</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PSZ_no</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SC</span></span><br><span class="line">	(LARGE_MAXCLASS + PAGE)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// arm64 走的这个分支</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LG_SIZEOF_PTR == 3 &amp;&amp; LG_TINY_MIN == 3 &amp;&amp; LG_QUANTUM == 4 &amp;&amp; LG_PAGE == 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_CLASSES \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_MAXCLASS		((((size_t)1) &lt;&lt; 13) + (((size_t)3) &lt;&lt; 11))   <span class="comment">//10240</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// arm32 走的这个分支</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LG_SIZEOF_PTR == 2 &amp;&amp; LG_TINY_MIN == 3 &amp;&amp; LG_QUANTUM == 3 &amp;&amp; LG_PAGE == 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_CLASSES \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_MAXCLASS		((((size_t)1) &lt;&lt; 13) + (((size_t)3) &lt;&lt; 11))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 不同的配置设置不同的SIZE_CLASSES</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-arena-boot-展开"><a href="#1-4-arena-boot-展开" class="headerlink" title="1.4 arena_boot 展开"></a>1.4 arena_boot 展开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">arena_boot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGIND_bin_yes(index, reg_size) 				\</span></span><br><span class="line"><span class="meta">	div_init(&amp;arena_binind_div_info[(index)], (reg_size));</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGIND_bin_no(index, reg_size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SC(index, lg_grp, lg_delta, ndelta, psz, bin, pgs,		\</span></span><br><span class="line"><span class="meta">    lg_delta_lookup)							\</span></span><br><span class="line"><span class="meta">	REGIND_bin_##bin(index, (1U&lt;&lt;lg_grp) + (ndelta &lt;&lt; lg_delta))</span></span><br><span class="line">	SIZE_CLASSES</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REGIND_bin_yes</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REGIND_bin_no</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> SC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 粘贴到macro.c 中, </span></span><br><span class="line"><span class="comment">// gcc -E -P macro.c -o result.c , kate result.c 替换 `; div_init` 为 `; \n div_init` </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arena_boot</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">0</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">3</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">3</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">1</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">3</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">2</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">4</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">3</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">4</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">4</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">4</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">5</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">6</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">6</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">6</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">7</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">6</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">8</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">6</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">4</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">9</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">7</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">10</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">7</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">5</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">11</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">7</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">5</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">12</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">7</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">5</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">13</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">8</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">6</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">14</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">8</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">6</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">15</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">8</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">6</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">16</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">8</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">6</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">17</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">9</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">18</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">9</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">7</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">19</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">9</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">7</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">20</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">9</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">7</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">21</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">10</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">8</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">22</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">10</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">8</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">23</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">10</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">8</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">24</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">10</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">8</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">25</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">11</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">9</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">26</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">11</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">9</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">27</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">11</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">9</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">28</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">11</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">9</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">29</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">12</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">10</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">30</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">12</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">31</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">12</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">10</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">32</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">12</span>) + (<span class="number">4</span> &lt;&lt; <span class="number">10</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">33</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">13</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">34</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">13</span>) + (<span class="number">2</span> &lt;&lt; <span class="number">11</span>))); </span><br><span class="line"> div_init(&amp;arena_binind_div_info[(<span class="number">35</span>)], ((<span class="number">1U</span>&lt;&lt;<span class="number">13</span>) + (<span class="number">3</span> &lt;&lt; <span class="number">11</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-高级宏展开"><a href="#1-5-高级宏展开" class="headerlink" title="1.5 高级宏展开"></a>1.5 高级宏展开</h3><h4 id="MALLOC-TSD-tsds-结构体"><a href="#MALLOC-TSD-tsds-结构体" class="headerlink" title="MALLOC_TSD tsds 结构体"></a><code>MALLOC_TSD</code> tsds 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  O(name,			type,			nullable type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_TSD							\</span></span><br><span class="line"><span class="meta">    O(tcache_enabled,		bool,			bool)		\</span></span><br><span class="line"><span class="meta">    O(arenas_tdata_bypass,	bool,			bool)		\</span></span><br><span class="line"><span class="meta">    O(reentrancy_level,		int8_t,			int8_t)		\</span></span><br><span class="line"><span class="meta">    O(narenas_tdata,		uint32_t,		uint32_t)	\</span></span><br><span class="line"><span class="meta">    O(offset_state,		uint64_t,		uint64_t)	\</span></span><br><span class="line"><span class="meta">    O(thread_allocated,		uint64_t,		uint64_t)	\</span></span><br><span class="line"><span class="meta">    O(thread_deallocated,	uint64_t,		uint64_t)	\</span></span><br><span class="line"><span class="meta">    O(prof_tdata,		prof_tdata_t *,		prof_tdata_t *)	\</span></span><br><span class="line"><span class="meta">    O(rtree_ctx,		rtree_ctx_t,		rtree_ctx_t)	\</span></span><br><span class="line"><span class="meta">    O(iarena,			arena_t *,		arena_t *)	\</span></span><br><span class="line"><span class="meta">    O(arena,			arena_t *,		arena_t *)	\</span></span><br><span class="line"><span class="meta">    O(arenas_tdata,		arena_tdata_t *,	arena_tdata_t *)\</span></span><br><span class="line"><span class="meta">    O(tcache,			tcache_t,		tcache_t)	\</span></span><br><span class="line"><span class="meta">    O(witness_tsd,              witness_tsd_t,		witness_tsdn_t)	\</span></span><br><span class="line"><span class="meta">    MALLOC_[[存储相关/[[存储相关/test|test]]|TEST]]_TSD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O(n, t, nt)							\</span></span><br><span class="line"><span class="meta">JEMALLOC_ALWAYS_INLINE t *						\</span></span><br><span class="line"><span class="meta">tsd_##n##p_get_unsafe(tsd_t *tsd) &#123;					\</span></span><br><span class="line"><span class="meta">	return &amp;tsd-&gt;use_a_getter_or_setter_instead_##n;		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">MALLOC_TSD</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> O</span></span><br><span class="line"><span class="comment">// 需要带入 n, t, nt , 根据MALLOC_TSD表确定类型 , 在n是 tcache时, t为tcache_t, nt为tcache_t</span></span><br><span class="line"><span class="comment">// 解释后为</span></span><br><span class="line"><span class="type">tcache_t</span>* <span class="title function_">tsd_tcachep_get_unsafe</span><span class="params">(<span class="type">tsd_t</span> *tsd)</span> &#123;					\</span><br><span class="line">	<span class="keyword">return</span> &amp;tsd-&gt;use_a_getter_or_setter_instead_tcache;		\</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsd_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The contents should be treated as totally opaque outside the tsd</span></span><br><span class="line"><span class="comment">	 * module.  Access any thread-local state through the getters and</span></span><br><span class="line"><span class="comment">	 * setters below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">tsd_state_t</span>	state;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O(n, t, nt)							\</span></span><br><span class="line"><span class="meta">	t use_a_getter_or_setter_instead_##n;</span></span><br><span class="line">MALLOC_TSD</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> O</span></span><br><span class="line">    <span class="comment">// 展开为 </span></span><br><span class="line">    <span class="type">tcache_t</span> use_a_getter_or_setter_instead_cache;</span><br><span class="line">    ... <span class="comment">//省略其他成员, 实际上会将MALLOC_TSD表中的所有字段全部展开, 成员为MALLOC_TSD的所有字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="相关的函数"><a href="#相关的函数" class="headerlink" title="相关的函数"></a>相关的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">rb_proto(, extent_avail_, <span class="type">extent_tree_t</span>, <span class="type">extent_t</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rb_proto(a_attr, a_prefix, a_rbt_type, a_type)			\</span></span><br><span class="line"><span class="meta">a_attr void								\</span></span><br><span class="line"><span class="meta">a_prefix##new(a_rbt_type *rbtree);					\</span></span><br><span class="line"><span class="meta">a_attr bool								\</span></span><br><span class="line"><span class="meta">a_prefix##empty(a_rbt_type *rbtree);					\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##first(a_rbt_type *rbtree);					\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##last(a_rbt_type *rbtree);					\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##next(a_rbt_type *rbtree, a_type *node);			\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##prev(a_rbt_type *rbtree, a_type *node);			\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##search(a_rbt_type *rbtree, const a_type *key);		\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key);		\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##psearch(a_rbt_type *rbtree, const a_type *key);		\</span></span><br><span class="line"><span class="meta">a_attr void								\</span></span><br><span class="line"><span class="meta">a_prefix##insert(a_rbt_type *rbtree, a_type *node);			\</span></span><br><span class="line"><span class="meta">a_attr void								\</span></span><br><span class="line"><span class="meta">a_prefix##remove(a_rbt_type *rbtree, a_type *node);			\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\</span></span><br><span class="line"><span class="meta">  a_rbt_type *, a_type *, void *), void *arg);				\</span></span><br><span class="line"><span class="meta">a_attr a_type *								\</span></span><br><span class="line"><span class="meta">a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\</span></span><br><span class="line"><span class="meta">  a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);		\</span></span><br><span class="line"><span class="meta">a_attr void								\</span></span><br><span class="line"><span class="meta">a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\</span></span><br><span class="line"><span class="meta">  void *arg);</span></span><br><span class="line"> <span class="comment">// 函数声明, gcc -E 预都出来</span></span><br><span class="line"> <span class="type">extent_t</span> * <span class="title function_">extent_avail_first</span><span class="params">(<span class="type">extent_tree_t</span> *rbtree)</span>; </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 函数实现 ph.h extent.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ph_gen(a_attr, a_prefix, a_ph_type, a_type, a_field, a_cmp)	\</span></span><br><span class="line"><span class="meta">a_prefix##remove_first(a_ph_type *ph) &#123;					\</span></span><br><span class="line"><span class="meta">	a_type *ret;							\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (ph-&gt;ph_root == NULL) &#123;					\</span></span><br><span class="line"><span class="meta">		return NULL;						\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	ph_merge_aux(a_type, a_field, ph, a_cmp);			\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	ret = ph-&gt;ph_root;						\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	ph_merge_children(a_type, a_field, ph-&gt;ph_root, a_cmp,		\</span></span><br><span class="line"><span class="meta">	    ph-&gt;ph_root);						\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	return ret;							\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">extent_esnead_comp</span><span class="params">(<span class="type">const</span> <span class="type">extent_t</span> *a, <span class="type">const</span> <span class="type">extent_t</span> *b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = extent_esn_comp(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = extent_ead_comp(a, b);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">UNUSED <span class="type">extent_t</span> * <span class="title function_">extent_avail_remove_first</span><span class="params">(<span class="type">extent_tree_t</span> *ph)</span> &#123; </span><br><span class="line">    <span class="type">extent_t</span> *ret; </span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;ph_root == ((<span class="type">void</span> *)<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">void</span> *)<span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    ph_merge_aux(<span class="type">extent_t</span>, ph_link, ph, extent_esnead_comp);</span><br><span class="line">    ret = ph-&gt;ph_root;</span><br><span class="line">    ph_merge_children(<span class="type">extent_t</span>, ph_link, ph-&gt;ph_root, extent_esnead_comp, ph-&gt;ph_root);</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-bits相关"><a href="#e-bits相关" class="headerlink" title="e_bits相关"></a>e_bits相关</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">EXTENT_BITS_ARENA_WIDTH = <span class="number">12</span> ;</span><br><span class="line">EXTENT_BITS_ARENA_SHIFT =<span class="number">0</span>;</span><br><span class="line">EXTENT_BITS_ARENA_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">12</span>)) - <span class="number">1</span>)) &lt;&lt; (<span class="number">0</span>));  <span class="comment">//4095 111111111111    fff</span></span><br><span class="line">EXTENT_BITS_SLAB_WIDTH =<span class="number">1</span>;</span><br><span class="line">EXTENT_BITS_SLAB_SHIFT =(<span class="number">12</span> + <span class="number">0</span>);</span><br><span class="line">EXTENT_BITS_SLAB_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">1</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">12</span> + <span class="number">0</span>))); <span class="comment">//4096 1000000000000     1000</span></span><br><span class="line">EXTENT_BITS_COMMITTED_WIDTH = <span class="number">1</span>;</span><br><span class="line">EXTENT_BITS_COMMITTED_SHIFT = (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>));</span><br><span class="line">EXTENT_BITS_COMMITTED_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">1</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))); <span class="comment">//8192  10000000000000   2000</span></span><br><span class="line">EXTENT_BITS_DUMPABLE_WIDTH = <span class="number">1</span>;</span><br><span class="line">EXTENT_BITS_DUMPABLE_SHIFT = (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))) ;</span><br><span class="line">EXTENT_BITS_DUMPABLE_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">1</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))))); <span class="comment">//16384 100000000000000 4000</span></span><br><span class="line">EXTENT_BITS_ZEROED_WIDTH =<span class="number">1</span>;</span><br><span class="line">EXTENT_BITS_ZEROED_SHIFT =(<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))));  <span class="comment">//15   1111 f </span></span><br><span class="line">EXTENT_BITS_ZEROED_MASK = ((((<span class="number">1</span> &lt;&lt; (<span class="number">1</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))))); <span class="comment">//32768  1000000000000000 8000</span></span><br><span class="line">EXTENT_BITS_STATE_WIDTH = <span class="number">2</span>;</span><br><span class="line">EXTENT_BITS_STATE_SHIFT = (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))))); <span class="comment">//16</span></span><br><span class="line">EXTENT_BITS_STATE_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">2</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))))))); <span class="comment">//196608  110000000000000000 30000</span></span><br><span class="line">EXTENT_BITS_SZIND_WIDTH =<span class="number">8</span>;</span><br><span class="line">EXTENT_BITS_SZIND_SHIFT =(<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))))));  <span class="comment">// 18 10010 12 </span></span><br><span class="line">EXTENT_BITS_SZIND_MASK =((((<span class="number">1</span> &lt;&lt; (<span class="number">8</span>)) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))))))); <span class="comment">// 66846720 11111111000000000000000000 3FC0000</span></span><br><span class="line">EXTENT_BITS_NFREE_WIDTH =((<span class="number">12</span> - <span class="number">3</span>) + <span class="number">1</span>);    <span class="comment">//10 1010 a </span></span><br><span class="line">EXTENT_BITS_NFREE_SHIFT =(<span class="number">8</span> + (<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))))));    <span class="comment">//26 11010 1a </span></span><br><span class="line">EXTENT_BITS_NFREE_MASK =((((<span class="number">1</span> &lt;&lt; (((<span class="number">12</span> - <span class="number">3</span>) + <span class="number">1</span>))) - <span class="number">1</span>)) &lt;&lt; ((<span class="number">8</span> + (<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))))))));  <span class="comment">// 68652367872 111111111100000000000000000000000000 FFC000000 </span></span><br><span class="line">EXTENT_BITS_SN_SHIFT =(((<span class="number">12</span> - <span class="number">3</span>) + <span class="number">1</span>) + (<span class="number">8</span> + (<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>)))))))); <span class="comment">// 36 100100 24</span></span><br><span class="line">EXTENT_BITS_SN_MASK =(<span class="number">18446744073709551615</span> &lt;&lt; (((<span class="number">12</span> - <span class="number">3</span>) + <span class="number">1</span>) + (<span class="number">8</span> + (<span class="number">2</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">1</span> + (<span class="number">12</span> + <span class="number">0</span>))))))))); <span class="comment">//  FFFFFFFFFFFFFFFF000000000 </span></span><br></pre></td></tr></table></figure>

<h3 id="je-malloc-基本流程"><a href="#je-malloc-基本流程" class="headerlink" title="je_malloc 基本流程"></a>je_malloc 基本流程</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">-&gt; je_malloc<span class="params">(size_t size)</span></span><br><span class="line">    | - static_opts_init<span class="params">(&amp;sopts)</span></span><br><span class="line">    | - dynamic_opts_init<span class="params">(&amp;dopts)</span></span><br><span class="line">    \ - imalloc<span class="params">(&amp;sopts, &amp;dopts)</span> # &quot;参考1.<span class="number">1</span> 初始化参数<span class="string">&quot;</span></span><br><span class="line"><span class="string">       \ - !malloc_initialized() &amp;&amp; !malloc_init() # &quot;</span>这个地方通常不会失败, 第一次会进malloc_init()函数<span class="string">&quot;</span></span><br><span class="line"><span class="string">       |  \ - malloc_init_state == malloc_init_initialized # &quot;</span>即malloc_initialized为<span class="literal">true</span>时不会进入malloc_init函数<span class="string">&quot;</span></span><br><span class="line"><span class="string">       |  | - malloc_init_hard()</span></span><br><span class="line"><span class="string">          |  \ - malloc_init_hard_needed() #判断是否有另一个线程正在初始化, 只要有一个线程进行初始化了即可</span></span><br><span class="line"><span class="string">            *| - malloc_init_hard_a0_locked() # 进行初始化的函数</span></span><br><span class="line"><span class="string">             |  \ - config_prof -&gt; prof_boot0()  ? 待研究 // TODO</span></span><br><span class="line"><span class="string">       |  |  |  | - malloc_conf_init() # 参数初始化 -&gt; android 上只load case 0 1的情况, 只覆盖opts </span></span><br><span class="line"><span class="string">                                                   应该是elf 编译时通过je_malloc_conf 引入的     ?待研究 //TODO </span></span><br><span class="line"><span class="string">                | - pages_boot() -&gt; os_overcommits = true 看起来没有做其他额外的处理</span></span><br><span class="line"><span class="string">                |  \ - init_thp_state() -&gt; JEMALLOC_USE_SYSCALL /sys/kernel/mm/transparent_hugepage/enabled ? not exsit</span></span><br><span class="line"><span class="string">                |  |  \ - opt_thp = init_system_thp_mode = thp_mode_not_supported  transparent_hugepage(THP)?                 </span></span><br><span class="line"><span class="string">    |  |  |     | - base_boot(TSDN_NULL)</span></span><br><span class="line"><span class="string">                |  \ - base_new(tsdn, 0, (extent_hooks_t *)&amp;extent_hooks_default) #ind(index) = 0 QUANTUM(2^4对齐) //TODO</span></span><br><span class="line"><span class="string">                |  |  \ - block = base_block_alloc(tsdn, NULL, extent_hooks, ind, &amp;pind_last, &amp;extent_sn_next, sizeof(base_t), QUANTUM)</span></span><br><span class="line"><span class="string">               |  |   |  \ - alignment = ALIGNMENT_CEILING(alignment, QUANTUM) #16字节对齐</span></span><br><span class="line"><span class="string">                         | - size_t usize = ALIGNMENT_CEILING(size, alignment);    #16字节对齐</span></span><br><span class="line"><span class="string">                         | - min_block_size = HUGEPAGE_CEILING(sz_psz2u(header_size + gap_size + usize)); # header + block</span></span><br><span class="line"><span class="string">								# HUGEPAGE_CEILING 按`HUGEPAGE_MASK` 对齐 64位上是 2^21</span></span><br><span class="line"><span class="string">                         | - next_block_size = HUGEPAGE_CEILING(sz_pind2sz(pind_next)) # &quot;</span>pind_next是<span class="number">1</span>, 这里初始化传的ind是<span class="number">0</span>, next即为<span class="number">1</span>,</span><br><span class="line">                         NPSIZES tab的总index-&gt;sizeClass 总的class的数目<span class="string">&quot;</span></span><br><span class="line"><span class="string">                         |  \ - sz_pind2sz_lookup(pind) #对应table SIZE_CLASSES(需要进行宏展开) 参考1.3 SIZE_CLASSES展开 //TODO gdb查看该值</span></span><br><span class="line"><span class="string">						 | - block_size = (min_block_size &gt; next_block_size) ? min_block_size : next_block_size; #最小2^21</span></span><br><span class="line"><span class="string">    |  |  |     |       *| - block = base_map(tsdn, extent_hooks, ind, block_size);</span></span><br><span class="line"><span class="string">                         |  \ - &lt;extent_hooks == &amp;extent_hooks_default&gt; - </span></span><br><span class="line"><span class="string">							 addr = extent_alloc_mmap(NULL, size, alignment, &amp;zero, &amp;commit) </span></span><br><span class="line"><span class="string">										#&quot;</span>size(block_size) alignment = <span class="number">1</span> &lt;&lt; <span class="number">21</span> slow时用到<span class="string">&quot;</span></span><br><span class="line"><span class="string">                            | - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, 1&lt;&lt; 12), commit)</span></span><br><span class="line"><span class="string">                            |  \ - mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0)</span></span><br><span class="line"><span class="string">                               | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ret, size, &quot;</span>libc_malloc<span class="string">&quot;);             </span></span><br><span class="line"><span class="string">       |        | - extent_boot() #锁相关的初始化, 先不用关注</span></span><br><span class="line"><span class="string">	            |  \ - rtree_new(&amp;extents_rtree, true)</span></span><br><span class="line"><span class="string">                |  |  \ - malloc_mutex_init(&amp;rtree-&gt;init_lock, &quot;</span>rtree<span class="string">&quot;, WITNESS_RANK_RTREE, malloc_mutex_rank_exclusive)</span></span><br><span class="line"><span class="string">				   | - mutex_pool_init(&amp;extent_mutex_pool, &quot;</span>extent_mutex_pool<span class="string">&quot;, WITNESS_RANK_EXTENT_POOL)                   </span></span><br><span class="line"><span class="string">                | - ctl_boot()</span></span><br><span class="line"><span class="string">                |  \ - malloc_mutex_init(&amp;ctl_mtx, &quot;</span>ctl<span class="string">&quot;, WITNESS_RANK_CTL, malloc_mutex_rank_exclusive)</span></span><br><span class="line"><span class="string">	    								malloc_mutex_rank_exclusive)                                       </span></span><br><span class="line"><span class="string">                | - config_prof -&gt; prof_boot1()</span></span><br><span class="line"><span class="string">    |  |  |     | - arena_boot() </span></span><br><span class="line"><span class="string">                |  \ - arena_dirty_decay_ms_default_set(opt_dirty_decay_ms)</span></span><br><span class="line"><span class="string">                   | - arena_muzzy_decay_ms_default_set(opt_muzzy_decay_ms)</span></span><br><span class="line"><span class="string">                   | - div_init(&amp;arena_binind_div_info[(index)], (reg_size)) # 需要进行宏展开</span></span><br><span class="line"><span class="string">                                       // gcc -E -P macro.c -o result.c</span></span><br><span class="line"><span class="string">                   |  \ - div_init(&amp;arena_binind_div_info[(0)], ((1U&lt;&lt;3) + (0 &lt;&lt; 3))); ... &quot;</span><span class="number">2</span>^<span class="number">32</span>/<span class="number">8</span> .. arena 表初始化</span><br><span class="line">																							参考<span class="number">1.4</span> arena_boot 展开<span class="string">&quot;</span></span><br><span class="line"><span class="string">                | - tcache_boot() # &quot;</span>cache_bin 用于分配小内存的缓存<span class="string">&quot;</span></span><br><span class="line"><span class="string">				|  \ - nhbins = sz_size2index(tcache_maxclass) + 1; # &quot;</span>共多少bins 其中包括small [<span class="number">0</span>-NBINS]和 large[NBINS+<span class="number">1</span> - nhbins]的<span class="string">&quot;</span></span><br><span class="line"><span class="string">                   | - 	tcache_bin_info = (cache_bin_info_t *)base_alloc(tsdn, b0get(), nhbins * sizeof(cache_bin_info_t), CACHELINE);</span></span><br><span class="line"><span class="string">                   |  \ - base_alloc_impl(tsdn, base, size, alignment, NULL)</span></span><br><span class="line"><span class="string">                      |  \ - extent = extent_heap_remove_first(&amp;base-&gt;avail[i]); #&quot;</span>从base-&gt;avail中取<span class="string">&quot;</span></span><br><span class="line"><span class="string">                         | - &lt;extent == NULL?&gt; - base_extent_alloc(tsdn, base, usize, alignment) # &quot;</span>取不到的话, 需要分配<span class="string">&quot;</span></span><br><span class="line"><span class="string">	                     | - base_extent_bump_alloc(base, extent, usize, alignment)</span></span><br><span class="line"><span class="string">    |  |  |     | - arena_init(TSDN_NULL, 0, (extent_hooks_t *)&amp;extent_hooks_default)</span></span><br><span class="line"><span class="string">                |  \ - arena = arena_init_locked(tsdn, ind, extent_hooks) #&quot;</span>ind=<span class="number">0</span> Create a new arena &amp;insert into the arenas array </span><br><span class="line">                                                                                                              at index ind<span class="string">&quot;       </span></span><br><span class="line"><span class="string">                   | - arena = arena_get(tsdn, ind, false); #&quot;</span>Another thread may have already initialized arenas[ind] for auto arena<span class="string">&quot;</span></span><br><span class="line"><span class="string">                   | - arena = arena_new(tsdn, ind, extent_hooks);</span></span><br><span class="line"><span class="string">                   |  \ - &lt;ind == 0&gt; base = b0get()</span></span><br><span class="line"><span class="string">                      | - &lt;ind != 0&gt; base = base_new(tsdn, ind, extent_hooks)</span></span><br><span class="line"><span class="string">                      | - arena = (arena_t *)base_alloc(tsdn, base, sizeof(arena_t), CACHELINE) #&quot;</span>分配内存单元<span class="string">&quot;</span></span><br><span class="line"><span class="string">					  | - extent_list_init(&amp;arena-&gt;large) #&quot;</span>large 双向链表初始化<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | - extents_init(tsdn, &amp;arena-&gt;extents_dirty, extent_state_dirty, true) #&quot;</span>extents_dirty 初始化<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | - extents_init(tsdn, &amp;arena-&gt;extents_muzzy, extent_state_muzzy, false)</span></span><br><span class="line"><span class="string">                      | - ... # &quot;</span>arena相关的数据结构初始化<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | - &lt;i = 0; i &lt; NBINS; i++&gt; bin_init(&amp;arena-&gt;bins[i]) # &quot;</span>arena 管理的bin 初始化<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      |  \ - extent_heap_new(&amp;bin-&gt;slabs_nonfull)</span></span><br><span class="line"><span class="string">                         | - extent_list_init(&amp;bin-&gt;slabs_full); # &quot;</span>管理无空闲块的双向链表初始化<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | - arena-&gt;base = base; # &quot;</span>arena的元数据base 指向关系<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | - arena_set(ind, arena); # &quot;</span>arenas[inx] = arena<span class="string">&quot;</span></span><br><span class="line"><span class="string">                | - a0 = arena_get(TSDN_NULL, 0, false) # 取arenas[ind] ind = 0</span></span><br><span class="line"><span class="string">          |     | - malloc_init_state = malloc_init_a0_initialized;</span></span><br><span class="line"><span class="string">          | - tsd = malloc_tsd_boot0()</span></span><br><span class="line"><span class="string">          |  \ - tsd_boot0() #创建tsd_tsd</span></span><br><span class="line"><span class="string">             | - tsd_t *tsd = tsd = tsd_fetch()</span></span><br><span class="line"><span class="string">             | - return tsd</span></span><br><span class="line"><span class="string">          | - &lt; malloc_init_hard_recursible() true?&gt;</span></span><br><span class="line"><span class="string">          | Y\ - return true</span></span><br><span class="line"><span class="string">          | - malloc_init_narenas()</span></span><br><span class="line"><span class="string">          | - background_thread_boot1(tsd_tsdn(tsd))</span></span><br><span class="line"><span class="string">          | - malloc_init_percpu() #&quot;</span>配置一个cpu使用的arena总数<span class="string">&quot;</span></span><br><span class="line"><span class="string">          |  \ - opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);</span></span><br><span class="line"><span class="string">          | - malloc_init_hard_finish()</span></span><br><span class="line"><span class="string">       |  |  \ - malloc_init_state = malloc_init_initialized #&quot;</span>根据此标记, 不会再次重新进malloc_init函数<span class="string">&quot; end malloc_init()</span></span><br><span class="line"><span class="string">          | - malloc_tsd_boot1() #创建tsd ？ 只有两个tsd吗？ boot0 boot1？//TODO</span></span><br><span class="line"><span class="string">    | *| - tsd_t *tsd = tsd_fetch(); #如果已经初始化, 直接调到这一步</span></span><br><span class="line"><span class="string">       |  \ - tsd_fetch_impl(true, false);</span></span><br><span class="line"><span class="string">          |  \ - *tsd = tsd_get(true)</span></span><br><span class="line"><span class="string">          |  |  \ - wrapper = tsd_wrapper_get(init)</span></span><br><span class="line"><span class="string">                | - tsd_wrapper_t *wrapper = (tsd_wrapper_t *)pthread_getspecific(tsd_tsd) # tsd 区域</span></span><br><span class="line"><span class="string">                | - &lt;wrapper==NULL&gt; -wrapper = (tsd_wrapper_t *) malloc_tsd_malloc(sizeof(tsd_wrapper_t))</span></span><br><span class="line"><span class="string">				| - tsd_wrapper_set(wrapper)</span></span><br><span class="line"><span class="string">                |  \ - pthread_setspecific(tsd_tsd, (void *)wrapper) # malloc后设置成tsd</span></span><br><span class="line"><span class="string">          |  | -&lt;tsd-&gt;state != tsd_state_nominal&gt;- tsd_fetch_slow(tsd_t *tsd, false);</span></span><br><span class="line"><span class="string">       |  |  |  \ - &lt;tsd-&gt;state == tsd_state_uninitialized&gt; - tsd-&gt;state = tsd_state_nominal</span></span><br><span class="line"><span class="string">                | - tsd_slow_update(tsd); # 设置状态为 tsd_state_nominal 或 tsd_state_nominal_slow(Initialized but on slow path)</span></span><br><span class="line"><span class="string">                | - tsd_set(tsd);</span></span><br><span class="line"><span class="string">                | - tsd_data_init(tsd);</span></span><br><span class="line"><span class="string">          |     |  \ - tsd_tcache_data_init(tsd) #  Trigger tcache init </span></span><br><span class="line"><span class="string">          |     |  | *\ - *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true, NULL, true, arena_get(TSDN_NULL, 0, true))</span></span><br><span class="line"><span class="string">                      |  \ - ret = arena_palloc(tsdn, arena, usize, CACHELINE, zero, tcache); # zero = true</span></span><br><span class="line"><span class="string">       |  |     |        |if\ - &lt;usize &lt;= SMALL_MAXCLASS &amp;&amp; (alignment &lt; PAGE ||... &gt; # SMALL_MAXCLASS=10240 CACHELINE=64&lt;1&lt;&lt;12</span></span><br><span class="line"><span class="string">								- arena_malloc(tsdn, arena, usize, sz_size2index(usize), zero, tcache, true)</span></span><br><span class="line"><span class="string">                            | - &lt;tcache == NULL&gt; #上面调用传过来的tcache 是NULL?                                                        </span></span><br><span class="line"><span class="string">                      |    *| Y\ - return arena_malloc_hard(tsdn, arena, size, ind, zero)</span></span><br><span class="line"><span class="string">                               |  \ - arena = arena_choose(tsdn_tsd(tsdn), arena)</span></span><br><span class="line"><span class="string">                                  | - arena_malloc_small(tsdn, arena, ind, zero)  #直接从arena中分配</span></span><br><span class="line"><span class="string">                                  |  \ - bin = &amp;arena-&gt;bins[ind]</span></span><br><span class="line"><span class="string">                                     | - usize = sz_index2size(binind)</span></span><br><span class="line"><span class="string">                                     | - &lt; slab = bin-&gt;slabcur) != NULL &amp;&amp; extent_nfree_get(slab) &gt; 0 ?&gt; #bin-&gt;slabcur不为空</span></span><br><span class="line"><span class="string">                      |              | Y\ - arena_slab_reg_alloc(slab, &amp;bin_infos[binind])</span></span><br><span class="line"><span class="string">                                        |  \- *slab_data = extent_slab_data_get(slab)</span></span><br><span class="line"><span class="string">                                           | - bin_info = bin_infos[binind]</span></span><br><span class="line"><span class="string">                                           | - regind = bitmap_sfu(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info)</span></span><br><span class="line"><span class="string">                                          *| - ret = (void *)((uintptr_t)extent_addr_get(slab) + (bin_info-&gt;reg_size * regind))#&quot;</span>extent中的e_addr是内存单元(Region)的起始地址, regind是region的index<span class="string">&quot;</span></span><br><span class="line"><span class="string">                      |  |         &lt;==     | - return ret</span></span><br><span class="line"><span class="string">                      |              | N\ - ret = arena_bin_malloc_hard(tsdn, arena, bin, binind)</span></span><br><span class="line"><span class="string">                                        |  \ - bin_info = &amp;bin_infos[binind]</span></span><br><span class="line"><span class="string">                                           | - slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind) # 参考1.6.1&quot;</span>arena_bin_nonfull_slab_get过程<span class="string">&quot;       </span></span><br><span class="line"><span class="string">                                           | - bin-&gt;slabcur = slab;</span></span><br><span class="line"><span class="string">                      |  |         &lt;==     | - return arena_slab_reg_alloc(slab, bin_info)</span></span><br><span class="line"><span class="string">                           *| N\ - return tcache_alloc_small(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path=true)</span></span><br><span class="line"><span class="string">                               |  \ - tbin = tcache_small_bin_get(tcache, binind)</span></span><br><span class="line"><span class="string">                                  | *\ - return &amp;tcache-&gt;bins_small[binind] # bin 从tcache-&gt;bins_small[ind]中取出</span></span><br><span class="line"><span class="string">                                  | - ret = cache_bin_alloc_easy(tbin, &amp;tcache_success);</span></span><br><span class="line"><span class="string">                                  |  \ - ret = *(bin-&gt;avail - bin-&gt;ncached); bin-&gt;ncached--;</span></span><br><span class="line"><span class="string">                         | &lt;==    | - &lt;bins_small 已经初始化&gt; return ret</span></span><br><span class="line"><span class="string">                         |        | - &lt;bins_small 未初始化&gt;</span></span><br><span class="line"><span class="string">                                  | - &lt; Y &gt; - arena = arena_choose(tsd, arena) # &quot;</span>arena为NULL时, 为tcache绑定arena<span class="string">&quot;</span></span><br><span class="line"><span class="string">                                  | - ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,</span></span><br><span class="line"><span class="string">		    													bin, binind, &amp;tcache_hard_success)</span></span><br><span class="line"><span class="string">                                  | *\ - arena_tcache_fill_small(tsdn, arena, tcache, tbin, binind, </span></span><br><span class="line"><span class="string">	    									config_prof ? tcache-&gt;prof_accumbytes : 0) #填充bins_small[ind]</span></span><br><span class="line"><span class="string">                                     | - ret = cache_bin_alloc_easy(tbin, tcache_success) #tbin = bins_small[ind]</span></span><br><span class="line"><span class="string">                                     |  \ - ret = *(bin-&gt;avail - bin-&gt;ncached); bin-&gt;ncached--;</span></span><br><span class="line"><span class="string">                         | &lt;==       | - return ret</span></span><br><span class="line"><span class="string">       |  |     |     |  |if| - &lt; usize &gt; SMALL_MAXCLASS &amp;&amp; alignment &lt;= CACHELINE &gt;  # &quot;</span>large malloc<span class="string">&quot;</span></span><br><span class="line"><span class="string">                                - large_malloc(tsdn, arena, usize, zero) # zero = true</span></span><br><span class="line"><span class="string">                            |  \ - arena = arena_choose(tsdn_tsd(tsdn), arena) #64位</span></span><br><span class="line"><span class="string">                               | - extent = arena_extent_alloc_large(tsdn, arena, usize, alignment, &amp;is_zeroed) #is_zeroed = true</span></span><br><span class="line"><span class="string">       |  |     |              |*f\ - extent_t *extent = extents_alloc(tsdn, arena, &amp;extent_hooks,</span></span><br><span class="line"><span class="string">	    							  	&amp;arena-&gt;extents_dirty, NULL, usize, sz_large_pad, alignment, false, szind, zero, &amp;commit)</span></span><br><span class="line"><span class="string">                                  | *\ - extent_recycle(tsdn, arena, r_extent_hooks, extents,</span></span><br><span class="line"><span class="string">	    								new_addr, size, pad, alignment, slab, szind, zero, commit, false)#&quot;</span>比较复杂, 后面分析<span class="string">&quot;, extents</span></span><br><span class="line"><span class="string">                                     |if\ - &lt;extent &quot;</span>分配出来了<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">                         |   &lt;==        | - return extent</span></span><br><span class="line"><span class="string">       |  |                    |*f| - &lt;extent&quot;</span>没分配出来<span class="string">&quot;&gt;- extents_alloc(tsdn, arena, &amp;extent_hooks, </span></span><br><span class="line"><span class="string">		    						  	&amp;arena-&gt;extents_muzzy, NULL, usize, sz_large_pad, alignment, false, szind, zero, &amp;commit)</span></span><br><span class="line"><span class="string">                                  |if\ - &lt;extent &quot;</span>分配出来了<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">                         |   &lt;==        | - return extent </span></span><br><span class="line"><span class="string">       |  |                    |*f| - &lt;extent&quot;</span>还没分配出来<span class="string">&quot;&gt; - </span></span><br><span class="line"><span class="string">                                    - size = usize + sz_large_pad</span></span><br><span class="line"><span class="string">                                  	- extent_alloc_wrapper(tsdn, arena, &amp;extent_hooks, NULL, </span></span><br><span class="line"><span class="string">		    								usize, sz_large_pad, alignment, false, szind, zero, &amp;commit);</span></span><br><span class="line"><span class="string">                                  |  \ - *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks, new_addr, size, pad, </span></span><br><span class="line"><span class="string">                                                                         alignment, slab, szind, zero, commit) </span></span><br><span class="line"><span class="string">                                     | - &lt;extent == NULL&gt; # 没从&quot;</span>arena-&gt;extents_retained<span class="string">&quot;分配出来</span></span><br><span class="line"><span class="string">                         |   &lt;==     | N\ - return extent</span></span><br><span class="line"><span class="string">                                     | Y\ - extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks, new_addr, size, pad,</span></span><br><span class="line"><span class="string">                                                                                alignment, slab, szind, zero, commit)</span></span><br><span class="line"><span class="string">                         |   &lt;==     	| - return extent</span></span><br><span class="line"><span class="string">                |     | - *tcache = tsd_tcachep_get_unsafe(tsd) # returns a pointer to the thread-local instance 参考 1.5 宏展开扩展</span></span><br><span class="line"><span class="string">       |  |     |     | - tcache_init(tsd, tcache, avail_array)</span></span><br><span class="line"><span class="string">                      |  \ - ticker_init(&amp;tcache-&gt;gc_ticker, TCACHE_GC_INCR)</span></span><br><span class="line"><span class="string">                         | - for &lt;; i &lt; NBINS; i++ &gt;</span></span><br><span class="line"><span class="string">                         |  \ - tcache-&gt;lg_fill_div[i] = 1 #&quot;</span>填充除 /<span class="number">2</span>^lg_fill_div<span class="string">&quot;</span></span><br><span class="line"><span class="string">                            | - tcache_small_bin_get(tcache, i)-&gt;avail = ((uintptr_t)avail_stack + (uintptr_t)stack_offset)</span></span><br><span class="line"><span class="string">                            |  \ - &amp;tcache-&gt;bins_small[i] = avail_stack + stack_offset</span></span><br><span class="line"><span class="string">                         | - for &lt;i = NBINS; i &lt; nhbins; i++&gt; # </span></span><br><span class="line"><span class="string">                         |  \ - stack_offset += tcache_bin_info[i].ncached_max * sizeof(void *)</span></span><br><span class="line"><span class="string">                            | - tcache_large_bin_get(tcache, i)-&gt;avail = ((uintptr_t)avail_stack + (uintptr_t)stack_offset)</span></span><br><span class="line"><span class="string">                            |  \ - &amp;tcache-&gt;bins_large[i - NBINS] = avail_stack + stack_offset</span></span><br><span class="line"><span class="string">    | *| - imalloc_body(sopts, dopts, tsd) # &quot;</span>开始分配, 上面主要是填充avail_stack的过程<span class="string">&quot;</span></span><br><span class="line"><span class="string">       |  \ - compute_size_with_overflow(sopts-&gt;may_overflow, dopts, &amp;size) #计算size</span></span><br><span class="line"><span class="string">          |  \ - &lt;may_overflow?&gt;</span></span><br><span class="line"><span class="string">             | N\ - *size = dopts-&gt;item_size # &quot;</span>dopts-&gt;num_items = <span class="number">1</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">             | Y\ - *size = dopts-&gt;item_size * dopts-&gt;num_items</span></span><br><span class="line"><span class="string">       |  | - &lt; dopts-&gt;alignment == 0 &gt; # &quot;</span>不用对齐<span class="string">&quot;</span></span><br><span class="line"><span class="string">          | Y\ - ind = sz_size2index(size) #不用对齐时使用ind分配</span></span><br><span class="line"><span class="string">          | N\ - usize = sz_sa2u(size, dopts-&gt;alignment) #对齐的情况下按usize分配</span></span><br><span class="line"><span class="string">       	  | - allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize, ind)</span></span><br><span class="line"><span class="string">          |  \ - tcache = tcaches_get(tsd, dopts-&gt;tcache_ind)</span></span><br><span class="line"><span class="string">             |  \ - &amp;tcaches[ind]-&gt;tcache</span></span><br><span class="line"><span class="string">             | - arena = arena_get(tsd_tsdn(tsd), dopts-&gt;arena_ind, true)</span></span><br><span class="line"><span class="string">             |  \ - ret = (arena_t *)atomic_load_p(&amp;arenas[ind], ATOMIC_ACQUIRE)</span></span><br><span class="line"><span class="string">             | - iallocztm(tsd_tsdn(tsd), size, ind, dopts-&gt;zero, tcache, false, arena, sopts-&gt;slow)</span></span><br><span class="line"><span class="string">                                                                        #&quot;</span>sopts-&gt;slow是<span class="literal">true</span>的时候, tcache有可能是null<span class="string">&quot; // TODO</span></span><br><span class="line"><span class="string">          |&lt;=|  \ - ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path) #&quot;</span>第二次调用, 这次的tcache一般不是空<span class="string">&quot;</span></span><br><span class="line"><span class="string">                |  \ - &lt;tcache!=NULL &amp;&amp; size&lt;SMALL_MAXCLASS&gt;</span></span><br><span class="line"><span class="string">          | &lt;==    | Y\ - tcache_alloc_small(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path)</span></span><br><span class="line"><span class="string">                   | - &lt;tcache!=NULL &amp;&amp; size &lt;= tcache_maxclass&gt; # &quot;</span>tcache不为NULL 且 size &lt;= je_nhbins对应的class_size时<span class="string">&quot;</span></span><br><span class="line"><span class="string">          | &lt;==    | Y\ - tcache_alloc_large(tsdn_tsd(tsdn), arena, tcache, size, ind, zero, slow_path)</span></span><br><span class="line"><span class="string">                      |  \ - bin = tcache_large_bin_get(tcache, binind)</span></span><br><span class="line"><span class="string">                         |  \ - bin = &amp;tcache-&gt;bins_large[binind - NBINS]</span></span><br><span class="line"><span class="string">                         | - ret = cache_bin_alloc_easy(bin, &amp;tcache_success)</span></span><br><span class="line"><span class="string">                         |  \ - ret = *(bin-&gt;avail - bin-&gt;ncached)</span></span><br><span class="line"><span class="string">						 | - &lt;tcache_success?&gt; #&quot;</span>从tcache拿到可用的内存了吗?<span class="string">&quot;</span></span><br><span class="line"><span class="string">                   | &lt;== | Y\- return ret</span></span><br><span class="line"><span class="string">                         | N\- ret = large_malloc(tsd_tsdn(tsd), arena, sz_s2u(size), zero)</span></span><br><span class="line"><span class="string">                   | &lt;==    | - return ret</span></span><br><span class="line"><span class="string">          | &lt;==    | - arena_malloc_hard(tsdn, arena, size, ind, zero) #&quot;</span>&gt; je_nhbins对应的class_size时不走tcache, 走arena的分配 </span><br><span class="line">                                                || 没有tcache的情况下, 也走arena的分配<span class="string">&quot;        </span></span><br><span class="line"><span class="string">                   |  \ - arena = arena_choose(tsdn_tsd(tsdn), arena);</span></span><br><span class="line"><span class="string">          | &lt;==       | - &lt;size &lt;= SMALL_MAXCLASS&gt; - arena_malloc_small(tsdn, arena, ind, zero)</span></span><br><span class="line"><span class="string">                   |&lt;=|  \ - return ((uintptr_t)extent_addr_get(slab) + (uintptr_t)(bin_info-&gt;reg_size * regind)) # &quot;</span>small 要寻bitmap<span class="string">&quot;</span></span><br><span class="line"><span class="string">          | &lt;==       | - &lt;size &gt; SMALL_MAXCLASS &gt; - large_malloc(tsdn, arena, sz_index2size(ind), zero)</span></span><br><span class="line"><span class="string">                      |  \ - extent = arena_extent_alloc_large(tsdn, arena, usize, alignment, &amp;is_zeroed)</span></span><br><span class="line"><span class="string">                   |&lt;==  | - return extent_addr_get(extent) #&quot;</span>large 只需要找e_addr返回即可<span class="string">&quot;</span></span><br><span class="line"><span class="string">    |     | - *dopts-&gt;result = allocation;                  </span></span><br></pre></td></tr></table></figure>

<p>Small类型内存分配分为两类，一类是<code>arena_malloc_hard</code>，另一类是<code>arena_malloc_small</code>。</p>
<p>这两类的区别是<code>tcache_alloc_small</code>申请的内存有和线程进行绑定，即申请的内存数据会设置为线程私有数据(tsd)，而<code>arena_malloc_hard</code>申请的内存没有和线程绑定。</p>
<p>在<code>imalloc_body</code>流程中, 会获取tcache <code>tcache = tcaches_get(tsd, dopts-&gt;tcache_ind)</code>, 而在初始化或者slow malloc时, tcache是NULL, 就需要从<code>arena-&gt;bins</code>中获取.</p>
<ol>
<li><p>tcache中获取,  先从<code>tcache-&gt;bins_small[binind]</code>取出cache_bin的信息, 通过<code>cache_bin_alloc_easy</code>函数取出<code>*(bin-&gt;avail - bin-&gt;ncached)</code> 返回出去, 这个即为对应的可用的region, 此处<code>bin-&gt;ncached</code>保存的可用的缓存数目, 如果bin-&gt;ncached为0, 则需要重新装填bins_small结构, [见1.7 tsd-&gt;tcache-&gt;bins_small 填充流程](#1.7 tsd-&gt;tcache-&gt;bins_small 填充流程), 装填完后, 再次通过<code>cache_bin_alloc_easy</code>函数取出<code>*(bin-&gt;avail - bin-&gt;ncached)</code> 返回出region</p>
</li>
<li><p>不从tcache中获取, 需要加锁, 因为arena是全局的变量, 不是线程特有的. 通过<code>arena_malloc_hard</code>函数, 从<code>arena-&gt;bins[ind]</code>取出bin, 此处的bin不是tcache的<a href="#cache_bin">cache_bin</a>结构, 而是开篇介绍的<a href="#bin">bin</a>结构, 其中<code>bin-&gt;slabcur</code>是当前bin使用的extent结构, 需要从其位图中找出可用的region. 如果<code>slabcur</code>是空的, 或者当前的slab(extent)没有可用的region, 则需要调用<code>arena_bin_nonfull_slab_get</code>函数获取, 这里和[1.6 tsd-&gt;tcache-&gt;bins_small 填充流程](#1.6 tsd-&gt;tcache-&gt;bins_small 填充流程)流程是重复的, 需要理清tache-&gt;bins_small[ind]和arena-&gt;bins[ind]之间的关系.</p>
<blockquote>
<p>在装填过程中, 可以看出 arena-&gt;bins[ind] 维护的 <a href="#bin">bin</a> 是一个全局的大缓存, 而tache的<a href="#cache_bin">cache_bin</a>是一个和tsd绑定的小缓存, 当小缓存ncached变成0时, 即没有可用的region后, 需要装填cache_bin. 优先级是先从大缓存中装入(先找slabcur, slabcur满了, 再找slab_nofull出堆, 找free的region, 同时更新slabcur), 如果大缓存没有了, 就需要从extents_dirty(muzzy|retained)(heap)中回收, 回收也没有的话, 就需要mmap然后新建slab, 再分给小缓存(也包括更新大缓存, 和把extent注册到rtree中)</p>
</blockquote>
</li>
</ol>
<p><img src="/images/20201204103839.svg" alt="jemalloc.drawio"></p>
<h3 id="1-6-tsd-tcache-bins-small-填充流程"><a href="#1-6-tsd-tcache-bins-small-填充流程" class="headerlink" title="1.6 tsd-&gt;tcache-&gt;bins_small 填充流程"></a>1.6 tsd-&gt;tcache-&gt;bins_small 填充流程</h3><blockquote>
<p>“<code>lg_fill_div</code>用作tcache refill时作为除数. 当tcache耗尽时, 会请求arena bins_small进行refill. 但refill不会一次性灌满tcache, 而是依照其最大容量缩小2^lg_fill_div的倍数. 该数值同low_water一样是动态的, 两者互相配合确保tcache处于一个合理的充满度”</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">--&gt; arena_tcache_fill_small<span class="params">(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache, cache_bin_t *tbin, szind_t binind, uint64_t prof_accumbytes)</span></span><br><span class="line">  | - bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">  |for &lt;i = 0, nfill = <span class="params">(tcache_bin_info[binind].ncached_max &gt;&gt; tcache-&gt;lg_fill_div[binind])</span>; i &lt; nfill; i+&gt; -</span><br><span class="line">     |if\ - &lt; slab = bin-&gt;slabcur) != NULL &amp;&amp; extent_nfree_get<span class="params">(slab)</span> &gt; 0&gt; - #&quot;当前使用中的 slab 通过 bin-&gt;slabcur 分配&quot;</span><br><span class="line">        |  \ - <span class="params">(bin-&gt;slabcur-&gt;e_bits &amp; EXTENT_BITS_NFREE_MASK)</span>&gt;&gt;EXTENT_BITS_NFREE_SHIFT &gt; 0                                            </span><br><span class="line">        | - ptr = arena_slab_reg_alloc<span class="params">(slab, &amp;bin_infos[binind])</span></span><br><span class="line">        |  \ - arena_slab_data_t *slab_data = ent_slab_data_get<span class="params">(slab)</span></span><br><span class="line">           | - regind = bitmap_sfu<span class="params">(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info)</span> #&quot;计算可用region的在slab_data bitmap中的index&quot;</span><br><span class="line">           | - ret = <span class="params">(void *)</span><span class="params">((uintptr_t)</span>extent_addr_get<span class="params">(slab)</span> + <span class="params">(uintptr_t)</span><span class="params">(bin_info-&gt;reg_size * regind)</span>); #&quot;返回可用region的地址&quot;</span><br><span class="line">           | - extent_nfree_dec<span class="params">(slab)</span> #&quot;extent中可用的region数减去EXTENT_BITS_NFREE_SHIFT 数目, 表示这些region装填给了 tcache&quot;         </span><br><span class="line">           | - return ret</span><br><span class="line">     |el| - &lt; slab = bin-&gt;slabcur) != NULL &amp;&amp; extent_nfree_get<span class="params">(slab)</span> &gt; 0&gt; #&quot;即bin-&gt;slabcur为NULL &amp;&amp; bin-&gt;slabcur-&gt;e_bits标识NFREE时&quot;</span><br><span class="line">        |  \ - ptr = arena_bin_malloc_hard<span class="params">(tsdn, arena, bin, binind)</span>   # Re-fill bin-&gt;slabcur, then call arena_slab_reg_alloc<span class="params">()</span></span><br><span class="line">           |  \ - &lt;!arena_is_auto<span class="params">(arena)</span> &amp;&amp; bin-&gt;slabcur != NULL&gt; -</span><br><span class="line">              | Y\ - arena_bin_slabs_full_insert<span class="params">(arena, bin, bin-&gt;slabcur)</span>;  </span><br><span class="line">                 | - bin-&gt;slabcur = NULL;</span><br><span class="line">           |  | - slab = arena_bin_nonfull_slab_get<span class="params">(tsdn, arena, bin, binind)</span>  # 1.<span class="number">6.1</span> arena_bin_nonfull_slab_get过程  </span><br><span class="line">              |  \ - slab = arena_bin_slabs_nonfull_tryget(bin)  #<span class="string">&quot;Look for a usable slab.&quot;</span></span><br><span class="line">                 |  \ - extent_t *slab = extent_heap_remove_first(&amp;bin-&gt;slabs_nonfull) #nonfull 出堆 <span class="string">&quot;从slabs_nonfull中获取&quot;</span></span><br><span class="line">                 | - &lt;slab != NULL&gt;</span><br><span class="line">     |        |&lt;-| Y\ - return slab</span><br><span class="line">                 | N\ - bin_info = &amp;bin_infos[binind]</span><br><span class="line">           |  |  | - slab = arena_slab_alloc(tsdn, arena, binind, bin_info) #Allocate a new slab</span><br><span class="line">                 |  \ - szind = sz_size2index(bin_info-&gt;reg_size)</span><br><span class="line">           |        | - *slab = extents_alloc(tsdn, arena, &amp;extent_hooks, #从<span class="string">&quot;extents_dirty&quot;</span>中分配</span><br><span class="line">                                              &amp;arena-&gt;extents_dirty, NULL, bin_info-&gt;slab_size, <span class="number">0</span>, PAGE, <span class="literal">true</span>, binind, &amp;zero, &amp;commit)</span><br><span class="line">                    |  \ - extent_recycle(tsdn, arena, r_extent_hooks, extents, new_addr, size, </span><br><span class="line">                                          pad, alignment, slab, szind, zero, commit, <span class="literal">false</span>) # <span class="string">&quot;后面进行分析&quot;</span></span><br><span class="line">                       | - &lt;extent <span class="string">&quot;分配出来了&quot;</span>&gt;</span><br><span class="line">                       | Y\ - extent_dumpable_get(extent) #</span><br><span class="line">           |  |     |  &lt;--| - return extent #end <span class="string">&quot;arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)&quot;</span></span><br><span class="line">                    | - &lt; slab == NULL &gt; </span><br><span class="line">           |        | Y\ - slab = extents_alloc(tsdn, arena, &amp;extent_hooks, ##<span class="string">&quot; extents_dirty 中 没分配出来, 从extents_muzzy&quot;</span> 中分配</span><br><span class="line">		    					              &amp;arena-&gt;extents_muzzy, NULL, bin_info-&gt;slab_size, <span class="number">0</span>, PAGE, <span class="literal">true</span>, binind, &amp;zero, &amp;commit)</span><br><span class="line">                    | - &lt; slab == NULL &gt; - </span><br><span class="line">                    | N\ - extent_dumpable_get(extent)</span><br><span class="line">     |     |  |  	|&lt;-| - return extent #end <span class="string">&quot;arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)&quot;</span></span><br><span class="line">  |  |     |  |     | Y\ - slab = arena_slab_alloc_hard(tsdn, arena, &amp;extent_hooks, bin_info, szind);  #<span class="string">&quot; extents_muzzy 中 没分配出来&quot;</span></span><br><span class="line">                       | - slab = extent_alloc_wrapper(tsdn, arena, r_extent_hooks, NULL,</span><br><span class="line">	    						         			  bin_info-&gt;slab_size, <span class="number">0</span>, PAGE, <span class="literal">true</span>, szind, &amp;zero, &amp;commit)</span><br><span class="line">                       |  \ - *extent = extent_alloc_retained(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    						new_addr, size, pad, alignment, slab, szind, zero, commit)</span><br><span class="line">                          |  \ - *extent = extent_recycle(tsdn, arena, r_extent_hooks, #从<span class="string">&quot;extents_retained&quot;</span> 中分配</span><br><span class="line">	    						&amp;arena-&gt;extents_retained, new_addr, size, pad, alignment, slab, szind, zero, commit, <span class="literal">true</span>)</span><br><span class="line">                          | - &lt; slab == NULL &gt; - #<span class="string">&quot;extent_alloc_retained 没分配出来&quot;</span></span><br><span class="line">                          | N\ - extent_dumpable_get(extent)</span><br><span class="line">     |     |   |    |  &lt;==   | - return extent #end <span class="string">&quot;arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)&quot;</span></span><br><span class="line">  |  |     |   |          | Y\ - extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,</span><br><span class="line">		    											   new_addr, size, pad, alignment, slab, szind, zero, commit)</span><br><span class="line">	 |	   |			     | - *extent = extent_alloc(tsdn, arena) # <span class="string">&quot;参考 1.7 extent_alloc流程, 这里只是新建extent base的元数据&quot;</span></span><br><span class="line">                             | - &lt;*r_extent_hooks == &amp;extent_hooks_default&gt; -</span><br><span class="line">                             | Y\ - addr = extent_alloc_default_impl(tsdn, arena, new_addr,</span><br><span class="line">                                                              esize, alignment, zero, commit)  #<span class="string">&quot;Call directly to propagate tsdn&quot;</span></span><br><span class="line">                                | - addr = extent_alloc_default_impl(tsdn, arena, NULL, alloc_size, PAGE, &amp;zeroed, &amp;committed)</span><br><span class="line">                          |  \ - extent_alloc_core(tsdn, arena, new_addr, size, alignment, zero, #(new_addr=NULL)</span><br><span class="line">	    											commit, (dss_prec_t)atomic_load_u(&amp;arena-&gt;dss_prec, ATOMIC_RELAXED))</span><br><span class="line">                             | - addr = extent_alloc_mmap(new_addr, size, alignment, zero, commit)</span><br><span class="line">                                |  \ - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, PAGE), commit)</span><br><span class="line">                             | \ - os_pages_map(addr, size, os_page, commit)</span><br><span class="line">                                   | - addr = mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -<span class="number">1</span>, <span class="number">0</span>) </span><br><span class="line">                                                          #<span class="string">&quot;addr 0 系统自动分配地址, 分配实际的地址, 挂到extent base元数据的e_addr下&quot;</span></span><br><span class="line">                                   | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, <span class="string">&quot;libc_malloc&quot;</span>)</span><br><span class="line">                             |  |  | - return addr</span><br><span class="line">                             | - extent_init(extent, arena, addr, esize, slab, szind, arena_extent_sn_next(arena), </span><br><span class="line">                                                extent_state_active, *zero, *commit, <span class="literal">true</span>);</span><br><span class="line">                             |  \ - extent_addr_set(extent, addr); #<span class="string">&quot;这里应该是真正给extent设置region内存地址的地方&quot;</span></span><br><span class="line">                                | - extent_sn_set(extent, sn);</span><br><span class="line">                                | - ...</span><br><span class="line">     |     |                 | - extent_register(tsdn, extent)</span><br><span class="line">                             |  \ - *rtree_ctx = tsdn_rtree_ctx(tsdn, &amp;rtree_ctx_fallback)</span><br><span class="line">                                |  \ - *rtree_ctx = &amp;tsdn-&gt;tsd-&gt;use_a_getter_or_setter_instead_rtree_ctx</span><br><span class="line">                             |  \ - &lt; extent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, extent, <span class="literal">false</span>, <span class="literal">true</span>, &amp;elm_a, &amp;elm_b) ?&gt;</span><br><span class="line">                                | Y\ - # <span class="string">&quot;rtree中找到了这个extent&quot;</span></span><br><span class="line">                                   | - return <span class="literal">true</span># 不用再注册, 因为已经在rtree中了</span><br><span class="line">                                | N\ - # <span class="string">&quot;rtree中没找到, 需要注册&quot;</span></span><br><span class="line">                                   | - extent_rtree_write_acquired(tsdn, elm_a, elm_b, extent, szind, slab)</span><br><span class="line">                                   |  \ - rtree_leaf_elm_write(tsdn, &amp;extents_rtree, elm_a, extent, szind, slab)</span><br><span class="line">                                      | - rtree_leaf_elm_write(tsdn, &amp;extents_rtree, elm_b, extent, szind, slab)                         </span><br><span class="line">                                   | - bool slab = extent_slab_get(extent) </span><br><span class="line">                                   | - &lt;slab?&gt;</span><br><span class="line">                                   | Y\ - #小内存 small_class</span><br><span class="line">                                      | - extent_interior_register(tsdn, rtree_ctx, extent, szind) </span><br><span class="line">                                      |  \ - for (size_t i = <span class="number">1</span>; i &lt; (extent_size_get(extent) &gt;&gt; LG_PAGE) - <span class="number">1</span>; i++)</span><br><span class="line">                                                        # <span class="string">&quot;key&quot;</span> = (uintptr_t)extent_base_get(extent) + (uintptr_t)(i &lt;&lt; LG_PAGE)</span><br><span class="line">                                         |  \ - &lt;<span class="string">&quot;elm&quot;</span> = rtree_leaf_elm_lookup(tsdn, rtree, rtree_ctx, <span class="string">&quot;key&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>) FOUND?&gt;</span><br><span class="line">                                            | Y\ - rtree_leaf_elm_write(tsdn, rtree, elm, extent, szind, slab);</span><br><span class="line">                             | - return extent</span><br><span class="line">  |  |     |        | - *slab_data = extent_slab_data_get(slab);</span><br><span class="line">                    | - extent_nfree_set(slab, bin_info-&gt;nregs);</span><br><span class="line">                    |  \ - extent-&gt;e_bits = (extent-&gt;e_bits &amp; ~EXTENT_BITS_NFREE_MASK) | (nfree &lt;&lt; EXTENT_BITS_NFREE_SHIFT)</span><br><span class="line">                    | - bitmap_init(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, <span class="literal">false</span>)                                  </span><br><span class="line">           |  | &lt;-- | - return slab; # <span class="keyword">end</span> <span class="string">&quot; slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)&quot;</span></span><br><span class="line">              | - #end <span class="string">&quot;slab = arena_bin_nonfull_slab_get(tsdn, arena, bin, binind)&quot;</span></span><br><span class="line">              | - bin-&gt;slabcur = slab; #<span class="string">&quot;更新大缓存&quot;</span></span><br><span class="line">     | - *(tbin-&gt;avail - nfill + i) = ptr;</span><br><span class="line">  | - tbin-&gt;ncached = i;  #<span class="string">&quot;for end&quot;</span></span><br></pre></td></tr></table></figure>

<p>首先从 <code>tsd-&gt;tcache-&gt;bins_small[binind]</code> 中获取对应 <code>size_class</code> 的内存，有的话将内存直接返回给用户，如果 <code>bins_small[binind]</code> 中没有的话，需要通过 <code>slab(extent)</code> 对 <code>tsd-&gt;tcache-&gt;bins_small[binind]</code> 进行填充，一次填充多个以备后续分配，填充方式如下（当前步骤无法成功则进行下一步）：</p>
<ol>
<li>通过 <code>bin-&gt;slabcur</code> 分配</li>
<li>从 <code>bin-&gt;slabs_nonfull</code> 中获取可使用的 <code>extent</code></li>
<li>从 <code>arena-&gt;extents_dirty</code> 中回收 <code>extent</code>，回收方式为 *<strong>first-fit*<strong>，即满足大小要求且</strong>序列号最小地址最低（最旧）</strong>的 <code>extent</code>，在 <code>arena-&gt;extents_dirty-&gt;bitmap</code> 中找到满足大小要求并且第一个非空 heap 的索引 <code>i</code>，然后从 <code>extents-&gt;heaps[i]</code> 中获取第一个 <code>extent</code>。由于 <code>extent</code> 可能较大，为了防止产生内存碎片，需要对 <code>extent</code> 进行分裂（伙伴算法），然后将分裂后不使用的 <code>extent</code> 放回<code>extents_dirty</code>中</li>
<li>从 <code>arena-&gt;extents_muzzy</code> 中回收 <code>extent</code>，回收方式为 *<strong>first-fit*<strong>，即满足大小要求且</strong>序列号最小地址最低（最旧）</strong>的 <code>extent</code>，遍历每个满足大小要求并且非空的 <code>arena-&gt;extents_dirty-&gt;bitmap</code>，获取其对应 <code>extents-&gt;heaps</code> 中第一个 <code>extent</code>，然后进行比较，找到最旧的 <code>extent</code>，之后仍然需要分裂</li>
<li>从 <code>arena-&gt;extents_retained</code> 中回收 <code>extent</code>，回收方式与 <code>extents_muzzy</code> 相同</li>
<li>尝试通过 <code>mmap</code> 向内核获取所需的 <code>extent</code> 内存，并且在 <code>rtree</code> 中注册新 <code>extent</code> 的信息</li>
<li>再次尝试从 <code>bin-&gt;slabs_nonfull</code> 中获取可使用的 <code>extent</code></li>
</ol>
<p>简单来说，这个流程是这样的，<code>cache_bin -&gt; slab -&gt; slabs_nonfull -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernel</code></p>
<h3 id="1-7-extent-alloc流程"><a href="#1-7-extent-alloc流程" class="headerlink" title="1.7 extent_alloc流程"></a>1.7 extent_alloc流程</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--&gt; extent_t * extent_alloc<span class="params">(tsdn_t *tsdn, arena_t *arena)</span></span><br><span class="line">|  \ - *extent = extent_avail_first<span class="params">(&amp;arena-&gt;extent_avail)</span> #&quot;参考1.<span class="number">5</span> 宏展开<span class="string">&quot;</span></span><br><span class="line"><span class="string">   | - &lt; extent == NULL &gt;</span></span><br><span class="line"><span class="string">   | N\ - extent_avail_remove(&amp;arena-&gt;extent_avail, extent) # &quot;</span>先从extent_avail 中获取<span class="string">&quot;</span></span><br><span class="line"><span class="string">   | Y\ - return base_alloc_extent(tsdn, arena-&gt;base)</span></span><br><span class="line"><span class="string">      | - *extent = base_alloc_impl(tsdn, arena-&gt;base, sizeof(extent_t)</span></span><br><span class="line"><span class="string">      |  \ - usize = ALIGNMENT_CEILING(size, alignment)</span></span><br><span class="line"><span class="string">         | - asize = usize + alignment - QUANTUM;</span></span><br><span class="line"><span class="string">         | - for (szind_t i = sz_size2index(asize); i &lt; NSIZES; i++)</span></span><br><span class="line"><span class="string">         |  \ - extent = extent_heap_remove_first(&amp;base-&gt;avail[i])</span></span><br><span class="line"><span class="string">            | - &lt; extent != NULL &gt;</span></span><br><span class="line"><span class="string">        &lt;==*|  \ - break;</span></span><br><span class="line"><span class="string">      |  | - &lt; extent == NULL &gt; # &quot;</span>上面遍历完, 仍没找到有效的extent<span class="string">&quot;</span></span><br><span class="line"><span class="string">         | Y\ - extent = base_extent_alloc(tsdn, base, usize, alignment)</span></span><br><span class="line"><span class="string">            |  \ - *block = base_block_alloc(tsdn, base, extent_hooks, base_ind_get(base), </span></span><br><span class="line"><span class="string">                                             &amp;base-&gt;pind_last, &amp;base-&gt;extent_sn_next, size, alignment)</span></span><br><span class="line"><span class="string">               |  \ - *block = base_map(tsdn, extent_hooks, ind, block_size)</span></span><br><span class="line"><span class="string">                  |  \ - addr = extent_alloc_mmap(NULL, size, alignment, &amp;zero, &amp;commit) </span></span><br><span class="line"><span class="string">                     | - pages_map(new_addr, size, ALIGNMENT_CEILING(alignment, 1&lt;&lt; 12), commit)</span></span><br><span class="line"><span class="string">                     |  \ - mmap(addr, size, PROT_READ | PROT_WRITE, mmap_flags, -1, 0)</span></span><br><span class="line"><span class="string">                        | - prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ret, size, &quot;</span>libc_malloc<span class="string">&quot;);</span></span><br><span class="line"><span class="string">                     |  | - return addr</span></span><br><span class="line"><span class="string">               |  | - base_extent_init(extent_sn_next, &amp;block-&gt;extent, *(block + header_size), block_size - header_size)</span></span><br><span class="line"><span class="string">                  |  \ - sn = *extent_sn_next; #&quot;</span>extent 还有sn号<span class="string">&quot;</span></span><br><span class="line"><span class="string">                     | - extent_binit(extent, addr, size, sn)</span></span><br><span class="line"><span class="string">                     |  \ - extent_arena_set(extent, NULL)</span></span><br><span class="line"><span class="string">                        | - extent_addr_set(extent, addr);</span></span><br><span class="line"><span class="string">                        | - extent_bsize_set(extent, bsize);</span></span><br><span class="line"><span class="string">                        | - ... &quot;</span>设置extent e_bits 保存相关的数据结构关系<span class="string">&quot;</span></span><br><span class="line"><span class="string">               | - block-&gt;next = base-&gt;blocks; base-&gt;blocks = block; # &quot;</span>挂入arena-&gt;base-&gt;blocks链表<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>在small和large分配的函数中, 牵扯到的比较重要的函数就是这个<code>extent_recycle</code>了</p>
<p>下面对其重点分析一下</p>
<h4 id="extent-recycle-回收函数分析"><a href="#extent-recycle-回收函数分析" class="headerlink" title="extent_recycle 回收函数分析"></a><code>extent_recycle</code> 回收函数分析</h4><blockquote>
<p>Tries to satisfy the given allocation request by reusing one of the extents  in the given extents_t.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_recycle</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena, <span class="type">extent_hooks_t</span> **r_extent_hooks,</span></span><br><span class="line"><span class="params">    <span class="type">extents_t</span> *extents, <span class="type">void</span> *new_addr, <span class="type">size_t</span> size, <span class="type">size_t</span> pad,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> alignment, <span class="type">bool</span> slab, <span class="type">szind_t</span> szind, <span class="type">bool</span> *zero, <span class="type">bool</span> *commit,</span></span><br><span class="line"><span class="params">    <span class="type">bool</span> growing_retained)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">rtree_ctx_t</span> rtree_ctx_fallback;</span><br><span class="line">        <span class="comment">// 取tsd结构体的 use_a_getter_or_setter_instead_rtree_ctx成员</span></span><br><span class="line">        tsd_rtree_ctx(<span class="type">tsd_t</span> *tsd) &#123;</span><br><span class="line">            <span class="keyword">return</span> tsd_rtree_ctxp_get(tsd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">rtree_ctx_t</span> *</span><br><span class="line">        <span class="title function_">tsdn_rtree_ctx</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">rtree_ctx_t</span> *fallback)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">return</span> tsd_rtree_ctx(tsdn_tsd(tsdn));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">rtree_ctx_t</span> *rtree_ctx = tsdn_rtree_ctx(tsdn, &amp;rtree_ctx_fallback);</span><br><span class="line">    <span class="comment">// 从extents中回收extent extents是从上面传入的 arena-&gt;extents_dirty | extents_muzzy | extents_retained</span></span><br><span class="line">	<span class="type">extent_t</span> *extent = extent_recycle_extract(tsdn, arena, r_extent_hooks,</span><br><span class="line">	    rtree_ctx, extents, new_addr, size, pad, alignment, slab,</span><br><span class="line">	    growing_retained);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分裂, 把多余的放回到extents中</span></span><br><span class="line">	extent = extent_recycle_split(tsdn, arena, r_extent_hooks, rtree_ctx,</span><br><span class="line">	    extents, new_addr, size, pad, alignment, slab, szind, extent,</span><br><span class="line">	    growing_retained);</span><br><span class="line">	<span class="keyword">if</span> (extent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> <span class="comment">// 正常的话, 如果能回收到extent, 其状态应该是e_bits中commited应该是置位的, 如果没置位, 则表示需要重新通过mmap分配内存, 这里os_overcommits比较迷惑</span></span><br><span class="line">	<span class="keyword">if</span> (*commit &amp;&amp; !extent_committed_get(extent)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (extent_commit_impl(tsdn, arena, r_extent_hooks, extent,</span><br><span class="line">		    <span class="number">0</span>, extent_size_get(extent), growing_retained)) &#123;</span><br><span class="line">			extent_record(tsdn, arena, r_extent_hooks, extents,</span><br><span class="line">			    extent, growing_retained);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		extent_zeroed_set(extent, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (extent_committed_get(extent)) &#123;</span><br><span class="line">		*commit = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (extent_zeroed_get(extent)) &#123;</span><br><span class="line">		*zero = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pad != <span class="number">0</span>) &#123;</span><br><span class="line">		extent_addr_randomize(tsdn, extent, alignment);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(extent_state_get(extent) == extent_state_active);</span><br><span class="line">	<span class="keyword">if</span> (slab) &#123;</span><br><span class="line">		extent_slab_set(extent, slab);</span><br><span class="line">		extent_interior_register(tsdn, rtree_ctx, extent, szind);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*zero) &#123;</span><br><span class="line">		<span class="type">void</span> *addr = extent_base_get(extent);</span><br><span class="line">		<span class="type">size_t</span> size = extent_size_get(extent);</span><br><span class="line">        <span class="comment">// 如果不是0, 一般情况下, 上面肯定设置0了, 不是0, 会进行force purge过程, 告诉kernel 可以回收这块物理页, 虚拟内存不被mmu映射的话, 就是摆设</span></span><br><span class="line">		<span class="keyword">if</span> (!extent_zeroed_get(extent)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pages_purge_forced(addr, size)) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(addr, <span class="number">0</span>, size);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (config_debug) &#123;</span><br><span class="line">			<span class="type">size_t</span> *p = (<span class="type">size_t</span> *)(<span class="type">uintptr_t</span>)addr;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size / <span class="keyword">sizeof</span>(<span class="type">size_t</span>); i++) &#123;</span><br><span class="line">				assert(p[i] == <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">--&gt; extent_recycle<span class="params">(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,</span></span><br><span class="line"><span class="params">    	extents_t *extents, void *new_addr, size_t size, size_t pad,</span></span><br><span class="line"><span class="params">    	size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit,</span></span><br><span class="line"><span class="params">    	bool growing_retained)</span> # &quot;new_addr = NULL&quot;</span><br><span class="line"> |  \ - *rtree_ctx = tsdn_rtree_ctx<span class="params">(tsdn, &amp;rtree_ctx_fallback)</span></span><br><span class="line">    |  \ - *rtree_ctx = &amp;tsdn-&gt;tsd-&gt;use_a_getter_or_setter_instead_rtree_ctx</span><br><span class="line">    | - *extent = extent_recycle_extract<span class="params">(tsdn, arena, r_extent_hooks, #<span class="string">&quot;to find &amp; remove an extent from extents that can be used...&quot;</span></span></span><br><span class="line"><span class="params">	    								rtree_ctx, extents, new_addr, size, pad, alignment, slab, growing_retained)</span></span><br><span class="line">    |  \ - &lt;new_addr == NULL&gt; - <span class="params">(new_addr = NULL)</span></span><br><span class="line">       | Y\ - extents_fit_locked<span class="params">(tsdn, arena, extents, esize, alignment)</span></span><br><span class="line">          |  \ - max_size = esize + PAGE_CEILING<span class="params">(alignment)</span> - PAGE;</span><br><span class="line">             | - *extent = extents_first_fit_locked<span class="params">(tsdn, arena, extents, max_size)</span> #&quot; Do first-fit extent selection, </span><br><span class="line">               			i.e. select the oldest/lowest extent that is large enough.<span class="string">&quot;</span></span><br><span class="line"><span class="string">             | - &lt;alignment &gt; PAGE &amp;&amp; extent == NULL&gt; - #&quot;</span>没分配成功<span class="string">&quot;</span></span><br><span class="line"><span class="string">             | Y\ - extent = extents_fit_alignment(extents, esize, max_size, alignment); #&quot;</span>再fit 一遍alignment </span><br><span class="line">               		Find an extent with size [min_size, max_size) to satisfy the alignment requirement. </span><br><span class="line">               		For each size, <span class="keyword">try</span> only the first extent in the heap.<span class="string">&quot;</span></span><br><span class="line"><span class="string">             | - return extent</span></span><br><span class="line"><span class="string">    | - extent = extent_recycle_split(tsdn, arena, r_extent_hooks, rtree_ctx, </span></span><br><span class="line"><span class="string">	    								extents, new_addr, size, pad, alignment, slab, szind, extent, growing_retained)     </span></span><br><span class="line"><span class="string">					#&quot;</span>extent_recycle_extract 后如果有多的未用的空间, 再split放回到extents中?<span class="string">&quot;</span></span><br><span class="line"><span class="string">    |  \ - extent_split_interior(tsdn, arena, r_extent_hooks, rtree_ctx, &amp;extent,</span></span><br><span class="line"><span class="string">                                 &amp;lead, &amp;trail, &amp;to_leak, &amp;to_salvage, new_addr, size, pad, alignment, slab, szind, growing_retained)</span></span><br><span class="line"><span class="string">       | - &lt; result == extent_split_interior_ok &gt; #是否split成功了</span></span><br><span class="line"><span class="string">       | Y\ - &lt; lead != NULL &gt; #切到头部了</span></span><br><span class="line"><span class="string">       	  | Y\ - extent_deactivate(tsdn, arena, extents, lead) #设置成不活跃的</span></span><br><span class="line"><span class="string">    | &lt;-- | - return extent</span></span><br><span class="line"><span class="string">	   | N\ - # split失败 &quot;</span>should have picked an extent that was large enough to fulfill our allocation request<span class="string">&quot; ...</span></span><br><span class="line"><span class="string"> |	| &lt;-- | - return NULL</span></span><br><span class="line"><span class="string">    | - &lt; *commit &amp;&amp; !extent_committed_get(extent) &gt;</span></span><br><span class="line"><span class="string">    | Y\ - extent_commit_impl(tsdn, arena, r_extent_hooks, extent, 0, extent_size_get(extent), growing_retained))</span></span><br><span class="line"><span class="string">       |  \ - (*r_extent_hooks)-&gt;commit(*r_extent_hooks, extent_base_get(extent), extent_size_get(extent), </span></span><br><span class="line"><span class="string">                                        offset, length, arena_ind_get(arena)))</span></span><br><span class="line"><span class="string">          |  \ - extent_commit_default(...)</span></span><br><span class="line"><span class="string">       | - &lt;extent_commit_impl return true?&gt; </span></span><br><span class="line"><span class="string"> | &lt;-- | Y\ - return NULL  (os_overcommits = true时返回NULL /proc/sys/vm/overcommit_memory 值为0或1时)                                 </span></span><br><span class="line"><span class="string">    | - &lt; *zero == true &gt; </span></span><br><span class="line"><span class="string">    | Y\ - &lt; extent_zeroed_get(extent) == false &gt; # &quot;</span>extent-&gt;e_bits zero位非<span class="number">0</span>时<span class="string">&quot;</span></span><br><span class="line"><span class="string">       | Y\ - pages_purge_forced(addr, size)</span></span><br><span class="line"><span class="string">          |  \ - return (madvise(addr, size, MADV_DONTNEED) != 0) # &quot;</span>一般走不到这个地方<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="je-free-流程"><a href="#je-free-流程" class="headerlink" title="je_free 流程"></a>je_free 流程</h2><p>上面大概只分析了small 分配的流程， 还需要深入调研下，留待后续进行研究。</p>
<p>先来看下 free的流程， 加深对<code>extent_recycle</code>过程的理解</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">--&gt; je_free<span class="params">(void *ptr)</span></span><br><span class="line">  |  \ - tsd_t *tsd = tsd_fetch_min<span class="params">()</span>;    </span><br><span class="line">     | - return tsd_fetch_impl<span class="params">(true, true)</span> &lt;bool init, bool minimal)&gt;;</span><br><span class="line">     |  \ - tsd_t *tsd = tsd_get<span class="params">(true)</span> #从前面的分析中，怀疑只有两个tsd</span><br><span class="line">        |  \ - wrapper = tsd_wrapper_get<span class="params">(init)</span> #wrapper结构体封装了 tsd的初始化的状态 和 tsd结构体实例</span><br><span class="line">           |  \ - tsd_wrapper_t *wrapper = <span class="params">(tsd_wrapper_t *)</span>pthread_getspecific<span class="params">(tsd_tsd)</span></span><br><span class="line">     |  &lt;==| return &amp;wrapper-&gt;val; </span><br><span class="line">  |  | - tcache = tsd_tcachep_get<span class="params">(tsd)</span> #取出tsd结构体实例的tcache成员 参考 tsd的结构</span><br><span class="line">  | *| - ifree<span class="params">(tsd, ptr, tcache, false)</span> #slow_path<span class="params">(false)</span> 现在只关注fast的场景</span><br><span class="line">     |  \ - rtree_ctx_t *rtree_ctx = tsd_rtree_ctx<span class="params">(tsd)</span></span><br><span class="line">        | - rtree_szind_slab_read<span class="params">(tsd_tsdn(tsd), &amp;extents_rtree, rtree_ctx,</span></span><br><span class="line"><span class="params">	    			(uintptr_t)</span>ptr, true, &amp;alloc_ctx.szind, &amp;alloc_ctx.slab)</span><br><span class="line">        |  \ - rtree_leaf_elm_t *elm = rtree_read(tsdn, rtree, rtree_ctx, key, dependent) #key为ptr rtree遍历查找ptr，确定其位于哪个叶子节点</span><br><span class="line">           | - uintptr_t bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm, dependent); # elm-&gt;le_bits</span><br><span class="line">           | - *r_szind = rtree_leaf_elm_bits_szind_get(bits); #(bits &gt;&gt; LG_VADDR)（<span class="number">64</span>位为<span class="number">48</span>）可以查出index</span><br><span class="line">           | - *r_slab = rtree_leaf_elm_bits_slab_get(bits) #bits &amp; (uintptr_t)<span class="number">0</span>x1 得到其是否是slab（small_class）</span><br><span class="line">           | - #查询的结果放到alloc_ctx中（*r_szind *r_slab ）</span><br><span class="line">  |     | - idalloctm(tsd_tsdn(tsd), ptr, tcache, &amp;alloc_ctx, <span class="literal">false</span>, <span class="literal">false</span>) </span><br><span class="line">        |  \ - arena_dalloc(tsdn, ptr, tcache, alloc_ctx, slow_path)</span><br><span class="line">           | - &lt; tcache==NULL? &gt;</span><br><span class="line">  |        | Y\ - return arena_dalloc_no_tcache(tsdn, ptr) #<span class="string">&quot;没有tcache的情况，一般走不到这&quot;</span></span><br><span class="line">  |        | N\ - szind = alloc_ctx-&gt;szind;</span><br><span class="line">              | - slab = alloc_ctx-&gt;slab;</span><br><span class="line">              | - &lt; slab ?&gt;</span><br><span class="line">  |  | &lt;==    | Y\ - return arena_dalloc_small(tsdn, ptr) #<span class="string">&quot;走small的释放&quot;</span></span><br><span class="line">                 |  \ - extent_t *extent = iealloc(tsdn, ptr)</span><br><span class="line">                    |  \ - rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &amp;rtree_ctx_fallback)</span><br><span class="line">                       | - return rtree_extent_read(tsdn, &amp;extents_rtree, rtree_ctx, (uintptr_t)ptr, <span class="literal">true</span>)</span><br><span class="line">                       |  \ - rtree_leaf_elm_t *elm = rtree_read(tsdn, rtree, rtree_ctx, key, dependent) #ptr为key, 找出叶子节点</span><br><span class="line">                          | - return rtree_leaf_elm_extent_read(tsdn, rtree, elm, dependent)   #通过叶子节点找到对应的extent指针</span><br><span class="line">                          |  \ - bits = rtree_leaf_elm_bits_read(tsdn, rtree, elm, dependent)</span><br><span class="line">                       | &lt;== | - return rtree_leaf_elm_bits_extent_get(bits)  # 通过elm-&gt;le_bits 移位和位运算获得extent的指针               </span><br><span class="line">                    | - arena_t *arena = extent_arena_get(extent)</span><br><span class="line">                    |  \ - arena_ind = (unsigned)((extent-&gt;e_bits &amp; EXTENT_BITS_ARENA_MASK) &gt;&gt; EXTENT_BITS_ARENA_SHIFT) </span><br><span class="line">                                           #<span class="string">&quot;entent-&gt;e_bits 移位+位运算 得到arena ind&quot;</span></span><br><span class="line">                       | - return &amp;arenas[arena_ind] #arenas ind 取出arena</span><br><span class="line">                   *| - arena_dalloc_bin(tsdn, arena, extent, ptr)</span><br><span class="line">                    |  \ - binind = extent_szind_get(extent)</span><br><span class="line">                       |  \ - szind = (szind_t)((extent-&gt;e_bits &amp; EXTENT_BITS_SZIND_MASK) &gt;&gt; EXTENT_BITS_SZIND_SHIFT)</span><br><span class="line">                       | - bin_t *bin = &amp;arena-&gt;bins[binind]; #<span class="string">&quot;arena-&gt;bins[ind]取出bin&quot;</span></span><br><span class="line">                      *| - arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, <span class="literal">false</span>)</span><br><span class="line">                       |  \ - *slab_data = extent_slab_data_get(slab)</span><br><span class="line">                          | - binind = extent_szind_get(slab)</span><br><span class="line">                          | - *bin_info = &amp;bin_infos[binind]</span><br><span class="line">                          | - arena_slab_reg_dalloc(slab, slab_data, ptr)</span><br><span class="line">                          |  \ - regind = arena_slab_regind(slab, binind, ptr) #<span class="string">&quot;计算ptr的region id&quot;</span></span><br><span class="line">                             | - bitmap_unset(slab_data-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind) #重设该region在slab_data bitmap的使用标记</span><br><span class="line">                             | - extent_nfree_inc(slab) #<span class="string">&quot;entent 记录free的region数+1&quot;</span></span><br><span class="line">                          | - nfree = extent_nfree_get(slab) #<span class="string">&quot;获得free的region数&quot;</span></span><br><span class="line">                         *| - &lt; nfree == bin_info-&gt;nregs &gt; #<span class="string">&quot;该extent 变成了所有 region全是未使用的状态?&quot;</span></span><br><span class="line">                         *| Y\ - arena_dissociate_bin_slab(arena, slab, bin)</span><br><span class="line">                             | - &lt; slab == bin-&gt;slabcur &gt;</span><br><span class="line">                             | Y\ - bin-&gt;slabcur = NULL #该slab = slabcur时, 将slabcur 设成NULL结束</span><br><span class="line">                             | N\ - bin_info = &amp;bin_infos[binind]</span><br><span class="line">                                | - &lt; bin_info-&gt;nregs == <span class="number">1</span> ?&gt; #<span class="string">&quot;判断该slab是处在full列中还是nonfull堆中&quot;</span></span><br><span class="line">                                | Y\ - arena_bin_slabs_full_remove(arena, bin, slab) #full中删除</span><br><span class="line">                                | N\ - arena_bin_slabs_nonfull_remove(bin, slab); #从nonfull中删除                   </span><br><span class="line">                          |  | - arena_dalloc_bin_slab(tsdn, arena, slab, bin)                          </span><br><span class="line">                             |  \ - arena_slab_dalloc(tsdn, arena, slab)</span><br><span class="line">                                |  \ - arena_nactive_sub(arena, extent_size_get(slab) &gt;&gt; LG_PAGE)</span><br><span class="line">                                   |  \ - &amp;arena-&gt;nactive - (extent_size_get(slab) &gt;&gt; LG_PAGE) #<span class="string">&quot;arena active page (就是使用活跃状态的			</span></span><br><span class="line"><span class="string">                                   总page数 - extent占用的page数&quot;</span>)</span><br><span class="line">                          |  |  | *| - arena_extents_dirty_dalloc(tsdn, arena, &amp;extent_hooks, slab) </span><br><span class="line">                                                         #<span class="string">&quot;这个地方的生效条件是 该extent变成了所有 region全是未使用的状态&quot;</span></span><br><span class="line">                                      |  \ - extents_dalloc(tsdn, arena, r_extent_hooks, &amp;arena-&gt;extents_dirty, extent); #//TODO         </span><br><span class="line">                          | N\ - &lt; nfree == <span class="number">1</span> &amp;&amp; slab != bin-&gt;slabcur ?&gt; #<span class="string">&quot;extent nfree释放后恰好变成了1, 即从full状态变成了nonfull状态&quot;</span></span><br><span class="line">                             | Y\ - arena_bin_slabs_full_remove(arena, bin, slab) #<span class="string">&quot;将该slab从slab_full队中删除&quot;</span></span><br><span class="line">                                |  \ - extent_list_remove(&amp;bin-&gt;slabs_full, slab)</span><br><span class="line">                                | - arena_bin_lower_slab(tsdn, arena, slab, bin)</span><br><span class="line">                                   | - &lt; bin-&gt;slabcur != NULL &amp;&amp; extent_snad_comp(bin-&gt;slabcur, slab) &gt; <span class="number">0</span> &gt; #这个应该是比较哪个slab比较旧</span><br><span class="line">                                   | Y\ - &lt; extent_nfree_get(bin-&gt;slabcur) &gt; <span class="number">0</span> &gt; #slabcur nfree&gt;<span class="number">0</span>? </span><br><span class="line">                                       | Y\ - arena_bin_slabs_nonfull_insert(bin, bin-&gt;slabcur) </span><br><span class="line">                                                  ##当前slab旧, 轮转slab和slabcur, 即slabcur总是用最旧的, slabcur 入nonfull堆</span><br><span class="line">                                       | N\ - arena_bin_slabs_full_insert(arena, bin, bin-&gt;slabcur) # slabcur 入full堆, 因为nfree没了</span><br><span class="line">                                       | - bin-&gt;slabcur = slab #切换slabcur为当前的slab</span><br><span class="line">                                   | N\ - arena_bin_slabs_nonfull_insert(bin, slab) #slabcur旧, 不轮转, 将该slab其入nonfull堆, 从full列删除</span><br><span class="line">              | N\ - extent_t *extent = iealloc(tsdn, ptr)  </span><br><span class="line">  |  | &lt;==       | - return large_dalloc(tsdn, extent)   #<span class="string">&quot;走large的释放&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述流程中涉及到了 <code>arena_extents_dirty_dalloc</code>方法是内存被释放后, 与dirty extents堆的交互过程, 重点看下这部分, 其他都是相关bin 数据结构的关系整理.</p>
<h3 id="arena-extents-dirty-dalloc-extent变成了所有-region全是未使用的状态时的处理"><a href="#arena-extents-dirty-dalloc-extent变成了所有-region全是未使用的状态时的处理" class="headerlink" title="arena_extents_dirty_dalloc extent变成了所有 region全是未使用的状态时的处理"></a><code>arena_extents_dirty_dalloc</code> extent变成了所有 region全是未使用的状态时的处理</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># <span class="string">&quot;输入为extent, 即上面传下来的slab, 还有arena, 触发条件是extent变成了所有 region全是未使用的状态&quot;</span> 函数执行前后需要加锁, 略过</span><br><span class="line">--&gt;void arena_extents_dirty_dalloc<span class="params">(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks, extent_t *extent)</span> </span><br><span class="line">|  \ - extents_dalloc<span class="params">(tsdn, arena, r_extent_hooks, &amp;arena-&gt;extents_dirty, extent)</span>;</span><br><span class="line">   |  \ - extent_addr_set<span class="params">(extent, extent_base_get(extent))</span> #&quot;设置成addr page对齐的地址&quot;</span><br><span class="line">      | - extent_zeroed_set<span class="params">(extent, false)</span> # 是否是重置的, 传入的是false</span><br><span class="line">      | - extent_record<span class="params">(tsdn, arena, r_extent_hooks, extents, extent, false)</span> # 这里用到了 extents, 上文是 dirty的heap </span><br><span class="line">      |  \ - extent_szind_set<span class="params">(extent, NSIZES)</span>;</span><br><span class="line">         | - &lt; extent_slab_get<span class="params">(extent)</span> ?&gt; &quot;传入的entent是否是small class的slab &quot; 上文传下来是的</span><br><span class="line">        *| Y\ - extent_interior_deregister<span class="params">(tsdn, rtree_ctx, extent)</span>; #&quot;反注册, 从全局rtree中删除记录&quot; //TODO</span><br><span class="line">            | - extent_slab_set<span class="params">(extent, false)</span> # &quot;消除slab标记, 变成普通的extent&quot;</span><br><span class="line">         | - &lt; !extents-&gt;delay_coalesce? &gt; # 是否指定了延迟合并, 未指定则立即合并</span><br><span class="line">         | Y\ - extent = extent_try_coalesce<span class="params">(tsdn, arena, r_extent_hooks, rtree_ctx, extents, extent, NULL, growing_retained)</span>; </span><br><span class="line">         | N\ - &lt; extent_size_get<span class="params">(extent)</span> &gt;= LARGE_MINCLASS &gt; # &quot;extent size &gt;= <span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span> Always coalesce large extents eagerly  &quot;</span><br><span class="line">            | Y\ - &lt;for ; coalesced &amp;&amp; extent_size_get<span class="params">(extent)</span> &gt;= prev_size + LARGE_MINCLASS; &gt;</span><br><span class="line">                     #&quot;如果返回的coalesced为true &amp;&amp; extent的size &gt;= <span class="params">(合并前的size + <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span>, 就会一直触发合并, 直到合并不下去&quot;</span><br><span class="line">               |  \ - prev_size = extent_size_get<span class="params">(extent)</span> #&quot;记住合并前的大小&quot;</span><br><span class="line">                  | - extent = extent_try_coalesce<span class="params">(tsdn, arena, r_extent_hooks, rtree_ctx, extents, extent, &amp;coalesced, </span></span><br><span class="line"><span class="params">                                                   growing_retained)</span> #&quot;进行合并, 返回是否合并成功了&quot;</span><br><span class="line">        *| - extent_deactivate_locked<span class="params">(tsdn, arena, extents, extent)</span></span><br><span class="line">         |  \ - extent_state_set<span class="params">(extent, extents_state_get(extents) #上文传入的是dirty堆, 所以这里将extent标记为了dirty</span></span><br><span class="line"><span class="params">            | - extents_insert_locked(tsdn, extents, extent) #将extent插入到 dirty堆中                        </span></span><br></pre></td></tr></table></figure>

<h4 id="小内存释放小结"><a href="#小内存释放小结" class="headerlink" title="小内存释放小结"></a>小内存释放小结</h4><p>总结上述小内存释放的流程, 当前仅关注fast场景</p>
<ol>
<li><p>根据调用上下文执行流程, 找到其绑定的tsd</p>
</li>
<li><p>根据tsd找到其tcache成员</p>
</li>
<li><p>fast场景, 根据全局rtree, ptr地址为key, 检索出其size ind, 以及是否是 slab (地址是否是小内存的)</p>
</li>
<li><p>如果没有tcache, 走<code>arena_dalloc_no_tcache(tsdn, ptr)</code>流程, 一般情况下都是有tcache的, 走<code>arena_dalloc_small(tsdn, ptr)</code>流程</p>
</li>
<li><p>由<code>iealloc(tsdn, ptr)</code> 根据全局rtree, ptr地址为key, 检索出其 extent 结构, 由extent <code>extent_arena_get(extent)</code>获取extent对应的arena, 由extent <code>extent_szind_get(extent)</code>获取binind, 进而<code>&amp;arena-&gt;bins[binind]</code>获得bin结构, <code>arena_slab_regind(slab, binind, ptr) </code>获得ptr在extent中对应的region id.  清除该regionid 在extent中的使用标记, <code>extent_nfree_inc(slab)</code> extent 元信息中记录其 free region数+1</p>
</li>
<li><p>如果释放后, 该extent变成了全free 状态(即所有region 都是free的), arena active page数 - 该extent所占的page数, 最后将该extent或者合并后的extent挂入<code>dirty</code>堆中, 这时, 如果支持合并的话(have_dss对应的宏打开), 查extent前后的extent, 循环合并, 直到合并不了为止</p>
<p>6.1 ptr所在的slab是 bin-&gt;slabcur, 将slabcur 设成NULL</p>
<p>6.2 ptr所在slab不是slabcur的情况下, 如果其bin_info-&gt;nregs &#x3D;&#x3D; 1,  即释放前bin中的nregs(总region数)是1, 释放后, 该bin就变成未使用的状态了, 需要将其从slabfull 列中删除, 如果不是1(肯定也不是0, 就是&gt;1的情况), 将其从nonfull堆中删除</p>
<blockquote>
<p>bin nregs 是所有ind extent的region的总数</p>
</blockquote>
</li>
<li><p>如果释放后, nfree释放后恰好变成了1, 即从full状态变成了nonfull状态. 将 <code>arena-&gt;bins[binind]-&gt;slabcur</code> 切换为这个 <code>extent</code>，前提是这个 <code>extent</code> “更旧”（序列号更小地址更低），并且将替换后的 <code>extent</code> 移入 <code>arena-&gt;bins[binind]-&gt;slabs_nonfull</code>, 并从slab_full队中删除.</p>
</li>
</ol>
<h4 id="extent-try-coalesce-合并extent"><a href="#extent-try-coalesce-合并extent" class="headerlink" title="extent_try_coalesce 合并extent"></a>extent_try_coalesce 合并extent</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">extent_t</span> *</span><br><span class="line"><span class="title function_">extent_try_coalesce</span><span class="params">(<span class="type">tsdn_t</span> *tsdn, <span class="type">arena_t</span> *arena,</span></span><br><span class="line"><span class="params">    <span class="type">extent_hooks_t</span> **r_extent_hooks, <span class="type">rtree_ctx_t</span> *rtree_ctx, <span class="type">extents_t</span> *extents,</span></span><br><span class="line"><span class="params">    <span class="type">extent_t</span> *extent, <span class="type">bool</span> *coalesced, <span class="type">bool</span> growing_retained)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Continue attempting to coalesce until failure, to protect against</span></span><br><span class="line"><span class="comment">	 * races with other threads that are thwarted by this one.</span></span><br><span class="line"><span class="comment">	 */</span> </span><br><span class="line">    <span class="comment">// 这里的again 是多线程防止竞争用的, 如果有别的线程再操作, 这里会直接退出while 循环</span></span><br><span class="line">	<span class="type">bool</span> again;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		again = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Try to coalesce forward. 前向合并*/</span>  </span><br><span class="line">		<span class="type">extent_t</span> *next = extent_lock_from_addr(tsdn, rtree_ctx,</span><br><span class="line">		    extent_past_get(extent));</span><br><span class="line">		<span class="keyword">if</span> (next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * extents-&gt;mtx only protects against races for</span></span><br><span class="line"><span class="comment">			 * like-state extents, so call extent_can_coalesce()</span></span><br><span class="line"><span class="comment">			 * before releasing next&#x27;s pool lock.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="type">bool</span> can_coalesce = extent_can_coalesce(arena, extents,</span><br><span class="line">			    extent, next);</span><br><span class="line"></span><br><span class="line">			extent_unlock(tsdn, next);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (can_coalesce &amp;&amp; !extent_coalesce(tsdn, arena,</span><br><span class="line">			    r_extent_hooks, extents, extent, next, <span class="literal">true</span>,</span><br><span class="line">			    growing_retained)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (extents-&gt;delay_coalesce) &#123;</span><br><span class="line">					<span class="comment">/* Do minimal coalescing. */</span></span><br><span class="line">					*coalesced = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">return</span> extent;</span><br><span class="line">				&#125;</span><br><span class="line">				again = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Try to coalesce backward. 后向合并*/</span></span><br><span class="line">		<span class="type">extent_t</span> *prev = extent_lock_from_addr(tsdn, rtree_ctx,</span><br><span class="line">		    extent_before_get(extent));</span><br><span class="line">		<span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="type">bool</span> can_coalesce = extent_can_coalesce(arena, extents,</span><br><span class="line">			    extent, prev);</span><br><span class="line">			extent_unlock(tsdn, prev);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (can_coalesce &amp;&amp; !extent_coalesce(tsdn, arena,</span><br><span class="line">			    r_extent_hooks, extents, extent, prev, <span class="literal">false</span>,</span><br><span class="line">			    growing_retained)) &#123;</span><br><span class="line">				extent = prev;</span><br><span class="line">				<span class="keyword">if</span> (extents-&gt;delay_coalesce) &#123;</span><br><span class="line">					<span class="comment">/* Do minimal coalescing. */</span></span><br><span class="line">					*coalesced = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">return</span> extent;</span><br><span class="line">				&#125;</span><br><span class="line">				again = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (again);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (extents-&gt;delay_coalesce) &#123;</span><br><span class="line">		*coalesced = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> extent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去除多线程的逻辑外, 大致的流程是</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--&gt;extent_t * extent_try_coalesce<span class="params">(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, </span></span><br><span class="line"><span class="params">                                  extents_t *extents, extent_t *extent, bool *coalesced, bool growing_retained)</span></span><br><span class="line">|  \ - while<span class="params">(again)</span></span><br><span class="line">   |  \ - extent_t *next = extent_lock_from_addr<span class="params">(tsdn, rtree_ctx, extent_past_get(extent))</span> #&quot;查找后一个extent&quot;</span><br><span class="line">      | - bool can_coalesce = extent_can_coalesce<span class="params">(arena, extents, extent, next)</span> #&quot;查看是否可以合并&quot;</span><br><span class="line">      | - &lt; can_coalesce? &amp;&amp; !extent_coalesce<span class="params">(tsdn, arena, r_extent_hooks, extents, extent, next, true, growing_retained)</span> &gt;</span><br><span class="line">   |&lt;-| N\ - again = false</span><br><span class="line">      | - extent_lock_from_addr<span class="params">(tsdn, rtree_ctx, extent_before_get(extent))</span> #&quot;查找前一个extent&quot;</span><br><span class="line">      | - bool can_coalesce = extent_can_coalesce<span class="params">(arena, extents, extent, prev)</span>  </span><br><span class="line">      | - &lt; can_coalesce? &amp;&amp; !extent_coalesce<span class="params">(tsdn, arena, r_extent_hooks, extents, extent, next, false, growing_retained)</span> &gt;</span><br><span class="line">   |&lt;-| N\ - again = false</span><br></pre></td></tr></table></figure>

<h4 id="extent-coalesce-合并extent"><a href="#extent-coalesce-合并extent" class="headerlink" title="extent_coalesce 合并extent"></a>extent_coalesce 合并extent</h4><blockquote>
<p>看起来没有实现, 没有配置合并, 如果配置了, 会走<code>extent_dss_mergeable(extent a, extent b)</code>流程</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--&gt; bool extent_coalesce<span class="params">(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,</span></span><br><span class="line"><span class="params">      extents_t *extents, extent_t *inner, extent_t *outer, bool forward, bool growing_retained)</span></span><br><span class="line">|  \ - extent_merge_impl<span class="params">(tsdn, arena, r_extent_hooks, forward ? inner : outer, forward ? outer : inner, growing_retained)</span></span><br><span class="line">          #&quot;根据forward 标记倒换 inner outer次序, 根据上文看第二次后向合并的过程, forward是false, 则extent 是outer, back extent是 inner&quot;</span><br><span class="line">   |  \ - &lt; *r_extent_hooks == &amp;extent_hooks_default? &gt;</span><br><span class="line">      | Y\ - err = extent_merge_default_impl<span class="params">(extent_base_get(a), extent_base_get(b))</span></span><br><span class="line">         |  \ - err = extent_merge_default_impl<span class="params">(extent_base_get(a), extent_base_get(b))</span> #&quot;空实现?&quot; ??//TODO</span><br><span class="line">            |  \ - &lt;have_dss? JEMALLOC_DSS? &gt; # &quot;这个宏好像没开&quot;</span><br><span class="line">               |  \ - return !extent_dss_mergeable<span class="params">(addr_a, addr_b)</span></span><br><span class="line">      | N\ - err = <span class="params">(*r_extent_hooks)</span>-&gt;merge<span class="params">(*r_extent_hooks, extent_base_get(a), extent_size_get(a), extent_base_get(b),</span></span><br><span class="line"><span class="params">		    extent_size_get(b), extent_committed_get(a), arena_ind_get(arena))</span></span><br><span class="line">         | - extent_merge_default<span class="params">(...)</span></span><br><span class="line">         |  \ - extent_merge_default_impl<span class="params">(void *addr_a, void *addr_b)</span></span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/heap/" rel="tag"># heap</a>
              <a href="/tags/jemalloc/" rel="tag"># jemalloc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/sigev%20%E8%BF%BD%E8%B8%AA/" rel="prev" title="android sigev 信号追踪">
      <i class="fa fa-chevron-left"></i> android sigev 信号追踪
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/19/%E7%A8%B3%E5%AE%9A%E6%80%A7/scudo%E9%85%8D%E7%BD%AE/" rel="next" title="scudo配置">
      scudo配置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#jemalloc%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">jemalloc基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#size-class"><span class="nav-number">1.1.</span> <span class="nav-text">size_class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base"><span class="nav-number">1.2.</span> <span class="nav-text">base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin"><span class="nav-number">1.3.</span> <span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin-infos-binind"><span class="nav-number">1.4.</span> <span class="nav-text">bin_infos[binind]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extent"><span class="nav-number">1.5.</span> <span class="nav-text">extent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab"><span class="nav-number">1.6.</span> <span class="nav-text">slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extents"><span class="nav-number">1.7.</span> <span class="nav-text">extents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena"><span class="nav-number">1.8.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtree"><span class="nav-number">1.9.</span> <span class="nav-text">rtree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-bin"><span class="nav-number">1.10.</span> <span class="nav-text">cache_bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache"><span class="nav-number">1.11.</span> <span class="nav-text">tcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsd"><span class="nav-number">1.12.</span> <span class="nav-text">tsd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#je%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="nav-number">2.</span> <span class="nav-text">je初始化及内存申请</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 初始化参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-extent%E9%BB%98%E8%AE%A4%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 extent默认的处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-SIZE-CLASSES%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 SIZE_CLASSES定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-arena-boot-%E5%B1%95%E5%BC%80"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 arena_boot 展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%AB%98%E7%BA%A7%E5%AE%8F%E5%B1%95%E5%BC%80"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 高级宏展开</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MALLOC-TSD-tsds-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.5.1.</span> <span class="nav-text">MALLOC_TSD tsds 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.2.</span> <span class="nav-text">相关的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-bits%E7%9B%B8%E5%85%B3"><span class="nav-number">2.5.3.</span> <span class="nav-text">e_bits相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#je-malloc-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">je_malloc 基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-tsd-tcache-bins-small-%E5%A1%AB%E5%85%85%E6%B5%81%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">1.6 tsd-&gt;tcache-&gt;bins_small 填充流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-extent-alloc%E6%B5%81%E7%A8%8B"><span class="nav-number">2.8.</span> <span class="nav-text">1.7 extent_alloc流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#extent-recycle-%E5%9B%9E%E6%94%B6%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">2.8.1.</span> <span class="nav-text">extent_recycle 回收函数分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#je-free-%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">je_free 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-extents-dirty-dalloc-extent%E5%8F%98%E6%88%90%E4%BA%86%E6%89%80%E6%9C%89-region%E5%85%A8%E6%98%AF%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">arena_extents_dirty_dalloc extent变成了所有 region全是未使用的状态时的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%B0%8F%E7%BB%93"><span class="nav-number">3.1.1.</span> <span class="nav-text">小内存释放小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extent-try-coalesce-%E5%90%88%E5%B9%B6extent"><span class="nav-number">3.1.2.</span> <span class="nav-text">extent_try_coalesce 合并extent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extent-coalesce-%E5%90%88%E5%B9%B6extent"><span class="nav-number">3.1.3.</span> <span class="nav-text">extent_coalesce 合并extent</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VrGRp2q7WwXjxsCNmlDIZYbC-gzGzoHsz',
      appKey     : 'JgMXmmB7yKQf2zm80TaBp3JT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

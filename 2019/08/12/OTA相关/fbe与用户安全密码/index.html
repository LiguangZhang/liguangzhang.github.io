<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC] 1. fbe与用户安全密码之前介绍了fde与用户安全密码的关系，发现其是相对简单的。而对fbe和metadata加密的方式，在调研过程中发现密码的存储与文件ce区的密钥的关系则复杂的多。 1.1. 用户ce区文件解密这个过程伴随着一个函数向下执行的，即unlockUserKey函数，首先看下伴随这个过程的密钥来自哪里 123456unlockUserKey(userId, null,">
<meta property="og:type" content="article">
<meta property="og:title" content="fbe与用户安全密码">
<meta property="og:url" content="https://liguangzhang.github.io/2019/08/12/OTA%E7%9B%B8%E5%85%B3/fbe%E4%B8%8E%E7%94%A8%E6%88%B7%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="[TOC] 1. fbe与用户安全密码之前介绍了fde与用户安全密码的关系，发现其是相对简单的。而对fbe和metadata加密的方式，在调研过程中发现密码的存储与文件ce区的密钥的关系则复杂的多。 1.1. 用户ce区文件解密这个过程伴随着一个函数向下执行的，即unlockUserKey函数，首先看下伴随这个过程的密钥来自哪里 123456unlockUserKey(userId, null,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liguangzhang.github.io/images/20200527161613.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/20200527161620.png">
<meta property="article:published_time" content="2019-08-12T10:15:54.000Z">
<meta property="article:modified_time" content="2024-04-16T07:19:06.339Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="fbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liguangzhang.github.io/images/20200527161613.png">

<link rel="canonical" href="https://liguangzhang.github.io/2019/08/12/OTA%E7%9B%B8%E5%85%B3/fbe%E4%B8%8E%E7%94%A8%E6%88%B7%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>fbe与用户安全密码 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2019/08/12/OTA%E7%9B%B8%E5%85%B3/fbe%E4%B8%8E%E7%94%A8%E6%88%B7%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          fbe与用户安全密码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-12 18:15:54" itemprop="dateCreated datePublished" datetime="2019-08-12T18:15:54+08:00">2019-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 15:19:06" itemprop="dateModified" datetime="2024-04-16T15:19:06+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Filesystem/" itemprop="url" rel="index"><span itemprop="name">Filesystem</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Filesystem/%E5%8A%A0%E5%AF%86/" itemprop="url" rel="index"><span itemprop="name">加密</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h1 id="1-fbe与用户安全密码"><a href="#1-fbe与用户安全密码" class="headerlink" title="1. fbe与用户安全密码"></a>1. fbe与用户安全密码</h1><p>之前介绍了fde与用户安全密码的关系，发现其是相对简单的。而对fbe和metadata加密的方式，在调研过程中发现密码的存储与文件ce区的密钥的关系则复杂的多。</p>
<h2 id="1-1-用户ce区文件解密"><a href="#1-1-用户ce区文件解密" class="headerlink" title="1.1. 用户ce区文件解密"></a>1.1. 用户ce区文件解密</h2><p>这个过程伴随着一个函数向下执行的，即<code>unlockUserKey</code><em><strong>函数</strong></em>，首先看下伴随这个过程的密钥来自哪里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unlockUserKey(userId, <span class="literal">null</span>, auth.deriveDiskEncryptionKey());</span><br><span class="line">    <span class="comment">/** Unlock disk encryption */</span></span><br><span class="line"><span class="number">1712</span>     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlockUserKey</span><span class="params">(<span class="type">int</span> userId, <span class="type">byte</span>[] token, <span class="type">byte</span>[] secret)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="number">1713</span>         <span class="keyword">final</span> <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> mUserManager.getUserInfo(userId);</span><br><span class="line"><span class="number">1714</span>         mStorageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);</span><br><span class="line"><span class="number">1715</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>以机主用户为例， 上述参数中userID为0， token 为空， serialNumber为0，未知的只有secret，来自<code>deriveDiskEncryptionKey</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="type">byte</span>[] deriveDiskEncryptionKey() &#123;</span><br><span class="line"><span class="number">179</span>             <span class="keyword">return</span> derivePassword(PERSONALIZATION_FBE_KEY);</span><br><span class="line"><span class="number">180</span>         &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">160</span>         <span class="keyword">private</span> <span class="type">byte</span>[] derivePassword(<span class="type">byte</span>[] personalization) &#123;</span><br><span class="line"><span class="number">161</span>             <span class="keyword">if</span> (mVersion == SYNTHETIC_PASSWORD_VERSION_V3) &#123;</span><br><span class="line"><span class="number">162</span>                 <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">SP800Derive</span>(syntheticPassword.getBytes()))</span><br><span class="line"><span class="number">163</span>                     .withContext(personalization, PERSONALISATION_CONTEXT);</span><br><span class="line"><span class="number">164</span>             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">165</span>                 <span class="keyword">return</span> SyntheticPasswordCrypto.personalisedHash(personalization,</span><br><span class="line"><span class="number">166</span>                         syntheticPassword.getBytes());</span><br><span class="line"><span class="number">167</span>             &#125;</span><br><span class="line"><span class="number">168</span>         &#125;</span><br></pre></td></tr></table></figure>
<p>关键参数只有一个<code>syntheticPassword</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">byte</span>[] P0, <span class="type">byte</span>[] P1)</span> &#123;</span><br><span class="line"><span class="number">191</span>             <span class="built_in">this</span>.P1 = P1;</span><br><span class="line"><span class="number">192</span>             <span class="built_in">this</span>.syntheticPassword = String.valueOf(HexEncoding.encode(</span><br><span class="line"><span class="number">193</span>                     SyntheticPasswordCrypto.personalisedHash(</span><br><span class="line"><span class="number">194</span>                             PERSONALIZATION_SP_SPLIT, P0, P1)));</span><br></pre></td></tr></table></figure>
<p>这个密码生成的时候是一个随机的值？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> AuthenticationToken <span class="title function_">newSyntheticPasswordAndSid</span><span class="params">(IGateKeeperService gatekeeper,</span></span><br><span class="line"><span class="params"> <span class="number">463</span>             <span class="type">byte</span>[] hash, <span class="type">byte</span>[] credential, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"> <span class="number">464</span>         <span class="type">AuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> AuthenticationToken.create();</span><br><span class="line">...</span><br><span class="line"> <span class="number">478</span>         saveEscrowData(result, userId);</span><br><span class="line"> <span class="number">479</span>         <span class="keyword">return</span> result;</span><br><span class="line"> <span class="number">480</span>     &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">protected</span> <span class="keyword">static</span> AuthenticationToken <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="number">204</span>             <span class="type">AuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationToken</span>(SYNTHETIC_PASSWORD_VERSION_V3);</span><br><span class="line"> <span class="number">205</span>                     result.initialize(secureRandom(SYNTHETIC_PASSWORD_LENGTH),</span><br><span class="line"> <span class="number">206</span>                     secureRandom(SYNTHETIC_PASSWORD_LENGTH));</span><br><span class="line"> <span class="number">207</span>             <span class="keyword">return</span> result;</span><br><span class="line"> <span class="number">208</span>         &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个地方表明这个是伴随用户密码解锁过程解出来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> AuthenticationToken <span class="title function_">unwrapSyntheticPasswordBlob</span><span class="params">(<span class="type">long</span> handle, <span class="type">byte</span> type,</span></span><br><span class="line"><span class="params"> <span class="number">979</span>             <span class="type">byte</span>[] applicationId, <span class="type">long</span> sid, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"> <span class="number">980</span>         <span class="type">byte</span>[] blob = loadState(SP_BLOB_NAME, handle, userId);</span><br><span class="line"> </span><br><span class="line"><span class="number">94</span>         <span class="keyword">if</span> (version == SYNTHETIC_PASSWORD_VERSION_V1) &#123;</span><br><span class="line"> <span class="number">995</span>             secret = SyntheticPasswordCrypto.decryptBlobV1(getHandleName(handle),</span><br><span class="line"> <span class="number">996</span>                     Arrays.copyOfRange(blob, <span class="number">2</span>, blob.length), applicationId);</span><br><span class="line"> <span class="number">997</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">998</span>             secret = decryptSPBlob(getHandleName(handle),</span><br><span class="line"> <span class="number">999</span>                 Arrays.copyOfRange(blob, <span class="number">2</span>, blob.length), applicationId);</span><br><span class="line"><span class="number">1000</span>         &#125;</span><br><span class="line"><span class="comment">// 来自secret，secret的解密又有keymaster gatekeeper的参与</span></span><br><span class="line">         <span class="keyword">if</span> (type == SYNTHETIC_PASSWORD_TOKEN_BASED) &#123;</span><br><span class="line"><span class="number">1007</span>             <span class="keyword">if</span> (!loadEscrowData(result, userId)) &#123;</span><br><span class="line"><span class="number">1008</span>                 Log.e(TAG, <span class="string">&quot;User is not escrowable: &quot;</span> + userId);</span><br><span class="line"><span class="number">1009</span>                 <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">1010</span>             &#125;</span><br><span class="line"><span class="number">1011</span>             result.recreate(secret);</span><br><span class="line"><span class="number">1012</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1013</span>             result.syntheticPassword = <span class="keyword">new</span> <span class="title class_">String</span>(secret);</span><br><span class="line"><span class="number">1014</span>         &#125;</span><br></pre></td></tr></table></figure>
<p>这个流程可以追溯到解锁后，解锁密码的保存时触发的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">saveChosenPasswordnAndFinish(final String pin)    <span class="comment">#ChooseLockPassword.java - MiuiSystemUI</span></span></span><br><span class="line">  \ - saveLockPassword(pin, mUserPassword, mRequestedQuality, mUserIdToSetPassword) # LockPatternUtils.java</span><br><span class="line">     \ -  setLockCredential(password, CREDENTIAL_TYPE_PASSWORD, savedPassword,</span><br><span class="line">                      requestedQuality, userHandle, allowUntrustedChange); #LockSettingService.java</span><br><span class="line">         \ - setLockCredentialInternal(credential, type, savedCredential, requestedQuality, userId,</span><br><span class="line">                     allowUntrustedChange, /* isLockTiedToParent= */ false); #LockSettingService.java</span><br><span class="line">             \ - spBasedSetLockCredentialInternalLocked(credential, credentialType, savedCredential,</span><br><span class="line">                         requestedQuality, userId, allowUntrustedChange, isLockTiedToParent); #LockSettingService.java</span><br><span class="line">                  \ -  AuthenticationResult authResult = mSpManager.unwrapPasswordBasedSyntheticPassword(</span><br><span class="line">                            getGateKeeperService(), handle, savedCredential, userId, null);</span><br><span class="line">                  | - setLockCredentialWithAuthTokenLocked(credential, credentialType, auth, requestedQuality, userId);</span><br><span class="line">                       \ - unlockUserKey(userId, null, auth.deriveDiskEncryptionKey());</span><br><span class="line">             | -  setUserKeyProtection(userId, credential, convertResponse(gkResponse));</span><br><span class="line">                 \ - addUserKeyAuth(userId, token, secretFromCredential(credential)); #LockSettingService.java</span><br></pre></td></tr></table></figure>
<p>上述过程只是解锁的一个流程，在用户密码校验的地方，有一处值得注意，即使用<code>spBasedSetLockCredentialInternalLocked</code>进行核对时，是有条件的<br>注意这个函数<code>isSyntheticPasswordBasedCredentialLocked</code>, 只有这个函数为true时，才会对secret加这一层封装。从之前的流程分析下来，这个封装的中间文件存在了<br><code>/data/system_de/0/spblob</code>下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSyntheticPasswordBasedCredentialLocked</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">2517</span>         <span class="type">long</span> <span class="variable">handle</span> <span class="operator">=</span> getSyntheticPasswordHandleLocked(userId);</span><br><span class="line"><span class="number">2518</span>         <span class="comment">// This is a global setting</span></span><br><span class="line"><span class="number">2519</span>         <span class="type">long</span> <span class="variable">enabled</span> <span class="operator">=</span> getLong(SYNTHETIC_PASSWORD_ENABLED_KEY,</span><br><span class="line"><span class="number">2520</span>                 SYNTHETIC_PASSWORD_ENABLED_BY_DEFAULT, UserHandle.USER_SYSTEM);</span><br><span class="line"><span class="number">2521</span>       <span class="keyword">return</span> enabled != <span class="number">0</span> &amp;&amp; handle != SyntheticPasswordManager.DEFAULT_HANDLE;</span><br><span class="line"><span class="number">2522</span>     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>初步流程分析下来，用户密码和ce区文件解锁密码之间的导出关系比较复杂，且需要多个中间参数和keymater的参与</p>
<blockquote>
<p>上面的流程分析有点问题，unlockUserKey应该时UserController下发的<br>关注下面的函数：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> VerifyCredentialResponse <span class="title function_">verifyCredential</span><span class="params">(<span class="type">int</span> userId, CredentialHash storedHash,</span></span><br><span class="line"><span class="params"><span class="number">1907</span>             <span class="type">byte</span>[] credential, <span class="type">boolean</span> hasChallenge, <span class="type">long</span> challenge,</span></span><br><span class="line"><span class="params"><span class="number">1908</span>             ICheckCredentialProgressCallback progressCallback)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里如果<code>isSyntheticPasswordBasedCredentialLocked</code>返回false，再对整个解锁流程做一下梳理，密码输入后，会触发check的逻辑</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+- onPatternDetected(List&lt;Cell&gt; pattern) #图案绘完 ConfirmLockPattern.java</span><br><span class="line"> \ +- startVerifyPattern(pattern)</span><br><span class="line">    \ - long challenge = getActivity().getIntent().getLongExtra(MiuiChooseLockSettingsHelper.EXTRA_KEY_CHALLENGE, 0);</span><br><span class="line">    | +- LockPatternChecker.verifyPattern(mLockPatternUtils, pattern, challenge, localUserId, mContext, onVerifyCallback) #challenge未知，由外部传入</span><br><span class="line">       \ +- LockPatternUtils.verifyPattern(patternCopy, challenge, userId) # LockPatternChecker.java</span><br><span class="line">         \ - verifyCredential(patternToByteArray(pattern), CREDENTIAL_TYPE_PATTERN, challenge, userId); # LockPatternUtils.java</span><br><span class="line">            \ - getLockSettings().verifyCredential(credential, type, challenge, userId);</span><br><span class="line">               \ +- doVerifyCredential(credential, type, true, challenge, userId, null) # LockSettingService.java</span><br><span class="line">                  \ +-  response = spBasedDoVerifyCredential(credential, credentialType, hasChallenge, challenge, userId, progressCallback);</span><br><span class="line">                      \ - spBasedDoVerifyCredential&lt;credential, credentialType, hasChallenge, challenge, userId, progressCallback&gt;</span><br><span class="line">                        \ - long handle = getSyntheticPasswordHandleLocked(userId);</span><br><span class="line">                        | - mSpManager.unwrapPasswordBasedSyntheticPassword( getGateKeeperService(), handle, userCredential, userId, progressCallback); </span><br><span class="line">                  | +-  response = verifyCredential(userId, storedHash, credentialToVerify, hasChallenge, challenge, progressCallback);</span><br><span class="line">                     \ - CredentialHash storedHash = mStorage.readCredentialHash(userId) #从保存的密钥中间文件中构造hash</span><br><span class="line">                     | - gateKeeperResponse = getGateKeeperService().verifyChallenge(userId, challenge, storedHash.hash, credential); #challenge由外部传入，storedHash读取/data/system/gatekeeper.pattern.key|gatekeeper.password.key，通过verifyChallenge返回了一个token</span><br><span class="line">                     | - VerifyCredentialResponse response = convertResponse(gateKeeperResponse); #这里仍然有gatekeeper参与</span><br><span class="line">                     | - unlockKeystore(credential, userId);</span><br><span class="line">                     | - unlockUser(userId, response.getPayload(), secretFromCredential(credential)); #未知参数变成了token</span><br><span class="line">                        \ - mActivityManager.unlockUser(userId, token, secret, listener);</span><br><span class="line">                           \ - mUserController.unlockUser(userId, token, secret, listener) # ActivityManagerService.java</span><br><span class="line">                              \ - unlockUserCleared(userId, token, secret, listener) #UserController.java</span><br><span class="line">                                 \ - storageManager.unlockUserKey(userId, userInfo.serialNumber, token, secret);</span><br><span class="line">                                    \- mVold.unlockUserKey(userId, serialNumber, encodeBytes(token), encodeBytes(secret)) #StorageManagrService</span><br></pre></td></tr></table></figure>

<p>从上面的流程看，对于<code>isSyntheticPasswordBasedCredentialLocked</code>返回false的情况，需要关注的点是外部传入的<code>chanllenge</code>, 以及用户安全密码的中间文件<code>storeHash</code>和用户输入的安全密码，unlockKeyStore GateKeeper都需要能被调用到 <code>system/security/keystore</code> <code>system/core/gatekeeperd</code></p>
<h2 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2. 小结"></a>1.2. 小结</h2><p>从上述流程分析来看，fde和fbe用户密码与直接解锁密码的逻辑并不相同：</p>
<ul>
<li>fde的解锁方式上看，开机时CryptKeeper接管了keyguard的操作，用户密码与解锁fde磁盘加密主密钥直接相关，因此导出关系很单一。</li>
<li>而fbe的解锁方式，开机后直接走的keyguard，keyguard的模块逻辑比较复杂，而且用户密码经过了多层加密，最终的用户密码到ce区的文件解锁密码关系要复杂的多。中间经过了多层中转，需要逐层分析。 需要通过设备调试，发现其中的中转关系</li>
</ul>
<h2 id="1-3-spblob方式流程跟进"><a href="#1-3-spblob方式流程跟进" class="headerlink" title="1.3. spblob方式流程跟进"></a>1.3. spblob方式流程跟进</h2><p>从上面isSyntheticPasswordBasedCredentialLocked返回true的场景上，q的机型正是用的这种加密方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">774</span>         <span class="type">long</span> <span class="variable">handle</span> <span class="operator">=</span> getSyntheticPasswordHandleLocked(userId);</span><br><span class="line"><span class="number">2775</span>         <span class="type">AuthenticationResult</span> <span class="variable">authResult</span> <span class="operator">=</span> mSpManager.unwrapPasswordBasedSyntheticPassword(</span><br><span class="line"><span class="number">2776</span>                 getGateKeeperService(), handle, savedCredential, userId, <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先看  <code>getSyntheticPasswordHandleLocked</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getSyntheticPasswordHandleLocked</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line"><span class="number">2566</span>         <span class="keyword">return</span> getLong(SYNTHETIC_PASSWORD_HANDLE_KEY,</span><br><span class="line"><span class="number">2567</span>                 SyntheticPasswordManager.DEFAULT_HANDLE, userId);</span><br><span class="line"><span class="number">2568</span>     &#125;</span><br></pre></td></tr></table></figure>
<p><code>SYNTHETIC_PASSWORD_HANDLE_KEY</code>来自于<code>initializeSyntheticPasswordLocked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2533</span>     <span class="keyword">protected</span> AuthenticationToken <span class="title function_">initializeSyntheticPasswordLocked</span><span class="params">(<span class="type">byte</span>[] credentialHash,</span></span><br><span class="line"><span class="params"><span class="number">2534</span>             <span class="type">byte</span>[] credential, <span class="type">int</span> credentialType, <span class="type">int</span> requestedQuality,</span></span><br><span class="line"><span class="params"><span class="number">2535</span>             <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="number">2536</span>         Slog.i(TAG, <span class="string">&quot;Initialize SyntheticPassword for user: &quot;</span> + userId);</span><br><span class="line"><span class="number">2537</span>         <span class="keyword">final</span> <span class="type">AuthenticationToken</span> <span class="variable">auth</span> <span class="operator">=</span> mSpManager.newSyntheticPasswordAndSid(</span><br><span class="line"><span class="number">2538</span>                 getGateKeeperService(), credentialHash, credential, userId);</span><br><span class="line"><span class="number">2539</span>         onAuthTokenKnownForUser(userId, auth);</span><br><span class="line"><span class="comment">// 创建password相关的handle和spblob中间文件</span></span><br><span class="line"><span class="number">2544</span>         <span class="type">long</span> <span class="variable">handle</span> <span class="operator">=</span> mSpManager.createPasswordBasedSyntheticPassword(getGateKeeperService(),</span><br><span class="line"><span class="number">2545</span>                 credential, credentialType, auth, requestedQuality, userId);</span><br><span class="line"><span class="number">2546</span>         <span class="keyword">if</span> (credential != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">2547</span>             <span class="keyword">if</span> (credentialHash == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">2548</span>                 <span class="comment">// Since when initializing SP, we didn&#x27;t provide an existing password handle</span></span><br><span class="line"><span class="number">2549</span>                 <span class="comment">// for it to migrate SID, we need to create a new SID for the user.</span></span><br><span class="line"><span class="number">2550</span>                 mSpManager.newSidForUser(getGateKeeperService(), auth, userId);</span><br><span class="line"><span class="number">2551</span>             &#125;</span><br><span class="line"><span class="number">2552</span>             mSpManager.verifyChallenge(getGateKeeperService(), auth, <span class="number">0L</span>, userId);</span><br><span class="line"><span class="number">2553</span>             setAuthlessUserKeyProtection(userId, auth.deriveDiskEncryptionKey());</span><br><span class="line"><span class="number">2554</span>             setKeystorePassword(auth.deriveKeyStorePassword(), userId);</span><br><span class="line"><span class="number">2555</span>         &#125;</span><br><span class="line"><span class="number">2560</span>         fixateNewestUserKeyAuth(userId);</span><br><span class="line"><span class="number">2561</span>         setLong(SYNTHETIC_PASSWORD_HANDLE_KEY, handle, userId);</span><br><span class="line"><span class="number">2562</span>         <span class="keyword">return</span> auth;</span><br><span class="line"><span class="number">2563</span>     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">createPasswordBasedSyntheticPassword</span><span class="params">(IGateKeeperService gatekeeper,</span></span><br><span class="line"><span class="params"> <span class="number">627</span>             <span class="type">byte</span>[] credential, <span class="type">int</span> credentialType, AuthenticationToken authToken,</span></span><br><span class="line"><span class="params"> <span class="number">628</span>             <span class="type">int</span> requestedQuality, <span class="type">int</span> userId)</span></span><br><span class="line"> <span class="number">29</span>                     <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"> <span class="comment">//可以看到handle是一个随机值，最终setLong(SYNTHETIC_PASSWORD_HANDLE_KEY, handle, userId); 到数据库中，再次取得时候，直接从数据库中getLong获取</span></span><br><span class="line">         <span class="type">long</span> <span class="variable">handle</span> <span class="operator">=</span> generateHandle();</span><br><span class="line"> <span class="number">636</span>         <span class="type">PasswordData</span> <span class="variable">pwd</span> <span class="operator">=</span> PasswordData.create(credentialType);</span><br><span class="line"> <span class="number">637</span>         <span class="type">byte</span>[] pwdToken = computePasswordToken(credential, pwd);</span><br><span class="line"> ...</span><br><span class="line">         saveState(PASSWORD_DATA_NAME, pwd.toBytes(), handle, userId);</span><br><span class="line"> <span class="number">676</span>         createSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED, authToken,</span><br><span class="line"> <span class="number">677</span>                 applicationId, sid, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而unwrapPasswordBasedSyntheticPassword函数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为上面得handle 用户凭据  userId</span></span><br><span class="line">        <span class="type">AuthenticationResult</span> <span class="variable">authResult</span> <span class="operator">=</span> mSpManager.unwrapPasswordBasedSyntheticPassword(</span><br><span class="line"><span class="number">2776</span>                 getGateKeeperService(), handle, savedCredential, userId, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> AuthenticationResult <span class="title function_">unwrapPasswordBasedSyntheticPassword</span><span class="params">(IGateKeeperService gatekeeper,</span></span><br><span class="line"><span class="params"> <span class="number">861</span>             <span class="type">long</span> handle, <span class="type">byte</span>[] credential, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params"> <span class="number">862</span>             ICheckCredentialProgressCallback progressCallback)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"> <span class="number">866</span>         <span class="type">AuthenticationResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationResult</span>();</span><br><span class="line"> <span class="comment">//从中间文件解出 passworddata</span></span><br><span class="line"> <span class="number">867</span>         <span class="type">PasswordData</span> <span class="variable">pwd</span> <span class="operator">=</span> PasswordData.fromBytes(loadState(PASSWORD_DATA_NAME, handle, userId));</span><br><span class="line"> <span class="number">868</span>         result.credentialType = pwd.passwordType;</span><br><span class="line"> <span class="number">869</span>         <span class="type">byte</span>[] pwdToken = computePasswordToken(credential, pwd);</span><br><span class="line"><span class="comment">// 这中间走的分支都需要debug才能知道</span></span><br><span class="line"><span class="number">918</span>             sid = sidFromPasswordHandle(pwd.passwordHandle);</span><br><span class="line"> <span class="number">919</span>             applicationId = transformUnderSecdiscardable(pwdToken,</span><br><span class="line"> <span class="number">920</span>                     loadSecdiscardable(handle, userId));</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"> <span class="comment">// 需要参数 applicationId， sid</span></span><br><span class="line">        result.authToken = unwrapSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED,</span><br><span class="line"> <span class="number">928</span>                 applicationId, sid, userId);</span><br><span class="line"><span class="number">31</span>         result.gkResponse = verifyChallenge(gatekeeper, result.authToken, <span class="number">0L</span>, userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终要得到 authToken，进行验证得到的结果为gkResponse，然后再通过Spmanager的verifyChallenge验证challenge， 都为正确的，才说明密码是正确的。</span></span><br><span class="line">             <span class="keyword">if</span> (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &#123;</span><br><span class="line"><span class="number">2634</span>                 <span class="comment">// perform verifyChallenge with synthetic password which generates the real GK auth</span></span><br><span class="line"><span class="number">2635</span>                 <span class="comment">// token and response for the current user</span></span><br><span class="line"><span class="number">2636</span>                 response = mSpManager.verifyChallenge(getGateKeeperService(), authResult.authToken,</span><br><span class="line"><span class="number">2637</span>                         challenge, userId);</span><br><span class="line"><span class="number">2638</span>                 <span class="keyword">if</span> (response.getResponseCode() != VerifyCredentialResponse.RESPONSE_OK) &#123;</span><br><span class="line"><span class="number">2639</span>                     <span class="comment">// This shouldn&#x27;t really happen: the unwrapping of SP succeeds, but SP doesn&#x27;t</span></span><br><span class="line"><span class="number">2640</span>                     <span class="comment">// match the recorded GK password handle.</span></span><br><span class="line"><span class="number">2641</span>                     Slog.wtf(TAG, <span class="string">&quot;verifyChallenge with SP failed.&quot;</span>);</span><br><span class="line"><span class="number">2642</span>                     <span class="keyword">return</span> VerifyCredentialResponse.ERROR;</span><br><span class="line"><span class="number">2643</span>                 &#125;</span><br><span class="line"><span class="number">2644</span>             &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而文件密码与/data/system_de/0/spblob/下存储的文件，applicationId， 上面提到的handle有关</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationToken <span class="title function_">unwrapSyntheticPasswordBlob</span><span class="params">(<span class="type">long</span> handle, <span class="type">byte</span> type,</span></span><br><span class="line"><span class="params"> <span class="number">979</span>             <span class="type">byte</span>[] applicationId, <span class="type">long</span> sid, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"> <span class="number">980</span>         <span class="type">byte</span>[] blob = loadState(SP_BLOB_NAME, handle, userId);</span><br><span class="line"> <span class="number">981</span>         <span class="keyword">if</span> (blob == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="number">982</span>             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="number">983</span>         &#125;</span><br><span class="line"> <span class="number">984</span>         <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> blob[<span class="number">0</span>];</span><br><span class="line"> <span class="number">985</span>         <span class="keyword">if</span> (version != SYNTHETIC_PASSWORD_VERSION_V3</span><br><span class="line"> <span class="number">986</span>                 &amp;&amp; version != SYNTHETIC_PASSWORD_VERSION_V2</span><br><span class="line"> <span class="number">987</span>                 &amp;&amp; version != SYNTHETIC_PASSWORD_VERSION_V1) &#123;</span><br><span class="line"> <span class="number">988</span>             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown blob version&quot;</span>);</span><br><span class="line"> <span class="number">989</span>         &#125;</span><br><span class="line"> <span class="number">990</span>         <span class="keyword">if</span> (blob[<span class="number">1</span>] != type) &#123;</span><br><span class="line"> <span class="number">991</span>             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid blob type&quot;</span>);</span><br><span class="line"> <span class="number">992</span>         &#125;</span><br><span class="line"> <span class="number">993</span>         <span class="keyword">final</span> <span class="type">byte</span>[] secret;</span><br><span class="line"> <span class="number">994</span>         <span class="keyword">if</span> (version == SYNTHETIC_PASSWORD_VERSION_V1) &#123;</span><br><span class="line"> <span class="comment">// 解用户ce区文件的密码</span></span><br><span class="line"> <span class="number">995</span>             secret = SyntheticPasswordCrypto.decryptBlobV1(getHandleName(handle),</span><br><span class="line"> <span class="number">996</span>                     Arrays.copyOfRange(blob, <span class="number">2</span>, blob.length), applicationId);</span><br><span class="line"> <span class="number">997</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">998</span>             secret = decryptSPBlob(getHandleName(handle),</span><br><span class="line"> <span class="number">999</span>                 Arrays.copyOfRange(blob, <span class="number">2</span>, blob.length), applicationId);</span><br><span class="line"><span class="number">1000</span>         &#125;</span><br><span class="line"><span class="number">1005</span>         <span class="type">AuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationToken</span>(version);</span><br><span class="line"><span class="comment">// 这个地方也需要debug，应该是用的 SYNTHETIC_PASSWORD_TOKEN_BASED 方式</span></span><br><span class="line"></span><br><span class="line"><span class="number">1006</span>         <span class="keyword">if</span> (type == SYNTHETIC_PASSWORD_TOKEN_BASED) &#123;</span><br><span class="line"><span class="number">1007</span>             <span class="keyword">if</span> (!loadEscrowData(result, userId)) &#123;</span><br><span class="line"><span class="number">1008</span>                 Log.e(TAG, <span class="string">&quot;User is not escrowable: &quot;</span> + userId);</span><br><span class="line"><span class="number">1009</span>                 <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">1010</span>             &#125;</span><br><span class="line"><span class="number">1011</span>             result.recreate(secret);</span><br><span class="line"><span class="number">1012</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1013</span>             result.syntheticPassword = <span class="keyword">new</span> <span class="title class_">String</span>(secret);</span><br><span class="line"><span class="number">1014</span>         &#125;</span><br><span class="line"><span class="comment">// spblob格式升级</span></span><br><span class="line"><span class="number">1015</span>         <span class="keyword">if</span> (version == SYNTHETIC_PASSWORD_VERSION_V1) &#123;</span><br><span class="line"><span class="number">1016</span>             Log.i(TAG, <span class="string">&quot;Upgrade v1 SP blob for user &quot;</span> + userId + <span class="string">&quot;, type = &quot;</span> + type);</span><br><span class="line"><span class="number">1017</span>             createSyntheticPasswordBlob(handle, type, result, applicationId, sid, userId);</span><br><span class="line"><span class="number">1018</span>         &#125;</span><br><span class="line"><span class="number">1019</span>         <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">1020</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>上述过程，很多地方需要通过debug才能确定，需要进一步调研。查看哪些是可以拆解出来的。可以通过native程序解出来。</p>
<p>在keyguard解锁后校验密码的流程走的spblob的方式，在gatekeeper和keymaster的基础上对密码又做了一层封装。将spblob中间文件删除后，重启手机，用户ce区文件不能解密，重建spblob后也无法解密。用户ce区解锁也是每次开机加载机主用户时执行的，并不是每次解锁都会进行unlock。用户密码更新后，ce区密码也会更新，但该密码只是用来加密文件主密钥的密码，文件主密钥并没变，所以用户密码改变不需要重新解锁用户ce区，只需要更新中间文件spblob和&#x2F;data&#x2F;misc&#x2F;vold&#x2F;user_keys&#x2F;0&#x2F;current下的中间文件即可。<br>需要进一步调试跟踪各中间参数是怎样生成的， 最终效果是能模拟用户密码是否输入正确及推导出加密ce区主密钥的密钥</p>
<h2 id="1-4-debug-调试"><a href="#1-4-debug-调试" class="headerlink" title="1.4. debug 调试"></a>1.4. debug 调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">01-09 15:05:25.848  2575  2717 E LockPatternUtils: zlg:</span><br><span class="line">60167 01-09 15:05:25.848  2575  2717 E LockPatternUtils: java.lang.RuntimeException: checkCredential log</span><br><span class="line">60168 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.internal.widget.LockPatternUtils.checkCredential(LockPatternUtils.java:393)</span><br><span class="line">60169 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.internal.widget.LockPatternUtils.checkPattern(LockPatternUtils.java:447)</span><br><span class="line">60170 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.checkPattern(LockPatternChecker.java:91)</span><br><span class="line">60171 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.doInBackground(LockPatternChecker.java:49)</span><br><span class="line">60172 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at com.android.keyguard.LockPatternChecker$1.doInBackground(LockPatternChecker.java:39)</span><br><span class="line">60173 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at android.os.AsyncTask$3.call(AsyncTask.java:378)</span><br><span class="line">60174 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">60175 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">60176 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">60177 01-09 15:05:25.848  2575  2717 E LockPatternUtils: |at java.lang.Thread.run(Thread.java:919)</span><br><span class="line">60178 01-09 15:05:25.849  2115  2546 D LockSettingsService: spBasedDoVerifyCredential: user=0</span><br><span class="line">60179 01-09 15:05:25.850  2115  2546 E LockSettingsService: zlg :</span><br><span class="line">60180 01-09 15:05:25.850  2115  2546 E LockSettingsService: java.lang.RuntimeException: spBasedDoVerifyCredential log</span><br><span class="line">60181 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.spBasedDoVerifyCredential(LockSettingsService.java:2623)</span><br><span class="line">60182 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.doVerifyCredential(LockSettingsService.java:1875)</span><br><span class="line">60183 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.server.locksettings.LockSettingsService.checkCredential(LockSettingsService.java:1840)</span><br><span class="line">60184 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at com.android.internal.widget.ILockSettings$Stub.onTransact(ILockSettings.java:556)</span><br><span class="line">60185 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at android.os.Binder.execTransactInternal(Binder.java:1021)</span><br><span class="line">60186 01-09 15:05:25.850  2115  2546 E LockSettingsService: | at android.os.Binder.execTransact(Binder.java:994)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上述流程看，是走的checkPattern<br>图案解锁方式， 最后到checkCredential处，没有challenge，即challenge为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPattern</span><span class="params">(List&lt;LockPatternView.Cell&gt; pattern, <span class="type">int</span> userId)</span></span><br><span class="line"> <span class="number">433</span>             <span class="keyword">throws</span> RequestThrottledException &#123;</span><br><span class="line"> <span class="number">434</span>         <span class="keyword">return</span> checkPattern(pattern, userId, <span class="literal">null</span> <span class="comment">/* progressCallback */</span>);</span><br><span class="line"> <span class="number">435</span>     &#125;</span><br><span class="line"> <span class="number">436</span></span><br><span class="line"> <span class="number">437</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 438      * Check to see if a pattern matches the saved pattern.  If no pattern exists,</span></span><br><span class="line"><span class="comment"> 439      * always returns true.</span></span><br><span class="line"><span class="comment"> 440      * <span class="doctag">@param</span> pattern The pattern to check.</span></span><br><span class="line"><span class="comment"> 441      * <span class="doctag">@return</span> Whether the pattern matches the stored one.</span></span><br><span class="line"><span class="comment"> 442      */</span></span><br><span class="line"> <span class="number">443</span>     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPattern</span><span class="params">(List&lt;LockPatternView.Cell&gt; pattern, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params"> <span class="number">444</span>             <span class="meta">@Nullable</span> CheckCredentialProgressCallback progressCallback)</span></span><br><span class="line"> <span class="number">445</span>             <span class="keyword">throws</span> RequestThrottledException &#123;</span><br><span class="line"> <span class="number">446</span>         throwIfCalledOnMainThread();</span><br><span class="line"> <span class="number">447</span>         <span class="keyword">return</span> checkCredential(patternToByteArray(pattern), CREDENTIAL_TYPE_PATTERN, userId,</span><br><span class="line"> <span class="number">448</span>                 progressCallback);</span><br><span class="line"> <span class="number">449</span>     &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1837</span>     <span class="keyword">public</span> VerifyCredentialResponse <span class="title function_">checkCredential</span><span class="params">(<span class="type">byte</span>[] credential, <span class="type">int</span> type, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params"><span class="number">1838</span>             ICheckCredentialProgressCallback progressCallback)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="number">1839</span>         checkPasswordReadPermission(userId);</span><br><span class="line"><span class="comment">// 没有challenge</span></span><br><span class="line"><span class="number">1840</span>         <span class="type">VerifyCredentialResponse</span> <span class="variable">response</span> <span class="operator">=</span> doVerifyCredential(credential, type,</span><br><span class="line"><span class="number">1841</span>                                         <span class="literal">false</span>, <span class="number">0</span>, userId, progressCallback);</span><br><span class="line"><span class="number">1842</span>         <span class="keyword">if</span> ((response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) &amp;&amp;</span><br><span class="line"><span class="number">1843</span>                                            (userId == UserHandle.USER_OWNER)) &#123;</span><br><span class="line"><span class="number">1844</span>                 <span class="comment">//TODO(b/127810705): Update to credentials to use byte[]</span></span><br><span class="line"><span class="number">1845</span>                 <span class="type">String</span> <span class="variable">credentialString</span> <span class="operator">=</span> credential == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">String</span>(credential);</span><br><span class="line"><span class="number">1846</span>                 retainPassword(credentialString);</span><br><span class="line"><span class="number">1847</span>         &#125;</span><br><span class="line"><span class="number">1848</span>         <span class="keyword">return</span> response;</span><br><span class="line"><span class="number">1849</span>     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sid和applicationId是容易解出的， 根据上面debug的关键信息， 再跟一遍代码流程和参数的求解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/data/system_de/<span class="number">0</span>/spblob/4497efca1dd620f6.<span class="type">secdis</span></span><br><span class="line"><span class="variable">applicationId</span> <span class="operator">=</span> transformUnderSecdiscardable(pwdToken,</span><br><span class="line"> <span class="number">927</span>                     loadSecdiscardable(handle, userId));</span><br><span class="line">     <span class="keyword">private</span> <span class="type">byte</span>[] transformUnderSecdiscardable(<span class="type">byte</span>[] data, <span class="type">byte</span>[] rawSecdiscardable) &#123;</span><br><span class="line">     <span class="comment">// pwdToken 和 secdis文件内容联合做sha1-512</span></span><br><span class="line"><span class="number">1109</span>         <span class="type">byte</span>[] secdiscardable = SyntheticPasswordCrypto.personalisedHash(</span><br><span class="line"><span class="number">1110</span>                 PERSONALISATION_SECDISCARDABLE, rawSecdiscardable);</span><br><span class="line"><span class="number">1111</span>         <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[data.length + secdiscardable.length];</span><br><span class="line"><span class="number">1112</span>         System.arraycopy(data, <span class="number">0</span>, result, <span class="number">0</span>, data.length);</span><br><span class="line"><span class="number">1113</span>         System.arraycopy(secdiscardable, <span class="number">0</span>, result, data.length, secdiscardable.length);</span><br><span class="line"><span class="number">1114</span>         <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">1115</span>     &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nativeSidFromPasswordHandle-&gt;<span class="built_in">sidFromPasswordHandle</span>(pwd.passwordHandle);</span><br><span class="line"><span class="number">2</span><span class="function"><span class="type">static</span> jlong <span class="title">android_server_SyntheticPasswordManager_nativeSidFromPasswordHandle</span><span class="params">(JNIEnv* env, jobject, jbyteArray handleArray)</span> </span>&#123;</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span>    jbyte* data = (jbyte*)env-&gt;<span class="built_in">GetPrimitiveArrayCritical</span>(handleArray, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">37</span>        <span class="type">const</span> gatekeeper::<span class="type">password_handle_t</span> *handle =</span><br><span class="line"><span class="number">38</span>                <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> gatekeeper::<span class="type">password_handle_t</span> *&gt;(data);</span><br><span class="line"><span class="number">39</span>        jlong sid = handle-&gt;user_id;</span><br><span class="line"><span class="number">45</span>&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LockSettingsService: zlg: credential: [B@3ada1b6 hasChallenge: false challenge: 0 handle: 4942682767425413366</span><br><span class="line">SyntheticPasswordManager: zlg weaverSlot is INVALID_WEAVER_SLOT</span><br><span class="line">SyntheticPasswordManager: zlg: unwrapSyntheticPasswordBlob version not V1</span><br><span class="line">SyntheticPasswordManager: zlg: not unwrapSyntheticPasswordBlob type SYNTHETIC_PASSWORD_TOKEN_BASED</span><br><span class="line">LockSettingsService: zlg Unlocking user 0 with secret only, length 32 secret: [B@8fb4f53</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String <span class="title function_">getHandleName</span><span class="params">(<span class="type">long</span> handle)</span> &#123;</span><br><span class="line">  <span class="number">1182</span>         <span class="keyword">return</span> String.format(<span class="string">&quot;%s%x&quot;</span>, LockPatternUtils.SYNTHETIC_PASSWORD_KEY_PREFIX, handle);</span><br><span class="line">  <span class="number">1183</span>     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYNTHETIC_PASSWORD_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;synthetic_password_&quot;</span>;</span><br><span class="line"> <span class="type">byte</span>[] blob = loadState(SP_BLOB_NAME, handle, userId);</span><br><span class="line"> <span class="comment">// handle信息其实就是/data/system_de/0/spblob/&lt;handle&gt;.spblob</span></span><br><span class="line"> <span class="comment">// secret就是文件ce区主密钥的密钥， blob 是 /data/system_de/0/spblob/&lt;handle&gt;.spblob 读取的内容， applicationId是上面提到的sha1-512的值</span></span><br><span class="line">            secret = decryptSPBlob(getHandleName(handle),</span><br><span class="line">  <span class="number">1008</span>                 Arrays.copyOfRange(blob, <span class="number">2</span>, blob.length), applicationId);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptBlob(String keyAlias, <span class="type">byte</span>[] blob, <span class="type">byte</span>[] applicationId) &#123;</span><br><span class="line"><span class="number">139</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用 &quot;android.security.keystore&quot;的接口，这个地方注意KeyStore是java.Security.keyStore,是Java的公共接口</span></span><br><span class="line">源码在libcore/ojluni/src/main/java/java/security/KeyStore.java</span><br><span class="line"></span><br><span class="line"><span class="number">140</span>             <span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;AndroidKeyStore&quot;</span>);</span><br><span class="line"><span class="number">141</span>             keyStore.load(<span class="literal">null</span>);</span><br><span class="line"><span class="number">142</span></span><br><span class="line"><span class="number">143</span>             <span class="type">SecretKey</span> <span class="variable">decryptionKey</span> <span class="operator">=</span> (SecretKey) keyStore.getKey(keyAlias, <span class="literal">null</span>);</span><br><span class="line"><span class="number">144</span>             <span class="type">byte</span>[] intermediate = decrypt(decryptionKey, blob);</span><br><span class="line"><span class="number">145</span>             <span class="keyword">return</span> decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate);</span><br><span class="line"><span class="number">146</span>         &#125; </span><br><span class="line"></span><br><span class="line"><span class="number">1055</span>    <span class="keyword">public</span> <span class="keyword">final</span> Key <span class="title function_">getKey</span><span class="params">(String alias, <span class="type">char</span>[] password)</span></span><br><span class="line"><span class="number">1056</span>        <span class="keyword">throws</span> KeyStoreException, NoSuchAlgorithmException,</span><br><span class="line"><span class="number">1057</span>            UnrecoverableKeyException</span><br><span class="line"><span class="number">1058</span>    &#123;</span><br><span class="line"><span class="number">1062</span>        <span class="keyword">return</span> keyStoreSpi.engineGetKey(alias, password);</span><br><span class="line"><span class="number">1063</span>    &#125;</span><br><span class="line">这个keyStore的调用有点深，需要进一步查看， 最终进入了AndroidKeyStoreSpi.java内部</span><br></pre></td></tr></table></figure>


<p><code>KeyStore.getInstance(&quot;AndroidKeyStore&quot;)</code>返回的的是<code>AndroidKeyStoreSpi</code>的实例，调用<code>getKey</code>方法，最终调到了<code>AndroidKeyStoreSpi</code>的<code>engineGetKey</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/diegodu/p/6273611.html">ciper</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+- secret = decryptSPBlob&lt;getHandleName(handle), Arrays.copyOfRange(blob, 2, blob.length), applicationId&gt;  #SyntheticPasswordManager.java</span><br><span class="line">                                                            # handle blob applicationId 都可以解出</span><br><span class="line">  \ +- decryptBlob(String keyAlias, byte[] blob, byte[] applicationId)  # SyntheticPasswordCrypto.java</span><br><span class="line">    \ - KeyStore keyStore = KeyStore.getInstance(&quot;AndroidKeyStore&quot;);  #调用java se的公共接口，最终访问到了AndroidKeyStoreSpi</span><br><span class="line">    | +- keyStore.load(null); # AndroidkeyStoreSpi.engineLoad(param);</span><br><span class="line">       \ - android.security.KeyStore.getInstance  # 调用到了 native keyStore &quot;android.security.keystore&quot; 实例，构造AndroidKeyStoreSpi的mKeyStore 对象， 该对象持有remote 端， native的 keyStore service</span><br><span class="line">    | +- SecretKey decryptionKey = (SecretKey) keyStore.getKey(keyAlias, null);</span><br><span class="line">       \ +- AndroidkeyStoreSpi.engineGetKey(alias, password)   # passwd 为null， alias为 synthetic_password_&lt;handle&gt;值 getHandleName方法</span><br><span class="line">          \ - String userKeyAlias = Credentials.USER_PRIVATE_KEY + alias; # USERKEY_synthetic_password_&lt;handle&gt;</span><br><span class="line">          | +- key = AndroidKeyStoreProvider.loadAndroidKeyStoreKeyFromKeystore(mKeyStore, userKeyAlias, mUid);</span><br><span class="line">             \ - KeyCharacteristics keyCharacteristics = getKeyCharacteristics(keyStore, userKeyAlias, uid); # keyStore为上面实例的mKeyStore实例</span><br><span class="line">             | +- keyStore.getKeyCharacteristics(alias, null, null, uid, keyCharacteristics) # clientId为空 appid为空 android KeyStore.java</span><br><span class="line">          |      \ - mBinder.getKeyCharacteristics(promise, alias, clientId, appId, uid);  #key_store_service.cpp 这个clientId appId 是构造了两个KeymasterBlob[new byte[0]] 出来，native层也有相应的类， KeymasterBlob.h</span><br><span class="line">                | +- return loadAndroidKeyStoreSecretKeyFromKeystore(userKeyAlias, uid, keyCharacteristics)</span><br><span class="line">                   \ - Integer keymasterAlgorithm = keyCharacteristics.getEnum(KeymasterDefs.KM_TAG_ALGORITHM); #获得加密算法</span><br><span class="line">          |         | - List&lt;Integer&gt; keymasterDigests = keyCharacteristics.getEnums(KeymasterDefs.KM_TAG_DIGEST);</span><br><span class="line">                   | - keyAlgorithmString = fromKeymasterSecretKeyAlgorithm(keymasterAlgorithm, keymasterDigest); # 解出来为AES</span><br><span class="line">                   | +- return new AndroidKeyStoreSecretKey(secretKeyAlias, uid, keyAlgorithmString);</span><br><span class="line">          |           \ - AndroidKeyStoreKey(String alias, int uid, String algorithm) # mAlias mUid mAlgorithm   # AndroidKeyStoreKey 构造函数</span><br><span class="line">   | +- byte[] intermediate = decrypt(decryptionKey, blob); # SyntheticPasswordCrypto.java 获得key后进行解密 blob为spblob读出的数据</span><br><span class="line">      \ - byte[] iv = Arrays.copyOfRange(blob, 0, PROFILE_KEY_IV_SIZE); #初始化向量</span><br><span class="line">      | - byte[] ciphertext = Arrays.copyOfRange(blob, PROFILE_KEY_IV_SIZE, blob.length); # 密文</span><br><span class="line">      | - Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + &quot;/&quot;</span><br><span class="line">                  + KeyProperties.BLOCK_MODE_GCM + &quot;/&quot; + KeyProperties.ENCRYPTION_PADDING_NONE); # AES/GCM/NoPadding</span><br><span class="line">        \ - cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(DEFAULT_TAG_LENGTH_BITS, iv));   #解密数据 128 GCMParameterSpec怎么构造？ key为SecurityKey类型， C++怎么构造</span><br><span class="line">        | - return cipher.doFinal(ciphertext); # ciphertext是密文，解密出明文</span><br><span class="line">   | +- return decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate); # intermediate为上面Cipher解出的明文</span><br><span class="line">      \ - byte[] keyHash = personalisedHash(personalisation, keyBytes); # APPLICATION_ID_PERSONALIZATION 和 APPLICATION_ID_PERSONALIZATION</span><br><span class="line">      | - SecretKeySpec key = new SecretKeySpec(Arrays.copyOf(keyHash, AES_KEY_LENGTH), AES); # javax.crypto.spec.SecretKeySpec</span><br><span class="line">      | - decrypt(key, ciphertext) #此处ciphertext为上面的解出的intermediate， 重复上面的流程</span><br></pre></td></tr></table></figure>

<p>从keyStore的模型上看，涉及的模块较多，如果多机型是同样的解密算法的话，解密流程还是可以还原的。 但从实现上看，预估不同机型的不同平台上的解密插件是不同的，如果做定制的话，涉及的解析debug 转换java代码很多。 当前流程涉及到了很多java的sdk的类，这些类怎么转换成native的代码也是一个大问题。 而解密这块，目前涉及到AES&#x2F;GCM&#x2F;NoPadding的解密，native层可以使用openssl的库来完成。 ^a300bf</p>
<p>上述密码解出后，还有最后一步，即验证用户密码是否正确。<br>这个主要涉及到gatekeeper的校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">         result.authToken = unwrapSyntheticPasswordBlob(handle, SYNTHETIC_PASSWORD_PASSWORD_BASED,</span><br><span class="line"> <span class="number">937</span>                 applicationId, sid, userId);</span><br><span class="line"> <span class="number">938</span></span><br><span class="line"> <span class="number">939</span>         <span class="comment">// Perform verifyChallenge to refresh auth tokens for GK if user password exists.</span></span><br><span class="line"> <span class="number">940</span>         result.gkResponse = verifyChallenge(gatekeeper, result.authToken, <span class="number">0L</span>, userId);</span><br><span class="line"></span><br><span class="line"><span class="number">43</span>     <span class="keyword">public</span> <span class="meta">@Nullable</span> VerifyCredentialResponse <span class="title function_">verifyChallenge</span><span class="params">(IGateKeeperService gatekeeper,</span></span><br><span class="line"><span class="params">  <span class="number">1044</span>             <span class="meta">@NonNull</span> AuthenticationToken auth, <span class="type">long</span> challenge, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">  <span class="number">1045</span>         <span class="type">byte</span>[] spHandle = loadSyntheticPasswordHandle(userId);</span><br><span class="line">  <span class="number">1051</span>         VerifyCredentialResponse result;</span><br><span class="line">&gt; <span class="number">1052</span>         <span class="type">GateKeeperResponse</span> <span class="variable">response</span> <span class="operator">=</span> gatekeeper.verifyChallenge(userId, challenge,</span><br><span class="line">  <span class="number">1053</span>                 spHandle, auth.deriveGkPassword());</span><br><span class="line">  <span class="number">1054</span>         <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> response.getResponseCode();</span><br><span class="line">  <span class="number">1055</span>         <span class="keyword">if</span> (responseCode == GateKeeperResponse.RESPONSE_OK) &#123;</span><br><span class="line">  <span class="number">1056</span>             result = <span class="keyword">new</span> <span class="title class_">VerifyCredentialResponse</span>(response.getPayload());</span><br><span class="line">  <span class="number">1057</span>             <span class="keyword">if</span> (response.getShouldReEnroll()) &#123;</span><br><span class="line">  <span class="number">1058</span>                 response = gatekeeper.enroll(userId, spHandle,</span><br><span class="line">  <span class="number">1059</span>                         spHandle, auth.deriveGkPassword());</span><br><span class="line">  <span class="number">1060</span>                 <span class="keyword">if</span> (response.getResponseCode() == GateKeeperResponse.RESPONSE_OK) &#123;</span><br><span class="line">  <span class="number">1061</span>                     spHandle = response.getPayload();</span><br><span class="line">  <span class="number">1062</span>                     saveSyntheticPasswordHandle(spHandle, userId);</span><br><span class="line">  <span class="number">1063</span>                     <span class="comment">// Call self again to re-verify with updated handle</span></span><br><span class="line">&gt; <span class="number">1064</span>                     <span class="keyword">return</span> verifyChallenge(gatekeeper, auth, challenge, userId);</span><br><span class="line">  <span class="number">1065</span>                 &#125;</span><br><span class="line">  <span class="number">1069</span>             &#125;</span><br><span class="line">  <span class="number">1070</span>         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseCode == GateKeeperResponse.RESPONSE_RETRY) &#123;</span><br><span class="line">  <span class="number">1071</span>             result = <span class="keyword">new</span> <span class="title class_">VerifyCredentialResponse</span>(response.getTimeout());</span><br><span class="line">  <span class="number">1072</span>         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="number">1073</span>             result = VerifyCredentialResponse.ERROR;</span><br><span class="line">  <span class="number">1074</span>         &#125;</span><br><span class="line">  <span class="number">1075</span>         <span class="keyword">return</span> result;</span><br><span class="line">  <span class="number">1076</span>     &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++-- verifyChallenge --+++++++++</span><br><span class="line">+- verifyChallenge(gatekeeper, result.authToken, 0L, userId); #SyntheticPasswordManager.java</span><br><span class="line">  \ - byte[] spHandle = loadSyntheticPasswordHandle(userId); # /data/system_de/0/spblob/*.handle</span><br><span class="line">  | - response = gatekeeper.verifyChallenge(userId, challenge, spHandle, auth.deriveGkPassword()); # chanllenge 为 0</span><br><span class="line">     \ +- auth.deriveGkPassword()</span><br><span class="line">        \ -  derivePassword(PERSONALIZATION_SP_GK_AUTH)</span><br><span class="line">          \ - new SP800Derive(syntheticPassword.getBytes().withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT);</span><br><span class="line">            \ - Mac m = Mac.getInstance(&quot;HmacSHA256&quot;); m.init(new SecretKeySpec(syntheticPassword, m.getAlgorithm())); # javax.crypto.Mac</span><br><span class="line">              \ - spi.engineInit(key, params); #javax/crypto/Mac.java</span><br><span class="line">     |          \ - init(key, params) #AndroidKeyStoreHmacSpi.java params为空</span><br><span class="line">                | - ensureKeystoreOperationInitialized()</span><br><span class="line">                   \ - mKeyStore.begin(mKey.getAlias(), KeymasterDefs.KM_PURPOSE_SIGN, true,keymasterArgs, ... )</span><br><span class="line">                      \ - mBinder.begin(promise, getToken(), alias, purpose, pruneable, args, entropy, uid) # /system/core/keystore</span><br><span class="line">                      | - mChunkedStreamer = new KeyStoreCryptoOperationChunkedStreamer(</span><br><span class="line">                            new KeyStoreCryptoOperationChunkedStreamer.MainDataStream(</span><br><span class="line">                            mKeyStore, mOperationToken));    #后面update会用到,保存keystore和oprationtoken</span><br><span class="line">            | - withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT); #SP800Derive</span><br><span class="line">               \ - m.update(label);</span><br><span class="line">     |             \ - engineUpdate(new byte[] &#123;input&#125;, 0, 1);</span><br><span class="line">                      \ -  mChunkedStreamer.update(input, offset, len)</span><br><span class="line">                         \ - mKeyStoreStream.update(chunk)</span><br><span class="line">                             \ - mKeyStore.update(mOperationToken, null, input)</span><br><span class="line">                                 \ - mBinder.update(promise, token, arguments, input)</span><br><span class="line">               | - m.doFinal()      #SP800Derive.java</span><br><span class="line">                  \ - spi.engineDoFinal()</span><br><span class="line">                      \ -  engineDoFinal()</span><br><span class="line">                          \ - return result = mChunkedStreamer.doFinal(null, 0, 0, null, null);</span><br><span class="line">                             \ - output = update(input, inputOffset, inputLength)</span><br><span class="line">                                 \ - mKeyStoreStream.update(chunk)</span><br><span class="line">                                     \ - mKeyStore.update(mOperationToken, null, input)</span><br><span class="line">                                        \ - mBinder.update(promise, token, arguments, input)</span><br><span class="line">                             | -  mKeyStoreStream.finish(signature, additionalEntropy)</span><br><span class="line">                                 \ - mKeyStore.finish(mOperationToken, null, signature, additionalEntropy)</span><br><span class="line">                                     \ - mBinder.finish(promise, token, arguments, signature, entropy);</span><br><span class="line">                  | - spi.engineReset()</span><br><span class="line">                     \ - resetWhilePreservingInitState()</span><br><span class="line">     | - verifyChallenge(uid, challenge, (uint8_t *) currentPasswordHandle,</span><br><span class="line">                    currentPasswordHandleSize, (uint8_t *) currentPassword, currentPasswordSize,</span><br><span class="line">                    &amp;out, &amp;outSize, &amp;request_reenroll); # system/core/gatekeeperd/IGateKeeperService.cpp</span><br><span class="line">        \ -  verifyChallenge(uint32_t uid, uint64_t challenge,</span><br><span class="line">            const uint8_t *enrolled_password_handle, uint32_t enrolled_password_handle_length,</span><br><span class="line">            const uint8_t *provided_password, uint32_t provided_password_length,</span><br><span class="line">            uint8_t **auth_token, uint32_t *auth_token_length, bool *request_reenroll) #gatekeeperd.cpp 返回结果为auth_token, 如执行成功，                                                         reply-&gt;writeInt32(GATEKEEPER_RESPONSE_OK); reply-&gt;writeInt32(request_reenroll ? 1 : 0);</span><br><span class="line">  | - result = new VerifyCredentialResponse(response.getPayload()); # 执行成功，校验成功满足 GATEKEEPER_RESPONSE_OK 条件</span><br><span class="line">     \ -  mResponseCode = RESPONSE_OK;   #  VerifyCredentialResponse payload构造函数</span><br><span class="line">  | - response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK # 校验成功， 解锁成功</span><br></pre></td></tr></table></figure>

<p>经过debug， Mac.getInstance(“HmacSHA256”)，并init后得到的并不是<code>AndroidKeyStoreHmacSpi</code>的实例，而是OpenSSLMac，代码位于<code>/external/conscrypt/repackaged/common/src/main/java/com/android/org/conscrypt/</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-09 17:41:15.323  2608  2833 E zlg:    : getMac: spi com.android.org.conscrypt.OpenSSLMac.HmacSHA256 getProvider: com.android.org.conscrypt.OpenSSLProvider</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++-- verifyChallenge --+++++++++</span><br><span class="line">+- verifyChallenge(gatekeeper, result.authToken, 0L, userId); #SyntheticPasswordManager.java</span><br><span class="line">  \ - byte[] spHandle = loadSyntheticPasswordHandle(userId); # /data/system_de/0/spblob/*.handle</span><br><span class="line">  | - response = gatekeeper.verifyChallenge(userId, challenge, spHandle, auth.deriveGkPassword()); # chanllenge 为 0</span><br><span class="line">     \ +- auth.deriveGkPassword()</span><br><span class="line">        \ -  derivePassword(PERSONALIZATION_SP_GK_AUTH)</span><br><span class="line">          \ - new SP800Derive(syntheticPassword.getBytes().withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT);</span><br><span class="line">            \ - Mac m = Mac.getInstance(&quot;HmacSHA256&quot;); m.init(new SecretKeySpec(syntheticPassword, m.getAlgorithm())); # javax.crypto.Mac</span><br><span class="line">              \ - super(EvpMdRef.SHA256.EVP_MD, EvpMdRef.SHA256.SIZE_BYTES); #OpenSSLMac.java </span><br><span class="line">                 \ - NativeCrypto.EVP_get_digestbyname(&quot;sha256&quot;) # libopenssl</span><br><span class="line">              | - spi.engineInit(key, params); #javax/crypto/Mac.java</span><br><span class="line">                \ - resetContext(); #OpenSSLMac.java</span><br><span class="line">                  \ - new NativeRef.HMAC_CTX(NativeCrypto.HMAC_CTX_new()) #libopenssl</span><br><span class="line">                  | - NativeCrypto.HMAC_Init_ex(ctxLocal, keyBytes, evp_md)</span><br><span class="line">            | - withContext(PERSONALIZATION_SP_GK_AUTH, PERSONALISATION_CONTEXT); #SP800Derive</span><br><span class="line">               \ - m.update(label);</span><br><span class="line">     |             \ - engineUpdate(singleByte, 0, 1); # OpenSSLMac.java</span><br><span class="line">                      \ -  NativeCrypto.HMAC_Update(ctxLocal, input, offset, len) #OpenSSLMac.java</span><br><span class="line">               | - m.doFinal()      #SP800Derive.java</span><br><span class="line">                  \ - spi.engineDoFinal()</span><br><span class="line">                     \ - engineDoFinal() #OpenSSLMac.java</span><br><span class="line">                        \ - output = NativeCrypto.HMAC_Final(ctxLocal); # libopenssl</span><br><span class="line">                        | - resetContext();</span><br><span class="line">     | - verifyChallenge(uid, challenge, (uint8_t *) currentPasswordHandle,</span><br><span class="line">                    currentPasswordHandleSize, (uint8_t *) currentPassword, currentPasswordSize,</span><br><span class="line">                    &amp;out, &amp;outSize, &amp;request_reenroll); # system/core/gatekeeperd/IGateKeeperService.cpp</span><br><span class="line">        \ -  verifyChallenge(uint32_t uid, uint64_t challenge,</span><br><span class="line">            const uint8_t *enrolled_password_handle, uint32_t enrolled_password_handle_length,</span><br><span class="line">            const uint8_t *provided_password, uint32_t provided_password_length,</span><br><span class="line">            uint8_t **auth_token, uint32_t *auth_token_length, bool *request_reenroll) #gatekeeperd.cpp 返回结果为auth_token, 如执行成功，                                                         reply-&gt;writeInt32(GATEKEEPER_RESPONSE_OK); reply-&gt;writeInt32(request_reenroll ? 1 : 0);</span><br><span class="line">  | - result = new VerifyCredentialResponse(response.getPayload()); # 执行成功，校验成功满足 GATEKEEPER_RESPONSE_OK 条件</span><br><span class="line">     \ -  mResponseCode = RESPONSE_OK;   #  VerifyCredentialResponse payload构造函数</span><br><span class="line">  | - response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK # 校验成功， 解锁成功</span><br></pre></td></tr></table></figure>
<p>从上述实现看， OpenSSLMac 的实现相对比较简单，都是直接调到native 的libopenssl库中，而AndroidKeyStoreHmacSpi的实现方式则复杂很多，本身上层代码经过了很复杂的处理，最后又通过keystore进行加解密。</p>
<h3 id="1-4-1-Cipher-封装"><a href="#1-4-1-Cipher-封装" class="headerlink" title="1.4.1. Cipher 封装"></a>1.4.1. Cipher 封装</h3><p>测试下来，Cipher 的AES解密成功的条件是gatekeeper需要先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gatekeeper.verifyChallenge(fakeUid(userId), <span class="number">0L</span>,</span><br><span class="line"> <span class="number">898</span>                     pwd.passwordHandle, gkPwdToken)；</span><br></pre></td></tr></table></figure>
<p>这里有必要对Cipher AES的Android封装过程调研一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptBlob(String keyAlias, <span class="type">byte</span>[] blob, <span class="type">byte</span>[] applicationId) &#123;</span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;AndroidKeyStore&quot;</span>);</span><br><span class="line">            keyStore.load(<span class="literal">null</span>);</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">decryptionKey</span> <span class="operator">=</span> (SecretKey) keyStore.getKey(keyAlias, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">byte</span>[] intermediate = decrypt(decryptionKey, blob);</span><br><span class="line">            <span class="keyword">return</span> decrypt(applicationId, APPLICATION_ID_PERSONALIZATION, intermediate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(SecretKey key, <span class="type">byte</span>[] blob)</span><br><span class="line">            <span class="keyword">throws</span> NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,</span><br><span class="line">            InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException &#123;</span><br><span class="line">        <span class="type">byte</span>[] iv = Arrays.copyOfRange(blob, <span class="number">0</span>, PROFILE_KEY_IV_SIZE);</span><br><span class="line">        <span class="type">byte</span>[] ciphertext = Arrays.copyOfRange(blob, PROFILE_KEY_IV_SIZE, blob.length);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + KeyProperties.BLOCK_MODE_GCM + <span class="string">&quot;/&quot;</span> + KeyProperties.ENCRYPTION_PADDING_NONE);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key, <span class="keyword">new</span> <span class="title class_">GCMParameterSpec</span>(DEFAULT_TAG_LENGTH_BITS, iv));</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(ciphertext);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面的过程如keystore的getInstace 和 load函数大部分都调研完了，需要注意的是Cipher的这个地方还没看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">+ - Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">  \ - javax.crypto.Cipher.createCipher(trans, null)</span><br><span class="line">     \ -  cipherSpiAndProvider =  tryCombinations(null /*params*/, null, tokenizedTransformation);</span><br><span class="line">        \ -  CipherSpiAndProvider sap = tryTransformWithProvider(null, tokenizedTransformation, transform.needToSet, service); #获得对应的Provider，这个应该最终指向了 android.security.keystore.AndroidKeyStoreBCWorkaroundProvider</span><br><span class="line">           \ - Cipher spi = sap.cipherSpi   # 指向AndroidKeyStoreCipherSpiBase.java</span><br><span class="line">| - cipher.init(Cipher.DECRYPT_MODE, key, new GCMParameterSpec(DEFAULT_TAG_LENGTH_BITS, iv)); #SyntheticPasswordCrypto.java</span><br><span class="line">   \ - init(opmode, key, params, JceSecurity.RANDOM); #Cipher.java</span><br><span class="line">      \ - chooseProvider(InitType.ALGORITHM_PARAM_SPEC, DECRYPT_MODE, key, params, null, random);</span><br><span class="line">         \ - spiAndProviderUpdater.updateAndGetSpiAndProvider(initParams, spi, provider);</span><br><span class="line">           \ - tryTransformWithProvider(initParams, tokenizedTransformation, transform.needToSet, service);</span><br><span class="line">              \ - spi.engineSetMode(tokenizedTransformation[1]);</span><br><span class="line">              | - spi.engineSetPadding(tokenizedTransformation[2]);</span><br><span class="line">              | - spi.engineInit(initParams.opmode, initParams.key, initParams.spec, initParams.random);</span><br><span class="line">                \ -  init(opmode, key, random); </span><br><span class="line">                | - initAlgorithmSpecificParameters(params);</span><br><span class="line">                | - ensureKeystoreOperationInitialized();</span><br><span class="line">                   \ -  byte[] additionalEntropy = EmptyArray.BYTE;</span><br><span class="line">                   | - KeymasterArguments keymasterInputArgs = new KeymasterArguments();</span><br><span class="line">                   | - purpose = KeymasterDefs.KM_PURPOSE_DECRYPT;</span><br><span class="line">                   | - mKeyStore.begin(mKey.getAlias(), purpose, true, keymasterInputArgs, additionalEntropy, mKey.getUid()); #调进native的keystore中                              </span><br><span class="line">| - cipher.doFinal(ciphertext) #SyntheticPasswordCrypto.java</span><br><span class="line">   \ - updateProviderIfNeeded(); </span><br><span class="line">      \ - spiAndProviderUpdater.updateAndGetSpiAndProvider(null, spi, provider);</span><br><span class="line">        \ - return new CipherSpiAndProvider(sap.cipherSpi, sap.provider); </span><br><span class="line">   | -  return spi.engineDoFinal(input, 0, input.length);</span><br><span class="line">      \ - ensureKeystoreOperationInitialized()</span><br><span class="line">          \ -  byte[] additionalEntropy = EmptyArray.BYTE;</span><br><span class="line">          | - KeymasterArguments keymasterInputArgs = new KeymasterArguments();</span><br><span class="line">          | - purpose = KeymasterDefs.KM_PURPOSE_DECRYPT;</span><br><span class="line">          | - OperationResult opResult = mKeyStore.begin(mKey.getAlias(), purpose, true, keymasterInputArgs, additionalEntropy, mKey.getUid()); #调进native的keystore中</span><br><span class="line">          | - loadAlgorithmSpecificParametersFromBeginResult(opResult.outParams)</span><br><span class="line">             \ - byte[] returnedIv = keymasterArgs.getBytes(KeymasterDefs.KM_TAG_NONCE, null);</span><br><span class="line">             | - if (mIvRequired) mIv = returnedIv  # mIvRequired应该是false，没看到赋值的地方，可以加log验证</span><br><span class="line">          | - mMainDataStreamer = createMainDataStreamer(mKeyStore, opResult.token); #mKeyStore为android KeyStore的instance，其对端即为native的keystore</span><br><span class="line">             \ - return new KeyStoreCryptoOperationChunkedStreamer(                                                                                                                          </span><br><span class="line">                     new KeyStoreCryptoOperationChunkedStreamer.MainDataStream(keyStore, operationToken)); # 用到了keystore返回的参数token</span><br><span class="line">          |- mAdditionalAuthenticationDataStreamer = createAdditionalAuthenticationDataStreamer(mKeyStore, opResult.token); </span><br><span class="line">             \ - return new KeyStoreCryptoOperationChunkedStreamer(</span><br><span class="line">                    new AdditionalAuthenticationDataStream(keyStore, operationToken)); </span><br><span class="line">      | - flushAAD()</span><br><span class="line">         \ - output = mAdditionalAuthenticationDataStreamer.doFinal(EmptyArray.BYTE, 0 , 0 ,null, null);</span><br><span class="line">            \ - output = update(input, inputOffset, inputLength);</span><br><span class="line">               \ - mKeyStoreStream.update(chunk)  #经过了复杂的流程，最终调到这里 </span><br><span class="line">                  \ - keymasterArgs.addBytes(KeymasterDefs.KM_TAG_ASSOCIATED_DATA, input);</span><br><span class="line">                  | - mKeyStore.update(mOperationToken, keymasterArgs, null);    #AdditionalAuthenticationDataStream  # - 1.</span><br><span class="line">                     \ - output = new OperationResult(result.resultCode, result.token, result.operationHandle, input.length, result.output, result.outParams);</span><br><span class="line">            | - output = ArrayUtils.concat(output, flush()); #flush又是一个复杂的函数     </span><br><span class="line">            | - OperationResult opResult = mKeyStoreStream.finish(null, null)；</span><br><span class="line">               \ - return new OperationResult(KeyStore.NO_ERROR, mOperationToken, 0 ,0 , EmptyArray.BYTE, new KeymasterArguments());</span><br><span class="line">            | - return ArrayUtils.concat(output, opResult.output);</span><br><span class="line">      | - output = mMainDataStreamer.doFinal(input, offset, len, null, EmptyArray.BYTE);</span><br><span class="line">         \ - output = update(input, inputOffset, inputLength);</span><br><span class="line">            \ - mKeyStoreStream.update(chunk)  #经过了复杂的流程，最终调到这里</span><br><span class="line">               \ -  return mKeyStore.update(mOperationToken, null, input);  # - 2. </span><br><span class="line">         | - output = ArrayUtils.concat(output, flush()); #flush又是一个复杂的函数     </span><br><span class="line">         | - OperationResult opResult = mKeyStoreStream.finish(null, EmptyArray.BYTE)；</span><br><span class="line">           \ - opResult = mKeyStore.finish(mOperationToken, null, null, EmptyArray.BYTE); # - 3.</span><br><span class="line">         | - return ArrayUtils.concat(output, opResult.output);</span><br><span class="line">         | - return output</span><br></pre></td></tr></table></figure>
<p>从上面的流程看，经历的过程很复杂，而经过native keystore的操作有</p>
<ol>
<li>mKeyStore.update(mOperationToken, keymasterArgs, null);</li>
<li>mKeyStore.update(mOperationToken, null, input);</li>
<li>mKeyStore.finish(mOperationToken, null, null, EmptyArray.BYTE);<br>最终finish 结束了访问， 获得了结果， 而再keystore update 和 finish前 Java层又经过了一系列的转换数据的操作。包括数据分片的处理</li>
</ol>
<p>gatekeeperd 守护进程会向 Android 框架 API 授予访问 HAL 的权限，并且会参与向 Keystore 报告设备身份验证的活动。gatekeeperd 守护进程会在自己的进程中运行，与系统服务器隔离开来。</p>
<p>LockSettingsService 会通过 Binder 发出一个请求，该请求会到达 Android 操作系统中的 gatekeeperd 守护进程。gatekeeperd 守护进程会发出一个请求，该请求会到达此守护进程在 TEE 中的副本 (Gatekeeper)：</p>
<p><img src="/images/20200527161613.png" alt="gatekeeper"></p>
<p>每次密码验证成功时生成的身份验证令牌 (AuthToken)<br>用户安全 ID (SID)</p>
<p>每当用户注册新密码时，如果未提供之前的密码，系统就会使用加密伪随机数生成器 (PRNG) 生成一个用户 SID。这称为“不可信”重新注册，在正常情况下，Android 框架不允许进行这种操作。如果用户提供了之前的有效密码，便会发生“可信”重新注册；在这种情况下，用户 SID 会迁移到新密码句柄，从而保留绑定到它的密钥。</p>
<p>注册密码时，用户 SID 会随密码句柄中的密码一起接受 HMAC 处理。<br>用户 SID 会写入到 verify 函数返回的 AuthToken 中，并且会同所有与身份验证绑定的 Keystore 密钥相关联（如需详细了解 AuthToken 格式和 Keystore，请参阅身份验证）。由于对 enroll 函数的不可信调用会更改用户 SID，因此此类调用会使绑定到相应密码的密钥无法再使用。攻击者在控制 Android 操作系统后可以更改设备密码，但在此过程中，他们需要破坏掉受 Root 保护的敏感密钥。</p>
<h4 id="1-4-1-1-身份验证"><a href="#1-4-1-1-身份验证" class="headerlink" title="1.4.1.1. 身份验证"></a>1.4.1.1. 身份验证</h4><p>用户设置凭据并收到用户 SID 后，便可以开始进行身份验证，身份验证从用户提供 PIN 码、解锁图案、密码或指纹开始。所有 TEE 组件都共用一个密钥来验证对方的消息。</p>
<p><img src="/images/20200527161620.png" alt="身份验证"></p>
<p>对于 PIN 码、解锁图案或密码，LockSettingsService 会向 gatekeeperd 发出请求。守护进程将数据发至其副本，后者生成 AuthToken：对于 PIN 码&#x2F;解锁图案&#x2F;密码身份验证，gatekeeperd 将 PIN 码、解锁图案或密码哈希发送到 TEE 中的 Gatekeeper。如果 TEE 中的身份验证成功，TEE 中的 Gatekeeper 会将包含相应用户 SID（已使用 AuthToken HMAC 密钥签名）的 AuthToken 发送到它在 Android 操作系统中的副本。<br>守护进程收到经过签名的 AuthToken，并通过 Keystore 服务 Binder 接口的扩展程序将 AuthToken 传递给 Keystore 服务。（gatekeeperd 还会在设备被重新锁定以及设备密码发生变化时通知 Keystore 服务。）<br>Keystore 服务将 AuthToken 传递给 Keymaster，并使用与 Gatekeeper 和支持的生物识别 TEE 组件共用的密钥来验证这些 AuthToken。Keymaster 会将令牌中的时间戳视为最后一次身份验证的时间，并根据该时间戳做出密钥发布决定（以允许应用使用相应密钥）。</p>
<p>debug验证时，keystore解密的工作前需要gatekeeper先通过对用户密码的验证，验证正确后，gatekeeperd 守护进程会向 Android 框架 API 授予访问 HAL 的权限，并且会参与向 Keystore 报告设备身份验证的活动。keystore才可以使用，而在apk demo中碰到了<code>android.security.KeyStoreException: Signature/MAC verification failed </code>的问题，在手机解锁后执行也报这样的错误，可能与gatekeeper的授权有关。因为gatekeeper的访问不在public api中，需要进一步在编译系统中构建应用验证。如果没有验证用户安全密码，则会报<code>android.security.keystore.KeyPermanentlyInvalidatedException: Key permanently invalidated</code>的异常。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/fbe/" rel="tag"># fbe</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/20/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/clion%20%E9%98%85%E8%AF%BB%E8%B0%83%E8%AF%95Android%20native%E6%BA%90%E7%A0%81/" rel="prev" title="clion vscode 阅读Android native源码">
      <i class="fa fa-chevron-left"></i> clion vscode 阅读Android native源码
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/12/OTA%E7%9B%B8%E5%85%B3/f2fs%20gc/" rel="next" title="f2fs gc">
      f2fs gc <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-fbe%E4%B8%8E%E7%94%A8%E6%88%B7%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">1. fbe与用户安全密码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%94%A8%E6%88%B7ce%E5%8C%BA%E6%96%87%E4%BB%B6%E8%A7%A3%E5%AF%86"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 用户ce区文件解密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-spblob%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B%E8%B7%9F%E8%BF%9B"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. spblob方式流程跟进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-debug-%E8%B0%83%E8%AF%95"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. debug 调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-Cipher-%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. Cipher 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-1-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.4.1.1. 身份验证</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">269</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

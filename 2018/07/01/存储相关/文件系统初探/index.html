<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW WenKai:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":true,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="1. VFSVFS以一组通用对象看待所有文件系统.  超级块(SuperBlock) 索引节点(inode) 目录项(dentry) 文件(struct file)  1.1. 超级块 sb超级块代表一个已经安装的文件系统,存储该文件系统的有关信息(如类型\大小\状态等)   对基于磁盘的文件系统, 该对象通常存放在磁盘的特定扇区上; 对非磁盘的(如sysfs),现场创建保存在内存中   1234">
<meta property="og:type" content="article">
<meta property="og:title" content="文件系统初探">
<meta property="og:url" content="https://liguangzhang.github.io/2018/07/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="1. VFSVFS以一组通用对象看待所有文件系统.  超级块(SuperBlock) 索引节点(inode) 目录项(dentry) 文件(struct file)  1.1. 超级块 sb超级块代表一个已经安装的文件系统,存储该文件系统的有关信息(如类型\大小\状态等)   对基于磁盘的文件系统, 该对象通常存放在磁盘的特定扇区上; 对非磁盘的(如sysfs),现场创建保存在内存中   1234">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-16T10:07:22.609Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liguangzhang.github.io/2018/07/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'" />

  <title>文件系统初探 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2018/07/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          文件系统初探
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">2018-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 18:07:22" itemprop="dateModified" datetime="2024-04-16T18:07:22+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">文件系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-VFS"><a href="#1-VFS" class="headerlink" title="1. VFS"></a>1. VFS</h1><p>VFS以一组通用对象看待所有文件系统.</p>
<ul>
<li>超级块(SuperBlock)</li>
<li>索引节点(inode)</li>
<li>目录项(dentry)</li>
<li>文件(struct file)</li>
</ul>
<h2 id="1-1-超级块-sb"><a href="#1-1-超级块-sb" class="headerlink" title="1.1. 超级块 sb"></a>1.1. 超级块 sb</h2><p>超级块代表一个已经安装的文件系统,存储该文件系统的有关信息(如类型\大小\状态等)</p>
<blockquote>
<ol>
<li>对基于<code>磁盘</code>的文件系统, 该对象通常存放在磁盘的特定扇区上;</li>
<li>对<code>非磁盘</code>的(如sysfs),现场创建保存在内存中</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">super_block</span> &#123;</span><br><span class="line">    <span class="comment">//用于形成超级块链表</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	s_list;		<span class="comment">/* Keep this first */</span></span><br><span class="line">    <span class="comment">// 所属文件系统所在的设备描述符</span></span><br><span class="line">	<span class="type">dev_t</span>			s_dev;		<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">    <span class="comment">// 一个块需要几个bit表示, 如块为1024字节, 该处就是10 块大小的就位数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		s_blocksize_bits;</span><br><span class="line">    <span class="comment">// 块大小, 以字节为单位.</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		s_blocksize;</span><br><span class="line">	<span class="type">loff_t</span>			s_maxbytes;	<span class="comment">/* Max file size */</span></span><br><span class="line">    <span class="comment">// 文件系统类型</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_system_type</span>	*s_type;</span><br><span class="line">    <span class="comment">// 超级块操作</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">super_operations</span>	*s_op;</span><br><span class="line">    <span class="comment">// VFS磁盘限额处理方法</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dquot_operations</span>	*dq_op;</span><br><span class="line">    <span class="comment">// 用于配置磁盘限额的方法,处理来自用户空间的请求</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">quotactl_ops</span>	*s_qcop;</span><br><span class="line">    <span class="comment">// 导出的方法, 从NFS服务器中共享目录又称导出目录</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">export_operations</span> *s_export_op;</span><br><span class="line">    <span class="comment">// mount的flag,</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		s_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		s_iflags;	<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">    <span class="comment">// 魔数,用于识别文件系统</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		s_magic;</span><br><span class="line">    <span class="comment">// 文件系统的根目录的目录项对象, 从文件系统的超级块可以读到任何一个文件, 前提是知道根目录在哪里. </span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span>		*s_root;</span><br><span class="line">    <span class="comment">// 卸载所用的信号量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rw_semaphore</span>	s_umount;</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">	<span class="type">int</span>			s_count;</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">	<span class="type">atomic_t</span>		s_active;</span><br><span class="line">    <span class="comment">// 指向超级块扩展属性结构的指针</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">xattr_handler</span> **s_xattr;</span><br><span class="line">    <span class="comment">// 加密相关的操作</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">fscrypt_operations</span>	*s_cop;</span><br><span class="line">    <span class="comment">// 要导出的匿名目录项的列表    </span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_bl_head</span>	s_anon;		<span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	s_mounts;	<span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">block_device</span>	*s_bdev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">backing_dev_info</span> *s_bdi;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mtd_info</span>		*s_mtd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_node</span>	s_instances;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		s_quota_types;	<span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">quota_info</span>	s_dquot;	<span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sb_writers</span>	s_writers;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> s_id[<span class="number">32</span>];				<span class="comment">/* Informational name */</span></span><br><span class="line">	u8 s_uuid[<span class="number">16</span>];				<span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> 			*s_fs_info;	<span class="comment">/* Filesystem private info */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		s_max_links;</span><br><span class="line">	<span class="type">fmode_t</span>			s_mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">	   Cannot be worse than a second */</span></span><br><span class="line">	u32		   s_time_gran;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">	 * even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span> s_vfs_rename_mutex;	<span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">	 * in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Saved mount options for lazy filesystems using</span></span><br><span class="line"><span class="comment">	 * generic_show_options()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> __rcu *s_options;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dentry_operations</span> *s_d_op; <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Saved pool identifier for cleancache (-1 means none)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> cleancache_poolid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">shrinker</span> s_shrink;	<span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">	<span class="type">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Being remounted read-only */</span></span><br><span class="line">	<span class="type">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">workqueue_struct</span> *s_dio_done_wq;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span> s_pins;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep the lru lists last in the structure so they always sit on their</span></span><br><span class="line"><span class="comment">	 * own individual cachelines.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_lru</span>		s_dentry_lru ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_lru</span>		s_inode_lru ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span>		rcu;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">work_struct</span>	destroy_work;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		s_sync_lock;	<span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		s_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	s_inodes;	<span class="comment">/* all inodes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-超级块操作"><a href="#1-1-1-超级块操作" class="headerlink" title="1.1.1. 超级块操作"></a>1.1.1. 超级块操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">super_operations</span> &#123;</span><br><span class="line">   	<span class="keyword">struct</span> <span class="title class_">inode</span> *(*alloc_inode)(<span class="keyword">struct</span> super_block *sb);</span><br><span class="line">	<span class="built_in">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">   	<span class="built_in">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span> flags);</span><br><span class="line">	<span class="built_in">int</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line">	<span class="built_in">int</span> (*drop_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="built_in">void</span> (*evict_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="built_in">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="built_in">int</span> (*sync_fs)(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait);</span><br><span class="line">	<span class="built_in">int</span> (*freeze_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="built_in">int</span> (*freeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="built_in">int</span> (*thaw_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="built_in">int</span> (*unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="built_in">int</span> (*statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line">	<span class="built_in">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">	<span class="built_in">int</span> (*remount_fs2) (<span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">	<span class="type">void</span> *(*clone_mnt_data) (<span class="type">void</span> *);</span><br><span class="line">	<span class="built_in">void</span> (*copy_mnt_data) (<span class="type">void</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="built_in">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> (*show_options)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*show_options2)(<span class="keyword">struct</span> vfsmount *,<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*show_devname)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*show_path)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*show_stats)(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> dentry *);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">	<span class="built_in">ssize_t</span> (*quota_read)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*quota_write)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dquot</span> **(*get_dquots)(<span class="keyword">struct</span> inode *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">int</span> (*bdev_try_to_free_page)(<span class="keyword">struct</span> super_block*, <span class="keyword">struct</span> page*, <span class="type">gfp_t</span>);</span><br><span class="line">	<span class="built_in">long</span> (*nr_cached_objects)(<span class="keyword">struct</span> super_block *,</span><br><span class="line">				  <span class="keyword">struct</span> shrink_control *);</span><br><span class="line">	<span class="built_in">long</span> (*free_cached_objects)(<span class="keyword">struct</span> super_block *,</span><br><span class="line">				    <span class="keyword">struct</span> shrink_control *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-索引节点-inode"><a href="#1-2-索引节点-inode" class="headerlink" title="1.2. 索引节点 inode"></a>1.2. 索引节点 inode</h2><p>用于存放内核在操作文件或目录时需要的全部信息.<br>具体文件系统的索引节点存储在磁盘上,使用时将其读入内存填充VFS的索引节点,之后VFS inode的任何修改回写到磁盘上.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> &#123;</span><br><span class="line">	<span class="type">umode_t</span>			i_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		i_opflags;</span><br><span class="line">	<span class="type">kuid_t</span>			i_uid;</span><br><span class="line">	<span class="type">kgid_t</span>			i_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">posix_acl</span>	*i_acl;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">posix_acl</span>	*i_default_acl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">inode_operations</span>	*i_op;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">super_block</span>	*i_sb;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	*i_mapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*i_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		i_ino;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">	 * following functions for modification:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">	 *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">dev_t</span>			i_rdev;</span><br><span class="line">	<span class="type">loff_t</span>			i_size;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timespec</span>		i_atime;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timespec</span>		i_mtime;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timespec</span>		i_ctime;</span><br><span class="line">	<span class="type">spinlock_t</span>		i_lock;	<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		i_blkbits;</span><br><span class="line">	<span class="type">blkcnt_t</span>		i_blocks;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">	<span class="type">seqcount_t</span>		i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Misc */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		i_state;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		i_mutex;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		dirtied_when;	<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		dirtied_time_when;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_node</span>	i_hash;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	i_io_list;	<span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">bdi_writeback</span>	*i_wb;		<span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">	<span class="type">int</span>			i_wb_frn_winner;</span><br><span class="line">	u16			i_wb_frn_avg_time;</span><br><span class="line">	u16			i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	i_lru;		<span class="comment">/* inode LRU list */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	i_sb_list;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">hlist_head</span>	i_dentry;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span>		i_rcu;</span><br><span class="line">	&#125;;</span><br><span class="line">	u64			i_version;</span><br><span class="line">	<span class="type">atomic_t</span>		i_count;</span><br><span class="line">	<span class="type">atomic_t</span>		i_dio_count;</span><br><span class="line">	<span class="type">atomic_t</span>		i_writecount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">	<span class="type">atomic_t</span>		i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>	*i_fop;	<span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_lock_context</span>	*i_flctx;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	i_data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	i_devices;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>	*i_pipe;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">block_device</span>	*i_bdev;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">cdev</span>		*i_cdev;</span><br><span class="line">		<span class="type">char</span>			*i_link;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__u32			i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">	__u32			i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span>	i_fsnotify_marks;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_FS_ENCRYPTION)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fscrypt_info</span>	*i_crypt_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">void</span>			*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4个管理inode的链表:</p>
<ol>
<li>inode_unused, 目前还没使用的linode</li>
<li>inode_in_use,目前正在使用的inode</li>
<li>超级块的s_dirty字段,将所有脏inode链接</li>
<li>inode_in_use使用效率不高,  将使用中的inode计算hash值, hash值可能重复, i_hash将同样hash值的对个inode链接</li>
</ol>
<h3 id="1-2-1-索引节点操作"><a href="#1-2-1-索引节点操作" class="headerlink" title="1.2.1. 索引节点操作"></a>1.2.1. 索引节点操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode_operations</span> &#123;</span><br><span class="line">    <span class="comment">// 指定目录查找</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> * (*lookup) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="type">void</span> **);</span><br><span class="line">	<span class="built_in">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*permission2) (<span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">posix_acl</span> * (*get_acl)(<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> __user *,<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">void</span> (*put_link) (<span class="keyword">struct</span> inode *, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">bool</span>);</span><br><span class="line">	<span class="built_in">int</span> (*link) (<span class="keyword">struct</span> dentry *,<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*unlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*symlink) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="built_in">int</span> (*mkdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>);</span><br><span class="line">	<span class="built_in">int</span> (*rmdir) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*mknod) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="type">umode_t</span>,<span class="type">dev_t</span>);</span><br><span class="line">	<span class="built_in">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">			<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">int</span> (*rename2) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">			<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">	<span class="built_in">int</span> (*setattr2) (<span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">	<span class="built_in">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line">    <span class="comment">/*为指定的文件设置特定的扩展属性, (xattr)允许用户将文件与未被文件系统解释的信息关联,与之对应的是经过文件系统严格定义的正规文件属性,如文件创建和修改的事件等. 如文件作者/编码等</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="built_in">int</span> (*setxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">void</span> *,<span class="type">size_t</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*getxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="built_in">int</span> (*removexattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">	<span class="built_in">int</span> (*fiemap)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> fiemap_extent_info *, u64 start,</span><br><span class="line">		      u64 len);</span><br><span class="line">	<span class="built_in">int</span> (*update_time)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> timespec *, <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*atomic_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,</span><br><span class="line">			   <span class="keyword">struct</span> file *, <span class="type">unsigned</span> open_flag,</span><br><span class="line">			   <span class="type">umode_t</span> create_mode, <span class="type">int</span> *opened);</span><br><span class="line">	<span class="built_in">int</span> (*tmpfile) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>);</span><br><span class="line">	<span class="built_in">int</span> (*set_acl)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> posix_acl *, <span class="type">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-目录项-dentry"><a href="#1-3-目录项-dentry" class="headerlink" title="1.3. 目录项(dentry)"></a>1.3. 目录项(dentry)</h2><p>为方便查找操作, 引入目录. 每个目录项代表路径的一部分.</p>
<p>&#x2F;home&#x2F;test&#x2F;test.c   (test.c也是一个目录项)</p>
<p>目录项将路径中的每个部分与其对应的inode相连,沿着路径各部分的目录项进行搜索,最终找到目标文件的inode.</p>
<blockquote>
<p>与超级块和索引节点不同, 目录项在磁盘上没有对应描述. 只存在于内存中(目录页缓存),仅仅为提高系统的性能存在.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> &#123;</span><br><span class="line">	<span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> d_flags;		<span class="comment">/* protected by d_lock */</span></span><br><span class="line">	<span class="type">seqcount_t</span> d_seq;		<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">    <span class="comment">// dentry的链表, 链接所用的dentry. 保存parent指针和next指针.</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_bl_node</span> d_hash;	<span class="comment">/* lookup hash list */</span></span><br><span class="line">    <span class="comment">// 父目录项</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *d_parent;	<span class="comment">/* parent directory */</span></span><br><span class="line">    <span class="comment">// 目录项名字</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">qstr</span> d_name;</span><br><span class="line">    <span class="comment">// 与目录关联的inode</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *d_inode;		<span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">					 * negative */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN];	<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lockref</span> d_lockref;	<span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">    <span class="comment">// dentry 操作</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dentry_operations</span> *d_op;</span><br><span class="line">    <span class="comment">// 所属文件系统的超级块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">super_block</span> *d_sb;	<span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> d_time;		<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">	<span class="type">void</span> *d_fsdata;			<span class="comment">/* fs-specific data */</span></span><br><span class="line">    <span class="comment">// 最近未使用的目录项链表</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> d_lru;		<span class="comment">/* LRU list */</span></span><br><span class="line">    <span class="comment">// 通过该字段加入到其父目录的 d_subdirs链表中</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> d_child;	<span class="comment">/* child of parent list */</span></span><br><span class="line">    <span class="comment">// 其子目录链表的头</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> d_subdirs;	<span class="comment">/* our children */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 一个inode可能对应多个dentry, 与该inode相关连的所有目录通过dentry的d_alias挂入inode的i_dentry链表中</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">hlist_node</span> d_alias;	<span class="comment">/* inode alias list */</span></span><br><span class="line">	 	<span class="keyword">struct</span> <span class="title class_">rcu_head</span> d_rcu;</span><br><span class="line">	&#125; d_u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-几点小结"><a href="#1-3-1-几点小结" class="headerlink" title="1.3.1. 几点小结"></a>1.3.1. 几点小结</h3><ul>
<li>每个dentry通过<code>d_hash</code>字段挂入dentry_hashtable中的某个链表里. 通过该链表管理所有目录.目录一经创建, 就会加入到该链表里</li>
<li>引用计数为0的dentry通过d_lru挂入链表dentry_unsed,等待释放或重新使用</li>
<li>每个dentry通过d_inode与一个inode关联,多个dentry可以与一个inode关联</li>
<li>指向同一个inode的dentry通过d_alias字段链接在一起,都挂入inode的i_dentry链表中</li>
<li>每个dentry通过d_parent字段指向其parent目录的dentry,通过d_child跟同一目录中其他文件的dentry链接在一起,都挂在parent目录dentry的d_subdirs链表中</li>
<li>每个d_entry通过d_sb指向所属文件系统的超级块</li>
</ul>
<h3 id="1-3-2-dentry的状态"><a href="#1-3-2-dentry的状态" class="headerlink" title="1.3.2. dentry的状态"></a>1.3.2. dentry的状态</h3><ul>
<li>空闲状态(free): 不包含有效信息, 且未被VFS使用</li>
<li>未使用状态(unused): d_inode字段仍指向关联的inode, 但引用计数为0, 未被VFS使用, 没有进程访问. 在内存回收时可能被丢弃</li>
<li>使用状态(in use) 存在使用进程, 关联inode. 不会被丢弃</li>
<li>负状态(negative) 没有关联inode, 由于其关联的inode被删除或解析一个不存在的文件创建,留作使用</li>
</ul>
<h3 id="1-3-3-目录项操作-dentry-oprations"><a href="#1-3-3-目录项操作-dentry-oprations" class="headerlink" title="1.3.3. 目录项操作(dentry_oprations)"></a>1.3.3. 目录项操作(dentry_oprations)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry_operations</span> &#123;</span><br><span class="line">    <span class="comment">// 判断dentry是否有效.</span></span><br><span class="line">	<span class="built_in">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*d_weak_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*d_hash)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="built_in">int</span> (*d_compare)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="keyword">struct</span> dentry *,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> qstr *);</span><br><span class="line">	<span class="built_in">int</span> (*d_delete)(<span class="type">const</span> <span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">void</span> (*d_prune)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">	<span class="built_in">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="type">char</span> *(*d_dname)(<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vfsmount</span> *(*d_automount)(<span class="keyword">struct</span> path *);</span><br><span class="line">	<span class="built_in">int</span> (*d_manage)(<span class="keyword">struct</span> dentry *, <span class="type">bool</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *(*d_select_inode)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *(*d_real)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">	<span class="built_in">void</span> (*d_canonical_path)(<span class="type">const</span> <span class="keyword">struct</span> path *, <span class="keyword">struct</span> path *);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-文件对象"><a href="#1-4-文件对象" class="headerlink" title="1.4. 文件对象"></a>1.4. 文件对象</h2><p>文件描述进程已经打开的文件, 进程直接处理的是文件, 而不是其他三个.因多个进程可以打开和操作同一个文件, 所以同一个文件可能存在多个对应的<strong>文件对象</strong>.但对应的<strong>inode</strong>和<strong>dentry</strong>是唯一的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 文件系统的所有已打开文件通过该字段挂入文件系统的超级块(sb)的s_files链表中</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">llist_node</span>	fu_llist;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span> 	fu_rcuhead;</span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>		f_path;</span><br><span class="line">    <span class="comment">// 关联的inode</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span>		*f_inode;	<span class="comment">/* cached value */</span></span><br><span class="line">    <span class="comment">// 文件操作</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>	*f_op;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">    <span class="comment">// 打开文件时指定的参数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		f_pos_lock;</span><br><span class="line">    <span class="comment">// 目前文件的offset,每次读写从该位置开始</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fown_struct</span>	f_owner;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>	*f_cred;</span><br><span class="line">    <span class="comment">// 文件预读状态</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_ra_state</span>	f_ra;</span><br><span class="line">    <span class="comment">// fpos改变时, f_version ++</span></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="comment">// 供文件系统或驱动程序使用的私有数据</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	f_ep_links;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	f_tfile_llink;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="comment">// 查看inode的i_mapping字段</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	*f_mapping;</span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>

<p>内核从磁盘上将inode装入内存时, 与该inode相关的文件操作存放在i_fop字段,之后进程打开这个文件时,VFS通过inode中的i_fop初始化新文件对应的f_op字段.</p>
<h3 id="1-4-1-文件操作-file-operations-f-op"><a href="#1-4-1-文件操作-file-operations-f-op" class="headerlink" title="1.4.1. 文件操作(file_operations f_op)"></a>1.4.1. 文件操作(file_operations f_op)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file_operations</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">	<span class="built_in">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="built_in">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="built_in">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="built_in">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="comment">// 指定的文件映射到指定的地址空间, 由mmap()调用</span></span><br><span class="line">	<span class="built_in">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="built_in">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">// 当调用close时会被调用 根据具体文件系统而定</span></span><br><span class="line">	<span class="built_in">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="comment">// 引用计数变为0时, 调用释放文件对象</span></span><br><span class="line">	<span class="built_in">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="comment">// 将文件所有被缓存的数据写入磁盘, 由系统调用fsync()和fdatasync()调用, fdatasync()只会影响文件的数据部分,fsync会同步更新文件的属性</span></span><br><span class="line">	<span class="built_in">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="built_in">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="built_in">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="built_in">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line">	<span class="built_in">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="comment">// 从一个pipe移动数据到一个文件, 由系统调用splice()时调用</span></span><br><span class="line">	<span class="built_in">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        <span class="comment">// 从一个文件移动数据到一个pipe, 由系统调用splice()时调用</span></span><br><span class="line">	<span class="built_in">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 为一个已打开的文件设置一个租约, 提供当一个进程试图打开或读写文件内容时,有文件租约的进程会被通知的机制</span></span><br><span class="line">	<span class="built_in">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">	<span class="built_in">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="built_in">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="built_in">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-文件系统相关的数据结构"><a href="#1-5-文件系统相关的数据结构" class="headerlink" title="1.5. 文件系统相关的数据结构"></a>1.5. 文件系统相关的数据结构</h2><h3 id="1-5-1-file-system-type-具体文件系统类型"><a href="#1-5-1-file-system-type-具体文件系统类型" class="headerlink" title="1.5.1. file_system_type(具体文件系统类型)"></a>1.5.1. file_system_type(具体文件系统类型)</h3><p>ex: ext2_fs_type ext3_fs_type vfat_fs_type</p>
<p>Linux 支持的文件系统, 都会有且只有一个file_system_type结构, 每当有一个文件系统被安装时,会有一个<code>vfsmount</code>结构被创建, 代表该文件系统的一个安装实例, 也代表了该文件系统的一个安装点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_DEV_MOUNT	16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_VISIBLE	32	<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *(*mount) (<span class="keyword">struct</span> file_system_type *, <span class="type">int</span>,</span><br><span class="line">		       <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *(*mount2) (<span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> file_system_type *, <span class="type">int</span>,</span><br><span class="line">			       <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="type">void</span> *(*alloc_mnt_data) (<span class="type">void</span>);</span><br><span class="line">	<span class="built_in">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">    <span class="comment">// 不同类型的文件系统通过next字段链接形成链表</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_system_type</span> * next;</span><br><span class="line">    <span class="comment">// 同一种文件系统的超级块通过s_instances字段链接到一起, 挂入fs_supers链表中.</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span> fs_supers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_lock_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_umount_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_vfs_rename_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> s_writers_key[SB_FREEZE_LEVELS];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_lock_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_mutex_key;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">lock_class_key</span> i_mutex_dir_key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-vfsmount实例"><a href="#1-5-2-vfsmount实例" class="headerlink" title="1.5.2. vfsmount实例"></a>1.5.2. vfsmount实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vfsmount</span> &#123;</span><br><span class="line">    <span class="comment">// 该文件系统根目录的dentry, 与mountpoint一般是相同的.</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *mnt_root;	<span class="comment">/* root of the mounted tree */</span></span><br><span class="line">    <span class="comment">// 指向安装文件系统的超级块</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">super_block</span> *mnt_sb;	<span class="comment">/* pointer to superblock */</span></span><br><span class="line">    <span class="comment">// 挂载参数</span></span><br><span class="line">	<span class="type">int</span> mnt_flags;</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-与进程相关的数据结构"><a href="#1-5-3-与进程相关的数据结构" class="headerlink" title="1.5.3. 与进程相关的数据结构"></a>1.5.3. 与进程相关的数据结构</h3><p>每个进程都有自己的根目录和当前工作目录,内核使用了struct fs_struct记录这些信息, 进程描述符的fs字段指向该进程的fs_struct结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fs_struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> users;</span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="type">seqcount_t</span> seq;</span><br><span class="line">    <span class="comment">// 打开文件时默认设置的文件访问权限</span></span><br><span class="line">	<span class="type">int</span> umask;</span><br><span class="line">	<span class="type">int</span> in_exec;</span><br><span class="line">    <span class="comment">// pwd指向当前工作目录</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span> root, pwd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了根目录&#x2F;当前工作目录, 进程还需要记录自己打开的文件. 进程已经打开的文件用struct files_struct来记录, <code>进程描述符</code>的files字段指向该进程的files_struct结构.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">files_struct</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">bool</span> resize_in_progress;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> resize_wait;</span><br><span class="line"><span class="comment">// fdtab是初始的文件描述表, fdt最初指向fdtab</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> __rcu *fdt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fdtable</span> fdtab;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="comment">// 最近关闭的文件描述符中最小的下一个可用的文件描述符</span></span><br><span class="line">	<span class="type">int</span> next_fd;</span><br><span class="line">    <span class="comment">// 执行exec时需要关闭的文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 当前已经打开的文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 文件对象的初始化数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> __rcu * fd_array[NR_OPEN_DEFAULT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件描述符fd等于文件对象在数组fd_array中的下标. 通过fd_array中的前3个分别是stdin, stdout,stderr 标准描述符.</p>
<p>内核将fd&#x2F;max_fds以及其他字段组织在一起, 成了fdtable,称为文件描述符表. 当进程打开的文件数目超过32个时,内核调用expand_fdtable()生成一个新的文件描述表, 将它的地址指向fdt</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fdtable</span> &#123;</span><br><span class="line">    <span class="comment">// 文件对象的最大数目</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">    <span class="comment">// 指向当前的文件对象数组, 初始指向fd_array</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> __rcu **fd;      <span class="comment">/* current fd array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;</span><br><span class="line">    <span class="comment">// 当前已经打开的文件描述符, 初始指向open_fds_init</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *open_fds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *full_fds_bits;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rcu_head</span> rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-路径查找辅助结构"><a href="#1-5-4-路径查找辅助结构" class="headerlink" title="1.5.4. 路径查找辅助结构"></a>1.5.4. 路径查找辅助结构</h3><p>nameidata用于在路径查找的过程中记录中间信息和查找结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nameidata</span> &#123;</span><br><span class="line">    <span class="comment">// 所解析的最后一个路径的对象</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>	path;</span><br><span class="line">    <span class="comment">// 表示当前目录项的名称</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">qstr</span>	last;</span><br><span class="line">    <span class="comment">// 根目录</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>	root;</span><br><span class="line">    <span class="comment">// 父目录关联的inode</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span>	*inode; <span class="comment">/* path.dentry.d_inode */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">unsigned</span>	seq, m_seq;</span><br><span class="line">    <span class="comment">// 路径最后一个分量的类型, 可以去LAST_NORM/LAST_DOT/LAST_DOTDOT/LAST_BIND</span></span><br><span class="line">	<span class="type">int</span>		last_type;</span><br><span class="line">    <span class="comment">// 符号链接嵌套的深度</span></span><br><span class="line">	<span class="type">unsigned</span>	depth;</span><br><span class="line">	<span class="type">int</span>		total_link_count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">saved</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">path</span> link;</span><br><span class="line">		<span class="type">void</span> *cookie;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">inode</span> *inode;</span><br><span class="line">		<span class="type">unsigned</span> seq;</span><br><span class="line">	&#125; *stack, internal[EMBEDDED_LEVELS];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">filename</span>	*name;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nameidata</span> *saved;</span><br><span class="line">	<span class="type">unsigned</span>	root_seq;</span><br><span class="line">	<span class="type">int</span>		dfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-VFS的缓存机制"><a href="#1-6-VFS的缓存机制" class="headerlink" title="1.6. VFS的缓存机制"></a>1.6. VFS的缓存机制</h2><p>内核启动时,通过vfs_caches_init()创建inode&#x2F;dentry&#x2F;file文件对象&#x2F;vfsmount缓存提高操作系统性能</p>
<h3 id="1-6-1-inode缓存"><a href="#1-6-1-inode缓存" class="headerlink" title="1.6.1. inode缓存"></a>1.6.1. inode缓存</h3><ul>
<li>从内存中申请或释放一个inode对象,必须通过kmem_cache_alloc和kmem_cache_free进行</li>
<li>将inode对象插入不同的链表, 具有相同hash值的inode对象在同一链表中. 当访问一个inode时,先在缓存hash表中查询,如果查到,引用计数+1, 如没有, 需要找到一个空闲的inode, 从底层的文件系统中读取信息填充该inode, 插入到对应的链表中.</li>
</ul>
<h3 id="1-6-2-目录项缓存"><a href="#1-6-2-目录项缓存" class="headerlink" title="1.6.2. 目录项缓存"></a>1.6.2. 目录项缓存</h3><p>执行文件操作时, VFS需要解析文件路径中的每一部分, 并为之构造目录项对象, 重复访问同一文件时或包含相同的目录项时,直接从内存中获得对应的dentry</p>
<p>目录项的缓存机制与inode缓存类似, 不重复介绍. 申请dentry时需要关联inode.</p>
<h3 id="1-6-3-缓冲区缓存"><a href="#1-6-3-缓冲区缓存" class="headerlink" title="1.6.3. 缓冲区缓存"></a>1.6.3. 缓冲区缓存</h3><p>对磁盘文件访问, 最终转化为对磁盘操作. 扇区是块设备的基本单元, 也是最小的寻址单元. 内核在扇区上抽象出了<code>块</code>的概念,块的大小是扇区的n倍, 不能超过页面长度, 通常为512b&#x2F;1k&#x2F;4k</p>
<p>块被作为文件系统的最小寻址单元, 一个磁盘块被调入内存时, 需存储在对应的内存上的缓冲区中.</p>
<p>新的kernel版本上, page cache中包含buffer cache. page cache为4k大小, 根据配置的块大小, 一个page cache可以包含一个还是多个(最多8-对应512b)buffer cache.</p>
<h2 id="1-7-文件系统的注册与安装"><a href="#1-7-文件系统的注册与安装" class="headerlink" title="1.7. 文件系统的注册与安装"></a>1.7. 文件系统的注册与安装</h2><p>将指定文件系统的file_system_type对象向内核注册.已注册文件系统的file_system_type对象形成链表.</p>
<h3 id="1-7-1-文件系统安装"><a href="#1-7-1-文件系统安装" class="headerlink" title="1.7.1. 文件系统安装"></a>1.7.1. 文件系统安装</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mnt_namespace</span> &#123;</span><br><span class="line">	<span class="type">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ns_common</span>	ns;</span><br><span class="line">    <span class="comment">// 该namespace下的根目录的vfsmount对象</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mount</span> *	root;</span><br><span class="line">    <span class="comment">// 链接属于该命名空间的安装的所有文件系统</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>	list;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_namespace</span>	*user_ns;</span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		mounts; <span class="comment">/* # of mounts in the namespace */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		pending_mounts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下, 所有进程共享同样的namespace, 即看到的是同样的结构.但如调用clone()时使用CLONE_NEWNS标志, 进程会获得一个新的namespace. 只有保证是相同的namespace, 看到的文件结构才一致.</p>
<p>mount是基于进程的namespace进行安装的. 同样的namespace共享安装</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/Android%20fuse%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/" rel="prev" title="Android fuse 文件系统调研">
      <i class="fa fa-chevron-left"></i> Android fuse 文件系统调研
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/07/01/USB%E7%9B%B8%E5%85%B3/AndroidQ%20Usb%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94/" rel="next" title="AndroidQ Usb差异对比">
      AndroidQ Usb差异对比 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-VFS"><span class="nav-number">1.</span> <span class="nav-text">1. VFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E8%B6%85%E7%BA%A7%E5%9D%97-sb"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 超级块 sb</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E8%B6%85%E7%BA%A7%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1. 超级块操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9-inode"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 索引节点 inode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1. 索引节点操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%9B%AE%E5%BD%95%E9%A1%B9-dentry"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 目录项(dentry)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E5%87%A0%E7%82%B9%E5%B0%8F%E7%BB%93"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. 几点小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-dentry%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. dentry的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-%E7%9B%AE%E5%BD%95%E9%A1%B9%E6%93%8D%E4%BD%9C-dentry-oprations"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3. 目录项操作(dentry_oprations)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. 文件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-file-operations-f-op"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. 文件操作(file_operations f_op)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. 文件系统相关的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-file-system-type-%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. file_system_type(具体文件系统类型)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-vfsmount%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. vfsmount实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. 与进程相关的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4-%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE%E8%BE%85%E5%8A%A9%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4. 路径查找辅助结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-VFS%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. VFS的缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-inode%E7%BC%93%E5%AD%98"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. inode缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BC%93%E5%AD%98"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 目录项缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BC%93%E5%AD%98"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. 缓冲区缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. 文件系统的注册与安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1. 文件系统安装</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'Iv1.773e833554cd839d',
      clientSecret: '4cd8b611b2443334348612d6b38282820001ae11',
      repo        : 'BlogComments',
      owner       : 'LiguangZhang',
      admin       : ['LiguangZhang'],
      id          : 'c7dc668500fa483750c047ee4f10901a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>

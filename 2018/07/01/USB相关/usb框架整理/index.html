<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW WenKai:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liguangzhang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="1. UsbPortManager-usb role管理 1.1. USB主机和USB设备 1.2. Usb设备演进 1.3. typec设备 role管理 1.3.1. power 模式 1.3.2. 数据模式 1.3.3. 相关底层节点 1.3.4. 状态切换与通知     2. USB host 管理 2.1. Usb host 添加和删除设备. 2.1.1. usb_host_loa">
<meta property="og:type" content="article">
<meta property="og:title" content="Usb Framework层框架整理">
<meta property="og:url" content="https://liguangzhang.github.io/2018/07/01/USB%E7%9B%B8%E5%85%B3/usb%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="1. UsbPortManager-usb role管理 1.1. USB主机和USB设备 1.2. Usb设备演进 1.3. typec设备 role管理 1.3.1. power 模式 1.3.2. 数据模式 1.3.3. 相关底层节点 1.3.4. 状态切换与通知     2. USB host 管理 2.1. Usb host 添加和删除设备. 2.1.1. usb_host_loa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb2.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb_device.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/mini_usb.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/typec.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb_dev_file.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb_interface.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/alsa-jiagou.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb%E6%9E%9A%E4%B8%BE.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/switch_function.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/usb_device_mode.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/accessory_mode_control.png">
<meta property="og:image" content="https://liguangzhang.github.io/images/stateMachine.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/state_tree.jpg">
<meta property="og:image" content="https://liguangzhang.github.io/images/Tethering-state.svg">
<meta property="article:published_time" content="2018-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-16T03:50:14.485Z">
<meta property="article:author" content="liguang.zhang">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liguangzhang.github.io/images/usb2.png">

<link rel="canonical" href="https://liguangzhang.github.io/2018/07/01/USB%E7%9B%B8%E5%85%B3/usb%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'" />

  <title>Usb Framework层框架整理 | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liguangzhang.github.io/2018/07/01/USB%E7%9B%B8%E5%85%B3/usb%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liguang.zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Usb Framework层框架整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">2018-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 11:50:14" itemprop="dateModified" datetime="2024-04-16T11:50:14+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/USB/" itemprop="url" rel="index"><span itemprop="name">USB</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/01/USB%E7%9B%B8%E5%85%B3/usb%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/01/USB%E7%9B%B8%E5%85%B3/usb%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- TOC -->

<ul>
<li><a href="#1-usbportmanager-usb-role%E7%AE%A1%E7%90%86">1. UsbPortManager-usb role管理</a><ul>
<li><a href="#11-usb%E4%B8%BB%E6%9C%BA%E5%92%8Cusb%E8%AE%BE%E5%A4%87">1.1. USB主机和USB设备</a></li>
<li><a href="#12-usb%E8%AE%BE%E5%A4%87%E6%BC%94%E8%BF%9B">1.2. Usb设备演进</a></li>
<li><a href="#13-typec%E8%AE%BE%E5%A4%87-role%E7%AE%A1%E7%90%86">1.3. typec设备 role管理</a><ul>
<li><a href="#131-power-%E6%A8%A1%E5%BC%8F">1.3.1. power 模式</a></li>
<li><a href="#132-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F">1.3.2. 数据模式</a></li>
<li><a href="#133-%E7%9B%B8%E5%85%B3%E5%BA%95%E5%B1%82%E8%8A%82%E7%82%B9">1.3.3. 相关底层节点</a></li>
<li><a href="#134-%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E9%80%9A%E7%9F%A5">1.3.4. 状态切换与通知</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-usb-host-%E7%AE%A1%E7%90%86">2. USB host 管理</a><ul>
<li><a href="#21-usb-host-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87">2.1. Usb host 添加和删除设备.</a><ul>
<li><a href="#211-usbhostload%E5%B0%8F%E7%BB%93">2.1.1. usb_host_load小结</a></li>
<li><a href="#212-usbhostreadevent-%E7%9B%91%E5%90%AC%E8%8A%82%E7%82%B9">2.1.2. usb_host_read_event 监听节点</a><ul>
<li><a href="#2121-usbhostreadevent-%E5%B0%8F%E7%BB%93">2.1.2.1. usb_host_read_event 小结</a></li>
</ul>
</li>
<li><a href="#213-%E4%B8%A4%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.1.3. 两个回调函数</a></li>
<li><a href="#214-usbdeviceadded%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87">2.1.4. usb_device_added方法添加设备</a></li>
<li><a href="#215-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A7%A3%E6%9E%90">2.1.5. 描述符解析</a><br>  - <a href="#21501-usb-%E7%AB%AF%E7%82%B9%E7%AE%A1%E9%81%93%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB">2.1.5.0.1. USB 端点、管道和接口的关系</a></li>
<li><a href="#216-addedcb-%E5%9B%9E%E8%B0%83%E5%B0%8F%E7%BB%93">2.1.6. added_cb 回调小结</a></li>
</ul>
</li>
<li><a href="#22-%E4%B8%8A%E5%B1%82%E8%8E%B7%E5%8F%96usb-%E8%AE%BE%E5%A4%87%E5%B9%B6%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93">2.2. 上层获取USB 设备并进行传输</a><ul>
<li><a href="#221-usb%E4%BC%A0%E8%BE%93%E9%80%9A%E4%BF%A1">2.2.1. USB传输通信</a></li>
</ul>
</li>
<li><a href="#23-usbalsamanager-%E9%9F%B3%E9%A2%91%E7%AE%A1%E7%90%86">2.3. UsbAlsaManager 音频管理</a><ul>
<li><a href="#231-usbalsamanager%E5%88%9D%E5%A7%8B%E5%8C%96">2.3.1. UsbAlsaManager初始化</a></li>
<li><a href="#232-usbalsamanager-systemready">2.3.2. UsbAlsaManager systemReady</a></li>
<li><a href="#233-usbdeviceadded-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83">2.3.3. usbDeviceAdded 事件回调</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-usb-device%E7%AE%A1%E7%90%86">3. Usb device管理</a><ul>
<li><a href="#31-usb%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B">3.1. Usb枚举过程</a></li>
<li><a href="#32-%E4%BC%A0%E7%BB%9Fusb-device%E4%B8%8Eaccessory%E9%85%8D%E4%BB%B6%E6%A8%A1%E5%BC%8F">3.2. 传统Usb device与accessory(配件)模式</a><ul>
<li><a href="#321-accessory%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B">3.2.1. accessory模式下的枚举过程:</a></li>
<li><a href="#322-accessory%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6">3.2.2. accessory模式框架</a><ul>
<li><a href="#3221-%E7%94%B3%E8%AF%B7accessory%E6%9D%83%E9%99%90">3.2.2.1. 申请accessory权限</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#33-usb-%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB">3.3. Usb 网络共享</a><ul>
<li><a href="#331-%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1">3.3.1. 配置网卡</a></li>
<li><a href="#332-statemachine">3.3.2. StateMachine</a><ul>
<li><a href="#3321-state-%E6%A8%A1%E5%BC%8F">3.3.2.1. state 模式</a></li>
<li><a href="#3322-state-machine%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8">3.3.2.2. State Machine各个模块作用</a><ul>
<li><a href="#33221-smhandler">3.3.2.2.1. Smhandler</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#333-tethering%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%9C%BA">3.3.3. Tethering网络状态机</a><ul>
<li><a href="#3331-tetherinterfacesmtetherinterfacestatemachine">3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)</a><ul>
<li><a href="#33311-tetherinterfacesm-%E5%88%9D%E5%A7%8B%E5%8C%96">3.3.3.1.1. TetherInterfaceSM 初始化</a></li>
</ul>
</li>
<li><a href="#3332-tethermastersm">3.3.3.2. <strong>TetherMasterSM</strong></a><ul>
<li><a href="#33321-%E4%B8%BB%E6%8E%A7%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96">3.3.3.2.1. 主控状态机初始化</a></li>
<li><a href="#33322-%E6%8E%A5%E6%94%B6interface%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9B%9E%E8%B0%83">3.3.3.2.2. 接收interface状态机的回调</a></li>
</ul>
</li>
<li><a href="#3334-%E6%94%B6%E5%88%B0configured%E7%8A%B6%E6%80%81%E5%90%8E-%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB">3.3.3.4. 收到configured状态后, 开启网络共享</a><ul>
<li><a href="#33341-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%BF%80%E6%B4%BB%E7%AD%89">3.3.3.4.1. 网络配置激活等</a></li>
<li><a href="#33342-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86">3.3.3.4.2. 涉及到的网络知识</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#34-usb-pc-share-pc%E4%BA%92%E8%81%94%E7%BD%91">3.4. Usb pc-share pc互联网</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<p>结构</p>
<ul>
<li><p>UsbPortManager</p>
</li>
<li><p>UsbHostManager</p>
<ul>
<li>UsbAlsaManager</li>
</ul>
</li>
<li><p>UsbDeviceManager</p>
<p><img src="/images/usb2.png" alt="usb//images/usb2.png"></p>
</li>
</ul>
<h1 id="1-UsbPortManager-usb-role管理"><a href="#1-UsbPortManager-usb-role管理" class="headerlink" title="1. UsbPortManager-usb role管理"></a>1. UsbPortManager-usb role管理</h1><h2 id="1-1-USB主机和USB设备"><a href="#1-1-USB主机和USB设备" class="headerlink" title="1.1. USB主机和USB设备"></a>1.1. USB主机和USB设备</h2><p>USB通信中居于核心地位的是主机(Host)，常见的USB主机是PC机。</p>
<ul>
<li><p>任何一次USB的数据传输都必须由主机发起和控制</p>
</li>
<li><p>所有的USB外设都只能和主机建立连接</p>
</li>
<li><p>任何二个外设之间或是二个主机之间都无法直接通信</p>
</li>
</ul>
<p>USB主机和USB设备的功能是不同的。</p>
<p>USB主机的功能:</p>
<ul>
<li>通过USB接口给外设提供电源（外设也可以自带电源）</li>
<li>检测和配置设备（即设备的枚举）</li>
<li>错误检查和管理数据的传输</li>
<li>根据设定的传输方式与外设交换数据</li>
</ul>
<p>USB设备的功能:</p>
<ul>
<li><p>管理电源。设备可以由USB接口获取电源，也可能有自己的电源</p>
</li>
<li><p>检测通信</p>
<p>每一个设备都要检测通信信息包中的地址是否和本设备的地址相符，如果不符，设备就会忽略本次通信，这由USB接口硬件自动进行处理。在设备一开始连上USB接口时，使用固定的默认地址0，然后USB主机在检测阶段会给设备分配一个地址，以后的通信都按这个地址进行</p>
</li>
<li><p>通信数据的错误检查。由USB接口硬件保证，不必编程处理</p>
</li>
<li><p>响应请求<br>主机在检测到有设备连接上以后，会按USB协议发送相应的设备请求来了解设备的类型和能力，并对设备进行一些配置（如设定地址和配置描述符），设备应能响应这些请求，并返回相应的应答数据</p>
</li>
<li><p>根据设定的传输方式与主机交换数据</p>
</li>
</ul>
<h2 id="1-2-Usb设备演进"><a href="#1-2-Usb设备演进" class="headerlink" title="1.2. Usb设备演进"></a>1.2. Usb设备演进</h2><p>USB Type A：该标准一般适用于个人电脑PC中，是应用于最广泛的接口标准</p>
<p>USB Type B：一般用于3.5寸移动硬盘、以及打印机、显示器等连接</p>
<p><img src="/../images/usb_device.jpg" alt="usb_device"></p>
<p><img src="/images/mini_usb.jpg" alt="mini_usb"></p>
<p>USB Type C：USB Type C这个接口名称是在USB 3.1时代之后出现的，该接口的亮点在于更加纤薄的设计、更快的传输速度（最高10Gbps）以及更强悍的电力传输（最高100W）。Type-C双面可插接口最大的特点是支持USB接口双面插入，主要面向更轻薄、更纤细的设备（未来可能统一手机平板的接口，取代Micro USB接口）。</p>
<p>配备Type-C连接器的标准规格连接线可通过3A电流，同时还支持超出现有USB供电能力的“USB PD”，可以提供最大100W 的电力。</p>
<p><img src="/images/typec.jpg" alt="typec"></p>
<h2 id="1-3-typec设备-role管理"><a href="#1-3-typec设备-role管理" class="headerlink" title="1.3. typec设备 role管理"></a>1.3. typec设备 role管理</h2><p>Type-C与既有的USB Type-A与USB Type-B相比，具备无方向性的插拔、并能同时进行<em>数据传输、影音输出及电源传递</em>。消费者无法从Type-C的物理外观判断何者是<code>主控端</code>(例如计算机或笔电)或设备端(例如手机或随身碟)，这点与传统接口有显著差异(传统上Type-A即是主控端，USB Micro-B是设备端)：因此，Type-C与USB Power Delivery(以下简称USB PD)规范定义了数种<code>双模式</code>的角色，用以解决各种设备相互连接时可能产生的问题。</p>
<p>USB Power Delivery(USB PD):</p>
<ul>
<li>POWER_ROLE_SOURCE</li>
<li>POWER_ROLE_SINK</li>
</ul>
<blockquote>
<p>source 和 sink 对应 主控端和受控端，source提供电力的一方，sink接收电力的一方。</p>
</blockquote>
<p>设备需要支持两种模式，与计算机相连时应作为设备端，与随身碟或耳机相连时则转换角色作为主控端</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;usb_supplying_notification_title&quot;</span>&gt;</span>USB supplying power to attached device<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;usb_charging_notification_title&quot;</span>&gt;</span>USB charging this device<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关的模式，见上层设置界面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] DEFAULT_MODES = &#123;</span><br><span class="line">    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_NONE,</span><br><span class="line">    UsbBackend.MODE_POWER_SOURCE | UsbBackend.MODE_DATA_NONE,</span><br><span class="line">    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MTP,</span><br><span class="line">    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_PTP,</span><br><span class="line">    UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MIDI</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-power-模式"><a href="#1-3-1-power-模式" class="headerlink" title="1.3.1. power 模式"></a>1.3.1. power 模式</h3><ul>
<li><p>MODE_DFP    dfp<br>DFP 是一种在host或hub上的USB Type-C端口，与device相连接 </p>
</li>
<li><p>MODE_UFP    ufp<br>UFP 是一种在device或hub上的USB Type-C端口，与host或hub的DFP相连接</p>
</li>
<li><p>MODE_DUAL    dual<br>DRP 是一种既可作为DFP或UFP进行工作的USB Type-C端口 </p>
<blockquote>
<p>DRP指的是作为Power Source（提供者）和Sink（消费者）的电源端口。例如，笔记本电脑上的USB Type-C端口支持USB-PD DRP，既可以作为Power Source（连接U盘或手机时），也可以作为Sink（连接显示器或电源适配器时）</p>
</blockquote>
</li>
</ul>
<h3 id="1-3-2-数据模式"><a href="#1-3-2-数据模式" class="headerlink" title="1.3.2. 数据模式"></a>1.3.2. 数据模式</h3><ul>
<li><p>DATA_ROLE_HOST  host</p>
<p>手机作为usb主机使用</p>
</li>
<li><p>DATA_ROLE_DEVICE device</p>
<p>手机作为USB设备使用</p>
</li>
</ul>
<h3 id="1-3-3-相关底层节点"><a href="#1-3-3-相关底层节点" class="headerlink" title="1.3.3. 相关底层节点"></a>1.3.3. 相关底层节点</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/sys/<span class="class"><span class="keyword">class</span>/<span class="title">dual_role_usb</span></span></span><br><span class="line"><span class="class"><span class="title">sp7731e_1h10</span>:/<span class="title">sys</span>/<span class="title">class</span>/<span class="title">dual_role_usb</span>/<span class="title">sprd_dual_role_usb</span> # <span class="title">ls</span> -<span class="title">l</span></span></span><br><span class="line"><span class="class"><span class="title">total</span> 0</span></span><br><span class="line"><span class="class">-<span class="title">r</span>--<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span> 4096 1970-01-01 17:49 <span class="title">data_role</span></span></span><br><span class="line"><span class="class"><span class="title">lrwxrwxrwx</span> 1 <span class="title">root</span> <span class="title">root</span>    0 1970-01-01 17:49 <span class="title">device</span> -&gt; ../../../403<span class="title">c0000</span>.<span class="title">spi</span>:<span class="title">pmic</span>@0:<span class="title">typec</span>@380</span></span><br><span class="line"><span class="class">-<span class="title">rw</span>-<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span> 4096 1970-01-01 17:49 <span class="title">mode</span></span></span><br><span class="line"><span class="class"><span class="title">drwxr</span>-<span class="title">xr</span>-<span class="title">x</span> 2 <span class="title">root</span> <span class="title">root</span>    0 1970-01-01 00:00 <span class="title">power</span></span></span><br><span class="line"><span class="class">-<span class="title">r</span>--<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span> 4096 1970-01-01 17:49 <span class="title">power_role</span></span></span><br><span class="line"><span class="class"><span class="title">lrwxrwxrwx</span> 1 <span class="title">root</span> <span class="title">root</span>    0 1970-01-01 17:49 <span class="title">subsystem</span> -&gt; ../../../../../../../../../../../<span class="title">class</span>/<span class="title">dual_role_usb</span></span></span><br><span class="line"><span class="class">-<span class="title">r</span>--<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span> 4096 1970-01-01 17:49 <span class="title">supported_modes</span></span></span><br><span class="line"><span class="class">-<span class="title">rw</span>-<span class="title">r</span>--<span class="title">r</span>-- 1 <span class="title">root</span> <span class="title">root</span> 4096 1970-01-01 00:00 <span class="title">uevent</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>supportedModes 对应支持的[power模式](#power 模式),   这一项一般是固定的(不可改变)</p>
<p>MODE_DFP | MODE_UFP | MODE_DUAL</p>
</li>
<li><p>mode </p>
<p>none&#x2F;dfp&#x2F;ufp</p>
</li>
<li><p>power_role</p>
<p>no-power&#x2F;source&#x2F;sink</p>
</li>
<li><p>data_role</p>
<p>no-data&#x2F;host&#x2F;device</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./android/<span class="number">0000</span>:<span class="number">7008</span>:A111<span class="literal">-09</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">01.953</span>  <span class="number">3432</span>  <span class="number">3450</span> I UsbPortManager: USB port changed: port=UsbPort&#123;id=sprd_dual_role_usb, supportedModes=dual&#125;, status=UsbPortStatus&#123;connected=false, currentMode=none, currentPowerRole=source, currentDataRole=host, supportedRoleCombinations=[<span class="type">source</span>:<span class="type">host</span>]&#125;, canChangeMode=true, canChangePowerRole=false, canChangeDataRole=false</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-状态切换与通知"><a href="#1-3-4-状态切换与通知" class="headerlink" title="1.3.4. 状态切换与通知"></a>1.3.4. 状态切换与通知</h3><p>Hal层通过uevent机制监控上述底层节点的变化, 通过回调PortManager注册的callback的notifyPortStatusChange函数,使portManager更新port. 同时,portManager也可以通过queryPortStatus函数向hal层查询port的信息.</p>
<ul>
<li><p>DISPOSITION_ADDED</p>
<p>底层上报的portinfo在上层的mPorts中没有找到</p>
</li>
<li><p>DISPOSITION_CHANGED</p>
<p>底层上报的portinfo在上层的mPorts中找到了,且对应的 currentMode | currentPowerRole | currentDataRole | supportedRoleCombinations 几个值中任一个改变了</p>
</li>
<li><p>DISPOSITION_REMOVED</p>
<p>上层mPorts中有的项没有在底层上报的所有portinfo中, 该项设置为Removed</p>
</li>
<li><p>DISPOSITION_READY</p>
<p>底层上报的portinfo 在上层的mPorts中,且 currentMode | currentPowerRole | currentDataRole | supportedRoleCombinations 都没变.</p>
</li>
</ul>
<p>PortManager对上层提供的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a list of physical USB ports on the device.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* This list is guaranteed to contain all dual-role USB Type C ports but it might</span></span><br><span class="line"><span class="comment">* be missing other ports depending on whether the kernel USB drivers have been</span></span><br><span class="line"><span class="comment">* updated to publish all of the device&#x27;s ports through the new &quot;dual_role_usb&quot;</span></span><br><span class="line"><span class="comment">* device class (which supports all types of ports despite its name).</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> The list of USB ports, or null if none.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UsbPort[] getPorts()</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Gets the status of the specified USB port.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> port The port to query.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> The status of the specified USB port, or null if unknown.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UsbPortStatus <span class="title function_">getPortStatus</span><span class="params">(UsbPort port)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the desired role combination of the port.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The supported role combinations depend on what is connected to the port and may be</span></span><br><span class="line"><span class="comment">* determined by consulting</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> UsbPortStatus#isRoleCombinationSupported UsbPortStatus.isRoleCombinationSupported&#125;.</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">* Note: This function is asynchronous and may fail silently without applying</span></span><br><span class="line"><span class="comment">* the requested changes.  If this function does cause a status change to occur then</span></span><br><span class="line"><span class="comment">* a &#123;<span class="doctag">@link</span> #ACTION_USB_PORT_CHANGED&#125; broadcast will be sent.</span></span><br><span class="line"><span class="comment">* &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> powerRole The desired power role: &#123;<span class="doctag">@link</span> UsbPort#POWER_ROLE_SOURCE&#125;</span></span><br><span class="line"><span class="comment">* or &#123;<span class="doctag">@link</span> UsbPort#POWER_ROLE_SINK&#125;, or 0 if no power role.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dataRole The desired data role: &#123;<span class="doctag">@link</span> UsbPort#DATA_ROLE_HOST&#125;</span></span><br><span class="line"><span class="comment">* or &#123;<span class="doctag">@link</span> UsbPort#DATA_ROLE_DEVICE&#125;, or 0 if no data role.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setPortRoles</span><span class="params">(UsbPort port, <span class="type">int</span> powerRole, <span class="type">int</span> dataRole)</span></span><br></pre></td></tr></table></figure>

<p>在有状态变更时, 发送ACTION_USB_PORT_CHANGED的广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsbPortStatus</span><span class="params">(<span class="type">int</span> currentMode, <span class="type">int</span> currentPowerRole, <span class="type">int</span> currentDataRole,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> supportedRoleCombinations)</span> &#123;</span><br><span class="line">        mCurrentMode = currentMode;</span><br><span class="line">        mCurrentPowerRole = currentPowerRole;</span><br><span class="line">        mCurrentDataRole = currentDataRole;</span><br><span class="line">        mSupportedRoleCombinations = supportedRoleCombinations;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 接收广播.</span></span><br><span class="line"><span class="keyword">if</span> (UsbManager.ACTION_USB_PORT_CHANGED.equals(intent.getAction())) &#123;</span><br><span class="line">            <span class="type">UsbPortStatus</span> <span class="variable">portStatus</span> <span class="operator">=</span> intent.getExtras()</span><br><span class="line">                    .getParcelable(UsbManager.EXTRA_PORT_STATUS);</span><br><span class="line">            <span class="keyword">if</span> (portStatus != <span class="literal">null</span>) &#123;</span><br><span class="line">                mDataRole = portStatus.getCurrentDataRole();</span><br><span class="line">                mPowerRole = portStatus.getCurrentPowerRole();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-USB-host-管理"><a href="#2-USB-host-管理" class="headerlink" title="2. USB host 管理"></a>2. USB host 管理</h1><h2 id="2-1-Usb-host-添加和删除设备"><a href="#2-1-Usb-host-添加和删除设备" class="headerlink" title="2.1. Usb host 添加和删除设备."></a>2.1. Usb host 添加和删除设备.</h2><p>UsbHostManager的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 音频管理相关</span></span><br><span class="line">mAlsaManager = <span class="keyword">new</span> <span class="title class_">UsbAlsaManager</span>(context); </span><br><span class="line"><span class="keyword">if</span> (pm.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123;</span><br><span class="line">       mHostManager = <span class="keyword">new</span> <span class="title class_">UsbHostManager</span>(context, mAlsaManager, mSettingsManager);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>UsbService systemReady时,调用UsbHostManager的systemReady</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">systemReady</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Create a thread to call into native code to wait for USB host events.</span></span><br><span class="line">        <span class="comment">// This thread will call us back on usbDeviceAdded and usbDeviceRemoved.</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="built_in">this</span>::monitorUsbHostBus;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, runnable, <span class="string">&quot;UsbService host thread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了一个线程,调用了 jni 方法 monitorUsbHostBus.</p>
<p>对应 android_server_UsbHostManager_monitorUsbHostBus </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_server_UsbHostManager_monitorUsbHostBus</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在usb_host_init 中 , 新建一个usb_host_context对象，还有新建了一个INotify，并且usb_host_context的fd就是INotify的fd。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">usb_host_context</span>* context = <span class="built_in">usb_host_init</span>();</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;usb_host_init failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this will never return so it is safe to pass thiz directly</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">usb_host_run</span>(context, usb_device_added, usb_device_removed, <span class="literal">NULL</span>, (<span class="type">void</span> *)thiz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usb_host_run</span><span class="params">(<span class="keyword">struct</span> usb_host_context *context,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_device_added_cb added_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_device_removed_cb removed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_discovery_done_cb discovery_done_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *client_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> done;</span><br><span class="line">	<span class="comment">// 先调用了usb_host_load函数，这个函数主要把add和remove的回调，放到context相应的成员变量中，然后增加了dev目录放入INotify的观察。下面循环调用usb_host_read_event函数去读取INotify fd的事件。</span></span><br><span class="line"><span class="number">1.</span>    done = <span class="built_in">usb_host_load</span>(context, added_cb, removed_cb, discovery_done_cb, client_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line"></span><br><span class="line">        done = <span class="built_in">usb_host_read_event</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* usb_host_run() */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">usb_host_load</span><span class="params">(<span class="keyword">struct</span> usb_host_context *context,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_device_added_cb added_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_device_removed_cb removed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  usb_discovery_done_cb discovery_done_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *client_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// 添加 add remove的回调</span></span><br><span class="line">    context-&gt;cb_added = added_cb;</span><br><span class="line">    context-&gt;cb_removed = removed_cb;</span><br><span class="line">    <span class="comment">// 此处client_data 指向 jni 类的thiz </span></span><br><span class="line">    context-&gt;data = client_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">D</span>(<span class="string">&quot;Created device discovery thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* watch for files added and deleted within USB_FS_DIR */</span></span><br><span class="line">    context-&gt;wddbus = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_USBFS_WD_COUNT; i++)</span><br><span class="line">        context-&gt;wds[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* watch the root for new subdirectories */</span></span><br><span class="line">    <span class="comment">// 监控 root 根节点 /dev 目录的 CREATE 和 DELETE 事件, 返回 watch 描述符</span></span><br><span class="line">    context-&gt;wdd = <span class="built_in">inotify_add_watch</span>(context-&gt;fd, DEV_DIR, IN_CREATE | IN_DELETE);</span><br><span class="line">    <span class="comment">// ..监控失败</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 监控存在的/dev/下的特定的子目录  /dev/bus/usb  同样是 CREATE 和 DELETE 事件</span></span><br><span class="line">    <span class="comment">//  MAX_USBFS_WD_COUNT = 10;   监控 最多10个 目录</span></span><br><span class="line">    <span class="comment">// /dev/bus/usb/001    ...   /dev/bus/usb/002    .. /dev/bus/usb/009</span></span><br><span class="line">    <span class="comment">// 监控成功, 描述符放在对应的 wds数组中.</span></span><br><span class="line">    <span class="built_in">watch_existing_subdirs</span>(context, context-&gt;wds, MAX_USBFS_WD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for existing devices first, after we have inotify set up */</span></span><br><span class="line">    <span class="comment">// 最后查找已经存在的/dev/bus/usb 下的目录, 找到的设备调用added_cb函数.   </span></span><br><span class="line"></span><br><span class="line">    done = <span class="built_in">find_existing_devices</span>(added_cb, client_data);</span><br><span class="line">  </span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(devname, <span class="built_in">sizeof</span>(devname), <span class="string">&quot;%s/%s&quot;</span>, busname, de-&gt;d_name);</span><br><span class="line">            <span class="comment">// devname  ex:  /dev/bus/usb/001/001 </span></span><br><span class="line">            done = <span class="built_in">added_cb</span>(devname, client_data);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处 discovery_done_cb 为空.</span></span><br><span class="line">    <span class="keyword">if</span> (discovery_done_cb)</span><br><span class="line">        done |= <span class="built_in">discovery_done_cb</span>(client_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125; <span class="comment">/* usb_host_load() */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-usb-host-load小结"><a href="#2-1-1-usb-host-load小结" class="headerlink" title="2.1.1. usb_host_load小结"></a>2.1.1. usb_host_load小结</h3><ul>
<li>启动一个线程,初始化了iNotify实例( inotify_init ),  返回fd 赋给 usb_host_context的 fd 成员</li>
<li>绑定 add remove的回调函数, added_cb\removed_cb.  赋给 usb_host_context的 cb_added |  cb_removed 成员</li>
<li>监控 root 根节点 &#x2F;dev 目录的 CREATE 和 DELETE 事件, 返回 watch 描述符 给 usb_host_context 的 wdd成员</li>
<li>监控&#x2F;dev&#x2F;bus&#x2F;usb下存在的子目录 的CREATE 和 DELETE 事件, 返回 watch描述符给 usb_host_context的wds 数组成员</li>
<li>查找&#x2F;dev&#x2F;bus&#x2F;usb&#x2F;&lt;00i&gt;&#x2F; 下的设备是否存在, 如果存在这样的设备, 调用added_cb</li>
</ul>
<h3 id="2-1-2-usb-host-read-event-监听节点"><a href="#2-1-2-usb-host-read-event-监听节点" class="headerlink" title="2.1.2. usb_host_read_event 监听节点"></a>2.1.2. usb_host_read_event 监听节点</h3><p>通过INotify中的fd读取相关的事件,usb_host_run函数会在while循环中一直循环。一直运行该函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 inotify_init 实例的fd, 读出对应的事件</span></span><br><span class="line">ret = <span class="built_in">read</span>(context-&gt;fd, event_buf, <span class="built_in">sizeof</span>(event_buf));</span><br><span class="line"><span class="keyword">while</span> (offset &lt; ret &amp;&amp; !done) &#123;</span><br><span class="line">  event = (<span class="keyword">struct</span> inotify_event*)&amp;event_buf[offset];</span><br><span class="line">  wd = event-&gt;wd;</span><br><span class="line">  <span class="comment">// watch描述符为 /dev 目录的描述符</span></span><br><span class="line">  <span class="keyword">if</span> (wd == context-&gt;wdd) &#123;</span><br><span class="line">    <span class="comment">// 如果是CREATE事件, 且创建的目录为 /dev/bus</span></span><br><span class="line">    <span class="keyword">if</span> ((event-&gt;mask &amp; IN_CREATE) &amp;&amp; !<span class="built_in">strcmp</span>(event-&gt;name, <span class="string">&quot;bus&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 添加对 /dev/bus 目录的监控, 返回watch描述符赋给 context-&gt;wddbus</span></span><br><span class="line">      context-&gt;wddbus = <span class="built_in">inotify_add_watch</span>(context-&gt;fd, DEV_BUS_DIR, IN_CREATE | IN_DELETE);</span><br><span class="line">      <span class="comment">// 监控失败, 返回done 为 1, 结束循环,退出usb_host_run函数</span></span><br><span class="line">      <span class="keyword">if</span> (context-&gt;wddbus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        done = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 监控成功, 监控/dev/bus下的子目录,  下面的过程和 usb_host_load 过程一致.</span></span><br><span class="line">        <span class="built_in">watch_existing_subdirs</span>(context, context-&gt;wds, MAX_USBFS_WD_COUNT);</span><br><span class="line">        <span class="comment">// 查找存在的/deb/bus/usb 节点, 并调用added_cb添加设备. 此处done返回0, 仍然处于循环中</span></span><br><span class="line">        done = <span class="built_in">find_existing_devices</span>(context-&gt;cb_added, context-&gt;data);</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// watch 描述符为  /dev/bus 目录的 描述符</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wd == context-&gt;wddbus) &#123;</span><br><span class="line">      <span class="comment">// 如果为 CREATE 事件, 查找存在的 /dev/bus/usb 子目录节点....</span></span><br><span class="line">      <span class="keyword">if</span> ((event-&gt;mask &amp; IN_CREATE) &amp;&amp; !<span class="built_in">strcmp</span>(event-&gt;name, <span class="string">&quot;usb&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">watch_existing_subdirs</span>(context, context-&gt;wds, MAX_USBFS_WD_COUNT);</span><br><span class="line">        done = <span class="built_in">find_existing_devices</span>(context-&gt;cb_added, context-&gt;data);</span><br><span class="line">        <span class="comment">// 为DELETE事件, 且为usb子目录被删除了, 则删除对子目录的监控</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((event-&gt;mask &amp; IN_DELETE) &amp;&amp; !<span class="built_in">strcmp</span>(event-&gt;name, <span class="string">&quot;usb&quot;</span>)) &#123;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_USBFS_WD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context-&gt;wds[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="built_in">inotify_rm_watch</span>(context-&gt;fd, context-&gt;wds[i]);</span><br><span class="line">              context-&gt;wds[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">// 如果为 /dev/bus/usb/ 目录</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (wd == context-&gt;wds[<span class="number">0</span>]) &#123;</span><br><span class="line">                i = <span class="built_in">atoi</span>(event-&gt;name);</span><br><span class="line">                <span class="built_in">snprintf</span>(path, <span class="built_in">sizeof</span>(path), USB_FS_DIR <span class="string">&quot;/%s&quot;</span>, event-&gt;name);</span><br><span class="line">                <span class="built_in">D</span>(<span class="string">&quot;%s subdirectory %s: index: %d\n&quot;</span>, (event-&gt;mask &amp; IN_CREATE) ?</span><br><span class="line">                        <span class="string">&quot;new&quot;</span> : <span class="string">&quot;gone&quot;</span>, path, i);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; MAX_USBFS_WD_COUNT) &#123;</span><br><span class="line">                    <span class="type">int</span> local_ret = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 新建了该目录  (001-00MAX_USBFS_WD_COUNT的新建)</span></span><br><span class="line">                    <span class="keyword">if</span> (event-&gt;mask &amp; IN_CREATE) &#123;</span><br><span class="line">                        <span class="comment">// 添加对该目录的监控 </span></span><br><span class="line">                        local_ret = <span class="built_in">inotify_add_watch</span>(context-&gt;fd, path,</span><br><span class="line">                                IN_CREATE | IN_DELETE);</span><br><span class="line">                        <span class="keyword">if</span> (local_ret &gt;= <span class="number">0</span>)</span><br><span class="line">                            context-&gt;wds[i] = local_ret;</span><br><span class="line">                        <span class="comment">// 查找该目录下的文件, 并调用added_cb添加设备</span></span><br><span class="line">                        done = <span class="built_in">find_existing_devices_bus</span>(path, context-&gt;cb_added,</span><br><span class="line">                                context-&gt;data);</span><br><span class="line">                      <span class="comment">// 删除了该目录</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;mask &amp; IN_DELETE) &#123;</span><br><span class="line">                        <span class="comment">// 对该目录取消监控</span></span><br><span class="line">                        <span class="built_in">inotify_rm_watch</span>(context-&gt;fd, context-&gt;wds[i]);</span><br><span class="line">                        context-&gt;wds[i] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">      <span class="comment">// 如果为 /dev/bus/usb/&lt;001-00MAX_USBFS_WD_COUNT&gt; 目录</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; (i &lt; MAX_USBFS_WD_COUNT) &amp;&amp; !done; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (wd == context-&gt;wds[i]) &#123;</span><br><span class="line">                        <span class="built_in">snprintf</span>(path, <span class="built_in">sizeof</span>(path), USB_FS_DIR <span class="string">&quot;/%03d/%s&quot;</span>, i, event-&gt;name);</span><br><span class="line">                        <span class="keyword">if</span> (event-&gt;mask == IN_CREATE) &#123;</span><br><span class="line">                            <span class="built_in">D</span>(<span class="string">&quot;new device %s\n&quot;</span>, path);</span><br><span class="line">                            done = context-&gt;<span class="built_in">cb_added</span>(path, context-&gt;data);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;mask == IN_DELETE) &#123;</span><br><span class="line">                            <span class="built_in">D</span>(<span class="string">&quot;gone device %s\n&quot;</span>, path);</span><br><span class="line">                            done = context-&gt;<span class="built_in">cb_removed</span>(path, context-&gt;data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// 读取下一个 inotify_event 事件</span></span><br><span class="line">      offset += <span class="built_in">sizeof</span>(<span class="keyword">struct</span> inotify_event) + event-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-1-2-1-usb-host-read-event-小结"><a href="#2-1-2-1-usb-host-read-event-小结" class="headerlink" title="2.1.2.1. usb_host_read_event 小结"></a>2.1.2.1. usb_host_read_event 小结</h4><p>该函数即读取此次的inotify实例的fd,  放在event_buf数组中(包含多个inotify_event 事件.), 每个事件都有一个watch fd,</p>
<p>将watch fd 与之前建立的 watch fd比较, 判断是哪一个根目录的事件, 过滤出CREATE 和 DELETE 事件, 再由目录的层级添加对其子目录的监控,如果是CREATE事件,则查找目录下可能存在的usb设备节点, 找到调用added_cb添加解析设备,通知上层添加usb设备. 如果是 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;&lt;001-00MAX_USBFS_WD_COUNT&gt; 目录下的CREATE| DELETE 事件, 则直接添加删除设备,并通知到上层.只有在监控&#x2F;dev目录失败的情况下,才会退出循环,也就是终止线程的运行.其他情况都是返回0,不退出循环,线程一直执行.</p>
<h3 id="2-1-3-两个回调函数"><a href="#2-1-3-两个回调函数" class="headerlink" title="2.1.3. 两个回调函数"></a>2.1.3. 两个回调函数</h3><p>绑定的两个回调函数为 usb_device_added\usb_device_removed, 这两个函数在jni层.</p>
<p>着重介绍usb_device_added函数.</p>
<p>参数: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *devname   <span class="comment">//native 层通过inotify找到的设备名称  ex: /dev/bus/usb/001/001</span></span><br><span class="line"><span class="type">void</span>* client_data    <span class="comment">// jni 层的thiz </span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-usb-device-added方法添加设备"><a href="#2-1-4-usb-device-added方法添加设备" class="headerlink" title="2.1.4. usb_device_added方法添加设备"></a>2.1.4. usb_device_added方法添加设备</h3><p>先调用usb_device_open 方法打开该设备文件, 返回usb_device结构体.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">usb_device</span> &#123;</span><br><span class="line">    <span class="type">char</span> dev_name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> desc[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> desc_length;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> writeable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dev_file</p>
<p><img src="/images/usb_dev_file.png" alt="usb_dev_file"></p>
<p>该结构体中 desc为 设备描述内容(包含一个设备描述符&#x2F;n个配置描述符&#x2F;n个接口描述符&#x2F;n个端点描述符) , desc最大大小为4096, len中保存了实际的desc的大小, 即 &#x2F;dev&#x2F;bus&#x2F;usb&#x2F;001&#x2F;001 的文件大小.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jboolean result = env-&gt;<span class="built_in">CallBooleanMethod</span>(thiz, method_beginUsbDeviceAdded,</span><br><span class="line">        deviceName, <span class="built_in">usb_device_get_vendor_id</span>(device), <span class="built_in">usb_device_get_product_id</span>(device),</span><br><span class="line">        deviceDesc-&gt;bDeviceClass, deviceDesc-&gt;bDeviceSubClass, deviceDesc-&gt;bDeviceProtocol,</span><br><span class="line">        manufacturerName, productName, version, serialNumber);</span><br></pre></td></tr></table></figure>
<p>在USB设备枚举过程中，主机端的协义软件需要解析从USB设备读取的所有描述符信息。在USB主向设备发送读取描述符的请求后，USB设备将所有的描述符以连续的数据流方式传输给USB主机。主机从第一个读到的字符开始，根据双方规定好的数据格式，顺序地解析读到的数据流</p>
<p><strong>设备描述符</strong>：给出了USB设备的一般信息，一个设备描述符可以有多个配置描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">usb_device_descriptor</span> &#123;  </span><br><span class="line">    __u8  bLength;<span class="comment">//设备描述符的字节数大小，为0x12   </span></span><br><span class="line">    __u8  bDescriptorType;<span class="comment">//描述符类型编号，为0x01   </span></span><br><span class="line">  </span><br><span class="line">    __le16 bcdUSB;<span class="comment">//USB 规范发布号．表示了本设备能适用于那种协议，如2.0=0200，1.1=0110等． </span></span><br><span class="line">    __u8  bDeviceClass;<span class="comment">//USB设备类代码，由USB-IF分配，如果该字段为0x00，表示由接口描述符来指定（有可能该USB设备是一个复合设备，USB设备的各个接口相互独立，分别属于不同的设备类）。如果是0x01~0xfe，表示为USB-IF定义的设备类，例如0x03为HID设备，0x09为HUB设备。如果是0xff，表示由厂商自定义设备类型      </span></span><br><span class="line">    <span class="comment">//0x00不是在设备描述符中定义的，如HID   </span></span><br><span class="line">    __u8  bDeviceSubClass;<span class="comment">//子类型代码（由USB分配）．如果bDeviceClass值是0，一定要设置为0．其它情况就跟据USB-IF组织定义的编码． </span></span><br><span class="line">    __u8  bDeviceProtocol;<span class="comment">// 协议代码（由USB分配）．如果使用USB-IF组织定义的协议，就需要设置这里的值，否则直接设置为0。如果厂商自己定义的可以设置为FFH．</span></span><br><span class="line">    __u8  bMaxPacketSize0;<span class="comment">//端点０最大分组大小（只有8,16,32,64有效）  </span></span><br><span class="line">    __le16 idVendor;<span class="comment">//供应商ID（由USB分配）．</span></span><br><span class="line">    __le16 idProduct;<span class="comment">//产品ID（由厂商分配）．由供应商ID和产品ID，就可以让操作系统加载不同的驱动程序． </span></span><br><span class="line">    __le16 bcdDevice;<span class="comment">//设备出产编码．由厂家自行设置．</span></span><br><span class="line">    __u8  iManufacturer;<span class="comment">//厂商描述符字符串索引．索引到对应的字符串描述符． 为０则表示没有．  </span></span><br><span class="line">    __u8  iProduct;<span class="comment">//描述产品字符串的索引  </span></span><br><span class="line">    __u8  iSerialNumber;<span class="comment">//描述设备序列号字符串的索引   </span></span><br><span class="line">    __u8  bNumConfigurations;<span class="comment">//可能的配置数．指配置字符串的个数</span></span><br><span class="line">&#125; __attribute__ ((packed)); </span><br></pre></td></tr></table></figure>

<p>设备描述符给出了USB设备的一般信息，包括对设备及在设备配置中起全程作用的信息，包括制造商标识号ID、产品序列号、所属设备类号、默认端点的最大包长度和配置描述符的个数等。一个USB设备必须有且仅有一个设备描述符。设备描述符是设备连接到总线上时USB主机所读取的第一个描述符.</p>
<p><strong>配置描述符</strong>：配置描述符定义了设备的配置信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USB_CONFIGURATION_DESCRIPTOR_</span></span><br><span class="line">&#123;</span><br><span class="line">    BYTE      bLength,   <span class="comment">// 描述符大小．固定为0x09．</span></span><br><span class="line">    BYTE      bDescriptorType,  <span class="comment">// 配置描述符类型．固定为0x02．</span></span><br><span class="line">    WORD      wTotalLength, <span class="comment">//  返回整个数据的长度．指此配置返回的配置描述符，接口描述符以及端点描述符的全部大小．</span></span><br><span class="line">    BYTE      bNumInterfaces, <span class="comment">// 配置所支持的接口数．指该配置配备的接口数量，也表示该配置下接口描述符数量．</span></span><br><span class="line">    BYTE      bConfigurationValue, <span class="comment">// 作为Set Configuration的一个参数选择配置值．</span></span><br><span class="line">    BYTE      iConfiguration, <span class="comment">//用于描述该配置字符串描述符的索引．</span></span><br><span class="line">    BYTE      bmAttributes, <span class="comment">// 供电模式选择．Bit4-0保留，D7:总线供电，D6:自供电，D5:远程唤醒．</span></span><br><span class="line">    BYTE      MaxPower <span class="comment">//总线供电的USB设备的最大消耗电流．以2mA为单位．</span></span><br><span class="line">&#125;USB_CONFIGURATION_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>配置描述符中包括了描述符的长度（属于此描述符的所有接口描述符和端点描述符的长度的和）、供电方式（自供电&#x2F;总线供电）、最大耗电量等。主果主机发出USB标准命令Get_Descriptor要求得到设备的某个配置描述符，那么除了此配置描述符以外，此配置包含的所有接口描述符与端点描述符都将提供给USB主机。</p>
<p><strong>接口描述符</strong>：接口描述符说明了接口所提供的配置，一个配置所拥有的接口数量通过配置描述符的bNumInterfaces决定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USB_INTERFACE_DESCRIPTOR_</span></span><br><span class="line">&#123;</span><br><span class="line">    BYTE      bLength, <span class="comment">// 描述符大小．固定为0x09．</span></span><br><span class="line">    BYTE      bDescriptorType, <span class="comment">// 接口描述符类型．固定为0x04．</span></span><br><span class="line">    BYTE      bInterfaceNumber, <span class="comment">// 该接口的编号．</span></span><br><span class="line">    BYTE      bAlternateSetting, <span class="comment">// 用于为上一个字段选择可供替换的位置．即备用的接口描述符标号．</span></span><br><span class="line">    BYTE      bNumEndpoint, <span class="comment">// 使用的端点数目．端点０除外．</span></span><br><span class="line">    BYTE      bInterfaceClass, <span class="comment">// 类型代码（由USB分配）．</span></span><br><span class="line">    BYTE      bInterfaceSubClass, <span class="comment">// 子类型代码（由USB分配）．</span></span><br><span class="line">    BYTE      bInterfaceProtocol, <span class="comment">// 协议代码（由USB分配）．</span></span><br><span class="line">    BYTE      iInterface <span class="comment">// 字符串描述符的索引</span></span><br><span class="line">&#125;USB_INTERFACE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为<code>功能</code>更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p>
<p>　　如果一个配置描述符不止支持一个接口描述符，并且每个接口描述符都有一个或多个端点描述符，那么在响应USB主机的配置描述符命令时，USB设备的端点描述符总是紧跟着相关的接口描述符后面，作为配置描述符的一部分被返回。接口描述符不可直接用Set_Descriptor和Get_Descriptor来存取。</p>
<p>　　如果一个接口仅使用端点0，则接口描述符以后就不再返回端点描述符，并且此接口表现的是一个控制接口的特性，它使用与端点0相关联的默认管道进行数据传输。在这种情况下bNumberEndpoints域应被设置成0。接口描述符在说明端点个数并不把端点0计算在内。</p>
<p><strong>端点描述符</strong>：USB设备中的每个端点都有自己的端点描述符，由接口描述符中的bNumEndpoint决定其数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USB_ENDPOINT_DESCRIPTOR_</span></span><br><span class="line">&#123;</span><br><span class="line">    BYTE        bLength, <span class="comment">//描述符大小．固定为0x07．</span></span><br><span class="line">    BYTE        bDescriptorType, <span class="comment">// 接口描述符类型．固定为0x05．</span></span><br><span class="line">    BYTE        bEndpointAddress, <span class="comment">// USB设备的端点地址．Bit7，方向，对于控制端点可以忽略，1/0:IN/OUT．Bit6-4，保留．BIt3-0：端点号．</span></span><br><span class="line">    BYTE        bmAttributes, <span class="comment">// 端点属性．Bit7-2，保留．BIt1-0：00控制，01同步，02批量，03中断．</span></span><br><span class="line">    WORD      wMaxPacketSize, <span class="comment">//  本端点接收或发送的最大信息包大小．</span></span><br><span class="line">    BYTE        bInterval <span class="comment">// 轮循数据传送端点的时间间隔．对于批量传送和控制传送的端点忽略．对于同步传送的端点，必须为１，对于中断传送的端点，范围为１－２５５．对于全速/低速的中断端点，取值范围为 1~255，对于高速中断端点，取值范围为1~16，详细定义可以参考USB协议</span></span><br><span class="line">&#125;USB_ENDPOINT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。　　</p>
<p>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p>
<p>在将设备描述符的信息发到上层后, 接着遍历设备的各种描述符,之后调用endUsbDeviceAdded结束添加设备</p>
<h3 id="2-1-5-描述符解析"><a href="#2-1-5-描述符解析" class="headerlink" title="2.1.5. 描述符解析"></a>2.1.5. 描述符解析</h3><p>设备描述符&#x2F;配置描述符&#x2F;接口描述符&#x2F;端点描述符继承父类<code>UsbDescriptor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbDescriptor</span>&#123;</span><br><span class="line">-<span class="type">int</span> mLength</span><br><span class="line">-<span class="type">byte</span> mType</span><br><span class="line">---</span><br><span class="line">+postParse(ByteStream stream)</span><br><span class="line">+&lt;b&gt;parseRawDescriptors(ByteStream stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbDeviceDescriptor</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbConfigDescriptor</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbEndpointDescriptor</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbInterfaceDescriptor</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbUnknown</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbACInterface</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbHIDDescriptor</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbInterfaceAssoc</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbACEndpoint</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"><span class="keyword">package</span> UsbACEndpoint &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbACAudioControlEndpoint</span> <span class="keyword">extends</span> <span class="title class_">UsbACEndpoint</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbACAudioStreamEndpoint</span> <span class="keyword">extends</span> <span class="title class_">UsbACEndpoint</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbACMidiEndpoint</span> <span class="keyword">extends</span> <span class="title class_">UsbACEndpoint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbACInterface</span> <span class="keyword">extends</span> <span class="title class_">UsbDescriptor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> UsbACInterface &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb10ASGeneral</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb20ASGeneral</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbACFeatureUnit</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbACMixerUnit</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbMSMidiInputJack</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UsbMSMidiOutputJack</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line">class ... <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbACTerminal</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">UsbACHeaderInterface</span> <span class="keyword">extends</span> <span class="title class_">UsbACInterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> UsbACHeaderInterface&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb10ACHeader</span> <span class="keyword">extends</span> <span class="title class_">UsbACHeaderInterface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb20ACHeader</span> <span class="keyword">extends</span> <span class="title class_">UsbACHeaderInterface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> UsbACTerminal &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb10ACOutputTerminal</span> <span class="keyword">extends</span> <span class="title class_">UsbACTerminal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb10ACInputTerminal</span> <span class="keyword">extends</span> <span class="title class_">UsbACTerminal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb20ACInputTerminal</span> <span class="keyword">extends</span> <span class="title class_">UsbACTerminal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Usb20ACOutputTerminal</span> <span class="keyword">extends</span> <span class="title class_">UsbACTerminal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承parseRawDescriptors方法, descriptor前两个字节中存放了长度和类型.解析时根据长度和类型最终将一个device中存放的descriptor的全部描述符全部解析出来.</p>
<h5 id="2-1-5-1-1-USB-端点、管道和接口的关系"><a href="#2-1-5-1-1-USB-端点、管道和接口的关系" class="headerlink" title="2.1.5.1.1. USB 端点、管道和接口的关系"></a>2.1.5.1.1. USB 端点、管道和接口的关系</h5><p>USB 系统中数据的传输，宏观的看来是在HOST 和 USB 功能设备之间进行；微观的看是在应用软件的 Buffer 和 USB 功能设备的端点之间进行。一般来说端点都有 Buffer，可以认为USB通讯就是应用软件Buffer和设备端点Buffer之间的数据交换，交换的通道称为管道。应用软件通过和设备之间的数据交换来完成设备的控制和数据传输。通常需要多个管道来完成数据交换，因为同一管道只支持一种类型的数据传输。用在一起来对设备进行控制的若干管道称为设备的接口;</p>
<p>一个 USB 设备可以包括若干个端点，不同的端点以端点编号和方向区分。不同端点可以支持不同的传输类型、访问间隔以及最大数据包大小。除端点 0外，所有的端点只支持一个方向的数据传输。端点 0是一个特殊的端点，它支持双向的控制传输。管道和端点关联，和关联的端点有相同的属性，如支持的传输类型、最大包长度、传输方向等。</p>
<p><img src="/images/usb_interface.png" alt="usb_interface"></p>
<h3 id="2-1-6-added-cb-回调小结"><a href="#2-1-6-added-cb-回调小结" class="headerlink" title="2.1.6. added_cb 回调小结"></a>2.1.6. added_cb 回调小结</h3><ul>
<li>将设备描述符的参数通过<code>beginUsbDeviceAdded</code>会传给上层</li>
<li>将配置描述符的参数通过<code>addUsbConfiguration</code>回传给上层</li>
<li>将接口描述符的参数通过<code>addUsbInterface</code>回传给上层</li>
<li>将端口描述符的参数通过<code>addUsbEndpoint</code>回传给上层</li>
<li>最后调用endUsbDeviceAdded方法回调上层结束该设备的添加过程.</li>
</ul>
<p>beginUsbDeviceAdded:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 UsbDevice 对象, 并初始化和其绑定的 mNewConfigurations| mNewInterfaces | mNewEndpoints集合</span></span><br><span class="line">mNewDevice = <span class="keyword">new</span> <span class="title class_">UsbDevice</span>(deviceName, vendorID, productID,</span><br><span class="line">                    deviceClass, deviceSubclass, deviceProtocol,</span><br><span class="line">                    manufacturerName, productName, versionString, serialNumber);</span><br><span class="line"></span><br><span class="line">            mNewConfigurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            mNewInterfaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            mNewEndpoints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个  UsbConfiguration对象,并保存到   mNewConfigurations 集合中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addUsbConfiguration</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> attributes, <span class="type">int</span> maxPower)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNewConfiguration != <span class="literal">null</span>) &#123;</span><br><span class="line">            mNewConfiguration.setInterfaces(</span><br><span class="line">                    mNewInterfaces.toArray(<span class="keyword">new</span> <span class="title class_">UsbInterface</span>[mNewInterfaces.size()]));</span><br><span class="line">            mNewInterfaces.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNewConfiguration = <span class="keyword">new</span> <span class="title class_">UsbConfiguration</span>(id, name, attributes, maxPower);</span><br><span class="line">        mNewConfigurations.add(mNewConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 新建一个  UsbInterface,并保存到   mNewInterfaces 集合中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addUsbInterface</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> altSetting,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> Class, <span class="type">int</span> subClass, <span class="type">int</span> protocol)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNewInterface != <span class="literal">null</span>) &#123;</span><br><span class="line">            mNewInterface.setEndpoints(</span><br><span class="line">                    mNewEndpoints.toArray(<span class="keyword">new</span> <span class="title class_">UsbEndpoint</span>[mNewEndpoints.size()]));</span><br><span class="line">            mNewEndpoints.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNewInterface = <span class="keyword">new</span> <span class="title class_">UsbInterface</span>(id, altSetting, name, Class, subClass, protocol);</span><br><span class="line">        mNewInterfaces.add(mNewInterface);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 新建一个  UsbEndpoint,并保存到   mNewEndpoints 集合中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addUsbEndpoint</span><span class="params">(<span class="type">int</span> address, <span class="type">int</span> attributes, <span class="type">int</span> maxPacketSize, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">        mNewEndpoints.add(<span class="keyword">new</span> <span class="title class_">UsbEndpoint</span>(address, attributes, maxPacketSize, interval));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">endUsbDeviceAdded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNewInterface != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 接口描述符需要绑定端口描述符集合</span></span><br><span class="line">        mNewInterface.setEndpoints(</span><br><span class="line">                mNewEndpoints.toArray(<span class="keyword">new</span> <span class="title class_">UsbEndpoint</span>[mNewEndpoints.size()]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNewConfiguration != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 配置描述符需要绑定接口描述符集合</span></span><br><span class="line">        mNewConfiguration.setInterfaces(</span><br><span class="line">                mNewInterfaces.toArray(<span class="keyword">new</span> <span class="title class_">UsbInterface</span>[mNewInterfaces.size()]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNewDevice != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 设备描述符需要绑定配置描述符集合</span></span><br><span class="line">            mNewDevice.setConfigurations(</span><br><span class="line">                    mNewConfigurations.toArray(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">UsbConfiguration</span>[mNewConfigurations.size()]));</span><br><span class="line">            mDevices.put(mNewDevice.getDeviceName(), mNewDevice);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// It is fine to call this only for the current user as all broadcasts are sent to</span></span><br><span class="line">            <span class="comment">// all profiles of the user and the dialogs should only show once.</span></span><br><span class="line">            <span class="type">ComponentName</span> <span class="variable">usbDeviceConnectionHandler</span> <span class="operator">=</span> getUsbDeviceConnectionHandler();</span><br><span class="line">            <span class="keyword">if</span> (usbDeviceConnectionHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                getCurrentUserSettings().deviceAttached(mNewDevice);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getCurrentUserSettings().deviceAttachedForFixedHandler(mNewDevice,</span><br><span class="line">                        usbDeviceConnectionHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// deviceName is something like: &quot;/dev/bus/usb/001/001&quot;</span></span><br><span class="line">            <span class="type">UsbDescriptorParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbDescriptorParser</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isInputHeadset</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOutputHeadset</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (parser.parseDevice(mNewDevice.getDeviceName())) &#123;</span><br><span class="line">                isInputHeadset = parser.isInputHeadset();</span><br><span class="line">                isOutputHeadset = parser.isOutputHeadset();</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;---- isHeadset[in: &quot;</span> + isInputHeadset</span><br><span class="line">                        + <span class="string">&quot; , out: &quot;</span> + isOutputHeadset + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果为音频设备,通过UsbAlsaManager处理</span></span><br><span class="line">            mUsbAlsaManager.usbDeviceAdded(mNewDevice,</span><br><span class="line">                    isInputHeadset, isOutputHeadset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tianchiyuyin/p/5139948.html">描述符的相关信息可参考这里</a></p>
<p>其中几个参数描述了这几个描述符的关系:</p>
<ol>
<li>设备描述符中的 bNumConfigurations : 可能的配置数．指配置字符串的个数</li>
<li>配置描述符中的bNumInterfaces, 指接口描述符的个数</li>
<li>接口描述符中的bNumEndpoint, 指定端口描述符的个数</li>
</ol>
<p>除上述几种必须的描述符外, 还有字符串描述符，HID描述符，报告描述符等等.</p>
<h3 id="2-1-7-usb-device-removed方法销毁设备"><a href="#2-1-7-usb-device-removed方法销毁设备" class="headerlink" title="2.1.7. usb_device_removed方法销毁设备"></a>2.1.7. usb_device_removed方法销毁设备</h3><p>调用 usbDeviceRemoved 销毁deviceName对应的设备. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">usbDeviceRemoved</span><span class="params">(String deviceName)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="type">UsbDevice</span> <span class="variable">device</span> <span class="operator">=</span> mDevices.remove(deviceName);</span><br><span class="line">        <span class="keyword">if</span> (device != <span class="literal">null</span>) &#123;</span><br><span class="line">            mUsbAlsaManager.usbDeviceRemoved(device);</span><br><span class="line">            mSettingsManager.usbDeviceRemoved(device);</span><br><span class="line">            getCurrentUserSettings().usbDeviceRemoved(device);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-上层获取USB-设备并进行传输"><a href="#2-2-上层获取USB-设备并进行传输" class="headerlink" title="2.2. 上层获取USB 设备并进行传输"></a>2.2. 上层获取USB 设备并进行传输</h2><p>UsbManager提供了getDeviceList函数,获取当前的usb设备列表, </p>
<p>最终调用到UsbHostManager中,从其保存的mDevices中拿到设备列表. </p>
<p>拿到设备(UsbDevice)后,可以通过openDevice打开这个设备. 返回 UsbDeviceConnection 对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UsbDeviceConnection <span class="title function_">openDevice</span><span class="params">(UsbDevice device)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">deviceName</span> <span class="operator">=</span> device.getDeviceName();</span><br><span class="line">        <span class="type">ParcelFileDescriptor</span> <span class="variable">pfd</span> <span class="operator">=</span> mService.openDevice(deviceName);</span><br><span class="line">        <span class="keyword">if</span> (pfd != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UsbDeviceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbDeviceConnection</span>(device);</span><br><span class="line">            <span class="comment">// open中调到了 native_open 为native方法, 调用到了jni层打开该设备.</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> connection.open(deviceName, pfd, mContext);</span><br><span class="line">            pfd.close();</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了另一个jni类(<a target="_blank" rel="noopener" href="http://10.0.1.79:8081/source/xref/sprdroid8.1_trunk/frameworks/base/core/jni/android_hardware_UsbDeviceConnection.cpp">android_hardware_UsbDeviceConnection.cpp</a>)</p>
<p>native_open中主要调用了usb_device_new函数(见这里<a href="#open_device">open_device</a>), 返回了 native层 usb_device结构. 并将device跟field_context关联起来.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">usb_device</span>* device = <span class="built_in">usb_device_new</span>(deviceNameStr, fd);</span><br><span class="line"><span class="keyword">if</span> (device) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">SetLongField</span>(thiz, field_context, (jlong)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后用户进程获取的对象就是UsbDeviceConnection，使用UsbDeviceConnection访问usb设备时,最终都会通过field_context找到device.</p>
<h3 id="2-2-1-USB传输通信"><a href="#2-2-1-USB传输通信" class="headerlink" title="2.2.1. USB传输通信"></a>2.2.1. USB传输通信</h3><p>google提供了控制传输的两个方法:  <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection.html">官方资料</a></p>
<ul>
<li><p>bulkTransfer (块传输)    在bulk endpoint上进行传输<br>bulkTransfer(UsbEndpoint endpoint, byte[] buffer, int length, int timeout)；<br>在给定的端点执行一个bulk transaction；<br>参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint: OUT <span class="keyword">or</span> IN（Host to Device用OUT，Device to Host 用IN）；</span><br><span class="line">buffer  : 将要发送/接收的指令或数据，当endpoint为OUT，buffer为你定义好的指令或数据，将下发给device，当endpoint为IN，buffer则是一个容器，用来存储device返回的应答指令或数据，注意buffer的大小，以足够存储所有的数据；</span><br><span class="line">length  : 即发送/接收指令或数据的大小；</span><br><span class="line">timeout : 即指令或数据的最长通讯时间，在通讯出现问题时，若超时还未通讯完成，视为通讯失败；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  每个数据包长度高速的时候为512字节，低速设备最大64个字节；用于主机与USB设备之间的批量数据传输，通常一次块传输需要分解成若干个块传输事务。</p>
<p>  一次块传输的方向是单一的，对主机而言，要么是输入，要么是输出。因此，一次块传输是由若干个IN事务或由若干个OUT事务组成的。</p>
<p>  对于要进行输入的块传输，一般要执行若干个IN事务。每执行一个IN事务时，主机都首先发出IN令牌包。设备端点收到后做出响应，一般是回送一个数据包。如果不能回送数据，则回送NAK包或STALL包。NAK表示设备暂时不能回送数据；STALL表示端点一直停着或需要IJSB系统软件进行干预；如果主机收到合法数据包，则回以ACK握手包；如果主机在接收数据时发现有错，则不给设备任何回音。</p>
<p>  对于要进行输出的块传输，一般要执行若干个 OUT事务。每执行一个OUT事务时，主机都首先发出OUT令牌包，接着发出数据包。设备在收到数据包后，根据情况回以握手包；回以ACK表示数据已接收 无误，并通知主机可开始下一个0UT事务，以便传送下一个数据包；回以NAK表示数据已接收无误，但是主机不要再送数据，因为设备暂时不能接收(如缓冲区 满)；如果端点已终止，则回以STALL，通知主机不要再重发数据，因为设备出现了故障；如果接收时出现CRC校验错，则不发任何握手包。如果需要输入、输出同时进行，则需要使用2个端点。</p>
</blockquote>
</li>
<li><p>controlTransfer  (控制传输)<br>controlTransfer(int requestType, int request, int value, int index, byte[] buffer, int length, int timeout)<br>零点传输执行一个control transaction，即所有的通讯都是通过endpoint 0；<br>参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestType，  request type <span class="keyword">for</span> <span class="keyword">this</span> transaction 设置通信的方向</span><br><span class="line">       request      ，request ID <span class="keyword">for</span> <span class="keyword">this</span> transaction   设置的是访问的类型</span><br><span class="line">       value         ，value field <span class="keyword">for</span> <span class="keyword">this</span> transaction  </span><br><span class="line">       index         ，index field <span class="keyword">for</span> <span class="keyword">this</span> transaction</span><br><span class="line">       buffer       ，同<span class="built_in">bulkTransfer</span>()</span><br><span class="line">       length       ，同<span class="built_in">bulkTransfer</span>()</span><br><span class="line">       timeout     ，同<span class="built_in">bulkTransfer</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>该函数可以设置设备信息,可以看下面的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeThisDeviceAnAccessory</span><span class="params">(<span class="meta">@NonNull</span> UsbDeviceConnection connection)</span> &#123;</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MANUFACTURER,</span><br><span class="line">            <span class="string">&quot;Android&quot;</span>);</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MODEL,</span><br><span class="line">            <span class="string">&quot;Android device&quot;</span>);</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_DESCRIPTION,</span><br><span class="line">            <span class="string">&quot;Android device running CTS verifier&quot;</span>);</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_VERSION, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_URI,</span><br><span class="line">            <span class="string">&quot;https://source.android.com/compatibility/cts/verifier.html&quot;</span>);</span><br><span class="line">    AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_SERIAL, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送ACCESSORY_START 指令开始usb数据传输</span></span><br><span class="line">    AoapInterface.sendAoapStart(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendString</span><span class="params">(UsbDeviceConnection conn, <span class="type">int</span> index, String string)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = (string + <span class="string">&quot;\0&quot;</span>).getBytes();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> conn.controlTransfer(</span><br><span class="line">                <span class="comment">// host to device</span></span><br><span class="line">                UsbConstants.USB_DIR_OUT | UsbConstants.USB_TYPE_VENDOR,</span><br><span class="line">                AoapInterface.ACCESSORY_SEND_STRING, <span class="number">0</span>, index,</span><br><span class="line">                buffer, buffer.length, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">if</span> (len != buffer.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to send string &quot;</span> + index + <span class="string">&quot;: \&quot;&quot;</span> + string + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Sent string &quot;</span> + index + <span class="string">&quot;: \&quot;&quot;</span> + string + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>定制了设备的  MANUFACTURER &#x2F; DESCRIPTION &#x2F; VERSION 等的信息. 设置了相关的String信息后,可以从device设备上读取相应的信息.  同样通过 controlTransfer 函数, 不过requestType变为了 USB_DIR_IN.</p>
<p>USB 体系四种传输类型:</p>
<ul>
<li><p>控制传输：主要用于在设备连接时对设备进行枚举以及其他因设备而异的特定操作。</p>
</li>
<li><p>中断传输：用于对延迟要求严格、小数据的可靠传输，如键盘、游戏手柄等。</p>
</li>
<li><p>批量传输：用于对延迟要求宽松，游戏手柄等大量数据的可靠传输，如U盘等, 该模式即为块传输。</p>
</li>
<li><p>同步传输：用于对可靠性要求不高的实时数据传输，如摄像头、USB音响等.</p>
<p>  不同的传输类型在物理上并没有太大的区别，只是在传输机制、主机安排传输任务、可占用USB 带宽的限制以及最大包长度有一定的差异。</p>
</li>
</ul>
<h2 id="2-3-UsbAlsaManager-音频管理"><a href="#2-3-UsbAlsaManager-音频管理" class="headerlink" title="2.3. UsbAlsaManager 音频管理"></a>2.3. UsbAlsaManager 音频管理</h2><h3 id="2-3-1-UsbAlsaManager初始化"><a href="#2-3-1-UsbAlsaManager初始化" class="headerlink" title="2.3.1. UsbAlsaManager初始化"></a>2.3.1. UsbAlsaManager初始化</h3><p>进行初始化扫描, 调用了AlsaCardsParser类对<code>&quot;/proc/asound/cards&quot;</code> 文件进行扫描</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlsaCardsParser的scan方法</span></span><br><span class="line">mCardsParser.scan();</span><br></pre></td></tr></table></figure>

<p>扫描结果存放到AlsaCardRecord数组中 (mCardRecords) , 查看AlsaCardRecord的结构如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>     <span class="variable">mCardNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span>  <span class="variable">mField1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span>  <span class="variable">mCardName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span>  <span class="variable">mCardDescription</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//只有是usb audio设备该字段才有意义</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">mIsUsb</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>其中mIsUsb标明该音频设备是否是Usb设备. 判断标准是 包含 <code>at usb-</code> 关键字</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bullhead:/proc/asound <span class="comment"># cat cards</span></span><br><span class="line"> <span class="number">0</span> [<span class="type">msm8994tomtomsn</span>]: msm8994<span class="literal">-tomtom-</span> - msm8994<span class="literal">-tomtom-snd-card</span></span><br><span class="line">                      msm8994<span class="literal">-tomtom-snd-card</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-UsbAlsaManager-systemReady"><a href="#2-3-2-UsbAlsaManager-systemReady" class="headerlink" title="2.3.2. UsbAlsaManager systemReady"></a>2.3.2. UsbAlsaManager systemReady</h3><p>systemReady时添加对<code> /dev/snd/</code> 下的文件监控, 监控新建和删除.</p>
<p>同时对其下面的文件调用alsaFileAdded方法, 添加已经存在的设备.</p>
<p>新建文件时,回调alsaFileAdded方法, 删除了文件时回调 alsaFileRemoved 方法</p>
<p>对于alsaFileAdded方法, 过滤目录下文件名:</p>
<ul>
<li>文件名以<code>pcmC</code>开头的,以<code>p</code>结束的为TYPE_PLAYBACK设备(播放设备)</li>
<li>文件名以<code>pcmC</code>开头的,以<code>c</code>结束的为TYPE_CAPTURE设备(录音设备)</li>
<li>文件名以<code>midiC</code>开头的,为TYPE_MIDI设备.</li>
</ul>
<p>对于播放设备和录音设备, 创建<em>AlsaDevice</em>,并以filename为key存放到mAlsaDevices  的map中保存起来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ex:     /dev/snd/pcmC0D34c</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> mCard;   <span class="comment">//对应C后的一位</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> mDevice; <span class="comment">//对应D- c|p中间的位</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> mType;   <span class="comment">//对应其类型</span></span><br></pre></td></tr></table></figure>
<p>对于alsaFileRemoved方法, 只需要将filename对应key的 AlsaDevice 从mAlsaDevices中删除即可.</p>
<h3 id="2-3-3-usbDeviceAdded-事件回调"><a href="#2-3-3-usbDeviceAdded-事件回调" class="headerlink" title="2.3.3. usbDeviceAdded 事件回调"></a>2.3.3. usbDeviceAdded 事件回调</h3><p>在前一章中介绍了通过inotify监控&#x2F;dev&#x2F;bus&#x2F;usb下设备的机制.</p>
<p>这里在UsbHostManager中, 在接收到usbDeviceAdded后, 处理后(<a href="#endUsbDeviceAdded">endUsbDeviceAdded</a></p>
<p>), 将事件转发给了UsbAlsaManager.在转发给UsbAlsaManager之前, 借助UsbDescriptorParser类对新添加usb设备的描述符进行了解析. 涉及到了 新增的 descriptors文件夹下的多个类的处理.(这里涉及的类是UsbACTerminal) 最终判断出该设备是否是 input设备和 output设备.(含有麦克|含有外放) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="keyword">void</span> <span class="title function_">usbDeviceAdded</span><span class="params">(UsbDevice usbDevice,</span></span><br><span class="line"><span class="params">        // 传入的两个参数是通过上述解析过程解析出来的</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isInputHeadset, <span class="type">boolean</span> isOutputHeadset)</span> &#123;</span><br><span class="line">  <span class="comment">// 进一步检查设备中是否含有audio的接口</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">interfaceCount</span> <span class="operator">=</span> usbDevice.getInterfaceCount();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ntrfaceIndex</span> <span class="operator">=</span> <span class="number">0</span>; !isAudioDevice &amp;&amp; ntrfaceIndex &lt; interfaceCount;</span><br><span class="line">       ntrfaceIndex++) &#123;</span><br><span class="line">    <span class="type">UsbInterface</span> <span class="variable">ntrface</span> <span class="operator">=</span> usbDevice.getInterface(ntrfaceIndex);</span><br><span class="line">    <span class="comment">// interface 的 Class 为 USB_CLASS_AUDIO 说明是AUDIO设备</span></span><br><span class="line">    <span class="keyword">if</span> (ntrface.getInterfaceClass() == UsbConstants.USB_CLASS_AUDIO) &#123;</span><br><span class="line">      isAudioDevice = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isAudioDevice) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再次调用AlsaCardsParser类对 /proc/asound/cards 文件进行解析.</span></span><br><span class="line">  <span class="comment">// 规则, 对比这次解析前与解析后文件内容变化, 如果出现新的usb设备, 则返回其在mCardRecords中的index,</span></span><br><span class="line">  <span class="comment">// 如果没有新添加的usb设备, 则从旧的记录中找出对应的usb设备,返回其index</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">addedCard</span> <span class="operator">=</span> mCardsParser.getDefaultUsbCard();</span><br><span class="line">  <span class="comment">// 返回了usb设备, 才继续往下执行, 否则什么都不做</span></span><br><span class="line">  <span class="keyword">if</span> (mCardsParser.isCardUsb(addedCard)) &#123;</span><br><span class="line">    <span class="comment">// 切换音频设备?  这个函数比较长, 后面进行分析, 主要和AUDIO_SERVICE进行了通信</span></span><br><span class="line">    <span class="type">UsbAudioDevice</span> <span class="variable">audioDevice</span> <span class="operator">=</span> selectAudioCard(addedCard);</span><br><span class="line">    <span class="keyword">if</span> (audioDevice != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将新添加的usb audio 设备 以 usbDevice 添加到 mAudioDevices map中保存</span></span><br><span class="line">      mAudioDevices.put(usbDevice, audioDevice);</span><br><span class="line">      Slog.i(TAG, <span class="string">&quot;USB Audio Device Added: &quot;</span> + audioDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 /proc/asound/devices 中有 midi 的device, 且 android.software.midi 开关打开, 继续添加 midi device. 下面的不是重点.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasMidi</span> <span class="operator">=</span> mDevicesParser.hasMIDIDevices(addedCard);</span><br><span class="line">       <span class="keyword">if</span> (hasMidi &amp;&amp; mHasMidiFeature) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">device</span> <span class="operator">=</span> mDevicesParser.getDefaultDeviceNum(addedCard);</span><br><span class="line">         <span class="comment">// 等着 /dev/snd 下出现相应的 midi设备文件, 如果超时,直接返回null, 跳过后面的添加过程</span></span><br><span class="line">         <span class="type">AlsaDevice</span> <span class="variable">alsaDevice</span> <span class="operator">=</span> waitForAlsaDevice(addedCard, device, AlsaDevice.TYPE_MIDI);</span><br><span class="line">         ... <span class="comment">// 省略设备描述相关内容</span></span><br><span class="line">         <span class="type">UsbMidiDevice</span> <span class="variable">usbMidiDevice</span> <span class="operator">=</span> UsbMidiDevice.create(mContext, properties,</span><br><span class="line">                                                              alsaDevice.mCard, alsaDevice.mDevice);</span><br><span class="line">         <span class="keyword">if</span> (usbMidiDevice != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 以 usbDevice为key, 存放到 mMidiDevices map中</span></span><br><span class="line">           mMidiDevices.put(usbDevice, usbMidiDevice);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的过程分析, 可见UsbAlsaManager的流程:</p>
<p>对于USB audio类型的设备, 首先扫描 <code>/proc/asound/cards </code>文件, 找出usb设备, 在inotify检测到<code>/dev/bus/usb</code>下有新增的usb设备时, UsbHostManager将相应的usbDeviceAdded回调转发给UsbAlsaManager, 转发前解析了设备的desciptor, 判断其中是否含有麦克&#x2F;外放设备.  Alsa处理该转发时, 还需要去查找设备的接口中是否有USB_CLASS_AUDIO Class. 上述条件都满足时, 还要再次对<code>/proc/asound/cards</code> 文件进行扫描. 查找最近添加的usb audio设备. 查到了, 则调用selectAudioCard函数, 连接音频设备.</p>
<p>关键函数是 selectAudioCard 函数. 下面对该函数进行进一步分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> UsbAudioDevice <span class="title function_">selectAudioCard</span><span class="params">(<span class="type">int</span> card)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 继续扫描   &quot;/proc/asound/devices&quot; 文件</span></span><br><span class="line">    mDevicesParser.scan();</span><br><span class="line">    <span class="comment">// device 为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">device</span> <span class="operator">=</span> mDevicesParser.getDefaultDeviceNum(card);</span><br><span class="line">    <span class="comment">// device的数据结构:</span></span><br><span class="line">    <span class="comment">/* int mCardNum</span></span><br><span class="line"><span class="comment">       int mDeviceNum</span></span><br><span class="line"><span class="comment">       int mDeviceType</span></span><br><span class="line"><span class="comment">       int mDeviceDir */</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">hasPlayback</span> <span class="operator">=</span> mDevicesParser.hasPlaybackDevices(card);</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">hasCapture</span> <span class="operator">=</span> mDevicesParser.hasCaptureDevices(card); </span><br><span class="line">     <span class="comment">// Playback device file needed/present?</span></span><br><span class="line">     <span class="comment">//  audio playback 设备, 需要等 /dev/snd 下生成了对应的pcmC&lt;card&gt;D&lt;device&gt;p 设备节点生成, 注意此时的 device 为 0. card为相应的usb设备的卡. 等待超时时长  2.5s</span></span><br><span class="line">     <span class="keyword">if</span> (hasPlayback &amp;&amp; (waitForAlsaDevice(card, device, AlsaDevice.TYPE_PLAYBACK) == <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  	  <span class="comment">// Capture device file needed/present?</span></span><br><span class="line">     <span class="comment">// audio capture 设备, 需要等 /dev/snd下 pcmC&lt;card&gt;D&lt;device&gt;c 设备节点生成,   等待超时时长  2.5s</span></span><br><span class="line">     <span class="keyword">if</span> (hasCapture &amp;&amp; (waitForAlsaDevice(card, device, AlsaDevice.TYPE_CAPTURE) == <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 生成  UsbAudioDevice 对象, 对应的数据结构:</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        mCard = card;</span></span><br><span class="line"><span class="comment">        mDevice = device;</span></span><br><span class="line"><span class="comment">        mHasPlayback = hasPlayback;</span></span><br><span class="line"><span class="comment">        mHasCapture = hasCapture;</span></span><br><span class="line"><span class="comment">        mDeviceClass = deviceClass;    usb设备为kAudioDeviceClass_External</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="type">UsbAudioDevice</span> <span class="variable">audioDevice</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsbAudioDevice</span>(card, device, hasPlayback, hasCapture, deviceClass);</span><br><span class="line">      <span class="comment">// 通过 card 索引 从 mCardRecords 索引到 记录的 AlsaCardRecord</span></span><br><span class="line">      AlsaCardsParser.<span class="type">AlsaCardRecord</span> <span class="variable">cardRecord</span> <span class="operator">=</span> mCardsParser.getCardRecordFor(card);</span><br><span class="line">      <span class="comment">//proc/asound/cards 查看这些信息</span></span><br><span class="line">      audioDevice.setDeviceNameAndDescription(cardRecord.mCardName, cardRecord.mCardDescription);</span><br><span class="line">     <span class="comment">// Notifies AudioService when a device is added or removed</span></span><br><span class="line">     <span class="comment">// audioDevice - the AudioDevice that was added or removed</span></span><br><span class="line">     <span class="comment">// enabled - if true, we&#x27;re connecting a device (it&#x27;s arrived), else disconnecting</span></span><br><span class="line">      <span class="comment">// 与 AUDIO_SERVICE 进行交互, 连接当前audio设备.</span></span><br><span class="line"><span class="number">1.</span>      notifyDeviceState(audioDevice, <span class="literal">true</span> <span class="comment">/*enabled*/</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> audioDevice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还需要详细看一下     notifyDeviceState 函数:</span></span><br><span class="line"><span class="comment">// 分别连接录音设备和 播放设备.</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyDeviceState</span><span class="params">(UsbAudioDevice audioDevice, <span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> (enabled ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (alsaCard &lt; <span class="number">0</span> || alsaDevice &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Invalid alsa card or device alsaCard: &quot;</span> + alsaCard +</span><br><span class="line">                        <span class="string">&quot; alsaDevice: &quot;</span> + alsaDevice);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &quot;card=&quot; + card + &quot;;device=&quot; + device + &quot;;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> AudioService.makeAlsaAddressString(alsaCard, alsaDevice);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Playback Device   //对应播放设备</span></span><br><span class="line">            <span class="keyword">if</span> (audioDevice.mHasPlayback) &#123;</span><br><span class="line">                <span class="type">int</span> device;</span><br><span class="line">                <span class="comment">// 这个是通过解析usb设备的描述符得到的</span></span><br><span class="line">                <span class="keyword">if</span> (mIsOutputHeadset) &#123;</span><br><span class="line">                    device = AudioSystem.DEVICE_OUT_USB_HEADSET;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    device = (audioDevice == mAccessoryAudioDevice</span><br><span class="line">                        ? AudioSystem.DEVICE_OUT_USB_ACCESSORY</span><br><span class="line">                        : AudioSystem.DEVICE_OUT_USB_DEVICE);</span><br><span class="line">                &#125;</span><br><span class="line">                mAudioService.setWiredDeviceConnectionState(</span><br><span class="line">                        device, state, address, audioDevice.getDeviceName(), TAG);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Capture Device   //对应录音设备</span></span><br><span class="line">            <span class="keyword">if</span> (audioDevice.mHasCapture) &#123;</span><br><span class="line">                <span class="type">int</span> device;</span><br><span class="line">                <span class="keyword">if</span> (mIsInputHeadset) &#123;</span><br><span class="line">                    device = AudioSystem.DEVICE_IN_USB_HEADSET;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    device = (audioDevice == mAccessoryAudioDevice</span><br><span class="line">                        ? AudioSystem.DEVICE_IN_USB_ACCESSORY</span><br><span class="line">                        : AudioSystem.DEVICE_IN_USB_DEVICE);</span><br><span class="line">                &#125;</span><br><span class="line">                mAudioService.setWiredDeviceConnectionState(</span><br><span class="line">                        device, state, address, audioDevice.getDeviceName(), TAG);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于AudioService的setWiredDeviceConnectionState:</p>
<ol>
<li>判断是否需要发送拔出耳机的intent; (拔出耳机时,需要将当前播放的音频停掉)</li>
<li>通过底层AudioSystem处理设备的连接和断开连接</li>
<li>发送Intent广播(ex: ACTION_HEADSET_PLUG)通知外设状态变化</li>
</ol>
<p>关于<code>&quot;/proc/asound/devices&quot;</code> 文件内容:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp9832e_1h10:/proc/asound <span class="comment"># cat devices                                        </span></span><br><span class="line">  <span class="number">0</span>: [ <span class="number">0</span>]   : control</span><br><span class="line"> <span class="number">16</span>: [ <span class="number">0</span>- <span class="number">0</span>]: digital audio playback</span><br><span class="line"> <span class="number">17</span>: [ <span class="number">0</span>- <span class="number">1</span>]: digital audio playback</span><br><span class="line"> <span class="number">20</span>: [ <span class="number">0</span>- <span class="number">4</span>]: digital audio playback</span><br><span class="line"> <span class="number">21</span>: [ <span class="number">0</span>- <span class="number">5</span>]: digital audio playback</span><br><span class="line"> <span class="number">24</span>: [ <span class="number">0</span>- <span class="number">0</span>]: digital audio capture</span><br><span class="line"> <span class="number">25</span>: [ <span class="number">0</span>- <span class="number">1</span>]: digital audio capture</span><br></pre></td></tr></table></figure>

<p>可见对应整个流程,需要四个条件准备就绪: </p>
<ol>
<li>&#x2F;dev&#x2F;bus&#x2F;usb&#x2F; 下出现了新的设备, 且解析设备描述符为 HEADSET相关的设备:(desciptor, 判断其中是否含有 麦克&#x2F;外放设备.  还需要去查找设备的接口中是否有USB_CLASS_AUDIO Class)</li>
<li>&#x2F;dev&#x2F;snd&#x2F;下出现对应的音频设备</li>
<li>“&#x2F;proc&#x2F;asound&#x2F;cards” 中出现对应的声卡</li>
<li>“&#x2F;proc&#x2F;asound&#x2F;devices” 中出现对应的设备描述</li>
</ol>
<p>上述过程对应Alsa架构的音频设备管理.</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/azloong/article/details/44181421">Alsa 架构声卡相关知识</a></p>
<p><img src="/images/alsa-jiagou.png" alt="alsa-jiagou"></p>
<h1 id="3-Usb-device管理"><a href="#3-Usb-device管理" class="headerlink" title="3. Usb device管理"></a>3. Usb device管理</h1><p>手机作为usb设备,主要是和pc端的交互.pc作为usb主机, 与手机进行usb通信.</p>
<h2 id="3-1-Usb枚举过程"><a href="#3-1-Usb枚举过程" class="headerlink" title="3.1. Usb枚举过程"></a>3.1. Usb枚举过程</h2><p><img src="/images/usb%E6%9E%9A%E4%B8%BE.png" alt="usb枚举"></p>
<p>切换function涉及到的逻辑:</p>
<p><img src="/images/switch_function.png" alt="switch_function"></p>
<p>Client 对应app或者其他服务.</p>
<p>一个USB接口扩展出多个设备功能的实现方法有两种:</p>
<ul>
<li><p>在设备外部或内部加Hub扩展</p>
</li>
<li><p>以Usb Composite Device方式实现（一般称为复合设备）。</p>
<p>复合设备其实只是一个USB设备，只有一个USB设备地址，它实现多个功能的原因主要在于它扩展实现了多个USB接口，每个接口具有不同的设备类型。Android下采用了USB Composite Device这种方式来实现一个USB口的情况下扩展出多个功能设备，这种情况下一个USB接口（Interface）便对应一种类型的功能设备，需要实现与之对应的功能驱动。</p>
<p>![usb composite](&#x2F;images&#x2F;usb composite.png)</p>
</li>
</ul>
<h2 id="3-2-传统Usb-device与accessory-配件-模式"><a href="#3-2-传统Usb-device与accessory-配件-模式" class="headerlink" title="3.2. 传统Usb device与accessory(配件)模式"></a>3.2. 传统Usb device与accessory(配件)模式</h2><p>Android设备作为传统device设备, host端主要是pc(也可以是手机). 如mtp&#x2F;ptp&#x2F;mass_storage&#x2F;虚拟光驱&#x2F;tethering模式等.</p>
<p>Android设备还可以作为accessory设备, 以USB Device的角色与一些具有USB Host功能，但却扮演着配件角色的设备相连.</p>
<p>这些设备可能是机器人控制器、Dock（基座）、诊断设备、音响设备、配电设备、读卡器等等。</p>
<p>Google引入USB Accessory概念的原因应该主要有如下：</p>
<ul>
<li>非常多的Android设备不具有USB Host的功能而只具有USB Device功能，或者即使具备USB Host的功能，也承担不起对USB外设供电的任务，因为便携式Android设备本身的电池容量就很有限。</li>
<li>原来的Android设备，作为USB Device所实现的功能相对比较简单，内置的功能只有U盘或ADB调试设备等，Google希望提供应用层的USB开发库，让更多的软硬件厂商来开发新的功能，比如说安装一个APK应用，然后通过USB连接到一个与电视机配套的Dock上，就可以让一台Android手机变身为一个电视机遥控器。</li>
</ul>
<p>当Android设备作为Host模式时为USB总线供电；当Android设备连接到一个USB Accessory设备时，USB Accessory设备以Host身份为USB总线供电。</p>
<p><img src="/images/usb_device_mode.png" alt="usb_device_mode"></p>
<p>USB Accessory设备: 配件设备, 以host方式供电</p>
<p>Android 设备:  device角色, usb function切换为accessory.</p>
<p>两台手机互联时, 在打开accessory mode情况下, 连接adapter的一端为USB Accessory设备, 直接microusb或typec接口的一端为device设备.</p>
<h3 id="3-2-1-accessory模式下的枚举过程"><a href="#3-2-1-accessory模式下的枚举过程" class="headerlink" title="3.2.1. accessory模式下的枚举过程:"></a>3.2.1. accessory模式下的枚举过程:</h3><p>USB Accessory设备和Android设备两者双方整个枚举识别工作过程如下：</p>
<ul>
<li>USB Accessory设备发起USB控制传输进行正常的USB设备枚举，获取设备描述符和配置描述符等信息，此时大部分Android设备上报的还只是普通的U盘或MTP设备；</li>
<li>USB Accessory设备发起Vendor类型，request值为51（0x33）的控制传输命令（ACCESSORY_GET_PROTOCOL），看看该Android设备是否支持USB Accessory功能，如果支持的话会返回所支持的AOA协议版本</li>
<li>USB Accessory设备判断到该Android设备支持Accessory功能后，发起request值为52（0x34）的控制传输命令（ACCESSORY_SEND_STRING），并把该Accessory设备的相关信息（包括厂家，序列号等）告知Android设备</li>
<li>如果是USB Audio Accessory设备，还会发起request值为58（0x3A）的控制传输命令（SET_AUDIO_MODE命令），通知Android设备进入到Audio Accessory模式</li>
<li>USB Accessory设备发起request值为53（0x35）的控制传输命令（ACCESSORY_START），通知Android设备切换到Accessory功能模式开始工作。Android设备收到此uevent信息后，会先把sys.usb.config设置为包含accessory功能,此后Android设备工作在accessory 模式下. 厂商可以通过该模式开发出适用各种场景的usb配件.</li>
</ul>
<h3 id="3-2-2-accessory模式框架"><a href="#3-2-2-accessory模式框架" class="headerlink" title="3.2.2. accessory模式框架"></a>3.2.2. accessory模式框架</h3><p><img src="/images/accessory_mode_control.png" alt="accessory_mode_control"></p>
<p>在Android设备切换为accessory function成功后, 会触发configured的流程, 回调accessoryAttached函数.</p>
<p>通过匹配<code>android.hardware.usb.action.USB_ACCESSORY_ATTACHED</code>intent找到厂商的apk.apk在onCreate时会接收到的主要参数为UsbManager.EXTRA_ACCESSORY, 携带了usb accessory设备的描述信息. 也可以通过<code>getAccessoryList</code>接口拿到当前已经连接的accessory配件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String  mManufacturer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String  mModel;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String mDescription;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String mVersion;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String mUri;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span>  String mSerial;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;UsbAccessoryActivity&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;DemoKit&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span> <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:resource</span>=<span class="string">&quot;@xml/accessory_filter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过openAccessory方法拿到fd, 通过fd拿到输入输出流进行传输控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsbManager</span> <span class="variable">usbManager</span> <span class="operator">=</span> getContext().getSystemService(UsbManager.class);</span><br><span class="line"><span class="type">ParcelFileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> usbManager.openAccessory(accessory);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>.AutoCloseInputStream(fd))</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>.AutoCloseOutputStream(fd))</span><br></pre></td></tr></table></figure>

<p>而host端传输方式(假设host是手机)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsbDeviceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> mUsbManager.openDevice(device);</span><br><span class="line"><span class="type">UsbInterface</span> <span class="variable">iface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; device.getConfigurationCount(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (device.getInterface(i).getName().equals(<span class="string">&quot;Android Accessory Interface&quot;</span>)) &#123;</span><br><span class="line">        iface = device.getInterface(i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到输入流 输出流端口</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">UsbEndpoint</span> <span class="variable">in</span> <span class="operator">=</span> getEndpoint(iface, UsbConstants.USB_DIR_IN);</span><br><span class="line"><span class="keyword">final</span> <span class="type">UsbEndpoint</span> <span class="variable">out</span> <span class="operator">=</span> getEndpoint(iface, UsbConstants.USB_DIR_OUT);</span><br><span class="line"><span class="comment">// 往device端发送</span></span><br><span class="line"><span class="type">int</span> <span class="variable">numSent</span> <span class="operator">=</span> connection.bulkTransfer(out, sizeBuffer, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 接收device端的回复</span></span><br><span class="line"><span class="type">byte</span>[] recBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">numReceived</span> <span class="operator">=</span> connection.bulkTransfer(in, recBytes,</span><br><span class="line">                recBytes.length, timeout);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-1-申请accessory权限"><a href="#3-2-2-1-申请accessory权限" class="headerlink" title="3.2.2.1. 申请accessory权限"></a>3.2.2.1. 申请accessory权限</h4><p>打开accessory配件需要权限, 需要应用进行动态申请.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uidList中保存了已经为该accessory申请权限的应用的uid列表.</span></span><br><span class="line">mAccessoryPermissionMap.put(accessory, uidList);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsbManager</span> <span class="variable">mUsbManager</span> <span class="operator">=</span> (UsbManager) getSystemService(Context.USB_SERVICE);</span><br><span class="line"><span class="comment">//权限名称任意,仅是标识作用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ACTION_USB_PERMISSION</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;com.android.example.USB_PERMISSION&quot;</span>;</span><br><span class="line">...</span><br><span class="line">mPermissionIntent = PendingIntent.getBroadcast(<span class="built_in">this</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Intent</span>(ACTION_USB_PERMISSION), <span class="number">0</span>);</span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(ACTION_USB_PERMISSION);</span><br><span class="line">registerReceiver(mUsbReceiver, filter);</span><br><span class="line"><span class="comment">// 通过hasPermission方法查询是否已经有该配件的权限, 没有则申请权限, 启动UsbPermissionActivity弹框提示是否需要授权该类配件的权限.点击授予会调用PendingIntent.send方法发送该广播. </span></span><br><span class="line"><span class="keyword">if</span>(!mUsbManager.hasPermission(accessory))</span><br><span class="line">     mUsbManager.requestPermission(accessory, mPermissionIntent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BroadcastReceiver</span> <span class="variable">mUsbReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (ACTION_USB_PERMISSION.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="type">UsbAccessory</span> <span class="variable">accessory</span> <span class="operator">=</span> (UsbAccessory) intent.getParcelableExtra(UsbManager.EXTRA_ACCESSORY);</span><br><span class="line">                <span class="comment">// 权限被授予</span></span><br><span class="line">                <span class="keyword">if</span> (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(accessory != <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//call method to set up accessory communication</span></span><br><span class="line">                        <span class="comment">// 权限授予后, 可以进行通信.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;permission denied for accessory &quot;</span> + accessory);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="#https://developer.android.com/guide/topics/connectivity/usb/accessory">Accessory的google官方文档</a></p>
<p>accessory模式的框架与host框架开发类似. host模式下device设备开发文档见<a href="#https://developer.android.com/guide/topics/connectivity/usb/host">host overview</a></p>
<h2 id="3-3-Usb-网络共享"><a href="#3-3-Usb-网络共享" class="headerlink" title="3.3. Usb 网络共享"></a>3.3. Usb 网络共享</h2><p>usb模式涉及到usb网络共享. (usb网络绑定与逆绑定)</p>
<p>网络共享服务基于微软开发的rndis协议. 主要用于windows平台中usb网络设备的驱动开发.当手机通过usb连接到主机,启用usb绑定.需要将手机上的usb设置为rndis.主机上识别到新的网卡.要使用通过USB绑定的网卡,需要给主机分配IP地址.</p>
<p>在USB绑定中,主机是DHCP的客户端,手机是DHCP的服务器端.Android中使用了DNSmasq充当DHCP服务器.</p>
<p>切换为网络共享的流程和其他的模式是一样的, 都是通过UsbDeviceManager设置属性, init写入driver的相关节点, 开启rndis模式.开启后通过driver上报的uevent事件, 判断驱动是否可以正常工作.当收到configured状态时,开始真正的配置网络.</p>
<h3 id="3-3-1-配置网卡"><a href="#3-3-1-配置网卡" class="headerlink" title="3.3.1. 配置网卡"></a>3.3.1. 配置网卡</h3><p>等rndis切换成功后, Android设备网卡的节点会出现rndis0&#x2F;usb0的接口.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp9832a_2h11:/sys/class/net # ls -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 2012-01-07 00:54 dummy0 -&gt; ../../devices/virtual/net/dummy0</span><br><span class="line">lrwxrwxrwx 1 root root 0 2012-01-07 00:54 ip6tnl0 -&gt; ../../devices/virtual/net/ip6tnl0</span><br><span class="line">lrwxrwxrwx 1 root root 0 2012-01-07 00:54 lo -&gt; ../../devices/virtual/net/lo</span><br><span class="line">lrwxrwxrwx 1 root root 0 2012-01-07 00:56 rndis0 -&gt; ../../devices/20200000.usb/gadget/net/rndis0</span><br><span class="line">lrwxrwxrwx 1 root root 0 2018-07-11 10:38 usb0 -&gt; ../../devices/platform/soc/soc:ap-ahb/e2500000.usb2/gadget/net/usb0</span><br><span class="line">lrwxrwxrwx 1 root root 0 2012-01-07 00:54 seth_lte0 -&gt; ../../devices/virtual/net/seth_lte0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-StateMachine"><a href="#3-3-2-StateMachine" class="headerlink" title="3.3.2. StateMachine"></a>3.3.2. StateMachine</h3><h4 id="3-3-2-1-state-模式"><a href="#3-3-2-1-state-模式" class="headerlink" title="3.3.2.1. state 模式"></a>3.3.2.1. state 模式</h4><p>将对象的状态封装成一个对象，在不同的状态下同样的调用执行不同的操作</p>
<p>对象内部状态决定行为方式，对象状态改变则行为方式改变.封装对象的状态是将对象的状态与行为封装在一起；可以解决庞大的分支语句带来程序阅读性差和不便于进行扩展问题，使整个结构变得更加清晰明了，降低程序管理的复杂性提高灵活度。</p>
<p><img src="/images/stateMachine.jpg" alt="stateMachine"></p>
<p>StateMachine的构造函数都是protected类型，不能实例化；都是由其子类进行初始化操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">StateMachine</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    mSmThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(name);</span><br><span class="line">    mSmThread.start();</span><br><span class="line">    <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> mSmThread.getLooper();</span><br><span class="line"></span><br><span class="line">    initStateMachine(name, looper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-2-State-Machine各个模块作用"><a href="#3-3-2-2-State-Machine各个模块作用" class="headerlink" title="3.3.2.2. State Machine各个模块作用"></a>3.3.2.2. State Machine各个模块作用</h4><ul>
<li><strong>State</strong></li>
</ul>
<p>状态的基类，stateMachine中的状态都是由State派生而来，构造函数protected，不能实例化；只能由子类继承进行实例化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">IState</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">protected</span> <span class="title function_">State</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">　　<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message msg)</span> &#123;&#125;</span><br><span class="line">　　<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>SmHandler</strong></p>
<p><strong>SmHandler</strong>的内部类</p>
<ul>
<li><p><strong>StateInfo</strong></p>
<p><strong>存储当前State，和其parentState，以及是否激活状态；用来构建树形层次结构模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StateInfo</span> </span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">/** the  state */</span></span><br><span class="line">　　State state;</span><br><span class="line">　　<span class="comment">/** The parent of this state, null if there is no parent */</span></span><br><span class="line">　　StateInfo parentStateInfo;</span><br><span class="line">　　<span class="comment">/** True when the state has been entered and on the stack */</span></span><br><span class="line">　　<span class="type">boolean</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>HaltingState与QuittingState</p>
<p>都是State的 派生类，用于在状态停止和放弃之后处理的一些事情；都重写了ProcessMessage方法，</p>
<p>在StateMachine没有实际行动仅仅保留用于扩展。</p>
</li>
</ul>
<p>整个SmHandle是消息处理派发和状态控制切换的核心，运行在单独的线程上。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> </span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">/** The current message */</span></span><br><span class="line">　　<span class="keyword">private</span> Message mMsg;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">/** Stack used to manage the current hierarchy of states */</span></span><br><span class="line">　　<span class="keyword">private</span> StateInfo mStateStack[];</span><br><span class="line"></span><br><span class="line">　　<span class="comment">/** The map of all of the states in the state machine */</span></span><br><span class="line">　　<span class="keyword">private</span> HashMap&lt;State, StateInfo&gt; mStateInfo =</span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, StateInfo&gt;();</span><br><span class="line"></span><br><span class="line">　　<span class="comment">/** The initial state that will process the first message */</span></span><br><span class="line">　　<span class="keyword">private</span> State mInitialState;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">/** The destination state when transitionTo has been invoked */</span></span><br><span class="line">　　<span class="keyword">private</span> State mDestState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-2-1-Smhandler"><a href="#3-3-2-2-1-Smhandler" class="headerlink" title="3.3.2.2.1. Smhandler"></a>3.3.2.2.1. Smhandler</h5><p>  <strong>SmHandle是构建StateMachine的核心，运行在独立的线程上，有三个功能：</strong></p>
<ul>
<li><p>建立树形层次结构存储State；</p>
<p>在构成一个状态机前需要确定当前都多少状态，需要将这些状态集中起来进行管理。</p>
<p>StateMachine提供了这样一个protected类型方法 addState来将状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment">* state:　　　　加入state machine的State</span></span><br><span class="line"><span class="comment">* parent:  　　the parent of state, patent的状态节点可以为空</span></span><br><span class="line"><span class="comment">****************************************************/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StateInfo <span class="title function_">addState</span><span class="params">(State state, State parent)</span> &#123;</span><br><span class="line">    <span class="type">StateInfo</span> <span class="variable">parentStateInfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前状态parent详细信息 StateInfo</span></span><br><span class="line">        parentStateInfo = mStateInfo.get(parent);</span><br><span class="line">        <span class="keyword">if</span> (parentStateInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//当前状态父状态未加入到StateMachine中，</span></span><br><span class="line">　　　　　　<span class="comment">//递归先加入其Parent State</span></span><br><span class="line">            parentStateInfo = addState(parent, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前状态是否加入到 StateMachine层次结构中</span></span><br><span class="line">    <span class="type">StateInfo</span> <span class="variable">stateInfo</span> <span class="operator">=</span> mStateInfo.get(state);</span><br><span class="line">    <span class="keyword">if</span> (stateInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建State详细信息对象，将其加入到StateMachine层次结构中</span></span><br><span class="line">        stateInfo = <span class="keyword">new</span> <span class="title class_">StateInfo</span>();</span><br><span class="line">        mStateInfo.put(state, stateInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证我们有没有加入相同的状态，在两个不同层次，否则异常</span></span><br><span class="line">    <span class="keyword">if</span> ((stateInfo.parentStateInfo != <span class="literal">null</span>)</span><br><span class="line">            &amp;&amp; (stateInfo.parentStateInfo != parentStateInfo)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;state already added&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stateInfo.state = state;</span><br><span class="line">    stateInfo.parentStateInfo = parentStateInfo;</span><br><span class="line">    stateInfo.active = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> stateInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;State, StateInfo&gt; mStateInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, StateInfo&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>mStateInfo</strong>是按照tree层次组织State的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　SmHandle sm;</span><br><span class="line">　　sm.addState(S0,<span class="literal">null</span>);</span><br><span class="line">　　sm.addState(S1,S0);</span><br><span class="line">　　sm.addState(S2,S0);</span><br><span class="line">　　sm.addState(S3,S1);</span><br><span class="line">　　sm.addState(S4,S1);</span><br><span class="line">　　sm.addState(S5,S2);</span><br><span class="line">　　sm.addState(S6,S2);</span><br><span class="line">　　sm.addState(S7,S2);</span><br><span class="line"><span class="comment">//设置初始状态</span></span><br><span class="line">　　setInitialState(S4);      </span><br></pre></td></tr></table></figure>


<p><img src="/images/state_tree.jpg" alt="state_tree"></p>
</li>
<li><p>状态机的StateStack建立和状态切换；</p>
<p>各状态State加入到StateMachine，各条件初始化OK后，就可以启动状态机了。</p>
<p><em><strong><code>启动状态机</code></strong></em>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> </span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="comment">/** Send the complete construction message */</span></span><br><span class="line"><span class="number">1.</span>　　　　mSmHandler.completeConstruction();</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="number">1.</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">completeConstruction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//计算State tree的最大深度以便创建运行State Stack</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (StateInfo si : mStateInfo.values()) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">StateInfo</span> <span class="variable">i</span> <span class="operator">=</span> si; i != <span class="literal">null</span>; depth++) &#123;</span><br><span class="line">                  i = i.parentStateInfo;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (maxDepth &lt; depth) &#123;</span><br><span class="line">                  maxDepth = depth;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建State Stack</span></span><br><span class="line">    mStateStack = <span class="keyword">new</span> <span class="title class_">StateInfo</span>[maxDepth];</span><br><span class="line">    mTempStateStack = <span class="keyword">new</span> <span class="title class_">StateInfo</span>[maxDepth];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据当前mDestState（S5）按照其层次结构沿着其父子关系，</span></span><br><span class="line">    <span class="comment">//保存此条路径上的StateInfo 存储到State Stack中于是</span></span><br><span class="line">    <span class="comment">//例如:S0--S2—S5 存储到mStateStack中</span></span><br><span class="line">    setupInitialStateStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层次结构状态构建完成调用mStateStack中State的enter方法</span></span><br><span class="line">    <span class="comment">//使mStateStack中的State 处于active状态</span></span><br><span class="line">    mIsConstructionCompleted = <span class="literal">true</span>;</span><br><span class="line">    mMsg = obtainMessage(SM_INIT_CMD);</span><br><span class="line">    invokeEnterMethods(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Perform any transitions requested by the enter methods</span></span><br><span class="line"><span class="number">1.1</span>    performTransitions();      <span class="comment">//待下面分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>State Stack里面的元素结构是根据父子关系组成链式结构：S0——S2——S5；S5是mDestState，</p>
<p>S2，S0都是其parentState；状态是一种父子关系；</p>
<p><em><strong><code>状态切换</code></strong></em>:</p>
<p>StateMachine中提供了方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transitionTo</span><span class="params">(IState destState)</span> </span><br><span class="line">&#123;</span><br><span class="line">　　mSmHandler.transitionTo(destState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transitionTo</span><span class="params">(IState destState)</span> </span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">// mDestState保存当前状态 来处理消息；</span></span><br><span class="line">　　mDestState = (State) destState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>transitionTo</strong>仅仅是改变了当前状态mDestState，从StateStack建立这里可以看到和这个mDestState相关的还有mStateStack，如果改变了mDestState，mStateStack也需要改变，使mStateStack仍然是链式层次式结构。</p>
<ul>
<li><p>需要改变mStateStack: </p>
<p>mDestState改变时，没有同时改变 mStateStack，而是等到消息处理派发状态Handle的时候，当前的状态行为处理完，切换到下一个状态，即消息处理完毕然后才进行mStateStack的更新。目的是使状态切换和mStateStack的更新独立开来.</p>
<blockquote>
<p>ex:</p>
<p>​       mStateStack中存储：S0——S2——S5 mDestState为S5 （栈顶）</p>
<p>​       现在状态切换为S3，mDestState为S3</p>
<p>​       按照父子关系，mStateStack应该存储有：S0——S1——S3</p>
<p>​       那么此时S5，S2都要出栈pop from mStateStack</p>
<p>​       那我们就是要找到一个点，让S5，S2出栈；S3，S1进栈；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> <span class="comment">//Do any transitions</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">performTransitions</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="type">State</span> <span class="variable">destState</span> <span class="operator">=</span> mDestState;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前状态切换了 存在于mStateStack中的State需要改变</span></span><br><span class="line">            <span class="comment">//仍然按照链式父子关系来存储</span></span><br><span class="line">            <span class="comment">//先从当前状态S3找到 最近的被激活的parent状态S0</span></span><br><span class="line">            <span class="comment">//未被激活的全部保存起来(S3,S1) 返回S0</span></span><br><span class="line">            <span class="type">StateInfo</span> <span class="variable">commonStateInfo</span> <span class="operator">=</span> setupTempStateStackWithStatesToEnter(destState);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将mStateStack中 不属于当前状态(S3)，</span></span><br><span class="line">            <span class="comment">//关系链上的State(S5,S2)退出(执行exit方法)</span></span><br><span class="line">            invokeExitMethods(commonStateInfo);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将S3关系链 加入到栈中(S3,S1)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stateStackEnteringIndex</span> <span class="operator">=</span> moveTempStateStackToStateStack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新加入到mStateStack中 未被激活的State激活(S3,S1)</span></span><br><span class="line">            invokeEnterMethods(stateStackEnteringIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将延迟的消息移动到消息队列的前面，以便快速得到处理               </span></span><br><span class="line">            moveDeferredMessageAtFrontOfQueue();</span><br><span class="line">            <span class="keyword">if</span> (destState != mDestState) &#123;</span><br><span class="line">                <span class="comment">// A new mDestState so continue looping</span></span><br><span class="line">                destState = mDestState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No change in mDestState so we&#x27;re done</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>消息处理和派发；</li>
</ul>
<p>  StateMachine处理的核心就是SmHandler，就是一个Handler，运行在单独线程中。</p>
<p>Handler是用来异步处理派发消息，这里使用Handler管理各个状态，派发消息处理到各个状态中去执行。</p>
<p>　　状态机准备OK后（状态加入和状态栈构建完成）就可以执行某些行为，接收消息进行处理，派发到当前状态去执行。</p>
<p>看一下SmHandler中handleMessage是如何进行消息处理的。</p>
<p><strong>消息接收：</strong></p>
<p>​       StateMachine提供了sendMessage等方法将消息加入到消息队列中，当然都是交给SmHandler去处理的。</p>
<p>消息处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> </span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">//处理当前消息到state中去处理</span></span><br><span class="line">　　<span class="number">1.</span> processMsg(msg);</span><br><span class="line">　　<span class="comment">//消息处理完毕状态切换 更新mStateStack</span></span><br><span class="line">　　<span class="number">2.</span> performTransitions();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processMsg</span><span class="params">(Message msg)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">//派发消息到state中去处理</span></span><br><span class="line">　　<span class="type">StateInfo</span> <span class="variable">curStateInfo</span> <span class="operator">=</span> mStateStack[mStateStackTopIndex];</span><br><span class="line">　　<span class="keyword">while</span> (!curStateInfo.state.processMessage(msg))</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="comment">//当前状态mDestState 未处理该消息，交给其parent state处理</span></span><br><span class="line">　　　　curStateInfo = curStateInfo.parentStateInfo;</span><br><span class="line">　　　　<span class="keyword">if</span> (curStateInfo == <span class="literal">null</span>)&#123;</span><br><span class="line">　　　　　　<span class="comment">//此消息未被当前层次状态链处理</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里看到建立状态栈<code>mStateStack</code>的作用，用来支持进行链式的消息处理；（Chain of Responsibility）</p>
<h3 id="3-3-3-Tethering网络状态机"><a href="#3-3-3-Tethering网络状态机" class="headerlink" title="3.3.3. Tethering网络状态机"></a>3.3.3. Tethering网络状态机</h3><p><img src="/images/Tethering-state.svg" alt="Tethering-state"></p>
<p>Tethering对象使用了状态模式来实现共享连接机制的实现，为每个状态创建一个状态对象，一个状态对象根据不同情景可以切换到另一个状态对象。</p>
<h4 id="3-3-3-1-TetherInterfaceSM-TetherInterfaceStateMachine"><a href="#3-3-3-1-TetherInterfaceSM-TetherInterfaceStateMachine" class="headerlink" title="3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)"></a>3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)</h4><p>Tethering类图如上， Tethering对象为每一个使用共享连接的物理接口维护一个<strong>TetherInterfaceSM</strong>类型的状态机,管理Tethering接口的状态。TetherInterfaceSM(<code>TetherInterfaceStateMachine</code>的简写)状态机在NetworkManagementService服务触发的interfaceAdded回调中实例化。</p>
<p>TetherInterfaceSM类型的状态机状态:</p>
<ul>
<li>InitialState<strong>（初始状态）</strong></li>
<li>LocalHotspotState</li>
<li><strong>TetheredState</strong>（共享状态)</li>
<li><strong>UnavailableState</strong>（连接不可用状态）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TetherState</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IControlsTethering</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATE_UNAVAILABLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATE_AVAILABLE</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATE_TETHERED</span>    <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATE_LOCAL_ONLY</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>TetherInterfaceSM通过isAvailable、isTethered、isErrored、getLastError等函数对外提供Tethering接口的状态信息，从而使Tethering的getTetherableIfaces、getTetheredIfaces、getTetheredIfacePairs、getTetheringErroredIfaces、getLastTetherError等函数可以从接口对应的状态机中获得Tethering接口的状态。TetherInterfaceSM状态机在正常共享工作情况下应该处于<strong>TetheredState</strong>状态，在TetheredState状态通过NetworkManagementService的<strong>tetherInterface</strong>的函数来添加使用共享连接的接口。</p>
<p>在底层配置好rndis function后, 添加rndis0&#x2F;usb0的网卡接口,会回调interfaceAdded方法, 这时会新建TetherState实例, 同时会实例化一个TetherInterfaceStateMachine对象,作为TetherState的成员, 最后以接口名称为索引,加到mTetherStates的map中保存.</p>
<h5 id="3-3-3-1-1-TetherInterfaceSM-初始化"><a href="#3-3-3-1-1-TetherInterfaceSM-初始化" class="headerlink" title="3.3.3.1.1. TetherInterfaceSM 初始化"></a>3.3.3.1.1. TetherInterfaceSM 初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="title function_">TetherState</span><span class="params">(TetherInterfaceStateMachine sm)</span> &#123;</span><br><span class="line">            stateMachine = sm;</span><br><span class="line">            <span class="comment">// Assume all state machines start out available and with no errors.</span></span><br><span class="line">            <span class="comment">// 初始状态为 STATE_AVAILABLE</span></span><br><span class="line">            lastState = IControlsTethering.STATE_AVAILABLE;</span><br><span class="line">            lastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TetherInterfaceStateMachine</span><span class="params">(</span></span><br><span class="line"><span class="params">            String ifaceName, Looper looper, <span class="type">int</span> interfaceType, SharedLog log,</span></span><br><span class="line"><span class="params">            INetworkManagementService nMService, INetworkStatsService statsService,</span></span><br><span class="line"><span class="params">            IControlsTethering tetherController)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mServingMode = IControlsTethering.STATE_AVAILABLE;</span><br><span class="line">        <span class="comment">// 初始化四个状态</span></span><br><span class="line">        mInitialState = <span class="keyword">new</span> <span class="title class_">InitialState</span>();</span><br><span class="line">        mLocalHotspotState = <span class="keyword">new</span> <span class="title class_">LocalHotspotState</span>();</span><br><span class="line">        mTetheredState = <span class="keyword">new</span> <span class="title class_">TetheredState</span>();</span><br><span class="line">        mUnavailableState = <span class="keyword">new</span> <span class="title class_">UnavailableState</span>();</span><br><span class="line">        <span class="comment">// 添加了四个state, </span></span><br><span class="line">        <span class="number">1.</span>addState(mInitialState);</span><br><span class="line">        addState(mLocalHotspotState);</span><br><span class="line">        addState(mTetheredState);</span><br><span class="line">        addState(mUnavailableState);</span><br><span class="line">        <span class="comment">// 设置SmHandler的mInitialState为 InitialState</span></span><br><span class="line">        setInitialState(mInitialState);</span><br><span class="line">    &#125;</span><br><span class="line">mTetherStates.put(iface, tetherState);</span><br><span class="line"><span class="number">2.</span> tetherState.stateMachine.start();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span><span class="comment">//  addState, 每个State的parentState都为null </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        mSmHandler.addState(state, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span><span class="comment">// 启动状态机. 调用completeConstruction方法.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SmHandler</span> <span class="variable">smh</span> <span class="operator">=</span> mSmHandler;</span><br><span class="line">        <span class="keyword">if</span> (smh == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        smh.completeConstruction();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">completeConstruction</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为InitialState更新stack. 这个上面只有它自己</span></span><br><span class="line">    setupInitialStateStack();</span><br><span class="line">    <span class="comment">// smhandler 发送SM_INIT_CMD消息, 通过handleMessage处理</span></span><br><span class="line">    <span class="number">2.1</span> sendMessageAtFrontOfQueue(obtainMessage(SM_INIT_CMD, mSmHandlerObj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!mIsConstructionCompleted &amp;&amp; (mMsg.what == SM_INIT_CMD)</span><br><span class="line">                        &amp;&amp; (mMsg.obj == mSmHandlerObj)) &#123;</span><br><span class="line">                    <span class="comment">/** Initial one time path. */</span></span><br><span class="line">                    mIsConstructionCompleted = <span class="literal">true</span>;</span><br><span class="line">                    <span class="number">2.1</span><span class="number">.1</span>. <span class="comment">// 调用InitialState的enter方法</span></span><br><span class="line">                    invokeEnterMethods(<span class="number">0</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                  <span class="number">2.1</span><span class="number">.2</span> <span class="comment">// 更新DestState, 调用DestState的enter方法,并更新DestState的Stack, 这个地方因DestState为null, 所以这个地方可以忽略  </span></span><br><span class="line">                    performTransitions(msgProcessedState, msg);</span><br><span class="line"><span class="number">2.1</span><span class="number">.1</span> <span class="comment">//调用InitialState的enter方法</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">            sendInterfaceState(IControlsTethering.STATE_AVAILABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInterfaceState</span><span class="params">(<span class="type">int</span> newInterfaceState)</span> &#123;</span><br><span class="line">        mServingMode = newInterfaceState;</span><br><span class="line">        mTetherController.updateInterfaceState(</span><br><span class="line">                TetherInterfaceStateMachine.<span class="built_in">this</span>, newInterfaceState, mLastError);</span><br><span class="line">        sendLinkProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回头看mTetherController, 这个来自makeControlCallback函数. 注册回调的方式通知到TetherMasterSM主控状态机,</span></span><br><span class="line"><span class="comment">// 关于makeControlCallback回调中的notifyInterfaceStateChange和notifyLinkPropertiesChanged后面再分析.</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TetherInterfaceStateMachine</span>(</span><br><span class="line">                    iface, mLooper, interfaceType, mLog, mNMService, mStatsService,</span><br><span class="line">                    makeControlCallback(iface)));</span><br><span class="line">    <span class="keyword">private</span> IControlsTethering <span class="title function_">makeControlCallback</span><span class="params">(String ifname)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IControlsTethering</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateInterfaceState</span><span class="params">(</span></span><br><span class="line"><span class="params">                    TetherInterfaceStateMachine who, <span class="type">int</span> state, <span class="type">int</span> lastError)</span> &#123;</span><br><span class="line">                <span class="comment">// 通知到TetherMasterSM主控状态机,后面分析</span></span><br><span class="line">                notifyInterfaceStateChange(ifname, who, state, lastError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLinkProperties</span><span class="params">(</span></span><br><span class="line"><span class="params">                    TetherInterfaceStateMachine who, LinkProperties newLp)</span> &#123;</span><br><span class="line">                <span class="comment">// 通知到TetherMasterSM主控状态机</span></span><br><span class="line">                notifyLinkPropertiesChanged(ifname, who, newLp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化工作<ul>
<li>构建tree, 添加了TISM的四个状态. </li>
<li>初始状态为TISM的initialState, 并调用了其enter方法, 通过回调通知到主控状态机更新state.</li>
<li>将mIsConstructionCompleted标记为true, 后面可以处理各个state的processmessage方法.</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-2-TetherMasterSM"><a href="#3-3-3-2-TetherMasterSM" class="headerlink" title="3.3.3.2. TetherMasterSM"></a>3.3.3.2. <strong>TetherMasterSM</strong></h4><p>Tethering对象还提供了一个<strong>TetherMasterSM</strong>类型的主控状态机，提供<em><strong>共享连接的启动、停止等管理及连接状态事件的监控并向TetherInterfaceSM状态机发送事件通知</strong></em>。</p>
<p>TetherMasterSM状态机的状态包括：</p>
<ul>
<li><p>InitialState<strong>（初始状态）</strong></p>
</li>
<li><p>TetherModeAliveState（共享模式激活状态)</p>
</li>
<li><p>ErrorState</p>
<p>ErrorState类型的状态</p>
<ul>
<li>SetIpForwardingEnabledErrorState</li>
<li>SetIpForwardingDisabledErrorState</li>
<li>StartTetheringErrorState</li>
<li>StopTetheringErrorState</li>
<li>SetDnsForwardersErrorState等出错状态</li>
</ul>
</li>
</ul>
<p>正常共享工作情况下<strong>TetherMasterSM</strong>状态机处于<strong>TetherModeAliveState</strong>状态，在<strong>TetherModeAliveState</strong>状态打开共享连接，并调用NetworkManagementService服务的setIpForwardingEnabled、setDnsForwarders、startTethering函数启动共享连接服务。 </p>
<h5 id="3-3-3-2-1-主控状态机初始化"><a href="#3-3-3-2-1-主控状态机初始化" class="headerlink" title="3.3.3.2.1. 主控状态机初始化"></a>3.3.3.2.1. 主控状态机初始化</h5><p>在Tethering的构造函数中, 进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        mTetherMasterSM = <span class="keyword">new</span> <span class="title class_">TetherMasterSM</span>(<span class="string">&quot;TetherMaster&quot;</span>, mLooper);</span><br><span class="line"><span class="comment">//启动主控状态机</span></span><br><span class="line">        mTetherMasterSM.start();</span><br><span class="line">        TetherMasterSM(String name, Looper looper) &#123;</span><br><span class="line">            <span class="built_in">super</span>(name, looper);</span><br><span class="line"><span class="comment">// 构建tree, 每一个的parentnode也是null</span></span><br><span class="line">            addState(mInitialState);</span><br><span class="line">            addState(mTetherModeAliveState);</span><br><span class="line">            addState(mSetIpForwardingEnabledErrorState);</span><br><span class="line">            addState(mSetIpForwardingDisabledErrorState);</span><br><span class="line">            addState(mStartTetheringErrorState);</span><br><span class="line">            addState(mStopTetheringErrorState);</span><br><span class="line">            addState(mSetDnsForwardersErrorState);</span><br><span class="line"></span><br><span class="line">            mNotifyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            mIPv6TetheringCoordinator = <span class="keyword">new</span> <span class="title class_">IPv6TetheringCoordinator</span>(mNotifyList, mLog);</span><br><span class="line">            mOffload = <span class="keyword">new</span> <span class="title class_">OffloadWrapper</span>();</span><br><span class="line"><span class="comment">// 初始State为 TetherMasterSM的InitialState</span></span><br><span class="line">            setInitialState(mInitialState);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>TetherMasterSM的InitialState没有enter方法, 所以在启动主控状态机时并没有执行.只是更新了InitialState的stack,并将mIsConstructionCompleted标记为true</p>
<h5 id="3-3-3-2-2-接收interface状态机的回调"><a href="#3-3-3-2-2-接收interface状态机的回调" class="headerlink" title="3.3.3.2.2. 接收interface状态机的回调"></a>3.3.3.2.2. 接收interface状态机的回调</h5><p>接着TISM的初始化工作讲, 将回调interfaceAdd或interfaceChanged后, 初始化并启动了TISM状态机. 回调了notifyInterfaceStateChange方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// TISM initalState</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">            sendInterfaceState(IControlsTethering.STATE_AVAILABLE);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move into TetherMasterSM.</span></span><br><span class="line">    <span class="comment">// state = STATE_AVAILABLE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyInterfaceStateChange</span><span class="params">(</span></span><br><span class="line"><span class="params">            String iface, TetherInterfaceStateMachine who, <span class="type">int</span> state, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPublicSync) &#123;</span><br><span class="line">            <span class="comment">// 在TISM初始化时, 加到mTetherStates中的</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">TetherState</span> <span class="variable">tetherState</span> <span class="operator">=</span> mTetherStates.get(iface);</span><br><span class="line">            <span class="keyword">if</span> (tetherState != <span class="literal">null</span> &amp;&amp; tetherState.stateMachine.equals(who)) &#123;</span><br><span class="line">                <span class="comment">// 更新lastState为STATE_AVAILABLE</span></span><br><span class="line">                tetherState.lastState = state;</span><br><span class="line">                tetherState.lastError = error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data_saver相关, 暂不用关注</span></span><br><span class="line">            mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> which;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_UNAVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_AVAILABLE:</span><br><span class="line">                <span class="comment">// handler 处理 EVENT_IFACE_SERVING_STATE_INACTIVE消息.</span></span><br><span class="line">                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_TETHERED:</span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_LOCAL_ONLY:</span><br><span class="line">                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Unknown interface state: &quot;</span> + state);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mTetherMasterSM.sendMessage(which, state, <span class="number">0</span>, who);</span><br><span class="line">        sendTetherStateChangedBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// StateMachine的handleMessage进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (mIsConstructionCompleted) &#123;</span><br><span class="line">                    <span class="comment">/** Normal path */</span></span><br><span class="line"><span class="number">1.</span>                    msgProcessedState = processMsg(msg);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="number">2.</span>                performTransitions(msgProcessedState, msg);</span><br><span class="line"><span class="number">3.</span> 进到TetherMasterSm的InitialState处理</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InitialState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">                logMessage(<span class="built_in">this</span>, message.what);</span><br><span class="line">                <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EVENT_IFACE_SERVING_STATE_ACTIVE:</span><br><span class="line">                        <span class="type">TetherInterfaceStateMachine</span> <span class="variable">who</span> <span class="operator">=</span> (TetherInterfaceStateMachine) message.obj;</span><br><span class="line">                        <span class="keyword">if</span> (VDBG) Log.d(TAG, <span class="string">&quot;Tether Mode requested by &quot;</span> + who);</span><br><span class="line">                        handleInterfaceServingStateActive(message.arg1, who);</span><br><span class="line">                        transitionTo(mTetherModeAliveState);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 处理inactive消息,这个地方在这时什么也没做</span></span><br><span class="line">                    <span class="keyword">case</span> EVENT_IFACE_SERVING_STATE_INACTIVE:</span><br><span class="line">                        who = (TetherInterfaceStateMachine) message.obj;</span><br><span class="line">                        <span class="keyword">if</span> (VDBG) Log.d(TAG, <span class="string">&quot;Tether Mode unrequested by &quot;</span> + who);</span><br><span class="line">                        handleInterfaceServingStateInactive(who);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EVENT_IFACE_UPDATE_LINKPROPERTIES:</span><br><span class="line">                        <span class="comment">// Silently ignore these for now.</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> NOT_HANDLED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="number">1.</span> <span class="comment">// 没有转换state, 因此performTransitions也没有实际的工作.</span></span><br></pre></td></tr></table></figure>

<p>在仅仅有interfaceAdd回调时, 此时的TMSM主控状态机的状态保留在InitialState. 而TISM 接口状态机的状态也保存在InitialState. 同时TetherState的lastState为STATE_AVAILABLE</p>
<h4 id="3-3-3-3-收到configured状态后-开启网络共享"><a href="#3-3-3-3-收到configured状态后-开启网络共享" class="headerlink" title="3.3.3.3. 收到configured状态后, 开启网络共享"></a>3.3.3.3. 收到configured状态后, 开启网络共享</h4><p>在切换rndis成功后, 首先有网卡接口消息的上报, 然后收到configured uevent消息, 并通过广播拿到该状态后, 开启网络共享.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED,</span><br><span class="line">                              ConnectivityManager.TETHERING_USB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tetherMatchingInterfaces</span><span class="params">(<span class="type">int</span> requestedState, <span class="type">int</span> interfaceType)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (VDBG) &#123;</span><br><span class="line">          Log.d(TAG, <span class="string">&quot;tetherMatchingInterfaces(&quot;</span> + requestedState + <span class="string">&quot;, &quot;</span> + interfaceType + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String[] ifaces = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 下发netd找到所有网卡接口</span></span><br><span class="line">          ifaces = mNMService.listInterfaces();</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="type">String</span> <span class="variable">chosenIface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ifaces != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String iface : ifaces) &#123;</span><br><span class="line">              <span class="comment">// 找到usb0/rndis0</span></span><br><span class="line">              <span class="keyword">if</span> (ifaceNameToType(iface) == interfaceType) &#123;</span><br><span class="line">                  chosenIface = iface;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      changeInterfaceState(chosenIface, requestedState);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeInterfaceState</span><span class="params">(String ifname, <span class="type">int</span> requestedState)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> result;</span><br><span class="line">      <span class="keyword">switch</span> (requestedState) &#123;</span><br><span class="line">          <span class="keyword">case</span> IControlsTethering.STATE_UNAVAILABLE:</span><br><span class="line">          <span class="keyword">case</span> IControlsTethering.STATE_AVAILABLE:</span><br><span class="line">              result = untether(ifname);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 处理STATE_TETHERED</span></span><br><span class="line">          <span class="keyword">case</span> IControlsTethering.STATE_TETHERED:</span><br><span class="line">          <span class="keyword">case</span> IControlsTethering.STATE_LOCAL_ONLY:</span><br><span class="line">              result = tether(ifname, requestedState);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">tether</span><span class="params">(String iface, <span class="type">int</span> requestedState)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (DBG) Log.d(TAG, <span class="string">&quot;Tethering &quot;</span> + iface);</span><br><span class="line">      <span class="keyword">synchronized</span> (mPublicSync) &#123;</span><br><span class="line">          <span class="type">TetherState</span> <span class="variable">tetherState</span> <span class="operator">=</span> mTetherStates.get(iface);</span><br><span class="line">          <span class="comment">// 检查lastState是否是STATE_AVAILABLE, 不是的话, 状态出错</span></span><br><span class="line">          <span class="keyword">if</span> (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) &#123;</span><br><span class="line">              Log.e(TAG, <span class="string">&quot;Tried to Tether an unavailable iface: &quot;</span> + iface + <span class="string">&quot;, ignoring&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 通知到TISM 进入TISM的当前的状态机处理CMD_TETHER_REQUESTED消息. 消息参数为STATE_TETHERED</span></span><br><span class="line">          tetherState.stateMachine.sendMessage(</span><br><span class="line">                  TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);</span><br><span class="line">          <span class="keyword">return</span> ConnectivityManager.TETHER_ERROR_NO_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在开启网络共享时, 先通过TISM的状态机切换状态. </p>
<p>TISM的InitialState处理CMD_TETHER_REQUESTED消息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    logMessage(<span class="built_in">this</span>, message.what);</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_TETHER_REQUESTED:</span><br><span class="line">            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;</span><br><span class="line">            <span class="keyword">switch</span> (message.arg1) &#123;</span><br><span class="line">                <span class="keyword">case</span> IControlsTethering.STATE_LOCAL_ONLY:</span><br><span class="line">                    transitionTo(mLocalHotspotState);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 处理CMD_TETHER_REQUESTED消息. 消息参数为STATE_TETHERED</span></span><br><span class="line">                <span class="keyword">case</span> IControlsTethering.STATE_TETHERED:</span><br><span class="line">                    <span class="comment">// TISM 状态机切换到TetherdState</span></span><br><span class="line">                    transitionTo(mTetheredState);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    mLog.e(<span class="string">&quot;Invalid tethering interface serving state specified.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在基类StateMachine handleMessage的末尾处理performTransitions函数.</p>
<p>调用切换前State的Exit方法, 更新DestState的Stack, 对更新后的Stack未激活的stack执行其enter方法.</p>
<p>TISM的InitialState没有exit方法. 只执行TetherState的enter方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">TetheredState</span> <span class="keyword">extends</span> <span class="title class_">BaseServingState</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行BaseServingState的enter方法</span></span><br><span class="line">            <span class="built_in">super</span>.enter();</span><br><span class="line">            <span class="keyword">if</span> (mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) &#123;</span><br><span class="line">                transitionTo(mInitialState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">3.</span> <span class="comment">// 通知到主控状态机</span></span><br><span class="line">            sendInterfaceState(IControlsTethering.STATE_TETHERED);</span><br><span class="line">            <span class="comment">// SPRD: set sys.ril.internet_tethering prop when USB internet connected</span></span><br><span class="line">            <span class="keyword">if</span>(mInterfaceType == ConnectivityManager.TETHERING_USB) &#123;</span><br><span class="line">                SystemProperties.set(<span class="string">&quot;sys.ril.internet_tethering&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">BaseServingState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="number">1.</span> <span class="comment">//  配置ipv4.</span></span><br><span class="line">            <span class="keyword">if</span> (!startIPv4()) &#123;</span><br><span class="line">                mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="number">2.</span> <span class="comment">// 开启网卡usb网络共享状态, 下发netd. </span></span><br><span class="line">                mNMService.tetherInterface(mIfaceName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                mLog.e(<span class="string">&quot;Error Tethering: &quot;</span> + e);</span><br><span class="line">                mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isTetherIpv6SprdDesigned()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!startIPv6()) &#123;</span><br><span class="line">                    mLog.e(<span class="string">&quot;Failed to startIPv6&quot;</span>);</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Make this a fatal error once Bluetooth IPv6 is sorted.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">3.</span> <span class="comment">//sendInterfaceState(IControlsTethering.STATE_TETHERED);</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Move into TetherMasterSM.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyInterfaceStateChange</span><span class="params">(</span></span><br><span class="line"><span class="params">            String iface, TetherInterfaceStateMachine who, <span class="type">int</span> state, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPublicSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TetherState</span> <span class="variable">tetherState</span> <span class="operator">=</span> mTetherStates.get(iface);</span><br><span class="line">            <span class="keyword">if</span> (tetherState != <span class="literal">null</span> &amp;&amp; tetherState.stateMachine.equals(who)) &#123;</span><br><span class="line">                <span class="comment">// tetherState 的lastState更新为 STATE_TETHERED</span></span><br><span class="line">                tetherState.lastState = state;</span><br><span class="line">                tetherState.lastError = error;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> which;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="comment">// 处理STATE_TETHERED</span></span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_TETHERED:</span><br><span class="line">            <span class="keyword">case</span> IControlsTethering.STATE_LOCAL_ONLY:</span><br><span class="line">                which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主控状态机切换状态. InitialState处理EVENT_IFACE_SERVING_STATE_ACTIVE消息.</span></span><br><span class="line">        mTetherMasterSM.sendMessage(which, state, <span class="number">0</span>, who);</span><br><span class="line">        sendTetherStateChangedBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">InitialState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">                logMessage(<span class="built_in">this</span>, message.what);</span><br><span class="line">                <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> EVENT_IFACE_SERVING_STATE_ACTIVE:</span><br><span class="line">                        <span class="type">TetherInterfaceStateMachine</span> <span class="variable">who</span> <span class="operator">=</span> (TetherInterfaceStateMachine) message.obj;</span><br><span class="line">                        handleInterfaceServingStateActive(message.arg1, who);</span><br><span class="line">                       <span class="number">3.1</span> <span class="comment">// 主控状态机切换为 TetherModeAliveState</span></span><br><span class="line">                        transitionTo(mTetherModeAliveState);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                       <span class="number">3.2</span> <span class="comment">// sendMessage的末尾处理InitialState.exit方法(这里没有实现),并更新新的State的Stack, 最后执行TetherModeAliveState 的enter方法. 激活的意思.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleInterfaceServingStateActive</span><span class="params">(<span class="type">int</span> mode, TetherInterfaceStateMachine who)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == IControlsTethering.STATE_TETHERED) &#123;</span><br><span class="line">                <span class="comment">// No need to notify OffloadController just yet as there are no</span></span><br><span class="line">                <span class="comment">// &quot;offload-able&quot; prefixes to pass along. This will handled</span></span><br><span class="line">                <span class="comment">// when the TISM informs Tethering of its LinkProperties.</span></span><br><span class="line">                mForwardedDownstreams.add(who);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;   </span><br><span class="line"> <span class="number">3.2</span>     <span class="keyword">class</span> <span class="title class_">TetherModeAliveState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">mUpstreamWanted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">mTryCell</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 执行enter方法.</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// If turning on master tether settings fails, we have already</span></span><br><span class="line">                <span class="comment">// transitioned to an error state; exit early.</span></span><br><span class="line">                <span class="number">3.2</span><span class="number">.1</span> turnOnMasterTetherSettings</span><br><span class="line">                <span class="title function_">if</span> <span class="params">(!turnOnMasterTetherSettings()</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSimChange.startListening();</span><br><span class="line">                mUpstreamNetworkMonitor.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> De-duplicate with updateUpstreamWanted() below.</span></span><br><span class="line">                <span class="keyword">if</span> (upstreamWanted()) &#123;</span><br><span class="line">                    mUpstreamWanted = <span class="literal">true</span>;</span><br><span class="line">                    mOffload.start();</span><br><span class="line">                    <span class="number">3.2</span><span class="number">.2</span> chooseUpstreamType</span><br><span class="line">                    <span class="title function_">chooseUpstreamType</span><span class="params">(<span class="literal">true</span>)</span>;</span><br><span class="line">                    mTryCell = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;         </span><br></pre></td></tr></table></figure>

<p>在开启网络共享后, 先是TISM行动,  切换并激活了TetherState, 然后tetherState lastState变更到STATE_TETHERD, 并通知到主控状态机TMSM切换到TetherModeAliveState 并激活.</p>
<p>在上面两个状态机激活绑定状态时,即在enter时, 涉及到了usb网卡的配置及激活共享等操作. 这些命令抛开state的流程单独描述.</p>
<h5 id="3-3-3-3-1-网络配置激活等"><a href="#3-3-3-3-1-网络配置激活等" class="headerlink" title="3.3.3.3.1. 网络配置激活等"></a>3.3.3.3.1. 网络配置激活等</h5><ol>
<li>startIPv4</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">startIPv4</span><span class="params">()</span> &#123; <span class="keyword">return</span> configureIPv4(<span class="literal">true</span>); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">configureIPv4</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) Log.d(TAG, <span class="string">&quot;configureIPv4(&quot;</span> + enabled + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Replace this hard-coded information with dynamically selected</span></span><br><span class="line">        <span class="comment">// config passed down to us by a higher layer IP-coordinating element.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAsString</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prefixLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mInterfaceType == ConnectivityManager.TETHERING_USB) &#123;</span><br><span class="line">            <span class="comment">// &quot;192.168.42.129&quot;</span></span><br><span class="line">            ipAsString = USB_NEAR_IFACE_ADDR;</span><br><span class="line">            <span class="comment">// 24</span></span><br><span class="line">            prefixLen = USB_PREFIX_LENGTH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkAddress linkAddr;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得usb0网卡的初始配置</span></span><br><span class="line">            <span class="comment">// SND -&gt; &#123;63 interface getcfg usb0&#125;</span></span><br><span class="line">            <span class="comment">// RCV &lt;- &#123;213 63 9e:84:73:52:ac:0a 0.0.0.0     0      down broadcast multicast&#125;</span></span><br><span class="line">            <span class="comment">//                mHwAddr           mAddr    prefixLen  flag  flag       flag</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InterfaceConfiguration</span> <span class="variable">ifcg</span> <span class="operator">=</span> mNMService.getInterfaceConfig(mIfaceName);           </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                private String mHwAddr;</span></span><br><span class="line"><span class="comment">                private LinkAddress mAddr;</span></span><br><span class="line"><span class="comment">                private HashSet&lt;String&gt; mFlags = Sets.newHashSet();</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> NetworkUtils.numericToInetAddress(ipAsString);</span><br><span class="line">            <span class="comment">// 更新网口config, 更新后的参数</span></span><br><span class="line">            <span class="comment">// mAddr 192.168.42.129  lenth为24</span></span><br><span class="line">            linkAddr = <span class="keyword">new</span> <span class="title class_">LinkAddress</span>(addr, prefixLen);</span><br><span class="line">            ifcg.setLinkAddress(linkAddr);</span><br><span class="line">                <span class="comment">// enabled为true</span></span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    <span class="comment">//         mFlags.remove(FLAG_DOWN);    mFlags.add(FLAG_UP);</span></span><br><span class="line">                    ifcg.setInterfaceUp();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ifcg.setInterfaceDown();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// mFlags.remove(&quot;running&quot;);</span></span><br><span class="line">            ifcg.clearFlag(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="comment">// SND -&gt; &#123;64 interface setcfg usb0 192.168.42.129 24 broadcast up multicast&#125;</span></span><br><span class="line">            <span class="comment">// 更新后的usb0网卡参数, up表示会启动该网卡</span></span><br><span class="line">            <span class="comment">// 9e:84:73:52:ac:0a 192.168.42.129 24 up broadcast multicast</span></span><br><span class="line">            <span class="comment">// 设置更新完成后, 会收到回复</span></span><br><span class="line">            <span class="comment">// RCV &lt;- &#123;614 Address updated 192.168.42.129/24 usb0 128 0&#125;</span></span><br><span class="line">            <span class="comment">// RCV &lt;- &#123;600 Iface linkstate usb0 up&#125;</span></span><br><span class="line">            <span class="comment">// RCV &lt;- &#123;616 Route updated fe80::/64 dev usb0&#125;</span></span><br><span class="line">            <span class="comment">// RCV &lt;- &#123;614 Address updated fe80::9c84:73ff:fe52:ac0a/64 usb0 196 253&#125;</span></span><br><span class="line">            mNMService.setInterfaceConfig(mIfaceName, ifcg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Directly-connected route.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RouteInfo</span> <span class="variable">route</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteInfo</span>(linkAddr);</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">            mLinkProperties.addLinkAddress(linkAddr);</span><br><span class="line">            mLinkProperties.addRoute(route);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLinkProperties.removeLinkAddress(linkAddr);</span><br><span class="line">            mLinkProperties.removeRoute(route);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>开启网卡usb网络共享状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mNMService.tetherInterface(mIfaceName);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tetherInterface</span><span class="params">(String iface)</span> &#123;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// SND -&gt; &#123;65 tether interface add usb0&#125;</span></span><br><span class="line">            mConnector.execute(<span class="string">&quot;tether&quot;</span>, <span class="string">&quot;interface&quot;</span>, <span class="string">&quot;add&quot;</span>, iface);</span><br><span class="line">        &#125; </span><br><span class="line">        List&lt;RouteInfo&gt; routes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// SND -&gt; &#123;66 interface getcfg usb0&#125;</span></span><br><span class="line">        <span class="comment">// RCV &lt;- &#123;213 66 9e:84:73:52:ac:0a 192.168.42.129 24 up broadcast multicast&#125;</span></span><br><span class="line">        routes.add(<span class="keyword">new</span> <span class="title class_">RouteInfo</span>(getInterfaceConfig(iface).getLinkAddress(), <span class="literal">null</span>, iface));</span><br><span class="line">        addInterfaceToLocalNetwork(iface, routes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterfaceToLocalNetwork</span><span class="params">(String iface, List&lt;RouteInfo&gt; routes)</span> &#123;</span><br><span class="line">        <span class="comment">// SND -&gt; &#123;67 network interface add local usb0&#125;</span></span><br><span class="line">        modifyInterfaceInNetwork(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;local&quot;</span>, iface);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RouteInfo route : routes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!route.isDefaultRoute()) &#123;</span><br><span class="line">                <span class="comment">// SND -&gt; &#123;68 network route add local usb0 192.168.42.0/24&#125;</span></span><br><span class="line">                modifyRoute(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;local&quot;</span>, route);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>turnOnMasterTetherSettings</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.2</span><span class="number">.1</span>. <span class="comment">// 跳转turnOnMasterTetherSettings 函数. 启动共享连接服务</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">turnOnMasterTetherSettings</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TetheringConfiguration</span> <span class="variable">cfg</span> <span class="operator">=</span> mConfig;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="number">1.</span>             mNMService.setIpForwardingEnabled(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                mLog.e(e);</span><br><span class="line">                transitionTo(mSetIpForwardingEnabledErrorState);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Randomize DHCPv4 ranges, especially in hotspot mode.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Find a more accurate method name (startDHCPv4()?).</span></span><br><span class="line"> <span class="number">2.1</span>               <span class="comment">// TetheringConfiguration最初的信息来自于TetheringConfiguration的构造函数.</span></span><br><span class="line"> <span class="number">2.2</span>               mNMService.startTethering(cfg.dhcpRanges);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mNMService.stopTethering();</span><br><span class="line">                    mNMService.startTethering(cfg.dhcpRanges);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    mLog.e(ee);</span><br><span class="line">                    transitionTo(mStartTetheringErrorState);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mLog.log(<span class="string">&quot;SET master tether settings: ON&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">1.</span> setIpForwardingEnabled</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIpForwardingEnabled</span><span class="params">(<span class="type">boolean</span> enable)</span> &#123;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// SND -&gt; &#123;70 ipfwd enable tethering&#125;</span></span><br><span class="line">            mConnector.execute(<span class="string">&quot;ipfwd&quot;</span>, enable ? <span class="string">&quot;enable&quot;</span> : <span class="string">&quot;disable&quot;</span>, <span class="string">&quot;tethering&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="number">2.1</span> TetheringConfiguration初始化</span><br><span class="line"> <span class="comment">// Tethering构造函数中</span></span><br><span class="line"> updateConfiguration();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        mConfig = <span class="keyword">new</span> <span class="title class_">TetheringConfiguration</span>(mContext, mLog);</span><br><span class="line">        mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">TetheringConfiguration</span><span class="params">(Context ctx, SharedLog log)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SharedLog</span> <span class="variable">configLog</span> <span class="operator">=</span> log.forSubComponent(<span class="string">&quot;config&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tetherableUsbRegexs = ctx.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_tether_usb_regexs);</span><br><span class="line">        </span><br><span class="line"><span class="number">69</span>    &lt;string-array translatable=<span class="string">&quot;false&quot;</span> name=<span class="string">&quot;config_tether_usb_regexs&quot;</span>&gt;</span><br><span class="line"><span class="number">70</span>        &lt;item&gt;<span class="string">&quot;usb\\d&quot;</span>&lt;/item&gt;</span><br><span class="line"><span class="number">71</span>        &lt;item&gt;<span class="string">&quot;rndis\\d&quot;</span>&lt;/item&gt;</span><br><span class="line"><span class="number">72</span>    &lt;/string-array&gt;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Evaluate deleting this altogether now that Wi-Fi always passes</span></span><br><span class="line">        <span class="comment">// us an interface name. Careful consideration needs to be given to</span></span><br><span class="line">        <span class="comment">// implications for Settings and for provisioning checks.</span></span><br><span class="line">        tetherableWifiRegexs = ctx.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_tether_wifi_regexs);</span><br><span class="line">        tetherableBluetoothRegexs = ctx.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_tether_bluetooth_regexs);</span><br><span class="line"></span><br><span class="line">        dunCheck = checkDunRequired(ctx);</span><br><span class="line">        configLog.log(<span class="string">&quot;DUN check returned: &quot;</span> + dunCheckString(dunCheck));</span><br><span class="line"></span><br><span class="line">        preferredUpstreamIfaceTypes = getUpstreamIfaceTypes(ctx, dunCheck);</span><br><span class="line">        isDunRequired = preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN);</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span><span class="number">.1</span>        dhcpRanges = getDhcpRanges(ctx);</span><br><span class="line">        defaultIPv4DNS = copy(DEFAULT_IPV4_DNS);</span><br><span class="line"></span><br><span class="line">        configLog.log(toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span><span class="number">.1</span>    <span class="keyword">private</span> <span class="keyword">static</span> String[] getDhcpRanges(Context ctx) &#123;</span><br><span class="line">    <span class="comment">// 这个里面没改的话是空的,</span></span><br><span class="line">        <span class="keyword">final</span> String[] fromResource = ctx.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_tether_dhcp_range);</span><br><span class="line">        <span class="keyword">if</span> ((fromResource.length &gt; <span class="number">0</span>) &amp;&amp; (fromResource.length % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromResource;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 前面的为空, 返回下面这个写死的值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        private static final String[] DHCP_DEFAULT_RANGE = &#123;</span></span><br><span class="line"><span class="comment">            &quot;192.168.42.2&quot;, &quot;192.168.42.254&quot;, &quot;192.168.43.2&quot;, &quot;192.168.43.254&quot;,</span></span><br><span class="line"><span class="comment">            &quot;192.168.44.2&quot;, &quot;192.168.44.254&quot;, &quot;192.168.45.2&quot;, &quot;192.168.45.254&quot;,</span></span><br><span class="line"><span class="comment">            &quot;192.168.46.2&quot;, &quot;192.168.46.254&quot;, &quot;192.168.47.2&quot;, &quot;192.168.47.254&quot;,</span></span><br><span class="line"><span class="comment">            &quot;192.168.48.2&quot;, &quot;192.168.48.254&quot;, &quot;192.168.49.2&quot;, &quot;192.168.49.254&quot;,</span></span><br><span class="line"><span class="comment">            &quot;192.168.137.2&quot;, &quot;192.168.137.254&quot;, &quot;192.168.0.2&quot;, &quot;192.168.0.254&quot;,</span></span><br><span class="line"><span class="comment">       &#125;;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">return</span> copy(DHCP_DEFAULT_RANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="number">2.2</span> mNMService.startTethering(cfg.dhcpRanges);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTethering</span><span class="params">(String[] dhcpRange)</span> &#123;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Command</span>(<span class="string">&quot;tether&quot;</span>, <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String d : dhcpRange) &#123;</span><br><span class="line">            cmd.appendArg(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//SND -&gt; &#123;71 tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254&#125;</span></span><br><span class="line">            mConnector.execute(cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>turnOnMasterTetherSettings 主要工作就是下发了两个命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipfwd enable tethering</span><br><span class="line">tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254</span><br></pre></td></tr></table></figure>
</li>
<li><p>chooseUpstreamType</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3.2</span><span class="number">.2</span> <span class="comment">//  跳转chooseUpstreamType函数, 进行网络通路优化 tryCell true</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">chooseUpstreamType</span><span class="params">(<span class="type">boolean</span> tryCell)</span> &#123;</span><br><span class="line">            <span class="comment">// We rebuild configuration on ACTION_CONFIGURATION_CHANGED, but we</span></span><br><span class="line">            <span class="comment">// do not currently know how to watch for changes in DUN settings.</span></span><br><span class="line">            <span class="comment">// 可能更新了配置信息, 即上面的TetheringConfiguration</span></span><br><span class="line">            maybeUpdateConfiguration();</span><br><span class="line">            <span class="comment">// preferredUpstreamIfaceTypes是在TetheringConfiguration传入的, 注意系统中只定义了数据流量模式, wifi模式和蓝牙网络可以作为优选网络, 1/7/0. 在数据流量模式时, 需要检查TelephoneManager的dunCheck, dunCheck为DUN_REQUIRED时忽略数据流量模式, 即不能作为优选网络. 网络通路.     </span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">NetworkState</span> <span class="variable">ns</span> <span class="operator">=</span> mUpstreamNetworkMonitor.selectPreferredUpstreamType(</span><br><span class="line">                    mConfig.preferredUpstreamIfaceTypes);</span><br><span class="line">            <span class="keyword">if</span> (ns == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tryCell) &#123;</span><br><span class="line">                    mUpstreamNetworkMonitor.registerMobileNetworkRequest();</span><br><span class="line">                    <span class="comment">// We think mobile should be coming up; don&#x27;t set a retry.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mUpstreamNetworkMonitor.setCurrentUpstream((ns != <span class="literal">null</span>) ? ns.network : <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 如果找到了优选网络通路. 设置dns转发  </span></span><br><span class="line">  <span class="number">3.2</span><span class="number">.2</span><span class="number">.1</span>          setUpstreamNetwork(ns);</span><br><span class="line"></span><br><span class="line">            ...<span class="comment">//ipv6 相关</span></span><br><span class="line">            <span class="keyword">return</span> upV6Type;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">3.2</span><span class="number">.2</span><span class="number">.1</span> </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUpstreamNetwork</span><span class="params">(NetworkState ns)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">iface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ns != <span class="literal">null</span> &amp;&amp; ns.linkProperties != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Find the interface with the default IPv4 route. It may be the</span></span><br><span class="line">                <span class="comment">// interface described by linkProperties, or one of the interfaces</span></span><br><span class="line">                <span class="comment">// stacked on top of it.</span></span><br><span class="line">                mLog.i(<span class="string">&quot;Finding IPv4 upstream interface on: &quot;</span> + ns.linkProperties);</span><br><span class="line">                <span class="comment">// 选择最佳路由</span></span><br><span class="line">                <span class="type">RouteInfo</span> <span class="variable">ipv4Default</span> <span class="operator">=</span> RouteInfo.selectBestRoute(</span><br><span class="line">                    ns.linkProperties.getAllRoutes(), Inet4Address.ANY);</span><br><span class="line">                <span class="keyword">if</span> (ipv4Default != <span class="literal">null</span>) &#123;</span><br><span class="line">                    iface = ipv4Default.getInterface();</span><br><span class="line">                    mLog.i(<span class="string">&quot;Found interface &quot;</span> + ipv4Default.getInterface());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLog.i(<span class="string">&quot;No IPv4 upstream interface, giving up.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iface != <span class="literal">null</span>) &#123;                </span><br><span class="line">  <span class="number">1.</span>            setDnsForwarders(ns.network, ns.linkProperties);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 设置桥接转发</span></span><br><span class="line">  <span class="number">2.</span>        notifyDownstreamsOfNewUpstreamIface(iface);</span><br><span class="line">            <span class="keyword">if</span> (ns != <span class="literal">null</span> &amp;&amp; pertainsToCurrentUpstream(ns)) &#123;</span><br><span class="line">                <span class="comment">// If we already have NetworkState for this network examine</span></span><br><span class="line">                <span class="comment">// it immediately, because there likely will be no second</span></span><br><span class="line">                <span class="comment">// EVENT_ON_AVAILABLE (it was already received).</span></span><br><span class="line">                handleNewUpstreamNetworkState(ns);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCurrentUpstreamIface == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// There are no available upstream networks, or none that</span></span><br><span class="line">                <span class="comment">// have an IPv4 default route (current metric for success).</span></span><br><span class="line">                handleNewUpstreamNetworkState(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>发现优选网络通路后,  设置dns server地址, 并进行网络地址转换和ip转发</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">// SND -&gt; &#123;72 tether dns set 100 192.168.1.1&#125;</span></span><br><span class="line">    setDnsForwarders(ns.network, ns.linkProperties);</span><br><span class="line"><span class="number">2.</span> notifyDownstreamsOfNewUpstreamIface(iface)</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">notifyDownstreamsOfNewUpstreamIface</span><span class="params">(String ifaceName)</span> &#123;</span><br><span class="line">            mLog.log(<span class="string">&quot;Notifying downstreams of upstream=&quot;</span> + ifaceName);</span><br><span class="line">            mCurrentUpstreamIface = ifaceName;</span><br><span class="line">            <span class="keyword">for</span> (TetherInterfaceStateMachine sm : mNotifyList) &#123;</span><br><span class="line">                <span class="comment">// TISM此时处于TetherState, 因此由TetherState处理该消息</span></span><br><span class="line">                sm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED,</span><br><span class="line">                        ifaceName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">..<span class="comment">//TetherState的processMessage函数</span></span><br><span class="line">                <span class="keyword">case</span> CMD_TETHER_CONNECTION_CHANGED:</span><br><span class="line">                    <span class="type">String</span> <span class="variable">newUpstreamIfaceName</span> <span class="operator">=</span> (String)(message.obj);</span><br><span class="line">                    cleanupUpstream();</span><br><span class="line">                    <span class="keyword">if</span> (newUpstreamIfaceName != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            </span><br><span class="line">                           <span class="number">2.1</span>  <span class="comment">// 网络地址转换</span></span><br><span class="line">                            mNMService.enableNat(mIfaceName, newUpstreamIfaceName);</span><br><span class="line">                            <span class="number">2.2</span> <span class="comment">// 启动ip转发</span></span><br><span class="line">                            mNMService.startInterfaceForwarding(mIfaceName,</span><br><span class="line">                                    newUpstreamIfaceName);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            mLog.e(<span class="string">&quot;Exception enabling NAT: &quot;</span> + e);</span><br><span class="line">                            cleanupUpstreamInterface(newUpstreamIfaceName);</span><br><span class="line">                            mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;</span><br><span class="line">                            transitionTo(mInitialState);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mMyUpstreamIfaceName = newUpstreamIfaceName;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="number">2.1</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enableNat</span><span class="params">(String internalInterface, String externalInterface)</span> &#123;</span><br><span class="line">        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// SND -&gt; &#123;74 nat enable usb0 wlan0 1 192.168.42.0/24&#125;</span></span><br><span class="line">            <span class="comment">// 网络地址转换</span></span><br><span class="line">            modifyNat(<span class="string">&quot;enable&quot;</span>, internalInterface, externalInterface);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.2</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">modifyInterfaceForward</span><span class="params">(<span class="type">boolean</span> add, String fromIface, String toIface)</span> &#123;</span><br><span class="line">        <span class="comment">//  SND -&gt; &#123;75 ipfwd add usb0 wlan0&#125;</span></span><br><span class="line">        <span class="comment">//  RCV &lt;- &#123;614 Address updated fe80::9c84:73ff:fe52:ac0a/64 usb0 128 253&#125;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Command</span>(<span class="string">&quot;ipfwd&quot;</span>, add ? <span class="string">&quot;add&quot;</span> : <span class="string">&quot;remove&quot;</span>, fromIface, toIface);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mConnector.execute(cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用turnOnMasterTetherSettings时, 执行了tether start命令, 该命令会启动dnsmasq服务.</p>
<p>dnsmasq启动:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">M00AE64 06-29 08:31:02.445  7182  7182 I dnsmasq : started, version 2.51 cachesize 150</span><br><span class="line">M00AE65 06-29 08:31:02.445  7182  7182 I dnsmasq : compile time options: IPv6 GNU-getopt no-I18N DHCP no-scripts</span><br><span class="line">M00AE66 06-29 08:31:02.445  7182  7182 W dnsmasq : warning: no upstream servers configured</span><br><span class="line">M00AE67 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.0.2 -- 192.168.0.254, lease time 1h</span><br><span class="line">M00AE68 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.137.2 -- 192.168.137.254, lease time 1h</span><br><span class="line">M00AE69 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.49.2 -- 192.168.49.254, lease time 1h</span><br><span class="line">M00AE6A 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.48.2 -- 192.168.48.254, lease time 1h</span><br><span class="line">M00AE6B 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.47.2 -- 192.168.47.254, lease time 1h</span><br><span class="line">M00AE6C 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.46.2 -- 192.168.46.254, lease time 1h</span><br><span class="line">M00AE6D 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.45.2 -- 192.168.45.254, lease time 1h</span><br><span class="line">M00AE6E 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.44.2 -- 192.168.44.254, lease time 1h</span><br><span class="line">M00AE6F 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.43.2 -- 192.168.43.254, lease time 1h</span><br><span class="line">M00AE70 06-29 08:31:02.446  7182  7182 I dnsmasq : DHCP, IP range 192.168.42.2 -- 192.168.42.254, lease time 1h</span><br><span class="line">M00AE71 06-29 08:31:02.447  7182  7182 I dnsmasq : read /etc/hosts - 2 addresses</span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-3-2-涉及到的网络知识"><a href="#3-3-3-3-2-涉及到的网络知识" class="headerlink" title="3.3.3.3.2. 涉及到的网络知识"></a>3.3.3.3.2. 涉及到的网络知识</h5><ul>
<li><p>tether interface add usb0</p>
<p> 将interface写到dnsmasq  update_ifaces更新列表中, 使dnsmasq监听该新加的interface. 并在后面分配ip地址.</p>
</li>
<li><p>network interface add local usb0</p>
<p> 添加usb0 dev网卡设备到 local路由表中</p>
</li>
<li><p>network route add local usb0 192.168.42.0&#x2F;24</p>
<p>为usb0网卡在local表中添加路由规则   </p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp9853i_1h10:/ # busybox route -n </span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 wlan0</span><br><span class="line">192.168.42.0    0.0.0.0         255.255.255.0   U     0      0        0 usb0</span><br></pre></td></tr></table></figure>
</li>
<li><p>ipfwd enable tethering</p>
<p> 出于安全考虑，Linux系统默认是禁止数据包转发的。</p>
<blockquote>
<p>所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。   </p>
</blockquote>
<p> 启用ip转发功能, echo 1  &gt;   IPV4_FORWARDING_PROC_FILE</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> IPV4_FORWARDING_PROC_FILE[] = <span class="string">&quot;/proc/sys/net/ipv4/ip_forward&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tether start 192.168.42.2 192.168.42.254 192.168.43.2 192.168.43.254 192.168.44.2 192.168.44.254 192.168.45.2 192.168.45.254 192.168.46.2 192.168.46.254 192.168.47.2 192.168.47.254 192.168.48.2 192.168.48.254 192.168.49.2 192.168.49.254 192.168.137.2 192.168.137.254 192.168.0.2 192.168.0.254</p>
<p> 启动dnsmasq服务, DNSmasq是一个小巧且方便地用于配置<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DNS/427444">DNS</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DHCP">DHCP</a>的工具，适用于小型<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C">网络</a>，它提供了DNS功能和可选择的DHCP功能。它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。 </p>
</li>
<li><p>tether dns set 100 192.168.1.1</p>
<p>设置dnsmasq的dns服务器地址, 缓存DNS</p>
</li>
<li><p>nat enable usb0 wlan0 1 192.168.42.0&#x2F;24</p>
<p> 网络地址转换, pc地址在该网段内</p>
<p> usb0输入设备 wlan0为输出设备  1代表后面的地址组合只有一个    192.168.42.0&#x2F;24代表ip地址和子网掩码</p>
<p> 目的是修改来自源设备的数据包，使它看起来是目标设备发出的数据包</p>
<p> 借助于NAT，私有（保留）地址的”内部”网络通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>发送<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85">数据包</a>时，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80">私有地址</a>被转换成合法的IP地址，一个局域网只需使用少量IP地址即可实现私有地址网络内所有计算机与Internet的通信需求。</p>
<p> NAT将自动修改IP<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成。有些应用程序将源IP地址嵌入到IP<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>的数据部分中，所以还需要同时对报文的数据部分进行修改，以匹配IP头中已经修改过的源IP地址。否则，在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>数据部分嵌入IP地址的应用程序就不能正常工作   </p>
</li>
<li><p>ipfwd add usb0 wlan0</p>
<p>新加一条路由规则.  从usb0来的网转到wlan0去处理.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bytxl/article/details/9850803">路由规则相关案例1</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.51cto.com/laodou/2066476">路由规则相关案例2</a></p>
</li>
</ul>
<h2 id="3-4-Usb-pc-share-pc互联网"><a href="#3-4-Usb-pc-share-pc互联网" class="headerlink" title="3.4. Usb pc-share pc互联网"></a>3.4. Usb pc-share pc互联网</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo adb shell busybox route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 usb0</span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo adb shell ip route</span></span><br><span class="line">192.168.0.0/24 dev usb0 proto kernel scope link src 192.168.0.129</span><br></pre></td></tr></table></figure>

<p>由pc端开启网络共享,给手机使用. pc端对端地址(xp 192.168.0.1), 手机端地址(xp 192.168.0.129), </p>
<pre><code class="shell">0000.log|79018| S01155E 07-23 18:12:44.495   732   945 D ConnectivityService: Switching to new default network: NetworkAgentInfo&#123; ni&#123;[type: USBETHER[], state: CONNECTED/CONNECTED, reason: (unspecified), extra: (none), failover: false, available: true, roaming: false]&#125;  network&#123;100&#125;  nethandle&#123;432902426637&#125;  lp&#123;&#123;InterfaceName: usb0 LinkAddresses: [192.168.0.129/24,]  Routes: [0.0.0.0/0 -> 192.168.0.1 usb0,192.168.0.0/24 -> 0.0.0.0 usb0,] DnsAddresses: [192.168.0.1,] UsePrivateDns: false PrivateDnsServerName: null Domains: null MTU: 0&#125;&#125;  nc&#123;[ Transports: ETHERNET Capabilities: INTERNET&amp;NOT_RESTRICTED&amp;TRUSTED&amp;NOT_VPN&amp;FOREGROUND&amp;NOT_SUSPENDED Unwanted: ]&#125;  Score&#123;11&#125;  everValidated&#123;false&#125;  lastValidated&#123;false&#125;  created&#123;true&#125; lingering&#123;false&#125; explicitlySelected&#123;false&#125; acceptUnvalidated&#123;false&#125; everCaptivePortalDetected&#123;false&#125; lastCaptivePortalDetected&#123;fals[&#125; clat&#123;null&#125; ]
``: 
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/01/%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/Android%20fuse%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/" rel="prev" title="Android fuse 文件系统调研">
      <i class="fa fa-chevron-left"></i> Android fuse 文件系统调研
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/07/01/USB%E7%9B%B8%E5%85%B3/AndroidQ%20Usb%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94/" rel="next" title="AndroidQ Usb差异对比">
      AndroidQ Usb差异对比 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-UsbPortManager-usb-role%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">1. UsbPortManager-usb role管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-USB%E4%B8%BB%E6%9C%BA%E5%92%8CUSB%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. USB主机和USB设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Usb%E8%AE%BE%E5%A4%87%E6%BC%94%E8%BF%9B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. Usb设备演进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-typec%E8%AE%BE%E5%A4%87-role%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. typec设备 role管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-power-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. power 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 数据模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-%E7%9B%B8%E5%85%B3%E5%BA%95%E5%B1%82%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3. 相关底层节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E9%80%9A%E7%9F%A5"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4. 状态切换与通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-USB-host-%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">2. USB host 管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Usb-host-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E8%AE%BE%E5%A4%87"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. Usb host 添加和删除设备.</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-usb-host-load%E5%B0%8F%E7%BB%93"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1. usb_host_load小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-usb-host-read-event-%E7%9B%91%E5%90%AC%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2. usb_host_read_event 监听节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-1-usb-host-read-event-%E5%B0%8F%E7%BB%93"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">2.1.2.1. usb_host_read_event 小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E4%B8%A4%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3. 两个回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-usb-device-added%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4. usb_device_added方法添加设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A7%A3%E6%9E%90"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5. 描述符解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-1-1-USB-%E7%AB%AF%E7%82%B9%E3%80%81%E7%AE%A1%E9%81%93%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.5.0.1.</span> <span class="nav-text">2.1.5.1.1. USB 端点、管道和接口的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-6-added-cb-%E5%9B%9E%E8%B0%83%E5%B0%8F%E7%BB%93"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.6. added_cb 回调小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-7-usb-device-removed%E6%96%B9%E6%B3%95%E9%94%80%E6%AF%81%E8%AE%BE%E5%A4%87"><span class="nav-number">2.1.7.</span> <span class="nav-text">2.1.7. usb_device_removed方法销毁设备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%B8%8A%E5%B1%82%E8%8E%B7%E5%8F%96USB-%E8%AE%BE%E5%A4%87%E5%B9%B6%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 上层获取USB 设备并进行传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-USB%E4%BC%A0%E8%BE%93%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1. USB传输通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-UsbAlsaManager-%E9%9F%B3%E9%A2%91%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. UsbAlsaManager 音频管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-UsbAlsaManager%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1. UsbAlsaManager初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-UsbAlsaManager-systemReady"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2. UsbAlsaManager systemReady</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-usbDeviceAdded-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3. usbDeviceAdded 事件回调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Usb-device%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">3. Usb device管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Usb%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. Usb枚举过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BC%A0%E7%BB%9FUsb-device%E4%B8%8Eaccessory-%E9%85%8D%E4%BB%B6-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. 传统Usb device与accessory(配件)模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-accessory%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1. accessory模式下的枚举过程:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-accessory%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2. accessory模式框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-1-%E7%94%B3%E8%AF%B7accessory%E6%9D%83%E9%99%90"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">3.2.2.1. 申请accessory权限</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Usb-%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. Usb 网络共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1. 配置网卡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-StateMachine"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2. StateMachine</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-1-state-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">3.3.2.1. state 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-2-State-Machine%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">3.3.2.2. State Machine各个模块作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-2-1-Smhandler"><span class="nav-number">3.3.2.2.1.</span> <span class="nav-text">3.3.2.2.1. Smhandler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-Tethering%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3. Tethering网络状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-1-TetherInterfaceSM-TetherInterfaceStateMachine"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">3.3.3.1. TetherInterfaceSM(TetherInterfaceStateMachine)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-1-1-TetherInterfaceSM-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.3.1.1.</span> <span class="nav-text">3.3.3.1.1. TetherInterfaceSM 初始化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-2-TetherMasterSM"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">3.3.3.2. TetherMasterSM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-2-1-%E4%B8%BB%E6%8E%A7%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.3.2.1.</span> <span class="nav-text">3.3.3.2.1. 主控状态机初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-2-2-%E6%8E%A5%E6%94%B6interface%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="nav-number">3.3.3.2.2.</span> <span class="nav-text">3.3.3.2.2. 接收interface状态机的回调</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-3-%E6%94%B6%E5%88%B0configured%E7%8A%B6%E6%80%81%E5%90%8E-%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">3.3.3.3. 收到configured状态后, 开启网络共享</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-3-1-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%BF%80%E6%B4%BB%E7%AD%89"><span class="nav-number">3.3.3.3.1.</span> <span class="nav-text">3.3.3.3.1. 网络配置激活等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-3-2-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86"><span class="nav-number">3.3.3.3.2.</span> <span class="nav-text">3.3.3.3.2. 涉及到的网络知识</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Usb-pc-share-pc%E4%BA%92%E8%81%94%E7%BD%91"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. Usb pc-share pc互联网</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liguang.zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liguang.zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VrGRp2q7WwXjxsCNmlDIZYbC-gzGzoHsz',
      appKey     : 'JgMXmmB7yKQf2zm80TaBp3JT',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
